@&#MAIN-TITLE@&#Space subdivision to speed-up convex hull construction in E3
            

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Algorithm for computing the convex hull of a set of points in E3 we are proposed.


                        
                        
                           
                           The algorithm is based on spherical space subdivision.


                        
                        
                           
                           The algorithm eliminates as many input points as possible before the convex hull calculation.


                        
                        
                           
                           Experimental results show that the proposed algorithm achieves a better time complexity in comparison with other algorithms in E3.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Convex hull

Space subdivision

Points reduction

Points distribution

Approximated angle

Initial convex polyhedron

@&#ABSTRACT@&#


               
               
                  Convex hulls are fundamental geometric tools used in a number of algorithms. This paper presents a fast, simple to implement and robust Smart Convex Hull (S-CH) algorithm for computing the convex hull of a set of points in E
                     3. This algorithm is based on “spherical” space subdivision. The main idea of the S-CH algorithm is to eliminate as many input points as possible before the convex hull construction. The experimental results show that only a very small number of points are used for the final convex hull calculation. Experiments made also proved that the proposed S-CH algorithm achieves a better time complexity in comparison with other algorithms in E
                     3.
               
            

@&#INTRODUCTION@&#

A convex hull is a fundamental construction not only in computational geometry and mathematics. It has numerous applications in various fields such as collision detection, mesh generation, shape analysis, cluster analysis, metallurgy, crystallography, cartography, image processing, sphere packing and point location. There are many other problems which can be reduced to the convex hull, e.g. halfspace intersection, Delaunay triangulation, Voronoi diagram, etc. Fast convex hull algorithms are useful for interactive applications, such as collision detection in computer games and path planning for robotics in dynamic environments.

A subset 
                        
                           S
                           ⊆
                           
                              R
                              3
                           
                        
                      is convex if and only if for any two points 
                        p, q
                      ∈ S the line segment with endpoints 
                        p
                      and 
                        q
                      is contained in S. The convex hull 
                        
                           C
                           H
                           (
                           S
                           )
                        
                      of a set S is the smallest convex set containing S. The convex hull of a set of points P is a convex polyhedron with vertices in P.

Many algorithms for calculation of the convex hull in 3D have been developed over the last several decades. Chand and Kapur [1] developed the Gift Wrapping algorithm, and Preparata and Hong [2] developed a recursive algorithm, which is based on Divide & Conquer. Clarkson and Shor [3] introduced an incremental insertion algorithm, where the points are processed one by one with respect to the currently constructed convex hull. Barber et al. [4] developed an efficient convex hull algorithm, which is called QuickHull. Hybrid algorithm, which is based on QuickHull and Gift Wrapping algorithms, is presented in [9]. The time complexity of some of the convex hull algorithms is presented in Table 1.
                  

Several parallel algorithms for convex hull construction were proposed. Chow [12] presented a parallel convex hull algorithm that runs at O(log3
                     n) time complexity. Amato and Preparata [13] designed an O(log2
                     n) time algorithm using n processors, where n is the number of input points. Reif and Sen [14] proposed a randomized algorithm for three dimensional convex hulls that runs at O(log  n) time using a Divide & Conquer approach on O(n) processors. Amato et al. [15] gave a deterministic O(log3 
                     n) time algorithm for a convex hull in Rd
                      using 
                        
                           O
                           (
                           
                              n
                              log
                              
                              n
                              +
                              
                                 n
                                 
                                    d
                                    /
                                    2
                                 
                              
                           
                           )
                        
                      work. Gupta and Sen [11] proposed a fast parallel convex hull algorithm that is output-size sensitive.

There are several convex hull algorithms modified for GPU applications. Gao et al. [17] developed a two-phase convex hull algorithm in three dimensions that runs on the GPU. Stein et al. [10] proposed a parallel algorithm based on QuickHull approach.

Other algorithms are based on a probabilistic approach [18]. Precision of convex hull algorithm with regard to physical floating point representation is solved as well, e.g. in [16].

In this section, we introduce a new Smart Convex Hull (S-CH) algorithm based on space subdivision for construction of the convex hull in E3. The main idea of this algorithm is to eliminate as many input points as possible using an algorithm with O(N) complexity based on space subdivision, and a ``standard'' convex hull algorithm with O(nlog n) is used for the remaining points, where n ≪ N. We use “spherical” space subdivision based on 3D sectors for efficient elimination of points not contributing to the final convex hull.

This section is organized as follows. Section 2.1 presents the first step of the S-CH algorithm, which is an inner convex polyhedron construction followed by the location of points inside the initial convex polyhedron. In Section 2.2, we describe how to perform the division of points into non-overlapping 3D pyramidal shape sectors.
Section 2.3 presents reduction of the suspicious points. The calculation of a convex hull from the selected points with a standard convex hull algorithm is made in Section 2.4.
                     
                  

At the beginning of the proposed S-CH algorithm, we need to find the extremal points in all axes, i.e. points with maximum and minimum x, y or z coordinates. The time complexity of this step is O(N). For our purpose, we do not need the exact extremal points, because extremal points close enough are sufficient. This means that we do not have to search extremes through all the input points, but we can search only random sample points. According to experiments made, approx. 10% of all points are sufficient. This simplification does not cause any problems for future calculations and we save computational time as well and the complexity of this step is O(N) only. Therefore, we generally get six distinct extremal points or less.

Now we can create a convex polyhedron using these points, see Fig. 1. Note that the extremal points are determined using the above presented estimation. We assume that the volume of the final object is nonzero, so the convex polyhedron will not be degenerated. One very important property of this polyhedron is that any point lying inside cannot be a point on the convex hull. Thus, we can perform a fast and simple initial test for a point inside/outside the polyhedron and discard many points.

The location test of a point inside a polyhedron can be performed as follows. Each face of the polyhedron is an oriented plane with a normal vector oriented outside of the polyhedron. Then we can calculate:

                           
                              (1)
                              
                                 
                                    
                                       F
                                       i
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       a
                                       i
                                    
                                    x
                                    +
                                    
                                       b
                                       i
                                    
                                    y
                                    +
                                    
                                       c
                                       i
                                    
                                    z
                                    +
                                    
                                       d
                                       i
                                    
                                    =
                                    
                                       n
                                       i
                                       T
                                    
                                    x
                                    +
                                    
                                       d
                                       i
                                    
                                    =
                                    0
                                    ,
                                 
                              
                           
                        where 
                           x
                         is a point and 
                           
                              
                                 F
                                 i
                              
                              
                                 (
                                 x
                                 )
                              
                              =
                              0
                           
                         is the implicit equation of a plane with index i having the normal vector 
                           
                              
                                 n
                                 i
                              
                              =
                              
                                 (
                                 
                                    
                                       a
                                       i
                                    
                                    ,
                                    
                                       b
                                       i
                                    
                                    ,
                                    
                                       c
                                       i
                                    
                                 
                                 )
                              
                           
                        . If Fi
                        (
                           x
                        ) < 0 for at least one 
                           
                              i
                              
                              ∈
                              {
                              
                                 0
                                 ,
                                 1
                                 ,
                                 …
                                 ,
                                 
                                 7
                              
                              }
                              ,
                           
                         then point 
                           x
                         lies outside of the polyhedron and has to be further processed. Otherwise, point 
                           x
                         lies inside of the polyhedron and can be eliminated.

In the second step of the S-CH algorithm, only the points, which lie outside of the initial polyhedron, will be further processed. Firstly, we perform the division of 3D space into several non-overlapping “pyramidal shape” sectors, i.e. we are using an “approximated spherical” subdivision. A center point and both angles (azimuth φ and zenith θ) are used in this subdivision. The center point 
                           C
                         is defined as the average of all vertices of the initial polyhedron.

Division of space can be performed as a uniform spherical subdivision in both angles, where azimuth φ ∈ [0, 2π) and zenith θ ∈ [0, π]. However, using this, we would have to calculate the exact angles and, moreover, an explosion of small and singular triangles would occur at the both poles. Therefore, we use a simplified calculation of approximated angle. As a result of this simplification, the sectors are not uniformly distributed in the spherical coordinate space, but are uniformly distributed on the faces of a cube, see Fig. 2
                        . Now, when calculating the azimuth and zenith, we have to locate the exact third of the octant, where the point is located and then calculate the intersection with the given face. Calculation of the intersection is easy, because all faces are axes aligned, i.e. 
                           
                              x
                              =
                              ±
                              1
                           
                         or 
                           
                              y
                              =
                              ±
                              1
                           
                         or 
                           
                              z
                              =
                              ±
                              1
                           
                        . Finally, we have to determine a table of neighbors for each sector. Note that the neighboring sector can lie on another face of the cube. This means that adjacency of sectors can be determined across the edge of a cube or the vertex of a cube.

Now we are able to calculate the exact index of a sector to which the given point belongs.

For each sector with index i, one maximal point 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         is determined. This point equals a point where is a maximum distance between the center point 
                           C
                         and all points in a sector. The initial points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         are lying on the faces of the initial polyhedron. These points can be calculated as an intersection point of the axis of a sector and the face of the initial polyhedron.

For each new point we have to check whether the distance from this point to the center point 
                           C
                         is greater than the distance from 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         to the center point 
                           C
                        . If this is true, then we have to replace point 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         with a processed point, add this point into the sector with index i and recalculate the test planes, see Fig. 3. Otherwise we continue with the next step.

In the next step, we check whether the processed point lies over or under the test planes.

Firstly, we determine the projection of the actual point to the face of the unit cube. Then we can compare coordinates of this projection with the projection of maximal point 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         and based on the result, we choose one of four options, see Fig. 4. Now we have to use the five planes which are defined by maximal points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         of the actual sector and neighboring sectors (hatched green) and perform a test for a point over/under the plane. If the point is under all five planes, we can discard it, because such a point cannot be part of the convex hull. Otherwise we add this point into the sector with index i.

We can gain some extra speed-up if the input dataset is pre-sorted according to the distance from the center point 
                           C
                        . In such a case we start by processing the farthest points from the input dataset. It leads to fast determination of maximal points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         and more points from the input dataset can be eliminated. Moreover, the next step, which is described in Section 2.3, does not need be performed.

The pre-sorted input dataset can speed-up the reduction steps. However, the sorting algorithms have the time complexity O(N log  N), which is higher than the time complexity of reduction steps O(N). Therefore, it is not beneficial to sort the input dataset.
                     

We have already divided all suspicious points into sectors. We gave points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         some initial values before starting to divide points into non-overlapping sectors and we used these points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         to check whether to add or eliminate a point. Values of points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                         have changed during the division process; hence we have to recheck all suspicious points using the final values of points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                        . We minimize the number of suspicious points, which are input for the final convex hull construction, using this step. Final sets of suspicious points for input datasets with different distributions of points are shown in Fig. 5.
                        
                        
                     

It should be noted that the reduction test eliminates the vast majority of given points. In case that the majority of points are close to the surface of the corresponding convex hull then the performance of reduction steps will decreases as only few points will be reduced.

After performing the previous steps, we use any known algorithm for calculation of the convex hull. The set of input points for this algorithm equals suspicious points. The number of suspicious points is extremely low in comparison of the number of the original points; thus the time needed for determining the convex hull is insignificant compared to the time needed for reduction of the original input points. Therefore, this step is more or less independent of the choice of a convex hull algorithm. In our approach we used the library MIConvexHull,
                           1
                        
                        
                           1
                           This library is available at https://miconvexhull.codeplex.com/.
                         which is based on the QuickHull algorithm.

QuickHull uses a Divide & Conquer approach. This algorithm performs the following steps:

                           
                              1.
                              Find three points (for example, points with minimum and maximum x coordinates and a point with a minimum y coordinate) which are bound to be part of the convex hull.

Divide the set into two subsets of points by a plane formed by the three points. This step will be processed recursively.

On one side of the plane, determine the point with the maximum distance from the plane. The three points found before along with this one form a pyramid.

In the next step, the points lying inside of the pyramid can be ignored.

Repeat the previous two steps on the three planes formed by the pyramid.

Repeat this procedure until no points are left. Then the recursion has come to an end.

It can be seen that the S-CH algorithm is quite simple. In the following experimental results will be presented.

@&#EXPERIMENTAL RESULTS@&#

The proposed S-CH algorithm has been implemented in C# using .Net Framework 4.5 and tested on data sets using a PC with the following configuration:

                        
                           •
                           CPU: Intel® Core™ i7-2600 (4 × 3, 40 GHz).

Memory: 16GB RAM

Operating system Microsoft Windows 7, 64 bits

The proposed S-CH algorithm has been tested using different 3D datasets. These datasets have different types of distributions of points. For experiments, we used well-known distributions such as randomly distributed uniform points in a unit sphere, uniform points in a unit cube, points lying on a unit sphere or points with a Gaussian distribution. Other distributions used were Halton points and Gauss ring points, which are described in the following text. Furthermore, we describe how to generate uniform spherical data.

For generating uniform spherical points, spherical coordinates cannot be used, because these coordinates cause the points to be concentrated around poles. Therefore, we use the following approach to generate spherical points.

First, we generate a point 
                              P
                            lying in a cube, which represents an axis-aligned bounding box for a unit sphere, and determine the Euclidean norm of this point 
                              P
                           . If 
                              P
                            > 1, then we return to the start. Otherwise we normalize point 
                              P
                           . Finally, we multiply this point by the required radius. The value of a radius can be either the same for all points (points on the sphere) or randomly generated for each point.

Construction of a Halton sequence is based on a deterministic method. This sequence generates well-spaced “draws” points from the interval [0, 1]. The sequence uses a prime number as its base and is constructed based on finer and finer prime-based divisions of sub-intervals of the unit interval. The Halton sequence [8] can be described by the following recurrence formula:

                              
                                 (2)
                                 
                                    
                                       Halton
                                       
                                          
                                             (
                                             p
                                             )
                                          
                                          k
                                       
                                       =
                                       
                                          ∑
                                          
                                             i
                                             =
                                             0
                                          
                                          
                                             
                                                log
                                                p
                                             
                                             k
                                          
                                       
                                       
                                          1
                                          
                                             p
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                       
                                       
                                          (
                                          
                                             
                                                k
                                                
                                                   p
                                                   i
                                                
                                             
                                             
                                                
                                                mod
                                                
                                             
                                             p
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where p is the prime number and k is the index of the calculated element.

For the 3D space, subsequent prime numbers are used as a base. In our test, we used {2, 3, 5} for the Halton sequence and we got a sequence of points in a unit cube:

                              
                                 (3)
                                 
                                    
                                       
                                          
                                             
                                                Halton
                                                (
                                                
                                                   2
                                                   ,
                                                   3
                                                   ,
                                                   5
                                                
                                                )
                                                
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                
                                                   {
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            1
                                                            2
                                                         
                                                         ,
                                                         
                                                            1
                                                            3
                                                         
                                                         ,
                                                         
                                                            1
                                                            5
                                                         
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            1
                                                            4
                                                         
                                                         ,
                                                         
                                                            2
                                                            3
                                                         
                                                         ,
                                                         
                                                            2
                                                            5
                                                         
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                   
                                                      (
                                                      
                                                         
                                                            3
                                                            4
                                                         
                                                         ,
                                                         
                                                            1
                                                            9
                                                         
                                                         ,
                                                         
                                                            3
                                                            5
                                                         
                                                      
                                                      )
                                                   
                                                   ,
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         1
                                                         8
                                                      
                                                      ,
                                                      
                                                         4
                                                         9
                                                      
                                                      ,
                                                      
                                                         4
                                                         5
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                
                                                
                                                   (
                                                   
                                                      
                                                         5
                                                         8
                                                      
                                                      ,
                                                      
                                                         7
                                                         9
                                                      
                                                      ,
                                                      
                                                         1
                                                         25
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                
                                                   (
                                                   
                                                      
                                                         3
                                                         8
                                                      
                                                      ,
                                                      
                                                         2
                                                         9
                                                      
                                                      ,
                                                      
                                                         6
                                                         25
                                                      
                                                   
                                                   )
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         7
                                                         8
                                                      
                                                      ,
                                                      
                                                         5
                                                         9
                                                      
                                                      ,
                                                      
                                                         11
                                                         25
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                
                                                   (
                                                   
                                                      
                                                         1
                                                         16
                                                      
                                                      ,
                                                      
                                                         8
                                                         9
                                                      
                                                      ,
                                                      
                                                         16
                                                         25
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                
                                                
                                                   (
                                                   
                                                      
                                                         9
                                                         16
                                                      
                                                      ,
                                                      
                                                         1
                                                         27
                                                      
                                                      ,
                                                      
                                                         21
                                                         25
                                                      
                                                   
                                                   )
                                                
                                                ,
                                                …
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Visualization of the dataset with 104 points of the Halton sequence from (3) can be seen in Fig. 6
                           . We can see that the Halton sequence in 3D space covers this space more evenly than randomly distributed uniform points in the unit cube.

Construction of Gauss ring points in 3D space is based on the method for generating spherical points which is described above. For each point, the radius is determined using the following equation:

                              
                                 (4)
                                 
                                    
                                       r
                                       =
                                       0.5
                                       +
                                       0.5
                                       
                                       ·
                                       sign
                                       ·
                                       ran
                                       
                                          d
                                          Gauss
                                       
                                       ,
                                    
                                 
                              
                           where sign is a randomly generated number from set 
                              
                                 {
                                 
                                    −
                                    1
                                    ,
                                    1
                                 
                                 }
                              
                            and randGauss is a randomly generated number with Gauss distribution from interval [0, ∞).

Visualization of the dataset with 104 Gauss ring points can be seen in Fig. 7
                           
                           . We can see that this dataset consists of a large set of points, which are close to the sphere, and a small set of points, which are far from this sphere.

Some samples of convex hulls for datasets with a different distribution of points, which consist of 104 points, are shown in Fig. 8.
                        
                        
                     

It can be seen, the convex hull of points on a sphere or points with uniform distribution in a sphere has a spherical shape. Moreover, these convex hulls contain the majority of points. The convex hull of points with uniform distribution in a cube or Halton points is a box-shaped object. The random shape has a convex hull of Gauss points or Gauss ring points.

In the proposed approach, the main step is the division of the input set of points into non-overlapping sectors. Therefore, we need know an estimation of the optimal number of divisions, which should depend on the distribution of points. Consequently, we have to determine it for each type of input points separately.

We measured the time performance of the convex hull for different distributions of points, different numbers of points and different numbers of divisions. Measurement for 107 points is presented in Graph 1. For all tested distributions of input points, except points on a sphere, we can see that the time performance decreases with the increasing number of divisions until the optimal number of divisions is achieved. After that time, the complexity increases with the increasing number of divisions. The situation is different for points on a sphere. Based on Graph 1(f), it can be seen that the time complexity decreases with the increasing number of divisions. This is due to the fact that points are partially organized by the first step of the S-CH algorithm, and thus the construction of the final convex hull is accelerated. The speed up is gained due to better cache memory usage, more explained in [19].

Evaluating experimental results for different numbers of input points, including results from Graph 1, i.e. 105, 
                           
                              
                                 10
                              
                              ·
                              
                                 10
                                 5
                              
                           
                        , 106, 
                           
                              
                                 10
                              
                              ·
                              
                                 10
                                 6
                              
                           
                        , 107 and 
                           
                              
                                 10
                              
                              ·
                              
                                 10
                                 7
                              
                           
                        , we came to the following conclusion.

The expected optimal number of the divisions is directly proportional to number of points lying on the convex hull. If the user knows properties of the input dataset, then the number of divisions can be determined more precisely. The optimal number of divisions, which is almost the same for all numbers of input points, is shown in Graph 2.

In order to assess the effectiveness of the proposed algorithm, we need to know what proportion of input points to eliminate in each step of our algorithm, the size of the set of suspicious points and the number of points that lie on the convex hull. All these values are given relative to the size of the input dataset. Measurements were performed for different numbers of input points and different types of point distributions. The results of these experiments are in Tables 2–6.
                     

In Table 2 we can see the percentage of points eliminated by the initial polyhedron. It is obvious that the most points are eliminated for the Gauss distribution points. This is due to the fact that most of the Gauss points lie around the center. The number of points eliminated for Gauss ring points by the initial polyhedron is dependent on the total number of input points. From this, we can deduce, consistent with the Gauss ring distribution, that for smaller inputs, it may not be always possible to choose the ideal initial polyhedron. The results for the uniform distribution of points in a cube and Halton points are consistent with the theoretical estimate. (The theoretical estimate is obtained as the quotient of two volumes. The dividend is a volume of the ideal initial polyhedron and the divisor is a bounding volume for the input dataset.) The number of eliminated points is larger than the theoretical estimate for points with a uniform distribution inside a sphere.

The percentage of points eliminated by the testing planes can be seen in Table 3. The most points are reduced for Halton points and for points with uniform distribution in a cube. For all tested distributions of input points, except points on a sphere, we can see that almost all input points are discarded after these two steps of the S-CH algorithm.

The percentage of points eliminated by reduction of suspicious points can be seen in Table 4. The minimal number of points is discarded by this step for all tested distributions of input points. But there exist distributions of points when this step is important, e.g. points forming a spiral. We can see non-zero values for points on a sphere. This is due to the elimination of initial points 
                           
                              R
                              i
                              
                                 m
                                 a
                                 x
                              
                           
                        , which were artificially added at the beginning (see Section 2.2) and lying on the faces of the initial polyhedron.

The number of suspicious points for different numbers of input points and for different types of distributions is shown in Table 5. These points are used for the final calculation of the convex hull. It can be seen that for all tested distributions of points, except points on a sphere, the number of suspicious points is extremely low compared to the number of the original points.


                        Table 6 presents the percentage of points lying on the final convex hull. Convex hulls of points with Gauss ring distribution, Gauss distribution, Halton distribution or uniform distribution in a cube are determined by the few remaining points. More points lie on the convex hull of uniform points in a sphere. The convex hull of points on a sphere should be determined by all these points, but the experimental results do not correspond to this assumption. This is due to the floating point precision of calculation.

Moreover, we can see the percentage of suspicious points, which lie on the convex hull, in Graph 3.


                        
                        
                        
                        
                        
                        In this section, we focus on running times for the calculation of a convex hull using our proposed S-CH algorithm. Running times were measured for different numbers of input points with different distributions of points. Measurements were performed many times and average running times, calculated from the measured results, are in Tables 7–9
                        
                        
                        ; we can see these running times in Graph 4
                        
                        .

It can be seen that the best time performance is for datasets with the Gaussian distribution. These datasets are followed by Gauss ring points. This is expected behavior because most of the points using one of these distributions lie inside the initial polyhedron. Therefore, there are only a few points on the convex hull. The time performance for Halton points and for uniform points in a cube is similar. The running times for points with uniform distribution inside a sphere are a bit slower than the running times for uniform points in a cube. The worst time performance was obtained for points, which lie on a sphere. This is again expected behavior because there are no points for elimination during the first phase and therefore the convex hull calculation has to be done from the whole dataset.

You can see the best average running time for the optimal number of divisions for each distributions of points and different numbers of input points in Table 9.
                     

Moreover, we were performed the measurements for different real-world examples, see Fig. 9. Average running times for S-CH algorithm and QuickHull algorithm are in Table 10. We can see that our proposed S-CH algorithm give for dataset of MRI of brain better time performance than QuickHull algorithm. Contrary, time performance of QuickHull algorithm is better than S-CH algorithm for dataset of laser scanned bunny.

We compared the proposed S-CH algorithm with the incremental insertion algorithm and QuickHull algorithm, whose expected time complexity is O(Nlog  N), and with the Chan's algorithm, which expected time complexity is O(Nlog  h), where N is the number of input points and h is the number of points on the output convex hull. It should be noted that we use the library MIConvexHull, which is implemented in C# using .Net Framework 4.5, for measurements of the QuickHull algorithm. The results for the incremental insertion algorithm are based on the use of the ratio of the Randomized Incremental algorithm to QuickHull. This ratio was obtained from measurements for a C implementation of both algorithms.

Running times were measured for different numbers of input points with uniform distribution inside a sphere. The resultant speed-up of the S-CH algorithm with respect to the QuickHull algorithm, Chan's algorithm and Randomized Incremental algorithm can be seen in Graph 5.
                        
                     

It can be seen that the proposed S-CH algorithm clearly outperforms “standard” convex hull algorithms. The graph shows that speed-up grows slowly from 107 points. This is due to swapping.

@&#CONCLUSION@&#

A new fast convex hull algorithm in E
                     3 has been presented. The S-CH algorithm uses a space division technique. It is robust, as we do not use any angle calculations, and can process a large number of points as well as different distributions of points. Advantages of the S-CH algorithm are simple implementation, robustness and the use of almost any known algorithm for the final calculation of the convex hull as very efficient filtering, very small number of points are left for the final processing, i.e. for the final convex hull construction. Therefore the final efficiency is not sensitive to the convex hull algorithm properties. Thus, any brute force algorithm, which is easy to implement and robust, can also be used without significant influence to the algorithm efficiency. We do not assume any special order of input points. Otherwise, there is a possibility for a modification to increase the effectiveness of the algorithm.

For future work, the S-CH algorithm can be easily parallelized, as most of the steps are independent, and for large datasets influence of caching and data transfer should be explored more deeply.

@&#ACKNOWLEDGMENTS@&#

The authors would like to thank their colleagues at the University of West Bohemia, Plzen, for their comments and suggestions, and anonymous reviewers for their valuable comments and hints provided. The research was supported by MSMT CR projects LH12181 and SGS 2013-029.

@&#REFERENCES@&#

