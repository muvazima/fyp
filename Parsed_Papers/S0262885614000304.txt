@&#MAIN-TITLE@&#A unified approach to the recognition of complex actions from sequences of zone-crossings

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a method for the recognition of complex actions in a unified way.


                        
                        
                           
                           We encode simple action HMMs within the stochastic grammar that models complex actions.


                        
                        
                           
                           As input our method receives a sequence of crossings of tracks through a set of zones.


                        
                        
                           
                           We evaluate our method in a threat recognition setting.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Threat recognition

Complex actions

Temporal relations

Multi-threaded parsing

Stochastic parsing

@&#ABSTRACT@&#


               
               
                  We present a method for the recognition of complex actions. Our method combines automatic learning of simple actions and manual definition of complex actions in a single grammar. Contrary to the general trend in complex action recognition that consists in dividing recognition into two stages, our method performs recognition of simple and complex actions in a unified way. This is performed by encoding simple action HMMs within the stochastic grammar that models complex actions. This unified approach enables a more effective influence of the higher activity layers into the recognition of simple actions which leads to a substantial improvement in the classification of complex actions. We consider the recognition of complex actions based on person transits between areas in the scene. As input, our method receives crossings of tracks along a set of zones which are derived using unsupervised learning of the movement patterns of the objects in the scene. We evaluate our method on a large dataset showing normal, suspicious and threat behaviour on a parking lot. Experiments show an improvement of ~30% in the recognition of both high-level scenarios and their composing simple actions with respect to a two-stage approach. Experiments with synthetic noise simulating the most common tracking failures show that our method only experiences a limited decrease in performance when moderate amounts of noise are added.
               
            

@&#INTRODUCTION@&#

Recognition of complex actions such as having a meal or checking the vulnerabilities of a truck is a challenging task with applications in fields such as surveillance and monitoring of activities of daily living (ADL). Complex actions are composed of one or more threads of simple actions with specific temporal arrangements. Simple actions such as run, walk, crouch or bend are aimed at providing an instantaneous behavioural description. There exist a number of methods in the literature for the recognition of simple actions [1]. Their relatively short temporal span and stability make them suitable to be modelled from appearance using few abstraction layers in the form of discriminant representations [2–5], state-based models [6–8] or a combination of both.

Complex actions may involve a single actor for a long period of time such as having a meal or involve several actors simultaneously such as checking the vulnerabilities of a parked truck where the threatening action must be carried out after the truck driver has left the vehicle. Modelling of complex actions is usually done by breaking the complex action into sequences or sets of simple actions. Hierarchical approaches are very popular for this kind of problems because of their high descriptive power achieved by adding new abstraction layers on top of previously defined ones. Some examples of these approaches are Hierarchical Hidden Markov Models (HHMM) [9–12] and Syntactic methods [13–18].

Many authors recognised the need to learn the simple actions, by attribute learning [19–21] or using topic models based upon Latent Dirichlet Allocation (LDA) or Hierarchical Dirichlet Process (HDP) [22–24], where Hospedales [25] also included explicit knowledge of rare event using a weakly supervised joint topic model. In this paper we address this need to learn the simple actions by matching the sensor data domain to a semantically higher level using zones, which are defined by data driven clustering. In contrast to the approaches mentioned before we favour using tracks over lower level image features as we expect that tracks provide longer term information needed to recognise longer term threat models.

In the present paper, we address the problem of recognition of complex actions using syntactic approaches and present an application to the recognition of threats in a parking lot. We tackle the problem of sparsity of training data by allowing manual definition of the complex actions. Manual definition of the structure of the activity in the surveillance setting has been previously highlighted by other authors [15,26,16,27–30].

We present an approach for the recognition of complex actions. Our method is inspired by the recent method by Zhang et al. [31]. They propose multi-threaded parsing to recognise multi-threaded complex actions. In their approach simple actions are deduced from trajectories between common start and end points. In our case we use more advanced simple action detectors based on HMMs that allow one to recognise more sophisticated behaviours such as loitering and walking around. Our approach gets as input sequences of zone-crossings learned in an unsupervised way from the trajectories of detected objects in the scene. The novelty of our method is that we integrate statistical learning of simple actions with manual specification of complex actions in a single grammar by encoding simple action HMMs as stochastic grammar rules. Recognition is carried out in a unique parsing procedure. Similar approaches divide this problem into two stages: In the first stage simple actions are detected which are then passed to a second stage that recognises complex actions. Our motivation for using a unified approach is that optimal detections at the simple action level are not necessarily optimal at the complex level. Therefore, our unified approach leads to a more effective top-down influence which allows to select simple action detections more relevant at the complex action layer. We provide experimental evaluation in a threat recognition dataset and show that the proposed method outperforms in terms of recognition accuracy to a similar method that divides recognition into two stages. Fig. 1
                      shows an overview of our method.

The outline of the paper is as follows: in Section 2 we describe some related work. In Section 3 we describe the problem that we aim at solving. Section 4 describes the feature extraction process. Section 5 covers the process of learning statistical models for simple actions. In Section 6 we show how simple actions models and complex activity rules are both put together in the form of a grammar. Section 7 contains details of the parsing procedure used for recognition. Section 8 presents the experimental validation of our approach for the recognition of threats in a parking lot. Finally, Section 9 gives some concluding remarks.

@&#RELATED WORK@&#

Aggarwal et al. presented a review of human activity analysis methods including both single-layered and hierarchical approaches for recognition of simple and complex actions [32].

Coupled Hidden Markov Models (CHMM) are specially designed to model concurrent activities. They have been applied in the surveillance setting to model interactions and group activities [8,7]. The main drawback is that they need some training data in order to model the relationships between concurrent activities. Therefore, they do not allow for manual specification of the structure of the activities in case there is not enough training data.

There are also a number of related approaches for the recognition of activities of daily living (ADL). Hamid et al. used event n-grams, a type of bag-of-words representation for representing complex actions [33]. In their bag-of-words representation temporal relations are only considered among sequences of n primitive actions. Rohrbach et al. presented an approach for learning and recognition of composite cooking activities [21]. In order to alleviate the problem of sparsity of training data, they devised a method to augment the training data through the use of script annotations. Even though these methods perform well recognizing ADL they lack of the complex assessment of temporal relations essential for to threat recognition which is used in our proposed method.

Hierarchical Hidden Markov Models (HHMM) have been used for modelling complex actions [9]. They use the principle of decomposition of the problem into successive abstraction layers, the more global action dynamics being captured by the higher layers. Later on, approaches have been presented aiming at introducing more efficiency by sharing common substructures [11]. Applications to recognition of complex indoor activities have been presented [12]. Among the advantages of HHMM is that both learning and recognition are done in a unified way facilitating the flow of information among all the levels of the hierarchy. Nevertheless, they are not suited at modelling concurrent activities such as those involving more than one thread of actions. Another limitation is that some training data are required in order to set up the model parameters for the complex action models, whereas our method only requires training data for the simple actions which is usually easier to gather.

Other layered approaches have been presented for the recognition of complex actions. Duong et al. presented a two-layered approach for recognition of ADL [34]. The bottom layer models atomic actions and the upper layer represents high-level activities composed of sequences of atomic actions. Khoshhal et al. presented a two-stage approach for human behaviour analysis around an ATM [35]. Bayesian Networks are used at the first level to infer basic movement primitives which are fed to an HMM to recognise behaviours by evaluating sequences of basic movements. Recently, Kooij et al. presented an approach for unsupervised discovery of behaviours by jointly clustering sequences of actions [24]. They presented experiments in a surveillance setting. The drawbacks of layered approaches are that they usually lack a flow of information allowing one to use global knowledge in the higher layer to drive recognition in the lower layer. Nater et al. presented a hierarchical approach for unsupervised behaviour learning and abnormality detection with the distinguished property of allowing for top-down influence of behaviour models towards the tracking module [36]. Actions are defined as trajectories within a hierarchy of silhouettes built by agglomerative clustering on the silhouette data. One drawback of the aforementioned approaches for threat recognition is that they do not allow for manual specification of behaviours. This is an important capability because often many properties of complex actions are known a priori.

Manual specification of finite-state machines has been successfully used for the recognition of complex actions in the surveillance setting. Several authors used hand-crafted state machines to recognise complex behaviours [26,28,29,37]. One feature of these approaches is that transitions between states are decided based on logical rather than probabilistic measurements. This is a limitation since it forces decision based on thresholds instead of allowing more robust probabilistic reasoning. Moreover, the whole model is hand-crafted not allowing to apply statistical learning for the simple actions. In a slightly different approach Mahajan et al. presented an approach to learn activity patterns with a hierarchy of finite state machines [38].

Syntactic methods are specially suited for modelling activities with hierarchical organization, which is usually the case of complex actions. Models are represented by grammars. Ivanov and Bobick [13] presented an approach to recognise complex actions by parsing simple actions with a stochastic grammar [39]. The same authors presented a parsing approach for recognition of complex events in a parking lot [15]. Extensions to stochastic grammars have been proposed to deal with attributes [16] and multi-tasked activities [17]. Recently, it has been presented an approach for the recognition of long-term behaviours based on stochastic parsing [18]. It consists on a 2-stage model for the recognition of a limited set of indoor activities. Recognition of simple actions is based on a simple k-nearest-neighbours approach that would not allow to recognise actions such as loitering. Recognition of long-term behaviours is carried out with a single-threaded stochastic parser, which does not allow the method to recognise behaviours carried out by multiple actors or involving complex temporal relations.

In this section we explain the problem that we want to solve, in order to facilitate a better understanding of our work. We aim to recognise threats in a parking lot belonging to one of the following categories:
                        
                           •
                           
                              Stop for a meal shows normal behaviour of a truck driver going to the service area for a meal and going back to the truck


                              Stop for a meal with check shows the same as the previous one but the truck driver performs routinary checks for the integrity of the vehicle.

In Something is wrong, the behaviour of the truck driver reveals that something is wrong, yet no evidence of threatening behaviour is observed.


                              Potentially criminal behaviour shows threatening activity as e.g., an attempt to break into the truck or to intercept the truck driver.


                              Criminal behaviour shows explicit threats such as an attack


                     Fig. 2
                      shows an overview of the parking lot. There are some fixed elements in the scene which are: the truck, the truck parking area, the car parking area, the smoking area and the service area (depicted zones are only indicative for the reader).

These threats are examples of complex actions that can only be assessed looking at the whole clip. There are subtle threats, e.g., checking the truck and more explicit ones, e.g., aggression. Scenarios range from simple (one or two persons, empty scene) to complex (five persons, long trajectories).

In the following we provide the description of an example clip.
                        
                           T3.2: A car enters the scene and stops at the car parking area. The truck driver steps out. He walks to the service area. Person P0 steps out the car and walks to the truck parking area. P0 walks around the truck and looks at it. P0 returns to his car. The truck driver returns to his truck. The car leaves.
                     
                  


                     Fig. 3
                      shows two shots of typical actions in this scenario.

All the complex actions in this dataset cover large temporal spans (see Table 2 for information about the duration of each clip). The simplest scenarios involve a single actor whereas the most complex ones may involve up to 2 or 3 actors simultaneously. Moreover, there may eventually appear actors not involved in the main action of the clip. Therefore, in order to deal with this dataset, we require methods capable of recognizing actions with large temporal extents, involving multiple actors and which are robust to spurious observations.

We adopt a grammar-based approach to tackle with this problem. Consider for example the threat Potential thief checks truck after truck driver has gone to service area (PTcheckTafterTDgotoSA). We decompose this complex activity with the simpler ones Potential thief checks truck (PTcheckT) and Truck driver goes to service area (TDgotoSA). In the form of a grammar rule this would be:
                        
                           (1)
                           
                              
                                 PTcheckTafterTDgotoSA
                                 →
                                 TDgotoSA
                                 
                                    precedes
                                 
                                 PTcheckT
                                 
                                    pr
                                 
                              
                           
                        
                     where the left-hand side shows the symbol representing the threat and the right-hand side the composite sequence of simpler actions along with the temporal relations. At the end of the rule, between square brackets, we denote its prior probability.

Symbols in the right-hand side can be in turn further decomposed. For example, PTcheckT can be decomposed in Person goes to truck (PgotoT) and Person loiters nearby truck (PloitersnearT). Similarly, TDgotoSA can be decomposed in truck driver steps out from truck (TDstepoutT), truck driver goes from truck to service area (TDfromTtoSA) and truck driver enters service area (TDenterSA).
                        
                           (2)
                           
                              
                                 
                                    
                                       PTcheckT
                                       →
                                       PgotoT
                                       
                                          meets
                                       
                                       PloitersnearT
                                       
                                          pr
                                       
                                    
                                 
                                 
                                    
                                       TDgotoSA
                                       →
                                       TDstepoutT
                                       
                                          meets
                                       
                                       TDfromTtoSA
                                       
                                          meets
                                       
                                       TDenterSA
                                       
                                          pr
                                       
                                    
                                 
                              
                           
                        
                     
                  

Further decomposing the activities might introduce too much perception bias with the risk of not fitting the actual observation processes. That is why we leverage on statistical learning to derive rules of the lower levels.

We achieve complex activity recognition by first learning activity zones where mobiles evolve in the scene. In a second step, the simple action is characterised as a pattern of visited activity zones modelled through a Hidden Markov Model.

We interpret activity zones as those important areas on the observed scene where mobiles interact with other mobiles or perform behavioural changes. Such behavioural changes include: stop walking to meet someone, speed up walking or simply stand waiting. Remark that this information can be extracted from the analysis of the mobile speed profile.

The first task is thus to analyse the mobile speed profile and obtain those speed changing points. The second task is to cluster speed changing points to build the final activity zones. Finally we perform feature extraction by representing each track as a sequence of transitions through zones.

Let us consider the dataset X
                        ={x(n)}, n
                        =1…N made up of N tracks. Each track x in this dataset is defined as the set of points x
                        (n)
                        ={x
                        
                           i
                        
                        
                           n
                        
                        =(u,
                        v)
                           i
                        },
                        i
                        =1…|x
                        (n)| where (u, v)
                           i
                         is the mobile position on the ground on the i-th frame. Moreover, we establish t
                        (n)
                        ={t
                        
                           i
                        
                        (n)} corresponding to the timestamps of each frame and track.

In our application, u and v are time series vectors whose length is not equal for all objects as the time they spend in the scene is variable. The instantaneous speed for that mobile at point (u, v)
                           i
                         is 
                           
                              w
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   u
                                                   ˙
                                                
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                
                                                   v
                                                   ˙
                                                
                                                2
                                             
                                          
                                       
                                    
                                    
                                       
                                          1
                                          2
                                       
                                    
                                 
                              
                           
                        . The objective is then to detect those points of changing speed allowing to detect those important areas of the scene where behavioural interactions or changes occur.

The mobile object time series speed vector, w(t), is analysed in the frame of a multi-resolution analysis with a smoothing function, 
                           
                              
                                 ρ
                                 
                                    2
                                    s
                                 
                              
                              
                                 t
                              
                              =
                              ρ
                              
                                 
                                    
                                       2
                                       s
                                    
                                    t
                                 
                              
                           
                        , to be dilated at different scales s. We have employed in our Application a Haar wavelet, which is one of the most widespread in the literature. Without any dilation (s
                        =0). The Haar wavelet is defined as:
                           
                              
                                 
                                    ρ
                                    
                                       t
                                    
                                    =
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                                ⩽
                                                t
                                                <
                                                1
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In this frame, the approximation A of w(t) by ρ is such that A
                        
                           s
                           −1(w)=∫
                        w(t)ρ(2
                           s
                           −1(t
                        −
                        b))dt is a broader approximation of Asw; where b is a translation parameter spanning the time domain of w(t).

By analyzing the time series w at different resolutions, it is possible to smooth out small details at coarse resolutions; but track points associated with important speed changes are seen as sharp discontinuities present at several successive scales. We select those points where the discontinuities remain at the different analysed scales.

Activity zones are thus computed having as input the track speed changing points calculated as explained in last section. These points are first clustered by a fast partitioning algorithm such as the well-known Leader algorithm [40], allowing us to quickly create an initial set of zones Z
                           n
                        . In a second step the partition is corrected leading to the final activity zones. To correct the initial partition, different relationships between initial zones Z
                           n
                         are taken into account. Such relationships are set in a Soft Computing framework. We employ then fuzzy operators to combine these relationships.

For the first step, we employ thus the clustering Leader algorithm. It has the advantage to work on-line without needing to specify the number of clusters in advance. In this method, it is assumed that a threshold T is given. The algorithm constructs a partition of the input space (defining a set of clusters) and a leading representative for each cluster, so that every point in a cluster is within a distance T of the leading representative. The first point is assigned to a cluster. Then the next point is assigned to an existing cluster or defines a new cluster depending on the distance between the point and the cluster leading representative. The process is repeated until all input points are assigned to clusters.

In our application, when a point is designed as cluster leader (or leading representative), L, the cluster influential zone, Z
                              n
                           , is defined by a radial basis function (RBF) centred at the position L; and the belongingness of a new point p(u,v) to that zone is given by:
                              
                                 (3)
                                 
                                    
                                       
                                          Z
                                          n
                                       
                                       
                                          L
                                          p
                                       
                                       =
                                       ϕ
                                       
                                          L
                                          p
                                       
                                       =
                                       exp
                                       
                                          
                                             −
                                             
                                                
                                                   
                                                      
                                                         p
                                                         −
                                                         L
                                                      
                                                   
                                                   2
                                                
                                                
                                                   T
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The RBF function has a maximum of 1 when its input is p
                           =
                           L and thus acts as a similarity detector with decreasing values outputted whenever p strides away from L. An object element will be included into a cluster Zn
                            if Zn
                            (L, p)≥0.5; the cluster receptive field (hyper-sphere) is controlled by the learnt parameter T. We have set this parameter to the value T
                           =1.26 using the method suggested by [41], which we describe in the following section for completeness.

For a set of N points whose partition is known, an error function is established to calculate the divergence between the clustering induced partition and the ‘true’ partition. For a point pj
                            let L be the leader associated to this point in the calculated clustering structure; and M be the leader associated to the same point in the ‘true’ partition. The error function is defined as:
                              
                                 (4)
                                 
                                    
                                       E
                                       =
                                       
                                          1
                                          N
                                       
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             N
                                          
                                          
                                             
                                                E
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           where
                              
                                 (5)
                                 
                                    
                                       
                                          E
                                          j
                                       
                                       =
                                       ϕ
                                       
                                          L
                                          
                                             p
                                             j
                                          
                                       
                                       −
                                       ϕ
                                       
                                          M
                                          
                                             p
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        

An iterative gradient-descent method is employed to adjust T and minimise the error.
                              
                                 (6)
                                 
                                    
                                       T
                                       
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       T
                                       
                                          t
                                       
                                       −
                                       η
                                       
                                          
                                             δE
                                             
                                                t
                                             
                                          
                                          δT
                                       
                                    
                                 
                              
                           
                        

The threshold T is originally set to a large value (inducing a large partition error) and diminishes until convergence.

We find the final activity areas by merging similar initial zones Zn
                           . We look to establish fuzzy similarity relations between these different zones. On the end, new zones are given by the fulfilment of different relations. The first relation indicates if zone 
                              
                                 Z
                                 
                                    n
                                    i
                                 
                              
                            overlaps zone 
                              
                                 Z
                                 
                                    n
                                    j
                                 
                              
                           . This relation is defined as follows:
                              
                                 
                                    
                                       
                                          R
                                          
                                             1
                                             ij
                                          
                                       
                                    : Zone 
                                       
                                          Z
                                          
                                             n
                                             i
                                          
                                       
                                     overlaps Zone 
                                       
                                          Z
                                          
                                             n
                                             j
                                          
                                       
                                    
                                    
                                       
                                          (7)
                                          
                                             
                                                
                                                   R
                                                   
                                                      1
                                                      ij
                                                   
                                                
                                                =
                                                
                                                   
                                                      ∑
                                                      
                                                         k
                                                         =
                                                         1
                                                      
                                                      3
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                               
                                                                  p
                                                                  
                                                                     u
                                                                     v
                                                                  
                                                                  ∈
                                                                  
                                                                     
                                                                        Z
                                                                        
                                                                           n
                                                                           i
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                            
                                                               
                                                                  Z
                                                                  
                                                                     n
                                                                     j
                                                                  
                                                               
                                                               
                                                                  
                                                                     
                                                                        L
                                                                        j
                                                                     
                                                                     ,
                                                                     p
                                                                     
                                                                        u
                                                                        v
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 

That is, points (u, v) belonging to 
                                       
                                          Z
                                          
                                             n
                                             i
                                          
                                       
                                     centred at Li
                                     are tested to verify the overlap/similarity with 
                                       
                                          Z
                                          
                                             n
                                             j
                                          
                                       
                                    .

Similar relations that we have introduced are the following


                                    
                                       
                                          R
                                          
                                             2
                                             ij
                                          
                                       
                                    : zone 
                                       
                                          Z
                                          
                                             n
                                             i
                                          
                                       
                                     and zone 
                                       
                                          Z
                                          
                                             n
                                             j
                                          
                                       
                                     are destination zones for mobiles departing from any same activity zone 
                                       
                                          Z
                                          
                                             n
                                             k
                                          
                                       
                                    
                                 


                                    
                                       
                                          R
                                          
                                             3
                                             ij
                                          
                                       
                                    : zone 
                                       
                                          Z
                                          
                                             n
                                             i
                                          
                                       
                                     and zone 
                                       
                                          Z
                                          
                                             n
                                             j
                                          
                                       
                                     are origin zones for mobiles arriving to the same activity zone 
                                       
                                          Z
                                          
                                             n
                                             k
                                          
                                       
                                    
                                 


                                    
                                       
                                          R
                                          
                                             4
                                             ij
                                          
                                       
                                    : zone 
                                       
                                          Z
                                          
                                             n
                                             i
                                          
                                       
                                     and zone 
                                       
                                          Z
                                          
                                             n
                                             j
                                          
                                       
                                     have about the same number of detected mobiles stopping at the zone


                                    
                                       
                                          R
                                          
                                             5
                                             ij
                                          
                                       
                                    : zone 
                                       
                                          Z
                                          
                                             n
                                             i
                                          
                                       
                                     and zone 
                                       
                                          Z
                                          
                                             n
                                             j
                                          
                                       
                                     have about the same mobile interaction time. The mobile interaction time is the mean time a mobile spends in that zone.

All relations can be aggregated employing a soft computing aggregation operator
                              
                                 (8)
                                 
                                    
                                       R
                                       =
                                       
                                          R
                                          1
                                       
                                       ∩
                                       
                                          R
                                          2
                                       
                                       ∩
                                       
                                          R
                                          3
                                       
                                       ∩
                                       
                                          R
                                          4
                                       
                                       ∩
                                       
                                          R
                                          5
                                       
                                    
                                 
                              
                           
                        

In our application we employ a typical bounded product T-norm operator. Eq. (8) thus translates as:
                              
                                 (9)
                                 
                                    
                                       R
                                       =
                                       max
                                       
                                          
                                             0
                                             ,
                                             
                                                R
                                                1
                                             
                                             +
                                             
                                                R
                                                2
                                             
                                             +
                                             
                                                R
                                                3
                                             
                                             +
                                             
                                                R
                                                4
                                             
                                             +
                                             
                                                R
                                                5
                                             
                                             −
                                             4
                                          
                                       
                                    
                                 
                              
                           
                        

R is made transitive with:
                              
                                 (10)
                                 
                                    
                                       
                                          R
                                          T
                                       
                                       =
                                       
                                          max
                                          k
                                       
                                       
                                       min
                                       
                                          
                                             R
                                             
                                                
                                                   Z
                                                   
                                                      n
                                                      i
                                                   
                                                
                                                
                                                   Z
                                                   
                                                      n
                                                      k
                                                   
                                                
                                             
                                             ,
                                             R
                                             
                                                
                                                   Z
                                                   
                                                      n
                                                      k
                                                   
                                                
                                                
                                                   Z
                                                   
                                                      n
                                                      j
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           RT
                            then indicates the strength of the similarity between 
                              
                                 Z
                                 
                                    n
                                    i
                                 
                              
                            and 
                              
                                 Z
                                 
                                    n
                                    j
                                 
                              
                           . If we define a discrimination level α in the closed interval [0,1], an α
                           −
                           cut can be defined such that
                              
                                 (11)
                                 
                                    
                                       
                                          R
                                          T
                                       
                                       
                                          
                                             Z
                                             
                                                n
                                                i
                                             
                                          
                                          
                                             Z
                                             
                                                n
                                                j
                                             
                                          
                                       
                                       =
                                       1
                                       ⇔
                                       
                                          R
                                          T
                                       
                                       
                                          
                                             Z
                                             
                                                n
                                                i
                                             
                                          
                                          
                                             Z
                                             
                                                n
                                                j
                                             
                                          
                                       
                                       ⩾
                                       α
                                    
                                 
                              
                           
                        

From the classification point of view, R
                           
                              T
                           
                           
                              α
                            induces a new partition with a new set of clusters {ωj
                           } such that cluster ωj
                            is made of all initial zones 
                              
                                 Z
                                 
                                    n
                                    j
                                 
                              
                            which up to the alpha level fulfil the relations set above and can thus be merged to form a final activity zone.

Practically, the central point in ωj
                            clusters is calculated, and the final zones correspond to the Voronoi tessellations on those points (see Fig. 4
                           ).

From each track x(r) we extract the set of zone crossings as the features of that track.

Specifically, features for track x(r) are the set of zones crossed by the track along with the entering and exiting times. This is,
                           
                              (12)
                              
                                 
                                    
                                       Z
                                       
                                          r
                                       
                                    
                                    =
                                    
                                       
                                          
                                             z
                                             t
                                          
                                          
                                             τ
                                             t
                                             0
                                          
                                          
                                             τ
                                             t
                                             1
                                          
                                       
                                    
                                    ,
                                    t
                                    =
                                    1
                                    …
                                    T
                                    ,
                                 
                              
                           
                        where zt
                        
                        =
                        ωj
                         is the zone crossed by track r at time t, and τ
                        
                           t
                        
                        0 and τ
                        
                           t
                        
                        1 are the entering time and the exiting time, respectively.

When an object is moving along the boundary of a zone many spurious zone-crossings may be triggered in short time. In order to cut irrelevant information and speed-up the processing, we filter out zone crossings below a certain time threshold ρ. Therefore, the final list of zone crossings is defined as,
                           
                              (13)
                              
                                 
                                    
                                       Z
                                       
                                          r
                                       
                                    
                                    =
                                    
                                       
                                          
                                             z
                                             t
                                          
                                          
                                             τ
                                             t
                                             0
                                          
                                          
                                             τ
                                             t
                                             1
                                          
                                       
                                    
                                    −
                                    
                                       
                                          
                                             
                                                z
                                                t
                                             
                                             
                                                τ
                                                t
                                                0
                                             
                                             
                                                τ
                                                t
                                                1
                                             
                                          
                                          
                                             
                                                
                                                   τ
                                                   t
                                                   1
                                                
                                                −
                                                
                                                   τ
                                                   t
                                                   0
                                                
                                                ≤
                                                ρ
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The use of the entering and exiting times will not be explicit until we deal with temporal relations in the parsing section. Meanwhile, in order to train the simple and complex action models, we focus on the sequences of zone crossings for each track z
                        (r)
                        =z1…zT
                        .

Note that, during training of simple actions our method uses the information of which portion of track is responsible for each simple action (as discussed in next section). However, during testing our method can recognise simple and complex actions using unsegmented tracks as input. That is, one track may cover multiple simple actions (sub-segmentation) or one simple action may be covered by multiple tracks (over-segmentation due to track breaks).

Simple actions are single-threaded activities showing certain invariability in the feature observations. Actions shown in the right-hand side of rule (Eq. (2)) fit into this definition. Fig. 4 shows examples from three simple actions in our dataset. We use Hidden Markov Models (HMM) [42] in order to model such simple actions using sequences of crossed zones as feature observations.

We are interested in learning the parameters Ψ
                        m
                     , m
                     =1…M that best explain each of the simple actions, where M is the number of simple actions. Consider the training set for the m-th simple action Z
                     (m), which is composed by all the portions 
                        
                           
                              
                                 z
                                 ˜
                              
                              
                                 r
                                 i
                              
                           
                        
                      of tracks performing that action (we use the pair (r, i) to denote the i-th portion of the r-th track, considering a portion as a contiguous subsequence of the track). We seek the parameters that maximize the following likelihood:
                        
                           (14)
                           
                              
                                 
                                    Ψ
                                    m
                                    ⋆
                                 
                                 =
                                 arg
                                 
                                    max
                                    
                                       Ψ
                                       m
                                    
                                 
                                 
                                    
                                       ∑
                                       
                                          
                                             
                                                
                                                   z
                                                   ˜
                                                
                                                
                                                   r
                                                   i
                                                
                                             
                                          
                                          ∈
                                          
                                             Z
                                             
                                                m
                                             
                                          
                                       
                                    
                                    
                                       P
                                       
                                          
                                             
                                                
                                                   
                                                      z
                                                      ˜
                                                   
                                                   
                                                      r
                                                      i
                                                   
                                                
                                             
                                             |
                                             
                                                Ψ
                                                m
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

This is usually done with the Expectation–Maximization algorithm.

In HMM, the system is assumed to be in a certain discrete state qt
                     
                     =
                     Sa
                     , a
                     =1…Q at each time t. Each state Sa
                      is able to generate observations (in our case, zone-crossings) according to some the emission probabilities
                     
                        
                           (15)
                           
                              
                                 
                                    B
                                    a
                                 
                                 
                                    
                                       
                                          z
                                          t
                                       
                                       =
                                       
                                          ω
                                          j
                                       
                                    
                                 
                                 =
                                 P
                                 
                                    
                                       
                                          z
                                          t
                                       
                                       =
                                       
                                          ω
                                          j
                                       
                                       
                                          
                                             
                                                q
                                                t
                                             
                                             =
                                             
                                                S
                                                a
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     
                  

The system behaves as a finite-state machine as it changes the state at each time step according to the transition probabilities
                        
                           (16)
                           
                              
                                 
                                    A
                                    
                                       a
                                       ,
                                       b
                                    
                                 
                                 =
                                 P
                                 
                                    
                                       
                                          q
                                          
                                             t
                                             +
                                             1
                                          
                                       
                                       =
                                       
                                          S
                                          b
                                       
                                       
                                          
                                             
                                                q
                                                t
                                             
                                             =
                                             
                                                S
                                                a
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     
                  

The probability of starting at each state is denoted by
                        
                           (17)
                           
                              
                                 
                                    π
                                    a
                                 
                                 =
                                 P
                                 
                                    
                                       
                                          q
                                          1
                                       
                                       =
                                       
                                          S
                                          a
                                       
                                    
                                 
                                 .
                              
                           
                        
                     
                  

The parameters of an HMM are thus, Ψ
                        m
                     
                     ={B, A, π}.

There are three important issues involved in the learning the parameters of our simple action models.
                        
                           •
                           Initialization of the parameters so that the states have a geometric interpretation.

Selection of the appropriate number of states, i.e., model selection.

Ending probabilities

We deal with these issues in the next Sections.

Parameter learning in HMM is an iterative procedure which requires initial estimates of the parameters B, A and π. While the final result has shown not to be affected by the initialization of A and π this is not the case for the parameter B 
                        [42].

Our motivation is that states have a geometrical interpretation so that they are related to specific regions in the scene. In order to assign the states a geometric interpretation we compute initial emission probabilities B according to spatial clustering of action data. This is, consider the collection points involved in the m-th action
                           
                              (18)
                              
                                 
                                    
                                       X
                                       
                                          m
                                       
                                    
                                    =
                                    
                                       
                                          
                                             x
                                             i
                                          
                                          
                                             
                                                t
                                                start
                                                r
                                             
                                          
                                          ≤
                                          
                                             t
                                             i
                                          
                                          ≤
                                          
                                             t
                                             end
                                             r
                                          
                                          ,
                                          r
                                          =
                                          1
                                          …
                                          
                                             N
                                             m
                                          
                                       
                                    
                                 
                              
                           
                        where Nm
                         is the number of training tracks of the m-th action and t
                        
                           start
                        
                        
                           r
                        ,
                        t
                        
                           end
                        
                        
                           r
                         are the starting and ending times of the m-th action within the r-th track.

Such collection of points is spatially partitioned into Q clusters 
                           
                              X
                              
                                 m
                                 a
                              
                           
                        , a
                        =1…Q using k-means, each cluster corresponding to a state of the HMM. Selection of the number of clusters will be addressed in the next subsection. Initial emission probabilities B
                        
                           a
                        
                        (0)(z
                        
                           t
                        
                        =
                        ω
                        
                           j
                        ) input to the model learning algorithm are defined as the number of points of the a-th cluster falling within zone ωj
                        . This is,
                           
                              (19)
                              
                                 
                                    
                                       B
                                       a
                                       
                                          0
                                       
                                    
                                    
                                       
                                          
                                             z
                                             t
                                          
                                          =
                                          
                                             ω
                                             j
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                I
                                                j
                                             
                                             
                                                
                                                   X
                                                   
                                                      m
                                                      a
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             ∑
                                             
                                                j
                                                ′
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      I
                                                      
                                                         j
                                                         ′
                                                      
                                                   
                                                   
                                                      
                                                         X
                                                         
                                                            m
                                                            a
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where I
                        
                           j
                        (.) denotes the set of points within zone ωj
                         and |.| denotes the number of points in the set.

The rationale behind Eq. (19) is to associate state Sa
                         with observations nearby cluster 
                           
                              X
                              
                                 m
                                 a
                              
                           
                        .

Selecting an appropriate number of states Q for an HMM is an important issue. An HMM with too few states may lead to too simple models that do not fit the actual observation process. On the other hand, an HMM with too many states may overfit the data thus lacking generalization ability. Approaches such as the Bayesian Information Criterion are used to balance both extrema by favouring good fits whereas complex models are penalized. We have opted for the simpler approach of choosing the minimum number of states so that the model fits the data in a certain proportion. Even though this method does not provide a principled justification for the chosen number of states, it provides the flexibility of adjusting the complexity of the model with a single parameter.

We select a maximum number of states large enough to overfit any of our models. In our case we set this value to Q
                        max
                        =25. We compute the ML parameters Ψ
                        
                           m
                        
                        
                           k
                         according Eq. (14) for all the action models m
                        =1…M and all the state-set sizes Q
                        =1…Q
                        max. We denote such likelihood values as p
                        
                           m
                        
                        
                           Q
                        . For the m-th action model, we select the number Q of states such that
                           
                              (20)
                              
                                 
                                    
                                       p
                                       m
                                       
                                          Q
                                          −
                                          1
                                       
                                    
                                    ≤
                                    λ
                                    
                                       p
                                       m
                                       
                                          Q
                                          max
                                       
                                    
                                    ≤
                                    
                                       p
                                       m
                                       Q
                                    
                                 
                              
                           
                        where 0≤
                        λ
                        ≤1 is a threshold indicating the proportion of fit of the model to the data.

Standard definition of HMM allow only for initial probabilities. This means that given a valid sequence, any of its sub-sequences starting at a feasible initial state may obtain a high likelihood regardless its end. In our case this means that an instance of the simple action Person goes from A to B will be considered as highly likely as long as it starts in A and develops correctly towards B, regardless it finally ends in B or not. In order to avoid this problem we explicitly compute the ending probabilities, which can be denoted as
                           
                              (21)
                              
                                 
                                    
                                       θ
                                       a
                                    
                                    =
                                    
                                       
                                          ∑
                                          i
                                          R
                                       
                                       
                                          
                                             
                                                P
                                                
                                                   
                                                      
                                                         q
                                                         
                                                            T
                                                            i
                                                         
                                                      
                                                      =
                                                      
                                                         S
                                                         a
                                                      
                                                   
                                                
                                             
                                             R
                                          
                                       
                                    
                                    =
                                    
                                       
                                          
                                             ∑
                                             i
                                             R
                                          
                                          
                                             
                                                α
                                                
                                                   T
                                                   i
                                                
                                             
                                             
                                                a
                                             
                                             
                                                β
                                                
                                                   T
                                                   i
                                                
                                             
                                             
                                                a
                                             
                                          
                                       
                                       
                                          
                                             ∑
                                             
                                                a
                                                ′
                                             
                                          
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      ′
                                                   
                                                   R
                                                
                                                
                                                   
                                                      α
                                                      
                                                         T
                                                         
                                                            i
                                                            ′
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         a
                                                         ′
                                                      
                                                   
                                                   
                                                      β
                                                      
                                                         T
                                                         
                                                            i
                                                            ′
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         a
                                                         ′
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where Ti
                         refers to the last observation of the i-th training sample, R are the total number of training samples, and α
                        
                           t
                        (.),
                        β
                        
                           t
                        (.) are the forward and backward variables at time t estimated during the learning procedure with the EM algorithm [42]. Therefore, we will also include the probability of a sequence ending at a certain state into our model of simple actions detections. In this way, our method effectively avoids considering partial observations as highly likely detections.

Syntactic approaches have been used for recognizing complex actions [13,15–18,31]. One of their appealing features is their ability to represent highly structured behaviours that otherwise would be difficult to model with statistical approaches. Behaviours are represented following a hierarchical organization in the form of grammar rules. This allows one to easily represent increasingly complex structures by re-utilizing components. In production rules there are two types of symbols: terminals and non-terminals. Terminals are atomic observations that cannot be further decomposed. Non-terminals can be decomposed into sequences of terminals and non-terminals. Consider the following rules:
                        
                           (22)
                           
                              
                                 
                                    
                                       S
                                       →
                                       AB
                                    
                                 
                                 
                                    
                                       A
                                       →
                                       aA
                                       
                                          a
                                       
                                    
                                 
                                 
                                    
                                       B
                                       →
                                       bB
                                       
                                          b
                                       
                                    
                                 
                              
                           
                        
                     where non-terminals and terminals are in uppercase and lowercase, respectively. S is the starting symbol corresponding to the first production which can be substituted by the sequence AB. Non-terminals A, B are responsibles of generating sequences of a, b respectively. A pipe (|) is used to define multiple productions associated to the same non-terminal. It is easy to see that this grammar constitutes a model for the generation of sequences of a's followed by sequences of b's. The specification of models for complex actions follows the same idea: terminals are primitive observations and non-terminals are intermediate constructions representing activities in a range of complexity. All valid activities are generable from the starting symbol S.

Extensions have been proposed to this simple case better adapted to deal with complex scenarios sensed from visual inputs. Stochastic grammars [39,13] allow for probabilities both in the production rules and the terminal observations. Zhang et al. [31] relax the sequentiality constraint allowing for complex temporal relations such as meet, overlap, during, after …

Consider an input sequence of feature observations z
                     1,…,zn
                      and the conditional probabilities 
                        
                           P
                           =
                           
                              
                                 p
                                 
                                    
                                       z
                                       
                                          a
                                       
                                    
                                 
                                 ,
                                 p
                                 
                                    
                                       z
                                       
                                          b
                                       
                                    
                                 
                              
                           
                        
                      that the observations have been given by the terminals. Consider the following grammar G defining the generation of either sequences of a's overlapping with b's or sequences of a's during b's:
                        
                           (23)
                           
                              
                                 
                                    
                                       S
                                       →
                                       A
                                       
                                          overlaps
                                       
                                       B
                                       
                                          0.5
                                       
                                       
                                          
                                             A
                                             
                                                during
                                             
                                             B
                                             
                                                0.5
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       A
                                       →
                                       a
                                       
                                          meets
                                       
                                       A
                                       
                                          0.75
                                       
                                       A
                                       
                                          0.75
                                       
                                       
                                          
                                             a
                                             
                                                0.25
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       B
                                       →
                                       b
                                       
                                          meets
                                       
                                       B
                                       
                                          0.75
                                       
                                       
                                          
                                             b
                                             
                                                0.25
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     where the prior probability of each rule is denoted in square brackets.

Stochastic grammars define a probability measure 
                        
                           P
                           
                              
                                 z
                                 
                                    G
                                    P
                                 
                              
                           
                        
                      of a sequence of observations z
                     =
                     z
                     1,…zn
                      given the grammar G and the conditional observation probabilities 
                        P
                     .

The procedure to compute this probability is known as parsing and will be detailed in Section 7.

Most syntactic approaches adopt a bottom-up approach to the recognition of high level activities. At the bottom, simple actions are detected by some standalone method and next such detections are fed up to the syntactic parser which recognises the complex actions [13,31]. The novelty of our work is that we propose a method that unifies the two levels.

Our approach uses zone crossings as primitive observations for the unified recognition of both simple and complex actions. Therefore, recognition of simple and complex actions is performed in the same parsing procedure. This allows for an effective top-down influence of the expectations of the complex actions regarding the detection of simple actions.

Our unified approach requires that simple action models from Section 5 (i.e., HMMs) are represented in the form of grammar rules to be integrated in the same parsing procedure. The starting symbol corresponding to the m-th simple action is denoted as 
                           
                              S
                              
                                 m
                              
                           
                        . Each state S
                        
                           a
                        
                        (m) in the HMM can be reached from the starting symbol with probability π
                        
                           a
                        
                        (m) as denoted in Eq. (17). This can be represented by the following grammar rule:
                           
                              (24)
                              
                                 
                                    
                                       S
                                       
                                          m
                                       
                                    
                                    →
                                    
                                       S
                                       1
                                       
                                          m
                                       
                                    
                                    
                                       
                                          π
                                          1
                                          
                                             m
                                          
                                       
                                    
                                    
                                       …
                                    
                                    
                                       S
                                       n
                                       
                                          m
                                       
                                    
                                    
                                       
                                          π
                                          n
                                          
                                             m
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The behaviour of an HMM consists of a sequence of observation emission and state transitions. At each time step, an emission zt
                         and a transition to a different (or the same) state is produced. This is represented by the following rule:
                           
                              (25)
                              
                                 
                                    
                                       S
                                       a
                                       
                                          m
                                       
                                    
                                    →
                                    
                                       b
                                       a
                                       
                                          m
                                       
                                    
                                    
                                       m
                                    
                                    
                                       S
                                       1
                                       
                                          m
                                       
                                    
                                    
                                       
                                          A
                                          
                                             a
                                             1
                                          
                                          
                                             m
                                          
                                       
                                    
                                    
                                       …
                                    
                                    
                                       b
                                       a
                                       
                                          m
                                       
                                    
                                    
                                       m
                                    
                                    
                                       S
                                       n
                                       
                                          m
                                       
                                    
                                    
                                       
                                          A
                                          an
                                          
                                             m
                                          
                                       
                                    
                                 
                              
                           
                        where {m} indicates the meet relation, A
                        
                           ab
                        
                        (m) are the transition probabilities introduced in Eq. (16) and b
                        
                           a
                        
                        (m) is a terminal that is related to the observations by the likelihood P(z
                        
                           t
                        |b
                        
                           a
                        
                        (m))=
                        B
                        
                           a
                        
                        (m)(z
                        
                           t
                        ) introduced in Eq. (15). Therefore, each observation zt
                         in the sequence is considered to be a terminal b
                        
                           a
                        
                        (m) with probability B
                        
                           a
                        
                        (m)(z
                        
                           t
                        ), for all simple actions (m) and states (a). In order to avoid unnecessary overhead we discard unlikely observations
                           
                              (26)
                              
                                 
                                    
                                       B
                                       a
                                       
                                          m
                                       
                                    
                                    
                                       
                                          z
                                          t
                                       
                                    
                                    <
                                    ϵ
                                 
                              
                           
                        where ϵ is a parameter subject to optimization in the experiments section.

The completion of a simple action 
                           
                              S
                              
                                 m
                              
                           
                         (i.e., its detection) can only be accomplished by the activation of a terminal rule (i.e., a rule without non-terminals). We take into account the ending probabilities of a simple action by adding a terminal rule at each state allowing one to trigger its detection according to the probability of that state being an ending state (i.e., the probability that the simple action ends in a specific region). This can be denoted as,
                           
                              (27)
                              
                                 
                                    
                                       S
                                       a
                                       
                                          m
                                       
                                    
                                    →
                                    …
                                    
                                       
                                          
                                             b
                                             a
                                             
                                                m
                                             
                                          
                                          
                                             
                                                θ
                                                a
                                                
                                                   m
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where θ
                        
                           a
                        
                        (m) are the ending probabilities of Eq. (21). In this way, we explicitly take into account the probability of a simple action ending at each of its states. This is equivalent to say that a highly likely detection needs not only to start and to develop according to the model, but also to end accordingly. Conventional HMMs only consider where the sequence of observations starts and how it develops, but not where it ends.

The coupling of simple and complex action layers into a unified approach is performed by using the simple actions symbols developed in the previous section to construct the complex action rules, as described in the following.

The starting symbol of a simple action S(m) encodes a valid instance of the m-th simple action. Arbitrarily complex representations can be reached by re-using existing symbols to form new symbols.

Several approaches have been presented to learn grammar rules from a corpus of data. In [43] the authors use a bi-clustering algorithm to iteratively identify pairs of symbols co-occurring in the training corpus. Each identified pair is associated to a new rule and the training set is reduced by replacing the appearances of that pair for the new rule. In [44] the authors learn rules for event detection from video. They use the minimum description length (MDL) principle in order to iteratively reduce the length of the training data by finding primitive co-occurrences and replacing them by rules. Similarly in [45], the authors used the MDL principle to infer the rules from primitive series of events. The method was used in a visual surveillance application. Zhang et al. [31] also use the MDL approach to infer the rules of a context-free grammar.

These approaches require that the training set is composed only by the activities that we want to model. However in some real situations, such as the recognition of threats in a parking lot, activities of interest often happen in parallel to other unrelated activities. Using the above methods for rule induction would lead to undesired learning of correlations between unrelated activities. In order to overcome this limitation, authors in [46] introduce deictic supervision consisting on providing, along with the training data, a spatial and temporal bounding of the activities of interest.

In the proposed approach, we have opted for manual specification of the rules of complex actions because manual specification of complex actions has been previously used by other authors in the surveillance setting [15,26,16,27–30]. Table 1
                         shows a snippet of the rules used in the experiments for illustrative purposes (the complete set is shown in the appendix in Table 3). We illustrate two types of scenarios, namely, stop for a meal with check and potentially criminal behaviour described below and specified in Table 1.

This scenario encodes the routine behaviour of stopping for a meal plus a check before entering the truck. It is composed of two parts. In the first part the truck driver goes from the truck to the service area (TDfromTtoSA). This action is composed mainly by three sub-actions, namely, exiting the truck, going from truck parking area to service area and entering the service area. Alternatively, truck driver loitering around the truck may either be observed before going to the service area, or not. The second part (TDfromSAtoT_2) consists of the truck driver returning to the truck plus a check consisting of either loitering or walking around the truck before entering it. Additional constraints are expressed in the form of temporal relations allowed between the observations. For example, the precede relation (denoted by {p}) indicates that there must be a delay between TDfromTtoSA and TDfromSAtoT_2. Actions related by the meet relation (denoted by {m}) must be observed without significant delay between them.

The second scenario in the table encodes the suspicious action of someone checking of the truck while the truck driver is in the service area. The first part consists of routine behaviour of the truck driver stopping for a meal. In the second part, someone from the car parking area approaches the truck and loiters and / or walks around it. These two parts may be either temporally overlapped or there may be a delay between them as indicated by the temporal relations overlap and precede ({o,p}).

Actions like someone loiters nearby Truck Parking area (XloiterTP) are either considered harmless when they are related to the truck driver in e.g., rule Truck Driver from Truck to Service Area (TDfromTtoSA) or they can be part of potentially criminal behaviours when they are related to a car driver in e.g., someone from Car Parking area checks Truck (XfromCPcheckT).

It is interesting to note how increasingly complex behaviours are built by a recursive combination of simpler ones. The proposed method for the recognition of complex actions is purely based on positional information. Identities of the persons involved in the complex actions are determined based on the expectations of the complex activity layer. For example, the truck driver is considered to be a person that steps off the truck and its identity can be subsequently propagated to someone going from Truck Parking area to Service Area (XfromTPtoSA) and someone entering Service Area (XenterSA) in the case they satisfy the temporal constraints of the higher-level rule Truck Driver from Truck to Service Area (TDfromTtoSA). In the case of having specific detectors for the truck driver (e.g., through face recognition or recognition by the clothing), we could improve the recognition by substituting either (or both) rules XfromTPtoSA and XenterSA by TDfromTPtoSA and TDenterSA. Which rules would incorporate explicit identification mechanisms would depend on the location of the detectors (nearby the truck or at the service area entrance).

Given a sequence of primitive observations, the parsing procedure allows to compute the most likely set of rule activations leading to the observations. Zhang et al. [31] proposed a parsing method allowing to deal with multiple threads of actions related by complex temporal relations such as precede, overlap, etc.

Consider a sequence of primitive observations (in our case, zone-crossings). The sequence is ordered by ending times and each observation is associated with an ID according to this ordering. Multi-threaded parsing uses relaxed ID sets, thus allowing states to contain non-contiguous ID-sets as opposed to stochastic parsing that requires consecutive IDs [13,39]. With such relaxed ID-sets the primitives corresponding to parallel complex events can be represented by the same state. Fig. 5
                      shows an example of the advantage of multi-thread parsing.

A set of states is maintained by the parsing procedure. Each state encodes the observed portion of a rule and is denoted as
                        
                           (28)
                           
                              
                                 I
                                 :
                                 X
                                 →
                                 λ
                                 ⋅
                                 Yμ
                                 
                                    v
                                 
                              
                           
                        
                     where I is the ID set that indicates the IDs of the primitives currently consumed by the state, the dot indicates the already observed part of the state, λ is the string of symbols already observed, Y is the next expected symbol, μ is the unobserved string and v is the Viterbi probability indicating the maximum possible derivation of the state.

Initially all the rules are converted to states with the dot at the initial position. Parsing iterates by processing the sequence of ordered primitives [z
                     
                        t
                     ,
                     τ
                     
                        t
                     
                     0,
                     τ
                     
                        t
                     
                     1] (Eq. (38)), one at each time step t. At each iteration we perform the following operations: terminal generation, scanning, completion and prediction.

For a given zone-crossing zt
                         we generate the set of terminals b
                        
                           a
                        
                        (m) related to the simple actions m intersecting with that zone-crossing. This is,
                           
                              (29)
                              
                                 
                                    
                                       b
                                       a
                                       
                                          m
                                       
                                    
                                    
                                    s
                                    .
                                    t
                                    .
                                    
                                    
                                       B
                                       a
                                       
                                          m
                                       
                                    
                                    
                                       
                                          z
                                          t
                                       
                                    
                                    >
                                    ϵ
                                    ∀
                                    m
                                    ,
                                    a
                                 
                              
                           
                        as noted in Eq. (26).

During scanning we update the states which expect any of the generated terminals b
                        
                           a
                        
                        (m) as next symbol. This is,
                           
                              (30)
                              
                                 
                                    
                                       
                                          
                                             
                                                I
                                                :
                                                
                                                   S
                                                   a
                                                   
                                                      m
                                                   
                                                
                                                →
                                                ⋅
                                                
                                                   b
                                                   a
                                                   
                                                      m
                                                   
                                                
                                                μ
                                                
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                t
                                                :
                                                
                                                   z
                                                   t
                                                
                                                
                                                   
                                                      P
                                                      
                                                         
                                                            
                                                               z
                                                               t
                                                            
                                                            
                                                               b
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       ⇒
                                       
                                          I
                                          ′
                                       
                                       :
                                       
                                          S
                                          a
                                          
                                             m
                                          
                                       
                                       →
                                       
                                          b
                                          a
                                          
                                             m
                                          
                                       
                                       ⋅
                                       μ
                                       
                                          
                                             P
                                             
                                                
                                                   
                                                      z
                                                      t
                                                   
                                                   
                                                      b
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where I is the null set (since the state has not consumed any primitive yet), I′={t} and t is the ID of the primitive in the input stream. In the case of our grammar μ can either be empty (Eq. (27)) or μ
                        =
                        S
                        
                           i
                        
                        (m) (Eq. (25)). Initially, states with no observation have a Viterbi probability of 1.

When a state is fully observed (the dot is at the end) we say the state is completed. During completion we propagate the completed state up to the higher levels by updating those states that expect it as the next symbol (similarly as it is done in scanning). For each completed state I
                        :
                        Y
                        →
                        λ
                        ⋅[v], we seek the state X fulfilling the following conditions.
                           
                              •
                              
                                 Y is the next unobserved symbol of X (the symbol next to the dot).


                                 I
                                 ∩
                                 I′=∅, the ID set of the completed state I does not share any primitive with the ID set of X, I′.

The temporal relation between Y and the observed sub-events of X are consistent with the rule definition. Temporal relations are checked with a similar fuzzy method than [47]. This method is governed by a parameter κ controlling the allowed temporal overlap between the observations.

In case these conditions hold, X can be assumed as I′:
                        X
                        →
                        ω
                        ⋅
                        Yμ[v′] and the following state is created:
                           
                              (31)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   I
                                                   ′
                                                
                                                :
                                                X
                                                →
                                                ω
                                                ⋅
                                                Yμ
                                                
                                                   
                                                      v
                                                      ′
                                                   
                                                
                                             
                                          
                                          
                                             
                                                I
                                                :
                                                Y
                                                →
                                                λ
                                                ⋅
                                                
                                                   v
                                                
                                             
                                          
                                       
                                    
                                    ⇒
                                    
                                       I
                                       ″
                                    
                                    :
                                    X
                                    →
                                    ωY
                                    ⋅
                                    μ
                                    
                                       
                                          v
                                          ″
                                       
                                    
                                 
                              
                           
                        where I″=
                        I′∪
                        I and v″=
                        v′v.

New completed states may be created as result of this operation. We repeat this process until all newly created completed states have been processed.

Consider as an example the completed state
                           
                              (32)
                              
                                 
                                    I
                                    :
                                    TDfromTtoSA
                                    →
                                    λ
                                    ⋅
                                    
                                       v
                                    
                                 
                              
                           
                        resulting from the observation of the simple action truck driver goes from truck to service area. Note that I is the null set since this state has not consumed any observation yet. During completion, higher-level states expecting this simple action as next observation such as
                           
                              (33)
                              
                                 
                                    
                                       I
                                       ′
                                    
                                    :
                                    stopformeal
                                    →
                                    ⋅
                                    TDfromTtoSA
                                    
                                    TDfromSAtoT
                                    
                                       1
                                    
                                    ,
                                 
                              
                           
                        will be updated producing the new state
                           
                              (34)
                              
                                 
                                    I
                                    ∪
                                    
                                       I
                                       ′
                                    
                                    :
                                    stopformeal
                                    →
                                    TDfromTtoSA
                                    ⋅
                                    TDfromSAtoT
                                    
                                       v
                                    
                                 
                              
                           
                        
                     

Original (non-updated) state is also kept in the state-set. This is because due to the relaxed ID-set, we need to contemplate the possibility that new observations still to arrive may match the current state with higher probability.

Using this approach a simple action is considered to be detected each time a simple action non-terminal is completed.

During prediction we remove the set of completed states from the pool of active states for the next iteration and keep them apart for further checking at the end of parsing.

At the end of parsing, we check all the completed root states I
                        
                           f
                        
                        :
                        S
                        →
                        λ
                        ⋅[v
                        
                           f
                        ]. We classify the clip as the category of the state with the highest Viterbi probability. According to our grammar, the symbol λ corresponds to one of the 5 categories (Table 3). In the case there are not completed root states, the clip is classified as the null category (i.e., it does not follow the rules of the grammar).

Because of the relaxed ID-set some symbols may be left out of the final derivation. In order to favour derivations containing as much observations as possible, we apply a penalty according to the left-outs. For each completed starting symbol I
                        
                           f
                        
                        :
                        S
                        →
                        λ
                        ⋅[v
                        
                           f
                        ], we modify the final Viterbi probability as follows:
                           
                              (35)
                              
                                 
                                    v
                                    =
                                    
                                       v
                                       f
                                    
                                    
                                       
                                          ∏
                                          
                                             i
                                             ∉
                                             
                                                I
                                                f
                                             
                                          
                                       
                                       
                                          σ
                                       
                                    
                                 
                              
                           
                        where σ is a small probability value penalizing each observation not included in the final derivation.

Because of the relaxed ID set and the fuzzy temporal relations many redundant hypothesis can be generated for the same input stream. In order to avoid this overhead, authors in [31] introduce the maximum beam-width constraint. They consider as isomorphic those states sharing the same rule, same dot position but with different ID set. Between two isomorphic states the one with more consumed primitives and higher Viterbi probability is preferred. Considering {S
                           1,…,Sn
                           } an isomorphic state-set, a state Si
                            is ranked according to the following measure,
                              
                                 (36)
                                 
                                    
                                       r
                                       
                                          
                                             S
                                             i
                                          
                                       
                                       =
                                       v
                                       
                                          
                                             S
                                             i
                                          
                                       
                                       +
                                       σ
                                       
                                          
                                             
                                                
                                                   
                                                      ∪
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      n
                                                   
                                                   
                                                      I
                                                      
                                                         S
                                                         j
                                                      
                                                   
                                                
                                             
                                             −
                                             
                                                
                                                   I
                                                   
                                                      S
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where v(Si
                           ) is the Viterbi probability of state Si
                           , σ is the penalty of insertion error presented in previous section, |∪
                           
                              i
                              =1
                           
                              n
                           | denotes the number of primitives consumed by the union of all ID sets of the isomorphic states, and |Si
                           | denotes the number of primitives consumed by state Si
                           .

The beam-width constraint selects the top ω states in the isomorphic state set and discards the rest. Authors in [31] find the value ω
                           =3 a suitable one which we have adopted in the present work too.

Considering each zone-crossing independently leads to a combinatoric growth in the number of parsing states at the level of simple actions. This is due to the fuzzy temporal relations that usually allow to connect many non-consecutive observations making sense in terms of simple action models. The maximum beam-width constraint partially limits this growth but it does not explicitly address this issue. We leverage track continuity information in order to limit the number of states and therefore avoid the computational burden.

The track continuity constraint is applied at the completion step and imposes further conditions to the update of a state additionally to the ones already defined in Section 7.3. A new primitive belonging to a certain track a is accepted into a parsing state when either of the following conditions is fulfilled:
                              
                                 •
                                 the previous observed primitive is from the same track a, or

the track of the previous primitive is already finished (i.e., track discontinuity).

As result, only consecutive observations from a track are considered if there is tracking information. This constraint is only applied at the simple action level and therefore does not prevent the recognition of multi-threaded complex actions. In the case of track breaks due to occlusion or errors, this constraint has no effect and the algorithm considers all the sensible connections of zone-crossings and temporal relations in terms of simple action models.

This constraint is formalized as follows:
                                       
                                          (37)
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               I
                                                               ′
                                                            
                                                            :
                                                            
                                                               S
                                                               i
                                                               
                                                                  m
                                                               
                                                            
                                                            →
                                                            
                                                               b
                                                               i
                                                               
                                                                  m
                                                               
                                                            
                                                            ⋅
                                                            
                                                               S
                                                               j
                                                               
                                                                  m
                                                               
                                                            
                                                            
                                                               
                                                                  v
                                                                  ′
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            I
                                                            :
                                                            
                                                               S
                                                               j
                                                               
                                                                  m
                                                               
                                                            
                                                            →
                                                            λ
                                                            ⋅
                                                            
                                                               v
                                                            
                                                         
                                                      
                                                   
                                                   ⇒
                                                   
                                                      I
                                                      ″
                                                   
                                                   :
                                                   
                                                      S
                                                      i
                                                      
                                                         m
                                                      
                                                   
                                                   →
                                                   
                                                      b
                                                      i
                                                      
                                                         m
                                                      
                                                   
                                                   
                                                      S
                                                      j
                                                      
                                                         m
                                                      
                                                   
                                                   ⋅
                                                   
                                                      
                                                         v
                                                         ″
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    subject to either


                                    b
                                    
                                       i
                                    
                                    (m) and the first observed primitive of λ are consecutive observations from the same track, or


                                    b
                                    
                                       i
                                    
                                    (m) is the last observation from a track

@&#EXPERIMENTS@&#

We perform threat recognition experiments on a dataset recorded for EU project ARENA. The ARENA project aims to detect threats to mobile assets from multiple affordable sensors. This dataset is focussed at the detection of threats in a parking lot and contains 26 clips with acted scenarios corresponding to five categories ranging from normal criminal behaviour.

There are a total of 26 clips that are classified into the 5 categories: Stop for a meal, Stop for a meal with check, Something is wrong, Potentially criminal behaviour and Criminal behaviour. Table 2
                      shows the ground-truth category of each clip along with their durations.


                     Figs. 2 and 3 show an overview of the parking lot and two shots of typical actions, respectively. In Section 3 we provide the description of an example clip.

Our method processes the sequence of zone-crossings in the same order as they are observed. This means that observations from multiple tracks appearing simultaneously are processed in an interleaved way. We also keep the information about the track identity of the track performing each zone crossing. This information is used by the track continuity constraint to limit the number of rule activations and thus, avoid unnecessary computational burden, as explained in Section 7.5.2. Note that our method can naturally deal with track over-segmentation (i.e., track breaks) at the cost of a higher number of computations because the track continuity constraint cannot be used. In Section 8.7 we evaluate the performance of our method in such case. Track under-segmentation does not represent a problem because simple actions can be triggered by our method at any point of an existing track. Mathematically, the sequence of observations processed by our method can be defined as
                           
                              (38)
                              
                                 
                                    Z
                                    =
                                    
                                       
                                          
                                             z
                                             t
                                          
                                          
                                             τ
                                             t
                                             0
                                          
                                          
                                             τ
                                             t
                                             1
                                          
                                          r
                                       
                                    
                                 
                              
                           
                        where zt
                         is the crossed zone, (τ
                        
                           t
                        
                        0,
                        τ
                        
                           t
                        
                        1) are, respectively, the entering and exiting times to the zone (ordered ascendingly in time), and r is the track id (to be used by the track continuity constraint).

In order to classify each clip into one of the 5 categories we define the grammar of the behaviour in a parking lot shown in the Appendix A. These rules have been defined based on the expert knowledge about the complex actions. According to the organization of our grammar (see Appendix A), classification of each clip into one of the categories is done according to the starting rule recovered by the parser (i.e., the one of the form S
                        →…). Since recognition is based on trajectories, an aggressive act like fight is modelled as a potential thief and the truck driver loitering at the same time nearby the truck. For training of simple actions we use the leave-one-out strategy, thus, we discard all the data from the testing clip in order to train the models. We have used manually annotated bounding boxes as tracking input to our method. This is mainly for two reasons: One is to limit the effects of track discontinuities on the computational time. The other is to allow fair comparison with the competing method which needs simple actions to be contained within continuous tracks, otherwise they could not be detected (more details about the competing method in the next subsection).

As competing method we use an adaptation of the two-stage approach in [13] in order to deal with complex temporal relations. This adaptation consists of substituting the sequential parsing originally proposed by the authors by the multi-threaded parsing of [31] also used in our method. The competing method performs simple and complex action detection in two separate steps. In the first stage, simple actions are detected using regular HMM inference (we use the same HMM models as described in Section 5). Detected actions are fed into the parser which, in the second stage, classifies the input into one of the scenarios.

We use the same complex actions rules as in our method. In their work [13], authors also used manual specification of the grammar rules. According to [13] simple action detections are evaluated using a sliding window along each track and select the local maxima as detection candidates [13].

We use the same parameters for both methods unless otherwise noted. Zone filtering parameter ρ (Eq. (13)) is experimentally set to 0.3s. Margin for the temporal relations in our method is set to κ
                        =3s (refer to [47] for more details). In the competing method this parameter has been subject to optimization. For the model selection threshold λ (Eq. (20)) we have tried various values and have kept the one with best results. We have done likewise for the emission cutoff parameter ϵ (Eq. (26)) in the case of our method (we have not found necessary to use an emission cutoff for the competing method). As pointed out in Fig. 6
                         we have found that the best performing parameters for our method are ϵ
                        =10−12, λ
                        =0.5 and for the competing method: λ
                        =0.5 and κ
                        =9s. The large temporal margin found when optimizing the competing method suggests that simple action detection based on local maxima of HMM results in a poor localization and the complex action layer needs a larger margin in order to link the simple actions into the complex action rules. The main reason is that local optimal detections for the simple action models are not necessarily the more suitable in terms of complex actions.

For a more detailed assessment of the results, in Fig. 7
                         we show the confusion matrices corresponding to the best configurations. The last column “null” allocates the clips not recognised as any of the scenarios by the parser.

Our method obtains an increase in accuracy of around 33% with respect to the competing one. All the clips except two are correctly classified by our method. The two failures are due to the lack of training data of the simple actions involving the smoking area. There are so few examples of these simple actions (2 or 3 from each) that even using the leave-one-out scheme it is not possible to detect the left-out samples. Comparative results show a significant improvement of the proposed method with respect to the competing one. An interesting case is seen in categories stop for a meal and stop for a meal with check, in order to distinguish them, it is necessary to notice the subtle difference of truck driver loitering before entering the truck or not. Loiter is a quite challenging action to detect based on object trajectories. It has ambiguous initial and ending points and therefore is triggered many times when someone is in the truck parking area. In the case of stop for a meal, trimming too short the action truck driver goes from service are to truck causes phantom loitering actions to be detected before the truck driver enters the truck thus misleading the classification of the scenario in the case of the competing method. On the other hand, our method is able to correctly segment the actions in the scenario stop for a meal. Our method correctly detects the loiter actions when they occur in the category stop for a meal with check. The competing method reports the same failures as our method regarding clips involving the smoking area. Moreover, it assigns 3 clips to the null category meaning that the actions detected do not match any of the specified scenarios.

The proposed method spends an average of ~30min. to process each clip. Computational time is the main burden of the proposed method compared to the competing one which processes each clip in the order of seconds.
                           1
                        
                        
                           1
                           We have produced a non-optimized Matlab implementation of the parser in order to detect both simple and complex actions. The competing method uses the HMM toolbox in http://www.cs.ubc.ca/murphyk/Software/HMM/hmm.html in order to detect simple actions.
                        
                     

In order to give a more detailed assessment in Fig. 8
                         we show the detection accuracy for individual simple actions by both methods. Accuracy is measured with the F1-score with the precision and recall of the detections
                           
                              (39)
                              
                                 
                                    F
                                    1
                                    =
                                    
                                       
                                          precision
                                          ⋅
                                          recall
                                       
                                       
                                          precision
                                          +
                                          recall
                                       
                                    
                                 
                              
                           
                        
                     

Precision represents the detection accuracy by the delivered events normalized by the delivered events, whereas recall represents the same accuracy but normalized by the ground truth events. We measure the detection accuracy by the Dice Ratio of their intervals defined by the starting and ending times. Given two intervals A and B their Dice Ratio is computed as
                           
                              (40)
                              
                                 
                                    Q
                                    =
                                    
                                       
                                          2
                                          ⋅
                                          A
                                          ∩
                                          B
                                       
                                       
                                          A
                                          ∪
                                          B
                                       
                                    
                                 
                              
                           
                        
                     

For each simple action we measure precision by accumulating the best dice ratios between each detection and all ground truth candidates. The recall is computed in the inverse way, this is, we accumulate the best dice ratios between each ground truth action and all detected candidates. This agrees with the intuition that optimistic detections covering large intervals will have high precision and low recall, and vice-versa.

Our method outperforms the competing one in detection accuracy of individual actions. It obtains an improvement of 33% in recognition accuracy in the present dataset. This is also the case for the loitering action, as noticed earlier. The least represented simple actions in the training set are those involving the smoking area, which are the ones affected by total failures in some cases.

In general, the easiest actions to detect based on object trajectories are those involving large displacements across the scene. This is because they have a well-defined sequence of transitions between initial and ending areas which moreover are far apart from each other thus helping to reduce ambiguity.


                        Fig. 9
                         shows some example detections of our method in a scenario of the type stop for a meal with check. We can appreciate that the trace of bounding boxes of each detection corresponds fairly well to the underlying simple actions.

In order to evaluate the robustness of our method to tracking errors we have synthetically added two types of noise, namely, track breaks and ghost tracks. Track breaks consist in dividing a single track into portions at multiple breaking points. Each one of the portions will be considered as a different track. This type of noise simulates failure of the tracking module in correctly following an object along its trajectory. This can be caused by lost detections (i.e., false negatives). Ghost tracks added to each clip are randomly chosen from the rest of the clips. This type of noise simulate either false positive detections of the tracking module due to imaging artefacts or the presence of spurious objects unrelated with the main activity to be recognised. Ghost tracks are already present in those original clips displaying people not involved in the main action. By adding this type of noise we want to evaluate, under controlled conditions, the robustness of our method systematically against the two most common tracking errors in practice.

In the track break experiments we have added breaking points at random locations of each track. We consider that each track can be broken independently at each frame with a certain probability p according to a uniform distribution. We choose the values of p ranging from p
                        =0 (no breaks) to p
                        =0.05 (one break every 20 frames, in average). Since we are using a frame-rate of ~7 frames per second, a value of p
                        =0.05 represents one break at, approximately, every 3s. Our method uses the track identity information to reduce the number of candidate productions by means of the track continuity constraint. Track breaks will augment the number of hypothesis to be considered and therefore, the computational time will be affected. We have not added results for the competing method since it does not implement the ability of recovering from track breaks. Fig. 10
                         shows the recognition accuracy of complex actions achieved by our method as well as the computational time required. Due to the randomness of the noise, each result is the average of 5 different runs for each one of the 26 clips.

Results show that recognition accuracy decreases up to ~30% as we increase the track breaks until the point of approximately adding one break every 3s. On the other hand, the required computational time increases up to ~300%. This highlights the usefulness of using tracking information in our method for reducing the number of hypothesis. It is worth mentioning that until p
                        =0.01 there is almost no loss in accuracy and no increase in computational time.


                        Fig. 11
                         shows the recognition accuracy of both our method and the competing method in the presence of ghost tracks. We display the threat recognition results of adding from 1 to 5 ghost tracks to each clip chosen randomly from the rest of available clips. Ghost tracks are inserted at the same time points as they are shown in their original clips. Results are the average of 5 runs. Results show that our method is more robust to the presence of ghost tracks than the 2-stage competing method. Specifically, in the case of 5 ghost tracks, our method obtains an improvement of ~90%. The performance of our method is shown to be slightly worse for 2 than for 3 ghost tracks. These slight variations may be due to the fact that the 2-track random draws contain more harmful ghost tracks than the 3-track draws. Harmful ghost tracks are those that can potentially change the meaning of a clip such as a a person going from car park area to truck park area can change the meaning of a clip from normal behaviour to potentially criminal behaviour. Despite this slight variation, both methods show a decreasing-performance trend as the number of ghost tracks is increased.

@&#CONCLUSIONS@&#

We have presented an approach for the recognition of threats in a parking lot, or more generally, for the recognition of complex actions. Our method integrates statistical learning of simple actions and manual specification of complex actions into a single grammar. It implements a multi-threaded parsing procedure that allows the modelling and recognition of actions involving multiple objects which are related by complex temporal relations such as precede, during, overlap, … Our main contribution is a unified parsing mechanism allowing for effective influence of the higher layers into the recognition of primitive actions. As input to our method we use the crossings along a set of zones learned in an unsupervised way from the trajectories of detected objects in the scene. Learned zones create a partitioning of the scene in correspondence to the activities carried out on the scene (entering/exiting areas, loitering/standing areas) and are thus well suited for our action definition.

Our unified approach achieves improvements in the recognition of both simple and complex actions of ~30% with respect to a two-stage approach. Optimal detections regarding the simple action layer are not necessarily optimal for the complex action layer. We argue that such division limits the influence of the higher layer towards the lower one thus leading to a loss in accuracy. This is demonstrated in the experiments in a realistic dataset where we show higher recognition rates, both of simple and complex actions, of our unified approach with respect to a similar two-stage approach. Perhaps the clearest example is the ability to distinguish the subtle differences between the scenarios stop for a meal and stop for a meal with check which only differ on the occurrence of the loiter action in the latter case. This is particularly challenging since the loiter action is quite ambiguous in terms of trajectory and therefore triggers many phantom detections when someone is nearby the truck. Experiments with synthetic noise show the robustness of our method to the dominant failures in the tracking module causing track breaks and ghost tracks. Specifically, for moderate amounts of noise the proposed method only experiences a limited decrease in performance. The improvements in our method come at the expenses of higher computational costs. This is specially the case in the presence of track breaks where the track continuity constraint cannot be applied to reduce the number of candidate hypothesis. Directions of further research will explore ways of reducing computational complexity while preserving the discriminative and beneficial properties of our method.

@&#ACKNOWLEDGEMENTS@&#

The present work has been carried out in the framework of the EU project ARENA (grant ref. 261658). The authors want to thank the project partners for their contributions. Any opinions expressed in this paper do not necessarily reflect the views of the European Community. The Community is not liable for any use that may be made of the information contained herein.


                     
                  

@&#REFERENCES@&#

