@&#MAIN-TITLE@&#A model synthesis method based on single building facade

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a synthesis method via seamless stitching of each single building facade.


                        
                        
                           
                           We transform complicated 3D model synthesis into simple 2D constraints synthesis.


                        
                        
                           
                           Connection point set is used for seamless stitching.


                        
                        
                           
                           Both single and multiple examples we can handle.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Structure analysis

Global optimization

Single-example model synthesis

Multi-example model synthesis

@&#ABSTRACT@&#


               
               
                  In this paper we present a convenient building model synthesis method. It aims at obtaining new user-defined building models through seamless stitching after synthesis of each single building facade. During the optimization process of synthesis of each single building facade, we utilize model structure analysis method to obtain the smallest structural units and the constraint graph among them, transforming complicated three-dimension (3D) synthesis problem into two-dimension (2D) constraint graph synthesis problem. Then we construct a global energy function and minimize it through iterative optimization with expectation maximization algorithm, in order to obtain new objective constraint graph. During stitching process, in order to get complete model synthesis result, we replace objective constraint graph with structural unit to transform synthesis back into 3D space, and achieve automatic stitching between neighboring construction units and neighboring facades by using the connection point sets of structural units in original samples. The experiment results demonstrate our method can generate building models of absolutely different styles quickly and efficiently based on single or multiple samples, while maintaining the continuity and visual integrity of result models well.
               
            

@&#INTRODUCTION@&#

Since plenty of 3D building models are needed in the fields like 3D games, movies, and virtual reality, so how to generate these 3D models quickly and efficiently has become one of the most challenging problems in the field of computer graphics. Among the methods of generating 3D models, the most commonly used method is procedural modeling [1–3], which manually design the heuristic rules or parameters for creating models by experiences; however, this method is time-consuming and inconvenient to directly modify and edit the models. As the increasing appearance of plentiful sharable 3D models, constructing user-defined models based on the existing models has become a new direction in the modeling field, which has obtained a series of research achievements [4–9]. Such method can not only directly determine the pattern of models, but also simplify and accelerate the modeling process.

We propose a new modeling method for existing mesh building, which enables users to reuse already known building styles to create new contents very easily. Making use of the characteristic that most of building models are constructed from the stitching and combination of each separate facade, we transform the synthesis of building models into the seamless stitching of each single building facade after respective synthesis.

Aiming at key single building facade synthesis, we transform 3D synthesis into 2D synthesis of the 2D constraints between structural units (the constraints between structural units is defined as our constraint graph) by making use of the similarity between the structural unit repeatability (for example, a model includes multiple structural units like windows or doors, etc. of similar structure) and texture structure repeatability of building models, and by referring to the texture synthesis thought based on global optimization [10], constructing global energy function and solved it with optimization method, in order to obtain the objective constraint graph.

Aiming at seamless stitching, we solve the problem in two aspects: one is that the seamless stitching of the structural units included in each single facade after synthesis; and the other is that the seamless stitching of each neighboring facade. In this paper, an uniform framework is adopted to solve the above problems. Namely, the minimum distance between the connection point set in original examples of each structural unit and that of neighboring structural unit is used to achieve the automatic seamless stitching between neighboring structural units and neighboring facades.

The method proposed in this paper can achieve model synthesis based on both single example and multiple examples.

The main contributions of this paper are:
                        
                           •
                           According to the structural characteristics of building models, we have presented a new building model synthesis method. which aims at obtaining new user-defined building models through seamless stitching after synthesis of each single building facade. During single building facade synthesis, we have transformed complicated 3D model synthesis into simple 2D constraints synthesis and solved the problem based on the 2D constraints relationship between structural units of example model. During seamless stitching, we achieve automatic stitching of structural units based on the original connection point set of structural units and calculation of the minimum distance between point sets.

Our method provides a new way for building modeling synthesis, which significantly shorten the modeling time and avoid the creation process from scratch. Starting from single or multiple examples, users could create new building models with various styles based on existing building models. Our method not only enriches the means of modeling for professionals, but also enables non-professionals to enjoy the fun of modeling.

@&#RELATED WORK@&#

Example-based synthesis [7,10–15] has always been a hot-spot in computer graphics. In recent years, research on the reuse of existing model resources has also become an important topic of researches in 3D modeling field. Our method belongs to the above technology as well, so we will briefly narrate the methods for reusing existing models related to this paper.

In procedural modeling, researchers have achieved reuse of existing models by means of inverse procedural modeling, model synthesis, and inference-based procedural modeling, etc.

The inverse procedural modeling method proposed by Bokeloh et al. [4] uses symmetry analysis to detect regular patterns of the input model, and establishes the corresponding grammar system for every symmetric element; then the symmetric elements can then be used to infer a generative model. The model synthesis method proposed by Merrell and Manocha [9] later takes an existing model as input and generates many complex variations while following a local constraint, namely every point in the output is locally identical to some points in the input. Inference-based procedural modeling proposed by Biggers and Keyser [16] introduces user interactive mechanism in the phase of model analysis and generation, they sample and extract surface patches from input models, and develop a Petri net structure that describes the relationship between patches along an imposed parameterization, then they use the Petri net to generate a new model for a new parameterized line or curve given by user. An algebraic model is adopted by Bokeloh et al. [5] to express shape structure and develop a robust interactive system where user can rapidly obtain plausible shape variations by intuitively placing and moving a set of sparse handles. The modeling system established by Barroso et al. [17] introduces the concept of visual copy and paste, rewrites the rules for the existing models of procedural modeling by adding copy and paste operations during modeling, thus building new models.

All above methods generate new models by analyzing existing examples, but they describe models with abstract rules and parameters, so model builders have to be familiar with the rule system of models or parameter setting method, which is not easy for most common users.

In the research of reusing mesh models, researchers have achieved the reuse of pre-existing resources partially through component assembly technology.

Funkhouser et al. [18] have taken the lead in providing the example modeling method based on components assembly. It allows compositing of different parts from different input models to obtain a desired output. Later, Lee and Funkhouser [19] extends this method to support sketch-based search and synthesis. Kraevoy et al. [20] and Jain et al. [21] introduce component matching in synthesis process to improve the effectiveness of the component structure.

However, the result of modeling based on components assembly depends on the establishment of model database as well as the modularized splitting and matching results of models; meanwhile, this method considers the simple structural attribute of component connectivity, so the modeling result cannot maintain the structural characteristics of original models. In addition, its very difficult to obtain complete component information from building modeling, so such method cannot be applied to the construction of building models.

In the research of reusing mesh models in recent years, a modeling method based on structure preservation has been proposed. This method generally divides the example-based modeling process into two steps – model analysis and generation, and it is mostly applied to the reuse of building models.

Merrell [7] has taken the lead in utilizing the idea of example-based texture synthesis to propose a model synthesis method, which uses the self-similarity of a discrete example to generate large models that resemble the input model with the idea of enumeration. However, the method needs to manually segment the input model, which is a time-consuming process. In addition, because of the enumeration optimization used to maintain the structural consistency, the synthesis results produced by the method are only locally similar to the input. Cabral et al. [6] generate a new model based on the existing model quickly, but this method does not involve the problem of model segmentation, and the model used has already been divided, which makes the method limited. Similarly, the 3D building model redirection method proposed by Lin et al. [22] allows users to deal with some irregular models, but it requires user to interactively define the behavior attributes to partition the input model, which brings a lot of interaction. In addition, the method proposed by Bao et al. [23] can also achieve model synthesis by starting from single building facade, but this method divides single building facade semi-automatically, defining the constraints between split structures manually, and using heuristic search and quadratic programming alternatively by making use of such constraints to generate new solid layout of user-defined size. This method involves too much interaction, and the constraint graph will be presented by users, therefore requiring users to have certain modeling experiences.

The above-mentioned modeling methods based on structural maintenance are the most similar to the method proposed in this paper, but our method can obtain the repetitive or similar structural units included in modeling automatically through structure analysis, and achieve fast synthesis by means of global optimization; besides, it involves only little auxiliary interaction operation in the whole process. In addition, our method can achieve model synthesis based on both single example and multiple examples. Therefore, compared with the above methods, our method has lower requirements on the input models, having higher efficiency of synthesis, generating more abundant types of models.

The input in this paper is one or multiple mesh models, and our method can be used to automatically generate new building models which maintain the structure and shape characteristics of original models according to user-defined scale parameters. Our method mainly contains four stages: The stage of preprocessing, the stage of obtaining the 2D constraint graph of single facade to be synthesized, the stage of single building facade synthesis based on global optimization, and the stage of each building facade combination after synthesis. The basic flow of algorithm is shown as Fig. 1
                     .

Firstly, at the stage of preprocessing, users need to input the scale parameters of the models to be generated, namely the basic shape and size of the models to be synthesized, and interactively determine the area of each building facade participating in synthesis in example models.

Then, at the stage of obtaining the 2D constraint graph of single facade to be synthesized, we use the structural analysis method proposed by Pauly et al. [24] to automatically obtain the repetitive or similar smallest structural units included in this area and construct corresponding 2D constraint graph (refer to Section 4.1 for details).

Next, at the stage of single building facade synthesis based on global optimization, we firstly transform 3D model synthesis problem into 2D constraint graph synthesis problem, establishing corresponding synthesis energy function according to user-defined scale parameters and by using the 2D constraint graph obtained at the previous stage, and minimizing the objective constraint graph through iterative optimization with expectation maximization algorithm [25]; then we execute replacement of objective constraint graph by using the structural units included in example models and transform them back into 3D model space, and carry out seamless stitching of neighboring structural units to obtain corresponding 3D synthesis result. A building model includes at least four facades, so the above operation shall be conducted for each site to obtain the synthesis result of each facade (refer to Section 4.2 for details).

Finally, at the stage of each building facade combination after synthesis, we scale the part not participating in synthesis at the first stage according to user-defined scale parameters, and stitch them automatically with the result of each single facade synthesized to obtain the final 3D model (refer to Section 4.3 for details).

In this section, we will introduce the detail of each stage in our method, except for the preprocessing stage. User interaction is needed to determine the scale of models and the area of models that will participate in synthesis only in preprocessing stage, other stages will automatically complete the process without any interaction.

The model areas determined to participate in synthesis after preprocessing of the example models will include some repetitive or similar structural units (such as repetitive windows and doors), and we will use the constraint graph of these structural units to conduct synthesis. So, we shall carry out structural analysis on these example models, in order to obtain the smallest structural units included in the models and their constraint graph.

The existing methods for analysis of model structure are mainly divided into the following two types. The one type is structural analysis method based on manual splitting [9,22]. Such methods conduct interactive splitting according to users’ intention, and obtain the structural units demanded by users. But such methods involve too much interaction, which is inconvenient to operate. The other type of methods withdraws the smallest structural units in models automatically by using the self-similarity of model structure [4,24], which is widely applicable.

In this paper, the structure detection method proposed by Pauly et al. [24] is adopted to automatically obtain the smallest structural units, which are included in the facades to be synthesized. This method is adopted mainly because that, it enables the withdrawal of each structural unit included in the models, without any prior information on the shape or size, etc. of structural units. In consideration of that only the building models with translational repetitive structure are processed in this paper, we simplify this method and consider only translation similarity transformation.

With this method, we can obtain each structural unit included in the models quickly. For example, if we obtain the smallest structural units aiming at the blue single facade marked in Fig. 2
                        (a), we will obtain the result as shown in Fig. 2(b). In order to obtain the final 2D constraint graph, we need to label each structural unit. For example, the numerical value indicated in Fig. 2(b) is just the label of the structural unit obtained on it. Finally, by replacing the original location of each structural unit in examples with the labels, we could obtain corresponding 2D constraint graph, as shown in Fig. 2(c).

After obtaining the 2D constraint graph between structural units of example model, we could carry out single facade synthesis of models.

Firstly, we transform single facade synthesis of the model from 3D synthesis into 2D synthesis. Namely, with the existing 2D constraint graph as input, we synthesize new constraint graph as output result by means of synthesis and according to the size input by users at the stage of preprocessing. We discover that, this problem is similar to the problem which needs to be solved through texture synthesis, so we transform the above problem into energy optimization problem, and achieve automatic minimization with expectation maximization method [25] by referring to the idea of global optimization in texture synthesis [10].

Secondly, in order to obtain the final result of 3D model synthesis, we need to transform the 2D synthesis result back into corresponding 3D model, namely replace the elements in the constraint graph obtained from synthesis with the structural units they represent, and stitch them seamlessly to return to 3D model space and obtain complete 3D model. In this paper, by calculating the minimum distance between the connection point set of each structural unit in original example and that of neighboring structural unit, we achieve the seamless stitching of model.

The details about the realization of the algorithm will be introduced in the following.

We set the 2D constraint graph between the structural units of example models obtained in Section 4.1 as I, which is a 2D array, with every array point representing a structural unit in the example model; and we set the objective constraint graph to be obtained as O, which is initially an empty 2D array, with the size defined by users. Based on the aforementioned stipulations, the problem to be solved is just to generate O by making use of I, and to maintain the original neighborhood constraint graph of O in I to the greatest extent. This is quite analogous to texture synthesis, so we refer to the Ref. [10]. The synthesis problem mentioned above may be transformed into the following energy:
                              
                                 (1)
                                 
                                    E
                                    (
                                    O
                                    ,
                                    {
                                    
                                       
                                          I
                                       
                                       
                                          p
                                       
                                    
                                    }
                                    )
                                    =
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             p
                                             ∈
                                             
                                                
                                                   O
                                                
                                                
                                                   +
                                                
                                             
                                          
                                       
                                    
                                    dist
                                    (
                                    
                                       
                                          O
                                       
                                       
                                          p
                                       
                                    
                                    ,
                                    
                                       
                                          I
                                       
                                       
                                          p
                                       
                                    
                                    )
                                 
                              
                           where O indicates objective constraint graph; 
                              
                                 
                                    
                                       O
                                    
                                    
                                       p
                                    
                                 
                              
                            indicates a neighborhood of 
                              
                                 w
                              
                            in size and with array point 
                              
                                 p
                              
                            as the center in the objective constraint graph 
                              
                                 O
                                 ;
                                 
                                    
                                       I
                                    
                                    
                                       p
                                    
                                 
                              
                            indicates the neighborhood which is the most similar to 
                              
                                 
                                    
                                       O
                                    
                                    
                                       p
                                    
                                 
                              
                            in the example constraint graph 
                              
                                 I
                                 ;
                                 
                                    
                                       O
                                    
                                    
                                       +
                                    
                                 
                              
                            is a subset of O, and in order to ensure the continuity of model structure, the neighborhood determined by 
                              
                                 
                                    
                                       O
                                    
                                    
                                       +
                                    
                                 
                              
                            shall have certain overlap, so as to ensure that a number of neighborhoods can affect some given array point simultaneously. In this paper, 
                              
                                 
                                    
                                       O
                                    
                                    
                                       +
                                    
                                 
                              
                            is obtained at every 
                              
                                 |
                                 w
                                 /
                                 4
                                 |
                              
                            point among all the array points of O.

The energy function defined above indicates that, if every neighborhood in the objective constraint graph has a most similar neighborhood in the example constraint graph, the energy function value will be the minimum, and the objective constraint graph O has the strongest similarity with the example constraint graph I. This is almost the same as the texture synthesis in Ref. [10]. However, texture synthesis aims at the calculation of continuous pixel, while our constraint graph synthesis aims at discrete points, so some differences exist in concrete calculation process. Next, we will introduce the differences in calculation process in details.
                              
                                 (1)
                                 In the process of calculating inter-regional similarity, they make use of the color similarity of pixels, since the texture image processed in Ref. [10] consists of each pixel. The input in this paper is the constraint graph of each structural unit of 3D model, the numerical value in 2D array I is just the label of structural unit, and there is no other characteristic information, so we set that, the result is 0 if the numerical value of corresponding location is the same, or 1 if it is different when calculating the degree of similarity between 
                                       
                                          
                                             
                                                I
                                             
                                             
                                                p
                                             
                                          
                                       
                                     and 
                                       
                                          
                                             
                                                O
                                             
                                             
                                                p
                                             
                                          
                                       
                                    . The formula is shown as below:
                                       
                                          (2)
                                          
                                             dist
                                             (
                                             
                                                
                                                   O
                                                
                                                
                                                   p
                                                
                                             
                                             ,
                                             
                                                
                                                   I
                                                
                                                
                                                   p
                                                
                                             
                                             )
                                             =
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               1
                                                               ,
                                                            
                                                            
                                                               if
                                                               
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        
                                                                           o
                                                                        
                                                                        
                                                                           p
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               
                                                               ≠
                                                               
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        
                                                                           i
                                                                        
                                                                        
                                                                           p
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               0
                                                               ,
                                                            
                                                            
                                                               if
                                                               
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        
                                                                           o
                                                                        
                                                                        
                                                                           p
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                               =
                                                               
                                                                  
                                                                     (
                                                                     
                                                                        
                                                                           i
                                                                        
                                                                        
                                                                           p
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     k
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    where 
                                       
                                          
                                             
                                                (
                                                ·
                                                )
                                             
                                             
                                                k
                                             
                                          
                                       
                                     indicates dimension k of vector, 
                                       
                                          
                                             
                                                o
                                             
                                             
                                                p
                                             
                                          
                                       
                                     is the vectorized version of area 
                                       
                                          
                                             
                                                O
                                             
                                             
                                                p
                                             
                                          
                                       
                                    , and 
                                       
                                          
                                             
                                                i
                                             
                                             
                                                p
                                             
                                          
                                       
                                     is the vectorized version of area 
                                       
                                          
                                             
                                                I
                                             
                                             
                                                p
                                             
                                          
                                       
                                    . The above-mentioned formula is used to determine the degree of similarity between two areas by comparing the vectorized version of their corresponding location value. The result will be 0 if the corresponding location value is the same, otherwise it will be 1. The smaller the accumulated result is, the higher the degree of similarity between the two areas will be.

In the process of function minimization through iterative optimization with expectation maximization method [25], the algorithm requires certain overlapped area between neighboring areas; as shown in Fig. 3
                                    (b), the size of neighboring areas we adopt is 3*3. In current state, we explain corresponding calculation process with neighboring areas 
                                       
                                          
                                             
                                                O
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                O
                                             
                                             
                                                9
                                             
                                          
                                       
                                     in the objective constraint graph. Based on the definition of Formula (1), we require certain overlapping among the corresponding 9 areas. For processing of such areas, the original paper adopts the average value of pixel color for replacement aiming at texture image during optimization process; but as mentioned above, the numerical values input in 2D array represent concrete 3D structural units, they are not continuous, and cannot be replaced by average value. Therefore, such areas in this paper are processed according to the following rules:

If each area at a same location in overlapped area is numbered the same, we will use the label to assign the array point at this location; otherwise we will count the appearance frequency of each label possibly used to assign the location, and adopt the number appearing the most frequently to assign the array point at this location. For the sake of convenience, we will give an interpretation with the calculation process of the label for the green
                                       1
                                       For interpretation of color in Figs. 3 and 5, the reader is referred to the web version of this article.
                                    
                                    
                                       1
                                     location in Fig. 3(b) objective constraint graph. As shown in the figure, the nine neighborhoods in different colors with overlapped area will affect the label of this location. It is assumed that, the best matching of the nine neighborhoods here in the example constraints graph Fig. 3(a) is the area identified with corresponding color (
                                       
                                          
                                             
                                                I
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                I
                                             
                                             
                                                9
                                             
                                          
                                       
                                    ), the possible label of the green location will be 2, 2, 2, 2, 2, 3, 2, 2, 2 then according to our defined rule, the label 2 that appears most frequently will be selected as the current input number for this location.

The other processes of calculation with energy function are in accordance with that described in Ref. [10]. We minimize the energy function through iterative optimization with expectation maximization method [25] in order to obtain the final objective constraint graph O. Throughout the optimization process, the change of energy is generally as follows: at the beginning of iteration, the energy will decrease sharply, this is because we initialize the closest neighborhoods randomly, which will make the value of energy function large. Later on, the energy will reduce gradually, until convergence or the predefined number of iterations is reached. For example, aiming at the 2D constraint graph input in Fig. 4
                           (a), we could obtain the final objective constraint graph in Fig. 4(b) with our method.

The objective constraint graph we obtain after the abovementioned energy function calculation is still a 2D array, and each array point therein represents a structural unit, so in order to obtain the final 3D result, we shall firstly replace each array point in objective constraint graph with corresponding structural unit to make them back to 3D space. In addition, in order to ensure the completeness of final 3D model, we shall solve an important task, namely stitch neighboring structural units seamlessly, and make them become complete mesh model. Next, we will introduce corresponding transformation and connection process in details.

During the process of transformation back to 3D space, some constraints not existing in original example will be produced when the objective constraint graph is generated, namely the structural units not in the same row or column of example model will be arranged at the same row or column, and the size of each structural unit will possibly be different, in such case, if the label is replaced directly with structural unit, misplacement will appear between structural units. Therefore, in this paper, we need to scale structural units according to certain standard for subsequent stitching. Precisely, we determine the final scaling dimensions according to the appearance frequency of the label of each row and column in the objective constraint graph, namely we scale the other structural units in the same row or column according to the height and length of the structural unit appearing the most frequently. After uniform scaling of all structural units in the objective constraint graph, we could replace the label and make the synthesis result transformed back into corresponding 3D space.

In order to obtain complete mesh model, we still need to stitch neighboring structural units seamlessly. In synthesis result, most neighboring structural units have connected relation in original examples, and need not to be connected, so we only need to process the neighboring structural units without constraint relation in original examples.

For such situation, we firstly calculate the connection point set of the boundaries to be connected in each structural unit in this paper. The connection point set of a structural unit indicates the common point set of this constructural unit and its neighboring structural units in original model, namely what described with this point set is the method for connecting this structural unit with its neighboring structural units. For example, the points marked with oval in Fig. 5
                           (a) and (b) are just the connection point set of the present structural unit. Then, we achieve the connection of meshes by calculating the correspondence between the connection point sets of neighboring structural units; and in this paper, we determine the connected relation between point sets by calculating the minimum distance from the set of fewer connection points to the set of more connection points in structural units.

The detailed calculation process is interpreted in Fig. 5. Its assumed that, the two neighboring structural units to be connected currently are Fig. 5(a) and (b), and the connection point sets calculated are Set A and Set B (the points marked with oval in Fig. 5(a) and (b)), our objective is to calculate the corresponding point 
                              
                                 f
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            in Set B of any point 
                              
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       ix
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       iy
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       iz
                                    
                                 
                                 )
                              
                            in Set A, and merge the two points. Wherein, the calculation formula of 
                              
                                 f
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                            is as shown below:
                              
                                 (3)
                                 
                                    f
                                    (
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    =
                                    
                                       
                                          argmin
                                       
                                       
                                          
                                             
                                                b
                                             
                                             
                                                j
                                             
                                          
                                          ∈
                                          B
                                       
                                    
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      ix
                                                   
                                                
                                                -
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      jx
                                                   
                                                
                                                )
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      iy
                                                   
                                                
                                                -
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      jy
                                                   
                                                
                                                )
                                             
                                             
                                                2
                                             
                                          
                                          +
                                          
                                             
                                                (
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      iz
                                                   
                                                
                                                -
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      jz
                                                   
                                                
                                                )
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    
                                       a
                                    
                                    
                                       ix
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       iy
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       iz
                                    
                                 
                              
                            are the coordinates of current point 
                              
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                              
                            in Set A, while 
                              
                                 
                                    
                                       b
                                    
                                    
                                       jx
                                    
                                 
                                 ,
                                 
                                    
                                       b
                                    
                                    
                                       jy
                                    
                                 
                                 ,
                                 
                                    
                                       b
                                    
                                    
                                       jz
                                    
                                 
                              
                            are the coordinates of arbitrary point 
                              
                                 
                                    
                                       b
                                    
                                    
                                       j
                                    
                                 
                              
                            in Set B. The meaning of this formula is just to obtain the corresponding relation of each point in Set A with each point in Set B by calculating the minimum distance. For example, in Fig. 5(b), the points discovered that have the minimum distance from every corresponding point marked with oval in Fig. 5(a) are marked with oval of the same color.

In order to maintain the smoothness of the structural units after stitching, we adopt the following principles in the merging process: if the minimum distance between the two matching points is less than the given threshold, we merge these two points into one, i.e. we change the positions of points in structural unit B to the corresponding point in structural unit A (points marked in red, brown and orange in Fig. 5(c) are of this type). Otherwise we keep their original positions, respectively. The remaining points in set B which failed to search their matching ones (the points marked in blue in Fig. 5(b)) will also retain their original positions (Fig. 5(c) shows the merging result, the position of the blue point remains unchanged). We choose the threshold mentioned in the merging process as below: firstly, by sorting all the minimum distances between the matching points, we get the minimum and maximum ones. Then, we compare these two distances, if they are close to each other, we will merge all the rest of the point pairs, namely the threshold is set to slightly greater than the maximum distance. Otherwise, the threshold will be set as the mean value of the maximum and minimum distances. For all structural units to be connected, we may obtain the final complete mesh model by repeating the above process.

The result of transformation from objective constraint graph to 3D model is shown as Fig. 6
                           . Fig. 6(a) shows the facade of example model to be synthesized with the area marked in blue as input; Fig. 6(b) shows the result of objective constraint graph obtained aiming at the area in Fig. 6(b) and the label of each structural unit; Fig. 6(c) shows the 3D model result obtained through transformation; and Fig. 6(d) shows the triangular mesh model originated from single facade synthesis in Fig. 6(c). Obviously, the method proposed in this paper can not only realize single-facade synthesis, but also maintain the completeness of models well.

After the above operations, we obtain the synthesis result of only one facade in building model actually, but each building model has at least four facades. As shown in Fig. 7
                        (a), the blue area marked as Y is just the four single building facades included in the example sample. We need to synthesize each building facade separately with the method introduced in Section 4.2 according to user-defined size (Fig. 7(b) shows user-defined objective model), and the result is shown as the orange frame of Fig. 7(c).

In addition, except to the areas participating in synthesis, the example model possibly includes some areas not participating in synthesis, and these areas generally exclude repetitive structural units, such as the roof or floor of example building model, such as the area marked as S in Fig. 7(a). We often obtain such areas through manual division of examples. In order to ensure the completeness of model as the final result, we shall scale these areas correspondingly according to the size input by users at the stage of preprocessing, with the result as shown in the red frame of Fig. 7(c).

Finally, in order to obtain final complete model, we need to stitch the structural units neighboring to the boundary of each facade with the stitching method provided in Section 4.2.2, as shown in Fig. 7(d), and the result obtained is just the final model synthesis result obtained according to user-defined size.

In the previous section, we achieve the model synthesis based on single example. Our method combines each single facade after separate synthesis according to user-defined size, so it can be easily expanded to the model synthesis based on multiple examples. Namely, users may provide multiple example building models, specifying the areas participating in synthesis of each model and the size to be obtained, and marking the area from which the synthesis result of corresponding area will be obtained. In such case, we could synthesize each area separately according to users’ requirements with the method proposed in Section 4, and then stitch each area after synthesis.

The difference from the model synthesis based on single example is that, a same facade of the objective model possibly comes from different example models, while each facade in original examples will not be on a same plane initially, namely there is rotation, so before combination, we need to carry out corresponding rotation according to the information on source of walls in each part to make them on a same plane.


                     Fig. 8
                      shows the process of model synthesis based on multiple examples. Fig. 8(a) shows each input example model, and the areas marked with different colors participate in objective model synthesis; Fig. 8(b) shows the user-defined objective model, and the areas marked with different colors are the corresponding results to be obtained from different example model areas, with color corresponding to that in Fig. 8(a), namely the areas marked in the same color shall obtain the synthesis result from the example areas marked in corresponding color; Fig. 8(c) shows the single facade synthesis result of each synthesis area and the scaling result of non-synthesis area; and Fig. 8(d) shows the final synthesis result. Obviously, based on multiple examples, we could synthesize new building models.

In this section, we first present corresponding experiment results. Then, we compare our method with related works. At last, we analyze the limitation of our method.

In this paper, we realize relevant algorithm at PC computer based on C++ language. The environment for program operation is Windows 7, and the computer configuration is Intel Core 2 Duo E7300 3.1GHz CPU, 4GB memory. In order to verify the validity of our method, we have experimented multiple building models.


                        Fig. 9
                         presents the results of a series of model synthesis experiments. Where, the building marked in orange is the input model, while that marked in blue is the model synthesized with our method and according to user-defined style. Fig. 9(a)–(d) shows the results of model synthesis based on single example, and Fig. 9(e) and (f) shows the results of model synthesis based on multiple examples. Observing from the experimental results that whether complex or simple models, as long as it has having intrinsic self-similarity, we could synthesize it into similar objective models based on single or multiple examples with our method, and the scale and style of synthesis may be changed at random according to users’ input requirements.

We also analyzes the synthesis time. In the process of synthesis based on single example, once the attribute of input example model is marked, the next major work is just structural analysis, single facade synthesis of models based on global optimization, and area combination.

The time for structural analysis is mainly affected by the number of vertexes of input model. The structural analysis method adopted herein will sample the data points firstly when processing big data, in order to reduce the data points to be processed. In this way, for any input model, the data processed at the stage of structural analysis may be controlled at below 30,000–40,000, and it takes around 3min to process every model of this type.

The time for single-facade synthesis of global optimization model depends on the size of finally generated models (including the size of objective constraint graph and the complicity of every structural unit), and it mainly includes two parts: in the process of obtaining objective constraint graph, 2D synthesis is conducted, so the time taken is relatively short and only around 10s; in the process of transformation from objective constraint graph to 3D model, the time for replacement of structural units is not long, but the time consumed for stitching of structural units is relatively long, and according to the results (including 92,650 vertexes, 135,414 triangular patches, 6*6 matrix of the Example 2D constraint graph, and 15*8 matrix of objective constraint graph) of single-facade synthesis of the largest model in the experiment involved in this paper, the time consumed is about 2min.

Areas combination process is similar to the stitching of structural units after replacement of objective constraint graph, so the time consumed is basically close, and the time taken for the combination of a model is also around 2min.

In the experiment of model synthesis based on multiple examples, the main synthesis steps are similar to the model synthesis based on single example, so the execution time is close to that for synthesis based on single example, except that users’ interaction is more than that in synthesis based on single example, and its necessary to specify multiple synthesis areas participating in calculation.

Our method is similar to [7] in many aspects. Both are used to synthesize 3D models based on texture synthesis thought, and the input models processed with them have self-similarity structure, and their final objective is to synthesize models similar to input examples. However, the two methods have many absolutely different points. Firstly, model synthesis method finishes splitting of model examples manually, which is a very time-consuming process; the number of structural unit is different along with the difference of splitting results, and this will further affect the later enumeration optimization. In this paper, we split models automatically through structural detection by making use of models’ self-similarity. For the same model, the splitting result will be unique. In addition, it may be known from the previous analysis that, no matter whether the model is complicated or simple, the time may be controlled within a certain scope with the structural analysis method. Secondly, model synthesis method ensures the consistency of neighboring structural units through enumeration-based optimization, so the objective models synthesized with it are only locally similar to the input models, while in this paper, we carry out global optimization, and consider the final objective models from both local and global. However, model synthesis method is better than our method in some aspects. For example, its method can synthesize large-scale scenes, but our method can only expand the scale and style of model at present, but does not have the function of scene synthesis. So, this is a direction of our research in future.

The overall thought of the method proposed by Bao et al. [23] is extremely similar to our method, and both they synthesize the final building models by starting from a single facade of models. However, there exist some differences. Firstly, at the step of model analysis, they adopt the semi-automatic method proposed by Musialski et al. [26] to split the input into rectangular areas with layered tree-shaped structure; this expression method makes the input not restricted from mesh-like shape, but it requires plentiful interaction of users to obtain such structure. In this paper, we adopt the structural detection method proposed by Pauly et al. [24] to split the input automatically without users’ interaction. Secondly, at the step of model synthesis, their method requires the input of higher-level semantic information through users’ interaction in order to obtain the constraints between split areas, and to realize the synthesis of models according to such constraints; while in this paper, the synthesis process does not need the semantic information of structural units, but instead, we may obtain the synthesis result by applying global optimization algorithm according to the simple neighborhood constraint graph obtained from detection of structural units, and the algorithm realization is relatively simple, without higher requirements on users. In addition, Bao et al.’s method is not applicable to the synthesis based on multiple examples, since when examples are sourced from different models, its very difficult to define the high-level semantic constraint relationship between different model areas, while our method can realize model synthesis based on multiple samples very conveniently.

Another work [22] related to this paper is also about the processing of mesh models. It allows interactive retargeting after some heavy user-assisted hierarchical analysis. Interactive segmentation makes it capable of tackling irregular patterns. And a 3D architectural model can be interactively scaled to different dimensions. But it has an apparent disadvantage of the large amount of interaction. Additionally, the result of splitting based on users’ interaction will produce heavy impact on the effect of final model synthesis. In this paper, structural detection is adopted for automatic splitting without interaction. And the synthesis is also non-interactive, taking about 2min to do for each set of box scaling parameters. In addition, retargeting method is only to realize reproductive growth in several directions according to users’ splitting and based on original models, and the final synthesized model does not destroy the original connected relation, so stitching between structural units is unnecessary. In this paper, model synthesis problem is transformed into energy optimization problem, and the synthesis result is random at certain degree, so we need to complete the stitching of structural units without constraint graph in original models. However, just for the existence of randomness, our method can finally synthesize many models of the same scale but different contents, and provide more options for users. The method proposed by Lin et al. is better than our method in some aspects. Because of the introduction of interaction, they can handle irregular structures, while our automatic analysis method cannot possibly deal with. As a result, their method is more general and can produce richer variation than ours. So, to automatically tackle irregular structures is a direction of our future work.

Our method can be applied to model synthesis based on both single example and multiple examples. This is similar to the visual copy and paste for procedural building models, as proposed by Barroso et al. [17] Both methods can generate final objective models from multiple example models, but the method of visual copy and paste for procedural building models aims at procedural modeling models, and its input is the building models based on grammar rules, while such models are generally generated by professionals with special tools, and such method only copies the part selected in example models, but does not produce new structural contents. For our method in the paper, the input is triangular mesh models; relative to procedural modeling models, this method is easier to obtain and be understood by users, and also, our method may be used to synthesize many different but similar new structural contents based on original models, and has more abundant synthesis styles.

@&#LIMITATIONS@&#

We adopt EM method for iterative solution in global optimization. The essence of EM method is to ensure the continuity of model structure through the adjacency of each structural unit, and this will restrict the part participating in single-facade synthesis in example samples processed by us. Also, the 2D constraint graph obtained after structural analysis must be shaped similar to grid; otherwise it will be impossible to make clear the adjacency between structural units and get the objective constraint graph, leading to unable to complete single-facade synthesis of models. The EM method used in the optimization process could get stuck in local minima, which will also affect the synthesis effect.

Secondly, in order to ensure the continuity of model structure, a certain overlapped area is required between the neighborhood areas of objective constraint graph during the minimization of the energy function established. As a result, we cannot generate building models of only one row or one column.

In addition, in this paper, the final building model is obtained by combining the result of each single facade synthesis, while this combination method can produce only a certain angle, but not a radian, between building facades, so we cannot synthesize building models with radian.

In this paper, we propose a model synthesis method based on the optimization and recombination of single building facade, which transforms model synthesis problem into the stitching after optimization synthesis of each single building facade. This method can achieve model synthesis based on not only single example, but also multiple examples, producing synthesis results of absolutely different styles, and maintaining the continuity of example model structure and the completeness of visual effect well. Our method provides a new way for building modeling synthesis, which significantly shorten the modeling time and avoid the creation process from scratch, enriching the means of modeling for professionals, and assisting non-professionals to enjoy the fun of modeling.

Although Our method does not have high requirements on the complicity of 3D example models, but can only handle the models with self similarity and similar to buildings; if a model does not have self similarity, it will be impossible to withdraw structural units with the structural analysis method adopted herein, and to carry out subsequent other operations. In future, its expected to solve the above problems through structural analysis on models by adopting other characteristics (such as symmetry and structure) [27], and to expand the types of example models. In addition, the quality of model synthesis with the existing methods is directly judged by people visually. We hope to give objective and quantitative evaluation on the quality of synthesis.

@&#ACKNOWLEDGMENTS@&#

We would like to thank all anonymous reviewers for their constructive comments. This research has been supported by the National Science Foundation of China (61321491, 61100110, 61272219) and the Science and Technology Program of Jiangsu Province (BY2012190, BY2013072-04).

@&#REFERENCES@&#

