@&#MAIN-TITLE@&#Robust image hashing with embedding vector variance of LLE

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We investigate the use of LLE in image hashing.


                        
                        
                           
                           We find that embedding vector variances of LLE are approximately linearly changed by content-preserving operations.


                        
                        
                           
                           We propose a robust image hashing based on this LLE property.


                        
                        
                           
                           Our hashing outperforms some notable algorithms in classification performances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Image hashing

Robust hashing

Locally linear embedding

Data reduction

Secondary image

CIE 




                        




                           




                              L




                           




                           




                              ⁎




                           




                        




                        




                           




                              a




                           




                           




                              ⁎




                           




                        




                        




                           




                              b




                           




                           




                              ⁎




                           




                        




                      color space

@&#ABSTRACT@&#


               
               
                  Locally linear embedding (LLE) has been widely used in data processing, such as data clustering, video identification and face recognition, but its application in image hashing is still limited. In this work, we investigate the use of LLE in image hashing and find that embedding vector variances of LLE are approximately linearly changed by content-preserving operations. Based on this observation, we propose a novel LLE-based image hashing. Specifically, an input image is firstly mapped to a normalized matrix by bilinear interpolation, color space conversion, block mean extraction, and Gaussian low-pass filtering. The normalized matrix is then exploited to construct a secondary image. Finally, LLE is applied to the secondary image and the embedding vector variances of LLE are used to form image hash. Hash similarity is determined by correlation coefficient. Many experiments are conducted to validate our efficiency and the results illustrate that our hashing is robust to content-preserving operations and reaches a good discrimination. Comparisons of receiver operating characteristics (ROC) curve indicate that our hashing outperforms some notable hashing algorithms in classification between robustness and discrimination.
               
            

@&#INTRODUCTION@&#

Nowadays, the popularization of imaging device, such as smart cell phone, digital camera and scanner, provides us more and more digital images. Consequently, efficient techniques are needed for storing and retrieving hundreds of thousands of images. Meanwhile, it is easy to copy, edit and distribute images via powerful tools and the Internet. Therefore, digital right management (DRM) (image authentication, image forensics, copyright protection, etc.) is in demand. All these practical issues lead to emergence of image hashing. Image hashing is a novel technology for mapping input image into a short string called image hash. It not only allows us to retrieve images from large-scale database, but also can be applied to DRM. In fact, it has been widely used in image authentication [1], digital watermarking [2], image copy detection, tamper detection, image indexing [3], image retrieval, image forensics [4], and image quality assessment [5].

Generally, image hashing has two basic properties [6–8]. The first one is perceptual robustness. It requires that, for those visually identical images, image hashing should generate the same or very similar image hashes no matter whether their digital representations are the same or not. This means that image hashing must be robust against content-preserving operations, such as JPEG compression, brightness adjustment, contrast adjustment, watermark embedding and image scaling. The second property is called discrimination. This implies that, image hashing should extract different hashes from different images. In other words, similarity between hashes of different images should be small enough. Note that the two properties contradict with each other [8]. The first property requires robustness under small perturbations, whereas the second property amounts to minimization of collision probability for images with different contents. High performance algorithms should reach a good trade-off between the two properties. In addition to the basic properties, image hashing should have another property when it is applied to specific applications. For example, it should be key-dependent for image authentication [9].

Due to the wide use of image hashing, many researchers have paid attention to hashing techniques. For example, Venkatesan et al. [10] exploited statistics of discrete wavelet transform (DWT) coefficients to generate image hashes. This hashing is robust to JPEG compression and small-angle rotation, but sensitive to gamma correction and contrast adjustment. Lefebvre et al. [11] pioneered the use of Radon transform (RT) to hash extraction. This scheme can resist geometric transform, such as rotation and scaling, but its discriminative capability is limited. Kozat et al. [12] viewed images and attacks as a sequence of linear operators and presented an image hashing with two singular value decompositions (SVDs). The SVD–SVD hashing can tolerate geometric transform at the cost of significantly decreasing discrimination. In another study, Swaminathan et al. [13] proposed to calculate image hashes based on coefficients of Fourier–Mellin transform. This algorithm is robust against moderate geometric transforms and filtering. Monga and Mihcak [14] were the first to use non-negative matrix factorization (NMF) to derive image hashing. This method is robust against many popular digital operations, but sensitive to watermark embedding. Tang et al. [15] found invariant relation in the NMF coefficient matrix and exploited it to design hashing. This scheme is resistant to JPEG compression and watermark embedding, but sensitive to image rotation. In another work, Ou et al. [16] used RT combining with discrete cosine transform (DCT) to generate image hashes. The RT–DCT hashing is resilient to image rotation, but its discrimination is not good enough. Kang et al. [17] introduced a compressive sensing-based image hashing. This method is also sensitive to image rotation. Recently, Sun et al. [18] presented a robust image hashing by using relations in the weight matrix of locally linear embedding (LLE). This LLE-based hashing can tolerate JPEG compression, but is fragile to rotation and its discrimination is also not good enough. Tang et al. [19] exploited structural features to extract image hashes and introduced a novel similarity metric for tampering detection. This method is also sensitive to image rotation. In [20], Li et al. extracted image hashes by random Gabor filtering (GF) and dithered lattice vector quantization (LVQ). The GF–LVQ hashing has better performances than the well-known algorithms [13,17], but its discrimination is also not desirable enough. Zhao et al. [21] exploited Zernike moments (ZM) to calculate image hashes. The ZM-based hashing only tolerates rotation within 5°. Tang et al. [22] investigated the use of color vector angle (CVA) and then exploited CVA and DWT to design image hashing. The CVA–DWT hashing is also robust to rotation within 5°, but its discrimination can be improved.

Although many hashing algorithms have been reported, there are still some problems in hashing design. For example, more efforts are still needed for developing high performance algorithms reaching a desirable balance between robustness and discrimination. In this work, we propose a novel LLE-based image hashing, which can achieve a good trade-off between robustness and discrimination. The key technique of our work is an innovative use of LLE, which is based on the property that embedding vector variances are approximately linearly changed by content-preserving operations. Since LLE can efficiently learn global structure of nonlinear manifolds and discover compact representations of high-dimensional data, the use of LLE provides our hashing a good discrimination. Many experiments are conducted to validate the efficiency of our hashing. The results illustrate that our hashing is robust against popular digital operations and reaches a good discrimination. Comparisons indicate that our hashing outperforms some notable algorithms in classification between robustness and discrimination.

The rest of this paper is organized as follows. Section 2 introduces the proposed image hashing. Section 3 presents experimental results and Section 4 discusses performance comparisons. Finally, conclusions are drawn in Section 5.

Our proposed image hashing is a three-step method, whose block diagram is presented in Fig. 1
                     . In the first step, our hashing converts input image into a normalized matrix by preprocessing. In the second step, our method constructs a secondary image from the normalized matrix. Finally, we apply LLE to the secondary image and exploits LLE results to produce image hash. Details of these steps are described as follows.

To make a normalized image for constructing secondary image, some digital operations are applied to the input image. Firstly, bilinear interpolation is used to resize the input image to a standard size 
                           M
                           ×
                           M
                        , which makes our method robust against image rescaling. For RGB color image, the resized image is then converted into CIE 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                           
                              
                                 a
                              
                              
                                 ⁎
                              
                           
                           
                              
                                 b
                              
                              
                                 ⁎
                              
                           
                         color space and the 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         component is taken for representing the resized image. Here, we choose 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         component for image representation. This is based on the consideration that, CIE 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                           
                              
                                 a
                              
                              
                                 ⁎
                              
                           
                           
                              
                                 b
                              
                              
                                 ⁎
                              
                           
                         color space is perceptually uniform and the 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         component closely matches human perception of lightness [23,24]. For each image pixel, let 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         be color lightness, 
                           
                              
                                 a
                              
                              
                                 ⁎
                              
                           
                         and 
                           
                              
                                 b
                              
                              
                                 ⁎
                              
                           
                         be chromaticity coordinates, respectively. Thus, color space conversion [23] can be done by the following rules.
                           
                              (1)
                              
                                 
                                    
                                       L
                                    
                                    
                                       ⁎
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             116
                                             
                                                
                                                   (
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   /
                                                   
                                                      
                                                         Y
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   )
                                                
                                                
                                                   1
                                                   /
                                                   3
                                                
                                             
                                             −
                                             16
                                             ,
                                          
                                          
                                             if
                                             
                                             
                                                
                                                   Y
                                                
                                                
                                                   1
                                                
                                             
                                             /
                                             
                                                
                                                   Y
                                                
                                                
                                                   0
                                                
                                             
                                             >
                                             0.008856
                                          
                                       
                                       
                                          
                                             903.3
                                             (
                                             
                                                
                                                   Y
                                                
                                                
                                                   1
                                                
                                             
                                             /
                                             
                                                
                                                   Y
                                                
                                                
                                                   0
                                                
                                             
                                             )
                                             ,
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       a
                                    
                                    
                                       ⁎
                                    
                                 
                                 =
                                 500
                                 
                                    [
                                    f
                                    (
                                    
                                       
                                          X
                                       
                                       
                                          1
                                       
                                    
                                    /
                                    
                                       
                                          X
                                       
                                       
                                          0
                                       
                                    
                                    )
                                    −
                                    f
                                    (
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    /
                                    
                                       
                                          Y
                                       
                                       
                                          0
                                       
                                    
                                    )
                                    ]
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       b
                                    
                                    
                                       ⁎
                                    
                                 
                                 =
                                 200
                                 
                                    [
                                    f
                                    (
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    /
                                    
                                       
                                          Y
                                       
                                       
                                          0
                                       
                                    
                                    )
                                    −
                                    f
                                    (
                                    
                                       
                                          Z
                                       
                                       
                                          1
                                       
                                    
                                    /
                                    
                                       
                                          Z
                                       
                                       
                                          0
                                       
                                    
                                    )
                                    ]
                                 
                              
                           
                         where 
                           
                              
                                 X
                              
                              
                                 0
                              
                           
                           =
                           0.950456
                        , 
                           
                              
                                 Y
                              
                              
                                 0
                              
                           
                           =
                           1.0
                         and 
                           
                              
                                 Z
                              
                              
                                 0
                              
                           
                           =
                           1.088754
                         are the CIE XYZ tristimulus values of the reference white point, 
                           f
                           (
                           t
                           )
                         is defined as:
                           
                              (4)
                              
                                 f
                                 (
                                 t
                                 )
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   1
                                                   /
                                                   3
                                                
                                             
                                             ,
                                          
                                          
                                             if
                                             
                                             t
                                             >
                                             0.008856
                                          
                                       
                                       
                                          
                                             7.787
                                             t
                                             +
                                             16
                                             /
                                             116
                                             ,
                                          
                                          
                                             otherwise
                                          
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 X
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 Z
                              
                              
                                 1
                              
                           
                         are the CIE XYZ tristimulus values [24], which are calculated by the equation.
                           
                              (5)
                              
                                 
                                    [
                                    
                                       
                                          
                                             
                                                
                                                   X
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   Y
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   Z
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                    
                                    ]
                                 
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             0.4125
                                          
                                          
                                             0.3576
                                          
                                          
                                             0.1804
                                          
                                       
                                       
                                          
                                             0.2127
                                          
                                          
                                             0.7152
                                          
                                          
                                             0.0722
                                          
                                       
                                       
                                          
                                             0.0193
                                          
                                          
                                             0.1192
                                          
                                          
                                             0.9502
                                          
                                       
                                    
                                    ]
                                 
                                 
                                    [
                                    
                                       
                                          
                                             R
                                          
                                       
                                       
                                          
                                             G
                                          
                                       
                                       
                                          
                                             B
                                          
                                       
                                    
                                    ]
                                 
                              
                           
                         where R, G and B are the red, blue and green components of each image pixel, respectively.

Next, the 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         component is divided into non-overlapping blocks with a small size 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                           ×
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                        . For simplicity, let M be the integral multiple of 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                        , and 
                           
                              
                                 M
                              
                              
                                 1
                              
                           
                           =
                           M
                           /
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                        . Thus, to make an initial compression, we calculate block mean and use these means to construct a feature matrix as follows.
                           
                              (6)
                              
                                 F
                                 =
                                 
                                    [
                                    
                                       
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   1
                                                   ,
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   1
                                                   ,
                                                   2
                                                
                                             
                                          
                                          
                                             .
                                             .
                                             .
                                          
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   1
                                                   ,
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   2
                                                   ,
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   2
                                                   ,
                                                   2
                                                
                                             
                                          
                                          
                                             .
                                             .
                                             .
                                          
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   2
                                                   ,
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             .
                                             .
                                             .
                                          
                                          
                                             .
                                             .
                                             .
                                          
                                          
                                             .
                                             .
                                             .
                                          
                                          
                                             .
                                             .
                                             .
                                          
                                       
                                       
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   1
                                                
                                             
                                          
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   2
                                                
                                             
                                          
                                          
                                             .
                                             .
                                             .
                                          
                                          
                                             
                                                
                                                   μ
                                                
                                                
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         M
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    ]
                                 
                              
                           
                         where 
                           
                              
                                 μ
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                         is the mean of the block in the i-th row and the j-th column of the 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         component (
                           1
                           ≤
                           i
                           ≤
                           
                              
                                 M
                              
                              
                                 1
                              
                           
                        , 
                           1
                           ≤
                           j
                           ≤
                           
                              
                                 M
                              
                              
                                 1
                              
                           
                        ). This operation not only achieves initial compression, but also makes our method resistant to small-angle rotation, which can be understood as follows. Although small-angle rotation will alter pixel positions, pixels in a small region have similar values and then block means will not be significantly changed. Note that a big block size helps to improve robustness against large-angle rotation. But a bigger block size leads to fewer features in F, which will inevitably hurt discrimination. In experiments, we choose 
                           2
                           ×
                           2
                         as block size, which can reach a desirable balance between robustness and discrimination. Finally, a rotationally symmetric Gaussian low-pass filter is applied to the matrix F. This is to reduce the influence of digital operations on F. In practice, the element of Gaussian low-pass filter can be calculated by:
                           
                              (7)
                              
                                 G
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             G
                                          
                                          
                                             (
                                             1
                                             )
                                          
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             ∑
                                          
                                          
                                             j
                                          
                                       
                                       
                                          
                                             G
                                          
                                          
                                             (
                                             1
                                             )
                                          
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                    
                                 
                              
                           
                         in which 
                           
                              
                                 G
                              
                              
                                 (
                                 1
                                 )
                              
                           
                           (
                           i
                           ,
                           j
                        ) is defined as
                           
                              (8)
                              
                                 
                                    
                                       G
                                    
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 (
                                 i
                                 ,
                                 j
                                 )
                                 =
                                 
                                    
                                       e
                                    
                                    
                                       
                                          
                                             −
                                             (
                                             
                                                
                                                   i
                                                
                                                
                                                   2
                                                
                                             
                                             +
                                             
                                                
                                                   j
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                          
                                          
                                             2
                                             
                                                
                                                   σ
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                         where σ is a given standard deviation of the Gaussian distribution. For example, if the filter size is 
                           3
                           ×
                           3
                        , 
                           −
                           1
                           ≤
                           i
                           ≤
                           1
                        , and 
                           −
                           1
                           ≤
                           j
                           ≤
                           1
                        . Fig. 2
                         presents an instance of the preprocessing with 
                           M
                           =
                           512
                        , 
                           
                              
                                 s
                              
                              
                                 1
                              
                           
                           =
                           2
                        , and 
                           3
                           ×
                           3
                         filter size, where (a) is the original input image, (b) is the resized image, (c) is the 
                           
                              
                                 L
                              
                              
                                 ⁎
                              
                           
                         component of (b), (d) is the matrix F, and (e) is its blurred version.

To construct a secondary image for data reduction, we randomly select N blocks sized 
                           n
                           ×
                           n
                         from F under the control of a secret key. We view each block as a high dimensional vector of size 
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           ×
                           1
                         via concatenating block entries column by column. Let 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         be the corresponding vector of the i-th block (
                           1
                           ≤
                           i
                           ≤
                           N
                        ). Thus, we can obtain the secondary image X as follows.
                           
                              (9)
                              
                                 X
                                 =
                                 [
                                 
                                    
                                       x
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       N
                                    
                                 
                                 ]
                              
                           
                         Note that, during block selection, there can exist overlapping region between blocks. However, the same selected blocks should be discarded since the same vectors are not expected in the secondary image. Compared with the input image, the secondary image has fewer columns. As column number is equal to vector number that is kept unchanged during data reduction, a small vector number helps to make a short image hash. Fig. 3
                         is the schematic diagram of secondary image construction.

Locally linear embedding (LLE) [25] is a well-known algorithm for non-linear dimensionality reduction. It can efficiently discover compact representations of high-dimensional data by computing low-dimensional, neighborhood-preserving embeddings and learning global structure of nonlinear manifolds, such as those generated by face images or text documents [25]. LLE has been indicated better performances than some popular methods, such as principal component analysis (PCA) [26] and multidimensional scaling (MDS) [27]. Actually, LLE has been widely used in many applications, such as data clustering [28], video identification [29], gait analysis [30] and face recognition [31].

The classical LLE algorithm [25] consists of three steps, i.e., neighbor selection, weight calculation, and low-dimensional embedding vector computation. For simplicity, suppose that 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         is a vector of dimensionality D, where 
                           D
                           =
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                         and 
                           1
                           ≤
                           i
                           ≤
                           N
                        . Thus, details of these steps are illustrated as follows.

(1) Neighbor selection. For each vector 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         
                        
                           (
                           1
                           ≤
                           i
                           ≤
                           N
                           )
                        , its K nearest neighbors are chosen. This can be determined by Euclidean distance between 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         and the other vector 
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                         (
                           1
                           ≤
                           j
                           ≤
                           N
                         and 
                           j
                           ≠
                           i
                        ) as follows.
                           
                              (10)
                              
                                 U
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                          
                                             l
                                             =
                                             1
                                          
                                          D
                                       
                                       
                                          
                                             [
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             (
                                             l
                                             )
                                             −
                                             
                                                
                                                   x
                                                
                                                
                                                   j
                                                
                                             
                                             (
                                             l
                                             )
                                             ]
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                         where 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           (
                           l
                           )
                         and 
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                           (
                           l
                           )
                         are the l-th elements of 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                        , respectively. Thus, those vectors corresponding to the K smallest distances are the K nearest neighbors of 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                        .

(2) Weight computation. Calculate the weight matrix 
                           W
                           =
                           
                              
                                 (
                                 
                                    
                                       W
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 )
                              
                              
                                 N
                                 ×
                                 K
                              
                           
                        . The weight matrix can best linearly reconstruct 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         from its nearest neighbors, and the reconstruction errors are computed by the following cost function ε.
                           
                              (11)
                              
                                 ε
                                 (
                                 W
                                 )
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    
                                       |
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       −
                                       
                                          ∑
                                          j
                                       
                                       
                                          
                                             W
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       
                                          
                                             x
                                          
                                          
                                             j
                                          
                                       
                                       |
                                    
                                    
                                       2
                                    
                                 
                              
                           
                         where 
                           
                              
                                 W
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                         is the weight between 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                        . In practice, W can be calculated by minimizing the Eq. (11) subject to two constraints as follows. First, 
                           
                              
                                 W
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                           =
                           0
                         if 
                           
                              
                                 x
                              
                              
                                 j
                              
                           
                         is not a nearest neighbor of 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                        . Second, the sum of those neighbor weights of 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         is 1, i.e., 
                           
                              
                                 ∑
                              
                              
                                 j
                              
                           
                           
                              
                                 W
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                           =
                           1
                        .

(3) Low-dimensional embedding vector calculation. After the weight matrix is obtained, each high-dimensional vector 
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                         is then mapped to a low-dimensional vector 
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                         of dimensionality d. This can be done by minimizing the cost function Φ below.
                           
                              (12)
                              
                                 Φ
                                 (
                                 Y
                                 )
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    
                                       |
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       −
                                       
                                          ∑
                                          j
                                       
                                       
                                          
                                             W
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             j
                                          
                                       
                                       |
                                    
                                    
                                       2
                                    
                                 
                              
                           
                         where 
                           Y
                           =
                           [
                           
                              
                                 y
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 y
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 y
                              
                              
                                 N
                              
                           
                           ]
                         is a matrix forming by all low-dimensional embedding vectors. For more details of LLE algorithm, please refer to [25,32]. The MATLAB code of LLE algorithm can be downloaded from the personal website of Roweis [33].

Having obtained these low-dimensional embedding vectors, we calculate statistics of each embedding vector to produce a short image hash. Here we choose variance as the feature for representing low-dimensional embedding vector. This is because variance can efficiently measure the fluctuation of vector elements, and we also find the LLE property that embedding vector variances are approximately linearly changed by content-preserving operations. This LLE property will be validated in Section 3.1. The reason of the LLE property is that the effect of content-preserving operations on the change of embedding vector variances is relatively small and like Gaussian noise disturbance. Note that the use of LLE in our work is different from that of [18], which used LLE weight matrix to construct hash but cannot acquire good classification between robustness and discrimination. The variance of 
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                         is defined as follows.
                           
                              (13)
                              
                                 
                                    
                                       δ
                                    
                                    
                                       i
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    1
                                    
                                       d
                                       −
                                       1
                                    
                                 
                                 
                                    ∑
                                    
                                       l
                                       =
                                       1
                                    
                                    d
                                 
                                 
                                    
                                       [
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       (
                                       l
                                       )
                                       −
                                       
                                          
                                             μ
                                          
                                          
                                             i
                                          
                                       
                                       ]
                                    
                                    
                                       2
                                    
                                 
                              
                           
                         where 
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                           (
                           l
                           )
                         is the l-th element of 
                           
                              
                                 y
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 μ
                              
                              
                                 i
                              
                           
                         is the mean calculated by the below equation.
                           
                              (14)
                              
                                 
                                    
                                       μ
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    1
                                    d
                                 
                                 
                                    ∑
                                    
                                       l
                                       =
                                       1
                                    
                                    d
                                 
                                 
                                    
                                       y
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 l
                                 )
                              
                           
                         To reduce storage, each variance is quantized to an integer as follows.
                           
                              (15)
                              
                                 c
                                 (
                                 i
                                 )
                                 =
                                 Round
                                 
                                 
                                    (
                                    
                                       
                                          δ
                                       
                                       
                                          i
                                       
                                       
                                          2
                                       
                                    
                                    ×
                                    1000
                                    )
                                 
                              
                           
                         where Round(⋅) is the rounding operation, and 
                           1
                           ≤
                           i
                           ≤
                           N
                        . Next, by a pseudo-random generator, we scramble the integer sequence 
                           c
                           =
                           [
                           c
                           (
                           1
                           )
                           ,
                           c
                           (
                           2
                           )
                           ,
                           …
                           ,
                           c
                           (
                           N
                           )
                           ]
                         to make a secure image hash. Specifically, we can set a secret key as the seed of pseudo-random generator and create N random numbers. Then, we sort these N random numbers and use an array 
                           P
                           [
                           N
                           ]
                         to record the original positions of the sorted elements. Therefore, the i-th hash element is obtained by the below equation.
                           
                              (16)
                              
                                 h
                                 (
                                 i
                                 )
                                 =
                                 c
                                 
                                    (
                                    P
                                    [
                                    i
                                    ]
                                    )
                                 
                              
                           
                         Finally, our image hash h is obtained as follows.
                           
                              (17)
                              
                                 h
                                 =
                                 
                                    [
                                    h
                                    (
                                    1
                                    )
                                    ,
                                    
                                    h
                                    (
                                    2
                                    )
                                    ,
                                    …
                                    ,
                                    
                                    h
                                    (
                                    N
                                    )
                                    ]
                                 
                              
                           
                         It is clear that our hash consists of N integers. In experiment, we find that each integer only requires 11 bits at most for storage. Therefore, the length of our hash is 11N bits. This will be validated in Section 3.3.

Let 
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                           =
                           [
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                           (
                           1
                           )
                           ,
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                           (
                           2
                           )
                           ,
                           …
                           ,
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                           (
                           N
                           )
                           ]
                         and 
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                           =
                           [
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                           (
                           1
                           )
                           ,
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                           (
                           2
                           )
                           ,
                           …
                           ,
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                           (
                           N
                           )
                           ]
                         be a pair of hashes of two images. In this study, the well-known correlation coefficient is exploited to evaluate similarity between 
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                        . Specifically, the used correlation coefficient is defined as follows.
                           
                              (18)
                              
                                 S
                                 (
                                 
                                    
                                       h
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       h
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             l
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                       [
                                       
                                          
                                             h
                                          
                                          
                                             1
                                          
                                       
                                       (
                                       l
                                       )
                                       −
                                       
                                          
                                             m
                                          
                                          
                                             1
                                          
                                       
                                       ]
                                       [
                                       
                                          
                                             h
                                          
                                          
                                             2
                                          
                                       
                                       (
                                       l
                                       )
                                       −
                                       
                                          
                                             m
                                          
                                          
                                             2
                                          
                                       
                                       ]
                                    
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   l
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                             
                                                
                                                   [
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   (
                                                   l
                                                   )
                                                   −
                                                   
                                                      
                                                         m
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   ]
                                                
                                                
                                                   2
                                                
                                             
                                             ×
                                             
                                                
                                                   ∑
                                                
                                                
                                                   l
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                             
                                                
                                                   [
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   (
                                                   l
                                                   )
                                                   −
                                                   
                                                      
                                                         m
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   ]
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       +
                                       Δ
                                       s
                                    
                                 
                              
                           
                         where Δs is a small constant to avoid zero denominator, and 
                           
                              
                                 m
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 m
                              
                              
                                 2
                              
                           
                         are the means of 
                           
                              
                                 h
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 h
                              
                              
                                 2
                              
                           
                        , respectively. The range of correlation coefficient is 
                           [
                           −
                           1
                           ,
                           1
                           ]
                        . The greater the correlation coefficient, the more similar the evaluated hashes and then the more similar the corresponding images. If the correlation coefficient is greater than a threshold, the two images of the input hashes are considered as visually identical images. Otherwise, they are the images with different contents. Here, correlation coefficient is chosen as the similarity metric. This is based on the observation that content-preserving operations approximately linearly change the variances of low-dimensional embedding vectors. Section 3.1 will empirically verify this.

@&#EXPERIMENTAL RESULTS@&#

In the experiments, our parameter settings are as follows. In the preprocessing, the input image is resized to 
                        512
                        ×
                        512
                     , the 
                        
                           
                              L
                           
                           
                              ⁎
                           
                        
                      component of the input image is divided into 
                        2
                        ×
                        2
                      non-overlapping blocks, and a 
                        3
                        ×
                        3
                      Gaussian low-pass filter with zero mean and a unit standard deviation is taken. During secondary image construction, 50 blocks of size 
                        50
                        ×
                        50
                      are randomly chosen. For LLE, 30 nearest neighbors are selected for each vector and the dimensionality of low-dimensional embedding vector is 30. In other words, the used parameters of our hashing are: 
                        M
                        =
                        512
                     , 
                        
                           
                              s
                           
                           
                              1
                           
                        
                        =
                        2
                     , 
                        n
                        =
                        50
                     , 
                        N
                        =
                        50
                     , 
                        K
                        =
                        30
                      and 
                        d
                        =
                        30
                     . Thus, our hash length is 50 integers. To validate efficiency of our hashing, robustness and discrimination are tested in Sections 3.1 and 3.2, respectively. Section 3.3 presents hash length analysis and Section 3.4 discusses the effect of different parameter settings on hash performances.

Many images in the USC-SIPI Image Database [34] are taken as test images, including 8 standard color images sized 
                           512
                           ×
                           512
                         and all color images, i.e., 37 images sized 
                           512
                           ×
                           512
                           ∼
                           2250
                           ×
                           2250
                        , in the ‘Aerials’ volume. Fig. 4
                         illustrates these standard color images and Fig. 5
                         presents typical images in the ‘Aerials’ volume. We exploit Photoshop, MATLAB and StirMark [35] to generate visually identical versions of these test images. The adopted digital operations include brightness adjustment, contrast adjustment, gamma correction, 
                           3
                           ×
                           3
                         Gaussian low-pass filtering, speckle noise, salt and pepper noise, JPEG compression, watermark embedding, image scaling, and the operation of rotation, cropping and rescaling. For the operation of rotation, cropping and rescaling, each test image is firstly rotated, the rotated version is then cropped to remove those padded pixels introduced by rotation, and the cropped version is finally resized to the original size of the test image. Detailed parameter settings of each operation are listed in Table 1
                        . It is observed from Table 1 that total number of the used operations is 76. This means that each test image has 76 visually similar versions. Therefore, there are 
                           (
                           8
                           +
                           37
                           )
                           ×
                           76
                           =
                           3420
                         pairs of visually similar images.

We extract image hashes of the test images and their similar versions, calculate similarity between each pair of hashes, and find that our hashing is robust to the used digital operations. For space limitation, only the results of 8 typical standard color images are plotted here. Fig. 6
                         presents the robustness results under various digital operations. Clearly, all results are bigger than 0.70. To demonstrate the robustness performance of our hashing on a big dataset, we calculate statistics of correlation coefficients based on the above mentioned 3420 pairs of visually similar images. The results are listed in Table 2
                        . It is observed from these results that, the means of correlation coefficients for all digital operations are bigger than 0.87, and all standard deviations are very small. Note that correlation coefficient is an effective metric for measuring the linearity. These big correlation coefficients empirically verify that the variances of LLE results are approximately linearly changed by content-preserving operations. In addition, the minimum values of correlation coefficients for all digital operations are bigger than 0.75, except the operation of rotation, cropping and rescaling. The minimum value of rotation, cropping and rescaling is 0.4572, which is much smaller than those values of other operations. This is because it is a combinational operation, which causes more changes in the attacked images than other operations. Consequently, if there are no rotated images in application, we can select 0.75 as the threshold. In this case, all similar images are almost correctly detected. If there exists some rotated images, the threshold should be lowered. From Fig. 6(j), we find that only a few cases are smaller than 0.75. Therefore, we can choose 0.70 as the threshold to resist most of the above used operations.

To test discrimination of our hashing, we collect a large database with 200 different color images via Internet and digital camera, whose sizes range from 
                           256
                           ×
                           256
                         to 
                           2048
                           ×
                           1536
                        . Specifically, we download 67 images from Internet, take 100 images from a well-known public database, i.e., the Ground Truth Database [36], and capture 33 images with camera. We apply our hashing to the image database, extract 200 image hashes, calculate similarity between each pair of hashes, and then reach 
                           200
                           ×
                           (
                           200
                           −
                           1
                           )
                           /
                           2
                           =
                           19900
                         correlation coefficients. Distribution of these results is shown in Fig. 7
                        , where the x-axis is the correlation coefficient and the y-axis is its frequency. It is observed that the minimum and the maximum of correlation coefficients are −0.6891 and 0.6967, respectively. And further, the mean and standard deviation of the distribution in Fig. 7 are 0.0066 and 0.1905, respectively. Clearly, if we choose 0.80 or 0.70 as the threshold, no images will be falsely considered as similar images. If the threshold is 0.60, only 0.05% different images will be mistakenly detected as visually identical images. Actually, a big threshold will improve discrimination, but will also inevitably decrease robustness. Table 3
                         illustrates our detection performances under different thresholds, where robustness is described by the percentage of similar images judged as identical images and discrimination is indicated by the percentage of different images detected as similar images. In practice, we can choose a threshold in terms of specific applications.

A short length is a basic requirement for image hash. To analyze the required bits for storing our hash, we take the 200 image hashes extracted in discrimination as the sample data. As each image hash contains 50 elements, the total number of hash elements is 
                           50
                           ×
                           200
                           =
                           10
                           
                           000
                        . Fig. 8
                         is the distribution of these hash elements, where the x-axis is the value of hash element and the y-axis is its frequency. It is found that the minimum value is 4 and the maximum value is 1666. This means that storage of hash element only requires 11 bits, which can represent integers ranging from 0 to 
                           
                              
                                 2
                              
                              
                                 11
                              
                           
                           −
                           1
                           =
                           2047
                        . Therefore, the length of our hash is 
                           50
                           ×
                           11
                           =
                           550
                         bits, reaching a reasonable short length. As a reference, the lengths of the SVD–SVD hashing [12], the ZM-based hashing [21], and the CAV-DWT hashing [22] are 1600 digits, 560 bits, and 960 bits, respectively.

To evaluate the effect of parameter settings on our hash performances, we use different parameter values to validate robustness and discrimination. To make visual comparisons between the results of different settings, the notable tool, i.e., receiver operating characteristics (ROC) graph [37], is adopted here. In the ROC graph, the x-axis is generally defined as false positive rate (FPR) 
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                         and the y-axis is used to represent true positive rate (TPR) 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        . The two rates are calculated by the below equations.
                           
                              (19)
                              
                                 
                                    
                                       P
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       
                                          n
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          N
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       P
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       
                                          n
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          N
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                         where 
                           
                              
                                 n
                              
                              
                                 1
                              
                           
                         is the number of visually different images detected as similar images, and 
                           
                              
                                 N
                              
                              
                                 1
                              
                           
                         is the total number of different images, 
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                         is the number of visually similar images judged as identical images, 
                           
                              
                                 N
                              
                              
                                 2
                              
                           
                         is the total number of similar images. Clearly, 
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                         are indicators of discrimination and robustness, respectively. The smaller the 
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                         value, the better the discrimination performance. And the bigger the 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                         value, the better the robustness performance. Since ROC curve is formed by a set of points (
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        , 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        ), the curve close to the top-left corner (a small 
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                         and a big 
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        ) is better than the one far away from the top-left corner.

Here, we mainly discuss the key parameters, i.e., the number of nearest neighbors K and the dimensionality of low-dimensional vector d for LLE. Firstly, we only vary the K value and keep other parameters unchanged. The used K values include 5, 15, 25, 30, 35, and 40. Fig. 9
                         is the ROC curve comparisons among different K values. It is observed that all ROC curves are close to the top-left corner, indicating that our hashing reaches a satisfactory balance between robustness and discrimination. To view differences, the ROC curves around the top-left corner are enlarged in the right-bottom part of Fig. 9. It is found that, a moderate K value, such as 30 or 35, can reach a slightly better classification performance than those small K values (such as 5 or 15) and big K values (e.g., 40). This can be understood as follows. In LLE algorithm, K nearest neighbors are used to reconstruct a vector. A small K value cannot make a good reconstruction due to the lack of enough nearest neighbors. But a big K value will bring some unnecessary neighbors, leading to a larger reconstruction error. In the experiments, we find that, for 
                           512
                           ×
                           512
                         images, 
                           K
                           =
                           30
                         or 
                           K
                           =
                           35
                         can reach a good classification performance between robustness and discrimination. Moreover, computational time is also compared. To this end, the total consumed time for extracting 200 hashes in discrimination test is recorded, and then the average time for generating a hash is acquired. Our hashing is implemented with MATLAB R2012a, running in a desktop PC with 3.4 GHz Intel Core i5-3570 CPU and 4.0 GB RAM. We observe that the running time under different K values is around 0.61 seconds, and the time under 
                           K
                           =
                           40
                         is a little more than those of other values. Table 4
                         summarizes the comparison of computational time under different K values.

Secondly, we only change the d value. The adopted values of d are 25, 30, 35, and 40. Fig. 10
                         presents the ROC curve comparisons among different d values. From the results, we find that all ROC curves reach the top-left corner. This implies that the d value has little effect on classification performances of our hashing. To view more details, the right-bottom region of Fig. 10 shows the magnified part of the ROC curves around the top-left corner. We observe that the curves of 
                           d
                           =
                           30
                         and 
                           d
                           =
                           35
                         are almost the same, and the curves of 
                           d
                           =
                           25
                         and 
                           d
                           =
                           40
                         is a little below them. Therefore, for 
                           512
                           ×
                           512
                         images, we can choose 
                           d
                           =
                           30
                         or 
                           d
                           =
                           35
                         to achieve a good classification between robustness and discrimination. In addition, we calculate the average time of hash generation and find that the time under different d values is also around 0.61 seconds. The comparison of computational time is presented in Table 5
                        .

To illustrate our superiority in classification performances, we compare our hashing with some notable image hashing algorithms including LLE-based hashing [18], RT–DCT hashing [16], GF–LVQ hashing [20] and CVA–DWT hashing [22]. To ensure fair comparisons, the test images used in Sections 3.1 and 3.2 are also taken here. In the comparisons, all images are converted to 
                        512
                        ×
                        512
                     , and other parameters are the same with the default settings of the assessed algorithms. The original metrics for measuring hash similarity are also adopted here, i.e., Hamming distance for LLE-based hashing and RT–DCT hashing, the normalized Hamming distance for GF–LVQ hashing, and 
                        
                           
                              L
                           
                           
                              2
                           
                        
                      norm for CVA–DWT hashing. Thus, hash lengths of LLE-based hashing, RT–DCT hashing, GF–LVQ hashing, and CVA–DWT hashing are 300, 240, 120, 960 bits, respectively.

We exploit the compared algorithms to generate hashes of the above images and then calculate hash similarity with respective metric. For our hashing, the results of 
                        K
                        =
                        30
                      and 
                        d
                        =
                        30
                      is taken here. To make theoretical analysis, the ROC graph is used again. In the ROC graph, if some algorithms reach the same TPR, the algorithm with small FPR is better than the algorithm with big FPR. Similarly, the algorithm with big TPR outperforms the algorithm with small TPR when they have the same FPR. Intuitively, the larger the area under ROC curve, the better the classification performance. Fig. 11
                      is the ROC curve comparisons among the assessed algorithms. Clearly, our ROC curve is above those curves of the compared algorithms. In other words, the area under our ROC curve is much larger than others. This means that our hashing has better classification performance than other image hashing algorithms. For example, when 
                        
                           TPR
                        
                        ≈
                        1.0
                     , the best FPRs of LLE-based hashing, RT–DCT hashing, GF–LVQ hashing, CVA–DWT hashing, and our hashing are 0.5569, 0.9963, 0.7040, 0.1033, and 0.0087, respectively. And when 
                        
                           FPR
                        
                        ≈
                        0
                     , the optimum TPRs of LLE-based hashing, RT–DCT hashing, GF–LVQ hashing, CVA–DWT hashing, and our hashing are 0.8959, 0.7018, 0.7827, 0.9406, and 0.9953, respectively.

In fact, the good classification performance of our hashing is contributed by our well-designed steps, including the similarity metric. Specifically, our preprocessing reduces influences of content-preserving operations and thus helps to achieve good robustness. Our second step provides a secondary image suitable for data reduction with LLE. The use of LLE in the third step makes our hashing discriminative since it can efficiently learn global structure of nonlinear manifolds and discover compact representations. Finally, according to the LLE property, we select the correlation coefficient as similarity metric, which can effectively measure the linearly changed variances of embedding vectors and thus make our algorithm reach a desirable tradeoff between robustness and discrimination.

Moreover, computational time of generating a hash is also compared. This is done by recording the total consumed time of extracting 200 hashes in respective discrimination test. The average time of LLE-based hashing, RT–DCT hashing, GF–LVQ hashing and CVA–DWT hashing is 0.04, 3.04, 0.42 and 0.27 seconds, respectively. Our average time is about 0.61 seconds, which is slower than those of LLE-based hashing, RT–DCT hashing and CVA–DWT hashing, but is much faster than that of RT–DCT hashing. The low speed of RT–DCT hashing is due to the high complexity of RT. Performance comparisons are summarized in Table 6
                     . Our hashing outperforms the compared algorithm in classification with respect to robustness and discrimination. As to computational time and hash length, our hashing reaches moderate performances. The fastest algorithm is the LLE-based hashing, and the GF–LVQ hashing has the shortest length.

@&#CONCLUSIONS@&#

In this work, we have proposed a robust image hashing based on LLE. The key contribution of our work is the innovative use of LLE. As LLE is good at discovering compact representation by learning global structure of input data, it provides our image hashing a desirable discrimination. More specifically, we have observed the LLE property that embedding vector variances are approximately linearly changed by content-preserving operations, so as to measure hash similarity with correlation coefficient. Many experiments have been conducted to validate efficiency of our image hashing. The results have shown that our image hashing is robust to many common digital operations and reaches a good discrimination. ROC curve comparisons with some well-known algorithms have illustrated that our hashing outperforms the compared algorithms in classification performances with respect to robustness and discrimination.

@&#ACKNOWLEDGEMENTS@&#

This work is partially supported by the National Natural Science Foundation of China (61300109, 61363034, 61303203), the Guangxi Natural Science Foundation (2012GXNSFBA053166, 2012GXNSFGA060004), Guangxi “Bagui Scholar” Teams for Innovation and Research, the Scientific and Technological Research Projects in Guangxi Higher Education Institutions (YB2014048, ZL2014005), the Project of the Guangxi Key Lab of Multi-source Information Mining & Security (14-A-02-02, 13-A-03-01), the Project of Outstanding Young Teachers' Training in Higher Education Institutions of Guangxi, and Guangxi Collaborative Innovation Center of Multi-source Information Integration and Intelligent Processing. The authors would like to thank the anonymous referees for their valuable comments and suggestions.

@&#REFERENCES@&#

