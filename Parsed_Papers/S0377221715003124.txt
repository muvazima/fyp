@&#MAIN-TITLE@&#An accelerated branch-and-price algorithm for multiple-runway aircraft sequencing problems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We improve the tractability of multiple-runway aircraft sequencing problems.


                        
                        
                           
                           First effective branch-and-price algorithm reported for this problem.


                        
                        
                           
                           Solving elementary shortest path problem with non-triangular separation times.


                        
                        
                           
                           Subproblem solved using specialized, effective dynamic programming procedure.


                        
                        
                           
                           Optimal solutions in far better CPU times (vs. CPLEX) on challenging instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Aircraft sequencing

Branch-and-price

Column generation

Dynamic programming

Elementary shortest path problems

@&#ABSTRACT@&#


               
               
                  This paper presents an effective branch-and-price (B&P) algorithm for multiple-runway aircraft sequencing problems. This approach improves the tractability of the problem by several orders of magnitude when compared with solving a classical 0–1 mixed-integer formulation over a set of computationally challenging instances. Central to the computational efficacy of the B&P algorithm is solving the column generation subproblem as an elementary shortest path problem with aircraft time-windows and non-triangular separation times using an enhanced dynamic programming procedure. We underscore in our computational study the algorithmic features that contribute, in our experience, to accelerating the proposed dynamic programming procedure and, hence, the overall B&P algorithm.
               
            

Sustained growth in air traffic volumes worldwide and rising airline delay costs continue to motivate research related to airport operations management. Aircraft sequencing problems (ASP), in particular, have motivated a great deal of academic research because runways constitute a major bottleneck at airports. From a modeling viewpoint, Abela, Abramson, Krishnamoorthy, De Silva, and Mills (1993) developed a mixed-integer programming (MIP) formulation for a single-runway aircraft sequencing problem that is solved using a branch-and-bound (B&B) algorithm. Likewise, Ernst, Krishnamoorthy, and Storer (1999) and Beasley, Krishnamoorthy, Sharaiha, and Abramson (2000) investigated 0–1 mixed-integer programming formulations with disjunctive constraints for aircraft separation for single- and multiple-runway aircraft sequencing problems. Bianco, Dell’Olmo, and Giordani (1999) proposed an MIP formulation that is based on the similarity between aircraft sequencing problems over a single runway and asymmetric traveling salesman problems (ATSP). This was further exploited in Ghoniem, Sherali, and Baik (2014) where valid inequalities, preprocessing routines, and reformulation-linearization technique constructs were developed to improve the tractability of computationally challenging single-runway aircraft sequencing problems. Briskorn and Stolletz (2014) demonstrated that, when aircraft are partitioned into subgroups based on their weight class, effective preprocessing routines can be derived and incorporated into classical formulations in order to improve the problem tractability. Numerous works have investigated the incorporation of practical considerations. For example, the notion of constrained position shifting has been examined in Venkatakrishnan, Barnett, and Odoni (1993), Bianco, Dell’Olmo, and Giordani (2006), and Balakrishnan and Chandran (2010), to name a few. Further, Artiouchine, Baptiste, and Dürr (2008) developed a branch-and-cut approach for solving an aircraft sequencing problem with holding patterns where each aircraft is assigned to one time-window from a set of disjoint options with the objective of maximizing the minimum separation between consecutive landings. Soomer and Franx (2008) considered a tactical, single-ruwnay problem in which airline companies express a cost function related to their delays and a heuristic is developed to find a schedule that accommodates their preferences.

Although cases involving combined aircraft arrival-departure problems or multiple runways have been examined to some extent, the survey by Bennell, Mesgarpour, and Potts (2011) indicates that single-runway aircraft landing problems have received greater attention. It also suggests that such aircraft sequencing problems are commonly solved using dynamic programming (DP) algorithms, B&B algorithms, and metaheuristics. To date, competitive branch-and-price (B&P) algorithms for the multiple-runway aircraft sequencing problem (MRASP) have not been reported in the literature, despite its similarity with parallel machine scheduling problems with time-windows and sequence-dependent processing times (Chen & Powell, 1999), vehicle routing problems (VRP) or the m-ATSP with time-windows.

We focus in this paper on solving combined aircraft arrival-departure sequencing problems over multiple independent runways using an effective B&P algorithm. Based on the multiple-runway aircraft sequencing problem setting in Beasley et al. (2000), Wen, Larsen, and Clausen (2005) attempted a B&P approach, but to no avail. The authors reported that their column generation (CG) approach yielded tight linear programming (LP) bounds in the course of the B&P algorithm, but the overall computational effort of the B&P algorithm was prohibitive for the Beasley et al. (2000) instances in the OR-Library. The following challenges arose in the exploration of B&P algorithms for the MRASP. First, such B&P implementations seem inadequate because the Beasley et al. (2000) instances with about 100 aircraft can alternatively be solved in no more than a few seconds using a classical 0–1 MIP formulation with disjunctive constraints, standard solvers such as CPLEX, and modern computing capabilities. However, as discussed in this paper, smaller instances that are considerably more difficult for optimization solvers can be generated. Second, obtaining tight column generation-based LP bounds is not sufficient to ensure effective node pruning in the B&P algorithm unless high quality feasible solutions were also dynamically revealed. The latter were typically lacking, thereby reducing the usefulness of the LP bounds. To alleviate such shortcomings, Ghoniem and Farhadi (2015) demonstrated that tight LP bounds and optimal or near-optimal solutions could be produced for small-sized challenging problem instances using the complementary column generation feature of Ghoniem and Sherali (2009) and an interior point dual stabilization scheme suggested by Rousseau, Gendreau, and Feillet (2007). Although this heuristic approach consistently yielded optimal or near-optimal solutions and accelerated the LP phase of the CG approach, the overall computational effort remained impractical and made a B&P implementation beyond reach. This computational hurdle is essentially due to solving the CG subproblem as an MIP using standard commercial solvers such as CPLEX or GUROBI.

Central to the success of the proposed B&P algorithm is solving the CG subproblem as an elementary shortest path problem with time-windows and non-triangular aircraft separation times using a DP procedure (Irnich & Desaulniers, 2005). Although adapted to cater for the need to separate consecutive and nonconsecutive aircraft operations, the DP procedure is based on and extends algorithms for elementary shortest path problems with time-windows and resource constraints (ESPPTRC), as successfully implemented in the context of the VRP with time-windows (VRPTW) using B&P algorithms (Kallehauge, Larsen, Madsen, & Solomon, 2005). In particular, Desrochers (1988) introduced a label reaching algorithm based on the Bellman-Ford-Moore shortest path algorithm and demonstrated its usefulness for the VRPTW (Desrochers, Desrosiers, & Solomon, 1992). Feillet et al. (2004) extended the algorithm for elementary shortest path problems with resource constraints (ESPPRC). Whereas such algorithms assume that the triangular inequality holds for arc costs, this condition does not hold in MRASP due to non-triangular aircraft separation times and so the implemented DP procedure is accordingly adapted.

This paper makes the following contributions. It rehabilitates the use of B&P algorithms for multiple-runway aircraft sequencing problems and demonstrates that they can markedly outperform other classical exact methods using a set of “hard”, mid-sized instances. Solving the pricing subproblem as an elementary shortest path problem using a specialized DP approach is at the heart of the computational efficacy of the proposed B&P algorithm. We also elaborate on the specific algorithmic features that contribute toward speeding up the DP approach in our experience. This enhanced DP procedure (EDP) considers the inclusion of multiple columns/paths to the restricted master program at every CG iteration, solving the subproblem heuristically when it yields a negative-reduce-cost column within a specified time limit or exactly otherwise, and a relaxed dominance rule within the DP scheme. Using a set of computationally challenging randomly generated instances that we have made public, we compare and contrast the following solution methods:

                        
                           •
                           Our proposed B&P algorithm with the base versus the enhanced DP procedure;

An MIP formulation similar to that in Beasley et al. (2000) that is enhanced with preprocessing routines and symmetry-defeating hierarchical constraints.

The remainder of this paper is organized as follows. For clarity in the exposition, Section 2 presents a classical 0–1 MIP formulation for MRASP along with preprocessing routines and lexicographic symmetry-defeating hierarchical constraints. MRASP is also reformulated as a set partitioning model that lends itself to a column generation approach. Section 3 expounds on the DP procedure that is devised to solve the pricing subproblem. Section 4 delineates the proposed B&P algorithm. Section 5 reports our empirical results over a set of computationally challenging problem instances and highlights the relative merits of the proposed B&P algorithm over alternative approaches. Section 6 concludes this paper with a summary of our findings and directions for future research.

In Section 2.1, we state a 0–1 MIP formulation for the multiple-runway aircraft sequencing problem (MRASP) based on Beasley et al. (2000) which is used for comparative purposes in our computational study. MRASP is then reformulated as a set partitioning formulation for which a master program is briefly discussed in Section 2.2. This paves the way for the discussion of a DP procedure for the subproblem in Section 3 and the development of a B&P algorithm in Section 4.

Given a set of m( ≥ 2) parallel, independent runways (Ghoniem & Farhadi, 2015; Wen et al., 2005) and n aircraft with input data on aircraft types (heavy/large/small), operation types (arrival/departure), ready-times and due-times, and the minimum separation times enforced by aviation authorities, the multiple-runway aircraft sequencing problem seeks to jointly assign the aircraft to runways and to determine the best aircraft sequence for each runway with respect to a chosen objective function. In doing so, time-window restrictions must be met for all aircraft and minimal safety separation times need to be enforced between any pair of aircraft that are assigned to the same runway. It should be pointed out that our study does not address a specific airport layout and runway configuration. It rather considers a generic setting with parallel runways that are sufficiently spaced to be deemed independent with the purpose of investigating enhanced algorithmic developments and the related computational effort.

Consider the following notation:


                        Index sets and parameters:
                        
                           
                              •
                              
                                 M ≡ {1,…, m}: A set of m parallel, independent runways.


                                 J ≡ {1,…, n}: A set of n aircraft (landings or departures).


                                 rj
                                 : Ready-time for aircraft j, ∀j ∈ J.


                                 dj
                                 : Due-time for aircraft j, ∀j ∈ J.


                                 
                                    
                                       O
                                       j
                                    
                                 : Operation type of aircraft j, being a landing or a departure, ∀j ∈ J.


                                 
                                    
                                       C
                                       j
                                    
                                 : Class of aircraft j based on its size, e.g., heavy, large, or small, ∀j ∈ J.


                                 wj
                                 : Weight assigned to aircraft j based on its operation type and its weight class, ∀j ∈ J. In particular, higher priority is assigned to landings over departures and to heavy aircraft over large and small ones. Moreover, in our test-bed 
                                    
                                       
                                          w
                                          
                                             j
                                             1
                                          
                                       
                                       =
                                       
                                          w
                                          
                                             j
                                             2
                                          
                                       
                                    
                                  if 
                                    
                                       
                                          O
                                          
                                             j
                                             1
                                          
                                       
                                       =
                                       
                                          O
                                          
                                             j
                                             2
                                          
                                       
                                    
                                  and 
                                    
                                       
                                          C
                                          
                                             j
                                             1
                                          
                                       
                                       =
                                       
                                          C
                                          
                                             j
                                             2
                                          
                                       
                                    
                                 .


                                 
                                    
                                       
                                          p
                                          
                                             
                                                j
                                                1
                                             
                                             
                                                j
                                                2
                                             
                                          
                                       
                                       :
                                    
                                  Minimum separation time required between aircraft j
                                 1 and j
                                 2 if they are assigned to the same runway and are respectively the leading and the following aircraft, ∀j
                                 1, j
                                 2 ∈ J, j
                                 1 ≠ j
                                 2. This separation time is dictated by the operation types and weight classes of any pair of aircraft and is typically asymmetric (e.g., see Table 1
                                 , Section 3).


                        Decision variables:
                        
                           
                              •
                              
                                 tj
                                 : the start-time of aircraft j, ∀j ∈ J. This is the time at which aircraft j accesses a runway, whether for landing or departing, as commonly considered in the literature.


                                 zij
                                  ∈ {0, 1}: zij
                                  = 1 if and only if aircraft j is assigned to runway i, ∀i ∈ M, j ∈ J.


                                 
                                    
                                       
                                          y
                                          
                                             
                                                j
                                                1
                                             
                                             
                                                j
                                                2
                                             
                                          
                                       
                                       ∈
                                       
                                          {
                                          0
                                          ,
                                          1
                                          }
                                       
                                    
                                 : 
                                    
                                       
                                          y
                                          
                                             
                                                j
                                                1
                                             
                                             
                                                j
                                                2
                                             
                                          
                                       
                                       =
                                       1
                                    
                                  if and only if aircraft j
                                 1 and j
                                 2 are assigned to the same runway and 
                                    
                                       
                                          t
                                          
                                             j
                                             2
                                          
                                       
                                       >
                                       
                                          t
                                          
                                             j
                                             1
                                          
                                       
                                       ,
                                    
                                  ∀j
                                 1, j
                                 2 ∈ J, j
                                 1 ≠ j
                                 2.

The multiple-runway aircraft sequencing problem is formulated as the following 0–1 MIP that is denoted by MRASP:

                           
                              (1a)
                              
                                 
                                    
                                       
                                          
                                             
                                                M
                                                R
                                                A
                                                S
                                                P
                                             
                                             :
                                             
                                             Minimize
                                             
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                w
                                                j
                                             
                                             
                                                t
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1b)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   M
                                                
                                             
                                             
                                                z
                                                
                                                   i
                                                   j
                                                
                                             
                                             =
                                             1
                                             ,
                                             
                                             ∀
                                             j
                                             ∈
                                             J
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1c)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                r
                                                j
                                             
                                             ≤
                                             
                                                t
                                                j
                                             
                                             ≤
                                             
                                                d
                                                j
                                             
                                             ,
                                             
                                             ∀
                                             j
                                             ∈
                                             J
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1d)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                             
                                                t
                                                
                                                   j
                                                   2
                                                
                                             
                                             ≥
                                             
                                                t
                                                
                                                   j
                                                   1
                                                
                                             
                                             +
                                             
                                                p
                                                
                                                   
                                                      j
                                                      1
                                                   
                                                   
                                                      j
                                                      2
                                                   
                                                
                                             
                                             −
                                             
                                                (
                                                1
                                                −
                                                
                                                   y
                                                   
                                                      
                                                         j
                                                         1
                                                      
                                                      
                                                         j
                                                         2
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                (
                                                
                                                   d
                                                   
                                                      j
                                                      1
                                                   
                                                
                                                −
                                                
                                                   r
                                                   
                                                      j
                                                      2
                                                   
                                                
                                                +
                                                
                                                   p
                                                   
                                                      
                                                         j
                                                         1
                                                      
                                                      
                                                         j
                                                         2
                                                      
                                                   
                                                
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                             ∀
                                             
                                                j
                                                1
                                             
                                             ∈
                                             J
                                             ,
                                             
                                                j
                                                2
                                             
                                             ∈
                                             J
                                             ,
                                             
                                                j
                                                1
                                             
                                             ≠
                                             
                                                j
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1e)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                             
                                                y
                                                
                                                   
                                                      j
                                                      1
                                                   
                                                   
                                                      j
                                                      2
                                                   
                                                
                                             
                                             +
                                             
                                                y
                                                
                                                   
                                                      j
                                                      2
                                                   
                                                   
                                                      j
                                                      1
                                                   
                                                
                                             
                                             ≥
                                             
                                                z
                                                
                                                   i
                                                   
                                                      j
                                                      1
                                                   
                                                
                                             
                                             +
                                             
                                                z
                                                
                                                   i
                                                   
                                                      j
                                                      2
                                                   
                                                
                                             
                                             −
                                             1
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                             
                                             ∀
                                             i
                                             ∈
                                             M
                                             ,
                                             
                                                j
                                                1
                                             
                                             ∈
                                             J
                                             ,
                                             
                                                j
                                                2
                                             
                                             ∈
                                             J
                                             ,
                                             
                                                j
                                                1
                                             
                                             <
                                             
                                                j
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1f)
                              
                                 
                                    
                                       
                                          
                                             
                                             y
                                             ,
                                             z
                                             
                                             binary
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective function (1a) minimizes total weighted start-times. Constraint (1b) ensures that every aircraft is assigned to exactly one of the m runways. Time-window restrictions are introduced in Constraint (1c). Constraint (1d) guarantees proper separation between any pair of aircraft. Constraint (1e) activates the sequencing variables between any pair of aircraft that are assigned to the same runway. Because of Constraint (1e), Constraint (1d) will enforce separation only between aircraft that are assigned to the same runway, thereby reflecting our assumption that runways are independent and sufficiently spaced. Constraint (1f) defines binary decision variables.

By preprocessing, to ensure feasibility, we can enforce:

                                 
                                    (2)
                                    
                                       
                                          
                                          
                                          
                                          
                                             y
                                             
                                                
                                                   j
                                                   2
                                                
                                                
                                                   j
                                                   1
                                                
                                             
                                          
                                          =
                                          0
                                          ,
                                          
                                          ∀
                                          
                                             j
                                             1
                                          
                                          ∈
                                          J
                                          ,
                                          
                                             j
                                             2
                                          
                                          ∈
                                          J
                                          ,
                                          
                                             j
                                             1
                                          
                                          ≠
                                          
                                             j
                                             2
                                          
                                          ,
                                          
                                             r
                                             
                                                j
                                                2
                                             
                                          
                                          +
                                          
                                             p
                                             
                                                
                                                   j
                                                   2
                                                
                                                
                                                   j
                                                   1
                                                
                                             
                                          
                                          >
                                          
                                             d
                                             
                                                j
                                                1
                                             
                                          
                                          .
                                       
                                    
                                 
                              
                           

By preprocessing, without loss of optimality, we can impose:

                                 
                                    (3)
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      y
                                                      
                                                         
                                                            j
                                                            2
                                                         
                                                         
                                                            j
                                                            1
                                                         
                                                      
                                                   
                                                   =
                                                   0
                                                   ,
                                                   
                                                
                                             
                                             
                                                
                                                   ∀
                                                   
                                                      j
                                                      1
                                                   
                                                   ∈
                                                   J
                                                   ,
                                                   
                                                      j
                                                      2
                                                   
                                                   ∈
                                                   J
                                                   ,
                                                   
                                                      j
                                                      1
                                                   
                                                   ≠
                                                   
                                                      j
                                                      2
                                                   
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                             
                                                
                                                   
                                                      r
                                                      
                                                         j
                                                         1
                                                      
                                                   
                                                   <
                                                   
                                                      r
                                                      
                                                         j
                                                         2
                                                      
                                                   
                                                   ,
                                                   
                                                      d
                                                      
                                                         j
                                                         1
                                                      
                                                   
                                                   ≤
                                                   
                                                      d
                                                      
                                                         j
                                                         2
                                                      
                                                   
                                                   ,
                                                   
                                                      O
                                                      
                                                         j
                                                         1
                                                      
                                                   
                                                   =
                                                   
                                                      O
                                                      
                                                         j
                                                         2
                                                      
                                                   
                                                   ,
                                                   
                                                      C
                                                      
                                                         j
                                                         1
                                                      
                                                   
                                                   =
                                                   
                                                      C
                                                      
                                                         j
                                                         2
                                                      
                                                   
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

The inherent symmetry amongst parallel, independent runways can be combated using a variety of symmetry-defeating hierarchical constraints (Sherali & Smith, 2001) including the following lexicographic-based ordering:

                                 
                                    (4)
                                    
                                       
                                          
                                          
                                          
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                J
                                             
                                          
                                          
                                             2
                                             
                                                n
                                                −
                                                j
                                             
                                          
                                          
                                             z
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          ≥
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                J
                                             
                                          
                                          
                                             2
                                             
                                                n
                                                −
                                                j
                                             
                                          
                                          
                                             z
                                             
                                                i
                                                +
                                                1
                                                ,
                                                j
                                             
                                          
                                          ,
                                          
                                          ∀
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          m
                                          −
                                          1
                                          .
                                       
                                    
                                 
                              
                           

The MRASP is alternatively reformulated as the following set partitioning formulation (master program), denoted by SPP, where a column construct 
                           
                              Q
                              h
                           
                         has 0–1 entries that represent a subset of aircraft that are assigned to the same runway with an associated cost κh
                         and where the binary variable xh
                         equals 1 if and only if column 
                           
                              Q
                              h
                           
                         is selected:

                           
                              (5a)
                              
                                 
                                    
                                       
                                          
                                             SPP
                                             
                                                :
                                                Minimize
                                             
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   h
                                                   =
                                                   1
                                                
                                                H
                                             
                                             
                                                κ
                                                h
                                             
                                             
                                                x
                                                h
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5b)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                subject
                                                
                                                to
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   h
                                                   =
                                                   1
                                                
                                                H
                                             
                                             
                                                Q
                                                j
                                                h
                                             
                                             
                                                x
                                                h
                                             
                                             =
                                             1
                                             ,
                                             
                                             ∀
                                             j
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             n
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5c)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                ∑
                                                
                                                   h
                                                   =
                                                   1
                                                
                                                H
                                             
                                             
                                                x
                                                h
                                             
                                             =
                                             m
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5d)
                              
                                 
                                    
                                       
                                          
                                             
                                             x
                                             
                                             binary
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective function (5a) minimizes the total weighted start-times of aircraft. Constraint (5b) achieves a set partitioning scheme for aircraft, guaranteeing that every aircraft is assigned to exactly one runway, whereas Constraint (5c) specifies the number of runways to be used. To circumvent the generation of a huge number of columns, the LP relaxation of such formulations can be tackled using CG to produce either a heuristic or an exact solution in the context of a B&P algorithm. At each iteration of the CG procedure, a continuous restricted master program of model SPP is solved, yielding the following dual values for the pricing subproblem:

                           
                              •
                              
                                 π: vector of dual variables associated with Constraint (5b), where 
                                    
                                       π
                                       =
                                       
                                          π
                                          ¯
                                       
                                    
                                  represents specific dual variable values obtained at a given CG iteration.


                                 π
                                 0: dual variable associated with Constraint (5c), where 
                                    
                                       
                                          π
                                          0
                                       
                                       =
                                       
                                          
                                             π
                                             ¯
                                          
                                          0
                                       
                                    
                                  represents a specific dual variable value obtained at a given CG iteration.

The subproblem, denoted by SP
                        
                           
                              (
                              
                                 π
                                 ¯
                              
                              ,
                              
                                 
                                    π
                                    ¯
                                 
                                 0
                              
                              )
                              ,
                           
                         can be stated as an MIP that seeks to identify a subset of aircraft that are assigned to and sequenced over a runway in a fashion that minimizes the reduced cost of the constructed column. To alleviate the computational burden associated with the long tailing-off effect of column generation and to produce high quality 0–1 heuristic solutions to SPP, Ghoniem and Farhadi (2015) combined the interior point dual stabilization (IPDS) technique of Rousseau et al. (2007) with the complementary CG scheme proposed by Ghoniem and Sherali (2009). Although the synergistic use of such algorithmic enhancements accelerated the CG convergence and yielded optimal or near-optimal solutions to SPP, solving the subproblem using an MIP solver remained computationally onerous. This shortcoming inhibits the implementation of effective branch-and-price algorithms, but can be overcome by solving the CG subproblem as an elementary shortest path problem with time-windows and non-triangular aircraft separation times using the dynamic programming procedure described next.

In this section, we present our proposed DP approach for solving the CG subproblem of model SPP. Section 3.1 introduces a path extension scheme, followed by a discussion of dominance rules and a description of the overall DP scheme in Section 3.2.

The pricing subproblem is represented in the sequel as a directed graph G ≡ (V, E) where V represents the set of landing/departing aircraft and E represents the set of directed arcs between pairs of aircraft/nodes. We denote by δ(u, v), ∀(u, v) ∈ E, the minimum separation time required between aircraft u and v. Under the FAA aircraft separation standard, the triangle inequality δ(s, v) ≤ δ(s, u) + δ(u, v), does not hold for certain triplets of nodes in the network. Further, each node is characterized by a time-window during which the start-time of its aircraft, tv, v ∈ V, has to be scheduled: rv
                         ≤ tv
                         ≤ dv
                        , ∀v ∈ V, where rv
                         and dv
                         are the ready-time and the due-time for node v, respectively.

Solving the pricing problem aims at identifying a minimal cost path (in the sense of the reduced cost), starting from a dummy origin node s. In doing so, provision should be also made to separate certain non-consecutive aircraft that are sequenced over the same runway, i.e., along this shortest path. Let path Pv
                         be the path extending from the dummy origin s directly to node v. We set the ready-time of the dummy node s as rs
                         ≡ 0, its time separation to any other node in the network as δ(s, v) ≡ 0, ∀v ∈ V, and its dual variable value to 
                           
                              
                                 π
                                 s
                              
                              ≡
                              
                                 
                                    π
                                    ¯
                                 
                                 0
                              
                           
                         (i.e. the dual value associated with Constraint (5c)). Any path Pv
                         is characterized by a cumulative reduced cost cv
                         and its resource consumption tv
                        , which, in the context of MRASP, corresponds to the cumulative time along the path (i.e., the earliest time at which aircraft/node v can start). This information is encapsulated in a label Pv
                         = (cv, tv, Rv
                        ), where Rv
                         denotes the set of reachable nodes from v. With this notation, for the case of the dummy node, 
                           
                              
                                 P
                                 s
                              
                              =
                              
                                 (
                                 −
                                 
                                    
                                       π
                                       ¯
                                    
                                    0
                                 
                                 ,
                                 0
                                 ,
                                 V
                                 )
                              
                           
                        .

To determine an optimal solution with non-triangular arc costs, the attributes of the labels, the label updating rule, and the dominance rule need to be adjusted. We define the degree of non-triangularity for any node u in the graph, θ, as the maximum number of predecessors along a path extended to u for which nonconsecutive separation needs to be enforced. In general, θ can vary between 0 and |V| − 1. The case of θ = 0 presents itself in a network where the triangular inequality holds. The worst case of θ = |V| − 1 arises when there exists a path through all nodes in V, ending in u, such that the consecutive separation between the |V| − 1 consecutive nodes preceding u is not sufficient to properly separate the first node and node u. An examination of the FAA aircraft separation time standard in Table 1 indicates that θ = 3. For example, this arises in the following sequence of four aircraft: Heavy arrival, large departure, large departure, and small arrival, where the consecutive separation times amount to 75 + 60 + 60 = 195 s, whereas 196 s are required between the first and fourth aircraft.


                        Algorithm 1 
                        extend (Pu, v) updates the labels as a path from node u is extended to node v. We also let τ(Pu
                        , ℓ) be the ℓ
                           th
                         parent of node u along the path Pu
                         with τ(Pu
                        , 0) ≡ u itself. To properly update the time tv
                         while enforcing consecutive and nonconsecutive node separation, it is necessary to appropriately separate v from its θth
                         predecessors along this path. update-R(Pv
                        ) identifies nodes j∉Pv
                         that are adjacent to v and fulfill the following feasibility and improvement conditions: (i) Extending Pv
                         with j would not cause j to miss its due-time, i.e., tj
                         < dj
                         and (ii) 
                           
                              
                                 w
                                 j
                              
                              
                                 t
                                 j
                              
                              −
                              
                                 
                                    π
                                    ¯
                                 
                                 j
                              
                              <
                              0
                           
                         and, hence, the inclusion of j improves the overall reduced cost of path Pv
                        .
                     

Let 
                           
                              
                                 P
                                 ¯
                              
                              v
                           
                         be the set of all non-dominated labels extended to node v as the DP algorithm progresses. When non-dominated paths from some node u are extended to adjacent reachable nodes, v, the labels of the latter nodes get updated accordingly. In Feillet et al. (2004), the following dominance rule is adopted: Considering 
                           
                              
                                 P
                                 v
                                 *
                              
                              =
                              
                                 (
                                 
                                    c
                                    v
                                    *
                                 
                                 ,
                                 
                                    t
                                    v
                                    *
                                 
                                 ,
                                 
                                    R
                                    v
                                    *
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 P
                                 v
                                 ′
                              
                              =
                              
                                 (
                                 
                                    c
                                    v
                                    ′
                                 
                                 ,
                                 
                                    t
                                    v
                                    ′
                                 
                                 ,
                                 
                                    R
                                    v
                                    ′
                                 
                                 )
                              
                              ,
                           
                         two distinct paths extended to node v, 
                           
                              P
                              v
                              *
                           
                         dominates 
                           
                              P
                              v
                              ′
                           
                         if and only if 
                           
                              
                                 c
                                 v
                                 *
                              
                              ≤
                              
                                 c
                                 v
                                 ′
                              
                              ,
                              
                                 t
                                 v
                                 *
                              
                              ≤
                              
                                 t
                                 v
                                 ′
                              
                              ,
                           
                         and 
                           
                              
                                 R
                                 v
                                 ′
                              
                              ⊆
                              
                                 R
                                 v
                                 *
                              
                           
                        . A minimal cost path is ultimately constructed by iteratively extending non-dominated paths to reachable nodes.


                        Algorithm 2 , dominance
                        
                           
                              (
                              
                                 P
                                 v
                                 *
                              
                              ,
                              
                                 P
                                 v
                                 ′
                              
                              ,
                              λ
                              )
                              ,
                           
                         checks for dominance of labels when new labels are extended to some node v. A few modifications are required to the dominance rule in Feillet et al. (2004). Let Ω be a temporary set that stores pairs of labels at each node. enqueue and dequeue respectively add and remove a pair of labels from the set Ω. If path 
                           
                              P
                              v
                              *
                           
                         is not dominating path 
                           
                              P
                              v
                              ′
                           
                         the algorithm returns false, thus the path 
                           
                              P
                              v
                              ′
                           
                         gets added to the labels at node v. Otherwise, we need to check that 
                           
                              P
                              v
                              *
                           
                         would continue to dominate 
                           
                              P
                              v
                              ′
                           
                         if both paths were extended to the possible adjacent reachable nodes for the next θ stages. If so, we conclude that path 
                           
                              P
                              v
                              ′
                           
                         is indeed dominated by 
                           
                              P
                              v
                              *
                           
                         and, therefore, is not extended to node v. Let λ be set to the value of θ, the degree of non-triangularity in the graph, that is recursively called in dominance
                        
                           
                              (
                              
                                 P
                                 v
                                 *
                              
                              ,
                              
                                 P
                                 v
                                 ′
                              
                              ,
                              λ
                              )
                           
                        .
                     

Algorithm dominance caters for solving shortest path problems with non-triangular distances. For the worst case where θ = |V| − 1, the algorithm would conduct a complete enumeration of nodes at each iteration of extending the labels, which can be computationally burdensome. Instead, the approach is customized for the aircraft sequencing application and the algorithmic computational effort is curtailed by identifying and exploiting the specific situations for which non-triangular separation times arise under the FAA standard. We redefine Algorithm dominance based on such exceptions. Three main exceptions are identified and depicted in Figs. 1
                        –3
                        
                        .


                        exception1 is illustrated in Fig. 4
                        . Here, assume that 
                           
                              
                                 t
                                 v
                                 *
                              
                              <
                              
                                 t
                                 v
                                 ′
                              
                              ,
                           
                        
                        
                           
                              
                                 c
                                 v
                                 *
                              
                              <
                              
                                 c
                                 v
                                 ′
                              
                              ,
                           
                         and 
                           
                              
                                 R
                                 v
                                 ′
                              
                              ⊆
                              
                                 R
                                 v
                                 *
                              
                           
                        . If we assume that the triangle inequality holds, according to the dominance rule proposed by Feillet et al. (2004), we can immediately conclude that 
                           
                              P
                              v
                              *
                           
                         dominates 
                           
                              P
                              v
                              ′
                           
                         and therefore 
                           
                              P
                              v
                              ′
                           
                         is not extended to v. However, for a reachable node j that is a small arrival, we have under FAA separation times that 
                           
                              
                                 t
                                 j
                                 *
                              
                              =
                              m
                              a
                              x
                              
                                 {
                                 
                                    r
                                    j
                                 
                                 ,
                                 
                                    t
                                    v
                                 
                                 +
                                 δ
                                 
                                    (
                                    v
                                    ,
                                    j
                                    )
                                 
                                 ,
                                 
                                    t
                                    
                                       v
                                       1
                                    
                                 
                                 +
                                 δ
                                 
                                    (
                                    
                                       v
                                       1
                                    
                                    ,
                                    j
                                    )
                                 
                                 }
                              
                           
                         = 996 and 
                           
                              
                                 t
                                 j
                                 ′
                              
                              =
                              m
                              a
                              x
                              
                                 {
                                 
                                    r
                                    j
                                 
                                 ,
                                 
                                    t
                                    v
                                 
                                 +
                                 δ
                                 
                                    (
                                    v
                                    ,
                                    j
                                    )
                                 
                                 ,
                                 
                                    t
                                    
                                       u
                                       1
                                    
                                 
                                 +
                                 δ
                                 
                                    (
                                    
                                       u
                                       1
                                    
                                    ,
                                    j
                                    )
                                 
                                 }
                              
                           
                         = 960. Due to the non-triangular separation times and the need to enforce proper separation between consecutive and non-consecutive aircraft, it is observed that, although 
                           
                              
                                 t
                                 v
                                 ′
                              
                              <
                              
                                 t
                                 v
                                 *
                              
                              ,
                           
                        
                        
                           
                              P
                              v
                              *
                           
                         does not dominate 
                           
                              P
                              v
                              ′
                           
                         when extended to j. Node v
                        1 causes a 61 unit increase in the value of 
                           
                              t
                              j
                              *
                           
                         that would otherwise be observed under consecutive separation times. We shall refer to this time increase as push.

Let v° be the node in 
                           
                              P
                              v
                              *
                           
                         that causes the push in 
                           
                              t
                              j
                              *
                           
                        . For exception1 and exception2 this node is v
                        1 and in exception3 this node is v
                        2 (see Figs. 1,2 and 3). In general, a reachable node j that can potentially cause the largest push occurs when aircraft j is a small arrival, with δ(v, j) = 60. The value of push can be derived as 
                           
                              δ
                              
                                 (
                                 
                                    v
                                    ∘
                                 
                                 ,
                                 j
                                 )
                              
                              −
                              
                                 (
                                 
                                    (
                                    
                                       t
                                       v
                                       *
                                    
                                    +
                                    60
                                    )
                                 
                                 −
                                 
                                    t
                                    
                                       v
                                       ∘
                                    
                                    *
                                 
                                 )
                              
                           
                        . If 
                           
                              p
                              u
                              s
                              h
                              ≤
                              (
                              
                                 t
                                 v
                                 ′
                              
                              −
                              
                                 t
                                 v
                                 *
                              
                              )
                              ,
                           
                         with 
                           
                              
                                 t
                                 v
                                 *
                              
                              <
                              
                                 t
                                 v
                                 ′
                              
                              ,
                           
                         then 
                           
                              P
                              v
                              *
                           
                         dominates 
                           
                              P
                              v
                              ′
                           
                        . Otherwise, no conclusion can be made and the label 
                           
                              P
                              v
                              ′
                           
                         would be added to 
                           
                              
                                 P
                                 ¯
                              
                              v
                           
                        . Algorithm 3, check-dominance, enforces our adjusted dominance rule among pairs of labels using the aforementioned exception rules.
                        
                     

Using the check-dominance algorithm we update the set of non-dominated labels 
                           
                              
                                 P
                                 ¯
                              
                              v
                           
                         at node v. Let the set 
                           
                              L
                              v
                           
                         be the set of newly extended labels to node v at each iteration. update-
                           
                              
                                 P
                                 ¯
                              
                              
                                 (
                                 
                                    
                                       P
                                       v
                                    
                                    ¯
                                 
                                 ,
                                 
                                    L
                                    v
                                 
                                 )
                              
                           
                         adds 
                           
                              L
                              v
                           
                         to 
                           
                              
                                 P
                                 v
                              
                              ¯
                           
                         while removing all dominated labels. For each newly generated path Pv
                         in 
                           
                              L
                              v
                           
                         and each path 
                           
                              P
                              v
                              ′
                           
                         in 
                           
                              
                                 
                                    P
                                    v
                                 
                                 ¯
                              
                              ,
                           
                         the algorithm removes the dominated labels from both sets. At the end, all the non-dominated members of the filtered sets 
                           
                              L
                              v
                           
                         and 
                           
                              
                                 P
                                 v
                              
                              ¯
                           
                         jointly constitute the updated set 
                           
                              
                                 P
                                 v
                              
                              ¯
                           
                        .


                        Algorithm 5
                         summarizes the overall DP procedure for elementary shortest path problems with time-windows and non-triangular separations (ESPP-TW-NTS). To this end, let A be the set of nodes having negative reduced costs and B the set of nodes that have unextended labels and require further examination.

In this section, we overview certain elements of the proposed B&P algorithm related to the DP procedure and the branching scheme. In our computational study, we contrast two implementations of our DP approach. The first, simply referred to as DP, is delineated in Algorithm 5, ESPP-TW-NTS. The second is an enhanced DP (EDP) procedure with the following details that aim at accelerating its computational performance:

                        
                           1.
                           
                              Multiple columns: In the course of solving the subproblem, the DP procedure often constructs multiple labels/columns that have a negative reduced cost and ultimately retains one that minimizes the reduced cost. Instead of adjoining only the best column to the RMP, EDP augments the RMP with up to k columns having a negative reduced cost, where k is a user-specified scalar (set to 20 in our computations). Similar strategies have been empirically observed to accelerate CG techniques as in Kohl (1995) or Larsen (1999). Ghoniem and Sherali (2009) additionally advocate that every column that prices out favorably in a CG iteration be iteratively complemented with multiple columns that form a feasible 0–1 solution to the set partitioning formulation, as possible (even if certain complementary columns turn out to have nonnegative reduced costs).


                              Heuristic solution of subproblem with CPU time threshold: At early iterations of CG approaches, the RMP may not produce useful (near-optimal) dual variable values and, hence, certain labels produced may not ultimately be part of the set partitioning LP solution. We, therefore, set a time limit, denoted by ε, for the computational time of the DP procedure. Specifically, if negative reduced cost labels/columns are identified within ε CPU seconds, the DP procedure terminates and returns these labels for inclusion in the RMP. Otherwise, the DP procedure continues until an optimal label is identified. The ε-parameter can be fine-tuned depending on the difficulty or the size of the problem instances examined. In our computational study, we set ε = 1 CPU seconds.


                              Dominance rule: The dominance rule in Algorithm 3 plays an important role in eliminating inferior labels. This, in turn, reduces the size of the problem and accelerates the computational performance of the DP procedure. In this strategy, we use a relaxed version of the dominance rule with the following adjustments:

                                 
                                    •
                                    Relax the condition 
                                          
                                             
                                                R
                                                v
                                                ′
                                             
                                             ⊆
                                             
                                                R
                                                v
                                                *
                                             
                                          
                                        in Algorithm 3;

If the DP procedure does not find labels with negative reduced costs at termination, then enforce the condition 
                                          
                                             
                                                R
                                                v
                                                ′
                                             
                                             ⊆
                                             
                                                R
                                                v
                                                *
                                             
                                          
                                        and re-run DP;

If no label having a negative reduced cost is produced, then terminate the CG scheme;

Otherwise, for the next CG iteration solve the subproblem using the relaxed dominance rule.

We adopt a depth-first strategy in the proposed B&P algorithm. Exploiting the similarity between the MRASP and the VRPTW, we implement a branching scheme similar to the notion of branching on flow variables in the VRPTW (Desrochers et al., 1992). Specifically, we branch on a flow variable 
                        
                           f
                           
                              
                                 j
                                 1
                              
                              
                                 j
                                 2
                              
                           
                        
                      whereby 
                        
                           
                              f
                              
                                 
                                    j
                                    1
                                 
                                 
                                    j
                                    2
                                 
                              
                           
                           =
                           1
                        
                      implies that aircraft j
                     1 immediately precedes aircraft j
                     2 in the columns generated and 
                        
                           
                              f
                              
                                 
                                    j
                                    1
                                 
                                 
                                    j
                                    2
                                 
                              
                           
                           =
                           0
                        
                      implies the weaker restriction that aircraft j
                     2 does not immediately follow aircraft j
                     1 in the columns generated. Such branching decisions can be readily incorporated into the DP procedure by including or excluding the corresponding arc (j
                     1, j
                     2) in the paths constructed.

In this section, we compare the computational performance of the proposed B&P algorithm against solving a classical MIP model for the multiple-runway aircraft sequencing problem using branch-and-bound/cut techniques (as implemented in CPLEX 12.5). The MIP model was implemented and solved using AMPL/CPLEX. The B&P algorithm, including solving the column generation subproblem using the proposed DP, was coded in C
                        #
                      under Visual Studio. All runs were performed with a time limit of 3600 CPU seconds on a Windows 7 professional 64-bit operating system with an Intel Core i7-2600 CPU with 3.40 Gigahertz and 12 Gigabyte RAM desktop.

In this section, we present computational results for problem instances that are based on Doha International Airport. An examination of landings and departures over 18-month of data in recent years indicates that peak activity involves nearly 50 aircraft during certain hours of the day (Farhadi, Ghoniem, & Al-Salem, 2014). Specifically, peak arrival activity occur at 3, 15, and 20 GMT (Doha time being GMT + 3:00), whereas busier hours of the day for departures are at 5, 17, and 22 GMT. A set of eight prototypical instances are reported in Table 2
                         with m = 2, 3, and 4 runways. The recently inaugurated Hamad International Airport has two parallel, independent runways, and the instances with a higher number of parallel runways do no reflect the airport configuration and are considered for computational purposes only. Aircraft, whether departures or arrivals, are predominantly heavy and large in our instances (as opposed to “Small”). A time-window of 15 minutes is assigned for each aircraft operation and runways are used in a mixed-mode setting, whereby both departures and arrivals can use the same runway.


                        Table 2 specifies for each of the 8 instances its number, the number of aircraft, and the number of runways considered. The CPU time (seconds) and the optimality gap within one CPU hour are reported for solving the MIP formulation using CPLEX. For the B&P algorithm, the root-node gap, the total CPU time, and the number of B&P nodes explored to achieve an optimal solution are provided. We observe that these instances are intractable using CPLEX for m = 2 and 3 runways for which the B&P algorithm yields optimal solutions and presents a more attractive alternative. However, these instances become substantially easier and, in fact, mostly solvable in manageable times by CPLEX for m = 4 runways. In this case, the comparison between CPLEX and the B&P algorithm is mixed, with an overall more consistent performance by the B&P algorithm. Note for example, for m = 4, CPLEX solved the first instance in about 50 CPU minutes and the last instance in a fraction of one CPU second. Further investigation of both approaches is provided next with a larger set of randomly generated instances.

We delineate in Section 5.2.1 a data generation scheme that we used to construct additional computationally challenging instances. The associated results are reported in Section 5.2.2.

To further demonstrate the computational challenges that can arise with small- and mid-sized problem instances, we generated a test-bed of randomly simulated instances. We considered 15 problem sizes, each characterized by the number of aircraft, n, and the number of runways, m: 15-aircraft instances with 2, 3, and 4 runways and 20/25/50-aircraft instances with 2,…, 5 runways. For each (n, m) combination, five instances were generated, resulting in a total of 75 instances that are available at the following URL: http://ahmed.ghoniem.info/download/MASP-SET.txt.

The FAA minimum aircraft separation times were adopted as displayed in Table 1. Aircraft ready-times were randomly generated using a discrete uniform distribution over the interval 
                              
                                 (
                                 0
                                 ,
                                 γ
                                 
                                    n
                                    m
                                 
                                 )
                                 ,
                              
                            where γ was selected in the interval (30,100). The parameter γ simulates the inter-arrival time between aircraft, whereby smaller γ values result in busier aircraft activity and computationally more challenging instances. As such, as the value of n increased, we increased γ to curtail the difficulty of the problems. Further, for the same value of n, we reduced the value of γ as the number of runways increases. For example, for (n, m) = (15, 2), (15, 3), and (15, 4), we selected γ = 48, 42, and 36, respectively, whereas for (n, m) = (20, 2), (20, 3), (20, 4), and (20, 5), we set γ = 66, 60, 54, and 48, respectively. All the γ values are summarized in the result tables in Section 5.2.

The operation types (Arrival/Departure) were randomly assigned to aircraft using a discrete uniform distribution with equal likelihood (
                              
                                 
                                    1
                                    2
                                 
                                 /
                                 
                                    1
                                    2
                                 
                              
                           ). Likewise, aircraft weight classes (Heavy/Large/Small) were randomly assigned to aircraft using a discrete uniform distribution with equal likelihood (
                              
                                 
                                    1
                                    3
                                 
                                 /
                                 
                                    1
                                    3
                                 
                                 /
                                 
                                    1
                                    3
                                 
                              
                           ). The weight wj
                            reflects the aircraft operation type and its weight class. In our study, the greatest weight of 6 was assigned to heavy arrivals and the least weight of 1 was given to small departures. Every aircraft was prescribed a time-window of 600 seconds.


                           Tables 3
                            and 4 report our computational results using the following implementation strategies:

                              
                                 •
                                 Solving the MIP model introduced in Section 2.1 directly using the branch-and-bound/cut algorithm embedded in CPLEX 12.5. We also report the final percentage optimality gap recorded by the solver whenever it reached the time limit of 1 CPU hour.

Using the proposed B&P algorithm with the base DP procedure, which is referred to as Algorithm 5 (ESPP-TW-NTS), as discussed in Section 3.

Using the proposed B&P algorithm with the enhanced DP (EDP) procedure, which includes the algorithmic features discussed in Section 4.

For both of the foregoing variants of the B&P algorithm, we report the following statistics:

                              
                                 •
                                 The percentage optimality gap recorded at the root-node of the B&P algorithm based on the CG lower bound and the best feasible solution available at this point.

The total number of columns generated in the course of the B&P algorithm.

The total CPU time (seconds).

The total number of B&P nodes explored.

Because the B&P algorithm with the base DP scheme did not terminate within 1 CPU hour for certain instances involving 25 and 50 aircraft, we also report the final B&P optimality gap in an additional column in Table 4. All instances were solved to optimality within our time limit using the B&P algorithm with EDP.


                           MIP solver and effect of 
                           γ 
                           value
                        

The MIP model failed to solve 55/75 instances in our test-bed within a time limit of 1 CPU hour. It is notable that the 15- and 20-aircraft instances, which have been generated using a tight γ value, implying congested aircraft activity over a short planning horizon, were particularly challenging for CPLEX. Over such instances, the solver optimality gap at termination varied between 1.7 percent to 24.1 percent at an average. It has been observed in the literature (e.g., Beasley et al., 2000) that solving a given instance by adding more runways tends to reduce the computational burden. The intuition behind this observation is that, although the size of the problem increases, there is an opportunity to assign aircraft to less congested runways, whereby the sequencing effort becomes more manageable for each runway. In contrast, we generated distinct instances for (n, m) combinations with an adjusted value of γ with the purpose of creating hard instances as the number of runways increases. As such, the difficulty of an instance does not just depend on the value of (n, m); it is also impacted by the congestion in aircraft activity as reflected by the value of γ. For example, instances with (n, m) = (20, 5) and γ = 48 exhibited an optimality gap of 24.1 percent at an average, whereas instances (n, m) = (50, 5) and γ = 84 exhibited an average optimality gap of 1.2 percent.


                           Comparison of implementing B&P with DP vs. EDP
                        

The B&P algorithm with the enhanced dynamic programming procedure (EDP) yielded optimal solutions to all instances in our test-bed along with substantial computational savings over the B&P algorithm with the base DP procedure and over solving the compact MIP model using CPLEX. For example, these three methodologies respectively solved instances with (n, m) = (20, 5) in 0.3, 8.6, and 36000 CPU seconds (the latter-most yielding an average optimality gap of 24.1 percent at termination). The B&P algorithm with the base DP yielded an optimal solution for all 15- and 20-aircraft instances, but exhibited an optimality gap that ranged from 0 to 16 percent for 25- and 50-aircraft instances. It is notable that the B&P algorithm with EDP solved the instances with (n, m) = (50, 5) in 72 CPU seconds at an average, whereas the B&P algorithm with DP and the solution of the MIP model with CPLEX reached the computational time limit of 1 CPU hour for most (or all) these instances.

In our experience, EDP yielded an average computational savings of about 92 percent over the base DP scheme with an accompanying reduction in the total number of B&P nodes explored. This demonstrates the usefulness of jointly enforcing the three algorithmic features in EDP: (i) appending multiple (up to 20) columns in every CG iteration; (ii) heuristically solving the subproblem provided that a column with a negative reduce cost has been identified within a time limit of 1 CPU second; and (iii) using a relaxed dominance rule, as discussed in Section 4. To further investigate the effect of these three algorithmic features, we also implemented the proposed B&P algorithm with the following “intermediate” DP (IDP) procedures:

                              
                                 •
                                 IDP1: Combines the second and third algorithmic features (time threshold and relaxed dominance rule) and skips the first feature (multiple columns).

IDP2: Combines the first and third algorithmic features (multiple columns and relaxed dominance rule) and skips the second feature (time threshold).

IDP3: Combines the first two algorithmic features (multiple columns and time threshold) and skips the third feature (relaxed dominance rule).

Whereas B&P with EDP yielded 92 percent CPU savings over the base DP scheme, the use of IDP1, IDP2, or IDP3 in lieu of EDP respectively reduced this savings to 84 percent, 89 percent, and 69 percent. This underscores the usefulness of synergistically using the aforementioned algorithmic features and demonstrates, in particular, the importance of using a relaxed version of the dominance rule as in EDP.

To complete our computational study, a few concluding remarks are in order regarding the classical benchmark instances in the literature, Airland 1–13 (Beasley et al., 2000; Pinol & Beasley, 2006). Our purpose in Section 5.1 and 5.2 is not to introduce new instances in lieu of these classical instances; rather, it is to complement them. Although Airland 1–8 (with up to 50 aircraft) are trivial for modern-day computers and newer versions of CPLEX, it would be erroneous to conclude that instances of this size tend to be solvable in manageable times. Our instances in Sections 5.1 and 5.2 demonstrate that, on the contrary, these could be quite challenging and a DP-base B&P algorithm could offer an attractive alternative. It seems, therefore, pertinent to enlarge the pool of instances that are examined for runway scheduling problems.

By applying our work to Airland 1-13, our observations are summarized as follows:

                           
                              •
                              For Airland 1–7 (with up to 44 aircraft), our B&P algorithm provides optimal solutions within a few seconds. MIP solvers solve these instances in a fraction of one CPU second. Therefore, the B&P algorithm was viable, but not faster.

Our work has been designed with some commonly-used FAA separation times which require at most quadruplets of consecutive aircraft to be separated. Airland 8 presents non-triangular relationships that require a larger number of consecutive aircraft to be properly separated. It is of course possible to develop additional exceptions in the B&P algorithms and further algorithmic adjustments. However, we did not pursue this further, because this instance is solved by MIP solvers in no more than a few seconds in any case.

Larger instances, Airland 9-13, tend to be intractable for both MIP solvers and the B&P algorithm. Whereas such instances will continue to motivate developments of better exact solution methods, they have been primarily used to evaluate heuristic/metaheuristic techniques. To further examine such large-scale instances, we recommend for future research the incorporation of metaheuristics in solving the CG pricing subproblem in order to heuristically obtain high quality new columns in short times and the use of DP procedures only to prove optimality.

This paper re-examines the solution of multiple-runway aircraft sequencing problems with time-window restrictions using branch-and-price algorithms. Earlier works in the literature (Ghoniem & Farhadi, 2015; Wen et al., 2005) attempted heuristic column generation and exact branch-and-price approaches where the pricing problem was solved as an MIP using a standard commercial solver (CPLEX 12.5). Despite some improvements due to complementary column generation or stabilization techniques (as in Ghoniem and Farhadi, 2015), solving the subproblem as an MIP remained computationally onerous and prevented effective branch-and-price implementations. In contrast, this work departs from the literature on aircraft sequencing problems by solving the pricing problem as an elementary shortest path problem with time-windows and non-triangular aircraft separation times using dynamic programming. This concept, borrowed and adapted from the literature on vehicle routing problems with time-windows, proved to be particularly promising and enabled an exact solution to computationally challenging problem instances for which solving a classical 0–1 MIP was not possible, even within a time limit of 3600 CPU seconds. We also demonstrated a reduction in the computational effort of the branch-and-price algorithm itself by nearly 92 percent (especially for larger instances) by simultaneously implementing the following algorithmic features: (i) Generating up to 20 columns having a negative reduced as identified by the dynamic programming procedure during any column generation iteration; (ii) heuristically solving the pricing subproblem, provided that a column with a negative reduced cost is identified within 1 CPU second (otherwise, the subproblem is solved exactly); and (iii) using a relaxed dominance rule within the dynamic programming procedure to identify dominated labels/paths. We recommend for future research the cross-fertilization of the DP-based approach with variable neighborhood search techniques and other metaheuristic paradigms in order to further accelerate the construction of good columns in the course of the column generation procedures. Finally, it is worthwhile to investigate models and effective solution approaches that integrate taxiway and runway operations under different airport layouts.

@&#ACKNOWLEDGMENTS@&#

This research has been supported by Qatar National Research Fund under grant number NPRP 09-253-2-103. We also would like to thank three anonymous referees for their constructive comments.

@&#REFERENCES@&#

