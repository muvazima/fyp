@&#MAIN-TITLE@&#Semi-asynchronous and distributed weighted connected dominating set algorithms for wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose weighted connected dominating set algorithms for wireless sensor networks.


                        
                        
                           
                           Proposed algorithms are fully distributed and semi-asynchronous.


                        
                        
                           
                           Algorithms have 3ln(S) approximation ratio (S is the cost of the optimum solution).


                        
                        
                           
                           We provide theoretical analysis for message, time and space complexities.


                        
                        
                           
                           Algorithms are compared with the previous work through extensive simulations.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless sensor networks

Weighted connected dominating set

Distributed approximation algorithm

Backbone formation

@&#ABSTRACT@&#


               
               
                  Energy-efficient backbone construction is one of the most important objective in a wireless sensor network (WSN) and to construct a more robust backbone, weighted connected dominating sets can be used where the energy of the nodes are directly related to their weights. In this study, we propose algorithms for this purpose and classify our algorithms as weighted dominating set algorithms and weighted Steiner tree algorithms where these algorithms are used together to construct a weighted connected dominating set (WCDS). We provide fully distributed algorithms with semi-asynchronous versions. We show the design of the algorithms, analyze their proof of correctness, time, message and space complexities and provide the simulation results in ns2 environment. We show that the approximation ratio of our algorithms is 3ln(S) where S is the total weight of optimum solution. To the best of our knowledge, our algorithms are the first fully distributed and semi-asynchronous WCDS algorithms with 3ln(S) approximation ratio. We compare our proposed algorithms with the related work and show that our algorithms select backbone with lower cost and less number of nodes.
               
            

@&#INTRODUCTION@&#

WSNs do not have any fixed infrastructure and consist of sensor nodes that perform sensing and communicating tasks. Habitat monitoring, health care, environmental control, military surveillance and target tracking are example application areas of WSNs [1–3]. Backbone formation to construct a robust communication structure is a significant research area in WSNs. Backbones are provided in WSNs in order to decrease the number of messages and total time spent for routing the sensed data to the sink. By clustering the network and backbone formation, an energy-efficient topology is constructed which makes routing and data aggregation tasks easier. In clustering schemes, each node is classified as either cluster head or cluster member. Cluster members are ordinary nodes whereas cluster heads perform various task on behalf of the members of the clusters.

A WSN can be modeled as a graph G(V, E) where V is the set of vertices (nodes of WSN) and E is the set of edges (communication links between the nodes). A connected dominating set is a subset S of a graph G such that S forms a dominating set and is connected. CDSs have many advantages in network applications such as ease of broadcasting and constructing virtual backbones [4]. Due to this fact, CDSs have been extensively studied by researchers [5–7,4,8–10]. Existing CDS algorithms generally aim at minimizing the number of backbone nodes without considering other issues, on the other hand energy-efficient cluster head selection is very important for sensor networks. In the weighted connected dominating set (WCDS) construction problem, the total weight of the set is aimed to be minimized. When the node weights are related to their energy then WCDS becomes a robust backbone architecture. To the best of our knowledge, although central WCDS is studied by researchers [11–14], there are few work on distributed WCDS construction [15–18].

In this study, we propose WCDS algorithms for energy-efficient backbone formation for sensor networks. For WCDS construction, we firstly design a weighted dominating set algorithm then we provide a weighted Steiner tree algorithm to connect dominators. Our proposed algorithms are semi-asynchronous and fully distributed in nature making them suitable for large scale applications in sensor networks. We use β synchronizer independent from the timer events.

The rest of this paper is organized as follows. In Section 2, the network model, backbone formation problem and distributed algorithm model with the synchronizers are described and the related work is surveyed in Section 3. The proposed algorithms are described and analyzed in Section 4 and Section 5. The results of performance tests of the proposed algorithms are presented in Section 6. The performance evaluation of a sensor network application is analyzed in Section 7 and conclusions are given in Section 8.

@&#BACKGROUND@&#

The following assumptions are made about the network [19]:
                           
                              •
                              Each node has distinct node_id.

The nodes are stationary.

Links between nodes are symmetric. Thus if there is a link from u to v, there exists a reverse link from v to u.

Nodes do not know their positions and they are not equipped with a position tracker like a GPS receiver.

Each node knows its neighbors and its own energy.

Based on these assumptions, the network may be modeled as a node weighted undirected graph G
                        
                           w
                        (V
                        
                           w
                        ,
                        E) where V
                        
                           w
                         is the set of vertices (nodes) with weights (costs), E is the set of the edges. A node’s weight (w) is set as 1/e where e is its energy. An example weighted undirected graph model is depicted in Fig. 1
                         where ids are written inside nodes, weights and energies (in Joules) are placed near to nodes.

Clustering is a basic method to group similar objects from a whole set of objects. In networks, clustering is performed to simply partition the whole network into subnetworks to ease communication tasks. Backbone formation is the construction of the virtual path of cluster heads to provide the relaying of sensed data to the sink. Backbone formation objectives for sensor networks can be listed as follows:
                           
                              1.
                              Nodes may initiate the backbone formation operation at any time locally. Distributed time synchronization can be a costly operation for battery powered sensor nodes. Hence, these operations should be distributed and asynchronous.

The cluster heads are the servers of their cluster members. They collect sensed data from their members to process, aggregate, filter and route this data to the sink. A cluster head may consume its energy very fast, thus selection of cluster heads with high energy is crucial.

3 The backbone formation algorithms should be independent from the underlying protocols as much as possible to interface to various MAC and physical layer standards such as in [20–24].

4 The algorithms should be efficient in terms of time, message and space complexity to provide low energy consumptions of sensor networks.

In a distributed algorithm each device starts in an initial state S
                        
                           i
                         ∈ S, and changes its state from S
                        
                           i
                         to S
                        
                           j
                         and may output an O
                        
                           n
                         ∈ O after receiving an input I
                        
                           k
                         ∈ I according to defined state transition procedures. An input can be an interval event such as a timer interrupt; it can be an external event such as a neighbor’s failure or message receiving. The operation is divided into rounds in synchronous communication where each operation step is executed in a round. To be independent from the timer events, synchronizers may be used to design semi-asynchronous algorithms for sensor networks [25]. One of the most practical synchronizers that is suitable for sensor network algorithm design is the β synchronizer. To maintain a β synchronizer, firstly, a rooted tree should be constructed. Each node should know its children and parent in this tree. When a node completes its operation and receives OK from children, it sends OK message to its parent. Since a sensor network has a natural root node, the sink, the implementation of this synchronizer for sensor networks is straightforward [26].

@&#RELATED WORK@&#

A two-phased CDS algorithm is proposed by Wu [8], in which initially each vertex marks itself as dominator due to some predefined rules by exchanging neighbor lists. Dai [9] and Cokuslu [10] added extra heuristics to Wu’s algorithm to reduce the size of the connected dominating set. Besides, there are many studies on CDS construction [27,5–7,28,29,4,8–10] where the O(log(∆)) approximation ratio (∆ is the maximum node degree) can be achieved in O(log2(∆)) rounds [28]. All of these algorithms do not use node weights, they focus on the minimization of the number of dominators. Thus they are out of our concern.

Chvatal proposed a central weighted set cover based dominating set algorithm (CENTSET) with lnS approximation ratio where S is the minimum weight of the dominating set [30]. In each round, the dominator with the minimum weight ratio is chosen and it is covered with its neighbors. The algorithm stops when all nodes are covered. The weight ratio of the node n with cost c
                     
                        n
                      is calculated as c
                     
                        n
                     / Γ
                     
                        u
                      where Γ
                     
                        u
                      is the weight of uncovered neighbor nodes. In [31,5], the authors proposed the distributed synchronous weighted dominating set algorithm (SSET) which is the distributed version of the CENTSET. In SSET, each node finds the weight of its two hop neighbors (2-hop span), then a node enters dominating set if it has the smallest weight ratio among its 2-hop span. Chatterjee proposed a weighted maximal independent set based dominating set algorithm for ad hoc networks [15]. In this algorithm, a node enters the dominating set if it has the smallest weight ratio among dominatee neighbors. After this state change, the dominator node informs its neighbors about its state where the dominatee neighbors check their neighbor’s weight until all nodes are covered. Bao proposed an algorithm in which a node becomes a dominator if it has the smallest weight ratio among its one-hop neighbors or it has the smallest weight ratio among one of its two-hop neighbors excluding one-hop neighbors [16]. Chatterjee and Bao’s algorithms may produce weighted dominating sets with very high costs as shown in [17]. To further decrease the weight of the dominating set, Wang proposed a two phased weighted CDS algorithm where the first phase constructs dominating set [17]. In this phase, nodes first construct a MIS similar to [15], then each node runs the CENTSET on its 2-hop span and becomes dominatee if a node with its neighbors are covered by a smaller cost than its cost. The algorithm has an approximation ratio of min(18log(Δ),4 δ +1) for unit disk graphs where δ is the maximum ratio of costs of two adjacent wireless nodes. This approximation ratio can be high for general graphs. Our proposed weighted dominating set algorithm is a fully distributed, improved and semi-asynchronous version of SSET which aims to solve backbone formation problem in sensor networks as explained in Section 4.

In the second phase of the Wang’s algorithm, node weighted minimum spanning tree (MST) algorithm is executed to connect the dominators. The approximation ratio of the second phase is 10 for the unit disk graphs but may be high for general weighted graphs as shown in Section 4.2 since weight ratio of a connector is static during the execution of the algorithm. Our algorithms update the weight ratio of the candidate connectors in each round to further decrease the total weight of the selected connectors by simplifying the rules in Klein’s central node weighted Steiner tree algorithm which has an approximation ratio of 2 lnS 
                     [32]. In Klein’s algorithm the connector with the smallest weight ratio is chosen as the connector. The weight ratio of a connector is calculated as: ((cost of the node plus sum of distances to the trees)/(number of trees)) where a tree is a connected component of the dominators. When a connector is selected, the neighbor trees are merged with this connector. The algorithm ends when all dominators are in a single tree. Since our focus is the distributed and deterministic node weighted Steiner tree construction, we omit the unweighted algorithms like the one in [33], probabilistic algorithms in [18] and other central algorithms in [12–14].

Guha proposed that a WCDS can be constructed in two phases centrally [34]. In first phase, a node weighted dominating set algorithm is executed. In second phase, in order to connect dominators produced in the first phase, a node weighted Steiner tree algorithm is applied. To achieve this, Guha proposed a central WCDS algorithm by simply applying CENTSET and Klein’s algorithm sequentially on an undirected node weighted graph. The approximation ratio of this algorithm is 3 lnS where S is the total weight of the optimum solution.

In this study, we propose a semi-asynchronous and fully distributed version of Guha’s algorithm. In order to achieve this we should design distributed approximation algorithms for both CENTSET and Klein’s algorithm. We relax some constraints of Guha’s algorithm in order to decrease the time, message and space complexities. At the same time, we show that the approximation ratios of our algorithms are still 3ln(S). To the best of our knowledge, our algorithms are the first fully distributed and semi-asynchronous WCDS algorithms with 3ln(S) approximation ratio.

Our motivations to design the weighted dominating set algorithm are followings:
                           
                              1.
                              Approximation ratio of Wang’s algorithm is high for networks modeled with undirected weighted graphs. Example cases are given in Fig. 2
                                 .a and b where weights are written with small letters and placed near to nodes with their ids that are written with capital letters. Also w, ϵ, α ∈ ℝ+, ϵ ≤ 0.0001 w and α ≥ 2 in Fig. 2.a and b. Ideal algorithm and SSET select {B
                                 1, B
                                 2,…, B
                                 
                                    n
                                 } as dominators because weight ratio of each node in this set equals to (w + ϵ)/(w (4+2 α)+4 ϵ) is smaller than their neighbors’ weight ratios. This selection results n dominators with n (w + ϵ) total weight. Wang’s algorithm first selects {A
                                 1, A
                                 2,…, A
                                 
                                    n
                                 } as dominators since their weights are smaller than their neighbors’ weight. After that {C
                                 1, C
                                 2,…, C
                                 
                                    n
                                 } is selected as dominators because {B
                                 1, B
                                 2,…, B
                                 
                                    n
                                 } become dominatees. Lastly, {C
                                 1, C
                                 2,…, C
                                 
                                    n
                                 } quit to become dominators since {B
                                 1, B
                                 2,…, B
                                 
                                    n
                                 } cover their neighbors with lower cost. Wang’s algorithm selects {A
                                 1, A
                                 2,…, A
                                 
                                    n
                                 } and {B
                                 1, B
                                 2,…, B
                                 
                                    n
                                 } as dominators, thus produces 2 n dominators with n (w + ϵ)+ nw total weight approximately 2 times more than those of SSET in Fig. 2.a. A worse scenario is given in Fig. 2.b. Ideal algorithm and SSET select only B
                                 1 as dominator since its weight ratio equals to (w + ϵ)/(w (n +1)+ ϵ) and it has the smallest weight ratio among all nodes. This selection results (w + ϵ) total weight. On the other side, Wang’s algorithm selects {A
                                 1, A
                                 2,…, A
                                 
                                    n
                                 } as dominators since their weight is smaller than B
                                 1’s weight and produces n dominators with nw total weight approximately n times more than those of SSET in Fig. 2.b.

In SSET algorithm, the nodes are assumed to be time synchronized. To maintain this situation, the nodes should implement a time synchronization protocol [35] which can consume energy of sensor nodes.

A flooding based approach can be designed to disseminate weight ratios of nodes like the one in [36]. But in this case, for a network with N nodes, message complexity can be as large as Θ (N
                                 2). For battery constraint sensor nodes, this theoretical upper bound may not be suitable.

We propose a semi-asynchronous weighted dominating set algorithm (ASYNSET) which is an improved, semi-asynchronous, weighted and sensor network adopted version of the SSET algorithm. In ASYNSET, rounds are triggered by the sink node which is the root of a β synchronizer. In this way, the nodes do not need to run a time synchronization protocol as in SSET. The β synchronizer tree can be constructed by a distributed tree algorithm like the one in [26]. The message complexity of the algorithm is decreased by using the idea in SSET [31,5] that is given in Observation 1.
                           Observation 1
                           If node nv
                              ’s weight ratio (w(v)) is smaller than its 2-hop neighbors, it is selected as a dominator by the CENTSET algorithm.

The steps of the ASYNSET algorithm is given in Algorithm 1. When a node awakens, it firstly sends its energy by MY_ENERGY message to its neighbors. A node must collect the energy values of its neighbors to calculate its weight ratio which is then sent as in MY_WRATIO message to the neighbors. After a node receives all MY_WRATIO messages from its neighbors, it sends a 2HOP_WRATIO message including the id of the node having the smallest weight ratio. When all of these messages are transmitted successfully, the nodes learn the weight ratio of their two-hop neighbors, if a node has the smallest weight ratio, it sends a CONNECT message and becomes a dominator node. If a non-dominator node receives a CONNECT message for the first time, it sends a CONNECTED message to its neighbors indicating that it is connected to a dominator node. After a node finishes its operation in a round, it executes the synchronize procedure which is given in Algorithm 3 with the other procedures. A node will send OK message to its parent in β synchronizer tree if it receives OK from its children and it executes the synchronize procedure. The OK messages are convergecasted to the sink node in this way and if a dominator is selected in a round, the sink node receives OK (TRUE) message. When the sink node receives OK message with TRUE parameter, it multicasts START message to neighbors for starting the new round, otherwise END message is multicasted to terminate the execution of the algorithm.
                           Algorithm 1
                           ASYNSET Algorithm for nodem
                              
                              
                                 
                                    
                                 
                              
                           

Our motivations for designing the distributed semi-asynchronous weighted Steiner tree algorithm (ASYNTREE) are given in Fig. 3
                        .a and b where the performance of the MST approach is far from the optimum. We simplify the connector selection rule in Klein’s algorithm in order to design the distributed versions which aim to select a small number of low cost nodes as connectors. We assume the cost of each edge as zero. The rules for the connector selection of our algorithms are given below:
                           
                              •
                              If a candidate node connects more than one tree, its weight ratio is calculated as (cost of the node)/(number of trees to be connected).

If a candidate node is a neighbor of only one tree and has a candidate neighbor which is a neighbor of at least one of the other trees, its weight ratio is calculated as (sum of cost of the node and its candidate)/(number of trees to be connected).

The node with the smallest weight ratio is selected in each round.

By applying these rules, our algorithms choose the same connectors with the ideal algorithm as shown in Fig. 3.a and b. Ideal algorithm and ASYNTREE select 1 connector with w+ϵ total weight whereas MST algorithm selects w+1 connectors with 2w+ϵ total weight in Fig. 3.a. A worse scenario is given in Fig. 3.b. Ideal algorithm and ASYNTREE select 1 dominator with w+ϵ total weight whereas WANG’s algorithm selects n dominators with nw total weight in Fig. 2.b. The reason of this increase in the performance compared to the MST approach due to fact that the weight ratio of each candidate connector is calculated as a function of its cost and number of neighbor trees and in each iteration it is updated as opposed to the static weight ratios in MST approach.

We use rooted tree structures consisting of the dominators which are in the same connected component in order to decrease the message complexity. Each dominator should know its children and parent in its dominator tree. To provide asynchronous operation we modify and adopt the GHS algorithm [37] and we use a β synchronizer.

The steps of ASYNTREE algorithm are given in Algorithm 2. When a dominator node awakens it firstly runs the modified GHS algorithm in order to calculate its tree id and the total node count in its tree. The modifications are listed below:
                           
                              •
                              We added an extra field to the REPORT message which is used by the core nodes to calculate the total number of nodes in tree. An example operation is given in Fig. 4
                                 . The black nodes in this example are the core nodes. The directions of the edges show the flow of the REPORT message. A leaf node in this tree sends REPORT message where it only knows itself. After a node receives all REPORT messages from its children, it sends REPORT(total count +1)

After the core nodes construct the minimum spanning tree, one of them is chosen as the leader of the tree which then sends an END ((tree id, node count of the tree) message to its children. This message is forwarded to all nodes in the tree to inform the tree id and the node count of the tree.

When a node receives an END message, it makes a synchronization operation on the β synchronizer tree.

ASYNTREE Algorithm for nodem
                              
                              
                                 
                                    
                                 
                              
                           

After the dominator nodes finish the execution of the modified GHS algorithm, the sink node starts the execution of the next step by sending a START message. When dominator nodes receive this message, they send TREE_INFO messages to inform candidate connectors which are dominatees at that time. When a dominatee receives TREE_INFO from all dominator neighbors it sends DTEE_INFO to its dominatee neighbors and wait for the same message from them. After TREE_INFO and DTEE_INFO messages are exchanged, a dominatee node calculates its weight ratio by using our heuristic and sends MY_WRATIO message. When a dominator node receives all MY_WRATIO messages from its neighbors and children in dominator tree, it sends this message to the parent in this dominator tree. After a dominator tree leader receives all MY_WRATIO messages, it sends a CONNECT message including the id of the candidate having the smallest weight ratio or it sends a NOT_CONNECT message if the smallest weight ratio is ∞. When a dominator node receives a CONNECT or NOT_CONNECT message it forwards this message by sending to its neighbors. When a dominatee node receives a CONNECT message which includes the id of another dominatee node or a NOT_CONNECT message, it finishes the execution of this round and calls synchronize procedure. Otherwise it becomes a real candidate for the next connector. The nodes aggregate the weight ratios to find the smallest by sending CONNECT_REQ on the β synchronizer tree. When the sink node finds the smallest weight ratio, it sends TREE_MRG to its children in β synchronizer tree to merge the trees with the newly selected connector. If all of the dominators are connected on the same tree, the sink node ends the algorithm by sending an END message.

@&#ANALYSIS@&#

In this section we give proof of correctness, approximation ratio, message complexity, time complexity and space complexity analysis.


                        
                           Observation 2
                           ASYNSET algorithm can be divided into 6 steps.
                                 
                                    1.
                                    Each node learns energies of its neighbors to calculate its weight ratio at the beginning of the algorithm.

Each node learns the weight ratio of its 2 hop neighbors to find the node with the smallest weight ratio.

Nodes having the smallest weight ratio among its 2 hop neighbors enter dominating set.

After a new dominator is selected, its 2 hop neighbors update their weight ratios.

Nodes are synchronized after a round is finished.

Algorithm execution is terminated at each node after dominating set is constructed.

ASYNSET produces the same dominating set with the CENTSET algorithm and the execution is terminated at each node.

Assume the contrary. In this situation, execution of at least one of the step of ASYNSET given in Observation 2 should fail. At first round all nodes exchange MY_ENERGY messages to acquire the energy information of their neighbors, so Step 1 is achieved. Nodes learn the weight ratios of their 2 hop neighbors by firstly transmitting MY_WRATIO messages then 2HOP_WRATIO messages which provides Step 2. Then a node having the smallest weight ratio among its 2 hop neighbors enters dominating set as in Observation 1 and sends CONNECT message to its neighbors, so Step 3 is achieved. When a node receives CONNECT message it marks the source node as covered and sends a CONNECTED message to its neighbors. The recipients of the CONNECTED messages marks the source nodes as covered so the weight ratio is updated successfully that provides Step 4. Before finishing the execution of a round, each node calls the synchronize procedure and sends a OK message to its parent in β synchronizer tree when it receives all OK messages from its children, so that synchronization process is completed successfully and Step 5 is provided. If a node receives the OK message with TRUE field or it is selected as a dominator in a round, it sends the OK message with TRUE parameter. The rounds are triggered by the sink node with the dissemination of the START, after it receives OK messages with TRUE parameter from its children in β synchronizer tree. At the beginning of a round, if a node is not covered it sends a NOT_CONNECTED message to its neighbors thus all nodes can distinguish the covered and uncovered nodes. Sink node terminates the algorithm by sending an END message if a new dominator is not selected in previous round. By applying these operations, Step 6 is provided. All steps are achieved in ASYNSET, thus we contradict with our assumption, ASYNSET produces the same dominating set with CENTSET.

ASYNTREE algorithm can be divided into 7 steps.
                                 
                                    1.
                                    Connected dominators construct trees at the beginning of the algorithm.

Each dominatee calculates its weight ratio.

Each leader dominator learns weight ratios of candidate dominatees.

Dominatee with the smallest weight ratio is chosen as the new dominator (connector).

Weight ratios of dominatees are updated after the selection of the new dominator.

Nodes are synchronized after a round is finished.

Algorithm execution is terminated after a connected dominating set is constructed.

ASYNTREE connects the elements of a dominating set and the execution is terminated at each node.

Assume the contrary in which execution of at least one of the steps of ASYNTREE given in Observation 3 should fail. At the beginning of the algorithm each dominator learns its tree information by using modified GHS, this provides Step 1. In the other rounds, each dominatee calculates its weight ratio as in proposed heuristic by receiving TREE_INFO and sending DTEE_INFO messages, so Step 2 is provided. A leader dominator can learn all weight ratios of the neighbor dominatees by receiving aggregated MY_WRATIO messages where Step 3 is provided. A dominatee becomes a real candidate after receiving CONNECT messages from all neighboring trees when all nodes synchronize with the sink by sending the smallest weight ratio in CONNECT_REQ messages which they have received, sink finds the connector with the smallest weight ratio. Sink node connects the trees by sending TREE_MRG message so tree_ids are updated. By applying these operations, Step 4, Step 5 and Step 6 are achieved. The sink node terminates the algorithm if the smallest weight ratio is ∞ by sending an END message where Step 7 is provided. We contradict with our assumption since all steps are achieved in ASYNTREE.


                        
                           Theorem 3
                           The total approximation ratio of ASYNSET and ASYNTREE to the optimum WCDS is 3ln(S).

From Theorem 1, ASYNSET produces the same dominating set with CENTSET. Thus the approximation ratio of ASYNSET is lnS.

In ASYNTREE, we apply Klein’s steiner-tree algorithm in a distributed manner. Klein’s algorithm minimizes the total cost of nodes and edges in G′, and our problem aims at minimizing the total cost of nodes in S only, and therefore, we can assume the cost of each edge zero. As Klein’s algorithm does not forbid zero-cost edges, their performance bound ratio 2 lnS is still valid. The output of Klein’s algorithm is used as the output of our problem.

For any instant of input, let c
                              1 be the total cost of nodes in S in the output, and c
                              1
                              
                                 opt
                               be the cost from the optimal solution to the problem; and with the assumption that the edges are of zero cost, define c
                              1
                              
                                 opt
                               to be the minimum cost of the problem, which minimizes the total cost of nodes and edges.

For convenience, we call the problem we are tackling problem 1, and the other problem, which counts the edge-costs, problem 2. From the optimal solution of problem 1, counting the costs of tree edges, we have OK. On the other hand, from the optimal solution of problem 2, taking away the tree edges, we have N. Therefore, Θ. By Klein’s result, we have |λ
                              
                                 m
                              |N, since the output of their algorithm is used directly. Consequently, 3ln(S) approximation ratio is valid for ASYNSET and ASYNTREE.


                        
                           Definition 1
                           
                              λ set: is the set of dominators of a connected component in G’ graph in which dominators at most 2 hops away from each other produced by the ASYNSET algorithm running on G graph are assumed to be connected in G’ graph. The λm
                               is the set with the maximum cardinality among λ sets for a graph G.

ASYNSET terminates in |λ
                              
                                 m
                              | rounds.

Assume that there are multiple λ sets where λ
                              
                                 i
                               ={v
                              
                                 i1, v
                              
                                 i2, v
                              
                                 i3,…}. A v
                              
                                 ij
                               and v
                              
                                 kl
                               can be selected as dominators by ASYNSET algorithm concurrently in a round when i ≠ k since they are at least 3 hops away from each other as given in Definition 1. Algorithm selects dominators in this way until all of the elements of the |λ
                              
                                 m
                              | are marked as dominator.


                              The message complexity of a round in ASYNSET is O(N).
                           

At the worst case a node sends at most 6 messages in a round: START, MY_ENERGY, MY_WRATIO, 2HOP_WRATIO, CONNECT and OK. Thus the message complexity of a round is O(N).

The message complexity of the ASYNSET algorithm is Θ (|λ
                              
                                 m
                              |N), at the worst case is O(N
                              2), at the best case is Ω (N).

The algorithm terminates in λ
                              
                                 m
                               rounds as given in Lemma 1 where the message complexity of each round is O(N) as proven in Lemma 2. So that the message complexity of the algorithm is Θ (|λ
                              
                                 m
                              |N). At the worst case for |λ
                              
                                 m
                              | = N, the message complexity is O(N
                              2). The best case occurs when |λ
                              
                                 m
                              | =1, the message complexity in this case is Ω (N).

The message complexity of the modified GHS algorithm is O(Nlog(N)).

The message complexity of the GHS algorithm is O(N log(N)+ M)[37] where M is the edge count. It can be implemented with O(N log(N)) radio multicast messages. In the modified GHS algorithm, additionally each node sends a END and OK message with an overhead of O(N) message complexity, thus message complexity is still O(N log(N)).

The message complexity of the ASYNTREE algorithm is Θ (N (|C| +log(N))), at the worst case is O(N
                              2), at the best case is Ω (N log(N)) where C is the connector count.

A dominator node may send TREE_INFO, MY_WRATIO, CONNECT or NOT_CONNECTED, CONNECT_REQ and TREE_MRG messages concurrently a dominatee node may send DTEE_INFO, MY_WRATIO, CONNECT_REQ and TREE_MRG messages in a round. Thus the message complexity of a round in ASYNTREE is O(N). The total message complexity of the ASYNTREE algorithm is Θ (N (|C| +log(N)) from Lemma 3. At the worst case for |C| ∈ O(N), the message complexity is O(N
                              2). At the best case for |C| =1, the message complexity is Ω (N log(N)).


                        
                           Lemma 4
                           Assuming that diameter is D and degree is ∆, the time complexity of a round in ASYNSET is O(D+∆).


                              β synchronizer tree can be constructed in O(D) time [26]. A round is started by the sink node with the dissemination of the START message in O(D) time. Then idle nodes send NOT_CONNECTED message to their neighbors where this operation may take O(Δ) time. After that the nodes exchange their weight ratios by sending MY_WRATIO messages which takes same time as the previous operation. This operation is followed by the transmission of 2HOP_WRATIO, CONNECT messages where both of these operations may accomplish in O(Δ) time individually. The recipient of the CONNECT messages send CONNECTED message that takes O(1) time since each of this recipient is at most 2 hops away from each other. At last, the nodes end the execution of the round and terminate by sending OK messages in O(D) time. The time complexity of a round is: O(2 D +4 Δ +1) ∈ O(D + Δ).

The time complexity of the ASYNSET algorithm is Θ ((D + Δ) |λ
                              
                                 m
                              |), at the worst case is O(N (D + Δ)) and at the best case is Ω (D + Δ).

The time complexity of the ASYNSET algorithm is Θ ((D + Δ) |λ
                              
                                 m
                              |) which can be derived from Lemma 1 and Lemma 4. At the worst case for |λ
                              
                                 m
                              | = N, the time complexity is O(N (D + Δ)). At the best case for |λ
                              
                                 m
                              | =1, time complexity is Ω (D + Δ).

The time complexity of the modified GHS algorithm is O(Nd
                              
                              2+
                              D) where Nd
                               is the maximum number of the elements of the dominators in the same connected component at the beginning of the algorithm.

The time complexity of the GHS algorithm is O(N
                              2) [37], since trees of connected components are constructed concurrently, the operation will be completed with the construction of the tree with the maximum node count (Nd
                              ), the time complexity of the modified GHS algorithm is O(Nd
                              
                              2). Additionally, in the modified GHS algorithm, synchronization operation takes O(D) time at the worst case. Thus the total time complexity is O(Nd
                              
                              2+ D).

The time complexity of a round in ASYNTREE algorithm is O(N
                              
                                 d
                               
                              + D + Δ).

The round is started by the sink node either with sending START or TREE_MRG message where this operation takes O(D) time. The dominatee nodes collect TREE_INFO messages from dominator nodes, then send DTEE_INFO messages in O(Δ) time. These operations are followed by the transmission of CONNECT or NOT_CONNECTED messages in O(N
                              
                                 d
                              ) time. Lastly, nodes are synchronized in O(D) time. Consequently, the time complexity is O(N
                              
                                 d
                               + D + Δ).

The time complexity of the ASYNTREE algorithm is Θ ((C + N
                              
                                 d
                              ) N
                              
                                 d
                               + C (D + Δ)) at the worst case is O(N
                              2).

From Lemma 5 and Lemma 6, the time complexity of the algorithm is Θ ((C + N
                              
                                 d
                              ) N
                              
                                 d
                               + C (D + Δ)). At the worst case for N
                              
                                 d
                               = C = N, the time complexity is O(N
                              2).


                        
                           Theorem 7
                           The space complexity of the ASYNSET and ASYNTREE algorithm per node are Θ(∆).

In ASYNSET and ASYNTREE, for storing the states of its neighbors, Θ(∆) space is required per node. Other space consumption is constant.

The greatest message sizes in ASYNSET and ASYNTREE are 2log(N) bits and Nlog(N) bits respectively.

In ASYNSET, the messages having the greatest number of fields are MY_ENERGY and MY_WRATIO with 2 fields, this requires 2log(N) bits. In ASYNTREE, TREE_MRG message may have N ields for merging thus N log(N) bits may be required.

We implemented ASYNSET and ASYNTREE algorithms in ns2 simulator version 2.31 to test their performance with extensive simulations. To compare ASYNSET with the existing work, we implemented Chatterje’s MIS based algorithm (MIS), Bao’s algorithm (BAO), SSET algorithm, the first phase of the Wang’s algorithm (WANG) and a flooding based weighted dominating set algorithm (FLOODSET) with the same rules in ASYNSET. To compare our weighted Steiner tree algorithms, we implemented second phase of the WANG’s algorithm (WANG2nd) and a flooding based weighted Steiner tree algorithm (FLOODTREE) with the same rules in ASYNTREE. Although our proposed algorithms are asynchronous and do not need time synchronization, we assume that nodes are time synchronized in order to implement other algorithms.

We generated randomly connected networks with 100 to 400 nodes that are uniformly distributed. IEEE 802.11 radio and MAC standards readily available in ns2 simulator were chosen for lower layer protocols. Our algorithms only require send, receive primitives which are important services required from MAC and physical layer [20–24], thus various types of lower layer standards can be used. Two ray ground was used as the propagation model. The transmission power is 0.660 mW, the receive power is 0.395 mW, and the communication range of a sensor node is 250 m. We measured the performance of the algorithms for average node degrees varying between 4,5 and 6. To vary degrees, different size of flat surface areas were chosen. We also varied the initial energy of the nodes by randomly generating from 0-50J, 0-100J, 0-150J intervals. We measured the total weight of the dominators and connectors, count of dominators and connectors, energy consumption, wallclock times. The surface areas are given in Table 1
                     .

One of the most important target of the weighted dominating set algorithms is to select a low weighted backbone where the selected nodes will have high energy when the weights of the nodes are directly related to their energies. So that, we firstly measured the total weight of the dominators produced by the algorithm. Unless otherwise stated, the default node degree is 5, node count is 200 and node energies are varied between 0-100J.

In Fig. 5
                        , the weight of the dominators produced by the ASYNSET against the node degree is shown. When the node degree is increased, ASYNSET selects higher energy nodes as dominators. This shows that the algorithm responds well with the increase of the network connectivity. The weight of the dominators produced by the ASYNSET against the energy interval is shown In Fig. 6
                        . The measurements show that when the energy interval is increased, ASYNSET selects dominators with higher energy thus the total weight of the backbone decreases.

A comparison of the algorithms against the node count is given in Fig. 7
                        . The total cost of the dominators produced by the ASYNSET is the smallest among the other algorithms. WANG and BAO performs well and approximate to the ASYNSET where MIS performs the worst. Other comparisons are shown in Figs. 8 and 9
                        
                         against the varying node degree and energy interval. In all of three comparisons, the performance order of the algorithms are same.

Weighted dominating set algorithms aim to choose a small subset of nodes with low weight. Thus, minimizing the dominator count is important. In Figs. 10 and 11
                        
                        , the dominator count against the node degree and energy interval are given. At the worst case, the dominator count is one fourth of the total node count. The dominator count is stable against the varying node degree and energy interval.

The comparisons of the MIS, BAO, WANG and ASYNSET are shown in Figs. 12, 13 and 14
                        
                        
                        . ASYNSET produces the smallest dominating set compared to the other algorithms against the node count as shown in Fig. 12. ASYNSET’s performance is the best, the performance of the WANG is close to the ASYNSET and MIS performs worst with the BAO. This performance order does not change when the node degree and the energy interval is varied as shown in Figs. 13 and 14. In all algorithms except the MIS, the size of dominating set reduces when the node degree is increased as shown in Fig. 13.

Minimizing the total weight of connectors is an important objective of the node weighted Steiner tree algorithms. Thus, we measured the total weight of the connectors produced by the algorithms. Before running the Steiner tree algorithms, the dominating set algorithms are executed. The ASYNSET and ASYNTREE are executed together and to compare the performance of these algorithms, WANG and WANG (2nd) are executed in the same way. The total weight of the connectors produced by the ASYNTREE algorithm against the varying node degree and energy interval are shown in Figs. 15 and 16
                        
                        . The total weight of the connectors decrease when the node degree and energy interval are increased. As the node degree increases, the connectivity between low weighted nodes and high weighted nodes increases where ASYNTREE benefits from this fact. Also ASYNTREE runs efficiently and chooses nodes with higher energy as the energy interval increases.

Comparisons of the selected connector weight produced by the ASYNTREE and WANG (2nd) are given in Figs. 17, 18 and 19
                        
                        
                        . The total weight of the connectors of both algorithms against the total node count, node degree are approximate. Although at first look it may be stated from these results that the performance of the algorithms are similar, it should be noted that the energy of the nodes in the dominating set produced by the ASYNSET is higher than those of WANG which means that the set of candidate of connectors for ASYNTREE consists of lower energy than those of WANG (2nd). Although ASYNTREE has this drawback at the beginning of the execution, the performance of the ASYNTREE and WANG (2nd) are approximate in the end. In the next section, we show the reason for this situation.

The other important target of the weighted Steiner tree algorithms is to minimize the connector count. In Figs. 20 and 21
                        
                        , the connector count of the ASYNTREE algorithm against the varying node degree and energy interval is shown. The connector count decreases when the node degree is decreased. The reason of this situation is when the network connectivity increases, a connector may connect more trees. The performance of the ASYNTREE algorithm is stable against the varying energy interval as shown in the previous section where the total weight of the connectors decreases. The performance comparisons of the ASYNTREE and WANG (2nd) are given in Figs. 22, 23 and 24
                        
                        
                        . ASYNTREE produces less number of connectors than WANG (2nd) against the varying node count, node degree and energy interval. Although ASYNTREE and WANG (2nd) produces approximate weight of connectors as shown in the previous section, ASYNTREE produces a smaller connector set than WANG (2nd).

The energy consumption of the ASYNSET algorithm against the varying node degree is given in Fig. 25
                        . As shown in this figure, the energy consumption increases linearly as the node count increases and it behaves stable as the node degree increases. The energy consumptions of the algorithms are shown in Fig. 26
                        . The performance order of the other algorithms is: WANG, SSET, ASYNSET and FLOODSET. The energy consumption of the ASYNSET is approximately 10 times greater than the consumption of the WANG. ASYNSET consumes slightly more than SSET because of the synchronization operations. The performance order of the algorithms shows that when the algorithms get complicated by adding extra messages and extra rules in order to reduce the size and the cost of the dominating set, then the energy consumption of the algorithms increase.

In Fig. 27
                        , the energy consumption of the ASYNTREE algorithm against the varying node degree and node count is given. When the node degree is increased, the number of connectors decrease in ASYNTREE thus the number of rounds and energy consumption decreases. The comparison of the energy consumption of the weighted Steiner tree algorithms are given in Fig. 28
                        . The lowest energy is consumed by the WANG (2nd), whereas the highest energy is consumed by FLOODTREE.

As a result of our tests, it can be concluded that although our algorithms construct robust and low cost backbones for sensor networks, they consume more energy than the related work. Since energy efficiency is a very important objective for sensor networks, one may claim that our algorithms are not suitable for sensor networks. To disprove this claim, we will show an implementation of an example sensor network application on top of different backbones and measure their energy consumptions in Section 7. We will give a break-even analysis and we will show that the energy consumption of a sensor application may increase significantly if the quality of the backbone is reduced which may result that the energy consumption of the backbone formation becomes trivial compared to the energy consumption of the application.

In this section, we give the wallclock time measurements of the algorithms. In Fig. 29
                        , the wallclock time measurements of the weighted dominating set algorithms are given. The performance order of the weighted dominating set algorithms is: WANG, SSET-ASYNSET and FLOODSET. The wallclock time measurements of SSET and ASYNSET are much the same where the nodes are idle in SSET when they finish the execution of a round, on the other hand, during this idle time, the synchronization operation is executed by the nodes in ASYNSET. The time consumption of the FLOODSET is much more than the other weighted dominating set algorithms. In Fig. 30
                        , the wallclock time measurements of the node weighted Steiner tree algorithms are shown. ASYNTREE performs the best among other approaches since it is a semi-asynchronous algorithm in which there is no idle time.

In this section, we show the implementation of an example sensor network application and analyze the energy consumption of the application against two backbone architectures which are listed below:
                        
                           1.
                           The backbone constructed by the semi-asynchronous algorithms: We executed ASYNSET and ASYNTREE algorithm to form the backbone (ASYNSET+ASYNTREE).

The backbone constructed by the WANG’s algorithms: To form the backbone, we executed the first and second phases of the WANG’s algorithm (WANGALL).

The sensor network applications need two important services from the underlying network architecture: data aggregation and data routing. The data aggregation can be accomplished by clustering the network where each cluster head may aggregate the sensed data of cluster members. The data routing can be divided into two tasks as intra-cluster routing and inter-cluster routing. The intra-cluster routing operation involves the transmission of a sensed data message from an ordinary node to its cluster head, the inter-cluster operation is the relaying of the aggregated data from a cluster head to the sink along the way of the backbone.
                           Algorithm 3
                           Rooted Tree Formation and Clustering Algorithm for nodem
                              .
                                 
                                    
                                 
                              
                           

The Application for nodem
                              .
                                 
                                    
                                 
                              
                           

To accomplish the data aggregation and data routing operations, we first formed the backbone, we then constructed a tree structure rooted at the sink and finally we clustered the network. To construct rooted tree structure and clusters, sink floods CONSTRUCT_PATH message to the network where the other nodes execute the Algorithm 3. If the receiver and sender of this message is a dominator, the receiver sets its parent to the message source and forwards this message. If the receiver of this message is a dominatee and the sender is a dominator, the receiver sets its cluster head to the message source and sends IN_CLUSTER message to acknowledge the source dominator that it belongs to the cluster of the source dominator.

By using the above described network topology, each node runs the application given in Algorithm 4 where periodically each cluster member node senses, records and then sends this recorded data in a SENSED_DATA message to its cluster head. The cluster heads aggregate these messages and send them in a AGG_SENSED_DATA message over the backbone.

We measure the energy consumption of the application against the varying node count, node degree and energy interval. To evaluate the performance of the backbone structures, we do a break-even analysis. In Figs. 31, 32 and 33
                        
                        
                        , the total energy consumptions against the node count are given. The "B" letters in figures show the break-even point. The energy consumption of the network with 100 nodes is shown in Fig. 31. In this figure, the energy consumption of WANGALL exceeds ASYNSET+ASYNTREE after the 40th event. In Figs. 32 and 33 the energy consumptions of the network with 200 nodes and 300 nodes are given respectively, where WANGALL exceeds ASYNSET+ASYNTREE after the 30th event. From these measurements we may say that our proposed backbone algorithms become more energy-efficient than the WANGALL when the node count is increased.

The total energy consumptions against the varying node degree are given in Figs. 32, 34 and 35
                        
                        . The energy consumption of the network with 200 nodes and 4 degree is shown in Fig. 35. In this figure, the energy consumption of WANGALL exceeds ASYNSET+ASYNTREE after the 50th event. When the node degree is increased, our backbone algorithms are more energy-efficient as shown in Figs. 32 and 34. Lastly, we investigate the energy consumptions against the varying energy interval. As shown in Figs. 32, 36 and 37
                        
                        , when the energy interval is increased, since our algorithms produce lower cost backbones with less number of nodes, they become more energy-efficient than WANGALL.

Consequently, although our algorithms consume more energy than WANGALL during the backbone construction phase, the total energy consumed by the given sensor network application with the backbone construction of the WANGALL exceeds the total consumption of our algorithms after the 50th event at the worst case from our measurements. Besides, when the node count, node degree or energy interval is increased our proposed backbone algorithms become more energy-efficient since the quality of the produced backbone increases.

@&#CONCLUSIONS@&#

We proposed weighted connected dominating set algorithms for energy-efficient backbone formation in WSNs. We first design ASYNSET algorithm in order to produce a small weighted connected dominating set. ASYNSET is the semi-asynchronous and fully distributed version of CENTSET. After producing the weighted dominating set, we connect the dominators by designing ASYNTREE algorithm. This fully distributed algorithm use a heuristic derived from the Klein’s algorithm. We gave the analysis for the proof of correctness, approximation ratio, time complexity, message complexity and space complexity of the algorithms. All algorithms are implemented in ns2 simulation environment and the results obtained show that our proposed algorithms select lower cost backbone than the other approaches. Although our proposed algorithms consume more energy than the related work during the backbone construction phase, the backbone construction is performed initially and possibly only after a topology change in the network. On the other side, communication via the backbone is performed regularly and the energy consumption of a sensor network application is decreased when our backbone is applied instead of the others as a result of our break-even analysis. So for the energy-efficient and long-lived sensor network applications, our algorithms are favorable.

@&#REFERENCES@&#

