@&#MAIN-TITLE@&#Energy-efficient image transmission in wireless multimedia sensor networks using block-based Compressive Sensing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Energy efficient CS methodology for image transmission in WMSNs is proposed.


                        
                        
                           
                           Unique encoding algorithm for CS measurements with the Bernoulli matrix is formulated.


                        
                        
                           
                           Experimental analysis in the Atmega 128 of Mica2 to compute the execution time.


                        
                        
                           
                           Optimal range of communication distance for the proposed methodology is evaluated.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

WMSN

CS

Mica2

Atmega 128

Encoding

@&#ABSTRACT@&#


               
               
                  Wireless multimedia sensor networks (WMSNs) are capable of retrieving audio, image and video data in addition to scalar sensor data. The lifetime of these networks is mainly dependent on the communication and computational energy consumption of the node. In this paper, compressed sensing (CS)-based image transmission is proposed to reduce the energy consumption considerably with acceptable image quality. A unique encoding algorithm is formulated for the CS measurements attained with the Bernoulli measurement matrix. The proposed CS method produces better results at a lower sparsity range. Experimental analysis is performed using the Atmega 128 processor of Mica2 to compute the execution time and energy consumption in the hardware platform. The proposed CS method has a considerable reduction in energy consumption and better image quality than the conventional CS method. The simulation results show the efficiency of the proposed method.
               
            

@&#INTRODUCTION@&#

WMSN is a network of wirelessly interconnected sensor nodes equipped with multimedia devices capable of retrieving video streams, images, audio streams and scalar sensor data. The availability of inexpensive hardware such as CMOS cameras and microphones has led to the development of WMSNs. WMSNs are able to store, process in real-time, correlate and fuse multimedia data originated from heterogeneous sources [1]. WMSNs are resource constrained and have high bandwidth demand. It is essential to reduce both computational and communication energy consumptions involved in image transmission to increase the lifetime of these networks. Recently, CS has been widely used, allowing the entire signal to be determined from relatively few linear measurements. It is used to capture and represent compressible signals at a rate significantly below the Nyquist rate. It simultaneously senses and compresses the data at low complexity. In this paper, CS is used for reducing the energy consumption in WMSNs.

Candes and Wakin [2] proposed a new sampling theory that simultaneously combines sampling and compression procedures during acquisition. The use of CS theory can recover sparse signals and images from far fewer samples or measurements than traditional methods present in the WMSN. The hardware architecture proposed for the real-time implementation of CS acquisition has less complexity compared to the conventional digital camera [3]. Hence, the implementation of a CS-based real-time image acquisition system has a promising future. The sparse vector can also be estimated from coarsely quantized and noisy measurements by CS [4–6]. This can further reduce the energy consumption of the image transmission process.

Romberg [7] described the combined usage of the low-pass discrete cosine transform (DCT) and the noiselet coefficients for image acquisition. The image is reconstructed by minimizing the total variation (l
                     1 minimization). Han et al. [8] proposed that the image could be divided into dense and sparse components, which are encoded by the CS technique. The correlation between these two components is studied by using an autoregressive model. Projection onto convex sets (POCS) is used to reduce the decoding computational complexity and the number of random measurements needed for CS. Xiong et al. [9] suggested an adaptive measurement matrix to reduce the dimension of block compressed sensing (BCS)-based image representation and to improve the recovered image quality. CS-based image transmission and recovery for wireless sensor network (WSN) applications are discussed in [7–9]. However, the energy consumption of the transmission is not evaluated in any target platforms. Chen et al. [10] used CS for image compression and implemented the CS-based compression algorithm on the Intel XScale PXA270 processor. Mamaghanian et al. [11] proposed a CS-based solution for electrocardiogram signal compression in wireless body area networks. The lifetime evaluation of the mote has been performed in the shimmer platform.

Karakus et al. [12] proposed a framework for CS-based signal recovery, and the energy consumption was determined by using the Atmega processor. The effects of acquiring, processing and communicating CS-based measurements on WSNs are analysed and compared to conventional approaches. CS prolongs the network lifetime for sparse signals, and it is more advantageous for WSNs with a smaller coverage area. Based on the programming logic, operations are decided and the energy consumption is analysed. The total energy consumption has been computed based on the energy consumed by each instruction. However, the entire process is not validated in the target platform. Alternatively, we have extended the energy analysis procedure to incorporate image transmission in WMSNs. However, for image applications, the sparsifying basis and measurement matrix plays a major role in determining the energy consumption. The optimal measurement range required to achieve an acceptable image quality suitable for WMSN applications is also suggested. Further, a new encoding algorithm is developed that uniquely suits the unquantized measurements obtained using the Bernoulli sensing matrix. Experiments are performed on the Atmel Atmega 128 Processor of Mica2 for analysing the energy consumption.

The rest of the paper is organized as follows. Section 2 provides an overview of CS. In Section 3, the proposed framework is discussed in detail. In Section 4, the performance evaluation is explained. Image recovery analysis and the corresponding simulation results are discussed. Energy analysis for image transmission and its validation in the target platform is also explained. Conclusions are provided in Section 5.

Consider a real valued, finite length, one-dimensional signal X
                     ∈
                     RN
                     . Using the N
                     ×
                     N basis matrix ψ
                     =[ψ
                     1|ψ
                     2|…|ψN
                     ] with the vectors{ψi
                     } as columns, a signal X can be expressed as
                        
                           (1)
                           
                              X
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       N
                                    
                                 
                              
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    ψ
                                 
                                 
                                    i
                                 
                              
                              =
                              ψ
                              S
                           
                        
                     where X is an N
                     ×1 column vector with coefficients Xi
                     , i
                     =1,2,…,
                     N and S is a vector of coefficients representing X in ψ basis. The process of measurement in CS [13] can be defined as,
                        
                           (2)
                           
                              y
                              =
                              φ
                              X
                              =
                              φ
                              ψ
                              S
                              =
                              Θ
                              S
                           
                        
                     where φ is an M
                     ×
                     N random matrix, Θ
                     =
                     φψ and y is an M
                     ×1 measurement vector. It is assumed that M
                     <
                     N. The number of measurements depends upon the sparsity and incoherence [14]. Low coherence between measurement basis φ and representation basis ψ results in fewer measurements. The number of measurements M for the perfect reconstruction of a K-sparse N dimension signal [13] is given by
                        
                           (3)
                           
                              M
                              ⩾
                              α
                              ·
                              K
                              ·
                              log
                              
                                 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             K
                                          
                                       
                                    
                                 
                              
                           
                        
                     where α is some positive constant affecting the probability of recovery. Signal X could be recovered exactly by solving the minimum l
                     1
                     -norm optimisation problem. The reconstruction process is formulated as,
                        
                           (4)
                           
                              
                                 
                                    S
                                 
                                 
                                    ^
                                 
                              
                              =
                              
                                 
                                    min
                                 
                                 
                                    S
                                 
                              
                              ‖
                              S
                              
                                 
                                    ‖
                                 
                                 
                                    
                                       
                                          ℓ
                                       
                                       
                                          1
                                       
                                    
                                 
                              
                              
                              subject to
                              
                              y
                              =
                              Θ
                              S
                              ,
                              
                              X
                              =
                              ψ
                              
                                 
                                    S
                                 
                                 
                                    ^
                                 
                              
                           
                        
                     
                  

This methodology can be made in-built during the acquisition process itself. The signal can be recovered at the receiver with the help of measurements by using recovery techniques such as convex optimisation, linear programming, POCS [7] and greedy algorithms – orthogonal matching pursuit (OMP) [13], regularized OMP (ROMP) [15], stage wise OMP (STOMP) [16], basis pursuits (BP) [17], and compressive sampling matching pursuit (CoSaMP) [18]. The Bernoulli measurement matrix (±1 entry with equal probability) and OMP are used for acquisition and recovery of an image in this paper.

The input image is divided into 8×8 blocks and is, processed and transmitted by the following methods: transform coding (TC), conventional CS (CCS) and proposed CS (PCS). PCS is compared with TC and CCS [12]. The entire framework for the energy analysis of the image transmission is shown in Fig. 1
                     .

The image is captured, divided into blocks of size 8×8 and transformed using DCT, yielding N transform coefficients. To obtain a K-sparse approximation of the signal, the K largest values with their corresponding locations are identified [12]. The retrieved elements (A) are encoded using the Huffman table as used in the joint photographic experts group (JPEG) standard [19] and are transmitted to the receiving end. At the receiver section, decoded K values are placed in their corresponding locations, and then the inverse DCT (IDCT) is applied. The recovered image quality depends on the value of K.

The image is captured, divided into blocks of size 8×8 and sparsified using DCT, which is then given to the CS process. CS measurements are obtained by taking the M random projections (Y
                        1) of the image as in Eq. (2) using φ
                        1
                        ψ and are encoded using the Huffman table (EY
                        
                        1) as used in the JPEG standard. The measurements (Y
                        1) are generated by multiplying the image vector X (64×1) with a random M
                        ×
                        N Gaussian matrix [12], having binary entries and ψ the DCT coefficient matrix.

In the receiver section, the recovery from encoded measurements EY
                        
                        1 depends on the sparsity of X and the properties of the measurement matrix. If the number of measurements M is large enough, then the signal X can be recovered properly. OMP is a greedy recovery algorithm and can recover a signal with K non-zero entries in dimension N given M random linear measurements of that signal. φ
                        1 is a Gaussian measurement matrix, satisfying the restricted isometry property (RIP) [14]. OMP constructs an approximation by going through an iteration process. For the first iteration, the residual vector will be the measurement vector. At each iteration, the column vector of φ
                        1, which mostly resembles the residual vector, corresponds to a non-zero entry of X. Thus, one non-zero entry of the signal X is estimated. Subtracting that contribution from the observation vector y and repeating eventually yields all of the non-zero entries of signal X. Compared with other alternative methods, a major advantage of the OMP is its simplicity and speed. IDCT is taken for the values obtained from OMP, and the image is recovered. The recovered image quality depends on measurements M.

In this method, the image is captured, divided into blocks of size 8×8 and sparsified using binary DCT (BinDCT) [20], which is then given to the CS process. The eight-point BinDCT of the C1 configuration is used to obtain the multiplierless transform with dyadic values. BinDCT-C1 needs 23 shifts and 42 additions to obtain the transformed coefficients [20]. Although there will be a reduction in the reconstruction quality, BinDCT-C1 is adopted in PCS to achieve energy efficiency. CS measurements are obtained by taking the M random projections (Y
                        2) of the image.
                           
                              (5)
                              
                                 
                                    
                                       Y
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 
                                    
                                       φ
                                    
                                    
                                       2
                                    
                                 
                                 X
                                 =
                                 
                                    
                                       φ
                                    
                                    
                                       2
                                    
                                 
                                 ψ
                                 WS
                                 =
                                 Θ
                                 WS
                              
                           
                        
                     

The measurements are obtained by multiplying the random M
                        ×
                        N Bernoulli (random±1) matrix and DCT coefficient matrix. The DCT coefficient matrix is multiplied with a weighing matrix (W) to extract the requisite sparse elements. W is a binary matrix of size 8×8, having K number of ones along the diagonal in the requisite indices. The measurements are retrieved with only addition operations against floating point multiplications involved in the conventional measurement process using the random Gaussian matrix. The measurements are encoded (EY
                        
                        2) using the proposed encoder, which is explained in Section 3.3.1.

In the receiver section, the recovery from the decoded measurements Y
                        2 is performed using OMP. The reconstruction process is formulated as:
                           
                              (6)
                              
                                 
                                    
                                       S
                                    
                                    
                                       ^
                                    
                                 
                                 =
                                 
                                    
                                       min
                                    
                                    
                                       S
                                    
                                 
                                 ‖
                                 S
                                 
                                    
                                       ‖
                                    
                                    
                                       
                                          
                                             ℓ
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                                 
                                 subject to
                                 
                                 
                                    
                                       y
                                    
                                    
                                       2
                                    
                                 
                                 =
                                 Θ
                                 WS
                                 ,
                                 
                                 X
                                 =
                                 ψ
                                 
                                    
                                       S
                                    
                                    
                                       ^
                                    
                                 
                              
                           
                        
                     

IDCT is obtained for the values obtained using OMP, and the image is recovered. The recovered image quality depends on measurements M.

The measurements obtained with PCS have more repetitive elements with a large magnitude. The encoding algorithm is developed by considering this unique characteristic and is shown in Table 1
                           . Encoding is performed on a block-by-block basis. The measurements in each block are encoded consecutively by using the Coding Block_n (Yn
                           ) algorithm, where Yn
                            are the measurements of the nth block of an image. The elements occurring more than once are considered duplicates and are removed from Yn
                            to generate the non-duplicate sequence (An
                           ). The original sequence is represented based on the number of non-duplicate elements and their position in An
                           .

The code word (Code_n) of the proposed encoding algorithm is the concatenation of Pn
                           , Sn
                           , and Vn
                           . The non-duplicate elements (An
                           ) and the new sequence (Bn
                           ) are encoded to obtain the actual codeword. Because the number of non-duplicate elements (length (An
                           )) varies from block to block, it is indicated with a binary value (Pn
                           ). The number of bits used to represent Pn
                            is derived using t
                           =ceil (log2 (length (An
                           ))). An
                            are encoded using the modified lossless entropy coding (LEC) algorithm as shown in Table 1, whose output is Sn
                           . The prefix value used in the dictionary of the LEC algorithm [21] has been reversed entirely as shown in Table 2
                            because larger numbers occur frequently in the measurements.


                           Bn
                            are converted to binary form with the most significant bit indicating the polarity bit, and the result is represented by Vn
                           . If only two elements are present in An
                           , the elements are represented with two bits, with MSB indicating the polarity and LSB having 1 for one element and 0 for the other element. The proposed encoding algorithm is explained with an example in Table 3
                           , indicating the coding of an individual 8×8 block measurements for sparsity K
                           =2. The bits required to represent the measurements of a block using the Huffman and LEC algorithms is calculated and presented in Table 4
                           .

It can be clearly observed that the proposed encoding algorithm has a 66% reduction in bits versus the Huffman [19] and LEC algorithms [21] while operated on the same measurements.

@&#PERFORMANCE EVALUATION@&#

The performance of the PCS is evaluated based on the image quality, compression efficiency and energy consumption. The metrics involved in the performance analysis are presented.

Peak signal-to-noise ratio, structural similarity index and mean square error are the performance metrics used for the image analysis.

MSE is the cumulative squared error between the recovered image and the original image, and it is defined by Eq. (7),
                              
                                 (7)
                                 
                                    MSE
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          MN
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             m
                                             =
                                             1
                                          
                                          
                                             M
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             n
                                             =
                                             1
                                          
                                          
                                             N
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                I
                                                (
                                                m
                                                ,
                                                n
                                                )
                                                -
                                                R
                                                (
                                                m
                                                ,
                                                n
                                                )
                                             
                                          
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           where I(m,n) is the pixel value of the original image and R(m,n) is the pixel value of the recovered image. If MSE=0, it is a perfect recovery.

PSNR is the ratio between the peak signal energy and the MSE observed between the processed image and the original image [22]. The PSNR (dB) is calculated using Eq. (8)
                           
                              
                                 (8)
                                 
                                    PSNR
                                    =
                                    10
                                    
                                       
                                          log
                                       
                                       
                                          10
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            2
                                                         
                                                         
                                                            b
                                                         
                                                      
                                                      -
                                                      1
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          MSE
                                       
                                    
                                 
                              
                           where b is the number of bits per pixel (bpp) of the original image. A higher PSNR value indicates better image quality.

The structural similarity measure [23] is also used as a quality criterion for image assessment. The general form of the metric that is used to measure the structural similarity between two signal vectors x and y is given by Eq. (9)
                           
                              
                                 (9)
                                 
                                    SSIM
                                    (
                                    x
                                    ,
                                    y
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   2
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         x
                                                      
                                                   
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         y
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         G
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         x
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         μ
                                                      
                                                      
                                                         y
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         G
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   2
                                                   
                                                      
                                                         σ
                                                      
                                                      
                                                         xy
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         G
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         σ
                                                      
                                                      
                                                         x
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         σ
                                                      
                                                      
                                                         y
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         G
                                                      
                                                      
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where μx
                            and μy
                            are the sample means of x and y, respectively, 
                              
                                 
                                    
                                       σ
                                    
                                    
                                       x
                                    
                                    
                                       2
                                    
                                 
                              
                            and 
                              
                                 
                                    
                                       σ
                                    
                                    
                                       y
                                    
                                    
                                       2
                                    
                                 
                              
                            are the sample variances of x and y, respectively, and σxy
                            is the sample cross-covariance between x and y. The values for G
                           1
                           =(K
                           1
                           L)2 and G
                           2
                           =(K
                           2
                           L)2, the default values used for K
                           1 and K
                           2, are 0.01 and 0.03, respectively, and L is the dynamic range of pixel values [23].

In CS, a better PSNR is obtained as the sparsity level K and the number of measurements M is increased. However, it is essential to make a trade-off while choosing the sparsity and the number of measurements. The image block length of 64×1 is considered with varying sparsity levels, and the successful recoveries using the OMP algorithm for the entire measurement ranges are observed. The true reconstruction ratio (TRR) is the ratio between the number of successful recoveries and the total number of trials. One hundred trials are used for this analysis. The simulated results for varying sparsity levels over the entire measurement range are shown in Fig. 2
                           .

For K
                           =3, the exact recovery of the measurement vector is obtained when the measurement value is ‘21’ and as the sparsity level is increased to 6, full recovery is obtained when the measurement value is ‘39’. It is observed that with an increase in sparsity level, the measurements required to achieve full recovery (TRR=1) are increased greatly. For the 64×1 image block length, the upper limit of sparsity level is kept as six to obtain the full recovery of the signal length at the lower number of measurements. When K
                           >12, measurements will exceed the signal length ‘64’. Hence, to obtain a reasonable compression, the sparsity range is assumed to be less than six in each block.

Sparsity in the TC method indicates the number of non-zero elements in each image block, whereas in CCS and PCS, it indicates the number of non-zero elements in the recovered vector. The number of measurements taken at the transmitter side influence the number of elements recovered at the receiver side. The selection of the measurements (M) is made such that the recovered block has a sparsity level of two to six. Images are recovered at the receiver side with varying measurements considered based on the sparsity levels. The PSNR computed for the Lena image (256×256) is shown in Fig. 3
                           .

The PSNR increases with the increase in sparsity for all three methods. It is clear that the PCS method outperforms CCS but has a lower PSNR than the TC method. However, the reduction in PSNR is tolerable if the energy consumption is taken into consideration. When the sparsity value of the image is low, the PSNR difference between the PCS and the TC is approximately 0.5dB, and for higher sparsity values, the PSNR difference is nearly 2dB. In spite of the reduction in PSNR, the obtained values are acceptable for image transmission in the WSN scenario. Lena (256×256) and Moon surface (256×256) images are measured and recovered using the TC, CCS and PCS methods for sparsity levels K
                           =4 and K
                           =5, respectively. The corresponding results are shown in Fig. 4
                           .

The quality metrics are extensively calculated for a wide variety of input images from the image database [24,25]. In all cases, the PCS method outperforms the CCS method. Quality metrics measured with K
                           =4 for a subset of images are tabulated in Table 5
                            for validation.

The bits per pixel (bpp) and the compression ratio (CR) are the metrics used for analysing the compression results. The metrics are calculated for different sparsity levels with the Lena image (256×256) and are shown in Table 6
                        .

PCS achieves better compression than CCS, but it is inferior to the TC method because of the increased number of measurements required by the CS methods versus the TC method. (e.g., sparsity=2, TC=4; CCS and PCS=8). At a sparsity level of two, the number of measurements for the CS methods is nearly double that of the TC method, and all of the measurements are of a larger magnitude because it is the linear combination of all pixel values. Even at lower sparsity, the CR of PCS is only 0.44% less than the TC method. For K
                        =4, the elements to be encoded by the individual methods are TC=8 and CCS and PCS=17. Because the number of measurements in TC is less than the CCS and PCS methods, TC will have a better compression ratio. However, PCS has a better CR than CCS, which has an equal number of measurements. Consequentially, the rate distortion analysis is performed only for CCS and PCS to have an acceptable comparison [12], and the results are provided for Mandrill and Moon surface images (256×256) as shown in Fig. 5
                        .

For higher sparsity levels, if the number of measurements increases, the bpp also increases. It is evident that in both cases, PCS dominates CCS due to an efficient implementation of the encoding algorithm.

Energy consumption in a WSN node has two components: communication energy (E
                        COM) and computation energy (E
                        COMP). The Mica2 platform is used to determine the features of the energy dissipation model, which has the Atmel Atmega 128L processor and Chipcon CC1000 radio.

The energy consumed for ‘per bit’ transmission and the energy consumed for ‘per bit’ reception are given in Eqs. (10) and (11), respectively.
                              
                                 (10)
                                 
                                    
                                       
                                          E
                                       
                                       
                                          TX
                                       
                                    
                                    =
                                    
                                       
                                          ε
                                       
                                       
                                          e
                                       
                                    
                                    +
                                    
                                       
                                          ε
                                       
                                       
                                          a
                                       
                                    
                                    
                                       
                                          d
                                       
                                       
                                          α
                                       
                                    
                                 
                              
                           
                           
                              
                                 (11)
                                 
                                    
                                       
                                          E
                                       
                                       
                                          RX
                                       
                                    
                                    =
                                    
                                       
                                          ε
                                       
                                       
                                          e
                                       
                                    
                                 
                              
                           where εe
                           
                           =100×10−12 is the energy dissipated per bit per m2, εa
                           
                           =50×10−9 is the energy consumed by the circuit per bit, d is the distance between a wireless transmitter and a receiver, and α
                           =2 is the path loss parameter [26].

The communication energy per bit is
                              
                                 (12)
                                 
                                    
                                       
                                          E
                                       
                                       
                                          COM
                                       
                                    
                                    =
                                    
                                       
                                          E
                                       
                                       
                                          TX
                                       
                                    
                                    +
                                    
                                       
                                          E
                                       
                                       
                                          RX
                                       
                                    
                                 
                              
                           
                        

TC and CCS methods utilize the floating point implementation of DCT, whereas BinDCT-C1 is used for PCS. The measurement cycle in TC involves sorting the data in a block and choosing K=
                           2 maximum elements and its location. The sparse elements and the locations are encoded using the JPEG Huffman algorithm. In CCS, DCT coefficients are multiplied with the M
                           ×
                           N Gaussian measurement matrix to obtain the measurements, and JPEG Huffman encoding is utilized to encode it. However, in PCS, BinDCT-C1 coefficients are multiplied with the M
                           ×
                           N Bernoulli measurement matrix to obtain the measurements, and the proposed encoding technique encodes it.

The computational energy for all of the methods is calculated by using Atmega 128 [27] as the target platform. It operates at 8MHz with an active power consumption of 22mW. Compilation is performed via WinAVR with the ‘–O3’ optimisation setting. The experiments are performed for an 8×8 image block with two to four sparsity levels, and the results are shown in Table 7
                           .

From the tabulated values, it is evident that PCS has a 98.83% reduction in computational energy on average versus the TC and CCS methods with normal DCT implementation. TC [12] and CCS [12] used normal DCT, which has floating point multiplications. However, in reality, floating point operations are not used in on-board processor implementation. Hence, PCS is also compared with the Loeffler, Ligtenberg and Moschytz (LLM) algorithm-based [28] DCT implementation in TC and CCS methods, which is used in conventional JPEG encoding. The LLM algorithm utilizes 192 multiplications and 512 additions and needs 580,106cycles for implementation in the Atmega 128 processor. Using these values, the computational energy consumption is calculated for all methods, and the results are given in Table 8
                           .

From Table 8, it is clear that PCS has an 81.56% reduction in computational energy on average versus the TC and CCS methods with an LLM-based DCT implementation. Although the TC method has a better CR and PSNR as shown in Table 6 and in Fig. 3, respectively, its computational energy is more than the PCS method.

The total energy consumption is the sum of the communication E
                           COM and computational E
                           COMP energy. The total energy consumption in the direct hop is given below,
                              
                                 (13)
                                 
                                    
                                       
                                          E
                                       
                                       
                                          TOT
                                       
                                    
                                    =
                                    
                                       
                                          E
                                       
                                       
                                          COM
                                       
                                    
                                    ×
                                    
                                       
                                          Bits
                                       
                                       
                                          tot
                                       
                                    
                                    +
                                    
                                       
                                          E
                                       
                                       
                                          COMP
                                       
                                    
                                    ×
                                    
                                       
                                          Block
                                       
                                       
                                          tot
                                       
                                    
                                 
                              
                           
                        

The communication energy for the entire image transmission is obtained by multiplying the communication energy per bit and the total bits used to represent the entire image (Bitstot). The computation energy for the entire image transmission is obtained by multiplying the computation energy for an 8×8 block (E
                           COMP) and the total number of blocks in the image (Blocktot). The total energy consumption from source to destination is the sum of the communication energy and the computation energy calculated for the entire image. The energy consumption is calculated by varying the distance between the source and the destination. Energy consumed for raw image transmission without any processing (No Processing-NP) is also analysed for comparison. The results for the transmission of the Lena image (256×256) are shown in Fig. 6
                           . TC and CCS methods are assumed to use the LLM method of the DCT implementation for this comparison. The PCS method has low energy in all cases when compared to TC and CCS. It is inferred that NP has the least total energy consumption versus all of the other three methods when d
                           <40m, d
                           <60m and d
                           <80m for the sparsity levels of 2, 3 and 4, respectively. The raw images can be transmitted within these limits by direct hop transmission. Beyond these ranges, PCS has considerably less power consumption compared to the other methods. For the sparsity levels less than six, the overall energy dissipation is less for PCS than the other methods because fewer measurements are transmitted and the computational energy is also very low.

Hence, PCS is energy efficient under lower sparsity (<6) when compared to other models. When the sparsity level is six, TC outperforms PCS because a greater number of measurements are transmitted in the PCS approach, leading to increased communication energy even though the computational energy remains low.

The total energy consumption in multihop transmission is given below,
                              
                                 (14)
                                 
                                    
                                       
                                          E
                                       
                                       
                                          TOT
                                          1
                                       
                                    
                                    =
                                    
                                       
                                          E
                                       
                                       
                                          COM
                                          _
                                          path
                                       
                                    
                                    ×
                                    
                                       
                                          Bits
                                       
                                       
                                          tot
                                       
                                    
                                    +
                                    
                                       
                                          E
                                       
                                       
                                          COMP
                                       
                                    
                                    ×
                                    
                                       
                                          Block
                                       
                                       
                                          tot
                                       
                                    
                                 
                              
                           
                        

The communication energy per bit for the entire path is multiplied with Bitstot used, and the computation energy is calculated for the entire image. The communication and computation energy for the entire path are added to obtain the total energy consumption for the transmission of the entire image from source to destination. The energy consumption is calculated by varying the number of hops between the source and the destination. Communication energy consumption of the source node will be lower in multihop transmission than in direct transmission. The number of hops is optimised by using Dijkstra’s algorithm and by finding the shortest path based on the distance between the source and the destination. The scenario with a varying number of hops between the source and the destination is considered for further analysis. Nodes are randomly placed in a square area of 100m×100m with an average node degree of 10, and the number of nodes equals 319.

The node closest to the centre of the field is chosen as the source node, and the destination node is chosen randomly. The total communication and computation energy required for image transmission using NP, TC, CCS and PCS models are calculated and plotted for different sparsity levels as shown in Fig. 7
                           .

The PCS has low energy consumption versus TC and CCS for the different number of hops as shown in Fig. 7. In multihop transmission, the image can be sent using PCS because it has considerably less energy consumption compared with all of the other methods.

@&#CONCLUSION@&#

The energy analysis for the image transmission using CS has been performed efficiently in this paper for the WMSN scenario. The PCS method has lower energy consumption with an acceptable range of image quality, provided that the sparsity level is within six. The image can be sent with considerably reduced energy consumption, with the distance greater than 60m in direct hop transmission. In multihop transmission, PCS is efficient in the entire communication range. The proposed encoding algorithm consumes less energy and also has a better compression capability compared with the existing methods. PCS achieves a 98.83% and 81.56% reduction in energy consumption on average, when compared with the TC and CCS methods with DCT and the LLM-based DCT implementation, respectively. Hence, the proposed system can be used in resource-constrained WMSNs for CS-based image transmission applications. However, quantization of the CS measurements can still reduce the data to be transmitted and lead to low energy consumption. In the future, the quantization effects on measurements and the efficient recovery of images from them can also be included and analysed. A lifetime analysis of the application can be performed and to improve it, harvester-based implementations will be suggested.

@&#REFERENCES@&#

