@&#MAIN-TITLE@&#
               FCMLab: A finite cell research toolbox for MATLAB

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Overview of the current state of the art of high-order fictitious domain methods.


                        
                        
                           
                           Review of the recently introduced Finite Cell Method.


                        
                        
                           
                           Introduces FCMLab as an entrypoint into high-order fictitious domain methods.


                        
                        
                           
                           Information provided allows researchers to quickly prototype new numerical ideas.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Finite Cell Method

Fictitious domain methods

MATLAB

Object-oriented finite elements

High-order finite elements




                     p-FEM

@&#ABSTRACT@&#


               
               
                  The recently introduced Finite Cell Method combines the fictitious domain idea with the benefits of high-order finite elements. Although previous publications demonstrated the method’s excellent applicability in various contexts, the implementation of a three-dimensional Finite Cell code is challenging. To lower the entry barrier, this work introduces the object-oriented MATLAB toolbox FCMLab allowing for an easy start into this research field and for rapid prototyping of new algorithmic ideas. The paper reviews the essentials of the methods applied and explains in detail the class structure of the framework. Furthermore, the usage of the toolbox is discussed by means of different two- and three-dimensional examples demonstrating all important features of FCMLab (http://fcmlab.cie.bgu.tum.de/).
               
            

@&#INTRODUCTION@&#

For decades, the Finite Element Method (FEM) has been among the most prominent approaches to solve partial differential equations (PDEs) numerically. Many theoretical and algorithmic enhancements of the method now allow to simulate very complex scenarios in science and technology. What remains unchanged, however, is the central idea to describe the PDE’s solution and the domain geometry using the same mesh. This dual-use of elements for the approximation of the geometric shape and solution characteristics implies e.g. that distorted elements have to be avoided, as they would degrade the numerical accuracy. For non-trivial geometries, this constraint complicates the mesh generation process considerably and renders the method’s intrinsic need for a geometry-conforming discretization as one often limiting factor in daily engineering practice.

Alternative numerical approaches try to drop this limitation by separating the discretization of the solution from that of the geometry. Prominent examples are meshless and element-free methods [1,2]. Also the Generalized Finite Element, Immersed Boundary, Fictitious Domain, Fat Boundary, Cartesian Grid-FEM and certain variants of extended Finite Element Methods follow this approach [3–16]. For a comprehensive review see [17–19]. A common idea of these methods is to approximate the PDE’s solution using a non-geometry-conforming discretization (approximation mesh) and to capture the actual domain geometry on a separate geometry mesh. Many of these approaches use a rather fine approximation mesh on which linear shape functions are spanned. This h-FEM-like concept has been extended to higher orders by the Finite Cell Method (FCM), combining a fictitious domain approach with the benefits of high-order finite elements (p-FEM). The Finite Cell Method was first introduced in [20,21], where its potential was demonstrated for linear-elastic examples in two and three dimensions. Various extensions of the FCM confirm its versatility in the context of topology optimization [22], geometrically non-linear continuum mechanics [23], adaptive mesh-refinement [24–27], computational steering [28,29], biomedical engineering [30], numerical homogenization [31], elastoplasticity [32], wave propagation in heterogeneous materials [33,34], local enrichment for material interfaces [35], convection diffusion problems [36,37], thin-walled structures [38], design-through-analysis and iso-geometric-analysis [26,27,39,40], weak coupling of non-matching, multi-patch geometries [41], and multi-physical applications [42]. The potential of high-order-fictitious-domain methods is also demonstrated in the context of Kantorovich methods [43,44], immersed B-Spline methods (I-Splines) [45,6,46], and eXtended Finite Element Methods (XFEM) [13–16].

Yet, research in this field essentially demands for the availability of a high-order Finite Element code, which is not trivial to implement. To lower this entry barrier, the goal of the present work is to introduce FCMLab, an object-oriented MATLAB toolbox tailored for quick prototyping of new algorithmic ideas. Similar open-source software projects have been launched recently in the communities of hp-FEM, XFEM, meshless methods, and isogeometric analysis (see e.g. [47–54]). The authors hope that this work will be helpful for researches interested in high-order fictitious domain methods. For this purpose, the second section of this paper briefly explains the essential concepts of high-order Finite Elements and of the Finite Cell Method. The most important parts of the code design are outlined in the third section. The fourth section explains how to use the toolbox by different examples in two and three dimensions.

As indicated in the introduction, this section outlines the essential ideas of the Finite Cell Method. As a model problem, linear elasticity will be considered and some basics of the p-version of the Finite Element Method, being a prerequisite for the FCM will be sketched, briefly.

Consider a two- or three dimensional domain 
                           
                              Ω
                           
                         with its boundary 
                           
                              ∂
                              Ω
                           
                         divided into Neumann and Dirichlet parts 
                           
                              
                                 
                                    Γ
                                 
                                 
                                    N
                                 
                              
                           
                         and 
                           
                              
                                 
                                    Γ
                                 
                                 
                                    D
                                 
                              
                           
                        , respectively, such that
                           
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       N
                                    
                                 
                                 ∩
                                 
                                    
                                       Γ
                                    
                                    
                                       D
                                    
                                 
                                 =
                                 ∅
                                 
                                 and
                                 
                                 
                                    
                                       Γ
                                    
                                    
                                       N
                                    
                                 
                                 ∪
                                 
                                    
                                       Γ
                                    
                                    
                                       D
                                    
                                 
                                 =
                                 ∂
                                 Ω
                                 .
                              
                           
                        Assuming linear-elastic behavior, the deformation 
                           
                              u
                           
                         caused by a body force 
                           
                              
                                 
                                    b
                                 
                                 
                                    ˆ
                                 
                              
                           
                         is described by the following set of partial differential equations:
                           
                              (1a)
                              
                                 ∇
                                 ·
                                 σ
                                 +
                                 
                                    
                                       b
                                    
                                    
                                       ˆ
                                    
                                 
                                 =
                                 0
                                 
                                 ∀
                                 
                                 x
                                 ∈
                                 Ω
                              
                           
                        
                        
                           
                              (1b)
                              
                                 σ
                                 =
                                 C
                                 :
                                 ε
                                 
                                 ∀
                                 
                                 x
                                 ∈
                                 Ω
                              
                           
                        
                        
                           
                              (1c)
                              
                                 ε
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       
                                          ∇
                                          u
                                          +
                                          
                                             
                                                
                                                   
                                                      ∇
                                                      u
                                                   
                                                
                                             
                                             
                                                ⊤
                                             
                                          
                                       
                                    
                                 
                                 
                                 ∀
                                 
                                 x
                                 ∈
                                 Ω
                              
                           
                        
                        
                           
                              (1d)
                              
                                 σ
                                 ·
                                 n
                                 =
                                 
                                    
                                       t
                                    
                                    
                                       ˆ
                                    
                                 
                                 
                                 ∀
                                 
                                 x
                                 ∈
                                 
                                    
                                       Γ
                                    
                                    
                                       N
                                    
                                 
                              
                           
                        
                        
                           
                              (1e)
                              
                                 u
                                 =
                                 
                                    
                                       u
                                    
                                    
                                       ˆ
                                    
                                 
                                 
                                 ∀
                                 
                                 x
                                 ∈
                                 
                                    
                                       Γ
                                    
                                    
                                       D
                                    
                                 
                                 .
                              
                           
                        Here, 
                           
                              σ
                           
                         and 
                           
                              ε
                           
                         denote the stress and strain tensor, respectively, and 
                           
                              C
                           
                         is the linear-elastic constitutive tensor. 
                           
                              
                                 
                                    t
                                 
                                 
                                    ˆ
                                 
                              
                           
                         and 
                           
                              
                                 
                                    u
                                 
                                 
                                    ˆ
                                 
                              
                           
                         are the traction and displacement vectors prescribed on the respective boundaries. 
                           
                              n
                           
                         is the outward-pointing normal vector on the boundary.

Following the principal of virtual work described e.g. in [55–58], the above equation is transferred into its corresponding weak form:

Find 
                           
                              u
                              ∈
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                              (
                              Ω
                              )
                           
                         such that
                           
                              (2a)
                              
                                 a
                                 (
                                 u
                                 ,
                                 v
                                 )
                                 =
                                 f
                                 (
                                 v
                                 )
                                 
                                 ∀
                                 
                                 v
                                 ∈
                                 
                                    
                                       H
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 Ω
                                 )
                              
                           
                        
                        
                           
                              (2b)
                              
                                 with
                                 
                                 a
                                 (
                                 u
                                 ,
                                 v
                                 )
                                 =
                                 
                                    ∫
                                    
                                       Ω
                                    
                                 
                                 ε
                                 (
                                 v
                                 )
                                 :
                                 C
                                 :
                                 ε
                                 (
                                 u
                                 )
                                 d
                                 Ω
                              
                           
                        
                        
                           
                              (2c)
                              
                                 and
                                 
                                 f
                                 (
                                 v
                                 )
                                 =
                                 
                                    ∫
                                    
                                       Ω
                                    
                                 
                                 v
                                 ·
                                 
                                    
                                       b
                                    
                                    
                                       ˆ
                                    
                                 
                                 d
                                 Ω
                                 +
                                 
                                    ∫
                                    
                                       
                                          
                                             Γ
                                          
                                          
                                             N
                                          
                                       
                                    
                                 
                                 v
                                 ·
                                 
                                    
                                       t
                                    
                                    
                                       ˆ
                                    
                                 
                                 d
                                 Γ
                                 ,
                              
                           
                        with 
                           
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                           
                         denoting the Sobolev space of order 1.

On the basis of the weak formulation, the Finite Element Method is applied to approximate the analytical solution. To this end, the infinite-dimensional Sobolev space is restricted to an n-dimensional subspace 
                           
                              
                                 
                                    V
                                 
                                 
                                    h
                                 
                              
                              ⊂
                              
                                 
                                    H
                                 
                                 
                                    1
                                 
                              
                           
                         being spanned by the basis 
                           
                              B
                              =
                              
                                 
                                    
                                       
                                          
                                             N
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             N
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             N
                                          
                                          
                                             n
                                          
                                       
                                    
                                 
                              
                           
                        . This allows to express the numerical approximation 
                           
                              
                                 
                                    u
                                 
                                 
                                    h
                                 
                              
                              ∈
                              
                                 
                                    V
                                 
                                 
                                    h
                                 
                              
                           
                         as a linear combination of basis functions:
                           
                              (3)
                              
                                 
                                    
                                       u
                                    
                                    
                                       h
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          n
                                       
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             ̃
                                          
                                       
                                    
                                    
                                       i
                                    
                                 
                                 ,
                              
                           
                        with 
                           
                              
                                 
                                    
                                       
                                          u
                                       
                                       
                                          ̃
                                       
                                    
                                 
                                 
                                    i
                                 
                              
                           
                         denoting the degrees of freedom related to shape functions 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                           
                        . Following a Bubnov-Galerkin approach, the space of test functions 
                           
                              v
                           
                         is reduced to the same space 
                           
                              
                                 
                                    V
                                 
                                 
                                    h
                                 
                              
                           
                         
                        [55]. Thus, the same basis representation can be employed for the test functions 
                           
                              
                                 
                                    v
                                 
                                 
                                    h
                                 
                              
                              ∈
                              
                                 
                                    V
                                 
                                 
                                    h
                                 
                              
                           
                        . To determine the unknown degrees of freedom, the above representation is inserted into the weak form (2) yielding a system of linear equations
                           
                              (4)
                              
                                 K
                                 
                                    
                                       u
                                    
                                    
                                       ̃
                                    
                                 
                                 =
                                 b
                                 ,
                              
                           
                        which has to be solved for the unknowns 
                           
                              
                                 
                                    u
                                 
                                 
                                    ̃
                                 
                              
                           
                        . Typically, 
                           
                              K
                           
                         and 
                           
                              b
                           
                         are denoted as stiffness matrix and external force vector.

The type of basis functions N has a major influence on the characteristics of the numerical method. For the Finite Cell Method, any high-order basis can be utilized. So far p-FEM shape functions [57,59], NURBS, being used in isogeometric analysis [60], and Gauss–Lobatto-Legendre polynomials, used in the Spectral Cell Method [33], have been applied successfully. Currently, FCMLab only provides basis functions from the p-version.

Its one dimensional shape functions 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                                 
                                    1
                                    D
                                 
                              
                           
                         (see Fig. 1
                        ) are defined as integrated Legendre polynomials [57]. They yield a hierarchical basis, which is superior to the classical Lagrange basis from a numerical point of view as the condition number of the corresponding stiffness matrix remains constant for an increasing polynomial degree (in case of Laplace problems). Although this property does not carry over to higher dimensions, a comparatively low condition number is maintained.

To obtain a two- or three-dimensional basis on a unit-square or -cube, the one-dimensional shape functions are combined in a tensor product
                           
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                    
                                       2
                                       D
                                    
                                 
                                 
                                    
                                       
                                          r
                                          ,
                                          s
                                       
                                    
                                 
                                 =
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                    
                                       1
                                       D
                                    
                                 
                                 
                                    
                                       
                                          r
                                       
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       j
                                    
                                    
                                       1
                                       D
                                    
                                 
                                 
                                    
                                       
                                          s
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 and
                                 
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       ,
                                       j
                                       ,
                                       k
                                    
                                    
                                       3
                                       D
                                    
                                 
                                 
                                    
                                       
                                          r
                                          ,
                                          s
                                          ,
                                          t
                                       
                                    
                                 
                                 =
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                    
                                       2
                                       D
                                    
                                 
                                 
                                    
                                       
                                          r
                                          ,
                                          s
                                       
                                    
                                 
                                 
                                    
                                       N
                                    
                                    
                                       k
                                    
                                    
                                       1
                                       D
                                    
                                 
                                 
                                    
                                       
                                          t
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

As depicted in Fig. 2
                        , the elements of the two-dimensional tensor-product space can be sorted into the following three groups:
                           
                              
                                 Nodal-mode.The combination of two one-dimensional nodal-modes gives rise to the well known bi-linear modes (see Fig. 3
                                 (a)). Just as in 1D, these can be associated directly to one node giving the group its name.


                                 Edge-mode.The combination of a one-dimensional internal-mode and a one-dimensional nodal-mode results in a function that is non-zero at only one edge (see Fig. 3(b)). Therefore, the mode can be directly associated to that edge and, thus, identified as a two-dimensional edge-mode.


                                 Internal-mode.The combination of two one-dimensional internal-modes yields a function that is zero on all four nodes and edges (see Fig. 3(c)). The mode can, therefore, be directly associated to the face and thus, identified as a bubble- or internal-mode.

This mode concept naturally extends into three-dimensions, where also internal- or volume-modes have to be considered.

Different alternatives to the tensor-product space, such as a trunk-space or anisotropic polynomial-degree-templates, are discussed in [61,57]. They are currently not implemented in FCMLab but might be added in the future.

As discussed in the introduction, mesh-generation is often time consuming and sometimes even a limiting factor when using FEM for industrial applications. This problem becomes even more severe for the p-version of the Finite Element Method: although the solution can be represented by much less and thus coarser elements compared to the h-version, they have to assume possibly complex shapes of the domain’s surface, to deliver accurate results [57]. The Finite Cell Method (FCM) [20,21], combining the benefits of higher-order Finite Elements with the ideas of fictitious domain methods, overcomes these mesh generation problems. The basics of the method are briefly reviewed in the first part of this section, whereas the second part addresses the imposition of boundary conditions for non-boundary-conforming discretizations.

The essential idea of the Finite Cell Method is to simplify the mesh-generation process by separating the approximation of the analytical solution from the geometry representation of the physical domain. For this purpose, two independent discretizations are introduced: the solution and the integration mesh. The first mesh is used to approximate the analytical solution and, thus, spans the shape functions. However, it does not resolve the geometry of the domain. This is done by the second mesh, which is completely independent of the first one and does not introduce any additional degrees of freedom.


                           Solution mesh The first step to separate the two meshes is to embed the actual physical domain 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       phy
                                    
                                 
                              
                            in a fictitious domain 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       fic
                                    
                                 
                              
                            such that their union 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ∪
                                    
                                 
                              
                            yields a simple shape (see Fig. 4
                           ). To recover the original boundary value problem on the new domain 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ∪
                                    
                                 
                              
                           , an indicator function 
                              
                                 α
                              
                            is defined as
                              1
                              Choosing 
                                    
                                       α
                                    
                                  as zero outside of the physical domain negatively influences the condition number of the stiffness matrix. To control the conditioning, the value of 
                                    
                                       α
                                    
                                  is typically set to a small value that allows to solve the system of equations without numerical problems. Experience shows that the direct solvers implemented in MATLAB can handle values of 
                                    
                                       α
                                       ≈
                                       
                                          
                                             10
                                          
                                          
                                             -
                                             10
                                          
                                       
                                    
                                  without major difficulties.
                           
                           
                              1
                           
                           
                              
                                 (5)
                                 
                                    α
                                    (
                                    x
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      ∀
                                                      
                                                      x
                                                      ∈
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            phy
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      0
                                                   
                                                   
                                                      ∀
                                                      
                                                      x
                                                      
                                                      ∉
                                                      
                                                      
                                                         
                                                            Ω
                                                         
                                                         
                                                            phy
                                                         
                                                      
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The bi-linear form 
                              
                                 a
                                 (
                                 ·
                                 ,
                                 ·
                                 )
                              
                            can then be rewritten as
                              
                                 
                                    a
                                    
                                       
                                          
                                             u
                                             ,
                                             v
                                          
                                       
                                    
                                    =
                                    
                                       ∫
                                       
                                          
                                             
                                                Ω
                                             
                                             
                                                phy
                                             
                                          
                                       
                                    
                                    ε
                                    (
                                    v
                                    )
                                    :
                                    C
                                    :
                                    ε
                                    (
                                    u
                                    )
                                    d
                                    Ω
                                    =
                                    
                                       ∫
                                       
                                          
                                             
                                                Ω
                                             
                                             
                                                phy
                                             
                                          
                                       
                                    
                                    1
                                    ·
                                    ε
                                    (
                                    v
                                    )
                                    :
                                    C
                                    :
                                    ε
                                    (
                                    u
                                    )
                                    d
                                    Ω
                                    +
                                    
                                       ∫
                                       
                                          
                                             
                                                Ω
                                             
                                             
                                                fic
                                             
                                          
                                       
                                    
                                    0
                                    ·
                                    ε
                                    (
                                    v
                                    )
                                    :
                                    C
                                    :
                                    ε
                                    (
                                    u
                                    )
                                    d
                                    Ω
                                    ≈
                                    
                                       ∫
                                       
                                          
                                             
                                                Ω
                                             
                                             
                                                ∪
                                             
                                          
                                       
                                    
                                    α
                                    ·
                                    ε
                                    (
                                    v
                                    )
                                    :
                                    C
                                    :
                                    ε
                                    (
                                    u
                                    )
                                    d
                                    Ω
                                    .
                                 
                              
                           The right hand side 
                              
                                 f
                                 (
                                 ·
                                 )
                              
                            can be treated analogously. In this way, the meshing of the complex physical domain can be simplified drastically, as the simply-shaped domain 
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       ∪
                                    
                                 
                              
                            can be discretized instead using a Cartesian-shaped solution mesh, which renders the mesh-generation process trivial. To avoid a confusion of names, the resulting non-boundary-conforming, high-order elements are denoted as Finite Cells giving the method its name.


                           Integration mesh The second step is to recover the domain geometry using a separate integration mesh. In principle, this second mesh can be generated following various strategies. One possibility is to use conforming integration simplices by triangulating the physical domain. XFEM- and Level Set-based methods commonly apply this strategy [14,15]. Typically, this approach is used with linear simplices. However, the method can also be extended to higher-orders as shown in [13,62–64,16,65,66].

An alternative strategy, which is followed within this work, is to use a space-tree as integration mesh (see e.g. [67]). Starting from the non-conforming solution mesh, cut cells are recursively refined towards the domain boundary yielding a quad- or octree structure (see Fig. 5
                           ). This approach has the advantage that it requires only a simple inside-outside test. It can therefore also be applied in conjunction with simple geometry modeling techniques such as voxel-models, whereas the triangulation approach demands for a more advanced geometry representation.

A challenging task being a consequence of the non-boundary-conforming discretization is the imposition of boundary conditions.

Like in the classical FEM, homogeneous, ’natural’ Neumann boundary conditions need no special treatment in the FCM. Inhomogeneous Neumann boundary conditions demand to explicitly include the boundary integral term of the linear form 2c. As the boundary is not resolved by edges of the finite cells, a classical integration over the element edges is not possible. Instead, an explicit surface discretization is introduced on which the traction integral can be evaluated. Just as the previously described integration mesh, this surface integration mesh is independent of the actual solution mesh and does not introduce additional degrees of freedom. A convenient way to generate this mesh – supported by FCMLab – is to provide the surface of interest as an STL
                              2
                              Surface Tesselation Language.
                           
                           
                              2
                            file. The STL format is supported by most CAD systems and represents surfaces as a collection of linear triangles over which the integration can be performed.

In contrast to the Neumann case, the incorporation of Dirichlet boundary conditions is more challenging. Classically, they are imposed by explicitly choosing the shape functions from kinematically admissible spaces, such that the prescribed values are met on the boundary by definition [57]. This imposes the boundary conditions in the strong sense and can also be followed in the case of non-boundary conforming discretizations by adapting the admissible function spaces for the particular geometry under consideration. Popular methods following this idea are for example web- and i-spline based methods (see e.g. [68,45]). An alternative approach followed in this work is to extend the weak formulation such that it directly incorporates the Dirichlet boundary conditions. Possible strategies for this purpose are for example the Lagrange Multiplier or Penalty Method [56,69,23,70]. An alternative is to use an approach originally introduced by Nitsche in [71] for the Laplace problem, which was later extended to other applications [72–75]. The idea of this method is to extend the original weak form (2) by additional constraining expressions as follows:
                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          ̃
                                       
                                    
                                    
                                       
                                          
                                             u
                                             ,
                                             v
                                          
                                       
                                    
                                    =
                                    a
                                    
                                       
                                          
                                             u
                                             ,
                                             v
                                          
                                       
                                    
                                    -
                                    
                                       ∫
                                       
                                          
                                             
                                                Γ
                                             
                                             
                                                D
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                             
                                                
                                                   
                                                      u
                                                   
                                                
                                             
                                             ·
                                             n
                                          
                                       
                                    
                                    ·
                                    v
                                    d
                                    Γ
                                    -
                                    
                                       ∫
                                       
                                          
                                             
                                                Γ
                                             
                                             
                                                D
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                             
                                                
                                                   
                                                      v
                                                   
                                                
                                             
                                             ·
                                             n
                                          
                                       
                                    
                                    ·
                                    u
                                    d
                                    Γ
                                    +
                                    β
                                    
                                       ∫
                                       
                                          
                                             
                                                Γ
                                             
                                             
                                                D
                                             
                                          
                                       
                                    
                                    v
                                    ·
                                    u
                                    d
                                    Γ
                                 
                              
                           
                           
                              
                                 
                                    and
                                    
                                    
                                       
                                          f
                                       
                                       
                                          ̃
                                       
                                    
                                    
                                       
                                          
                                             v
                                          
                                       
                                    
                                    =
                                    f
                                    
                                       
                                          
                                             v
                                          
                                       
                                    
                                    -
                                    
                                       ∫
                                       
                                          
                                             
                                                Γ
                                             
                                             
                                                D
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             σ
                                             (
                                             v
                                             )
                                             ·
                                             n
                                          
                                       
                                    
                                    ·
                                    
                                       
                                          u
                                       
                                       
                                          ˆ
                                       
                                    
                                    d
                                    Γ
                                    +
                                    β
                                    
                                       ∫
                                       
                                          
                                             
                                                Γ
                                             
                                             
                                                D
                                             
                                          
                                       
                                    
                                    v
                                    ·
                                    
                                       
                                          u
                                       
                                       
                                          ˆ
                                       
                                    
                                    d
                                    Γ
                                    .
                                 
                              
                           The first additional integral of the bi-linear form follows naturally from the divergence theorem when the test functions are not restricted to be homogeneous on the boundary. It, therefore, insures the method’s consistency. The second additional term of 
                              
                                 
                                    
                                       a
                                    
                                    
                                       ̃
                                    
                                 
                              
                            and the first additional term of 
                              
                                 
                                    
                                       f
                                    
                                    
                                       ̃
                                    
                                 
                              
                            are introduced to yield a symmetric stiffness matrix. The two remaining integrals are introduced for numerical stabilization, since coercivity might be lost when subtracting the consistency terms from the bilinear form. With this extension, the discrete problem can be reformulated incorporating the Dirichlet boundary conditions in the weak sense as follows:
                              
                                 
                                    
                                       
                                          
                                          
                                             
                                                Find
                                                
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      h
                                                   
                                                
                                                ∈
                                                V
                                                
                                                   
                                                      
                                                         Ω
                                                      
                                                   
                                                
                                                such
                                                
                                                that
                                             
                                          
                                       
                                       
                                          
                                          
                                             
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      ̃
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               u
                                                            
                                                            
                                                               h
                                                            
                                                         
                                                         ,
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               h
                                                            
                                                         
                                                      
                                                   
                                                
                                                =
                                                
                                                   
                                                      f
                                                   
                                                   
                                                      ̃
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               h
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                ∀
                                                
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      h
                                                   
                                                
                                                ∈
                                                V
                                                
                                                   
                                                      
                                                         Ω
                                                      
                                                   
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           In analogy to Neumann boundary conditions, the constraining expressions are evaluated using a separate surface integration mesh.

The major advantage of Nitsche-like methods is their inherent consistency, which ensures that the solution of the original strong problem 1e also solves the modified weak problem [73,76,74]. However, the major challenge of this approach is to select the stability parameter 
                              
                                 β
                              
                            large enough to ensure the coercivity of the modified weak form. As shown in [74,72,73], the correct value of 
                              
                                 β
                              
                            is dependent on the mesh-size h, the polynomial degree p, and the material parameters. [73–75] suggest to solve an auxiliary eigenvalue-problem to estimate 
                              
                                 β
                              
                           . However, their investigations show that choosing a value higher than the threshold has no significant effect on the numerical result. Following the work of [23,40,42], who showed that also an empirical choice of the stability parameter yields good results, the eigenvalue-estimate is omitted in this work.


                     FCMLab is an object-oriented MATLAB toolbox, which is intended to provide an easy entry point into the research field of higher-order fictitious domain methods. This section presents a compact outline of the code design. To this end, the two most frequently applied design patterns are introduced in the first part of the section. In the second part, the most important classes of the toolkit and their mutual dependencies are explained. The description of the code expects the reader to be familiar with general MATLAB programming and knowledge of object oriented concepts in MATLAB, as described e.g. in [78,79].

In the context of object-oriented software engineering, certain types of design problems keep on re-appearing, independent of the actual application under consideration. For this reason, design patterns have been developed as reusable template solutions for the most prominent design problems. A classical reference in this context is the textbook by Gamma, Helm, Johnson, and Vlissides [77].

The strategy pattern is a behavioral pattern aiming to decouple a family of algorithms from the actually calling code. For this purpose, different algorithms are implemented as separate classes. They all inherit from the same base class which defines the common interface. The client code then implements against this abstract interface and not against the actual implementations. Thus, the calling codes and the algorithms are decoupled, allowing to refactor and maintain the implementation of different algorithms without affecting the client code. Furthermore, the family of algorithms can be extended by simply adding new sub-classes. A numeric-oriented example is depicted in Fig. 6
                           (a).

The factory method pattern is a creational pattern aiming to simplify the creation of complex products. For this purpose, the creational process is decoupled from the client code by introducing an abstract creator class. This specifies the interface functions that create the respective object. These factory-methods are then implemented in different sub-classes deciding in which way the final product is constructed. This approach allows the client code to implement against the abstract interface without knowing about the details of the different creator classes. In this way, the implementation of the creational process can be exchanged easily as the calling code remains unaffected. A numeric-oriented example is depicted in Fig. 6(b).

The factory idea can be extended to the abstract factory pattern, which allows to create complex product families easily. Within FCMLab, both versions of the pattern are applied and combined.

Besides the aspects of extensibility and maintainability, a third important request when developing a software framework is to ensure and maintain code correctness and consistency. For this purpose, FCMLab is developed in a test-driven manner (see e.g. [80,81]). The framework is, thus, equipped with a test suite, which verifies the correctness of the individual modules following the idea of unit tests. Furthermore, the full simulation pipeline is tested using examples with analytical solutions which allow to verify the numerical results. To ensure code correctness during the on-going development process, a continuous integration system is employed, which automatically executes the entire test suite as soon as changes are committed to the version control system. To this end, we utilize the MATLAB xUnit Test Framework [82], the continuous integration server Jenkins (formally known as Hudson) [83], and Apache Subversion (SVN) [84].

The aim of FCMLab is to provide a prototyping framework in which new algorithmic ideas can be tested easily. Therefore, the framework has to be structured such that different components can be exchanged easily without affecting other parts of the code. The design must thus aim for high cohesion of the individual modules – in the sense that all libraries, classes, and functions have one clearly defined responsibility–and low coupling between the modules. To address these issues, the program is decomposed hierarchically into the sub-systems depicted in Fig. 7
                        . These are then arranged as layers such that each module only depends on lower layers. This architecture allows to regard each layer as a virtual machine with a clearly defined task, whose implementation can be exchanged without affecting up-stream elements. The details of the different packages are explained in the following sections.

The geometry packages provide essential geometric objects such as vertices, lines, quadrilaterals, and hexahedra (see Fig. 8
                           ). These are realized as separate classes and grouped according to their dimensionality as abstract curves, areas, and volumes. These abstractions all implement the class AbsGeometry that specifies the interface functions listed in Table 1
                           .

As discussed in Section 2.2, the Legendre-based shape functions can be associated to the different topological components. Therefore, the topology package, depicted in Fig. 9
                           , is responsible for handling the degrees of freedom. To this end, a Dof class is defined, which is then aggregated by the AbsTopology class. This interface is implemented by the classes Node, Edge, Face, and Solid that hold objects of their respective geometric counterparts. Furthermore, the classes store the associated polynomial degree of the shape functions.

As discussed in Section 2.3, the essential idea of the Finite Cell Method is to decouple the solution mesh from the geometry and to recover the original domain on the integration level. This demands for a separate geometry representation, which is provided by the embedded domain package (see Fig. 10
                           ). It contains the abstract AbsEmbeddedDomain class, which specifies the interface function getDomainIndex(…) determining the domain in which a point under consideration lies. This interface is implemented by different concrete domains, such as simple geometric objects that can be specified explicitly (e.g. sphere, rectangle, ellipse). Furthermore, FCMLab provides an implementation that allows to create embedded domains on the basis of CT-scan-data. This VoxelDomain class reads in the CT-data from a simple ASCII file format, which linearizes the three-dimensional matrix. The origin and the bounding box are extracted automatically. Based on this information, the Finite Cell mesh can be created. The list of domain types can be extended easily to suit new needs.

In addition to the domain description, the FCM demands for an explicit representation of the boundary for application of boundary conditions. For this purpose, the package provides a AbsBoundaryFactory class, which specifies the getBoundary(…) function returning a surface description as a list of geometric simplices. Presently, several explicit geometries such as circles and rectangles are provided as well as an implementation to read STL files,
                              3
                              For this purpose, the stlread function provided by Doron Harlev is used, which is available on the MATLAB Central File Exchange platform: http://www.mathworks.com/matlabcentral/fileexchange/6678-stlread.
                           
                           
                              3
                            which can be exported from a CAD model. Again, this list can be extended easily for new applications.

As discussed in Section 2.3, the domain integration for the FCM is carried out over a separate integration mesh. For this purpose, the integration package defines the non-abstract class Integrator. This class provides the service function integrate(…), taking the integrand and the integration domain as arguments. To generate the integration mesh, the integrator aggregates the abstract classes AbsPartitioner and AbsIntegrationScheme. The AbsPartitioner serves as an interface for different partitioning strategies (see Fig. 11
                           ). Currently, FCMLab provides one-, two-, and three-dimensional space trees as concrete partitioning strategies. These could be extended by different schemes, such as triangulations. The class AbsIntegrationScheme provides interfaces to get one-dimensional integration coordinates and weights. At present, the quadrature rule for Gauss–Legendre integration is available, which is used mostly in Finite Element Analysis [55].

The material package contains different constitutive relations. To encapsulate these from the other parts of the code, the AbsMaterial class is defined, which specifies the interface functionality listed in Table 2
                           .

In addition to providing the constitutive properties, the material package is also responsible for defining the Finite Cell indicator function 
                              
                                 α
                              
                            introduced in Section 2.3. For this purpose, the third method in the table is specified, which returns the 
                              
                                 α
                              
                           -value of the respective material. The idea is to associate one material for each domain: on the physical domains, the “real” materials are defined with 
                              
                                 α
                                 =
                                 1.0
                              
                           ; on the fictitious domains, auxiliary “void” materials are defined with 
                              
                                 α
                                 →
                                 0
                              
                           .
                              4
                              To avoid numerical difficulties due to badly conditioned matrices, an 
                                    
                                       α
                                    
                                 -value of 
                                    
                                       
                                          
                                             10
                                          
                                          
                                             -
                                             10
                                          
                                       
                                    
                                  is chosen for the numerical examples of Section 4.
                           
                           
                              4
                            This concept allows to handle all domains and materials in the same way during the integration process.

As depicted in Fig. 12
                           , FCMLab provides material laws for linear-elastic simulations. Again, this list can be extended by new materials easily as the other parts of the code implement against the interface defined by AbsMaterial.

The element package is the kernel of the toolbox. It is responsible for computing the stiffness matrix and the right-hand-side vector of an element. For this purpose, the abstract AbsElement class is defined aggregating its topological components, a material, and a domain and offers the interface functions listed in Table 3
                           . To implement these services, the shape functions and their derivatives need to be evaluated and arranged in matrices. As this process depends on the dimensionality of the problem, the strategy pattern is applied by encapsulating the shape-function evaluation into respective sub-classes (see Fig. 13
                           ). In this way, the higher-level parts of the code can use the abstract element without having to know about the details of the setup and the dimensionality. As the creation of an element is rather complex, different factories are provided to generate the most commonly used types.

The mesh package provides components to create and operate on one-, two-, and three-dimensional Cartesian meshes. For this purpose, a non-abstract Mesh class is defined aggregating the respective topological components as well as all elements (see Fig. 14
                           ). As services, it offers the functions listed in Table 4
                           . Furthermore, the mesh package offers different schemes to number the degrees of freedom. To this end, the AbsNumberingScheme is defined, which assigns the degrees of freedoms to the topological components. The interface is implemented by concrete strategies sorting the unknowns either according to their associated polynomial degree or to their topological component.

Following the abstract factory pattern, the mesh creation process is encapsulated into the abstract AbsMeshFactory class that handles the setup of the topology, the elements, and the numbering scheme.

The boundary condition package offers the possibility to constrain the numerical system using Neumann and Dirichlet boundary conditions. As described in Section 2.3, the latter can be applied in the strong and in the weak sense. To break the complexity of the package, it is split into sub-systems, which are explained in the following paragraphs.
                              5
                              Within the figures of the different packages, the terms DBC and NBC are used as abbreviations for Dirichlet and Neumann boundary conditions. Within FCMLab, the full class names are spelled out.
                           
                           
                              5
                           
                        


                           Dirichlet boundary conditions. To apply Dirichlet boundary conditions, the abstract AbsDirichletBoundaryCondition class is introduced. It provides the interface function modifyLinearSystem(…), which takes the mesh and the system of linear equations as arguments and applies the boundary conditions. From this super class, the StrongDirichletBoundaryCondition and WeakDirichletBoundaryCondition are derived.

Strong Dirichlet boundary conditions directly operate on degrees of freedom. Since the latter are associated to the topological components (see Section 3.3.2), three different classes are derived from AbsStrongDirichletBoundaryCondition. They handle the corresponding tasks for nodes, edges, and faces, respectively (see Fig. 15
                           ). In principle, strong Dirichlet boundary conditions can be applied in various ways. To allow for this flexibility, the strategy pattern is applied by introducing the interface class AbsStrongConstrainingAlgorithm. Presently, two implementations of this interface are provided: The first is the StrongPenaltyDirichletAlgorithm, which constrains the respective degrees of freedom by adding a specified penalty value on the main diagonal of the system matrix. The second strategy condenses the influence of the constrained degrees of freedom to the right hand side and thus results in a better conditioning of the stiffness matrix (see e.g. [85]).

As described in Section 2.3, weak Dirichlet boundary conditions can be e.g. applied following the penalty or a Nitsche-like method. Both approaches introduce additional boundary integrals constraining the solution appropriately. To evaluate these integrals, the WeakDirichletBoundaryCondition class aggregates a list of geometric objects as boundary description and an integrator object (see Fig. 16
                           ). The actual constraining algorithm is encapsulated by introducing the AbsWeakConstrainingAlgorithm interface class, which is then implemented by the WeakNitscheAlgorithm and WeakPenaltyAlgorithm.


                           Neumann boundary conditions. Also in the case of Neumann boundary conditions, two different cases have to be considered.

In the general case, the traction integral in 2c has to be evaluated over the Neumann boundary. To this end, the WeakNeumannBoundaryCondition class is introduced, which, in analogy to the weak Dirichlet case, aggregates a boundary description and an integrator object. The actual integrand is specified as a handle to a load function (see Fig. 17
                           ).

The second case is the application of a load vector, which lumps the applied tractions in the nodal degrees of freedom [58]. For this purpose, the NodalNeumannBoundaryCondition is defined.

To compute the mechanical reactions of the system under consideration for different load settings, a LoadCase class is introduced to which different body and surface loads can be associated.

@&#ANALYSIS@&#

The analysis package is at the top level of the FCMLab toolbox. Here the numerical problem is set up and run. For this purpose, the abstract class AbsAnalysis is introduced, which aggregates the mesh and boundary conditions (see Fig. 18
                           ) and specifies the interface functions listed in Table 5
                           . These are then implemented by concrete analyses. In its current state FCMLab provides a quasi-static and an eigenmode analysis (see Fig. 18).

The final module to be discussed here is the post-processing package. FCMLab offers two different ways to post-process numerical results: visual post-processing depicting the results as line or surface plots and integrational post-processing allowing the calculation of integral values, such as strain energy and mass. Again following the strategy pattern, both post-processor types operate on point-processors via an interface class AbsPointProcessor. These convert the numerical solution into the physical quantities of interest, such as strains, stresses, and energies (see Fig. 19
                           ).

In the context of the Finite Cell Method, both post-processing types have to be enhanced to operate on the non-boundary-conforming discretization. In case of integrational post-processing, the quadrature package outlined in Section 3.3.4 is used for this purpose. For visual post-processing, a separate post-processing mesh is introduced to visualize the results in two or three dimensions. Different factories provided by FCMLab allow for an easy creation of these meshes. The user can also choose between different types of visualization, such as line- or path- and surface-plots. For the latter plot type, also the finite cells, the integration cells, and the boundary condition mesh can be visualized.

Currently the toolbox only supports simulations of linear elastic problems. As shown by e.g. Schillinger et al., however, the Finite Cell Method also yields excellent results in the context of geometrically non-linear elasticity (see e.g. [27]). The modular setup of FCMLab, described in the previous sections, allows to easily extend the toolbox for applications of this category. As a guideline for users of the toolbox, the necessary steps shall be briefly outlined in the following.

First, new elements have to be defined, which allow for large deformations. To this end, new element classes have to be created in the element package, which implement the AbsElement interface.

In a second step, the respective material models (e.g. Moony-Rivlin or Neo-Hooke [86]) have to be implemented in the framework. This can be done easily by creating new sub-classes in the material package that implement the AbsMaterial interface.

The final step is the implementation of a non-linear solver, which solves the non-linear system of equations iteratively e.g. using the Newton’s method or a fix-point approach (see e.g. [86]). This has to be carried out in the analysis package by creating new classes, which implement the AbsAnalysis interface.

Similarly, the framework could be extended into the domain of fluid dynamics, where void and structure essentially interchange their role, see, e.g. [87]. For a convection diffusion problem the penalization factor 
                           
                              α
                           
                         is applied to the diffusion coefficient in the ’obstacle’ regime of the flow.

Having outlined the theoretical background and the basic program structure in the previous sections, this part of the work aims at demonstrating the usage of FCMLab. For this purpose, examples from previous FCM-related publications are reused for highlighting the different features of the toolbox. The section starts with a two-dimensional benchmark example with an explicit geometry description. In the second example, the mechanical behavior of a three-dimensional femur (thigh bone) is investigated using a voxel model. The section concludes with a third example demonstrating the possibility of eigenmode analyses using the Finite Cell Method.

This first example outlines the structure of a driver file to setup an analysis within FCMLab. For this purpose, the displacement of the annular plate depicted in Fig. 20
                        (a) shall be computed, following [23,42,40]. Assuming a plane stress configuration and the denoted material properties, the displacement in polar coordinates caused by the stated radial loading can be given analytically as:
                           
                              
                                 
                                    
                                       u
                                    
                                    
                                       r
                                    
                                 
                                 =
                                 -
                                 
                                    
                                       r
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ln
                                       r
                                    
                                    
                                       ln
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       u
                                    
                                    
                                       θ
                                    
                                 
                                 =
                                 0
                                 .
                              
                           
                        The corresponding polar stresses read
                           
                              
                                 
                                    
                                       σ
                                    
                                    
                                       r
                                    
                                 
                                 =
                                 
                                    
                                       ε
                                    
                                    
                                       r
                                    
                                 
                                 =
                                 
                                    
                                       ∂
                                       
                                          
                                             u
                                          
                                          
                                             r
                                          
                                       
                                    
                                    
                                       ∂
                                       r
                                    
                                 
                                 =
                                 -
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ln
                                       (
                                       r
                                       )
                                       +
                                       1
                                    
                                    
                                       ln
                                       (
                                       2
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       σ
                                    
                                    
                                       θ
                                    
                                 
                                 =
                                 
                                    
                                       ε
                                    
                                    
                                       θ
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       r
                                    
                                 
                                 
                                    
                                       ∂
                                       
                                          
                                             u
                                          
                                          
                                             θ
                                          
                                       
                                    
                                    
                                       ∂
                                       θ
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             u
                                          
                                          
                                             r
                                          
                                       
                                    
                                    
                                       r
                                    
                                 
                                 =
                                 -
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ln
                                       (
                                       r
                                       )
                                    
                                    
                                       ln
                                       (
                                       2
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       σ
                                    
                                    
                                       r
                                       θ
                                    
                                 
                                 =
                                 
                                    
                                       ε
                                    
                                    
                                       r
                                       θ
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                1
                                             
                                             
                                                r
                                             
                                          
                                          
                                             
                                                ∂
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      r
                                                   
                                                
                                             
                                             
                                                ∂
                                                θ
                                             
                                          
                                          +
                                          
                                             
                                                ∂
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      θ
                                                   
                                                
                                             
                                             
                                                ∂
                                                r
                                             
                                          
                                          -
                                          
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      θ
                                                   
                                                
                                             
                                             
                                                r
                                             
                                          
                                       
                                    
                                 
                                 =
                                 0
                                 .
                              
                           
                        
                     

The analysis can be separated into the parameter configuration and the analysis setup. These two sections are explained individually in the following paragraphs.


                        Parameter configuration. The driver file starts with the description of the discretization and material parameters:
                           
                              
                           
                        
                     

In a second step, the numerical parameters of the Finite Cell Method are specified as follows:
                           
                              
                           
                        
                     

Here the value of the indicator function 
                           
                              α
                           
                         outside of the physical domain is chosen to be a small positive number in order to avoid ill-conditioning of the system matrix.

The third step is to define the inner and outer radius of the annular plate and the discretization of the boundary mesh:
                           
                              
                           
                        
                     

Finally, the body forces and the boundary values need to be specified as function handles:
                           
                              
                           
                        
                     


                        Analysis setup. After having specified the different numerical parameters, the analysis can be setup. For this purpose, two different materials are defined for the physical and the void domain:
                           
                              
                           
                        
                     

The next step is to define the physical domain and its boundary. As the geometry can be described explicitly, the AnnularPlate implementation of the AbsDomain interface introduced in Section 3.3.3 is used:
                           
                              
                           
                        
                     

In a third step, the discretization is created using the element and mesh factories described in Section 3.3.6 and 3.3.7:
                           
                              
                           
                        
                     

With these entities, the quasi-static analysis can now be created:
                           
                              
                           
                        
                     

To apply the body forces, a new load case is set up and registered using the function handles defined above:
                           
                              
                           
                        
                     

To specify the weak Dirichlet boundary conditions, a Nitsche constraining algorithm and an integration scheme are specified. These are then used to create three boundary conditions for the inner and outer boundary in x- and y-direction, which are then registered to the analysis:
                           
                              
                           
                        
                     

With this setup, the analysis can be executed as follows:
                           
                              
                           
                        
                     

As discussed in Section 3.3.10, FCMLab offers the possiblities of visual and integral post-processing, which both work on point-processors. These can, for example, be defined as follows:
                           
                              
                           
                        
                     

To visualize these results, a visual post-processor is created to which different point-processors are registered:
                           
                              
                           
                        
                     

The visualization of the displacement and stress obtained from the registered post-processors is depicted in Fig. 20.

In analogy, the results can also be integrated over the domain:
                           
                              
                           
                        
                     

The following example aims at demonstrating the ability of FCMLab to work on geometries defined by voxel data. To this end, the mechanical reaction of a human femur (thigh bone) subjected to a hip-contact force is computed. Typically, inhomogeneous material models are applied in this context to capture the physical behavior correctly (see e.g. [30,88,89]). However, as the focus of this paper lies on demonstrating the usage of different geometry models, a homogeneous, linear-elastic material description is used.

As the analysis is again quasi-static, the general setup of the driver file remains unchanged. However, an important difference is that the bone’s geometry is represented by a voxel-model obtained from a CT
                           6
                           Computed Tomography.
                        
                        
                           6
                        -scan of the patient. The data file is loaded using the VoxelDomain implementation of the AbsDomain interface described in Section 3.3.3:
                           
                              
                           
                        
                     

The second important difference is that the hip-contact force has to be applied on the non-boundary-conforming discretization. To this end, a separate surface discretization of the hip-cap is loaded from an STL-file and then used to create a Neumann boundary condition:
                           
                              
                           
                        
                     

The remaining parts of the driver file follow in analogy to the first example and are, thus, not recapitulated here.

Of course, also three-dimensional results can be post-processed using FCMLab. Fig. 21
                         depicts exemplarily the von Mises’ stress distribution in the bone caused by the loading. The figure also shows the traction surface used to apply the hip-contact forces on the bones’ head.

This final example aims at demonstrating the use of FCMLab in the context of an eigenmode analysis. For this purpose, eigenmodes of the I-section beam depicted in Fig. 22
                         are computed.

In line with the annular plate example, the physical domain is represented by an explicit geometry description. As shown in Fig. 22(a), the beam is embedded in a slightly larger fictitious domain being discretized by 
                           
                              5
                              ×
                              5
                              ×
                              5
                           
                         finite cells of polynomial order 3. The driver file for this setup follows in analogy to the previous two examples. The important difference is that in this application no quasi-static analysis is performed. Instead, the EigenmodeAnalysis implementation of the AbsAnalysis interface is applied in the following way:
                           
                              
                           
                        
                     

Results are depicted in Fig. 23
                        , and the corresponding frequencies are listed in Table 6
                        . The comparison to references obtained from an ANSYS computation using 3200 quadratic elements of type Solid186 (see [90]) demonstrates that the Finite Cell Method does not only allow to significantly simplify the mesh generation process but also yields highly accurate results.

@&#CONCLUSION@&#

This work introduced FCMLab as an object-oriented MATLAB toolbox for the Finite Cell Method allowing rapid-prototyping of new algorithmic methods in the context of high-order fictitious domain methods.

To offer researchers an entry point for code extensions, the paper firstly explained the different modules of the framework in detail by pointing out the class structure and its internal dependencies. Secondly, the usage of the toolbox was explained by means of different examples demonstrating how explicit and voxel-based geometry models can be used for quasi-static and eigenmode analyses within FCMLab.

At the current stage, the toolbox’s scope allows to apply the Finite Cell Method in the context of one-, two-, and three-dimensional linear-elasticity. However, the framework is explicitly designed to allow for easy extensibility. It is, therefore, conceivable to broaden the applicability to non-linear problems or to implement alternative integration schemes. Also, the development of new approaches for imposing Dirichlet boundary conditions on the non-conforming discretization would be very interesting. We, therefore, explicitly invite interested researchers to join our development group at http://fcmlab.cie.bgu.tum.de/. Here, you can download the full source code of FCMLab and find a detailed Getting Started guide explaining the installation of the framework and how to setup and run your own examples.

@&#ACKNOWLEDGEMENTS@&#

The first two and the last author gratefully acknowledge the financial support of the German Research Foundation (DFG) under Grants RA 624/19-1 and RA 624/15-2. D. Schillinger acknowledges support from the Institute for Computational Engineering and Sciences (ICES) at the University of Texas at Austin and the German Research Foundation (DFG) under Grant SCHI 1249/1-2.

@&#REFERENCES@&#

