@&#MAIN-TITLE@&#Efficient community detection with additive constrains on large networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A novel definition for community suitable for scale-free network and overcoming drawbacks.


                        
                        
                           
                           An efficient community detection algorithm based on a given center set.


                        
                        
                           
                           An efficient community detection algorithm based without center set according to structural properties of the network.


                        
                        
                           
                           Experiments demonstrate that the definition is effective and the algorithms are scalable.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Community detection

Feedback control

Additive constrains

Large networks

Scale-free network

Graph algorithm

@&#ABSTRACT@&#


               
               
                  The community structure is one of the most important patterns in network. Since finding the communities in the network can significantly improve our understanding of the complex relations, lots of work has been done in recent years. Yet it still lies vacant on the exact definition and practical algorithms for community detection. This paper proposes a novel definition for community which overcomes the drawbacks of existing methods. With the new definition, efficient community detection algorithms are developed, which take advantage of additive topological and other constrains to discover communities in arbitrary shape based on the feedback. The algorithm has a linear run time with the size of graph. Experimental results demonstrate that the community definition in this paper is effective and the algorithm is scalable for large graphs.
               
            

@&#INTRODUCTION@&#

Complex networks have been widely used in many applications. Representative complex networks include Internet [10], email communication networks [9], social networks [43], mobile call networks [28], instant-messaging networks [23], citation networks [8], and biological networks [13]. Because of its importance, the mining of complex network attracts the attentions of researchers in the literature. Many data mining problems over complex network have been studied. One of them is community detection.

The goal of community detection is to cluster the similar vertices into one community and separate to the others. Since the vertices in the same community share similar properties, the communities in the network make users understand the complex relations deeply. As an example, the Zachary’s karate club network is shown in Fig. 1
                     . The friendship relationships among 34 members of karate club at a US University in the 1970s [45] are modeled as a network. Because of the conflict of opinion between the administrator and the instructor, the club can be split into two communities. If the community detection algorithms are applied to the network, before the artificial classification is performed, these two communities can be known. The problem is that when there are millions of persons in one organization, artificial classification becomes infeasible. In such cases, community detection techniques are in demand.

The Zachary’s karate club network is a typical social network. Since it is modeled based on real social relationships and the community structure is obvious after the break up, it has been analyzed by almost all community detection algorithms. In this paper, we choose it as the motivate example in this paper.

Community detection has many applications in systems related to complex networks. The examples include classification in social dimensions [40], finding influential bloggers [1] and recommendation system [44]. The social dimensions describe the affiliation of an actor. And the affiliations can be learned automatically in presence of community labels. Influential bloggers impact the followers in various ways, and they are often the most representative actors in a community. Community detection could help to find such bloggers.

Even though many community detection methods have been proposed due to its importance, the requirements of the applications have not been satisfied. Current methods have the following shortcomings.

First of all, community is not defined perfectly. Intuitively, a community is a group of vertices in the network, within which the connections are dense, but between which the connections are sparse. Although many researchers have tried to give an exact definition of the community [30,27,39,33,16], none of them have been generally accepted. The major reason is that existing definitions of community are based on the models far from the real-world situations. The method in [27,39] requires a fixed threshold. This makes them unsuitable for the communities in various forms. The definition in [30] assumes that in a stochastic network, each vertex connects to other vertices in the same probability. Clearly, for a complex network, this assumption does not always hold. The strong and weak definitions in [33] both have their drawbacks, since the strong definition is so strict that will miss some vertices like V
                     8 in Fig. 2
                     . In the other extreme, the weak definition is too loose and more like just a feature of community than an exact definition. That is, the whole network will meet the weak definition to be a community, which is incomprehensible.

The second is that current methods are not suitable for massive data. The time complexity of most classic clustering algorithms is more than O(n
                     2log
                     n), where n is the number of vertices. The naïve divisive [13] algorithms have time complexity O(m
                     2
                     n) where m is the number of edges. Though many optimization techniques [30,41,31,35,14] are proposed in recent years, none of them is suitable for massive data due to the nature spirit of division that has to find the weakest edges or vertices and the time complexity is not improved. Ref. [42] introduced Markov Cluster Process for the partition, while its time complexity is O(n
                     3). Some heuristic methods [3,21] have been proposed, but none of them have time complexity assurance. All the modularity maximization algorithms are approximate methods. The time complexity of [29] is O((m
                     +
                     n)n), the time complexity of [32] is O(mn
                     2), and that of [7] is O(mdlogn), where d is the depth of the “dendrogram”. Ref. [38] has used the method in [7] as a step, which makes its time complexity no smaller than O(mdlog
                     n). However, many applications such as social network involve huge graphs and require methods with linear or sub-linear time complexity.

The third is that they do not take advantages of feedback information and structural features of graphs sufficiently. Different users may have different requirement for communities. For example, the number of communities divided by an election should be exact the number of candidates. Feedback can help the system to discover the intensions of users. The knowledge of network structural features can also improve both efficiency and effectiveness of community detection. For example, if we know that the network is modeled as a forest, then the community should be easily found from the root vertex. Unfortunately, all existing algorithms are closed systems. It means that if the communities are generated, they are fixed without modifications. Feedback and structural information are never considered.

To overcome the shortcomings of current approaches, we propose a novel definition of community as well as two community detection algorithms. Our definition considers scale-free pattern for complex network, such that the definition is more convincing and closer to the real-world situations. The community detection algorithms proposed in this paper are based on the new community definition. The linear time complexity makes them suitable for web scale networks. Additionally, they can make sufficient usage of feedback information and structural information to improve the efficiency and effectiveness.

The contributions can be summarized as follows:
                        
                           (1)
                           The first contribution is the Peaks model and a novel definition for community. This definition is based on the scale-free pattern and the community structure pattern. Based on the Peaks model, a community definition matching the real-world situations is proposed. In this definition, each community has some centers, called “Core”. A community should satisfy that the distance from each vertex to the cores of the community should not be larger than those to any other community. And when it comes to an equal distance, a vertex should belong to the community with the most connections.

The second contribution is the practical criterion to quantify the community structure. The most impartial evaluation is when there is an exact division in real-world data. And it is convincing.

Two efficient community detection algorithms are proposed for different applications. These two algorithms can perform community detection according to our model in time complexity linear to the network size and are easy to make use of feedback information and structural features.

Extensive experiments demonstrate that our method outperforms existing methods and scales well for large network.

Organization: The remaining part the paper is organized as follow. Section 2 introduces the related work on community detection. The Peaks model and the exact definition of community are presented in Section 3. Then the Cores-Aware algorithm and the Cores-Unaware algorithm are proposed in Section 4. The experimental study is presented in Section 5. Section 6 draws the conclusions.

@&#RELATED WORK@&#

Community detection has been widely studied in the literature. In this section, we summary the existing definitions of community at first. And then we survey existing community detection algorithms briefly. More detailed survey and comparisons are in [20,25].

There is no generally accepted definition of community so far. The community is defined as n-cliques, n-clan and n-club in [27], and a collection of nodes whose connections within the collection is greater than a threshold [39]. Such definitions are too strict to be practical.

By the modularity proposed by Newman and Girvan [30], the constraint of community is that the edges inside a community should be more than the expectation in the stochastic model. However, such assumption is incomprehensible when the size of the network becomes huge and Fortunato and Barthelemy [11] have proved that it will ignore relatively small communities that can be even well-defined.

In [33], the community is defined as two types: strong community and weak community. The strong community makes a limit for every vertex, but such condition is too strong for the situations like in Fig. 2. Suppose we have known that vertex v1, v2 belong to community C1, vertex v3, v4 belong to community C2, vertex v5, v6, v7 belong to community C3, and vertex v8 is connected with all the other 7 vertices. According to the strong definition, the v8 should not belong to C3, which is unreasonable.

The weak community takes each community as a whole. It is a collection of nodes that the sum of all degrees within the collection is larger than the sum of all degrees toward the rest of the network. This definition is too weak to define the community perfectly. It is more like a feature of community than an exact definition. Even the whole network itself will certainly meet the definition.

Yanqing, etc. [16] proposed a new definition of the community as a revision of the strong community. That is, a community is required to satisfy that each node’s degree within it should not be smaller than its degree to any other community. This definition is close to the intuition, but some instances of the complex network are not considered, especially the scale-free network. As a comparison, our method shares the same advantages of this method but overcomes its shortcomings.

The difficulties in finding communities within an arbitrary network are that the number of communities is unknown, and the size and density may vary with each other. Finding a division of a graph is proven to be an NP-complete problem [30]. With its wide applications, community detection has become a hot topic research issue recently. Many approaches have been proposed. Here we survey existing approaches briefly. According to their definitions of communities, they can be classified into three categories.

The purpose of graph partition is to partition a graph into several sub-graphs, each of which contains almost the same number of vertices. The Kernighan–Lin algorithm [17] and the spectral bisection [2] are the common used approaches. However, they need to be aware of the number and size of communities, which are unknown before detection.

Hierarchical clustering [12] has the advantage that it does not require a preliminary knowledge on the number and size of the communities. But the drawback is that vertices with little neighbors are often classified as separated clusters. And its computational complexity is O(n
                           2log
                           n) for a sparse graph.

Partition clustering including k-means, k-modes and k-median is also a method for community detection. However, the number of the communities K needs to be assigned and it is not scalable for large network.

The divisive algorithms come from an intuitive idea, that is, to drop some particular edges to form the communities. The most popular algorithm is the G–N algorithm [13]. It has two crucial drawbacks. One is that the algorithm does not know where to end. The other is that the time complexity is O(m
                           2
                           n) with m as the number of edges and n as the number of the vertices, which is inefficient for large graphs.

After the G–N algorithm, many optimization techniques [30,41,31,35,14] are proposed in recent years. However, due to the natural spirit of division, none of them is suitable for massive graphs.

Modularity is proposed by Newman and Girvan in 2004 [30]. It is a great contribution as the first quantitative criterion for community detection. The modularity maximization algorithm checks all vertices. If adding a vertex to the community will increase the modularity, it is included into this community. It has been recently proved that modularity optimization is an NP-complete problem [5]. Existing modularity maximization algorithms are all based on approximate optimization.

However, all the maximization algorithms are based on the assumption that one node is connected to another one randomly in the network. Such assumption is incomprehensible when the size of the network becomes huge, where one node will ignore most of the others. The weakly interconnected complete graphs would be merged by modularity optimization if the network is sufficiently large [11], while the small communities would fail to be detected by modularity optimization, even though they are even well-defined [19].

In this section, a practical definition of community is proposed. For this definition, a peaks model is introduced at first. For the convenience of discussion, the networks in this paper are connected networks. An unconnected network can be processed in the same way by treating each connected component as an individual network. The community in this paper is defined as a partition of graph. The communities are independent and every node in the graph has a clear position. The overlapping situation [15] is not taken into consideration, but will be one of the future works.

Intuitively, a community is a group of vertices in the network with high influence to each other. Hu et al. [16] defines community in this way. However, it does not take some common patterns into consideration. We illustrate this drawback with an example.

As in the Fig. 3
                     , it is supposed that we have known that vertex v1, v2, v3 are the leaders of company C1, v4 and v5 are the leaders of company C2, and v6–v9 are other vertices that belong to C2. By the definition in [16], v10 should belong to C2, while it does not seem convincing since v10 is closer to the leaders of C1.

Such drawback makes existing methods different from the real-world situations. We attempt to solve this problem for scale-free network in this section. The scale-free distribution is one of the most important characteristics of many real-world networks [10]. A scale-free network is a network with vertex degree distribution following the power law.

To make the definition of community suitable for scale-free networks, the features can be used to define the community. One major feature of a scale-free network is that the connections of nodes are in a power-law distribution and some vertices have a large number of connections in a network. These vertices can be recognized as “cores” in the network. Since there have been a large number of edges around cores, the vertices around the cores have high probability to be a dense sub-graph. Thus, we define communities around cores.

At first, we define Cores formally in Definition 1.
                        Definition 1
                        Core


                        If v
                           1,
                           v
                           2,…,
                           vn
                           
                           ∊
                           O are n cores within community C, Dg(v) is the degree of v, O should satisfy that
                              
                                 
                                    ∀
                                    v
                                    ∈
                                    O,
                                    
                                    ∀
                                    
                                       
                                          v
                                       
                                       
                                          ′
                                       
                                    
                                    ∈
                                    C
                                    -
                                    O,
                                    
                                    Dg
                                    (
                                    v
                                    )
                                    ≥
                                    Dg
                                    (
                                    
                                       
                                          v
                                       
                                       
                                          ′
                                       
                                    
                                    )
                                 
                              
                           The set O is called core set and each vi
                           
                           ∊
                           O is a core.

The definition of core is natural to complex networks. For example, in Fig. 3, the leaders of a company are considered as the core set of the community.

From the aspect of core set, a network can be modeled as a 3D shape, where the height of every vertex is the distance to the nearest core, as shown in Fig. 4
                           .

To define community formally, we summary required symbols and abbreviations in Table 1
                           .

With the discussions above, a community should satisfy that the distance from each vertex to the core in this community should be no larger than that in any other community. When a vertex v has same shortest distances to the cores in two communities C
                           1 and C
                           2, v should belong to the community with the most vertices connected to v, since v has closer relations with such community. According to above discussions, the community is defined based on core in Definition 2.

A community partition of a graph G is a set of sub-graphs S
                           ={C
                           1,
                           C
                           2,…,
                           Cm
                           } in G satisfying:
                              
                                 
                                    
                                       
                                          ∪
                                       
                                       
                                          k
                                          =
                                          1
                                       
                                       
                                          k
                                          =
                                          m
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          k
                                       
                                    
                                    =
                                    G
                                 
                              
                           
                           
                              
                                 
                                    ∀
                                    C
                                    ⊂
                                    S
                                    ,
                                    
                                    C
                                    ∩
                                    (
                                    G
                                    -
                                    C
                                    )
                                    =
                                    ∅
                                 
                              
                           
                           
                              
                                 
                                    ∀
                                    v
                                    ∈
                                    
                                       
                                          C
                                       
                                       
                                          k
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          D
                                       
                                       
                                          
                                             
                                                C
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    (
                                    v
                                    )
                                    ≤
                                    min
                                    {
                                    
                                       
                                          D
                                       
                                       
                                          
                                             
                                                C
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                    (
                                    v
                                    )
                                    ,
                                    
                                    j
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    m
                                    }
                                 
                              
                           
                           
                              
                                 
                                    ∀
                                    v
                                    ∈
                                    
                                       
                                          C
                                       
                                       
                                          k
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          D
                                       
                                       
                                          
                                             
                                                C
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    (
                                    v
                                    )
                                    =
                                    
                                       
                                          D
                                       
                                       
                                          
                                             
                                                C
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                    (
                                    v
                                    )
                                    ,
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             ∈
                                             
                                                
                                                   C
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          A
                                       
                                       
                                          v
                                          ,
                                          i
                                       
                                    
                                    ≥
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             i
                                             ∈
                                             
                                                
                                                   C
                                                
                                                
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          A
                                       
                                       
                                          v
                                          ,
                                          i
                                       
                                    
                                    ,
                                    
                                    j
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    m
                                 
                              
                           Each Ci
                            is called a community.

Such definition provides properties for optimizing community detection algorithms. For the introduction of these properties, we define two concepts related to communities. The Inners are the vertices without connections to vertices in other communities and they are not the furthest vertices of any a path to the core of the community that it belongs to. The Boundaries are other vertices besides the Inners.
                        Definition 3
                        Inners


                        
                           Inners are vertices within a community, and I is the Inners of C iff 
                              
                                 ∀
                                 ν
                                 ∈
                                 I
                                 ,
                                 τ
                                 ∈
                                 G
                                 -
                                 C
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       ν
                                       ,
                                       τ
                                    
                                 
                                 =
                                 1
                              
                            and 
                              
                                 ∀
                                 ν
                                 ∈
                                 I
                              
                           , 
                              
                                 ∃
                                 μ
                                 ∈
                                 C
                              
                            make 
                              
                                 
                                    
                                       A
                                    
                                    
                                       ν
                                       μ
                                    
                                 
                                 =
                                 1
                                 
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 ν
                                 )
                                 ≤
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 μ
                                 )
                              
                           .


                           Boundaries are vertices within a community, and B is the Boundaries of C iff 
                              
                                 ∀
                                 ν
                                 ∈
                                 B
                              
                           , 
                              
                                 ∀
                                 τ
                                 ∈
                                 G
                                 -
                                 C
                              
                           , 
                              
                                 
                                    
                                       A
                                    
                                    
                                       ν
                                       ,
                                       τ
                                    
                                 
                                 =
                                 1
                              
                            or 
                              
                                 ∀
                                 ν
                                 ∈
                                 B
                              
                           , 
                              
                                 μ
                                 ∈
                                 C
                              
                            makes 
                              
                                 
                                    
                                       A
                                    
                                    
                                       ν
                                       μ
                                    
                                 
                                 =
                                 1
                                 
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 ν
                                 )
                                 ⩽
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 μ
                                 )
                              
                           
                        

The Inners and Boundaries of Zachary’s karate club in Fig. 1 are shown in Fig. 5
                           .

We propose two properties for the communities in our model in Theorems 1 and 2. They will be applied to the algorithms in Section 4.


                           If the degree of a vertex v is no less than all others inside a community, v belongs to the Cores, that is
                           
                              
                                 
                                    ∃
                                    ν
                                    ∈
                                    C
                                    ,
                                    
                                    ∀
                                    μ
                                    ∈
                                    C
                                    ,
                                    
                                    Dg
                                    (
                                    v
                                    )
                                    ≥
                                    Dg
                                    (
                                    μ
                                    )
                                    ,
                                    
                                    v
                                    ∈
                                    
                                       
                                          O
                                       
                                       
                                          C
                                       
                                    
                                 
                              
                           
                        

We proof it by reduction to absurdity.

Suppose ν
                           ∉
                           OC
                           , then according to the definition of core, 
                              
                                 ∃
                                 
                                    
                                       ν
                                    
                                    
                                       ′
                                    
                                 
                                 ∈
                                 
                                    
                                       O
                                    
                                    
                                       C
                                    
                                 
                                 ,
                                 Dg
                                 (
                                 ν
                                 )
                                 ⩽
                                 Dg
                                 (
                                 
                                    
                                       ν
                                    
                                    
                                       ′
                                    
                                 
                                 )
                              
                           . It is in contradiction with 
                              
                                 ∀
                                 μ
                                 ∈
                                 C
                                 ,
                                 Dg
                                 (
                                 ν
                                 )
                                 ⩾
                                 Dg
                                 (
                                 μ
                                 )
                              
                           . Then the theorem is proven.□

To show the second theorem, a lemma is 
                        
                           ν
                           
                              
                                 I
                              
                              
                                 C
                              
                           
                           
                              
                                 ∪
                              
                              
                                 C
                              
                              
                                 B
                              
                           
                           =
                           C
                        
                      introduced at first.
                        Lemma 1
                        
                           The Inners and the Boundaries ωs together form a community and no other vertices are in the community. That is, 
                           
                              
                                 
                                    
                                       I
                                    
                                    
                                       C
                                    
                                 
                                 
                                    
                                       ∪
                                    
                                    
                                       C
                                    
                                    
                                       B
                                    
                                 
                                 =
                                 C
                              
                           .

If 
                              
                                 ν
                                 ∈
                                 C
                                 ν
                                 ∉
                                 
                                    
                                       I
                                    
                                    
                                       C
                                    
                                 
                                 ,
                                 
                                 ∀
                                 τ
                                 ∈
                                 G
                                 -
                                 C
                                 ,
                                 
                                 
                                    
                                       A
                                    
                                    
                                       ν
                                       ,
                                       τ
                                    
                                 
                                 =
                                 1
                                 
                                 or
                                 
                                 μ
                                 ∈
                                 C
                                 
                                 yields
                                 
                                 
                                    
                                       A
                                    
                                    
                                       ν
                                       μ
                                    
                                 
                                 =
                                 1
                                 
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 ν
                                 )
                                 ≤
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 μ
                                 )
                              
                           . Then satisfies the definition of Boundaries, that is ν
                           ∊
                           B. Thus. Thus the lemma is proven.□


                           For a vertex v in Inners, there exist a vertex ω, such that the shortest distance from v to any core is no larger than that of. That is, 
                           
                              
                                 ∀
                                 ν
                                 ∈
                                 
                                    
                                       I
                                    
                                    
                                       C
                                    
                                 
                                 ,
                                 
                                 ∃
                                 ω
                                 ∈
                                 
                                    
                                       B
                                    
                                    
                                       C
                                    
                                 
                                 ,
                                 
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 ν
                                 )
                                 ≤
                                 
                                    
                                       D
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 ω
                                 )
                              
                           .


                           
                              
                                 (1)
                                 According to the definition of Inners, if 
                                       
                                          ν
                                          ∈
                                          I
                                          
                                             
                                                μ
                                             
                                             
                                                ′
                                             
                                          
                                          ,
                                          ∃
                                          μ
                                          ∈
                                          C
                                          
                                          makes
                                          
                                          
                                             
                                                A
                                             
                                             
                                                ν
                                                μ
                                             
                                          
                                          =
                                          1
                                          
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          ν
                                          )
                                          ≤
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          μ
                                          )
                                       
                                    .

If 
                                       
                                          μ
                                          ∈
                                          I
                                          ∃
                                          ω
                                          =
                                          
                                             
                                                μ
                                             
                                             
                                                k
                                             
                                          
                                          ,
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          ν
                                          )
                                          ⩽
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          μ
                                          )
                                          ⩽
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          
                                             
                                                μ
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                          ⩽
                                          …
                                          ⩽
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          
                                             
                                                μ
                                             
                                             
                                                k
                                             
                                          
                                          )
                                          =
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          ω
                                          )
                                       
                                    , the step is repeated and a is obtained such that 
                                       
                                          
                                             
                                                A
                                             
                                             
                                                μ
                                                
                                                   
                                                      μ
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                          
                                          =
                                          1
                                          
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          μ
                                          )
                                          ≤
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          
                                             
                                                μ
                                             
                                             
                                                ′
                                             
                                          
                                          )
                                       
                                    .

Step (1) and (2) are repeated until 
                                       
                                          
                                             
                                                μ
                                             
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          ∈
                                          C
                                          
                                          satisfying
                                          
                                          
                                             
                                                A
                                             
                                             
                                                
                                                   
                                                      μ
                                                   
                                                   
                                                      k
                                                   
                                                
                                                
                                                   
                                                      μ
                                                   
                                                   
                                                      k
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                          =
                                          1
                                          
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          
                                             
                                                μ
                                             
                                             
                                                k
                                             
                                          
                                          )
                                          ≤
                                          
                                             
                                                D
                                             
                                             
                                                C
                                             
                                          
                                          (
                                          
                                             
                                                μ
                                             
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          )
                                       
                                    . According to Theorem 2, 
                                       
                                          
                                             
                                                μ
                                             
                                             
                                                k
                                             
                                          
                                          ∈
                                          B
                                       
                                    .

According to these properties, if a core v is used as the center of a community, this community is surrounded by a set of vertices whose distances to v are relatively large. The communities are separated by vertices with relatively larger distance to their cores. This is a base of community detection algorithms in Section 4.

With the new definition, our algorithms for community detection are proposed in this section. The Cores-Aware algorithm and the Cores-Unaware algorithm share the same idea. In these algorithms, some vertices are selected as cores and each vertex is put to the community containing its nearest core. The former one is for the cases that the cores are aware in advance. The latter one is for the case that the cores are unaware. Since Cores-Aware algorithm is used as the base of the Cores-Unaware algorithm, the Cores-Aware algorithm is introduced first. After these two algorithms are introduced, the usages of feedback information and structural features are discussed.

The Cores-Aware algorithm is designed for the cases where all the cores are aware. For example, if the goal is to find communities in a social network for an election, the candidates are considered as cores. And the Cores-Aware algorithm is also a key part of the Cores-Unaware algorithm, which is for the situation where the Cores are unaware (see Fig. 6
                        ).

In Cores-Aware algorithm, some vertices are inputted as the cores of communities and other vertices are put to the communities according to the distances to the cores. To support the algorithm, we introduce a data structure V_Info. For each vertex v, a tuple with 6 attributes is in V_Info. The first attribute is a flag identifying whether v has been checked; the second is the ID of the layer which v located; the third is the degree of v, and the fourth is the ID of the community that v belongs to. The fifth is a vector contains all the neighbors of v. And the last is a vector with each entry as a triple (label, distance, count) representing each possible cluster for v.
                           
                              
                                 
                                 
                                    
                                       
                                          
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

As the pseudo code shown in Algorithm 1, the algorithm consists of three phases as follows. The whole process is a parallel breadth-first traversal.
                           
                              (1)
                              Each core is checked and assigned a uniform labels, and its count and distance are both initialized as 1 (line 1–3).

The graph is breadth-first traversed in parallel. For each vertex v with at least one of its neighbors not checked, it is checked whether v has a core as the unchecked neighbor. If so, such unchecked neighbor is considered as a candidate. The information of all candidates is recorded in the neighbor entry of v and its count is initialized as 1. The distns entry of each candidate u is set to be u’s distance plus 1. Otherwise, if for two vertices v and u, one of their neighbors shares same candidate clusters, the count entries of all shared candidate clusters are increased by 1. Then other neighbors are checked with the similar method (line 4–10)

Each vertex v is scanned and putted to the community with minimum distance from its core to v. If two communities share the same shortest distance from their cores to v, the community with larger number of edges connecting to v is selected, since the connections in a community should be dense according to the definition.

For example, the community detection is performed on the graph in Fig. 7
                        . We aware that v
                        1, v
                        2 are the cores of C
                        1 and v
                        10 is the core of C
                        2. They are assigned to different labels. And then the labels of v
                        3, v
                        4, v
                        5, v
                        6 are set to be same as that of v
                        1 and v
                        2, representing they belongs to C
                        1. Additionally, the label of v
                        10 is assigned the same label as v
                        11 and v
                        12. In the next step, the labels to v
                        7 and v
                        8 are set to be v
                        3 and v
                        5. The label to v
                        13 is set to be that of v
                        11 and v
                        12. In the last step, the label of v
                        9 may be that of v
                        7 and v
                        8 or that of v
                        13. Since more paths are from the core of C
                        1 to v
                        9, through v
                        7 and v
                        8, respectively. V
                        9 should be clustered to C
                        1.

Since each vertex is clustered to its nearest cores, the result is optimal. Step 1 runs in constant time. Step 2 and 3 run in time O(nP
                        2), where n is the number of vertices, P is the number of Cores. And step 4 runs in time O(nP
                        2). The time complexity of the cores-aware algorithm is O(nP
                        2). According to [10], a network has only a few vertices that are the most influential. Therefore, P can be treated as a constant.

In most cases, the cores of the communities are unaware in advance. To handle such instances, we design Cores-Unaware algorithm, which does not need the information of cores. In this section, the framework of the Cores-Unaware algorithm is introduced at first, and then some constraints will be discussed to make a more satisfying division.

It is common that some communities do not have certain cores. Since we know neither community number nor which vertices are cores, the Cores-Aware algorithm is infeasible in many cases. To make our method suitable for such cases, we propose the framework of Cores-Unaware algorithm in this section.

With the presence of the Cores-Aware algorithm, if some candidates can be selected as Cores, then community detection can be processed by invoking existing Core-Aware algorithm. Thus the essential problem is which vertices should be the Cores. To solve this problem, our algorithm chooses candidates of Cores and then filters the candidates with structural constraints of the network.

Since incorrect Cores may mislead the community detection, we should choose them carefully. According to Theorem 1, the vertex with the largest degree (we define it as the Peak) within a community must belong to the Cores. If the degree of a vertex is no less than any of its neighbor, we call it a Key. And if a vertex has the largest degree in a community, we call it a Peak. Peaks and Keys are defined formally as following.
                              Definition 5
                              Keys


                              
                                 Keys is a set of vertices within a network. A vertex K is a Keys of network N iff 
                                 
                                    
                                       ∀
                                       ν
                                       ∈
                                       K
                                       
                                       ν
                                       ∈
                                       C
                                       ,
                                       
                                       ∀
                                       μ
                                       ∈
                                       N
                                       -
                                       ν
                                       ,
                                       
                                       
                                          
                                             A
                                          
                                          
                                             ν
                                             ,
                                             τ
                                          
                                       
                                       =
                                       1
                                       ,
                                       
                                       then
                                       
                                       Dg
                                       (
                                       ν
                                       )
                                       ≥
                                       Dg
                                       (
                                       μ
                                       )
                                    
                                 . Each vertex in Keys is called a key.


                                 Peaks is a set of vertices within a community and a vertex P is a Peak of a community C iff 
                                 
                                    
                                       ∀
                                       ν
                                       ∈
                                       P
                                       ν
                                       ∈
                                       C
                                       ,
                                       
                                       0.35
                                       em
                                       ∀
                                       μ
                                       ∈
                                       C
                                       -
                                       ν
                                       ,
                                       
                                       then
                                       
                                       Dg
                                       (
                                       ν
                                       )
                                       ≥
                                       Dg
                                       (
                                       μ
                                       )
                                    
                                 . Each vertex in Peaks is called a Peak.

With the definition of Peaks and Keys, the following theorem is proposed as the foundation of the Cores-Unaware algorithm.


                                 If a vertex is a Peak, it is also a Key. That is, 
                                 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             C
                                          
                                       
                                       ⊆
                                       
                                          
                                             K
                                          
                                          
                                             C
                                          
                                       
                                    
                                 .

We prove the theorem with reduction to absurdity.

Suppose 
                                    
                                       
                                          
                                             P
                                          
                                          
                                             C
                                          
                                       
                                       ⊈
                                       
                                          
                                             K
                                          
                                          
                                             C
                                          
                                       
                                       ,
                                       ν
                                       ∈
                                       
                                          
                                             P
                                          
                                          
                                             C
                                          
                                       
                                    
                                 , then according to the definition of Keys, 
                                    
                                       ∃
                                       μ
                                       ∈
                                       N
                                       -
                                       ν
                                       ,
                                       
                                          
                                             A
                                          
                                          
                                             ν
                                             ,
                                             τ
                                          
                                       
                                       =
                                       1
                                       ,
                                       
                                       then
                                       
                                       Dg
                                       (
                                       ν
                                       )
                                       ≤
                                       Dg
                                       (
                                       μ
                                       )
                                    
                                 . If 
                                    
                                       μ
                                       ∈
                                       C
                                       ,
                                       Dg
                                       (
                                       ν
                                       )
                                       ≤
                                       Dg
                                       (
                                       μ
                                       )
                                    
                                  is in contradiction with the definition of the Peaks. Else if 
                                    
                                       μ
                                       ∉
                                       C
                                    
                                 , according to the definition of Cores, 
                                    
                                       μ
                                       ∈
                                       
                                          
                                             O
                                          
                                          
                                             C
                                          
                                       
                                    
                                 . It is in contradiction with 
                                    
                                       μ
                                       ∉
                                       C
                                    
                                 . The theorem is proven.□

Since the exact cores are unaware, we cluster all vertices to its nearest peak. As shown in Algorithm 2, the algorithm for the Cores-Unaware community detection consists of three phases as follows. In the first phrase (line 1–3), all the vertices are checked and each key is assigned with a uniform label. Since both of two connected nodes cannot be used as cores, if two or more keys are neighbors, they share the same label. Then, in the second phrase in line 4, the keys are reduced to the peaks according to structural constraints such as network conditions and topological constraints. This step is based on the constraints and will be discussed in detail in Section 4.2.2. The communities are found by running Cores-Aware Algorithm with peaks determined in the last step as cores (line 5).

We run the algorithm on Zachary’s karate club for example. Suppose we do not know the conflict between the club members, but we want to see whether there are some small communities in this graph. Firstly, the graph is traversed to find the keys with degrees larger than those of their neighbors. Such keys are {V
                           1, V
                           34}. Without structural constraints, these keys are totally retained to the peaks. Then we run the Cores-Aware algorithm on the graph based on the peaks and the partition results are obtained.
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

For efficient implement of steps 1–3, a heap is built. In each iteration, at most one vertex with the neighbors is deleted from the heap. With Fibonacci heap, the time complexity of steps 1–3 is O(n). The computational complexity of step 4 is related with P, where P is the number of the peaks, and mostly is far less than n. We will discuss the step 4 in Section 4.2.2. According to Section 4.1, the time complexity of step 5 in O(nP
                           2). In summary, the total time complexity is O(nP
                           2). According to [10], the number of most influential vertices is small in a network. Hence P can be treated as a constant number.

In the Cores-Unaware algorithm, structural constraints are used to pick proper Peaks from the set of keys. In this section, we will discuss structural constraints with their applications for peaks selection. Inspired by the definition of mountains, we propose four structural constraints. They are from the practical conclusions from the geographers.

The set of peaks can be selected according to existing peaks. The information for peak prediction includes the vertex number, size and all other topological conditions that will affect the set of peaks. If we know some vertices are peaks in advance, we can just add them into the Peaks. And if we know the number T of communities, we can just keep the top T Peaks and drop others.

The knowledge of network topological feature can improve both efficiency and effectiveness of community detection. Here we propose some examples. If we know that the network has a forest structure, then the community should be easily detected from the roots. If it is known that the maximum degree of vertices is 8, then the vertices with degree 8 are selected as the cores directly.

It is obvious that if there is more than one edge in a connected network, a vertex with degree one could never be a Peak. In default setting, we only consider the vertices with degree 1 and 2 since in real world, even a dense graph has sparse part and such constraint is sufficient to filter useless vertices. And when the degree constraint get larger, it is possible to remove potential candidates for relative small communities. If some special applications require cohesive community, the degree constraint could be set larger. According to such constraint, a proper minimum degree constraint will reduce the size of Keys significantly and avoid useless computation. For Cores-Unaware algorithm in Algorithm2, the minimum degree constraint can be applied on the step 1.

As discussed before, the drawback of the absence of distance constraint is that more communities that should be merged are generated. Fig. 8
                               illustrates this situation. Therefore, we add the distance constraint for the peak selection to make communities satisfying the distance constraint. Distance and degree gap are the most common measurements for mountains [4]. Mountains can be defined as “Height over base of 1000m (3281ft)–1500m (4921ft), with a slope greater than 5 degrees.” With the distance and degree gap, the structure of the division can be changed easily. For example, we can find the communities by defining that their distance should be greater than 10, and the gap should be greater than 10 degree.

In this section, our algorithms are applied to several datasets to verify their effectiveness and efficiency. First, a synthetic network is tested, and then our method is tested on some real-world networks. The experimental environment is a PC with Intel Celeron CPU E3200 2.4GHz, 2G main memories, VS2010. All algorithms are implemented with C++.

The modularity [30] is the most common used quantitative criteria in recent years. It is based on the assumption that each node can get attached to the others in the network. However, such assumption is incomprehensible when the size of the network becomes huge, where one vertex may connects with some vertices in higher possibility than others due to the locality. Hence, in this section, we will introduce a practical quantitative criterion.

The most impartial evaluation is the difference to the exact division as the baseline. As far as we know that the Zachary’s karate club has a real division based on this observation. The S-measure is defined based on the real division. S is the similarity between a division and the real division. It can be formally defined as follows. In this definition, N is the number of vertices and si
                         represents whether a vertex i is clustered to its real community. If i is clustered to its real community, si
                        
                        =1; else si
                        
                        =0.
                           
                              
                                 S
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             N
                                          
                                       
                                       
                                          
                                             s
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       N
                                    
                                 
                              
                           
                        Rand index [34] is a measure of the similarity between two results of clustering. Given S
                        ={o
                        1,
                        o
                        2,…,
                        on
                        } and two partitions X and Y to compare, a is the number of pairs in the same cluster in X and in the same cluster in Y, b is the number of pairs in different clusters of X and in different clusters of Y. The Rand index R is:
                           
                              
                                 R
                                 =
                                 
                                    
                                       a
                                       +
                                       b
                                    
                                    
                                       
                                          
                                             C
                                          
                                          
                                             n
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                     

To measure the quality of a community partition, we denote the correct division result as X, and the division result of the algorithm as Y.

We choose these two measures for the effectiveness because they are relative simple to compute and analysis of results is easy to perform according to these measures.

Since the network of Zachary’s karate club [45] has been widely used to test the community detection algorithms, we use it to compare our method with existing community detection methods. And it will be firstly used as a real-world network to test our algorithms. As mentioned in Fig. 1, we know in advance that the administrator and the instructor are represented by node 1 and node 33 respectively. These two vertices are considered as the Peaks of the network. Thus the Cores-Aware algorithm can be applied to the network. And the division result is illustrated in Fig. 9
                        .

The exact division in real-world is shown in Fig. 1(b). We can see that the attribution of vertex 9 is the only difference between our division and the real division. That shows that the Cores-Aware algorithm is effective.

Then the Cores-Unaware algorithm is applied one the network with just one constraint that every peak vertex should have a degree larger than two. The algorithm found two key vertices V
                        1 and V
                        34, because their degrees are larger than any their neighbors. Since V
                        34 and V
                        33 are neighbors and V
                        34 has a larger degree, V
                        34 is selected to be a key instead of V
                        33. Without other structural constraints, the keys are retained to the peaks. Hence the peaks here are {V
                        1,
                        V
                        34}. Then the communities are detected based on these peaks. It can be observed that the result is different with the Cores-Aware algorithm in which V
                        1 and V
                        33 are peaks. But it turned out that the division from Cores-Unaware algorithm is exact the same as the division from Cores-Aware algorithm. It shows that the Cores-Unaware algorithm is effective.

As shown in the Table 2
                        , the divisions of our algorithms are better in both the S measure and R measure on the data and it represents that their results are closer to the real division. The effectiveness of the algorithms is shown.

College football [13] is a network of American football games between Division IA colleges during regular season fall 2000. The network is a known community structure that the teams are divided into “conferences”. And the teams in the same “conference” meet each other more than those in other conferences. We verify the performance of the Cores-Unaware algorithm when the topological properties are adopted.

The algorithm is run 15 times on the data with only different minimal degrees as the topological constraints. As shown in Table 3
                        , the divisions are the same when minimal degree changes from 1 to 10. The network is divided into 12 communities, same as the real division, and both the S-measure and R-measure are high. The division result is close to the real division. When the minimal degree is 11, the division results contain 5 communities. Both S-measure and R-measure are declined. When the minimal degree is 12, only 2 communities are found. The S-measure and R-measure are very low. And the minimal degree reaches 13 or above, the division is just the network itself.

As we can be observed in Fig. 10
                        , the run time of all the 15 experiments are almost the same. Thus the stability of the algorithm is verified. Since the degree of all the cores found in the algorithm are larger than 10, when the minimal degree varies from 1 to 10, the division results are same. But when the minimal degree gets larger, some cores are pruned, which results in less community numbers. When the minimal degree is larger than 12, all the cores are pruned. It shows that the topological properties affect the algorithm within a certain range.

We evaluate the effectiveness and the scalability of the algorithms on the synthetic networks in this section.

Fortunato and Barthelemy [11] have proved that a network consisting of a ring of cliques and connected through single links may fail to be detected by any a modularity maximization algorithm when the size N and number M of the cliques changes. They mentioned that when n
                           >
                           m(m
                           −1)+2, the cliques will be clustered into pairs. To test the performance on such difficult case, we generate a network with n
                           =4, m
                           =16, and run the CNM algorithm and the Cores-Unaware algorithm on the network. The division results are shown in Figs. 11 and 12
                           
                           .

As can be seen in the Fig. 11, some well-defined communities may fail to be discovered by modularity optimization algorithm. As a comparison, the division from the Cores-Unaware algorithm in Fig. 12 is just the same as predetermined.

R-MAT is a well-known model for scale-free network generation proposed by Chakrabarti, etc. [6] in 2004. We generate R-MAT networks with different parameters for the scalability evaluation.

Firstly, six networks with 1K, 2K, 4K, 8K, 16K, 32K vertices are generated and the edges in each network are 10 times of the vertices number. Then they are processed by the Cores-Unaware and C–N–M algorithm, respectively. The results are presented in Fig. 13
                           . In Fig. 13, the time is in log scale. As we can see in the figure, the run time of the Cores-Unaware algorithm is around linear to the vertex number. And its growth rate is apparently smaller than the C–N–M algorithm. This experiment verified the computational complexity of our algorithm.

To test the impact of edges, six networks are generated with 10K, 20K, 40K, 80K, 160K, 320K edges and the number of vertices is fixed 4K. These networks are processed by the Cores-Unaware algorithm and C–N–M algorithm, respectively, and the results are shown in the Fig. 14
                           . The time axis is in log scale. From the figure, it can be observed that the number of the edges in the network has almost no effect on the efficiency of the Cores-Unaware algorithm when the number of the vertices is fixed. While the edge number affects the efficiency of C–N–M algorithm more significantly.

As analyzed in Section 1, the C–N–M algorithm achieves the best time complexity in all algorithms. Hence the experimental comparison is performed between proposed algorithm with the best performance and the algorithm proposed by this paper.

We tested the Cores-Unaware algorithm (with just one topological constraint that minimum degree=3) and C–N–M algorithm on different datasets to compare their performance. “Dolphins” is an undirected social network of frequent associations between 62 dolphins in a community living off Doubtful Sound, New Zealand. “College football” is a network of American football games between Division IA colleges during regular season fall 2000. “CA-GrQc” is a collaboration network of Arxiv General Relativity. “P2p_Gnutella04” is Gnutella peer to peer network from August 4 2002. “Email_Enron” is email communication network from Enron. “Soc-Epinions1” is a who-trust-whom online social network of a general consumer review site Epinions.com. “Slashdot0902” is a technology-related news website known for its specific user community. “Amazon0601” is Amazon product co-purchasing network from June 1 2003. “roadNet-PA” is road network of Pennsylvania. “road Net-CA” is road network of California. All the details are shown in Table 4
                        , where “–” means that it cannot be known or it is unable to get the result in limited time and space.

Since the Zachary’s karate club [45] and American College football [13] have real divisions, they can be exploited to be criterions. As observed in Table 4, the division of the Cores-Unaware algorithm is S
                        =0.971 and R
                        =0.711, they are larger than the division of the C–N–M algorithm with S
                        =0.706 and R
                        =0.487, respectively. It proves that our algorithm achieved a closer result to real division. Thus the effectiveness of the algorithm is also verified.

When the data size gets larger, the efficiency of the Cores-Unaware algorithm is better than the C–N–M algorithm. When the data size is larger than 10K, the C–N–M cannot return results with limited time and space. However, the Cores-Unaware algorithm is still practical. The C–N–M algorithm runs in time O(mdlog
                        n), where m is the number of edges, n is the number of vertices, and d is the depth of the “dendrogram” describing the network’s community structure [7]. As a comparison, the Cores-Unaware algorithm runs in time O(nP
                        2), where n is the number of vertices, and P is the number of Peaks. The division result of “road Net-CA” with 1,965,206 vertices and 5,533,214 edges shows that our algorithm is scalable.

@&#CONCLUSION@&#

Community detection in complex network is a basic task for graph management and mining. Even though many techniques for community detection have been proposed, exact definition and practical algorithms are still in demand. This demand motives us to propose a novel definition of community satisfying that the distance from each vertex to the Cores in the community should not be larger than that toward any other community. Inspired from geography knowledge, we propose the peak model to find community structure of complex network based on such definition. Such model is suitable for scale-free networks and can be exploited to solve more huge-graph problems.

To address community detection problem under this model, two algorithms are proposed. The first one is based on a given center set and the second one runs in absence of the center set. The algorithms are efficient and can take advantage of feedback and structural constraints to improve the performance. The computational complexity of the algorithm is nearly linear and suitable for large network. Experimental results one various data sets show that our algorithms are effective, efficient and able to scale to huge graphs.

Since the size of social graph data is getting larger and larger. As an example, the number of Facebook users has surpassed one billion at 2012. The algorithms suitable for with massive network are in urgent demand. We believe that proposed algorithms achieve a better understanding of the complex huge networks.

Despite the four most common topology constraints, as the future work, we will search for some better constraints. Since some network has many updating operation, dynamic maintenance of the community structure will be our most important future work. Besides, changing the algorithm to suit for the overlapping situation is also one of the future works.

@&#ACKNOWLEDGMENTS@&#

We thank Professor M.E.J. Newman and the SNAP team from Stanford for their generously providing data, applications and publications. This paper was partially supported by NGFR 973 Grant 2012CB316200, NSFC Grant 61003046, 61111130189 and NGFR 863 Grant 2012AA011004. Doctoral Fund of Ministry of Education of China (No. 20102302120054). Key Laboratory of Data Engineering and Knowledge Engineering (Renmin University of China), Ministry of Education (No. KF2011003). The Fundamental Research Funds for the Central Universities (No. HIT. NSRIF. 2013064).

@&#REFERENCES@&#

