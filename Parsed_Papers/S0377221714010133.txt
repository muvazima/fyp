@&#MAIN-TITLE@&#Total completion time minimization on multiple machines subject to machine availability and makespan constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We study bi-criteria scheduling with limited machine availability.


                        
                        
                           
                           Our goal is to minimize ∑Cj
                               subject to the condition that C
                              max  ≤ T.


                        
                        
                           
                           We show the problem, Pm
                              (t)|m(t + Δ) ≥ m(t) − 1, r − a, prmt|∑Cj
                              /C
                              max  ≤ T, 0 ≤ Δ < ce: paraid = "para0005" > is in P.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Scheduling

Parallel machine

Bi-criteria

Limited machine availability

Polynomial time algorithm

@&#ABSTRACT@&#


               
               
                  This paper studies preemptive bi-criteria scheduling on m parallel machines with machine unavailable intervals. The goal is to minimize the total completion time subject to the constraint that the makespan is at most a constant T. We study the unavailability model such that the number of available machines cannot go down by 2 within any period of p
                     max  where p
                     max  is the maximum processing time among all jobs. We show that there is an optimal polynomial time algorithm.
               
            

@&#INTRODUCTION@&#

Multi-criteria scheduling and scheduling subject to machine availability constraints have been two very active areas in manufacturing and operations management research over the last couple of decades. A lot of applications for multi-criteria scheduling have been addressed in the books (Steuer, 1986; T’kindt and Billaut, 2002), surveys (Chen and Bulfin, 1993; Dileepan and Sen, 1988; Hoogeveen, 2005) and the references therein. On the other hand, applications for scheduling subject to machine availability have been addressed in many surveys (Diedrich, Jansen, Schwarz, and Trystram, 2009; Lee, Lei, and Pinedo, 1997; Ma, Chu, and Zuo, 2010; Saidy and Taghvi-Fard, 2008; Schmidt, 2000) and the references therein. In the real life, both models may co-exist in some scenarios. While manufacturers aim at optimizing multi-criteria simultaneously, resources may not be always available due to breakdown, preventive maintenance or processing unfinished jobs from a previous planning horizon. However, most research in these two areas has been conducted independently from one another. The only work that concerns both bi-criteria scheduling and scheduling with limited machine availability simultaneously is done by the authors in paper (Huo and Zhao, 2011). The paper (Huo and Zhao, 2011) considers preemptively scheduling the jobs on two machines to minimize the total completion time and makespan at the same time with one as primary criterion and the other as secondary criterion.

In this paper, we continue our research on this complicated model trying to solve more tractable problems. We consider m, m ≥ 2, parallel machines with unavailability constraint. We study the unavailability model such that the number of available machines cannot go down by 2 within any period of p
                     max  where p
                     max  is the maximum processing time among all jobs. So, in this model, the number of available machines can decrease or increase at any time t; but there is a restriction on how the number of available machines decreases, i.e. the number of available machines can only go down by at most one machine unit, provided that it has not gone down by one machine unit during the interval [t − p
                     max , t]. This machine unavailabililty model is so far the maximally solvable model for total completion time minimization problem. It includes two special models that have been studied in literature: (1) The number of available machines can only increase. In this case, each machine has at most one unavailable period and this period starts at time zero. We say in this case that each machine has a release time; (2) Each machine may have multiple unavailable periods, but there is at most one machine unavailable at any time. In reality, the first machine unavailability model may occur due to the unfinished jobs in the previous scheduling horizon and the second machine model exists in many scenarios since the preventive maintenance or periodical repair is usually done on a rotation basis instead of maintaining or repairing several machines simultaneously.

We focus on preemptive schedules. A job can be preempted by another job or interrupted by machine unavailable intervals and resumed later on any available machine. Our goal is to minimize the total completion time subject to the condition that the makespan is at most a constant T. The makespan and total completion time are two objectives of considerable interest. Minimizing makespan can ensure a good balance of the load among the machines and minimizing the total completion time can reduce the inventory holding costs. It is quite common that the manufacturers wish to minimize both objectives. The motivations for bi-criteria scheduling concerned with makespan and total completion have been addressed by Gupta, Ho, and Webster (2000), Leung and Young (1989), and survey papers about multi-criteria scheduling mentioned above.

Formally speaking, there is a set J = {J
                     1, J
                     2, …, Jn
                     } of n jobs that need to be scheduled on m machines. Each job Jj
                      has a processing time pj
                     . Let p
                     max  = max (p
                     1, p
                     2, …, pn
                     ). Without loss of generality, the processing times of jobs are assumed to be integer. There are m machines in total and each may have unavailable intervals. Thus the number of available machines changes over time and we use m(t) to represent the number of available machines at time t. We assume that for all time t ≥ 0 and all Δ < ce: paraid = "para0010" > we have m(t + Δ) ≥ m(t) − 1. Let S be a feasible schedule of these n jobs on the m machines, the completion time of job Jj
                      in schedule S is denoted by Cj
                     (S). If S is clear from the context, we will use Cj
                      for short. The makespan of S is C
                     max (S) = max {Cj
                     (S)}, and the total completion time of S is ∑Cj
                     (S). We will use 
                        
                           C
                           max
                           *
                        
                      to denote the minimum makespan among all feasible schedules. The goal is to schedule the set of jobs on m parallel machines so as to minimize ∑Ci
                      subject to the machine unavailability constraint and the condition that C
                     max  ≤ T, where 
                        
                           T
                           ≥
                           
                              C
                              max
                              *
                           
                        
                     . To denote our problem, we can extend the 3-field notation introduced by Graham, Lawler, Lenstra, and Rinnooy Kan (1979): Pm(t)∣m(t + Δ) ≥ m(t) − 1, r − a, prmt∣∑Cj
                     /C
                     max  ≤ T, where 0 ≤ Δ < p
                     max .

@&#LITERATURE REVIEW@&#

So far there is only one research paper (Huo and Zhao, 2011) that considers multicriteria scheduling with limited machine availability constraint. In the paper, Huo and Zhao give optimal polynomial algorithms for three problems: (1) P
                              1, 1∣r − a, prmt∣∑Cj
                              /C
                              max  where p
                              1, 1 means one machine is always available and the other may have unavailable intervals; (2) P
                              1, 1∣r − a, prmt∣C
                              max /∑Cj
                              ; and (3) P
                              2∣r − a, prmt∣C
                              max /∑Cj
                               in which both machines are unavailable during an interval [t, t + x) and at most one machine is unavailable at any other time.

In the following, we will review the relevant results in the area of bi-criteria scheduling and in the area of scheduling with limited machine availability, respectively. We will survey the results concerning with makespan and total completion time only.

Research on multicriteria scheduling problems on parallel machines has not been dealt with adequately in the literature. Gupta et al. (2000) propose an exponential algorithm to solve optimally the bi-criteria problem of minimizing the weighted sum of makespan and mean flow time on two identical parallel machines. When preemption is allowed, P∣prmt∣C
                              max /∑Cj
                               and P∣prmt∣∑Cj
                              /C
                              max  are polynomially solved by Leung and Young (1989), and Leung and Pinedo (2003), respectively.

With limited machine availability, when there are multiple machines, if preemption is not allowed, makespan minimization and total completion time minimization problems are both NP-hard (Lee and Liman, 1993; Lenstra, Rinnooy Kan, and Brucker, 1977; Schmidt, 2000). When preemption is allowed and the machines have limited availability constraint, the makespan minimization problem is shown to be solvable in P by Liu and Sanlaville (1995); when each machine has a release time, that is, m(t) is non-decreasing, it is easy to show that SPT (shortest processing time first) rule minimizes ∑Cj
                               and one can modify the McNaughton rule (McNaughton, 1959) to minimize the makespan. Finally, for our unavailability model, i.e. m(t + Δ) ≥ m(t) − 1 for all t ≥ 0 and Δ < p
                              max , Leung and Pinedo (2004) showed that PSPT (preemptive SPT, i.e., at any time, when a machine becomes available for processing jobs, the job with the minimum remaining time gets scheduled.) rule gives the optimal schedule for the total completion time.

In this paper, we study the problem Pm(t)∣m(t + Δ) ≥ m(t) − 1, r − a, prmt∣∑Cj
                              /C
                              max  ≤ T for Δ < p
                              max . We show that we can solve this problem in polynomial time by developing an optimal algorithm.

Our paper is organized as follows. In Section 2, we give some preliminary results. In Section 3, we give the main results. We develop a polynomial algorithm and prove that it solves our problem optimally. In Section 4, we draw the conclusion.

As we mentioned before, SPT rule gives an optimal schedule for the total completion time when each machine has only a single unavailable interval starting from time 0. In general, however, SPT is not optimal when machines have arbitrary unavailable intervals. Still, it has been shown by Leung and Pinedo (2004) that PSPT rule gives an optimal schedule for the total completion time and some other objectives under our unavailability model. See below.

                        Lemma 1
                        Theorem 3 in Leung and Pinedo, 2004
                        


                        For m machines, m ≥ 2, if m(t + Δ) ≥ m(t) − 1 for all t ≥ 0 and Δ < ce: paraid = "para0019" > then PSPT minimizes 
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 f
                                 
                                    (
                                    
                                       C
                                       j
                                    
                                    )
                                 
                              
                            provided that f is increasing concave.

When the machines have arbitrary unavailable intervals, for the bi-criteria objective, ∑Cj
                     /C
                     max  ≤ T, following the same argument as Lemma 1 in Huo and Zhao (2011) one can show that the jobs complete in SPT order, see the following lemma.

                        Lemma 2
                        For m (m ≥ 2) machines with arbitrary unavailability constraints, there is a preemptive optimal schedule for the objective ∑Cj
                           /C
                           max  ≤ T, such that if pi
                            < pj
                           , then Ci
                            ≤ Cj
                           .

Suppose in an optimal schedule for ∑Cj
                           /C
                           max  ≤ T, there are two jobs Ji
                            and Jj
                            such that pi
                            < pj
                            and Ci
                            > Cj
                           . We can divide all the intervals that Ji
                            is scheduled into two parts such that the intervals in the first part are all before Cj
                            and the intervals in the second part are all after Cj
                           . We exchange the second part of Ji
                            with part of Jj
                            making sure that this part of Ji
                            does not overlap with the first part of Ji
                           . We must be able to do so since pj
                            ≥ pi
                           . In this way, the completion time of job Ji
                            is decreased by at least Ci
                            − Cj
                           , and the completion time of job Jj
                            is increased by (Ci
                            − Cj
                           ) and all other jobs have same completion time as before.□

Throughout this paper, we assume jobs J
                     1, J
                     2, …, Jn
                      are indexed in nondecreasing order of their processing times, i.e., p
                     1 ≤ p
                     2 ≤ ⋅⋅⋅ ≤ pn
                     .

In this section, we will develop an optimal algorithm for our problem. Here we consider 
                        
                           
                              C
                              max
                              *
                           
                           ≤
                           T
                           ≤
                           
                              C
                              max
                              ′
                           
                        
                      where 
                        
                           C
                           max
                           ′
                        
                      is the makespan of the schedule produced by PSPT rule and 
                        
                           C
                           max
                           *
                        
                      is the minimum makespan of problem Pm(t)∣m(t + Δ) ≥ m(t) − 1, r − a, prmt∣C
                     max  ≤ T which can be obtained by the algorithm of Liu and Sanlaville (1995). Apparently, if 
                        
                           T
                           <
                           
                              C
                              max
                              *
                           
                           ,
                        
                      no feasible schedule exists and if 
                        
                           T
                           >
                           
                              C
                              max
                              ′
                           
                           ,
                        
                      we can simply apply PSPT rule to the problem.

The basic idea of our algorithm is to iteratively schedule the jobs, in SPT order, as early as possible subject to the condition that all the remaining jobs can finish by T. We can show that in order to check whether the remaining jobs can finish by T, it is sufficient to check whether the last m − 1 jobs (or all the remaining jobs if less than m − 1 jobs are left) can finish by T.

Let n′ be the number of jobs we are going to schedule as early as possible subject to the condition that the last m − 1 jobs can finish by T. Initially, n′ = n, and n′ may be updated during the procedure. For each job Jj
                     , (1 ≤ j ≤ n′), when we add it to S, we try to schedule it on the machine with the earliest idle time. For convenience, we use fi
                      to denote the completion time of the last job scheduled on machine Mi
                      at the beginning of each iteration in our algorithm, and we reindex the machines such that f
                     1 ≤ f
                     2⋅⋅⋅ ≤ fm
                     . So job Jj
                      will be scheduled on machine M
                     1.

We also assume that at the beginning of each iteration, the unavailable intervals can be rearranged to the machine with index as large as possible, thus at any time instant after f
                     
                        i + 1, if machine M
                     
                        i + 1 is available, then Mi
                      must also be available. For each machine Mi
                     , we use ai
                      to denote the total length of the idle intervals between fi
                      and T on Mi
                     . We use Li
                      (1 ≤ i ≤ m) and |Li
                     | to represent the set of unavailable time intervals on machine Mi
                      during [fi, T] and its total length of these intervals, respectively. Apparently, if u ≤ v, the set of unavailable time intervals after time fv
                      in Lu
                      must be a subset of Lv
                      and Lv
                     ∖Lu
                      is the set of time intervals after fv
                      during which machine Mu
                      is available but Mv
                      is not.

Note that the above assumption is just for ease of algorithm description and analysis. If job Jj
                      is scheduled at certain time on a machine which is actually unavailable in S by our algorithm, we can always find a machine to schedule the job at the same time without rearranging the real unavailable intervals since preemptive is allowed.

After job Jj
                      is scheduled, we need to make sure that the last m − 1 jobs (or all the remaining jobs if n − j < m − 1) can finish by T. We first check if Jn
                      can complete on M
                     2 by T, then check if J
                     
                        n − 1 can complete on M
                     3 by T, and so on, in this order. During this process, we decide if a job Jk, n − m + 2 ≤ k ≤ n, needs to preempt Jj
                     , and if so, at what time and how much.

Specifically, for each job Jk, n − m + 2 ≤ k ≤ n (or j + 1 ≤ k ≤ n if n − j < m − 1), we first check if pk
                      ≤ ai, i = n − k + 2. If so, it means that machine Mi
                      has enough idle time interval before T to schedule Jk
                     , and we say that this machine has a surplus σi
                      = ai
                      − pk
                     ; otherwise, only part of the job with length ai
                      can be scheduled on machine Mi
                     , we say that the job has a deficit δk
                      = pk
                      − ai
                     . When a job Jk
                      has deficit, we check if its deficit can be distributed to the machines with surplus. We check the machines in the order of M
                     
                        i − 1, M
                     
                        i − 2, …, M
                     2. If a machine Ml
                      (i − 1 ≥ l ≥ 2) has surplus σl
                      and the surplus is more than the deficit, i.e. σl
                      ≥ δk
                     , we update σl
                      = σl
                      − δk, δk
                      = 0 and we continue to check the next job J
                     
                        k − 1 on machine M
                     
                        i + 1; otherwise, the surplus is less than the deficit, we update δk
                      = δk
                      − σl
                      and σl
                      = 0, and we continue to check the next machine with surplus. If after we consider all the machines Ml
                      (i − 1 ≥ l ≥ 2), we still have δk
                      > 0, then this is the amount that job Jk
                      has to be scheduled on M
                     1. We try to schedule this part of Jk
                      on M
                     1 as late as possible. So we first schedule Jk
                      backward starting from T to the idle interval where Jk
                      is not scheduled on Mi
                     . If there is still part of Jk
                      not scheduled, we schedule the remaining part of the job Jk
                      to those intervals where Jj
                      is scheduled but Jk
                      is not, and reschedule the replaced part of job Jj
                      to the idle time intervals on M
                     1 as early as possible, and set n′ = k − 1.

We repeat this procedure until all the last m − 1 jobs (or all the remaining jobs if n − j < m − 1) are checked. We then fix the schedule of Jj
                      and the jobs scheduled before Jj
                      on machine M
                     1, update the processing times of the last m − 1 jobs by excluding the part scheduled before the completion time of job Jj
                      on M
                     1, and remove the jobs that are scheduled after Jj
                      on M
                     1. If Jj
                      finishes at time T, set n′ = j. Otherwise, we continue to schedule the next job J
                     
                        j + 1 in a similar way until all n′ jobs have been scheduled. If n′ < n, we schedule all the remaining jobs 
                        
                           
                              J
                              n
                           
                           ,
                           …
                           ,
                           
                              J
                              
                                 
                                    n
                                    ′
                                 
                                 +
                                 1
                              
                           
                        
                      one by one, in this order, on machine 
                        
                           
                              M
                              2
                           
                           ,
                           …
                           ,
                           
                              M
                              
                                 n
                                 −
                                 
                                    n
                                    ′
                                 
                                 +
                                 1
                              
                           
                        
                      respectively. We schedule job Jk, n ≥ k ≥ n′ + 1 backward from time T on machine Mi, i = n − k + 2. If it cannot be completely scheduled on machine Mi
                     , we schedule the unfinished part of job Jk
                      backward during the idle time intervals on machines M
                     
                        i − 1, M
                     
                        i − 2, …, M
                     2, in this order. In case there is an overlap of Jk
                      on Ml
                     (i − 1 ≥ l ≥ 2) with part of Jk
                      on other machines, we swap the overlapped Jk
                      on Ml
                      with the job J
                     
                        n − l + 2 on Ml
                     . The formal algorithm is presented in the following.

                        Algorithm 1
                        
                           
                              
                                 
                              
                           
                        

We use an example to explain Algorithm 1. There are four machines such that M
                     1 is unavailable during [0, 3), M
                     3 is unavailable during [4, 7), M
                     4 is unavailable during [8, 12). See Fig. 1
                      (0). We need to schedule five jobs before time T = 12. The processing times of J
                     1, …, J
                     5 are 5, 6, 7, 10, 10, respectively. We first rearrange the unavailable intervals and renumber the machines so that all unavailable intervals are on the last machine M
                     4. Then we schedule J
                     1 on M
                     1 during [0, 5), we check if J
                     5, J
                     4, and J
                     3 can finish before 12. Since p
                     5 = 10 < a
                     2 = 12, we have σ
                     2 = 2, and δ
                     5 = 0. Similarly, σ
                     3 = 2, and δ
                     4 = 0, see Fig. 1 (1). For J
                     3, we first move the unavailable interval after time 5 to M
                     1. Then we get σ
                     4 = 1 δ
                     3 = 0. See Fig. 1 (2). So we fix the schedule of J
                     1, reorder the machines, see Fig. 2
                      (3). Then we schedule J
                     2 on the new M
                     1 during interval [0, 6), and do the check in a similar way. This time, however, J
                     4 has to utilize the surplus on M
                     2 (see Fig. 2 (4)), and J
                     3 has to preempt J
                     2 and so J
                     2 is delayed. By the algorithm, we update the processing time of J
                     3 and set n′ = 2 and stop Step 5(f). Then, we schedule job 5, 4, 3 in this order based on Step 7. The final schedule is given Fig. 2 (5).

                        Lemma 3
                        The order pn
                            ≥ p
                           
                              n − 1 ≥ ⋅⋅⋅ ≥ p
                           
                              n − m + 2 ≥ p
                           
                              n − m + 1 ≥ ⋅⋅⋅ ≥ p
                           1 is always maintained even if pk
                            is updated for some n − m + 2 ≤ k ≤ n in some iterations in Step 5 of the algorithm.

We show the Lemma is true after each time we schedule a job Jj
                            in Step 5. We first show that the relative order of the lengths of the last (m − 1) jobs is maintained. Let J
                           
                              k + 1 and Jk
                            be two of the last (m − 1) jobs. According to the algorithm, after Jj
                            is scheduled on M
                           1, we check if job J
                           
                              k + 1 can complete by T on machine M
                           
                              i − 1 and if job Jk
                            can complete by T on machine Mi
                           , where i = n − k + 2.

If p
                           
                              k + 1 is unchanged in Step 5 (g), we must have p
                           
                              k + 1 ≥ pk
                           . Otherwise, part of J
                           
                              k + 1 is scheduled before the completion time of job Jj
                            on machine M
                           1. Let 
                              
                                 p
                                 
                                    k
                                    +
                                    1
                                 
                                 ′
                              
                            be the new length of job J
                           
                              k + 1 after it is updated. We know 
                              
                                 
                                    p
                                    
                                       k
                                       +
                                       1
                                    
                                    ′
                                 
                                 ≥
                                 
                                    a
                                    
                                       i
                                       −
                                       1
                                    
                                 
                              
                           . Furthermore, there is no surplus on any machine M
                           
                              i − 1, …, M
                           2. If job Jk
                            can be fully scheduled on machine Mi
                           , we have 
                              
                                 
                                    p
                                    k
                                 
                                 ≤
                                 
                                    a
                                    i
                                 
                                 ≤
                                 
                                    a
                                    
                                       i
                                       −
                                       1
                                    
                                 
                                 ≤
                                 
                                    p
                                    
                                       k
                                       +
                                       1
                                    
                                    ′
                                 
                              
                           . Otherwise, part of job Jk
                            will be scheduled on machine M
                           1 backward from time T. Let 
                              
                                 p
                                 k
                                 ′
                              
                            be the length of job Jk
                            after Step 5(g). Since part of J
                           
                              k + 1 is scheduled before Cj
                            on M
                           1, there must be no idle time before f
                           
                              i − 1 on M
                           1 and we must have Cj
                            ≥ f
                           
                              i − 1. So if there is a part of job Jk
                            before f
                           
                              i − 1 on M
                           1, it must be excluded from 
                              
                                 p
                                 k
                                 ′
                              
                           . And since the unavailable intervals after fi
                            in L
                           
                              i − 1 is the subset of that in Li
                           , 
                              
                                 p
                                 k
                                 ′
                              
                            is at most a
                           
                              i − 1 at the end of Step 5 (g). Thus 
                              
                                 
                                    p
                                    k
                                    ′
                                 
                                 ≤
                                 
                                    a
                                    
                                       i
                                       −
                                       1
                                    
                                 
                                 ≤
                                 
                                    p
                                    
                                       k
                                       +
                                       1
                                    
                                    ′
                                 
                              
                            and the order is maintained.

Now we show that p
                           
                              n − m + 1 ≤ p
                           
                              n − m + 2. Note that when we check J
                           
                              n − m + 2, am
                            and a
                           1 will be updated at the beginning of Step 5(f), and we have am
                            ≥ a
                           1. If p
                           
                              n − m + 2 is not updated in Step 5, then p
                           
                              n − m + 2 ≥ p
                           
                              n − m + 1. Otherwise, let 
                              
                                 p
                                 
                                    n
                                    −
                                    m
                                    +
                                    2
                                 
                                 ′
                              
                            be the new length of job J
                           
                              n − m + 2. We must have 
                              
                                 
                                    p
                                    
                                       n
                                       −
                                       m
                                       +
                                       2
                                    
                                    ′
                                 
                                 ≥
                                 
                                    a
                                    m
                                 
                              
                            and there is no idle time before fm
                            on M
                           1 after Jj
                            is preempted and scheduled after part of J
                           
                              n − m + 2 on M
                           1, and Cj
                            ≥ am
                           . Furthermore, σl
                            = 0, for all l, 2 ≤ l ≤ m. In this case, all the remaining jobs have to be and can be scheduled on the first machine, which means that we must have am
                            ≥ a
                           1 ≥ p
                           
                              n − m + 1. Thus 
                              
                                 
                                    p
                                    
                                       n
                                       −
                                       m
                                       +
                                       2
                                    
                                    ′
                                 
                                 ≥
                                 
                                    a
                                    m
                                 
                                 ≥
                                 
                                    a
                                    1
                                 
                                 ≥
                                 
                                    p
                                    
                                       n
                                       −
                                       m
                                       +
                                       1
                                    
                                 
                              
                           . Since the processing time is unchanged for p
                           1, p
                           2, …, p
                           
                              n − m + 1, the relative order of the (remaining) processing times is maintained.□


                           Algorithm 1 generates a feasible schedule S of the n jobs with the first n′ jobs being scheduled as early as possible subject to the condition that the last m − 1 jobs can finish before T.

By assumption, 
                              
                                 T
                                 ≥
                                 
                                    C
                                    
                                       max
                                    
                                    *
                                 
                                 ,
                              
                            so there is a feasible schedule such that the makespan is at most T. We will show S is feasible in two phases: in phase 1, we will prove by induction that the partial schedule S after Step 5 is feasible; and in phase 2, we will show that the schedule S after Step 7 is still feasible.

                              Phase 1
                              In this step, we show the partial schedule S after Step 5 is feasible. Specifically, we show by induction that S, which is the partial schedule produced after the first n′ jobs have been scheduled as early as possible subject to the condition that the last m − 1 jobs can finish before T (we name it the earliness property), is feasible, and given S there is a way to schedule the remaining (n − n′) jobs before T.

This is certainly true when no jobs are scheduled. Assume that the hypothesis is true after the first j − 1 jobs have been scheduled, we need to show that after Jj
                            is scheduled in Step 5, the remaining jobs can all be scheduled before T. We show this in two steps.


                           Step (1). We first show that the partial schedule S at the end of Step 5 is feasible, and given S, the largest m − 1 jobs, Jn, J
                           
                              n − 1, …, J
                           
                              n − m + 2 (or all the remaining jobs, Jn, J
                           
                              n − 1, …, J
                           
                              j + 1 if n − j < m − 1) can be feasibly scheduled. By induction, job Jj
                            can be feasibly scheduled on machine M
                           1 in Step 5(d). Apparently, this is the earliest time that Jj
                            can be scheduled and so the earliness property is maintained. Now we will show that the largest m − 1 jobs, Jn, J
                           
                              n − 1, …, J
                           
                              n − m + 2 (or all the remaining jobs, Jn, J
                           
                              n − 1, …, J
                           
                              j + 1 if n − j < m − 1) can be feasibly scheduled based on Step 5(f).

As we can see in Step 5(f), these jobs are considered in non-increasing order of their processing time. For each job Jk, n − m + 2 ≤ k ≤ n, we schedule it backward from time T on machine Mi, i = n − k + 2. If a job Jk
                            has a deficit, we schedule the remaining part of Jk
                            to the idle times (surpluses) on the machines M
                           
                              i − 1, M
                           
                              i − 2, …, M
                           2, M
                           1. Since the deficit δk
                            and surplus σl
                           (i + 1 ≥ l ≥ 2) may be reduced after each machine Ml
                           (i + 1 ≥ l ≥ 2) is considered, we use 
                              
                                 δ
                                 k
                                 
                                    (
                                    0
                                    )
                                 
                              
                            to represent the initial deficit after Jk
                            is scheduled on machine Mi
                            and 
                              
                                 
                                    σ
                                    l
                                    
                                       (
                                       0
                                       )
                                    
                                 
                                 
                                    (
                                    i
                                    +
                                    1
                                    ≥
                                    l
                                    ≥
                                    2
                                    )
                                 
                              
                            to represent the initial surplus after job J
                           
                              n − l + 2 is scheduled on machine Ml
                           .

Without loss of generality, we assume that S does not contain any partial job Jk
                            before job Jj
                            was scheduled. And we have two cases based on whether the total surplus on machines M
                           
                              i − 1, M
                           
                              i − 2, …, M
                           2 is larger than the deficit of job Jk
                            or not.

                              Case 1
                              The total surplus on machines M
                                 
                                    i − 1, M
                                 
                                    i − 2, …, M
                                 2 is larger than the deficit of job Jk
                                 , that is, 
                                    
                                       
                                          ∑
                                          
                                             q
                                             =
                                             2
                                          
                                          
                                             i
                                             −
                                             1
                                          
                                       
                                       
                                          σ
                                          q
                                       
                                       ≥
                                       
                                          δ
                                          k
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                    
                                 .

Let p be the largest index such that 2 ≤ p < i and machine Mp
                                  has surplus. Job J
                                 
                                    n − p + 2 must have been fully scheduled on machine Mp
                                 , so 
                                    
                                       
                                          p
                                          
                                             n
                                             −
                                             p
                                             +
                                             2
                                          
                                       
                                       =
                                       T
                                       −
                                       
                                          f
                                          p
                                       
                                       −
                                       
                                          |
                                          
                                             L
                                             p
                                          
                                          |
                                       
                                       −
                                       
                                          σ
                                          p
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                       ≥
                                       
                                          p
                                          k
                                       
                                    
                                 . And since 
                                    
                                       
                                          p
                                          k
                                       
                                       =
                                       T
                                       −
                                       
                                          f
                                          i
                                       
                                       −
                                       
                                          |
                                          
                                             L
                                             i
                                          
                                          |
                                       
                                       +
                                       
                                          δ
                                          k
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                       ,
                                    
                                  we have 
                                    
                                       
                                          δ
                                          k
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                       ≤
                                       
                                          f
                                          i
                                       
                                       −
                                       
                                          f
                                          p
                                       
                                       
                                          +
                                          |
                                       
                                       
                                          L
                                          i
                                       
                                       
                                          |
                                          −
                                          |
                                       
                                       
                                          L
                                          p
                                       
                                       
                                          |
                                          −
                                       
                                       
                                          σ
                                          p
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                    
                                 . We can always schedule Jk
                                  of length min {δk, σp
                                 } on machine Mp
                                  backward from T to the time intervals such that during these intervals job Jk
                                  is not scheduled but (1) machine Mp
                                  is idle; or (2) J
                                 
                                    n − p + 2 is scheduled, and in this case we need to reschedule the replaced part of J
                                 
                                    n − p + 2 to the idle time intervals on machine Mp
                                 . Note that even if another job Jx
                                  replaced J
                                 
                                    n − p + 2 in the previous iterations and is scheduled during such time intervals on machine Mp
                                 , due to 
                                    
                                       
                                          δ
                                          x
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                       ≤
                                       
                                          f
                                          
                                             n
                                             −
                                             x
                                             +
                                             2
                                          
                                       
                                       −
                                       
                                          f
                                          p
                                       
                                       
                                          +
                                          |
                                       
                                       
                                          L
                                          
                                             n
                                             −
                                             x
                                             +
                                             2
                                          
                                       
                                       
                                          |
                                          −
                                          |
                                       
                                       
                                          L
                                          p
                                       
                                       
                                          |
                                          −
                                       
                                       
                                          σ
                                          p
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                       ,
                                    
                                  there always exists a set of time intervals with the total length of 
                                    
                                       σ
                                       p
                                       
                                          (
                                          0
                                          )
                                       
                                    
                                  such that Mp
                                  is available during these time intervals but M
                                 
                                    n − x + 2 is not (and Mi
                                  is not available either), and thus we can always use these intervals to schedule Jk
                                 . After that if δk
                                  is still larger than 0, we find the new p which is the largest index such that p < i and machine Mp
                                  has surplus and repeat the same procedure.

The total surplus on machines M
                                 
                                    i − 1, M
                                 
                                    i − 2, …, M
                                 2 is smaller than the deficit of job Jk
                                 , that is, 
                                    
                                       
                                          ∑
                                          
                                             q
                                             =
                                             2
                                          
                                          
                                             i
                                             −
                                             1
                                          
                                       
                                       
                                          σ
                                          q
                                       
                                       <
                                       
                                          δ
                                          k
                                          
                                             (
                                             0
                                             )
                                          
                                       
                                    
                                 . Based on whether there exist a machine Mp
                                 (2 ≤ p ≤ i − 1) that has a surplus, we have the following two cases:

                                    
                                       
                                          Case (a). There does not exist a machine Mp
                                          (2 ≤ p ≤ i − 1) that has a surplus.

In this case, we have 
                                             
                                                
                                                   ∑
                                                   
                                                      q
                                                      =
                                                      2
                                                   
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   σ
                                                   q
                                                
                                                =
                                                0
                                             
                                          . Let f
                                          1 be the earliest idle time on M
                                          1 before job Jj
                                           is scheduled. By induction hypothesis, all jobs Jj
                                          , …, Jn
                                           can be feasibly scheduled by T, so we must have that pk
                                           ≤ T − f
                                          1 − |L
                                          1|, and thus we can always schedule the deficit of job Jk
                                           during the time interval where machine M
                                          1 is available but machine Mi
                                           is not, which includes the available intervals in [f
                                          1, fi
                                          ] on machine M
                                          1 and the time intervals in Li
                                          ∖L
                                          1. We schedule the part of job Jk
                                           with length 
                                             
                                                δ
                                                k
                                                
                                                   (
                                                   0
                                                   )
                                                
                                             
                                           backward from T on machine M
                                          1 during the time intervals where machine Mi
                                           is unavailable but machine M
                                          1 is idle or has job Jj
                                           scheduled. If part of Jj
                                           needs to be replaced, we reschedule this part of job Jj
                                           to the idle time after Cj
                                           and update Cj
                                          . Note that by scheduling job Jk
                                           in this way, we make sure that Jj
                                           is scheduled as early as possible subject to the condition that Jk
                                           can finish at T. On the other hand, if there is a job other than Jj
                                          , say Jx
                                          , that is scheduled on M
                                          1 during an interval [t − ε, t] on M
                                          1, we skip it and schedule the unfinished part of job Jk
                                           before this part of Jx
                                           backward from t − ε and so on. Since x > k, by scheduling job Jk
                                           in this way, we make sure that job Jk
                                           is scheduled as early as possible subject to the condition that Jn
                                          , …, J
                                          
                                             k + 1 can finish by T.


                                          Case (b). There exists a machine Mp
                                          (2 ≤ p ≤ i − 1) that has a surplus, and let p be the largest index of all such machines.

In this case, since ap
                                           ≥ ai
                                           and job J
                                          
                                             n − p + 2 which has larger processing time than Jk
                                           has been fully scheduled on Mp
                                          , we can always schedule the deficit of job Jk
                                           during the time interval where machine Mi
                                           is unavailable but machine Mp
                                           is available, which includes the available intervals in [fp, fi
                                          ] on machine Mp
                                           and the time intervals in Li
                                          ∖Lp
                                          . Note that we must have that no partial jobs J
                                          
                                             k + 1, …, J
                                          
                                             n − p + 2 are scheduled on machine M
                                          1 and 
                                             
                                                
                                                   δ
                                                   k
                                                   
                                                      (
                                                      0
                                                      )
                                                   
                                                
                                                ≤
                                                
                                                   a
                                                   p
                                                
                                                −
                                                
                                                   a
                                                   i
                                                
                                             
                                          . Furthermore, no partial jobs J
                                          
                                             n − p + 3, …, Jn
                                           are scheduled on M
                                          1 after fp
                                           during the time intervals where machine Mp
                                           is available (Note that during these intervals, M
                                          
                                             p − 1, …, M
                                          2 are all available). Thus, we can always schedule the part of job Jk
                                           with length 
                                             
                                                δ
                                                k
                                                
                                                   (
                                                   0
                                                   )
                                                
                                             
                                           during the time intervals, where Mi
                                           is unavailable but Mp
                                           is available, on machine M
                                          1 and machines Mp, M
                                          
                                             p − 1, …, M
                                          2 if they have surplus. Specifically, we schedule part of job Jk
                                           with length of 
                                             
                                                
                                                   δ
                                                   k
                                                   
                                                      (
                                                      0
                                                      )
                                                   
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      q
                                                      =
                                                      2
                                                   
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   σ
                                                   q
                                                
                                             
                                           backward from T on machine M
                                          1 during the time intervals where Jk
                                           is not scheduled but M
                                          1 is idle or has Jj
                                           scheduled. If part of Jj
                                           needs to be replaced, we reschedule this part of job Jj
                                           to the idle time after Cj
                                           and update Cj
                                          . Then we distribute the unscheduled part of Jk
                                           of length 
                                             
                                                
                                                   ∑
                                                   
                                                      q
                                                      =
                                                      2
                                                   
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   σ
                                                   q
                                                
                                             
                                           on the machines with surplus during the time interval in [fp, fi
                                          ] where Mp
                                           is available and the time intervals of Li
                                          ∖Lp
                                           as we did in Case 1 but making sure these part of Jk
                                           does not overlap with the part that is scheduled on M
                                          1.

At the end of Step 5(f), let αk
                            be the part of job Jk
                            scheduled before Cj
                            on machine M
                           1. By the algorithm, this part of job Jk
                            will be fixed and the processing time of job Jk
                            will be updated in Step 5(g). Clearly, the new partial schedule S after this iteration is feasible and contains the partial job Jk
                            during the time interval [fp, Cj
                           ]. We now show that in the later iterations when we schedule J
                           
                              j + 1, 
                              
                                 
                                    J
                                    
                                       j
                                       +
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    
                                       n
                                       ′
                                    
                                 
                                 ,
                              
                            we can always schedule job Jk
                            feasibly. Consider the iteration when we schedule job J
                           
                              j + 1. The machines will be renumbered and we use 
                              
                                 
                                    M
                                    1
                                    ′
                                 
                                 ,
                                 …
                                 ,
                                 
                                    M
                                    
                                       m
                                       −
                                       1
                                    
                                    ′
                                 
                                 ,
                              
                           
                           
                              
                                 M
                                 m
                                 ′
                              
                            to represent the new ordered machines, and 
                              
                                 
                                    f
                                    1
                                    ′
                                 
                                 ,
                                 
                                    f
                                    2
                                    ′
                                 
                                 ,
                                 …
                                 ,
                                 
                                    f
                                    m
                                    ′
                                 
                              
                            and 
                              
                                 
                                    L
                                    1
                                    ′
                                 
                                 ,
                                 
                                    L
                                    2
                                    ′
                                 
                                 ,
                                 …
                                 ,
                                 
                                    L
                                    m
                                    ′
                                 
                              
                            to represent the earliest available time and the set of unavailable time intervals on machine 
                              
                                 
                                    M
                                    1
                                    ′
                                 
                                 ,
                                 …
                                 ,
                                 
                                    M
                                    
                                       m
                                       −
                                       1
                                    
                                    ′
                                 
                                 ,
                                 
                                    M
                                    m
                                    ′
                                 
                                 ,
                              
                            respectively. Apparently, we have 
                              
                                 
                                    f
                                    x
                                    ′
                                 
                                 ≥
                                 
                                    f
                                    x
                                 
                              
                            for all 1 ≤ x ≤ m. When we try to schedule job Jk
                            on 
                              
                                 
                                    M
                                    i
                                    ′
                                 
                                 ,
                              
                            job Jk
                            will have a new deficit 
                              
                                 
                                    δ
                                    k
                                    
                                       ′
                                       (
                                       0
                                       )
                                    
                                 
                                 =
                                 
                                    δ
                                    k
                                    
                                       (
                                       0
                                       )
                                    
                                 
                                 −
                                 
                                    α
                                    k
                                 
                                 +
                                 
                                    f
                                    i
                                    ′
                                 
                                 −
                                 
                                    f
                                    i
                                 
                                 
                                    +
                                    |
                                 
                                 
                                    L
                                    i
                                    ′
                                 
                                 
                                    |
                                    −
                                    |
                                 
                                 
                                    L
                                    i
                                 
                                 
                                    |
                                 
                              
                           . With the partial job Jk
                            of length αk
                            being scheduled during the interval [fp, Cj
                           ], we can still feasibly schedule the new deficit of job Jk
                           , 
                              
                                 
                                    δ
                                    k
                                    
                                       ′
                                       (
                                       0
                                       )
                                    
                                 
                                 ,
                              
                            after fp
                            during the time intervals, where 
                              
                                 M
                                 i
                                 ′
                              
                            is unavailable but Mp
                            is available, on machine 
                              
                                 M
                                 1
                                 ′
                              
                            and machines 
                              
                                 M
                                 y
                                 ′
                              
                            (2 ≤ y ≤ p), if they have surplus. By the same argument, job Jk
                            can always be feasibly scheduled in all the iterations until job J
                           
                              k − 1 is scheduled.


                           Step (2). Next, we show that if there are still jobs Jy
                            (j < y < n − m + 2) not scheduled after Step (1) above, we can find a feasible schedule for these jobs based on the schedule produced above.

We first schedule J
                           
                              n − m + 1 if there are still idle intervals on M
                           1 before T, we schedule job J
                           
                              n − m + 1 backward from T on M
                           1. Either it can be totally scheduled on M
                           1 and we are done, or it has a deficit δ
                           
                              n − m + 1 > 0. In the latter case, we try to schedule the remaining part of J
                           
                              n − m + 1 to those machines that have surplus just as we did in Step (1). By inductive hypothesis, the total length of the idle intervals (cannot be less than the total length of the remaining jobs) is sufficient, the deficit of this job must be able to be distributed to other machines starting from Mm
                            until M
                           2.

Then, we schedule the remaining jobs. After J
                           
                              n − m + 1 have been completely scheduled as above, or have not been scheduled at all because of no idle time on M
                           1, we backward schedule the remaining jobs in decreasing order of their processing times using the following procedure.

Let 
                              
                                 
                                    M
                                    
                                       i
                                       1
                                    
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    M
                                    
                                       i
                                       2
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    M
                                    
                                       i
                                       x
                                    
                                 
                              
                            be the machines that still have surplus. Let tu
                           (1 ≤ u ≤ x) be the end time of the last idle interval on 
                              
                                 M
                                 
                                    i
                                    u
                                 
                              
                            and we assume t
                           1 ≤ t
                           2 ≤ ⋅⋅⋅ ≤ tx
                           . We know that each of these machines has one of the longest m − 1 (or m if the first machine still has surplus after J
                           
                              n − m + 1 is scheduled) jobs that are completely scheduled. We denote these jobs by 
                              
                                 
                                    J
                                    
                                       i
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    
                                       i
                                       x
                                    
                                 
                              
                           .

Pick the next longest job Jw, j < w < n − m + 1 (or j < w ≤ n − m + 1 if J
                           
                              n − m + 1 is not scheduled because of no idle time on M
                           1). We backward schedule Jw
                            on the machine 
                              
                                 M
                                 
                                    i
                                    x
                                 
                              
                            starting from the end of the last idle interval tx
                           . If Jw
                            can be completely scheduled on the machine, we are done and continue to schedule the next job. Otherwise, it has a deficit δw
                           . The fact that 
                              
                                 J
                                 
                                    i
                                    x
                                 
                              
                            is one of the longest (m − 1) (or m if M
                           1 has surplus) jobs guarantees that δw
                            must be less than or equal to the length of job 
                              
                                 J
                                 
                                    i
                                    x
                                 
                              
                            which is scheduled after tx
                           . Also by the way we arrange the machines, we know that, for all 1 ≤ z ≤ x, δw
                            cannot be longer than the length of the part of job 
                              
                                 J
                                 
                                    i
                                    z
                                 
                              
                            scheduled after tx
                           . To schedule the remaining part of Jw
                           , we pick machine 
                              
                                 M
                                 
                                    i
                                    
                                       x
                                       −
                                       1
                                    
                                 
                              
                           . We schedule Jw
                            of length 
                              
                                 min
                                 (
                                 
                                    σ
                                    
                                       i
                                       
                                          x
                                          −
                                          1
                                       
                                    
                                 
                                 ,
                                 
                                    δ
                                    w
                                 
                                 )
                              
                            in the idle interval on 
                              
                                 M
                                 
                                    i
                                    
                                       x
                                       −
                                       1
                                    
                                 
                              
                           . If there is part of job Jw
                            overlapped with part of Jw
                            scheduled on 
                              
                                 
                                    M
                                    
                                       i
                                       x
                                    
                                 
                                 ,
                              
                            we exchange this overlapped part of job Jw
                            with 
                              
                                 J
                                 
                                    i
                                    
                                       x
                                       −
                                       1
                                    
                                 
                              
                            of the same length scheduled after tx
                            on 
                              
                                 M
                                 
                                    i
                                    
                                       x
                                       −
                                       1
                                    
                                 
                              
                           . If δw
                            = 0, we continue to schedule the next job; otherwise, we continue to schedule the remaining part to machine 
                              
                                 
                                    M
                                    
                                       i
                                       
                                          x
                                          −
                                          2
                                       
                                    
                                 
                                 ,
                              
                            etc. Note that during the time interval [tx, T], the total length of intervals, where 
                              
                                 J
                                 
                                    i
                                    z
                                 
                              
                            (1 ≤ z ≤ x) is scheduled but Jw
                            is not, is always larger than δw
                           . With the fact of 
                              
                                 T
                                 ≥
                                 
                                    C
                                    
                                       max
                                    
                                    *
                                 
                                 ,
                              
                            we must have δw
                            = 0 at some point. Following the same procedure, we can feasibly schedule all the remaining jobs.

Now we have shown that based on the partial schedule that the first j − 1 jobs are scheduled as early as possible subject to the condition that all the remaining jobs can be finished by T, the algorithm schedules job Jj
                            as early as possible subject to the condition that all the remaining jobs can be finished by T. By induction, the partial schedule S is feasible after the first n′ jobs have been scheduled as early as possible, and given S there is a way to schedule the remaining jobs before T.

                              Phase 2
                              Now we show that after Steps 6 and 7, the schedule S is still feasible. If n′ is never updated, then n′ = n, that is, we have feasibly scheduled all n jobs after Step 5; otherwise, we have n′ < n.

From the algorithm, we reset n′ in two cases. The first case is after we schedule job Jj
                            in Step 5(d), partial job Jk
                            with length of αk
                            > 0 has to be scheduled before Cj
                            on machine M
                           1. For this case, we set n′ = k − 1. Since αk
                            > 0, the completion time of jobs Jk
                           , …, Jn
                            must be T in our final schedule, otherwise, the earliness property of job Jj
                            will be violated. For this case, the partial jobs of Jk
                           , …, Jn
                            scheduled before Cj
                            will be fixed and the remaining part of jobs Jk
                           , …, Jn
                            must be able to be feasibly scheduled on machines M
                           2, …, Mi
                            in Step 7 following the same analysis as Case 2 of Step (1) in the above proof. The second case is when the current job Jj
                            finishes at time T after Step 5(f) and we set n′ = j. For this case, we have two subcases. (1) Job Jj
                            is not preempted. Since before Jj
                            is scheduled, we have a
                           1 ≥ a
                           2 ≥ ⋅⋅⋅ ≥ am
                            and all the remaining jobs have processing times larger than or equal to pj
                           , so we must have that a
                           1 = a
                           2 = ⋅⋅⋅ = am
                           , 
                              
                                 
                                    p
                                    
                                       n
                                       ′
                                    
                                 
                                 =
                                 ⋯
                                 =
                                 
                                    p
                                    n
                                 
                                 =
                                 
                                    p
                                    j
                                 
                                 ,
                              
                            exactly n − n′ < m jobs are left, and the completion time of jobs 
                              
                                 
                                    J
                                    
                                       
                                          n
                                          ′
                                       
                                       +
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    n
                                 
                              
                            must be T in our final schedule. For this subcase, it is clear that jobs J
                           
                              j + 1, …, Jn
                            can be feasibly scheduled in Step 7. (2) Job Jj
                            is preempted and finishes at T. Let job Jk
                            be the job with the smallest index that preempts job Jj
                           . Apparently, Jj
                            must be scheduled on M
                           1 during all those intervals where Mi
                            (i = n − k + 2) is available, thus we have pj
                            ≥ ai
                           , and all the machines Ml
                           (i ≥ l ≥ 2) have no surplus. For all jobs, Jx, j < x < k, we have px
                            ≥ pj
                            ≥ ai
                           . However, for all machines Mz, i + 1 ≤ z ≤ m, we have az
                            ≤ ai
                           . So we must have that the processing time of job Jx, j < x < k, is exactly ai
                            and az
                            = ai
                            for all i + 1 ≤ z ≤ m, and thus all such jobs Jx
                           (j < x < k) will finish at time T. For jobs Jk
                           , …, Jn
                           , following the same analysis as Case 2 of Step (1) in the above proof, they must be able to be feasibly scheduled on machines M
                           2, …, Mi
                            in Step 7 of Algorithm 1.□


                           Algorithm 1 can be implemented in O((nm
                           2 + nmB + BlogB) where B is the number of unavailable intervals.

Apparently, the running time of the algorithm is dominated by Step 5. In this step, we schedule n′ ≤ n jobs and for each job Jj
                           (1 ≤ j ≤ n′), we need to check whether the last m − 1 jobs can finish at T. To implement this step, we can maintain a list of the unavailable intervals, Bi
                           , on each machine Mi
                           , 1 ≤ i ≤ m. And we use |Bi
                           | to represent the number of intervals in Bi
                           . To build the initial lists, we first sort all the input unavailable intervals in non-decreasing order of the beginning time of the intervals and if necessary, we break the ties by the decreasing order of the length of the unavailable intervals; and then we scan and rearrange the sorted unavailable intervals one by one to machine Mm, M
                           
                              m − 1, …, M
                           1 in this order such that Bi
                            is the subset of B
                           
                              i + 1. Note that when we rearrange each interval, we only need to look at the last unavailable interval in Bi
                            for all m ≥ i ≥ 1. Thus, the time of creating the initial sets Bi
                           , 1 ≤ i ≤ m, is O(BlogB + Bm). And the total number of unavailable intervals in these initial sets, |B
                           1| + |B
                           2| + ⋅⋅⋅ + |Bm
                           |, is at most B.

When we check each of the last m − 1 jobs, Jk
                           , on machine Mi
                           (i = n − k + 2), we first calculate Jk
                           ’s deficit δk
                            and check if δk
                            can be decreased by using the surplus σl
                            of machines Ml
                            for all 2 ≤ l ≤ i − 1. It is easy to see that this can be done in O(m) time.

Next, if δk
                            is still greater than 0, we need to schedule this part of Jk
                            on machine M
                           1 backward from T to the intervals where Jk
                            is not scheduled on Mi
                            but M
                           1 is idle or has Jj
                            scheduled. To implement this, after Jj
                            is scheduled in Step 5(d), for M
                           1, we build another list, A, of intervals that either is idle or has job Jj
                            scheduled. This can be easily obtained based on the list for B
                           1. Let |A| be the number of intervals in A, then we must have that |A| ≤ |B
                           1| + 2. Thus when we schedule δk
                            of Jk
                            on M
                           1 to the intervals where Jk
                            is not scheduled on Mi
                            but M
                           1 is idle or has Jj
                            scheduled, we only need to traverse the intervals in Bi
                            (i = n − k + 2) and A backward simultaneously, and the running time is |A| + |Bi
                           |. Afterward, the number of intervals in A may be increased, but by at most |Bi
                           |. Thus when we check all the jobs, Jk, n ≥ k ≥ n − m + 2, the number of intervals in A is always bounded by O(B) and the total time to check all these jobs is O(mB + B). Note that, in Algorithm 1, when we check job J
                           
                              n − m + 2 on machine Mm
                           , we need to do some additional work, that is, moving the unavailable intervals after the updated f
                           1, where M
                           1 is available but Mm
                            is not, from Bm
                            to B
                           1. For this step, the update of Bm, B
                           1 and A can be done in time O(B). So the total time to check the last m − 1 jobs is O(m(m + B)) in each iteration of Step (5).

After that, in Step 5(h), we remove all the jobs after Cj
                            on machine M
                           1 and remove all the unavailable intervals before Cj
                            from B
                           1. So the total number of unavailable intervals in B
                           1, B
                           2, …, Bm
                            is still at most B. At the beginning of next iteration, before job J
                           
                              j + 1 is scheduled, we need to rearrange the unavailable intervals in Bi
                            for all 1 ≤ i ≤ m, such that the unavailable intervals after Cj
                           , where M
                           
                              i + 1 is available but Mi
                            is not, are moved from Bi
                            to B
                           
                              i + 1. This can be easily done in O(B). In conclusion, the total running time of the Algorithm 1 is O(nm
                           2 + nmB + BlogB).□


                           Algorithm 1 returns an optimal schedule S for Pm(t)∣m(t + Δ) ≥ m(t) − 1, r − a, prmt∣∑Cj
                           /C
                           max  ≤ T for Δ < p
                           max  in polynomial time.

By Lemma 4, S schedules the first n′ jobs as soon as possible as long as the last m − 1 jobs can finish before T. We now prove that S is optimal by first showing there exists an optimal schedule that schedules the first n′ jobs as early as possible subject to the condition that the last m − 1 jobs can finish by T. Assume there is an optimal schedule S* that does not schedule the first n′ jobs as early as possible. Let Ji, i ≤ n′, be the first job in S* that is not scheduled as early as possible and let t
                           1 be the first time that Ji
                            is not scheduled in S* but scheduled in S. That is, all the jobs with index less than i are scheduled in S* exactly the same as in S and job Ji
                            is scheduled in S* exactly the same as S before time t
                           1.

Consider all the jobs Jj
                           (j > i) scheduled at t
                           1 in S*. By Lemma 2, we have Cj
                           (S*) ≥ Ci
                           (S*). If there exists a time t′ and a job Jj
                            such that Jj
                            is scheduled at t
                           1 but not at t′ and Ji
                            is scheduled at t′, we can exchange Jj
                            at t
                           1 with Ji
                            at t′. The completion times of Ji
                            and Jj
                            are not increased and the completion times of other jobs are unchanged, so the total completion time is not increased, see Fig. 3
                           . So in the following, we assume t′ does not exist in S*; i.e. in S*, at any time after t
                           1, if Ji
                            is scheduled, then all the jobs Jj, j > i, that are scheduled at t
                           1 in S* must also be scheduled.

For the convenience, we define 
                              
                                 (
                                 
                                    J
                                    
                                       i
                                       1
                                    
                                 
                                 
                                    (
                                    
                                       t
                                       
                                          i
                                          1
                                       
                                    
                                    )
                                 
                                 ,
                                 
                                    J
                                    
                                       i
                                       2
                                    
                                 
                                 
                                    (
                                    
                                       t
                                       
                                          i
                                          2
                                       
                                    
                                    )
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    
                                       i
                                       p
                                    
                                 
                                 
                                    (
                                    
                                       t
                                       
                                          i
                                          p
                                       
                                    
                                    )
                                 
                                 )
                              
                            to be a “sequence” of a schedule, if we can reschedule 
                              
                                 
                                    J
                                    
                                       i
                                       k
                                    
                                 
                                 ,
                              
                            from 
                              
                                 t
                                 
                                    i
                                    k
                                 
                              
                            to 
                              
                                 t
                                 
                                    i
                                    
                                       k
                                       +
                                       1
                                    
                                 
                              
                            for 1 ≤ k ≤ p − 1 without increasing the total completion time of the schedule. And a sequence 
                              
                                 (
                                 
                                    J
                                    
                                       i
                                       1
                                    
                                 
                                 
                                    (
                                    
                                       t
                                       
                                          i
                                          1
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                           
                              
                                 
                                    J
                                    
                                       i
                                       2
                                    
                                 
                                 
                                    (
                                    
                                       t
                                       
                                          i
                                          2
                                       
                                    
                                    )
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    
                                       i
                                       p
                                    
                                 
                                 
                                    (
                                    
                                       t
                                       
                                          i
                                          p
                                       
                                    
                                    )
                                 
                                 
                                    )
                                 
                              
                            is an “exchange sequence” of a schedule if we can reschedule 
                              
                                 
                                    J
                                    
                                       i
                                       k
                                    
                                 
                                 ,
                              
                            from 
                              
                                 t
                                 
                                    i
                                    k
                                 
                              
                            to 
                              
                                 t
                                 
                                    i
                                    
                                       k
                                       +
                                       1
                                    
                                 
                              
                            (or 
                              
                                 t
                                 
                                    i
                                    1
                                 
                              
                            if k = p) without increasing the total completion time of the schedule. It is easy to see for this to be true, we must have 
                              
                                 
                                    J
                                    
                                       i
                                       k
                                    
                                 
                                 ,
                              
                            1 ≤ k ≤ p, is scheduled at 
                              
                                 
                                    t
                                    
                                       i
                                       k
                                    
                                 
                                 ,
                              
                            but not at 
                              
                                 t
                                 
                                    i
                                    
                                       k
                                       +
                                       1
                                    
                                 
                              
                            (or 
                              
                                 t
                                 
                                    i
                                    1
                                 
                              
                            if k = p).

Depending on the completion time of the jobs scheduled at t
                           1 in S*. we have the following two cases. We will show that in each case, there is an exchange sequence in S* so that we can reschedule Ji
                            at t
                           1 in S*.

                              Case 1
                              There exists a job Jj
                                  at t
                                 1, j > i, Cj
                                  ≠ T.

Let τ, Ci
                            ≤ τ ≤ Cj
                            be the first time after Ci
                            that Jj
                            is not scheduled. We must have that Jj
                            is continuously scheduled during the period [Ci
                            − 1, τ), and then is preempted at τ or finishes at τ if τ = Cj
                           . Then we must have that τ − (Ci
                            − 1) < pj
                            ≤ p
                           max  and thus m(τ) ≥ m(Ci
                            − 1) − 1. Since neither Ji
                            nor Jj
                            is scheduled at τ in S*, but both Ji
                            and Jj
                            are scheduled at Ci
                            − 1 in S*, there must exist a job Jl
                            (l > i) (or idle time/dummy job) which is scheduled at τ but not scheduled at Ci
                            − 1.

We can convert S* based on the exchange sequence (Jj
                           (t
                           1), Jl
                           (τ), Ji
                           (Ci
                            − 1)), see Fig. 4
                           . In this way, Ci
                            is decreased by at least 1, Cj
                            is increased by at most 1 and Cl
                            is not increased, all other jobs have same completion time as before, and the total completion time is not increased.

                              Case 2
                              For all jobs Jj
                                  at t
                                 1 such that j > i, we have Cj
                                  = T.

Since Ji
                            is scheduled at t
                           1 in S but not in S* and the number of available machines at t
                           1 is fixed, there must exists a job Jj
                            scheduled at t
                           1 in S* but not in S at time t
                           1. Since all the jobs Jj, j < i, have exactly the same schedule in S and S*, we must have j > i. Thus there must exist a time t
                           2 such that Jj
                            is not scheduled at t
                           2 in S* but is scheduled at t
                           2 in S. In return, there must exist a job Jk
                           , which is scheduled at t
                           2 in S* but not in S. Note that Jk
                            cannot be a dummy job representing a machine idle at t
                           2. Otherwise, we can follow the sequence (Jj
                           (t
                           1), Jk
                           (t
                           2), Ji
                           (Ci
                            − 1)) to move job Jj
                            out of t
                           1 and move Ji
                            from Ci
                            − 1 to t
                           1. The obtained schedule has smaller total completion time which is a contradiction. Also, k cannot be smaller than i because the schedule of these jobs are exactly the same in S and S*. So we must have k ≥ i. We can repeat the procedure until we find a job Jp
                            such that either Cp
                            < T or p = i. Since Ji
                            is scheduled at t
                           1 in S, but not in S*, there must exist a time that Ji
                            is scheduled in S* but not in S. And since the number of jobs and the makespan of the schedule is finite, we must be able to stop at some point. In this way, we get a sequence (Jj
                           (t
                           1), Jk
                           (t
                           2), …, Jp
                           (tp
                           )). Note that all the jobs except Jp
                            in this sequence must have completion time T in S*. If p = i, then we can follow the exchange sequence (Jj
                           (t
                           1), Jk
                           (t
                           2), …, Ji
                           (ti
                           )) to convert S* so that Ji
                            is scheduled at t
                           1 in S*. Otherwise, Cp
                            < T. If there exists a time ti
                            that Ji
                            is scheduled but Jp
                            is not scheduled, then we can have the exchange sequence (Jj
                           (t
                           1), Jk
                           (t
                           2), …, Jp
                           (tp
                           ), Ji
                           (ti
                           )) to convert S*. If there does not exist such time ti
                           , then at time Ci
                            − 1, both Ji
                            and Jp
                            are scheduled, let τ be the first time after Ci
                            − 1 such that Jp
                            is not scheduled. Then we have τ − (Ci
                            − 1) < pp
                            ≤ p
                           max , and thus m(τ) ≥ m(Ci
                            − 1) − 1. Since at time τ, both Ji
                            and Jp
                            are not scheduled, there must exist a job Jl
                            (l > i) which is scheduled at τ but not at Ci
                            − 1. We can follow the exchange sequence (Jj
                           (t
                           1), Jk
                           (t
                           2), …, Jp
                           (tp
                           ), Jl
                           (τ), Ji
                           (Ci
                            − 1)) to convert S* so that Ji
                            is scheduled at t
                           1 in S*, see Fig. 5
                           . In summary, we can always reschedule S* so that Ji
                            is scheduled at t
                           1 without increasing the total completion time.

By repeating the above process, we can always convert S* so that the schedule of the first n′ jobs in S* is exactly the same as that in S.

Note that the last n − n′ jobs complete exactly at T in S. And we have shown in the proof of Lemma 4, given the schedule of the first n′ jobs exactly the same as in S, the remaining jobs have to complete at T in any schedule. This means that S must be optimal.□

@&#CONCLUSIONS@&#

In this paper, we study the bi-criteria scheduling problem subject to the machine unavailability constraint: Pm(t)∣m(t + Δ) ≥ m(t) − 1, r − a, prmt∣∑Cj
                     /C
                     max  ≤ T for Δ < p
                     max . The number of machines can increase or decrease with the constraint that it cannot decrease by 2 within any period of p
                     max . This general unavailability model includes the special case that each machine has a release time after which the machine is always available; it also includes the special case where at any time there is at most one machine unavailable. We show that the problem is solvable in polynomial time by developing an optimal algorithm. Both the algorithm and the proofs are quite involved and subtle.

@&#REFERENCES@&#

