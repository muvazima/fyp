@&#MAIN-TITLE@&#The intelligent memory allocator selector

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Our solution is an intelligent memory allocator selector for operating systems.


                        
                        
                           
                           The solution selects an efficient and fastest memory allocator for each process.


                        
                        
                           
                           The approach reduces memory fragmentation, and increases system performance.


                        
                        
                           
                           Our solution is a dynamic and efficient solution to memory fragmentation problem.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Memory fragmentation

Memory allocator

Garbage collection

Virtual machine

@&#ABSTRACT@&#


               
               
                  Memory fragmentation is a serious obstacle preventing efficient memory usage. Garbage collectors may solve the problem; however, they cause serious performance impact, memory and energy consumption. Therefore, various memory allocators have been developed. Software developers must test memory allocators, and find an efficient one for their programs. Instead of this cumbersome method, we propose a novel approach for dynamically deciding the best memory allocator for every application. The proposed solution tests each process with various memory allocators. After the testing, it selects an efficient memory allocator according to condition of operating system (OS). If OS runs out of memory, then it selects the most memory efficient allocator for new processes. If most of the CPU power was occupied, then it selects the fastest allocator. Otherwise, the balanced allocator is selected. According to test results, the proposed solution offers up to 58% less fragmented memory, and 90% faster memory operations. In average of 107 processes, it offers 7.16±2.53% less fragmented memory, and 1.79±7.32% faster memory operations. The test results also prove the proposed approach is unbeatable by any memory allocator. In conclusion, the proposed method is a dynamic and efficient solution to the memory fragmentation problem.
               
            

@&#INTRODUCTION@&#

Memory fragmentation is a serious obstacle preventing efficient usage of memory. It appears in time while program is allocating and deallocating memory, shown in Fig. 1
                     . In the last situation of the figure, there are 9 blocks of free memory; however, even 4 blocks of memory cannot be allocated due to fragmentation.

Memory fragmentation can be split into two types: external and internal fragmentation. From operating system perspective, external fragmentation describes fragmentation between processes. Hence, internal fragmentation occurs inside of the processes.

In modern computers, external fragmentation was solved utilizing paging, detailed in Section 2.1 
                     [1–3]. Internal fragmentation was solved utilizing memory compaction of garbage collectors (Section 2.2). However, due to serious performance impact, memory and energy consumption [4–6], it is an inefficient solution. Even further, some garbage collectors do not support memory compaction; thus, they do not prevent memory fragmentation, such as Android KitKat and predecessors [7]. Therefore, internal fragmentation is still a challenging problem in this area.

For avoiding disadvantages of garbage collectors, memory allocators were developed for general purpose [8–12], multi-threaded processes [13], network applications [14], object oriented programming languages [15,16], video-on-demand servers [17], etc.

Modern operating systems assign a default memory allocator to every process. If this memory allocator was insufficient for the application then software developers should determine and add the most efficient and fastest memory management algorithm for their applications [18]. However, if the developer had no knowledge about memory allocators then the application would lose performance and memory. Instead of forcing developer to select a memory allocator, operating system should determine memory management algorithm for each process to accomplish the best performance and efficiency.

In this work, we propose an intelligent memory allocator selector (IMAS) that dynamically decides the best memory allocator for each process. The IMAS tests each process separately with various memory allocators. After the testing, it selects an efficient memory allocator. It also adopts to the operating system (OS) conditions. If OS runs out of memory then the IMAS selects the most memory efficient memory allocator for new processes. If processes consume most of the CPU power then it selects the fastest memory allocator. Otherwise, the balanced memory allocator is selected.

The IMAS has a test system, which logs CPU performance values and memory fragmentation ratios. These test results are used to select efficient memory allocator for processes. Therefore, they can be used for comparison between memory allocators and the IMAS. Tests have been done in a regular personal computer during its daily activity. 107 processes have been fully tested during our tests. According to test results, the IMAS provides up to 58% less fragmented memory than default memory allocator of OS. In average of 107 processes, the IMAS is 7.16±2.53% memory efficient. For CPU performance, the IMAS is up to 90% faster; and in average, it is 1.79±7.32% faster.

Test results prove our claims, the IMAS minimizes memory fragmentation by selecting an efficient memory allocator for each process. Therefore, memory management is done in faster and more efficient way.

The rest of the paper is organized as follows: Section 2 recalls the previous works. Section 3 presents details of the proposed solution. Section 4 gives the test results and discussion. Finally, Section 5 concludes the paper.

In modern computers, processes live in virtual address space, which is isolated from real address space [1]. In virtual address space, process thinks that it has all of the memory (except kernel memory), shown in Fig. 2
                        .

The memory address in virtual address space, called logical address, translated to real address utilizing memory management unit (MMU), shown in Fig. 3
                        . MMU uses segmentation and paging to translate logical address to physical address.

Paging unit splits whole memory into the pages, shown in Fig. 4
                         
                        [1–3]. It maps only occupied pages into the physical memory. In physical memory, each page can be in different places and different order. Therefore, external memory fragmentation does not occur.

Garbage collection (GC) is an automatic memory management system [19]. By the aid of GC, allocated memory areas do not need to be deallocated by the developer. GC does the deallocation automatically.

In unmanaged programming languages (C, C++, Pascal etc.), memory pointers are volatile and GC cannot change them. However, in managed programming languages (Java, C# etc.), virtual machine (VM) manages the memory operations; therefore, pointers can be changed easily [20,21]. Utilizing GC and VM, memory fragmentation can be prevented by compacting memory regions, shown in Fig. 5
                         
                        [22].

However, GC and VM operations cause serious performance penalties. In the first place, managed language code is not compiled into machine code. Instead, it is compiled into intermediate code [23]. The intermediate code is compiled into machine code during execution of the program. This compilation operation costs memory, CPU power, and energy consumption [4]. Furthermore, programs using GC run 70% slower when two times more memory supplied [5]. The programs need three times more memory for running 17% slower. Also, GC operations consume up to 40 times more energy than explicit memory allocators [6].

In conclusion, GC and VM may prevent memory fragmentation; however, this returns as significant performance impact, memory and energy consumption. Therefore, this solution cannot be considered as an efficient method for memory fragmentation.

The intelligent memory allocator selector (IMAS) has been developed under 32-bit Ubuntu Linux (version 12.04) OS. It is selected because of being open source and more suitable for developing system applications than Windows. Furthermore, it is prevalent server and embedded system OS; therefore, most servers and embedded systems will take advantage of the IMAS.

The purpose of the IMAS is choosing a decent memory allocator for each process. Therefore, it has a collection of memory allocators for testing with every process. Some of the essential memory allocators are selected into the collection for testing the IMAS. These memory allocators are the default memory allocator of the OS, hoard, thread-caching malloc (TCMalloc), and jemalloc. Hoard was developed for parallel running applications [13]. Google has been developing TCMalloc and using for Chrome internet browser [10]. Firefox and facebook have been using jemalloc for firefox browser and facebook server applications, respectively [24,11].

These allocators are tested for memory operation performance and memory fragmentation. When all memory allocators were tested, the IMAS categorizes the fastest, the most memory efficient and the balanced libraries for the process. The fastest library is the least time consuming library during memory operations. The most memory efficient library is the library with minimum memory fragmentation. The balanced library is the fastest and also the most memory efficient one. According to the OS conditions, the IMAS uses the appropriate library. When average CPU load was greater than or equal to 75%, the IMAS chooses the fastest library for new process. If available memory of the system is lower than average memory usage of the process then the most memory efficient library is loaded. For other situations, the IMAS loads the balanced library. Therefore, according to the system load, the IMAS selects the best memory allocator for the processes.

The IMAS needs to replace memory allocator of processes for loading appropriate memory allocator. Therefore, it hooks memory allocation functions, which are malloc, calloc, realloc, memalign, posix_memalign, valloc, pvalloc, free, mallopt, malloc_usable_size, cfree. Also, pthread_create and pthread_exit functions need to be hooked due to some memory allocators do some operations before creation and destruction of threads. The functions are briefly explained in Table 1
                        .

The imas.so is a shared object (dynamic link library), responsible part of the IMAS for hooking. It injects itself into every process utilizing possibilities of Linux OS [25]. Therefore, it is loaded before every other library, and its functions are loaded before the default memory allocator of the process. Thus, the IMAS hooks memory functions.
                           Algorithm 1
                           The imas.so initialization. 
                                 
                                    
                                       
                                       
                                          
                                             1:
                                                if 
                                                
                                                   is
                                                   _
                                                   process
                                                   _
                                                   excluded
                                                   (
                                                   )
                                                 
                                                then
                                             
                                          
                                          
                                             2:
                                                load_malloc_library(system_library);
                                          
                                          
                                             3:
                                                return;
                                          
                                          
                                             4:
                                                end if
                                             
                                          
                                          
                                             5:
                                             
                                          
                                          
                                             6:perf_res=load_performance_results();
                                          
                                          
                                             7:/⁎ Average memory used by the fastest library ⁎/
                                          
                                          
                                             8:avg_mem[0]=perf_res.summary[perf_res.result[0]].avg_mem;
                                          
                                          
                                             9:/⁎ Average memory used by the most memory efficient library ⁎/
                                          
                                          
                                             10:avg_mem[1]=perf_res.summary[perf_res.result[1]].avg_mem;
                                          
                                          
                                             11:cpu_load=get_cpu_load();
                                          
                                          
                                             12:free_ram=get_free_ram();
                                          
                                          
                                             13:
                                             
                                          
                                          
                                             14:
                                                if 
                                                
                                                   perf
                                                   _
                                                   res
                                                   .
                                                   test
                                                   _
                                                   mode
                                                 
                                                then
                                             
                                          
                                          
                                             15:
                                                malloc_library=perf_res.next_library;
                                          
                                          
                                             16:
                                                else if 
                                                
                                                   cpu
                                                   _
                                                   load
                                                   ≥
                                                   75
                                                 
                                                and 
                                                
                                                   free
                                                   _
                                                   ram
                                                   ≥
                                                   avg
                                                   _
                                                   mem
                                                   [
                                                   0
                                                   ]
                                                 
                                                then
                                             
                                          
                                          
                                             17:
                                                malloc_library=perf_res.result[0];
                                          
                                          
                                             18:
                                                else if 
                                                
                                                   cpu
                                                   _
                                                   load
                                                   <
                                                   75
                                                 
                                                and 
                                                
                                                   free
                                                   _
                                                   ram
                                                   <
                                                   avg
                                                   _
                                                   mem
                                                   [
                                                   1
                                                   ]
                                                 
                                                then
                                             
                                          
                                          
                                             19:
                                                malloc_library=perf_res.result[1];
                                          
                                          
                                             20:
                                                else
                                             
                                          
                                          
                                             21:
                                                malloc_library=perf_res.result[2];
                                          
                                          
                                             22:
                                                end if
                                             
                                          
                                          
                                             23:load_malloc_library(malloc_library);
                                          
                                          
                                             24:
                                             
                                          
                                          
                                             25:
                                                if 
                                                
                                                   perf
                                                   _
                                                   res
                                                   .
                                                   test
                                                   _
                                                   mode
                                                 
                                                then
                                             
                                          
                                          
                                             26:
                                                imas_perf_init();
                                          
                                          
                                             27:
                                                imas_perf_test_mode=perf_res.test_mode;
                                          
                                          
                                             28:
                                                end if
                                             
                                          
                                       
                                    
                                 
                              
                           

When the imas.so loaded with the process, it does initialization, shown in Algorithm 1. It checks if the process is excluded by the IMAS. Some programs are not compatible with some memory allocators; therefore, a function has been implemented for excluding these programs. If the process is excluded, it loads system memory allocator and exits from initialization. Otherwise, previously saved performance results are loaded. Afterwards, five-minute CPU load and free memory of the system are retrieved. According to CPU load and available memory size, the IMAS loads appropriate memory allocator for the process. If the system is overloaded and there is enough memory for the process, the IMAS loads the fastest memory allocator for the process, shown at lines 16–17 in Algorithm 1. However, if the system is not overloaded and there is not enough memory to run the process; the IMAS loads the most memory efficient library, shown at lines 18–19. In other cases, the IMAS loads the balanced memory allocator for the process. If the IMAS is in test mode, it loads next library for testing, shown at lines 14–15, and initializes the test mode, shown at line 25.
                           Algorithm 2
                           Hooked malloc function of the imas.so. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Size (size) of the will be allocated memory area
                                          
                                          
                                             Ensure: Pointer (p) of the allocated memory area
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:PERF_TYPE(TYPE_MALLOC);
                                          
                                          
                                             2:PERF_BEGIN(NULL);
                                          
                                          
                                             3:p=imas_malloc(size);
                                          
                                          
                                             4:PERF_END(p);
                                          
                                       
                                    
                                 
                              
                           

Hooked realloc function of the imas.so. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Previous memory area pointer (ptr), and size (size) of the new memory area
                                          
                                          
                                             Ensure: Pointer (p) of the reallocated memory area
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:PERF_TYPE(TYPE_REALLOC);
                                          
                                          
                                             2:PERF_BEGIN(ptr);
                                          
                                          
                                             3:p=imas_realloc(ptr, size);
                                          
                                          
                                             4:PERF_END(p);
                                          
                                       
                                    
                                 
                              
                           

Hooked memalign function of the imas.so. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Alignment value (alignment), and size (size) of the will be allocated memory area
                                          
                                          
                                             Ensure: Pointer (p) of the allocated memory area
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:PERF_TYPE(TYPE_MEMALIGN);
                                          
                                          
                                             2:PERF_BEGIN(NULL);
                                          
                                          
                                             3:p=imas_memalign(alignment, size);
                                          
                                          
                                             4:PERF_END(p);
                                          
                                       
                                    
                                 
                              
                           

Hooked free function of the imas.so. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Pointer (ptr) of the memory area
                                          
                                          
                                             Ensure: Frees the memory area
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:PERF_TYPE(TYPE_FREE);
                                          
                                          
                                             2:PERF_BEGIN(ptr);
                                          
                                          
                                             3:imas_free(ptr);
                                          
                                          
                                             4:PERF_END(NULL);
                                          
                                       
                                    
                                 
                              
                           

PERF_BEGIN macro. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Pointer (ptr) of the preallocated memory area
                                          
                                          
                                             Ensure: Gets and stores preliminary performance values
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:
                                                if 
                                                
                                                   imas
                                                   _
                                                   perf
                                                   _
                                                   test
                                                   _
                                                   mode
                                                 
                                                then
                                             
                                          
                                          
                                             2:
                                                
                                                if 
                                                
                                                   ptr
                                                   ≠
                                                   NULL
                                                 
                                                then
                                             
                                          
                                          
                                             3:
                                                allocated_size[0]=imas_malloc_usable_size(ptr);
                                          
                                          
                                             4:
                                                
                                                end if
                                             
                                          
                                          
                                             5:
                                                
                                             
                                          
                                          
                                             6:
                                                start=get_time();
                                          
                                          
                                             7:
                                                end if
                                             
                                          
                                       
                                    
                                 
                              
                           

PERF_END macro. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Pointer (ptr) of the allocated memory area
                                          
                                          
                                             Ensure: Calculates performance values and writes them into the log file
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:
                                                if 
                                                
                                                   imas
                                                   _
                                                   perf
                                                   _
                                                   test
                                                   _
                                                   mode
                                                 
                                                then
                                             
                                          
                                          
                                             2:
                                                end=get_time();
                                          
                                          
                                             3:
                                                
                                             
                                          
                                          
                                             4:
                                                
                                                if 
                                                ptr=NULL 
                                                and 
                                                
                                                   type
                                                   =
                                                   TYPE
                                                   _
                                                   REALLOC
                                                 
                                                then
                                             
                                          
                                          
                                             5:
                                                
                                                allocated_size[0]=0;
                                          
                                          
                                             6:
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             7:
                                             
                                          
                                          
                                             8:
                                                
                                                if 
                                                
                                                   ptr
                                                   ≠
                                                   NULL
                                                 
                                                then
                                             
                                          
                                          
                                             9:
                                                
                                                allocated_size[1]=imas_malloc_usable_size(ptr);
                                          
                                          
                                             10:
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             11:
                                                
                                             
                                          
                                          
                                             12:
                                                time_diff=end - start;
                                          
                                          
                                             13:
                                                allocated_memory_size=allocated_size[1] - allocated_size[0];
                                          
                                          
                                             14:
                                                write_to_log(type, time_diff, allocated_memory_size);
                                          
                                          
                                             15:
                                                end if
                                             
                                          
                                       
                                    
                                 
                              
                           

If performance test mode is enabled, the imas.so tests the malloc, realloc, memalign, and free functions from the aspects of performance and memory fragmentation. Because of other hooked functions (except thread functions) call these functions, it is enough doing tests for only the functions.

Algorithms of the functions are given in Algorithms 2–5. As seen in the algorithms, PERF_ macros are doing the performance tests, given in Algorithms 6 and 7. C macros were used for avoiding function calls and better performance measurement. For better understanding, think macros as functions, and their source codes are printed directly in where they are used.


                        PERF_TYPE macro defines the test type, which will be used by other macros for categorizing tests. PERF_BEGIN stores the preallocated memory area size, and gets the system time, given in Algorithm 6. After the memory operation, PERF_END gets the system time and calculates the passed time during the operation, shown at lines 2–12 in Algorithm 7. It calculates allocated memory size for calculating memory fragmentation later, shown at line 13. Finally, it logs results by using another thread for avoiding performance impact on memory operations during tests. The thread runs in every 5s, and writes average performance results, allocated memory size, and processes heap size into the log file.

The heap size is fetched from the OS by using virtual memory map of the process [26]. For example, abbreviated virtual memory map of gnome calculator is given in Fig. 6
                        . Some rows have been omitted due to space limits. In the map, heap memory can be clearly seen, and its size can be calculated by subtracting end address from start address. However, some memory allocators do not show the heap memory like this. So, the heap size is calculated by using other memory areas, whose path names are either nothing or [heap]. Also, these areas should be readable and writable private areas (rw-p). Later, the heap size will be compared with the allocated memory size for calculating the memory fragmentation.
                           Algorithm 8
                           
                              Process logs function of the imasd. 
                              
                                 
                                    
                                       
                                       
                                          
                                             Require: Path (path) of the will be processed log file
                                          
                                          
                                             Ensure: Processes the log file and updates the performance results for regarding process
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             1:file=open(path);
                                          
                                          
                                             2:process_path=read_string(file);
                                          
                                          
                                             3:malloc_library=read_integer(file);
                                          
                                          
                                             4:perf=read_perf(file);
                                          
                                          
                                             5:perf_avg=average_perf(perf);
                                          
                                          
                                             6:count=malloc_mem=heap_mem=0;
                                          
                                          
                                             7:
                                             
                                          
                                          
                                             8:
                                                while 
                                                not EOF(file) do
                                             
                                          
                                          
                                             9:
                                                mem=read_integer(file);
                                          
                                          
                                             10:
                                                malloc_mem=average(malloc_mem, mem, count);
                                          
                                          
                                             11:
                                                mem=read_integer(file);
                                          
                                          
                                             12:
                                                heap_mem=average(heap_mem, mem, count);
                                          
                                          
                                             13:
                                                count=count + 1;
                                          
                                          
                                             14:
                                                
                                                end while
                                             
                                          
                                          
                                             15:
                                                
                                             
                                          
                                          
                                             16:
                                                close(file);
                                          
                                          
                                             17:
                                                delete(path);
                                          
                                          
                                             18:
                                                
                                             
                                          
                                          
                                             19:
                                                perf_res=load_performance_results(process_path);
                                          
                                          
                                             20:
                                                smr=perf_res.summary[malloc_library];
                                          
                                          
                                             21:
                                                time=get_time();
                                          
                                          
                                             22:
                                                
                                             
                                          
                                          
                                             23:
                                                
                                                if 
                                                
                                                   smr
                                                   .
                                                   count
                                                   <
                                                   MAX
                                                   _
                                                   TEST
                                                   _
                                                   AMOUNT
                                                 
                                                then
                                             
                                          
                                          
                                             24:
                                                
                                                
                                                if 
                                                
                                                   time
                                                   −
                                                   smr
                                                   .
                                                   time
                                                   ≥
                                                   MIN
                                                   _
                                                   TIME
                                                   _
                                                   TO
                                                   _
                                                   RETEST
                                                 
                                                then
                                             
                                          
                                          
                                             25:
                                                
                                                smr.sec=average(smr.sec, perf_avg.sec, smr.count);
                                          
                                          
                                             26:
                                                
                                                mem_frag=(heap_mem - malloc_mem) / heap_mem;
                                          
                                          
                                             27:
                                                
                                                smr.mem_frag=average(smr.mem_frag, mem_frag, smr.count);
                                          
                                          
                                             28:
                                                
                                                smr.avg_mem=average(smr.avg_mem, heap_mem, smr.count);
                                          
                                          
                                             29:
                                                
                                                smr.count=smr.count + 1;
                                          
                                          
                                             30:
                                                
                                                smr.time=time;
                                          
                                          
                                             31:
                                                
                                                perf_res=analyze(perf_res);
                                          
                                          
                                             32:
                                                
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             33:
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             34:
                                                
                                             
                                          
                                          
                                             35:
                                                perf_res=select_next_test_library(perf_res, malloc_library);
                                          
                                          
                                             36:
                                                save_performance_results(process_path, perf_res);
                                          
                                       
                                    
                                 
                              
                           

The logs saved by the imas.so are processed by the IMAS Daemon (imasd). The imasd is a daemon process, which always runs. It is the brain of the IMAS. It processes the test logs, and determines the fastest, the most memory efficient, and the balanced libraries. Also, it decides the test mode, and chooses the next test library for each process.

Main function of the imasd scans test logs directory in every 5s, and sends unprocessed logs to the process logs function, given in Algorithm 8. The function opens the log file, and reads the process path, tested memory allocator library, and CPU performance values, shown at lines 1–4. Then, it averages the CPU performance values. The rest of the log file consists of memory allocator and heap memory sizes. The function reads sizes, and calculates averages by using average function. Afterwards, it closes and deletes the log file.

The average function is generally implemented like Eq. (1). However, huge memory sizes can easily lead to integer overflow and miscalculation of the average. Therefore, the approach shown in Eq. (2) is used for average calculation.
                           
                              (1)
                              
                                 average
                                 ←
                                 
                                    
                                       (
                                       
                                          average
                                          ⁎
                                          count
                                       
                                       )
                                       +
                                       addition
                                    
                                    
                                       count
                                       +
                                       1
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 average
                                 ←
                                 average
                                 ⁎
                                 (
                                 
                                    
                                       
                                          count
                                       
                                       
                                          count
                                          +
                                          1
                                       
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       addition
                                    
                                    
                                       count
                                       +
                                       1
                                    
                                 
                              
                           
                        
                     

The function loads previously saved performance results, shown at line 18 in Algorithm 8. The results holds performance summary for each memory allocator library. The summary consists of the last test time, test count, and averages of CPU performance value, memory fragmentation ratio, heap size. It also holds test mode, the next test library, and the fastest, the most memory efficient, the balanced memory allocator libraries.

If test count of the memory allocator library is less than maximum test amount, and time passed after the last test time is greater then minimum time for retesting then the log file is processed, shown at lines 23–33 in Algorithm 8. The function calculates the averages of CPU performance value, memory fragmentation ratio, heap memory size by adding values from the log file.
                           
                              (3)
                              
                                 
                                    
                                       heap
                                       _
                                       memory
                                       −
                                       malloc
                                       _
                                       memory
                                    
                                    
                                       heap
                                       _
                                       memory
                                    
                                 
                              
                           
                        
                     

Memory fragmentation is calculated by using Eq. (3). The malloc_memory variable holds the size of the memory without any blank area. However, the heap_memory variable holds the heap size of the process, which contains blank (wasted) memory areas. These areas are generally caused by memory fragmentation. Thus, the equation calculates the wasted memory percentage, which may also mean memory fragmentation percentage.
                           Algorithm 9
                           
                              analyze function of the imasd. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Performance results (perf_res) that will be analyzed
                                          
                                          
                                             Ensure: Selects the fastest (perf_res.result[0]), the most memory efficient (perf_res.result[1]), and the balanced (perf_res.result[2]) memory allocator libraries
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:sorted_libs_fastest=sort_desc_by_perf(perf_res);
                                          
                                          
                                             2:sorted_libs_mem_eff=sort_desc_by_mem_frag(perf_res);
                                          
                                          
                                             3:perf_res.result[0]=sorted_libs_fastest[MALLOC_LIB_END];
                                          
                                          
                                             4:perf_res.result[1]=sorted_libs_mem_eff[MALLOC_LIB_END];
                                          
                                          
                                             5:
                                             
                                          
                                          
                                             6:perf_res.result[2]=0;
                                          
                                          
                                             7:
                                                for i=0 to MALLOC_LIB_END do
                                             
                                          
                                          
                                             8:
                                                
                                                for j=0 to MALLOC_LIB_END do
                                             
                                          
                                          
                                             9:
                                                
                                                if 
                                                
                                                   i
                                                   =
                                                   sorted
                                                   _
                                                   libs
                                                   _
                                                   fastest
                                                   [
                                                   j
                                                   ]
                                                 
                                                then
                                             
                                          
                                          
                                             10:
                                                
                                                ranked_libs_fastest[i]=j + 1;
                                          
                                          
                                             11:
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             12:
                                                
                                                
                                                
                                                
                                                
                                                
                                                if 
                                                
                                                   i
                                                   =
                                                   sorted
                                                   _
                                                   libs
                                                   _
                                                   mem
                                                   _
                                                   eff
                                                   [
                                                   j
                                                   ]
                                                 
                                                then
                                             
                                          
                                          
                                             13:
                                                
                                                ranked_libs_mem_eff[i]=j + 1;
                                          
                                          
                                             14:
                                                
                                                
                                                
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             15:
                                                
                                                
                                                end for
                                             
                                          
                                          
                                             16:
                                             
                                          
                                          
                                             17:
                                                
                                                
                                                
                                                x=ranked_libs_fastest[perf_res.result[2]];
                                          
                                          
                                             18:
                                                
                                                
                                                
                                                
                                                   x
                                                   =
                                                   x
                                                 + ranked_libs_mem_eff[perf_res.result[2]];
                                          
                                          
                                             19:
                                                
                                                
                                                
                                                
                                                   y
                                                =ranked_libs_fastest[i] + ranked_libs_mem_eff[i];
                                          
                                          
                                             20:
                                             
                                          
                                          
                                             21:
                                                
                                                
                                                
                                                if 
                                                
                                                   y
                                                   >
                                                   x
                                                 
                                                then
                                             
                                          
                                          
                                             22:
                                                perf_res.result[2]=i;
                                          
                                          
                                             23:
                                                
                                                else if 
                                                y=x 
                                                then
                                             
                                          
                                          
                                             24:
                                                
                                                if 
                                                
                                                   ranked
                                                   _
                                                   libs
                                                   _
                                                   mem
                                                   _
                                                   eff
                                                   [
                                                   i
                                                   ]
                                                   >
                                                   ranked
                                                   _
                                                   libs
                                                   _
                                                   mem
                                                   _
                                                   eff
                                                   [
                                                   perf
                                                   _
                                                   res
                                                   .
                                                   result
                                                   [
                                                   2
                                                   ]
                                                   ]
                                                 
                                                then
                                             
                                          
                                          
                                             25:
                                                
                                                perf_res.result[2]=i;
                                          
                                          
                                             26:
                                                
                                                end if
                                             
                                          
                                          
                                             27:
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             28:
                                                end for
                                             
                                          
                                       
                                    
                                 
                              
                           

The function analyzes the performance results utilizing the analyze function, given in Algorithm 9. The analyze function selects the fastest, the most memory efficient, and the balanced libraries. It sorts the libraries by CPU performance and memory fragmentation, shown at lines 1–2 in Algorithm 9. It sorts in descending order; therefore, the last elements of the arrays are the fastest, and the most memory efficient libraries. Also, the array index shows rankings of the libraries. The balanced library is determined utilizing the rankings, calculated at lines 8–15 in Algorithm 9. The most ranked library is the balanced library, given at lines 17–22. However, sometimes ranks can be equal. In this situation, the more memory efficient library is selected, given at lines 23–26.
                           Algorithm 10
                           
                              imasd function for selecting the next test library. 
                                 
                                    
                                       
                                       
                                          
                                             Require: Performance results (perf_res) and the last tested memory allocator library (malloc_library)
                                          
                                          
                                             Ensure: Determines the next test library (perf_res.next_library)
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                          
                                          
                                             1:perf_res.test_mode=false;
                                          
                                          
                                             2:
                                                for i=0 to MALLOC_LIB_END do
                                             
                                          
                                          
                                             3:
                                                malloc_library=(malloc_library + 1) for % (MALLOC_LIB_END + 1);
                                          
                                          
                                             4:
                                                smr=perf_res.summary[malloc_library];
                                          
                                          
                                             5:
                                                
                                                if 
                                                
                                                   smr
                                                   .
                                                   count
                                                   <
                                                   MAX
                                                   _
                                                   TEST
                                                   _
                                                   AMOUNT
                                                 
                                                then
                                             
                                          
                                          
                                             6:
                                                
                                                if 
                                                
                                                   time
                                                   −
                                                   smr
                                                   .
                                                   time
                                                   ≥
                                                   MIN
                                                   _
                                                   TIME
                                                   _
                                                   TO
                                                   _
                                                   RETEST
                                                 
                                                then
                                             
                                          
                                          
                                             7:
                                                perf_res.next_library=malloc_library;
                                          
                                          
                                             8:
                                                perf_res.test_mode=true;
                                          
                                          
                                             9:
                                                return;
                                          
                                          
                                             10:
                                                
                                                end if
                                             
                                          
                                          
                                             11:
                                                
                                                end if
                                             
                                          
                                          
                                             12:
                                                end for
                                             
                                          
                                       
                                    
                                 
                              
                           

Finally, the process logs function selects the next test library, given in Algorithm 10, and saves performance results. The selection of the next test library starts from the last tested memory allocator library. If there is a memory allocator library that fulfils the requirements then it is selected; otherwise, the test mode is disabled.

@&#RESULTS AND DISCUSSION@&#

The imas.so already does tests for memory allocators. After the testing, the imasd calculates memory fragmentation, averages of CPU performance values and heap size. These values have been used to analyze the performance and memory gains of the IMAS.

Tests have been done on a regular PC, which has 1.8GHZ 2-core CPU and 2GB RAM, during its daily usage. Ubuntu 14.04 linux distribution has been used as test OS. Five tests have been done for each memory allocator. After the 50-day test period, 200 processes have been caught by the IMAS; and 107 processes have been completed all of five tests. The test results for selected processes are given in Tables 2 and 3
                     
                     .

In the results, CPU performance values, given as nanoseconds, indicate average time passed during execution of malloc, realloc, memalign, and free functions. Memory fragmentation ratios, calculated using Eq. (3), are given as percentages. Heap memory sizes, used in the equation, are given as megabytes. The balanced, the fastest, and the most memory efficient libraries for each process are emphasized in Memory Allocator, CPU Performance, and Memory Fragmentation columns, respectively.

As can be seen in Table 2, even init process, ancestor of all processes, needs a better memory allocator. Although, comparing processes using heap sizes causes ambiguous results; sometimes it can be enlightening. Such as AptanaStudio3, which is a Java program, is optimized with the IMAS. Due to high memory requirements of the process, 1-percent less fragmented heap may save 33 megabytes, shown in Table 3.

These results set gives a narrow perspective. Therefore, Fig. 7
                      represents the ratios of the fastest, the most memory efficient, and the balanced memory allocators for 107 processes. According to the fastest memory allocators, it can be said there is no winner for this category. They are almost evenly distributed among the processes. On the other hand, it is hard to mention harmony like this for the other categories. The most memory efficient and the balanced classifications are dominated by the Hoard and System memory allocators. According to these results, TCMalloc and jemalloc libraries are insufficient to compete with others. However, under other circumstances, they may perform better.

What would happen if default memory allocator of the OS was another memory allocator? Could the IMAS perform better? For this challenge, each memory allocator was assigned to all processes. Only one memory allocator was assigned and tested at a time. Therefore, default memory allocator replacement was simulated. The results are given in Fig. 8
                     . The left chart shows the average CPU gains, and the right one shows the average memory fragmentation gains per process. The balanced memory allocator is used for the IMAS results. Even if the default memory allocator was replaced, all results are against default memory allocator for better comparison.

According to CPU results, all memory allocators have significantly failed. However, the IMAS have gained tremendous results against the others. The IMAS gains are trivial against system allocator, due to the balanced algorithm gives priority to memory efficiency rather than CPU performance. For details, the IMAS CPU gains are given in Fig. 9
                     .

According to memory fragmentation results, other memory allocators except Hoard have been failed significantly again. The IMAS is also 23% better than the most efficient allocator in the chart, Hoard. The gap between the Hoard and the IMAS results is close because of the inefficacy of other memory allocators, shown in Fig. 7. The dominance of the balanced classification is shared between the Hoard and System allocators. However, if other memory allocators were gained significant results in balanced classification then the gap would be widened. Even in this situation, when CPU and memory fragmentation results were evaluated together, the results of the IMAS are unmatchable.

The average results are good for general comparison; however, they are insufficient for evaluating close results. For better comparison between the IMAS and Hoard, the results of each process are given in Figs. 10 and 11
                     
                     . The results are given in descending order; hence, the process numbers given in X-axis are irrelevant between charts. The charts also prove the superiority of the IMAS.

@&#CONCLUSIONS@&#

Existing operating systems assign a predetermined (default) memory allocator to all processes. Default memory allocator cannot be sufficient for all processes. It may work good for some; however other processes may need another memory allocator. When the default memory allocator failed for a process, it leads to memory fragmentation and performance loss. For fixing this problem, each software developer has to search, test, and evaluate memory allocators for finding an efficient memory allocator. If developer does not know about memory allocators then the program will be left in the hands of operating system, and suffer.

The purpose of this study is developing a novel memory management system for making operating systems more intelligent to select an efficient memory allocator for each process. Even for different OS conditions, like excessive memory or CPU usage, the IMAS selects the appropriate memory allocator. Therefore, the proposed solution makes applications and OS more efficient on both memory and CPU usage.

Applications should be improved constantly; and bugs should be eliminated. For speedy improvements and increasing the usage of the IMAS, our future work will be distributing the IMAS as open source through the author׳s GitHub repository [27]. Also, new memory allocators will be added for better selection process. In order to identify unnecessary memory allocators, online statistics collection feature will also be developed.

System applications are hard to develop and maintain. Linux OS gives opportunities like hooking memory allocation functions, and helps to development process. However, Windows OS does not give opportunities like this, and it is much harder to port IMAS to Windows platform. For the future work, this porting operation may be done.

@&#REFERENCES@&#

