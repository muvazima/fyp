@&#MAIN-TITLE@&#PARP-S: A secure piggybacking-based ARP for IEEE 802.11s-based Smart Grid AMI networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We identify ARP broadcast problem in 802.11s.


                        
                        
                           
                           We propose a secure piggybacking-based ARP for 802.11s-based Smart Grid networks.


                        
                        
                           
                           We propose several modifications to Hybrid Wireless Mesh Protocol (HWMP).


                        
                        
                           
                           Piggybacking-based ARP reduces the end to end delay significantly.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Smart Grid AMI

IEEE 802.11s-based Neighborhood Area Network

Secure address resolution protocol

ARP piggybacking

Elliptic curve digital signature algorithm

@&#ABSTRACT@&#


               
               
                  The Smart Grid is expected to utilize a wireless infrastructure for power data collection in its Advanced Metering Infrastructure (AMI) applications. One of the options to implement such a network infrastructure is to use a wireless mesh network based on IEEE 802.11s mesh standard. However, IEEE 802.11s standard relies on MAC-based routing and thus requires the availability of MAC addresses of destinations. Due to large size of AMI networks, this creates a broadcast storm problem when such information is to be obtained via Address Resolution Protocol (ARP) broadcast packets. In this paper, we propose a mechanism to significantly alleviate such broadcast storm problem in order to improve the scalability of 802.11s and thus make it better suited for Smart Grid AMI applications. Our contribution is adapting 802.11s standard for addressing ARP broadcast storm problem in a secure and efficient manner. Specifically, we utilize the proactive Path Request (PREQ) packet and Path Reply (PREP) of layer-2 path discovery protocol of 802.11s, namely HWMP, for piggybacking ARP information. In this way, the MAC address resolution is handled during routing tree creation/maintenance and hence the broadcasting of ARP requests by the smart meters (SMs) to learn the MAC address of the data collector (i.e., the gateway/root node) is completely eliminated. Furthermore, since piggybacking the ARP via PREQ may pose vulnerabilities for possible ARP cache poisoning attacks, the data collector also authenticates the messages it sends to SMs by using Elliptic Curve Digital Signature Algorithm (ECDSA). We have extensively analyzed the behavior and overhead of the proposed mechanism using implementation of IEEE 802.11s in ns-3 simulator. The evaluations for both UDP and TCP show that compared to the original ARP broadcast operations, our approach reduces the end-to-end delay significantly without negatively impacting the packet delivery ratio and throughput.
               
            

@&#INTRODUCTION@&#

The upcoming Smart Grid is envisioned to use communication networks for two-way flow of data that will be generated from several new applications [1]. Some of these applications include Advanced Metering Infrastructure (AMI), Demand Response (DR), Wide Area Situational Awareness, Distributed Generation, etc. These applications will run on different components of Smart Grid communication network including Neighborhood Area Networks, Home Area Network and Wide Area Networks [2]. For each of these network components, various underlying infrastructure alternatives and standards based on wireless, fiber, powerlines, etc. are being considered for development [2].

IEEE 802.11s-based Wireless Mesh Networks is one of the underlying data communication networks touted for Neighborhood Area Network applications [1]. One of the components of the upcoming Smart Grid is the AMI which is envisioned to be run on a Neighborhood Area Network. Specifically, each SM will be equipped with a 802.11 radio device and use the Neighborhood Area Network to send their power readings to a gateway node which can further relay them to the utility company for billing and analysis. In this way, the customer power network will be divided into clusters each is headed by a gateway node. Obviously, there may be advantages and disadvantages of this solution compared to other options such as using 4G, WiMax or powerline communications. We would like to note that the goal of this paper is not to compare these communication options as such works already exist [3]. We only mention that using a Wireless Mesh Network based solution has its advantages and there are a lot of utility companies adopting this solution so far [4].

Creation of Smart Grid AMI Wireless Mesh Networks pose some challenges since such networks will be far larger than the traditional small-scale Wireless Mesh Networks and expected to carry a heavier traffic and two-way traffic (e.g., due to DR and control messages from the utility [5]). Since large-scale real-life deployment of Wireless Mesh Networks and performance issues with increased network diameter has not been well investigated [6], more research is needed to adapt IEEE 802.11s protocol for Smart Grid Neighborhood Area Networks applications given that the standard has just been released and its real-life deployments are limited.

One of such issues that need attention is the overhead of Address Resolution Protocol (ARP) broadcasts in large scale networks. The IEEE 802.11s standard operates at the Media Access Control (MAC) layer and uses Hybrid Wireless Routing Protocol (HWMP) as its default routing protocol to find a multi-hop path towards the destination. HWMP uses MAC addresses in all of its operations. However, the applications running on the Smart Grid are all based on Internet Protocol (IP) [7]. This means each node only knows the destination IP address if a communication is to be established. However, when the data packets reach the 802.11s-based Neighborhood Area Networks from outside (e.g., from the utility company), the gateway node needs to know the MAC address of the destination for routing. As a result, each time, the corresponding MAC address of the destination IP address needs to be searched in the ARP table at the gateway [8]. If the IP address is not found in the ARP table, an ARP request packet will be broadcast in a multi-hop fashion within the mesh network. Note that this is not a one-time overhead. Similar ARP requests will be sent periodically when the ARP alive time-out parameter of the gateway in the ARP table expires. The problem is compounded if TCP protocol is used. In that case, the gateway node needs to acknowledge the receipt of the packets from all the SMs and thus it will need to know the MAC address of each SM which requires additional ARP broadcasts.

This paper addresses this ARP flooding problem and proposes an efficient and secure ARP that is based on piggybacking idea when routes are searched in the network. We name it Piggybacked-ARP (PARP) thereafter. To the best of our knowledge, this is the first work which deals with this ARP flooding problem in the context of Smart Grid AMI application. The main motivation is to eliminate these broadcasts by utilizing the already existing proactive PREQ packets of HWMP to carry the MAC address information. To this end, we modify the HWMP protocol and include the MAC address of the gateway node in each proactive PREQ packet. Note that this approach works for Universal Datagram Protocol (UDP). In the case of Transmission Control Protocol (TCP), since a three-way handshake is required (i.e., SYN–SYN/ACK–ACK) for establishing a communication, more things needs to be done. Hence, PREP packets from each SM are also extended to include the MAC address of each SM so that the gateway node will have the mappings between the MAC and IP addresses of each SM.

While PARP eliminates the ARP broadcast storm problem, it becomes vulnerable to ARP cache poisoning attack since it involves broadcasting of ARP as part of PREQ packet. ARP cache poisoning involves broadcasts of unsolicited and fake ARP replies to change the ARP tables at the nodes. One possible solution to this problem in the literature is the rejection of unsolicited ARP replies [9]. However, since this approach cannot be applied to our extended proactive PREQ packet, we propose to add authentication for the extended proactive PREQ and PREP packets. In this way, no fake extended PREQ and PREP can be sent since they will not be authenticated. This secure version of PARP is referred to as PARP-Secure (PARP-S) in the rest of the paper.

We conducted an extensive performance evaluation of PARP and its secure version PARP-S by implementing them under ns-3 simulator which has a built-in draft implementation of IEEE 802.11s. We observed that the proposed PARP and PARP-S can significantly reduce the end-to-end delay while maintaining the same packet delivery and throughput performance when compared to the existing solution. Furthermore, we showed that the security protection on the extended PREQ/PREP packets does not have a major impact on the performance.

This paper has many components that are important contributions from the perspective of IEEE 802.11s which is a relatively new standard that has not been explored much. First of all, we change the way HWMP works by modifying the packet structure as well as the algorithm. Secondly, we study the problem of ARP broadcasts in the context of 802.11s: (1) to optimize the several parameters that are vital to the operation of 802.11s; (2) to compare with several other baselines and assess the performance in a variety of conditions.

This paper is organized as follows. Section 2 provides background on 802.11s, HWMP, ARP and the problem motivation and definition. Section 3 describes the proposed PARP and PARP-S approaches. Section 4 presents the performance evaluation of our proposed approaches. Section 5 discusses the related works. Section 6 summarizes our results and concludes the paper.

@&#OVERVIEW@&#

IEEE 802.11s is the standard for bringing multi-hopping capability to wireless LANs. This standard covers various functions, such as mesh discovery, peering, security, and mesh path selection and forwarding. The nodes in 802.11s Wireless Mesh Network are given names based on their roles. All mesh routers are Mesh Points (MPs) and are able to provide connectivity at the data link layer between other MPs. If an MP also provides connectivity to another network such as the Internet or a wired LAN, it is termed a Mesh Portal Point (MPP). An MP becomes a Mesh Access Point (MAP) if it connects wireless clients (e.g., Mesh Station (Mesh STA)) to the mesh network.

A Mesh network is formed through discovery and peering mechanisms. The discovery process uses passive and active scanning mechanism to find other mesh nodes. After the discovery, two neighbor mesh nodes need to agree to establish a mesh peering to each other. After successful mesh peering, they become peer mesh stations and can communicate directly one another. A mesh node can establish a mesh peering with multiple neighbor mesh nodes. Peering mechanism has two modes: (1) a secure peering mode, called Authenticated Mesh Peering Exchange; and (2) a non-secure peering mode, called Mesh Peering Management (MPM). A secure peering requires a Shared Pairwise Master Key which can be derived from 802.1X or from Simultaneous Authentication of Equals (SAE). While 802.1X requires the presence of an authentication server, SAE does not need it as explained next.

In addition to the previously defined authentication methods, 802.11s amendments adopted a protocol to simultaneously authenticate two arbitrary peers, called SAE [10,11]. SAE requires a shared password and a set of domain parameters either from Finite Field Cryptography or Elliptic Curve Cryptography to achieve authentication and key agreement. As the name implies, the parties that involve in the exchange are equals, each side is able to initiate the protocol, and does not have to be direct neighbors. The initiator (i.e., the node initiating the protocol) is the one that discovers its neighbor(s) first.

In our case, we assume a Smart Grid Neighborhood Area Networks based on this mesh networking idea. Specifically, all the SMs will act as MPs/MAPs. Note that we may have Mesh STAs from Home Area Networks that can connect with SMs and have them act as MAPs. The gateway node which will be connected to the utility will be MPP. The connection can be via leased lines, WiMax or fiber. A sample Neighborhood Area Networks for AMI applications is depicted in Fig. 1
                           .

In this Wireless Mesh Network, the MPs will send their readings to MPP using mesh path selection and forwarding mechanisms of 802.11s. Mesh path selection enables path discovery within the mesh network. Its responsibility is for maintaining the layer-2 routing table accuracy so that the forwarding function will work correctly. Once the mesh path from a source to a destination is found, the forwarding function will guide the data movement from one mesh node to another until it reaches the intended destination.

@&#OVERVIEW@&#

HWMP is the default path selection mechanism in IEEE 802.11s Wireless Mesh Network. It combines two modes of path selection operations: (1) on-demand; and (2) proactive tree building. The first mode is always present while the later depends on the presence of a root node in the Wireless Mesh Network. The on-demand mode allows mesh nodes to communicate through peer-to-peer paths while the proactive mode builds a tree that connects all nodes in the mesh to a root node. In this way, a path is always available between all the mesh nodes via the root. Both modes use the metric cost of the link to determine which paths HWMP builds. This metric is called Airtime Link Metric which tries to minimize medium usage by taking into account the probability of success on the transmission of frames and the datarates that a given link can support. They also use the same processing rules and three common messaging: (1) Path Request (PREQ), (2) Path Reply (PREP); and (3) Path Error (PERR) packet.

In on-demand mode, a source node broadcasts a PREQ packet indicating the MAC address of destination to find a path to a destination. All nodes receiving PREQ packet create/update its path to this source node when (1) the PREQ sequence number is greater than the current path to the source; or (2) when the sequence number is the same as the current path but it offers a better metric. Target Only (TO) flag in PREQ packet determines whether only the destination or any intermediate node that knows a path to destination may reply to PREQ. When TO
                           =1, only destination is allowed to reply. Otherwise, the first intermediate node that responds to PREQ re-broadcasts PREQ with the updated metrics and sets TO flag to 1 in order to prevent all intermediate nodes sending other replies. Once the destination node (or any allowed intermediate node) receives PREQ packet, it sends to the source a unicast PREP. If the destination node receives further PREQ with a better metric (and same or greater sequence number), it sends a new PREP along the updated path. The same rule as in PREQ is used when the source node receives more than one PREP.

Proactive mode has two mechanisms to announce a root node: (1) proactive PREQ; and (2) Root Announcement (RANN) packets. While the first is intended to create paths between all mesh nodes and a root mesh proactively, the later is intended to distribute path information for reaching the root mesh node with no forwarding information creation. When using proactive PREQ packet, the root node broadcasts a proactive PREQ packet periodically with an increasing sequence number. Each node may receive multiple copies of PREQ each traversing different paths from the root node to the receiving node. The processing rules are the same as in on-demand mode. In case of RANN, there are three packets involved. The root issues pro-active RANN, SM replies with unicast PREQ and the root replies with unicast PREP.

In both path selection modes, retransmission of PREQ packet for path discovery occurs when after a certain amount of time, the node that sends PREQ packet does not receive PREP packet. In each retransmission, the waiting time is increased with a certain amount of time. Two HWMP parameters are used for this purpose. dot11MeshHWMP-netDiameterTraversalTime parameter is used for the waiting time and dot11MeshHWMP-maxPREQretries parameter is used for the number of retry.

For Smart Grid AMI applications, the proactive mode suits better since there will be a root/gateway node collecting readings from all SMs and these power readings are sent to the gateway node periodically, not on demand. Once the path between an SM and gateway is established, it will be used all the times. In on-demand mode, nodes communicate with other nodes only when they would like to exchange information. This is not the case in an Smart Grid AMI application where all the nodes should communicate with the gateway periodically. Therefore, for the rest of the paper we will assume the running of proactive mode when we refer to HWMP routing.

Among the two mechanisms to be used in the proactive mode (e.g., PREQ or RANN), we selected the PREQ mechanism for implementation. This is motivated by two reasons: First, PREQ has a two-way handshake mechanism while RANN has three-way handshake which is a longer process. This may further increase the overhead in large-scale Smart Grid AMI networks. Second, the only draft implementation of IEEE 802.11s uses PREQ in ns-3 which makes testing convenient.

ARP uses three parameters to control the ARP operations:
                              
                                 •
                                 
                                    ARP AliveTimeOut defines the minimum time a dynamic ARP entry remains in the ARP table before it is being refreshed (i.e., an ARP request will be issued for the corresponding entry). The default value is 120s and this typically comes as set with the ARP and operating system.


                                    ARP MaxRetries defines the maximum number of times that a node can send the same ARP request before declaring a destination to be unreachable and the corresponding entry of the destination’s IP address in the ARP table is marked as dead. The default value is 3.


                                    ARP WaitReplyTimeOut defines the number of seconds a node waits for ARP reply in response to an ARP request. The default value is 1s.

In 802.11s-based Smart Grid Networks, as opposed to typical use of ARP at the data link layer, ARP is employed above the HWMP protocol to get the MAC address of the data collector node. Typically, the data collector gateway is set as the root of the Wireless Mesh Network. Every SM sends its power consumption data periodically to the gateway at the same pre-defined time intervals. However, since the ARP table of each SM would be empty at the beginning of data collection, all SMs will broadcast an ARP request for learning the gateway MAC address and then find a path to the gateway. Similar ARP requests will be sent periodically when the ARP AliveTimeOut of the gateway in the ARP table expires. These requests are forwarded via the intermediate nodes until they reach the gateway node. Once the MAC address is found, it is passed to layer-2 so that it can be used by HWMP.

Since ARP is a widely deployed protocol in every system, it has been subject to various attacks [12]. ARP cache poisoning is one of such attacks at the MAC layer in which an attacker modifies the address mapping in the ARP table by sending a malicious ARP reply packet to the victim machine. In this way, the attacker diverts the traffic towards that machine to another machine (possibly itself). It can also perform a man-in-the middle attack by modifying the ARP tables of two victim machines and control their conversations. Finally, it can modify the ARP packet in any way.

These attacks are also valid in the context of 802.11s. Any adversary can send malicious ARP replies to one of the SMs in the network and change its ARP table. Since HWMP will be using the information in the ARP table, the created routes will not be valid. More details of the considered attacks will be provided later.

In 802.11s-based Neighborhood Area Networks, typically the data collector gateway and SMs have two different external networks to communicate with as depicted in Fig. 2
                        . As such, both the gateway and SMs will need to support 802.11s to form the Wireless Mesh Network and TCP/IP to communicate with Widea Area Networks or Home Area Networks respectively. This is needed to provide bi-directional communications between customers and utility company. For instance, the utility company may need to talk to some of the other intelligent devices at the house such as sensors, gas meters which are part of the Home Area Networks for demand response and dynamic pricing applications. The reverse is also true: Each of the other intelligent devices that are part of Home Area Networks should be able to send data to the utility company when needed. Since the utility company and the devices that are part of Home Area Networks utilize TCP/IP stack for communication, they utilize IP addresses of destinations. As a result, even though 802.11s is employed for communication between SMs (i.e., no need for IP addresses), each SM also needs to employ TCP/IP protocols on top of 802.11s to support communication to both sides (utility or Home Area Networks).

When TCP/IP is employed (i.e., either TCP or UDP can be used for different applications based on the needs) at SMs, the communication between the utility and the SMs or any of the Home Area Network devices, are based on IP addresses of destinations. Hence, when the gateway receives a request from the utility company to send data to a particular destination IP, it faces the problem of associating the IP address with a MAC address. This is because 802.11s utilizes MAC addresses only and the MAC address of the destination node needs to be used for communication within the mesh. As a result, there needs to be an ARP table to keep the IP-MAC associations. When the required MAC address for a destination cannot be found in the ARP table, a broadcast ARP request is issued. This broadcast packet floods the mesh network. Note that this is not a one-time operation since such broadcast packets are also sent during the periodic maintenance phase of ARP tables.

We claim that the broadcasting of ARP requests in 802.11s-based Wireless Mesh Networks can be a major overhead when the network scales as in the case of Smart Grid Neighborhood Area Networks applications such as AMI. To justify our case, we conducted a preliminary testing to demonstrate the effects of the ARP broadcasts in large scale networks. We used a controlled grid topology in which each node can communicate with a maximum of four neighbors in the vertical and horizontal directions. Since the default ARP AliveTimeOut is varied between operating systems as summarized in [13], we used the default ARP AliveTimeOut for Windows XP (e.g., 120s).


                        Fig. 3
                         shows the average number of broadcast packets per node triggered by ARP with increased SM count. By default, each node will send an ARP broadcast packet when the AliveTimeOut expires. The results indicate that even though each node only sends a small number of broadcast packets, the number of received and forwarded broadcast packets per node is much higher which creates the major storm. With the increased hop count, this is expected since the ARP request packets will be forwarded in the network. We note that ARP replies are also a concern for creating additional traffic but since they are unicast packets, the effect is not as significant as ARP requests packets. The bottom line is that larger networks experience greater broadcast storm than smaller networks which need to be taken into account in Smart Grid Neighborhood Area Networks. Note that for TCP, SYN packets can be used to determine the MAC addresses of SMs with a mechanism at Layer 2. We also implemented this idea but observed that the impact is minimal since this only eliminates the broadcast ARP requests from the gateway.

Obviously, these broadcast ARP requests to the same destination are not efficient and consume a significant amount of bandwidth that may affect throughput and prevent the reported data to arrive to the gateway in a timely manner. The timely arrival can be crucial when demand response applications need to use the Smart Grid Neighborhood Area Networks. Note that configuring a static ARP in each node may alleviate this problem. Nevertheless, this is not an efficient approach considering the number of SMs involved when trying to keep them up to date in case of hardware changes at the gateway node. Therefore, a mechanism that will address this problem in an efficient and secure manner is needed. Next, we provide the details of our proposed approach.

To alleviate the broadcast storm problem, we first propose to modify the HWMP for piggybacking the ARP information. Specifically, during the proactive routing formation and maintenance of HWMP in which the gateway node broadcasts a PREQ packet, an IP-to-MAC address mapping of the root node is piggybacked in the proactive PREQ packet. Every SM that receives this extended proactive PREQ packet, in addition to its basic PREQ receiving process, will create or update its ARP table. The decision to create or update is based on the freshness of the PREQ packet (i.e., based on the PREQ sequence number).

Nonetheless, this approach works with UDP where there is no need for acknowledgment from the gateway. For TCP protocol or for demand response applications where the gateway node needs to reply with acknowledgments or sends packets to certain SMs, there will be ARP request packets across the network transmitted by the gateway node. This node will issue an ARP request packet when it cannot find the MAC address of the final destination in its ARP table. Note that broadcasting (flooding) of this request to all the network is not efficient. Therefore, we also extend our previous approach by adding piggybacked ARP on PREP packet in response to the piggybacked ARP in proactive PREQ packet. Every SM that receives a piggybacked proactive PREQ, will piggyback its address mapping information in its PREP packet to the gateway. On receiving the piggybacked ARP in PREP packet, the gateway node creates or updates its ARP table.

While the aforementioned approaches help reducing the broadcast storm, it becomes vulnerable to ARP cache poisoning attacks more easily since there is no mechanism to handle malicious piggybacked ARP packets. Specifically, an adversary can launch the following attacks:
                           
                              •
                              Cache poisoning attacks: An adversary can capture the PREQ/PREP packet and simply modify the MAC address mapping.

ARP spoofing attacks: An adversary can issue a fake PREQ/PREP packet to divert the traffic of an SM to itself or to another destination including a broadcast MAC address. In addition, it can divert the traffic of an SM and gateway to itself by acting as an intermediary (i.e., man-in-the-middle attack). In this way, it can control every packet between the SM and gateway.

To address these attacks we set two security goals: (1) to authenticate each PREQ/PREP packet for verification of sender; (2) to provide integrity of the packets when they are in transmit. In the following subsections, we discuss the details of our approach.

To implement our idea, we propose to make several modifications to basic HWMP. The first modification is to the packet formats while the second modification is to the general operation of HWMP.

We add two additional fields for both PREQ/PREP packets: (1) an address mapping field; and (2) a signature field. For the address mapping field, we have two choices to include: (1) only an IP address; or (2) both IP and MAC addresses. The first choice comes from the fact that the MAC address of the PREQ originator has been included in the PREQ packet. PREQ packet has the MAC address of the gateway node in the Originator Mesh STA Address field. Hence, it reduces the overhead. On the other hand, putting both IP and MAC addresses in the MAC address resolution packet is more flexible at the expense of an additional overhead of at least 48-bits (i.e., the length of MAC address). The flexibility is due to possible future changes in the network architecture such as addition of new nodes with new IP addresses. In that case, the mapping will be already in the packet and the IP-MAC pair will be entered in the ARP table as a new entry. Therefore, we choose the flexibility offered by the second choice in our design. We store the addresses in the following order: MAC address, IP address.

To address the security goals mentioned, we propose to add a signature mechanism to each of the piggybacked packets. The other solutions would not apply here since signatures ensure that the IP-to-MAC address mapping at the extended proactive PREQ/PREP packet comes from a legitimate node and its integrity is maintained. Whether it is a SM or gateway, they will not update their ARP tables unless they verify the signatures in the packets. Thus, a signature field in the packet format is used to store the digital signature. Its length varies depending on the length of signature. Our contribution here is to use digital signatures in HWMP and made the necessary changes to packet formats.

To create the signature field, we picked ECDSA which is the elliptic curve version of DSA [14]. This was mainly due to its efficiency compared to other approaches like RSA [15,16]. It has been included as digital signature scheme in ANSI X9.62, FIPS 186-2, IEEE 1363-2000 and ISO/IEC 15946-2 standard. ECDSA as well as other ECC methods require all parties to have the same elliptic curve domain parameters. These parameters describe an elliptic curve E defined over a finite field 
                              
                                 
                                    
                                       F
                                    
                                    
                                       q
                                    
                                 
                              
                           , a base point P
                           
                           
                              
                                 ∈
                              
                           
                           
                           E(
                              
                                 
                                    
                                       F
                                    
                                    
                                       q
                                    
                                 
                              
                           ), and its order n. However, a domain parameters generation algorithm is optional for elliptic curve based applications.

ECDSA uses a private key of a sender to generate the signature and a receiver node uses the sender public key for the signature verification. These keys are obtained using ECC domain parameters that are obtained via SAE. SAE stores an identifying number in the authentication algorithm field of an 802.11 authentication frame to identify an elliptic curve domain parameter in the Internet Assigned Numbers Authority (IANA) repository. IANA maintains a repository of finite cyclic groups for the Internet Key Exchange [17].

A final change to packet format is to be able to distinguish between former PREQ/PREP and the extended PREQ/PREP packets when they are received. To this end, we use the reserved bit in the Flags field as the identifier of these two additional fields. We use the last bit of the Flags field as the ARPTag subfield. These two additional fields are present when ARPTag
                           =1. The extended structure of both proactive PREQ and PREP packets are shown in Figs. 4 and 5
                           
                            respectively.

With the new packet formats and the involvement of ARP, we also modify the operation of HWMP. Before the gateway node sends an extended proactive PREQ, it signs the address mapping with its private key. When a node receives a PREQ packet, first it checks for the additional field based on the Flags field value. If this is an extended PREQ packet, the node verifies the digital signature of the packet with the gateway node’s public key. When the signature is verified, the node performs the following: (1) creates or updates its ARP table; (2) creates an extended PREP packet, sets the ARPTag subfield of the extended packet, and signs the extended PREP packet with its private key. On receiving this extended PREP packet, the gateway node verifies the signature with the sender’s public key and creates or updates its ARP table when the signature is valid. The modification of HWMP for the gateway and SM are shown in Algorithms 1 and 2 respectively. Algorithm 1 is used by the getaway for sending periodic proactive PREQ. The algorithm creates a unique message that consists of the address mapping information and the sequence number of the originator in an specific order. This unique message is signed by the gateway and verified at the receiver. Algorithm 2 is used by the receiver when receiving the proactive PREQ. In response to the proactive PREQ, the receiver creates a unique message by using the PREP originator sequence number. Algorithm 3 is used for both the gateway and SMs.

Note that a receiving node may receive multiple copies of PREQ/PREP packets. However, since one of the acceptance criteria of HWMP is freshness, we ensure that we use the newest address mapping information for creating/updating an ARP table.
                              Algorithm 1
                              Send Proactive PREQ 
                                    
                                       
                                    
                                 
                              

Receive PREQ 
                                    
                                       
                                    
                                 
                              

Receive PREP 
                                    
                                       
                                    
                                 
                              

In this section, we provide the description of implementation details and an extensive experimental analysis of the approach with respect to several baselines.

We used network simulator (NS-3) [18] to implement and test the proposed approaches. The flow monitor module [19] is used to collect data for performance evaluation. The Crypto++ library 5.6.1 is used for the implementation of authentication part. We considered an N by N mesh network of SMs using IEEE 802.11g, UDP protocol, and TCP protocol in an area of 1200m×1200m. The transmission range for the nodes is assumed to be 120m. One node which is located randomly in the mesh network acts as the data collector to communicate with the utility company (e.g., root/gateway) while the rest of the nodes act as SMs. Note that the area mimics the size of a neighborhood which will be using a single gateway to communicate with the utility company. As a result, we used node counts in relatively smaller values to reflect a rough estimate of households in such a neighborhood. For the experiments, we used 30 topologies for each experiment and get the average of the results for significance. We also computed the confidence of the results. For all the results, we observed that the experiment results stayed within 4.5–11% of the average with 90% confidence interval. The confidence intervals were not shown in the figures due to the clarity.

HWMP also uses several parameters to control its operations. While we mostly use the default HWMP parameters in our experiments, we specifically set dot11Mesh-HWMPnetDiameterTraversalTime parameter to 2s to accommodate various depths of the network topologies and prevent HWMP to retransmit broadcast PREQ packet for path discovery too early.

For assessing the performance, we used three metrics: (1) packet delivery ratio (PDR): This metric indicates the number of packets received at the data collector divided by the number of packets transmitted by all the SMs. This metric is crucial in understanding the positive impact of the proposed method for packet delivery; (2) average end-to-end (ETE) delay: This metric indicates the average ETE delay of all packets from SMs to the data collector; (3) throughput: This indicates the number of bits received at the gateway divided by the total simulation time. Note that we measure PDR and ETE delay at the application layer since we want to measure all delays of each unique data sent by SMs. However, for the throughput we measure it at the transport layer since the goodput (i.e., the application layer throughput) excludes the protocol overheads. We increased the SM count during the experiments for assessing the performance with increase network size and node density.

We compared our proposed approach to several baselines by using both UDP and TCP protocols. We represent the results in the graphs using the following names:
                           
                              1.
                              
                                 Base-A represents the basic operation of HWMP where there is no piggybacking of ARP and the ARP table of all nodes are initially empty with the default value of ARP AliveTimeout. The entries of the ARP table are created during ARP creation phase and are updated periodically during ARP table maintenance phase.


                                 Base-NA represents the ideal condition in which there is no ARP broadcast packets during the simulation time. Every node is pre-configured with all required address mapping information by storing the address mapping in the ARP table manually (i.e. static ARP). Static ARP does not need ARP table maintenance phase.


                                 PARP-NS represents our piggybacked ARP in which we piggyback the address mapping of the gateway node in every broadcast proactive PREQ to populate the address mapping of the gateway node to all SMs. In response to these proactive PREQ broadcast packets, every node will piggyback its address mapping information in the PREP packet. However, there is no security protection for the piggybacked ARP.


                                 PARP-S represents the secure version of piggybacked ARP where we add a signature in every piggybacked ARP either in proactive PREQ or PREP packets.

Our goal in the experiments is threefold: (1) to tune the ARP parameters and find the parameters for the optimal performance; (2) to understand the overhead of the proposed approach in terms of the updated management frames and signatures; and (3) to compare the performance of PARP-NS and PARP-S with the existing approaches.

Before starting to evaluate the proposed approach, we first evaluate the performance of the baseline to determine the optimal ARP parameters, specifically ARP WaitReplyTimeout and ARP AliveTimeout. Recall that ARP AliveTimeout determines the number of occurrence of broadcast ARP requests in the network during the simulation time. The longer the ARP AliveTimeout is, the less the ARP requests occur in the network. While our focus is more on ARP WaitReplyTimeout since it is sensitive to the network size, we only present the ARP AliveTimeout in two extreme cases, namely Base-A and Base-NA. ARP WaitReplyTimeout is set to two different values, specifically 1s and 4s. The approach with ARP WaitReplyTimeout value set to 1s is represented as Base-A-1sec while with the value 4s is represented as Base-A-4sec in the graphs. Next, we investigate the performance of these two approaches in terms of ARP request count. Their PDR, delay and throughput performance are also compared by considering Base-NA as a baseline. In this way, we aim to pick the most appropriate ARP AliveTimeout value for the rest of the experiments.

As depicted in Fig. 6
                           , basically Base-A-1sec transmits more broadcast ARP requests than Base-A-4sec since the ARP WaitReplyTimeout is too short which forces Base-A-1sec to re-transmit broadcast ARP requests. Note that if the number of retries exceeds the limit and a node still fails to receive the address mapping information, the corresponding entry in the ARP table is marked as dead and this node is unable to send its data to the intended destination. We name such nodes as inactive nodes.

Due to the different characteristics of UDP and TCP protocols, we get different results for the number of broadcast ARP requests. This is attributed to the fact that in UDP ARP requests are used for the purpose of sending data while in TCP they are used for connection establishment (i.e., SYN–SYN/ACK–ACK). Therefore, the gateway node is also involved and needs to send ARP requests to talk to the SMs. As a result, TCP is expected to produce more broadcast ARP requests than UDP.

Looking at Fig. 6 again, we observe that while the number of transmitted ARP requests for UDP is increasing as the network scales, this is not the case for TCP. For instance, the number of transmitted ARP requests for Base-A-1sec starts to drop after 64 nodes and becomes even less than that of Base-A-4sec after 121 nodes. This is an interesting outcome which may not be expected. We argue that this is due to the increasing number of inactive nodes in TCP as the network scales. Basically, the gateway becomes a bottleneck with too many SMs sending ARP requests at the same time and cannot reply to them to establish the TCP connection. To verify our argument, we assessed the number of inactive nodes for TCP as shown in Fig. 7
                           . Note that for these inactive nodes, TCP is unable to establish connection between those nodes and the gateway which eventually reduces the number of ARP broadcasts. In UDP, however, there is no inactive nodes and all the nodes are able to send their data to the gateway. The results in general indicate that increasing the ARP WaitReplyTimeout reduces the number of ARP requests for both protocols. It also reduces the number of inactive nodes for TCP.


                           Fig. 8
                            shows the impact of two different ARP WaitReplyTimeout values on the Base-A performance in terms of PDR, ETE delay and throughput.

For PDR and throughput, we observe that Base-A-4sec is doing as good as Base-NA in both TCP and UDP which is promising (see Fig. 8a and b). The PDR and throughput for Base-A-1sec is much less especially for increased network size. For instance, starting from 64 nodes, in TCP, there is a dramatic decrease in PDR and throughput. This is mainly due to increased number of ARP broadcasts which create additional traffic and contention. In addition, this can also partially be attributed to the existing of inactive nodes as explained before. When inactive node count increases, an increased number of nodes cannot contribute to the data transmissions which reduces the throughput. For Base-A-4sec, the effect of ARP broadcasts is minimized and thus more data can be transmitted successfully to the gateway node. Note that PDR and throughput for UDP is much less compared to TCP because of the nature of TCP (i.e., retransmissions).

Considering the ETE delay, there are a number of observations (see Fig. 8c and d). First of all, ETE for UDP is much less compared to TCP because of the lack of retransmissions and connection establishment phase. Second, in all cases, Base-NA has the least ETE delay due to lack of ARP broadcasts. The ETE delay for Base-A-4sec is higher than that of Base-NA because of the contention introduced by ARP broadcasts especially when the network scales. While Base-A-1sec ETE delay seems a bit reduced for increased node count (e.g., after 64 nodes), this result is not reflecting the actual situation. When looking at PDR and throughput, we have already seen that Base-A-1sec should not be used after 64 nodes due to significant drop in PDR and throughput (i.e., because of inactive nodes). The decrease in ETE delay can be explained as follows: For UDP, due to large number of ARPs, the number of data packets from further nodes (with respect to the gateway) decreases significantly. This reduces the overall ETE delay since mostly closer nodes to the gateway will be able to send their data. For TCP, due to the existing of too many inactive nodes, the number of contending nodes for accessing the medium decreases which eventually reduces the ETE delay. Note that for Base-A-4sec, all the nodes are able to send data to the gateway when the network size is up to 121. We observed only one inactive node when network size was 144. Hence, there is still a lot of contention among all the nodes in the network which increases medium access and queuing delay.

Looking at the overall results, for the rest of the experiments, we will use 4s as the ARP WaitReplyTimeout since it provides better reliability in terms of PDR and throughput.

In this subsection, we evaluate our proposed piggyback approaches: PARP-NS and PARP-S for UDP and TCP protocols.

As previously discussed, piggybacking ARP information in proactive PREQ and PREP packets adds additional overhead to the management frames. This extra overhead comes from the addition of fixed-size address mapping field and variable-size signature field. While the fixed-size address mapping field is used in PARP-NS, PARP-S has both overheads. In addition, there is an additional cryptographic computation time at each node for signing and verification of the content of the signature field when the security protection is employed.

We conducted two experiments to measure these overheads and observe their impact on the performance. First, we looked at the signature field overhead and reported the total overhead (of all packets) for each node count. This overhead is created by considering three different key-size in ECC: 160bits, 256bits, and 384bits. These keys created the signature size of 42bytes, 64bytes, and 96bytes respectively. As depicted in Fig. 9
                           a, PARP-NS has the lowest overhead as expected, while the overhead in PARP-S increases as the key size increases, either for UDP or TCP. We also put the overhead of RSA 1024bit key for comparison. The overhead of RSA is the highest.

We also observed that TCP overhead is more than UDP especially when the node count increases beyond 81. This indicates that TCP uses more management frames than UDP. This can be explained as follows: Since both UDP and TCP operate on the same environment and hence the amount of proactive PREQ and PREP packets they sent are similar, the higher overhead in TCP comes from PERR and/or additional PREQ packets. As mentioned before, HWMP has two mode of operations: proactive mode and reactive mode. Even though we use proactive mode, when a sender cannot find a route to a destination, reactive mode will kick in and start broadcasting PREQ packets to find a route. To verify this observation, we assessed the number of PREQ packets from all nodes. Fig. 9b shows the total on demand PREQs issued for PARP NS in UDP and TCP protocols. Note that there is no on demand PREQs for UDP protocol from the gateway since the gateway does not need to send any information. On the other hand, the gateway in TCP needs to send an acknowledgment for every packet received. Higher number of on demand PREQ packets from the gateway means that the gateway needs to delay the acknowledgments to some senders until the routes to these senders are found. The delay for the acknowledgment may trigger packet retransmission from a sender if it causes the retransmission timeout to expire for that packet. Hence, the number of PREQ packets will increase for TCP. The similar situation also arises for SMs. Some SMs need to buffer their data packet to the gateway and wait for the reactive mode to find the route to destination.

For the rest of the paper, we only present the results from 256bits key size since this key size has the security equivalent to 3072bits RSA [15].

We conducted several experiments to assess the performance of PARP-NS and PARP-S compared to Base-A and Base-NA. The experiment results show that the performance of our approaches is similar to that of Base-NA for all scenarios we tested (UDP and TCP protocols) as depicted in Fig. 10
                           .

In particular, the results indicate that PARP-NS and PARP-S match the performance of Base-A and Base-NA in terms of PDR and throughput for both UDP and TCP. However, the main advantage of our approaches is that they significantly reduce the ETE delay compared to the existing solution, namely Base-A. The reduction becomes more dramatic when the network scales. For UDP, the improvement almost doubles while TCP improvement becomes more obvious with increased network size. Obviously, this is due to decrease of ARP requests which reduces contention for the nodes to access the channel. We observe that PARP-NS and PARP-S performs even as good as Base-NA which is the best that can be achieved.

There are a number of other observations which can be made out of these results. First of all, we observe that TCP always performs better than UDP in terms of PDR. This is due to the reliable data delivery operation of TCP. Second, the throughput for all approaches does not change as we are looking at the total bits received at the gateway. However, the throughput of TCP is much higher than UDP even though the application layer of both protocols generates the same amount of data. This is because of higher number of packets received at the gateway with the reliability service provided by TCP through error control. In addition, some packets may arrive more than once due to being sent by the senders when their retransmission timers timeout. In term of fairness, Fig. 11
                            shows per-node throughput for two sample of 100 nodes topology. It shows that all nodes are able to send to the gateway and the fluctuation is typically due to the variation of the link quality between nodes.

Comparing PARP-NS and PARP-NS, the results depicted in Fig. 10 indicated that the overhead of signature signing and verification is almost negligible. As far as the PDR is concerned, PARP-S almost matches the performance of PARP-NS especially for TCP. In case of UDP, the PDR is slightly less due to slight increases in the ETE delay which causes some of the packets to be retransmitted and eventually dropped. The throughput for both approaches is almost identical in all cases.

The ETE delays are also very similar in particular for TCP. We only observed some fluctuations in TCP ETE delay of PARP-NS which can be attributed to the retransmission timeout problem in TCP. More specifically, each time TCP sends a packet, a retransmission timeout is set for the packet. When an acknowledgment is received from the destination before the timeout expires, this timeout is cancelled. However, if the sender does not receive an acknowledgment until the retransmission timeout expires, the sender retransmits the data and the transmission timeout value is increased by a certain amount. When this retransmission timeout value exceeds the next packet transmission schedule, this next packet will be buffered until successful delivery of the current packet (at the transport layer). Even if only a few SMs experience this problem, they eventually significantly affect the average delay of all the SMs tested. We speculate that this is the case that occurs for some of the specific SMs in PARP-NS which overall increases the average ETE at some specific node counts.

Overall, we can conclude that PARP-S is a secure and efficient approach whose performance is as good as PARP-NS and significantly outperforms Base-A.

@&#RELATED WORK@&#

With the development of AMI applications, a lot of wireless infrastructure and routing protocols were proposed [2,3]. In this paper our focus is 802.11s standard and we assume that the SMs will not have any resource and energy constraints. Therefore, we do not consider approaches that are geared for low-power devices such as RPL [20,21]. While these approaches can be implemented to replace HWMP, this will require a different hardware and frequency band for communication.

In the past, there has been some research on 802.11s in terms of improving its performance. For instance, Gharavi and Hu [22] strove to achieve more reliability by employing multiple-gateways and multipath routing. Jung et al. [23] proposed a new routing metric called link error rate metric and utilized multiple reserved paths to handle route instability. Kim et al. [24] studied delay-tolerant traffic management in 802.11s-based Wireless Mesh Networks. Finally, a recent study focused on the ping pong effect of the Airtime routing metric of HWMP and presented its correlation to the underlying rate control algorithms [25]. None of these approaches concerned with the ARP broadcast problem in Wireless Mesh Networks.

In general, broadcast packets (e.g., for MAC address resolution or path discovery) in shared wireless medium such as Wireless Mesh Networks may lead to frequent contention and collision among neighboring nodes. With the possible effects of interference and hidden terminal problems, Wireless Mesh Networks may lose up to 50% loss of throughput at each hop when a real world environment is considered [26]. This is still the case even with the new IEEE 802.11n MAC standard that has better data rates and transmission range [6]. To alleviate this issue, one proposed solution is to use multiple radios and communicate via different channels [27]. Multi-radio multi-channel Wireless Mesh Networks have been the focus of the research community recently [28]. While these types of Wireless Mesh Networks can boost the bandwidth, they still need to address issues joint channel assignment and routing in large-scale as well as the inter-flow interference. In addition, they will be more expensive as they require additional hardware. While our work in this paper is focusing on single radio Wireless Mesh Networks, it can still be applied to multi-radio large-scale Wireless Mesh Networks to further improve the packet delivery ratio and throughput.

ARP broadcast problem has been initially considered in small scale Wireless Mesh Networks where each node is assumed to talk to every other node randomly [13]. Again since MAC addresses are needed for finding the paths among any two nodes, the authors propose to use a gratuitous ARP sent from each node to the root node (if any) so that this root node can act as a central database for all IP and MAC address mappings. In this way, when there is an ARP request from any node in the network, it can respond to these requests. While we share the same goal of reducing the ARP broadcasts, the approach in [13] still allows a lot of ARP request and reply packets which cannot be tolerated in a large-scale AMI network. Our mechanism is very different since we have a root node and every node is expected to communicate with it. Our approach completely eliminates all ARP requests by piggybacking this information within PREQ packets in advance. Additionally, we also consider the possible ARP cache poisoning problem and investigate its effects on the network performance. Finally, we consider both TCP and UDP and investigate ARP parameter tuning via extensive experimentation.

ARP cache poisoning is a well-known attack and a number of ways that involve detection and prevention mechanisms have been proposed in the past to address it. For instance, there are detection mechanisms that work by monitoring ARP packets and alerting administrators through passive detection (e.g., arpwatch [29]), active detection [12] and Intrusion Detection Systems (e.g., snort [30]). However, these approaches will not be applicable for our problem due to the size of AMI applications and unavailability of administrators. The prevention mechanisms which rely on additional networks devices such as switches where the prevention is bound to these devices (e.g., Port security [31] and Dynamic ARP Inspection [31]) are also not applicable to our approach since we embed ARP within the PREQ and PREP.

A game theoretic approach based on voting mechanisms is proposed to mitigate the ARP cache poisoning problem in [32]. In this approach, each node has a long term table to store all the address mapping information in the neighborhood. When a node cannot find an address mapping in its long-term table, first it will try to resolve it through the normal ARP procedure (i.e., broadcast ARP request and unicast ARP reply mechanism). However, when there is an address mapping conflict that cannot be resolved by the node itself, voting mechanism is used to resolve this conflict. During the voting, each node will vote based on its long term table information. This approach contradicts with our goal of alleviating broadcast packets in Wireless Mesh Networks since the voting requests are issued in broadcast and hence would create additional overhead, especially in large-scale.

Due to inapplicability of the above approaches, alternative solutions that we consider for our approach are based on cryptographic approaches. One of such approaches is replacing the ARP protocol with a new protocol that involves a secure server [33]. The secure server keeps the IP to MAC address mapping database and shares secret keys with all nodes. In this approach, all nodes periodically and securely report their IP and MAC addresses to the secure server using shared secret keys. All ARP requests and replies for any address resolution occur between a node and the secure server. This approach alleviates broadcast ARP requests but it is not feasible in an AMI application since the communication between SMs and server may not be possible.

The ultimate solutions to cache poisoning problem is to provide authentication for ARP replies. Secure ARP [34] and Ticket-based ARP [35] fall into this category. S-ARP provides a defense against ARP cache poisoning using asymmetric cryptography. S-ARP uses DSA to provide authentication scheme for ARP replies and prevents ARP poisoning attacks. An additional ARP header that consists of 12 bytes S-ARP header and a variable length payload is added at the end of the ARP protocol standard to carry the authentication information. A variable length payload is also added at the end of the ARP replies in ticket-based ARP approach. This payload contains a ticket as a proof of IP address ownership. This ticket is generated and signed by the Local Ticket Agent as authentication proof of the association between IP and MAC addresses. The ticket also has an issue timestamp and expiration time which are used to identify when the ticket was generated and how long it is valid. The issue timestamp is also used for ticket revocation. TARP uses RSA with 1024-bit key. Our idea in this paper is also based on authentication but we do not use DSA or RSA due to their overheads. We use elliptic curve version of digital signature to not only address the issues regarding scalability and performance but also for easy integration of our approach with 802.11s. This is because elliptic curve has already been implemented in 802.11s standard for password-based authentication called Simultaneous Authentication of Equals (SAE) [10,11].

@&#CONCLUSION@&#

In this paper, we proposed a mechanism to tackle the ARP broadcast storm problem in 802.11s-based NANs by piggybacking the MAC address resolution in the proactive PREQ packet of HWMP. Piggybacking the MAC address resolution in proactive PREQ may however, pose security threats such as ARP cache poisoning attack. To address this issue, we also proposed an authentication mechanism based on ECDSA.

Through simulation, we showed that by adjusting the ARP WaitReplyTimeOut parameter, we can alleviate the destination unreachable problem due to smaller ARP WaitReplyTimeout values. By using these parameters, we assessed the performance of our proposed approach with and without authentication components. The simulation results indicated that the proposed piggybacking idea significantly decreases the ETE delay while maintaining the same PDR and throughput which are crucial in reliable data collection for large-scale AMI applications. The secure version PARP-S introduces only a slight overhead in terms of ETE delay and thus is shown to be a feasible mechanism to be employed for Smart Grid AMI applications.

In the future, we plan to compare the proposed approach with the case when there are two network interfaces associated with SMs. We also plan to compare with RPL by replacing HWMP. Another interesting direction is to investigate mechanisms to automatically derive MAC address from the IP address in IPv6 to alleviate ARP mappings.

@&#ACKNOWLEDGEMENTS@&#

This work is supported by US National Science Foundation under the Grant No. 1318872. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.comcom.2014.08.001.


                     
                        
                           
                        
                     
                  


                     
                        
                           
                        
                     
                  


                     
                        
                           
                        
                     
                  


                     
                        
                           
                        
                     
                  


                     
                        
                           
                        
                     
                  


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

