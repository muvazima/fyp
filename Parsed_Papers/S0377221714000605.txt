@&#MAIN-TITLE@&#New approaches to nurse rostering benchmark instances

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           New upper and lower bounds for benchmark nurse rostering instances.


                        
                        
                           
                           A general model which can be applied to a wide variety of staff rostering problems.


                        
                        
                           
                           A powerful dynamic programming method used to solve sub-problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Staff scheduling

Nurse rostering

Branch and price

Ejection chain

@&#ABSTRACT@&#


               
               
                  This paper presents the results of developing a branch and price algorithm and an ejection chain method for nurse rostering problems. The approach is general enough to be able to apply it to a wide range of benchmark nurse rostering instances. The majority of the instances are real world applications. They have been collected from a variety of sources including industrial collaborators, other researchers and various publications. The results of entering these algorithms in the 2010 International Nurse Rostering Competition are also presented and discussed. In addition, incorporated within both algorithms is a dynamic programming method which we present. The algorithm contains a number of heuristics and other features which make it very effective on the broad rostering model introduced.
               
            

@&#INTRODUCTION@&#

Rostering problems are found in a wide range of workplaces and industries including healthcare, manufacturing, transportation, emergency services, call centres and many more. Using a computational search algorithm to address these problems results in cost savings and better work schedules. As such, rostering problems in various forms have received a large amount of research attention over the years. This body of research grew steadily throughout the 1960s, 1970s and 1980s and then accelerated in growth as more powerful desktop personal computers became commonplace in workplaces during the 1990s. As the computational and processing power has grown so has the range and complexity of algorithms that can be applied and the size and complexity of the instances that can be solved. For an overview of rostering problems and solution methodologies see (Ernst, Jiang, Krishnamoorthy, & Sier, 2004). A very large annotated bibliography of publications relating to staff scheduling is also provided by Ernst, Jiang, Krishnamoorthy, Owens, and Sier (2004). For a literature review specifically aimed at the nurse rostering problem, see (Burke, De Causmaecker, Vanden Berghe & Van Landeghem, 2004).

As these review papers show, many different approaches have been used to solve nurse rostering problems. These include metaheuristics (Bellanti, Carello, Croce, & Tadei, 2004; Burke, Curtois, Post, Qu, & Veltman, 2008; Burke, Curtois, Qu, et al., 2010; Ikegami & Niwa, 2003; Moz & Pato, 2007), constraint programming (Darmoni et al., 1995; Meyer auf’m Hofe, 2000; Weil, Heus, Francois, & Poujade, 1995), mathematical programming (Azaiez & Al Sharif, 2005; Bard & Purnomo, 2005), other artificial intelligence techniques (such as case-based reasoning (Beddoe & Petrovic, 2007) and hybrid approaches (Burke, Li, & Qu, 2010; Qu & He, 2008). Each method has strengths and weaknesses. For example, as will be shown in this paper, a mathematical programming approach may be able to solve some instances to optimality extremely quickly but on other instances it may take infeasible amounts of time or use too much memory. A metaheuristic, on the other hand, may be able to find a good solution to difficult instances quite quickly but may not be able to find the optimal solution to another instance which an exact method can solve very quickly. An obvious solution to this well-known phenomenon is to combine and hybridise different techniques. This is one of the principles behind adaptive approaches such as hyperheuristics.

The aim of this paper, however, is to provide new results (upper bounds and lower bounds) for a large collection of diverse rostering benchmark instances. This is the first occasion that a branch and price method has been applied to these instances. We also introduce the dynamic programming algorithm which is at the core of the branch and price method and we present a general rostering model which was used for all the instances tested.

Branch and price is a branch and bound method in which each node of the branch and bound tree is a linear programming relaxation which is solved using column generation. The column generation consists of a restricted master problem and a pricing problem. Solving the pricing problem provides new negative reduced cost columns to add to the master problem. The pricing problem can be considered as the problem of finding the optimal work schedule for an individual employee but with the addition of dual costs, that is, additional (possibly negative) costs based on which shift assignments are made or not made. In non-root nodes of the branch and bound tree, there may also be additional branching constraints on certain assignments that must or must not be made.

Although this is the first time that branch and price has been applied to these instances, it has previously been used on the nurse rostering problem (Eveborn & Rönnqvist, 2004; Jaumard, Semet, & Vovor, 1998; Maenhout & Vanhoucke, 2010; Mason & Smith, 1998). All these earlier applications have similar structure and the same structure is adopted here. The master problem is modelled as a set covering problem and solved using a linear programming method such as the simplex method. The pricing problem is formulated as a resource constrained shortest path problem and solved using a dynamic programming approach. The branch and bound tree is generally too large for a complete search and so heuristic, constraint branching schemes are adopted in which branching is performed on shift assignments in the roster. Although the dynamic programming algorithms all use the same principles (dominance pruning and bound pruning), the actual implementations are dependent on the constraints and objectives present in the pricing problem. For a recent overview of column generation see (Lubbecke & Desrosiers, 2005) and for further reading on resource constrained shortest path problems see (Irnich & Desaulniers, 2005).

In the next section, we discuss the challenge of modelling such a wide variety of instances and how it was solved. In Section 3, we introduce the benchmark instances and Section 4 presents the branch and price algorithm. Section 5 contains the results of applying the algorithms to the benchmark instances. In Section 6, we discuss the International Nurse Rostering Competition and finish with conclusions in Section 7.

One of the most significant challenges in addressing a large diverse collection of instances is developing a model which can be used for all the instances with their varying types of constraints and objectives. In all the instances, there are common types of constraints/objectives which are relatively straightforward to model. These include the cover constraints (ensuring that there is a correct or a preferable number of employees assigned to each shift). However, the types of constraints that can be present in each employee’s work schedule can vary significantly from instance to instance. This is due to the reality of each workplace having its own set of rules and requirements defined by different employers, employees, unions and national legislation. Furthermore, each employee often has a different contract to reflect such features as full-time employment, part-time employment and night shift working. To provide a system which can incorporate these variations, we developed a general constraint based on pattern/string matching or more specifically regular expressions. Regular expressions are a powerful yet compact way of specifying patterns to be found or matched. They are commonly used in Computer Science and so we will not expand upon the subject here. Instead, we refer readers to one of the many textbooks on the subject such as (Friedl, 2006). Using a regular expression constraint in staff scheduling problems appears to be a natural fit and this is not the first example of its application to these type of problems (Côté, Gendron, Quimper, & Rousseau, 2011; Demassey, Pesant, & Rousseau, 2006; Pesant, 2004). However, in order to fully include all the variations in the instances we used, our approach is broader than some of this earlier work. First though, we will illustrate by example how this constraint can be applied in staff rostering problems. The basic idea behind the constraint is to consider the employee’s work schedule as the ‘search text’ containing the regular expressions to be matched and the regular expressions to be matched are sequences of shifts. After presenting the examples below, we also provide a figure to illustrate how the constraint works in practice (Figs. 1–3
                     
                     
                     ). The figures show a short section of a single employee’s schedule. The coloured squares labelled E, D and N represent early, day and night shifts respectively. The highlighted days show where the regular expression in question has been matched.
                        Example 1
                        If a night shift (N) can only be followed by another night shift or a day off then it could be modelled by the constraint “maximum zero matches of the pattern ‘N followed by any shift other than N’”. Note that we use the expression “maximum zero” here as another way of saying this pattern must not appear at all. We use this expression instead though because all the matches are expressed as either a maximum or minimum number of matches in order to provide more modelling power (Fig. 1).

If an employee must not work more than five consecutive shifts then it could be modelled by the constraint “maximum zero matches of the pattern ‘Any, Any, Any, Any, Any, Any’” where Any is any shift (that is, not a day off) (Fig. 2).

If an employee must have a minimum of two consecutive night shifts then the constraint would be “maximum zero matches of the pattern ‘anything but N, followed by N, followed by anything but N’” (Fig. 3).

As can be seen, the constraint is based on the idea of string/pattern matching. However, it is more like a regular expression and extends some of the previous work because we also allow:
                        
                           ▪
                           
                              Grouping: Matching one of a group of shifts at a point in the sequence.


                              Negation: Matching anything but a specific shift or group of shifts at a point in the sequence.


                              Alternation: Matching multiple patterns.


                              Quantifiers: The pattern(s) must appear a minimum or maximum number of times.

Restricting the search text to a specific region of the work schedule.

Only matching a pattern if it starts on a particular day in the work schedule.

This enables us to model some of the more complicated constraints such as those relating to weekend work or constraints that only apply between certain dates in the planning period. Using this general regular expression constraint, we can model many of the constraints found in staff scheduling problems. An example list is provided below.
                        
                           ▪
                           Minimum/maximum consecutive work days.

Minimum/maximum consecutive non-work days.

Day on/off requests.

Shift on/off requests.

Minimum/maximum number of shifts (optionally within a specific time frame).

Minimum/maximum number of shifts of a specific type (optionally within a specific time frame).

Minimum/maximum number of consecutive shifts of a specific type (optionally within a specific time frame).

Days off after a series of shifts of a specific type.

Shift rotations (which shifts can follow which shifts).

Minimum/maximum shift rotations.

Minimum/maximum number of weekends worked (or any group of days/dates).

Minimum/maximum number of consecutive weekends worked.

Although all these constraints can be modelled using the regular expression constraint there are though some constraints which cannot. In particular, this includes those relating to the minimum and maximum amount of work time an employee can be assigned. For this type of constraint, we developed a general constraint called Workload which is simply a minimum or maximum amount of work time which can be assigned to a single employee between any two dates in the planning horizon.

A mathematical model of the problem is now presented.
                        
                           
                              
                              
                              
                                 
                                    
                                       Sets
                                    
                                 
                                 
                                    
                                       E
                                    
                                    Employees to be scheduled, e
                                       ∊
                                       E
                                    
                                 
                                 
                                    
                                       T
                                    
                                    Shift types to be assigned, t
                                       ∊
                                       T
                                    
                                 
                                 
                                    
                                       D
                                    
                                    Days in the planning horizon, d
                                       ∊{1,… ,|D|}
                                 
                                 
                                    
                                       Re
                                       
                                    
                                    Regular expressions for employee e, r
                                       ∊
                                       Re
                                       
                                    
                                 
                                 
                                    
                                       We
                                       
                                    
                                    Workload limits for employee e, w
                                       ∊
                                       We
                                       
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       Parameters
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   RU
                                                
                                                
                                                   er
                                                
                                                
                                                   max
                                                
                                             
                                          
                                       
                                    
                                    Maximum number of matches of regular expression r in the work schedule of employee e
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   RL
                                                
                                                
                                                   er
                                                
                                                
                                                   min
                                                
                                             
                                          
                                       
                                    
                                    Minimum number of matches of regular expression r in the work schedule of employee e
                                    
                                 
                                 
                                    
                                       RWer
                                       
                                    
                                    Weight associated with regular expression r for employee e
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   WU
                                                
                                                
                                                   ew
                                                
                                                
                                                   max
                                                
                                             
                                          
                                       
                                    
                                    Maximum number of hours to be assigned to employee e within the time period defined by workload limit w
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   WL
                                                
                                                
                                                   ew
                                                
                                                
                                                   min
                                                
                                             
                                          
                                       
                                    
                                    Minimum number of hours to be assigned to employee e within the time period defined by workload limit w
                                    
                                 
                                 
                                    
                                       WWew
                                       
                                    
                                    Weight associated with workload limit w for employee e
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   CU
                                                
                                                
                                                   td
                                                
                                                
                                                   max
                                                
                                             
                                          
                                       
                                    
                                    Maximum number of shifts of type t required on day d
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   CL
                                                
                                                
                                                   td
                                                
                                                
                                                   min
                                                
                                             
                                          
                                       
                                    
                                    Minimum number of shifts of type t required on day d
                                    
                                 
                                 
                                    
                                       CWtd
                                       
                                    
                                    Weight associated with the cover requirements of shift type t on day d
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       Variables
                                    
                                 
                                 
                                    
                                       xetd
                                       
                                    
                                    1 if employee e is assigned shift type t on day d, 0 otherwise
                                 
                                 
                                    
                                       RNer
                                       
                                    
                                    The number of matches of regular expression r in the work schedule of employee e
                                    
                                 
                                 
                                    
                                       WNew
                                       
                                    
                                    The number of hours assigned to employee e within the time period defined by workload limit w
                                    
                                 
                                 
                                    
                                       CNtd
                                       
                                    
                                    The number of shifts of type t assigned on day d
                                    
                                 
                              
                           
                        
                     
                  


                     Constraints
                  

Employees can be assigned only one shift per day
                        
                           (1a)
                           
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       t
                                       ∈
                                       T
                                    
                                 
                              
                              
                                 
                                    x
                                 
                                 
                                    etd
                                 
                              
                              ⩽
                              1
                              ,
                              
                              ∀
                              e
                              ∈
                              E
                              ,
                              
                              d
                              ∈
                              D
                           
                        
                     
                     Objective Function
                     
                        
                           (1b)
                           
                              Min
                              
                              f
                              (
                              x
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       e
                                       ∈
                                       E
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       4
                                    
                                 
                              
                              
                                 
                                    f
                                 
                                 
                                    e
                                    ,
                                    i
                                 
                              
                              (
                              x
                              )
                              +
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       t
                                       ∈
                                       T
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       d
                                       ∈
                                       D
                                    
                                 
                              
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       5
                                    
                                    
                                       6
                                    
                                 
                              
                              
                                 
                                    f
                                 
                                 
                                    t
                                    ,
                                    d
                                    ,
                                    i
                                 
                              
                              (
                              x
                              )
                           
                        
                     where
                        
                           (1c)
                           
                              
                                 
                                    f
                                 
                                 
                                    e
                                    ,
                                    1
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       r
                                       ∈
                                       
                                          
                                             R
                                          
                                          
                                             e
                                          
                                       
                                    
                                 
                              
                              
                                 max
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             
                                                
                                                   
                                                      RN
                                                   
                                                   
                                                      er
                                                   
                                                
                                                -
                                                
                                                   
                                                      RU
                                                   
                                                   
                                                      er
                                                   
                                                   
                                                      max
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             RW
                                          
                                          
                                             er
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1d)
                           
                              
                                 
                                    f
                                 
                                 
                                    e
                                    ,
                                    2
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       r
                                       ∈
                                       
                                          
                                             R
                                          
                                          
                                             e
                                          
                                       
                                    
                                 
                              
                              
                                 max
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             
                                                
                                                   
                                                      RL
                                                   
                                                   
                                                      er
                                                   
                                                   
                                                      min
                                                   
                                                
                                                -
                                                
                                                   
                                                      RN
                                                   
                                                   
                                                      er
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             RW
                                          
                                          
                                             er
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1e)
                           
                              
                                 
                                    f
                                 
                                 
                                    e
                                    ,
                                    3
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       w
                                       ∈
                                       
                                          
                                             W
                                          
                                          
                                             e
                                          
                                       
                                    
                                 
                              
                              
                                 max
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             
                                                
                                                   
                                                      WN
                                                   
                                                   
                                                      ew
                                                   
                                                
                                                -
                                                
                                                   
                                                      WU
                                                   
                                                   
                                                      ew
                                                   
                                                   
                                                      max
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             WW
                                          
                                          
                                             ew
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1f)
                           
                              
                                 
                                    f
                                 
                                 
                                    e
                                    ,
                                    4
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       w
                                       ∈
                                       
                                          
                                             W
                                          
                                          
                                             e
                                          
                                       
                                    
                                 
                              
                              
                                 max
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             
                                                
                                                   
                                                      WL
                                                   
                                                   
                                                      ew
                                                   
                                                   
                                                      min
                                                   
                                                
                                                -
                                                
                                                   
                                                      WN
                                                   
                                                   
                                                      ew
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             WW
                                          
                                          
                                             ew
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1g)
                           
                              
                                 
                                    f
                                 
                                 
                                    t
                                    ,
                                    d
                                    ,
                                    5
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 max
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             
                                                
                                                   
                                                      CL
                                                   
                                                   
                                                      td
                                                   
                                                   
                                                      min
                                                   
                                                
                                                -
                                                
                                                   
                                                      CN
                                                   
                                                   
                                                      td
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             CW
                                          
                                          
                                             td
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (1h)
                           
                              
                                 
                                    f
                                 
                                 
                                    t
                                    ,
                                    d
                                    ,
                                    6
                                 
                              
                              (
                              x
                              )
                              =
                              
                                 max
                              
                              
                                 
                                    
                                       0
                                       ,
                                       
                                          
                                             
                                                
                                                   
                                                      CN
                                                   
                                                   
                                                      td
                                                   
                                                
                                                -
                                                
                                                   
                                                      CU
                                                   
                                                   
                                                      td
                                                   
                                                   
                                                      max
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             CW
                                          
                                          
                                             td
                                          
                                       
                                    
                                 
                              
                           
                        
                     The objective function (1b) is a weighted sum of the soft constraints (1c)–(1h). (1c) and (1d) relate to the regular expression constraints, (1e) and (1f) relate to the workload constraints and (1g) and (1h) the cover constraints. When applying this model to an instance in which one of the employee’s constraints or a cover constraints is a hard constraint we simply set the weight to a very high number (significantly higher than any of the other weights).

The significant advantage of this model is that it can incorporate the requirements of many different workplaces without needing to be extended. This means that the algorithm does not need to be modified when a new constraint is encountered as long as it can be modelled as a regular expression. For example, the benchmark instances discussed in the next section could be described as different problems because most of them have a different set of constraints and objectives. However, we were able to model them all using this single model.

In order to validate our algorithms and encourage more competition and collaboration between researchers working on rostering we have built a collection of diverse and challenging benchmark instances. The collection has grown over several years and has been drawn from various sources such as industrial collaborators (including software companies and hospitals), scientific publications and other researchers. The collection continues to grow, is currently drawn from thirteen different countries and the majority of the data sets are based on real world rostering scenarios. Table 1
                      lists the instances. As can be seen, they vary in the length of the planning horizon, the number of employees, the number of shift types and the number of skills. Each instance also varies in the number, priority and type of constraints and objectives present. The objectives were set by the organisation that provided the data. For example, some prefer to minimise overstaffing whereas other prefer to maximise staff satisfaction by setting the weights for those objectives higher instead.

The instances are available for download from http://www.cs.nott.ac.uk/~tec/NRP/, where all the required information on each instance, best solutions, visualisations and other software is also available. The data set files are not included within this paper because of their large size.


                     Table 2
                      lists the instances used in the First International Nurse Rostering Competition. The instances were created by the competition organisers and not released before the competition. They are discussed further in Section 6.

The implementation of the branch and price approach follows the previously published algorithms mentioned in section 1. However, quite a lot of time was spent improving the performance of the implementation. For example, profiling the algorithm reveals that during the column generation, typically about 5% of the computation time is spent re-solving the restricted master problem (using the simplex method) whereas the other 95% of the time is used in solving the sub-problems (generating the new columns using the dynamic programming algorithm). This meant that the performance of the algorithm could be most significantly improved through:
                        
                           (1)
                           Reducing the number of calls to the pricing problem solver.

Improving the performance of the pricing problem solver.

Stabilization (reducing the oscillation of the dual values) was particularly important and effective for the first. For the second, additional heuristics and bounding methods were very effective, especially exploiting the fact that it is not necessary to find the most negative reduced cost column each time (that is, the pricing problem does not have to be solved to optimality until it is necessary to show that there are no more negative reduced cost columns). These heuristics are discussed in more detail in Section 4.1. For the stabilization, we used the method presented in Pigatti et al. (2005) which is relatively straightforward to implement and does not depend on instance specific parameters but was also very effective.

To solve the master problem we used the simplex method of the open-source, Coin-OR linear programming solver (clp) (COIN-OR, 2010) which we found to be fast and stable.

Within a time limit, two different heuristic branching strategies are applied in the branch and bound tree to try and find new solutions (upper bounds). For the first strategy, we simply branch on the variables in the master problem by selecting the variable that is closest to one. This strategy often quickly provides an upper bound but this upper bound can usually be improved by the second branching strategy. In the second strategy, we branch on individual employee-shift assignments (constraint branching). At each node in the tree, we select the employee-shift assignment that has the value closest to one when summing all the master problem variables (columns) that contain this assignment. Columns that do not contain this assignment are then removed from the master problem and when the master problem is re-solved the pricing problem solver only generates columns which contain this assignment (and any other forced assignments from ancestor nodes in the tree). We carried out some initial experiments with branching on the most fractional assignments (closest to 0.5) instead. There did not appear to be much difference in solution quality but it was slightly slower on average so chose to branch on assignments closest to one.

The initial solution is provided by applying the variable depth search algorithm for 5seconds. If a provable optimal solution (lower bound equal to upper bound) is not found within the time limit, then the best upper bound is returned.

We use a dynamic programming approach to solve the pricing problem. That is, to generate new columns where the columns are basically new work schedules (also called shift patterns) for individual employees. The problem can be classified as a resource constrained shortest path problem. Fig. 4
                         shows an example graph for an instance with three shift types (Early, Day and Night). A path consists of n connected nodes between the source and sink node where n is the number of days in the planning horizon. Each shift type and a day off represent the nodes that can be chosen on each day. Resources are collected along the path depending on which nodes are part of that path.

The idea behind dynamic programming is to use bounding and dominance to prune paths/nodes that can be shown to be unnecessary to expand. Although dynamic programming can be very effective at solving certain types of problem, in worst cases the number of paths can still grow exponentially.

An interesting feature of our implementation is that we solve the problem over a number of iterations where at each iteration the number of paths that can be expanded is restricted to a maximum and the paths to expand are selected heuristically. If at the end of an iteration the maximum limit was not reached then the problem was solved. Otherwise, we try again with a higher limit but possibly also with a new upper bound (i.e. the best solution found at the previous limit). We also resume the search at the point the limit was reached in order to avoid superfluous repetitions. An outline of the algorithm is provided by Fig. 5
                         and discussed in more detail below.

The algorithm is able to solve the problem to proven optimality or just return the first set of solutions it finds with an objective function value below a bound. This bound and the flag indicating whether to solve it to optimality are passed as parameters to the algorithm. The other algorithm parameters are variables which may change between calls to the method: The dual costs (from the cover constraints) and any branching constraints. (The branching constraints are assignments which must or must not be made in the shift pattern because they are fixed in the branch and bound tree).

As already discussed, in the column generation algorithm it is not necessary to solve the pricing problem to optimality every time (that is, it does not need to find the most negative reduced cost column) but any negative reduced cost columns are acceptable.

The maximum array sizes to use at each iteration of the algorithm is set at step 3. In the pseudocode, the values shown are: {32, 128, 512, 2048, 8192, infinity} which is the setting used for the results shown in Section 5. Some testing was performed varying the size of this set and the values in it but no clear best setting was found when tested over all instances. However, a general strategy of starting with small values which are solved very quickly before gradually moving to the larger values appears to work best.

At step 15 (i.e. after a shift assignment is made), a lower bound is calculated (a minimum objective function value) for a partially complete pattern by looking at the assignments already made, the objectives for that employee and the dual costs. This lower bound is then used to discard the pattern if it is greater than or equal to the best upper bound found so far. (Although not shown in the pseudocode this exact same procedure is also done at step 5 where other assignments are made due to branching constraints).

After creating a new partial pattern, it is necessary to compare this pattern to the partial patterns in NextArray for dominance. The dominance checking simply involves comparing the patterns by examining the values of the variables RNer
                         and WNew
                         used in the objectives (1c)–(1f) for the employee e that the pattern is being generated for. For example, if it is a minimum objective (1f) or (1d) then the pattern with the higher variable value is dominant for that objective. If it is a maximum objective (1c) or (1e) then the pattern with the lower variable value dominates. A pattern dominates another pattern if it dominates for at least one objective and is not dominated on any other objectives.

If the pattern is dominated by an existing pattern then it is discarded (to significantly increase the computation speed the pattern that dominates it is moved to the start of the NextArray, this has the effect that the next time the array is iterated through to check for dominance there is a greater chance it finds a dominant pattern more quickly). If the pattern dominates any existing patterns then it is added to NextArray and all the patterns that it dominates are removed. If it is identical to an existing pattern (that is, neither are better for any of the objectives) then it is also discarded. If it is incomparable to an existing pattern (that is, they each are better on an objective or cannot yet be compared for an objective) then it must be added. It may still dominate other patterns though which can be removed. It is also useful to note that when comparing two patterns, an objective which can be shown to be already satisfied in both patterns can be ignored in the comparison.

Dominance checking is the most time consuming part of the algorithm, particularly when the number of patterns to compare is large. A number of suggestions have been made in the literature to speed up this process. These include maintaining sorted lists or checking for dominance at different points in the algorithm. However, the feasibility of these suggestions depends upon the type and number of objectives present. We perform the dominance testing at step 19 but it is also possible to compare patterns at steps 30 and 31 instead.

At step 23, the new pattern cannot be added to NextArray as it would cause the maximum array size to be exceeded. However, the pattern with the worst objective function value is replaced with the new pattern if it has a better objective function value. This is another heuristic rule which improves the speed of the algorithm.

At step 24, the algorithm moves to step 29 and tries a different shift assignment at the current day (TryNextAssignment is simply a label at the end of that loop which in effect immediately moves to the start of the loop and tries the next shift type). During development we did experiment though with going to step 9 (move to the next day) instead of going to the step 29 as it may appear more efficient to not test every shift type if we already have a valid pattern. However, it was found to be much more effective to continue generating new patterns by going to step 29. This is because we are testing all possible shift types which although slower, as a result of the heuristics and rules within lines 16–27 the patterns which remain by the next day (step 9) are the dominant patterns with lower partial objective function values.

It is worth mentioning that although adding the heuristics described had the most significant impact on the performance of the algorithm, how the algorithm is implemented can also have an effect on the speed of the algorithm. This is particularly the case with respect to memory management and the types of data structures used.

@&#RESULTS@&#

In addition to providing results for the branch and price algorithm, we also compare them to an ejection chain based approach called variable depth search (VDS). Although the core of the algorithm is an ejection chain method, it contains a number of other features that have been added since it was originally described in Burke et al. (2013). These include incorporating a dynamic programming method into an iterative constructive method at the start of the algorithm. (This is the same dynamic programming algorithm used to solve the pricing problem in the branch and price method). A solution disruption and repair method (based on Burke et al., 2008) has also been added to extend the algorithm if the time limit is not exceeded and some fast, hill climbing methods which use the search neighbourhoods described in Burke, Curtois, Ochoa, et al. (2010) have been incorporated too. The search neighbourhoods are defined by the assignment or de-assignment of shifts to employees or the swapping of two shifts between two employees. Additional neighbourhoods are then defined by extending these search neighbourhoods by considering assignments, de-assignments and swaps of shifts on multiple adjacent days (sometimes called block moves).

The variable depth search operates by taking these individual moves and chaining them into a single much larger move in order to escape from the local minima that they would otherwise be restricted to. Heuristics are used to dynamically select which moves to link together. When a local minimum is reached for this larger chain neighbourhood a re-start heuristic is used. The mechanism involves completely un-assigning all the shifts assigned to a small number of employees and then re-building their schedules using the dynamic programming method.

For the first set of results and comparisons we applied the branch and price algorithm to each benchmark instance. We then repeated the experiments with the VDS method but setting its maximum time limit parameter to exactly the same amount of time as used by the branch and price algorithm. The results are shown in Table 3
                     .

The instances in Table 3 are ordered on our estimated difficulty in solving them based on all the testing we have done (note that this does not correspond only to their size). The problem is a minimisation problem and results in bold indicate optimal solutions. All experiments were performed on a desktop PC with an Intel Core 2 Duo 2.83gigahertz processor.

For the branch and price, we have also included the lower bounds found at the root node of the branch and bound tree (that is, before the integer constraints must be satisfied). The lower bounds are very close (often equal) to the optimal solution objective function value. The branch and price method is able to solve most of the instances to optimality but the computation time varies from less than one tenth of a second up to 10hours on the hardest instance. On the largest (and hardest) instance we set a 10hour time limit as beyond this, in testing, the algorithm had previously encountered a pricing problem in this instance for which the dynamic programming method ran out of memory (using over 2gigabytes). This was because the size of the state space for the dynamic programming method is related to the number of shift types and the length of the planning period and this instance has twelve shift types and a six week horizon. Despite this, a very good upper bound can still be found for this instance within the 10hours.

For some of the easier instances, the solutions were actually integer at the root node and so no branching was necessary. Others were slightly fractional but could be made feasible and optimal quite quickly in the branch and bound tree. The harder instances were very fractional though and the algorithm had to go deep in the tree to find an upper bound.

The variable depth search solves some of the easier instances in less than a second but compared to the branch and price some of the other results are worse. Despite this it is still worth noting that all these solutions are far better than could be achieved by hand (and of course in much less time also). One apparently anomalous result is the result for WHPP which appears to be significantly worse. However, in this instance the weights for the objectives are set such that some of the objectives have a weight of one and all others have a weight of 1000. The higher weighted objective appears to be quite difficult to completely satisfy so that near optimal solutions in terms of the number of objectives satisfied appear quite sub-optimal in terms of the objective function value. Some of the other instances also have similar large steps in weights and therefore also objective functions.

Only on one instance (Valouxis-1) does the variable depth search find a better solution than the branch and price method but there does not appear to be an obvious reason why it outperforms on this instance.

In the results, for both the algorithms we chose a single seed and identical parameter settings for every instance. That is, we did not perform many runs with different settings and chose the best result from each setting. For the instances Valouxis-1, Ikegami-3Shift-DATA1.1, Ikegami-3Shift-DATA1.2 on which the branch and price did not find the optimal solution though, it has also found the optimal solutions too in approximately the same computation times but with different algorithm settings such as different seeds.

For a second set of experiments, we restricted the algorithms to shorter computation times. Based on feedback from end users we chose 30seconds and 10minutes. The feedback received suggested that if users want good solutions quickly they prefer not to wait more than 30seconds. If they are willing to wait a little longer for optimal or near-optimal solutions they generally prefer not to wait more than approximately 10minutes. The results are shown in Table 4
                     .

The results in Table 4 show that (as would be expected) the more computation time provided, the better the solutions. When the computation time is increased to 10minutes, the branch and price method is able to further improve twelve instances. Increasing the computation time to 10minutes for the VDS method further improves fifteen instances.

Over 30seconds the branch and price is better on eight instances, equal on eight and worse on eleven. Over 10minutes it is better on eleven instances, equal on ten and worse on six. On all instances where the algorithms are equal they both found the optimal solutions. It is also evident that under both time restrictions the VDS is generally better on the larger instances and the branch and price outperforms on the smaller instances. It is also interesting to note that if the branch and price does not find the optimal solution within the time limit, the best upper bound it returns is generally worse than the solution found by the VDS in the same time. This suggests the potential benefit of using both algorithms in parallel if possible.

One apparently anomalous result is for the VDS on the ORTEC01 instance where the result is better for 30seconds versus 10minutes. This is, however, correct. The VDS contains heuristics which automatically adjust based on the pre-defined computation time and the instance size. In this case, the heuristic worked very well on this instance.

In 2010, the First International Nurse Rostering Competition was held. The competition consisted of three ‘tracks’ each with different instances. For the first track (sprint) the algorithms were allowed a maximum of 10seconds computation time to solve each instance. For the second track (medium) the algorithms were allowed 10minutes and for the third track (long) 10hours were permitted. A number of instances for each track were released at the start of the competition and, at the end, competitors submitted their best solutions found within the time allowed for each instance. The results for the top five algorithms were verified and then tested by the organisers on some hidden instances to produce the final rankings for each track. We entered the competition using both the branch and price and the variable depth search algorithms.

We used the same model as developed for the benchmark instances to model the competition instances and then tested the variable depth search and branch and price algorithms on them. The results
                        1
                        The solutions are also available online at http://www.cs.nott.ac.uk/~tec/ and also on request from the authors.
                     
                     
                        1
                      are shown in Tables 5 and 6
                     
                     .

As shown in Table 5, although the branch and price method could solve most of the instances to provable optimality, for the sprint instances the time required was longer than the maximum allowed of 10seconds. Therefore, for those instances we used the variable depth search. The results are shown in Table 6 (we have also included the results of testing the variable depth search on the instances within the competition time limits).

In Table 7
                     , we show the rankings of the solutions we submitted for the instances released by the competition organisers (fourteen competitors entered the competition).

On every instance our algorithms were first or first equal. However, in the final rankings we did not do so well due to some changes the organisers made to the hidden instances. For the majority of the hidden instances, the start date of the planning horizon was changed (but not the horizon length). We did not foresee this and as a result we incorrectly modelled some of the constraints relating to weekends. As such, our solvers’ objective function values for nearly all the hidden instances was incorrect, which clearly had a very adverse effect on the final rankings (our final competition rankings were: sprint: 4th, medium: 2nd, long: 2nd).

@&#CONCLUSION@&#

We have presented new results for benchmark nurse rostering problems which will be particularly useful to other researchers. The results also show that a branch and price method can solve some instances very effectively. For other instances, the time and resource requirements may be restrictive though. However, with new heuristics and other new ideas it may be possible to improve the performance further. For example, more advanced branching schemes in the branch and bound tree or decomposing the problem by splitting up the planning period may yield improvements. Although the variable depth search is not as successful as the branch and price on some instances, it is still a robust solver and able to find good solutions quickly. Another avenue for future research may be further integration of the two algorithms.

Within both algorithms, a dynamic programming method is used which has also been introduced. The algorithm uses a number of novel ideas and heuristics which we believe are general enough to be adapted to other problem domains also.

All the instances tested were modelled using a generic model, at the core of which is a regular expression constraint. Although we cannot claim to be the first to apply this concept to staff scheduling problems, we have expanded the idea to make it even more powerful and widely adoptable.

Finally, Fig. 6
                      is a screenshot of a modelling tool for rostering problems (Roster Booster). The software features the variable depth search algorithm and the column generation algorithm (for calculating lower bounds) presented here, and is freely available for download at the website of Staff Roster Solutions Limited (http://www.staffrostersolutions.com). (Staff Roster Solutions is a spin-out company formed by the University of Nottingham to commercially license and develop its research on rostering algorithms such as that presented here).

@&#REFERENCES@&#

