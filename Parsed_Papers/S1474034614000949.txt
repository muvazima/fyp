@&#MAIN-TITLE@&#Model-based fault localization in bottling plants

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We created a customizable solution for automatic fault diagnosis in bottling plants.


                        
                        
                           
                           The model-based approach allows the generation of individual diagnosis solutions.


                        
                        
                           
                           New validated models for all relevant plant components were developed.


                        
                        
                           
                           The diagnosis solution was tested in practical scale and judged as a useful tool.


                        
                        
                           
                           Up to 87.1% of compliant diagnosis results were obtained.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Model-based fault localization

Automatic fault diagnosis

Consistency-based diagnosis

Bottling plant

Packaging line

@&#ABSTRACT@&#


               
               
                  The bottling of beverages is carried out in complex plants that consist of several machines and material flows. To realize an efficient bottling process and high quality products, operators try to avoid plant downtimes. With actual non-productive times of between 10% and 60%, the operators require diagnosis tools that allow them to locate plant components that cause downtime by exploiting automatically acquired machine data.
                  This paper presents a model-based solution for automatic fault diagnosis in bottling plants. There are currently only a few plant-specific solutions (based on statistical calculations or artificial neural networks) for automatic bottling plant diagnosis. In order to develop a customizable solution, we followed the model-based diagnosis approach which allows the automatic generation of diagnosis solutions for individual plants. The existing stochastic and discrete-event models for bottling plants are not adequate for model-based diagnosis. Therefore, we developed new first-principle models for the relevant plant components, validated them numerically, and abstracted them to qualitative diagnosis models. Based on the diagnosis engine OCC’M Raz’r, application systems for two real plants and one virtual plant (based on discrete-event simulation) were generated and evaluated. Compared to the reasons for downtime identified by experts, we obtained up to 87.1% of compliant diagnosis results. The diagnosis solution was tested by practitioners and judged as a useful tool for plant optimization.
               
            

@&#INTRODUCTION@&#

A bottling plant for filling beverages into returnable bottles is an assembly of different types of specialized machines and conveyors. They automatically handle the complete process, from pallets with crates containing empty bottles to the final output of pallets with (cleaned) crates and filled and labeled bottles. The plants can be large, distributed over several halls, and have a complex 3D layout, as illustrated in Fig. 1
                     . This shows a bottling hall of a brewery with two large bottling plants. One can see the filling, labeling, packing, and cleaning machines at the back and conveying systems for empty, filled, and labeled bottles at the front.

From an abstract point of view, which reflects the flows and manipulation of different types of objects, the basic schematic topology can be simplified as indicated in Fig. 2
                     . There are lines for primary packaging (M3 for cleaning bottles, M4 for filling and capping bottles, and M5 for labeling bottles), secondary packaging (unpacking and packing crates with M2 and M5) and tertiary packaging (de-palletizing and palletizing with M1 and M7), all organized as an automated branching but directed flow. Certain backward loops, such as re-submission of improperly cleaned or filled bottles to previous steps, are omitted in Fig. 2. Besides the machines (M1–M7) shown in Fig. 2, there are additional machines for inspection and for sorting out improper objects.

In order to prevent oxygen intake or microbiological contamination of the beverage, a major objective is to avoid interruptions to the filling process (M4). Apart from internal reasons, the filling and capping machine will stop operating if there is a lack of input, i.e. bottles, or a tailback of filled bottles preventing further output, i.e. disturbances caused by other machines (Section 5 presents two examples). Due to the high speeds and output rates (up to 100,000 packages per hour), machines and conveyors are failure-sensitive with a degree of availability of 92–98% [1]. In order to avoid each disturbance of a machine in the line resulting in the filling machine stopping, the conveyors are designed as buffers (BB2-5, BC1,2,5, BP0,1), which should provide a continuous supply and output to/from other machines and, in particular, the filling and capping machine (M4). This works in conjunction with a general operating principle: machines and conveyors upstream and downstream from the filler operate at higher throughput rates than the filling machine. This principle is usually the only global one. There is no global control and the machines are controlled individually (or, sometimes, as small aggregates).

In practice, these provisions cannot guarantee avoidance of unwanted idle time of the filling machine. Unplanned downtime of the plant can be 10–60% ([2,3]) of the planned production time. Taking steps to reduce downtime by identifying frequent causes requires statistics and an analysis based on the recorded operating data supplied by (some of) the machines. These operating data capture only status information about the machine, such as normal_operation, stopped (due to an internal cause or intervention), lack (stopped because of missing input material), and tailback (stopped because of output by the next component). Due to the interlaced flows of the various object types, time offsets, the large scale of the plants, and the amount and often fragmentary nature of the data (for instance, there are no status data of conveyors), this analysis can be difficult and time-consuming. As a consequence, the bottle filling and packaging industries are very interested in an automated diagnosis tool for their plants that provides information about bottlenecks and weaknesses in the plant, regarding both the physical performance and configuration and the control principles and parameters.

Providing such a tool was the goal of the LineMod project that is described in this paper. The project was carried out to find a solution for automatic fault diagnosis of bottling plants. The project addressed industrial needs by localizing the causes of reduced performance of the plant (mainly tied to the output of the filling machine) based on the available production data of the machines (e.g. over a period of weeks or months). Many of the potential end users, for example breweries, are small or medium-sized enterprises that cannot afford spending many resources on the establishment or adaptation of a tailored diagnosis system for their plant. Another practical requirement was to be able to cheaply accommodate frequent changes to the structure of the line, due to rearrangement or addition of machines. Additionally, a plant is a combination of machines from various manufacturers with different instrumentation and data availability. These issues suggested a need for a model-based solution to diagnosis, which allows adaptation to be performed by simply (re-)specifying the plant structure. The project focused on interruptions to transportation that caused a total standstill of the filling machine due to a lack or tailback of containers (as opposed to an automatic reduction of machine speeds to prevent filler stops).

This paper starts with a survey of previous literature in order to position our work (Section 2). Section 3 first summarizes the foundations of the chosen approach to diagnosis, called consistency-based diagnosis. Then it presents the key contribution of this paper, the library of the component models that were developed for the domain of bottling plants, and we describe the diagnosis solution. Both have been described in more detail in previous publications (see [4–6]).

Section 4 discusses the validation of the component models and the evaluation of the results of the implemented solution using both incidents on real plants and simulated incidents. We carried out a validation of the numerical base model components and present exemplary results. To evaluate the final diagnosis solution we followed two routes, one based on simulation data acquired by discrete event simulation on a plant and the other based on recorded data from two real world bottling plants and a comparison with manual analysis. We present the results and explain them with the help of sample scenarios. Finally, the project outcome is discussed with regard to industrial applicability.

Among the existing approaches for modeling bottling plants, several deal with statistical distributions of disturbances and failures and aim to provide a basis for modeling or simulation of the respective plant structures ([7–9], or [10]). Models of chained production lines, which include the application area of bottling and packaging considered here, can be found in queuing theory [11]. Many other solutions pursue analytical approaches. Based on Markov chains, filling degrees of buffer elements can be approximately predicted (see [12,13]). The approach is based on stochastic models describing state changes of a plant with differential equations. However, all stochastic approaches need simplifications to enable the equation systems to be solved. Some important simplifications are (for a more detailed listing see [14]):
                           
                              •
                              Disturbances and failures of machines occur randomly. Lacks or tailbacks in the flow of material caused by failures of downstream or upstream machines have no effect on other machines. Hence, failures are not propagated.

The number of operating employees is always sufficient to resolve a disturbance within its determined period of malfunction.

Disturbances only occur while machines are operating; if a machine is in lack or tailback states, no disturbance can occur.

Along the whole plant, no objects are removed or rejected.

Due to these few but necessary simplifications, this approach based on Markov chains is an inadequate solution for diagnosing faulty behavior in bottling plants and is therefore unsuitable for a diagnosis tool. Further characteristics of the application domain, which are not considered, are:
                           
                              •
                              Besides there being a flow of primary packaging materials (bottles), closed flows of secondary packaging materials (crates) and tertiary packaging materials (pallets) also exist.

Machines can operate with different output rates and conveyors can transport objects with different velocities; in modern plants, velocities and output rates are controlled.

Certain machines can be electronically or mechanically “locked” to form one machine (such as the filling machine and the inspector of the investigated plant structures).

Certain machines (such as bottle washing machines) can buffer a considerable number of objects. This has a high impact on the overall behavior of a plant because temporary failures of upstream machines can be compensated due to buffer capacities or failure propagation can be considerably delayed.

Inspector machines can remove or reject defective objects.

In industry, discrete-event-simulation models are also used for detailed modeling of system behavior. Plants are planned and designed using these kinds of simulation models. Furthermore, it has been attempted to raise the productivity by adjusting and optimizing single machine parameters, and output rates of machines and plants are predicted ([15–18], or [10]). For research activities, simulations have also been used to model virtual systems with realistic behavior ([19,20], or [21]). However, while discrete-event models are useful for simulating the possible behavior of plants under some given initial conditions, they do not lend themselves as diagnosis solutions where the task is to identify a specific actual fault scenario in the plant.

@&#METHODS@&#

Up until now, only a few solutions for diagnosing filling machine downtimes and finding the origins of these disturbances in bottling plants have been described in the scientific literature. One solution [22] is described for a special bottling plant in Patras, Greece, based on a decision tree. In order to achieve an executable solution, the decision rules were simplified considerably and only downtimes longer than one minute were diagnosed. The obtained algorithm seems to be inflexible, very much customized to the single plant under study, and no evaluation (e.g. regarding diagnosis correctness) is described. Generally, decision tree solutions that were also examined in preliminary studies regarding our LineMod project depend on the availability of complete data about all plant components, a precondition that is rarely satisfied in practical applications. Another solution is based on artificial neural networks (ANNs) which achieved good results when tested on simulated data. However for a real plant, coverage of training data is impossible to achieve. Also, the flexibility of the solution turned out to be unacceptable, since every reconfiguration and rearrangement of the plant structure implies a new training phase of the ANN. For a complete description and evaluation of the solution, we refer to the closing report of the respective project [23].

There are two commercial systems for diagnosis of filling machine downtimes. The “Filler Stop Tracker” [24] developed by ProLeit AG requires the operator to enter the cause of a filler stop. Although it is not an automatic solution, it demonstrates the need for diagnosis solutions in this domain.

The “Downalyse KIT” was the first system for automatic fault localization in bottling plants in the marketplace [25]. It was developed by Krones AG as a module within their “Line Diagnosis System” LDS. The “Downalyse KIT” algorithm uses the downtimes of all machines of a bottling plant to compare propagation time and length with nominal values and is categorizing them by this into plant relevant and non plant relevant failures. It is limited to the primary material flow (bottles) and ignores secondary material flows (e.g. crates), tertiary material flows (e.g. pallets), and backward loops as well as the dynamic behavior of the buffering, which leads to wrong diagnoses.

In summary, while there is a need for a diagnosis system in this domain, no acceptable solution is available as of now. The solutions proposed to date are either not flexible enough to be adapted to new plant configurations or their diagnosis quality is too low.

Model-based diagnosis [26] is most advanced within model-based systems with respect to theory and industrial applications. It was developed as a response to limitations of rule-based diagnostic expert systems when applied to engineered systems. Rule-based systems are aimed at capturing experiential knowledge and are hence confined to faults or fault combinations, symptoms, and diagnostic contexts that were experienced in the past. In contrast, the model-based approach attempts to represent first principles’ knowledge about the physics of the systems to be diagnosed and thus provides a basis for diagnosing new devices under novel situations, and even performing fault localization in the presence of unknown faults. A key idea is the creation of libraries of models of system buildings blocks which can be re-used to configure plant models just like the building blocks themselves are aggregated to form a plant.

This progress is shown by a number of technical and industrial applications. Success has been achieved, for example, with fault localization in power transmission networks [27], monitoring and fault detection in ballast water tank systems [28], and diagnosis and self-reconfiguration for spacecraft of NASA [29]. Also, model-based fault detection and identification within the scope of the commercial monitoring system for gas turbines TIGER [30], the generation of fault trees for the diagnosis of forklifts [31], diagnosis of dyeing factories [32], generation of decision trees for onboard diagnostics of dynamic automotive systems [33], and process fault detection in the chemical industry [34] were made possible. Ref. [35] gives an additional overview of successful applications of model-based diagnosis.

In the presented work we followed the consistency-based approach. Bottling plants contain a fixed set of components, COMPS, which interact in a fixed system structure. These are the machines and connecting conveyors displayed in Fig. 2. It is assumed that the system is well-designed, i.e. behaves and performs as intended if all components behave correctly. A disturbance of the entire system can be caused by a single faulty component or a set of faulty components. The diagnosis task is to decide whether there are components that are not behaving as intended, i.e. are showing faulty behavior (fault detection). Furthermore, it can be determined which components are operating in a fault mode (fault localization) and in which fault modes they operate (fault identification).Details about the theory or algorithmic aspects may be found in [26,28,36], or [37].

For consistency-based diagnosis, the system structure and the behavior need to be represented in a model which allows automation of the location and identification of causes of misbehavior within the system. A model-based diagnosis algorithm then compares the model’s predicted behavior with the observed behavior of the real world system. The core step is to check whether or not the observed system behavior contradicts the predictions generated by the system model (hence the name consistency-based diagnosis (see Fig. 3
                        )). If the predictions of the nominal model, i.e. the combination of models of correct behavior for all relevant components, is inconsistent with the observations, a fault has been detected. However, consistency-based diagnosis can derive more information if the model allows determination of the causes of the inconsistency more precisely: if, for instance, two component models OK(C1) and OK(C2) give rise to inconsistency, it can be concluded that at least one of them must be defective. If there are more such inconsistent submodels, their combined evidence allows the fault localization to be narrowed down: if, in addition to {OK(C1), OK(C2)}, {OK(C1), OK(C3)} are inconsistent, then it can be concluded that C1 is a possible single fault, while C2 is not, but is part of a potential double fault {OK(C1), OK(C2)}.

Please note that this illustrates that consistency-based diagnosis is also able to perform fault localization based on a model of the system’s correct behavior (MODELOK) only. This means that no assumptions about the possible faults need to be made and, hence, faults that have not been encountered before and/or are not described can be localized. Secondly, the example shows that consistency-based diagnosis can easily diagnose multiple faults. Both capabilities are in contrast to an experience-based approach to diagnosis as used in rule-based expert systems.

When component models are supplemented by models of their particular failures, the principle described above also allows checking of the consistency of certain assumed faults with the given observations, refuting certain fault hypotheses, and hence also allows for fault identification.

The intuitive idea explained above can be turned into a rigorous logical theory which enables us to precisely define the concepts and goals of model-based diagnosis and to design solution algorithms and to prove their correctness. In the following, we summarize these logical foundations (for details, see [26]).

For a particular plant, COMPS denotes the set of all components the plant is composed of (In our application domain, this is the set of conveyors and machines listed in Fig. 2). To refer to normal or faulty behavior, each component Ci has a set of behavior modes (Ci), where the mode OK(Ci), representing the intended normal behavior of Ci, is always included in the set modes (Ci). All other modes represent faults. This may simply be the negation of OK, 
                           
                              ¬
                           
                        OK(Ci), which has no specific associated behavior, i.e. no fault model. Alternatively, there can also be particular fault modes, such as conveyor_stopped, with an associated behavior model. A mode assignment MA is the assignment of one mode to each component contained in (a subset of) COMPS. MA is called complete if modes are assigned to all components in COMPS.

The required description of a system contains two elements:
                           
                              •
                              LIB: A model library, assigning behavior models to component modes. From a logical point of view, the library contains a set of implications mode (Ci)⇒model (Ci). The library represents domain knowledge, which can be re-used within different plant models.

STRUCTURE: The structural description of the specific plant, which determines the variables that are shared by the component (mode) models according to the topology of the plant, i.e. the connectivity of the components.

Together, these elements infer a system model from a mode assignment, which can then be checked for consistency with the observation. Based on this, we can define the concept of a consistency-based diagnosis for a set of observations OBS of the actual system behavior (in our case the recorded status messages described in Section 1) as a complete mode assignment MA that is consistent with the structural description of the plant, the component (mode) models and OBS. These elements can be stated as sets of first-order formulas and the criterion for MA being a diagnosis under the given set of observations as
                           
                              
                                 STRUCTURE
                                 ∪
                                 LIB
                                 ∪
                                 {
                                 MA
                                 }
                                 ∪
                                 OBS
                                 
                                 ⊭
                                 ⊥
                              
                           
                        where denotes “False” and ⊭ means it is not entailed by the theory (in other words: it is consistent). For detecting faults, it is first of all assumed that all components operate correctly: in the mode assignment MAOK, OK modes are assigned to all components and the system behaves as intended. It then only has to be checked whether the model of the correctly behaving system is inconsistent with the observations OBS:
                           
                              
                                 STRUCTURE
                                 ∪
                                 LIB
                                 ∪
                                 {
                                 
                                    
                                       MA
                                    
                                    
                                       OK
                                    
                                 
                                 }
                                 ∪
                                 OBS
                                 ⊨
                                 ⊥
                              
                           
                        
                     

If faulty components should be localized, i.e. the separation of correctly operating components from faulty ones, it is often sufficient to restrict the modes of each component C to OK(C) and 
                           
                              ¬
                           
                        OK(C). In particular, minimal fault localizations are of practical interest, i.e. a minimal set of faulty components which suffices to explain a symptom. There is no need to assume additional components to be faulty.

To perform fault identification and/or refine fault localization, fault modes of components and their respective behavior models can be defined, as previously mentioned. The combinations of fault models span an entire space of models. The larger the space of models grows, the more models need to be checked for consistency with the observations. In order to respond to this situation advanced search strategies and heuristics have been developed (see Ref. [26]).

A number of algorithms have been developed and described in the literature such as the:
                           
                              •
                              General Diagnostic Engine (GDE) [38] which uses only OK models and fault probabilities.

GDE+ [39] which also exploits fault models.

Default-based Diagnostic Engine (DDE) ([28,40]) which allows orders on fault modes to guide the search.

The diagnosis solution presented in this paper uses the commercial diagnosis engine “OCC’M’s Raz’r” [41], which is an implementation of GDE+ basic component models.

We firstly list the most important assumptions underlying the material transportation models presented here, which are fulfilled in our project domain (under normal conditions) but should also apply to a much broader class of problems.
                              
                                 •
                                 The transported objects (bottles) are rigid bodies with fixed spatial extensions and they are not significantly deformed by transportation.

They are transported with a fixed orientation (e.g. crates), or the orientation does not affect transportation times significantly (e.g. due to the symmetric cross-section, such as for bottles).

There is no interaction among the objects or between objects and the components that has a significant impact on the transportation process (such as bouncing).

Objects can only move in the direction of motion of the transportation means (or not at all).

Based on these general assumptions, we generated a library of component models which allows the configuration of models for different plants. For typical bottling plants, we needed 4 basic component models and one virtual component model for connection:
                              
                                 •
                                 
                                    Material Transporter (MT) for conveyers or machines processing and/or transporting objects of one kind in a linear way (e.g. belt, labeling machine, inspector).


                                    Split Element (SpE) and Merge Element (ME) that respectively divide a flow of objects of one kind or join two flows.


                                    Separate Element (SE) for machines splitting a flow of aggregate objects into the flows of its constituent objects (crate unpacker and depalletizer).


                                    Combine Element (CE) for machines assembling objects of two kinds to create a flow of aggregate objects (crate packer and palletizer).


                                    Transportation Connector (TC), a virtual component to connect the elements.

In the following section, we describe the modeling concept of the components using MT as an example. The other components are built in a similar way and are described in Refs. [42,43].

In order to present the essentials of the modeling approach, we consider some sort of model archetype which can be specialized or extended to accommodate other kinds of machines. This is a generic machine that:
                              
                                 •
                                 has one input and one output with v
                                    in, v
                                    out being the respective velocities of the means of transportation (e.g. belts),

possibly transforms or modifies one kind of object (for instance, cleaning of bottles), but does not amalgamate several objects to form a new one,

has a buffer with a (constant) capacity C.

The process of buffering the objects can be fairly random. For instance, bottles may gather in bulk with gaps in between. However, it is assumed that (under normal behavior) no object is prevented from approaching the output unless it is blocked by other objects ahead, waiting for output. For instance, within the bottle conveyor, its shape and several parallel belts with different speeds ensure that bottles are not left in some corner, but are pushed towards the “ideal” fastest belt, if there is space. In the following, the intuition behind the model can be best described in terms of three fundamental concepts and four “behavior rules”, each of which is first introduced informally and then turned into equations. One of the problems to be solved stems from the fact that a local machine model in isolation cannot determine whether an actual flow occurs at its input and output. However, it can and has to express the limits on the machine’s potential to take in or output objects. Table 1
                            summarizes the variables and equations of the model of an MT and Fig. 4
                            illustrates it.


                           Concept 1: The potential input and output flow, in.q
                           pot and out.q
                           pot, represent the maximal flow the machine can accept or generate, dependent on its internal state.

The actual flows are represented by two different variables, in.q
                           act and out.q
                           act. The first restriction is determined by:


                           Rule 1: The potential input flow is given by the input speed of the Material Transporter, unless the buffer is full. In this case, it cannot be higher than the actual output flow.

In the mathematical model (see Table 1), this rule is formalized by
                              
                                 (1)
                                 
                                    
                                       
                                          
                                             in
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   pot
                                                
                                             
                                             (
                                             t
                                             )
                                             =
                                             
                                                
                                                   v
                                                
                                                
                                                   in
                                                
                                             
                                             (
                                             t
                                             )
                                             /
                                             
                                                
                                                   d
                                                
                                                
                                                   0
                                                
                                             
                                          
                                          
                                             if
                                             
                                             B
                                             (
                                             t
                                             )
                                             <
                                             C
                                          
                                       
                                       
                                          
                                             in
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   pot
                                                
                                             
                                             (
                                             t
                                             )
                                             =
                                             min
                                             (
                                             
                                                
                                                   v
                                                
                                                
                                                   in
                                                
                                             
                                             (
                                             t
                                             )
                                             /
                                             
                                                
                                                   d
                                                
                                                
                                                   0
                                                
                                             
                                             ,
                                             out
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   act
                                                
                                             
                                             (
                                             t
                                             )
                                             )
                                          
                                          
                                             if
                                             
                                             B
                                             (
                                             t
                                             )
                                             =
                                             C
                                          
                                       
                                    
                                 
                              
                           where d
                           0 denotes the diameter of the object cross-section and B is the filling degree of the buffer (in terms of number of objects). It involves the assumption that an actual outflow generates the potential for intake instantaneously, which is not true in practice and is hence another reason for expressing tolerance intervals with values and time. Note that we assume all velocities and flows are positive, as their sign is determined by their association with the intrinsic direction of the Material Transporter. Computing B is straightforward:


                           Rule 2: The change in the total number of buffered objects is determined by the actual input and output flows.

The respective equation
                              
                                 (2)
                                 
                                    dB
                                    /
                                    dt
                                    =
                                    in
                                    .
                                    
                                       
                                          q
                                       
                                       
                                          act
                                       
                                    
                                    (
                                    t
                                    )
                                    -
                                    out
                                    .
                                    
                                       
                                          q
                                       
                                       
                                          act
                                       
                                    
                                    (
                                    t
                                    )
                                 
                              
                           indicates that B is computed by integrating the difference of the actual flows. Setting up the model fragments for the potential output flow is based on the second key idea:


                           Concept 2: B
                           out denotes the number of buffered output objects at time t, i.e. the number of objects that can possibly be subject to output at this time. Before we clarify this crucial concept, we use its intuitive understanding and the third concept to formulate the rule for the potential output flow.


                           Concept 3: The minimal transportation time td
                            is the time an object needs to get directly from the input to the output, i.e. if it is not delayed by other objects that are piling up.


                           Rule 3: The potential output flow is determined solely by the output speed, if there is more than one buffered output object. Otherwise, it cannot be higher than the actual input flow at the time, reduced by the minimal transportation time.

One should be aware that in the second case each single object may (potentially) leave the output with speed v
                           out. However, if the input flow at the time when it entered was lower, there will be a gap after the output of the object, which makes the (average) flow lower than v
                           out. As a special case, the potential output flow becomes zero if the actual input flow was zero at the respective time.

Again, the respective equation
                              
                                 (3)
                                 
                                    
                                       
                                          
                                             out
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   pot
                                                
                                             
                                             (
                                             t
                                             )
                                             =
                                             
                                                
                                                   v
                                                
                                                
                                                   out
                                                
                                             
                                             (
                                             t
                                             )
                                             /
                                             
                                                
                                                   d
                                                
                                                
                                                   0
                                                
                                             
                                          
                                          
                                             if
                                             
                                             
                                                
                                                   B
                                                
                                                
                                                   out
                                                
                                             
                                             (
                                             t
                                             )
                                             ≥
                                             1
                                          
                                       
                                       
                                          
                                             out
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   pot
                                                
                                             
                                             (
                                             t
                                             )
                                             =
                                             min
                                             (
                                             in
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   act
                                                
                                             
                                             (
                                             t
                                             -
                                             
                                                
                                                   t
                                                
                                                
                                                   d
                                                
                                             
                                             )
                                             ,
                                             
                                                
                                                   v
                                                
                                                
                                                   out
                                                
                                             
                                             (
                                             t
                                             )
                                             /
                                             
                                                
                                                   d
                                                
                                                
                                                   0
                                                
                                             
                                             )
                                          
                                          
                                             else
                                          
                                       
                                    
                                 
                              
                           formalizes this. Computing B
                           out also involves the minimal transportation time td
                           . If an object entered the Material Transporter later than time t
                           −
                           td
                           , it cannot possibly reach the output at time t and hence cannot become part of the buffered output objects. If it entered earlier, it may or may not have already left the output before t, dependent on how the actual output flow reduced B
                           out. This consideration is captured by:


                           Rule 4: The change in the number of buffered output objects at time t is determined by the actual input flow at time t
                           −
                           td
                            diminished by the actual outflow at time t.

Hence, B
                           out is also obtained by integration according to equation
                              
                                 (4)
                                 
                                    
                                       
                                          dB
                                       
                                       
                                          out
                                       
                                    
                                    (
                                    t
                                    )
                                    /
                                    dt
                                    =
                                    in
                                    .
                                    
                                       
                                          q
                                       
                                       
                                          act
                                       
                                    
                                    (
                                    t
                                    -
                                    
                                       
                                          t
                                       
                                       
                                          d
                                       
                                    
                                    )
                                    -
                                    out
                                    .
                                    
                                       
                                          q
                                       
                                       
                                          act
                                       
                                    
                                    (
                                    t
                                    )
                                 
                              
                           which completes the model of the Material Transporter with buffer. Note that B
                           out is not necessarily the number of objects that form a contiguous pile in front of the output. It could be less, because the last objects that joined the pile entered later than t
                           −
                           td
                           .

Another class of machines produces an output by combining objects (CE) of different kinds, such as for instance the packaging of 20 bottles in a crate. The ratio of the number of different objects participating in this combination is usually not arbitrary, but exactly specified. This ratio links the various potential and actual inflows and the outflow, which is then limited by the “slowest” input flow (relative to the ratio of the respective object type).

The counterpart to this very generic combination element is the Separate Element (SE), with unpackers being a subclass, in which the slowest actual outflow of a separation result limits the potential inflow of the composite object.

Finally, one flow of objects may be split (SpE) into (usually) two flows (either randomly or with a preference) or generated by merging objects from two input flows (ME).

Each of the respective models describes the behavior of an individual instance of the respective element class but does not determine the actual flows, because this can only be determined from the interaction of two (or more) connected elements. For instance, if one element has a non-empty output buffer and could produce an output (out.q
                           pot
                           >0), but the next element is blocked and cannot receive input (in.q
                           pot
                           =0), then there is no actual flow at this point: out.q
                           act
                           =0. The laws for this interaction are modeled by the virtual component Transportation Connector TC. TC links the potential and actual flows of two elements.


                           Rule TC: The actual output flow of a machine MT
                              n
                            is limited by both its own potential output flow and the potential input flow of the following machine MT
                              n
                           
                           +1 (and equal to the actual input flow of this machine):
                              
                                 (5)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   MT
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             out
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   act
                                                
                                             
                                             (
                                             t
                                             )
                                             =
                                             min
                                             (
                                             
                                                
                                                   MT
                                                
                                                
                                                   n
                                                   +
                                                   1
                                                
                                             
                                             .
                                             in
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   pot
                                                
                                             
                                             (
                                             t
                                             )
                                             ,
                                             
                                                
                                                   MT
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             out
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   pot
                                                
                                             
                                             (
                                             t
                                             )
                                             )
                                          
                                       
                                       
                                          
                                             
                                                
                                                   MT
                                                
                                                
                                                   n
                                                
                                             
                                             .
                                             out
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   act
                                                
                                             
                                             (
                                             t
                                             )
                                             =
                                             
                                                
                                                   MT
                                                
                                                
                                                   n
                                                   +
                                                   1
                                                
                                             
                                             .
                                             in
                                             .
                                             
                                                
                                                   q
                                                
                                                
                                                   act
                                                
                                             
                                             (
                                             t
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        

This relatively small set of fairly generic model types turns out to cover the variety of machines in a bottling plant and also, more generally, the machines in food packaging plants that we have encountered.

Using the model presented in Section 3.2 directly for diagnosis is not appropriate. Firstly, as for all numerical models, its accuracy is only “pretended” in many respects, for example in assuming conservation laws to hold and in ignoring the imprecision in the available data, for example when flows are determined via counters or the speed of belts. Secondly, the diagnostic task requires the analysis of qualitative rather than arbitrarily small numerical deviations from the nominal behavior and hence needs to be addressed by an appropriate level of abstraction in the model. Finally, the status messages indicate only whether a machine is running or has been stopped and, hence, whether a flow is zero or non-zero, and any model that requires more detailed information cannot exploit these observations and is useless.

This level of model abstraction is appropriate for the intended goal of the diagnosis: we focused on “hard” failures (namely stopping of the filling machine) caused by hard faults (blockage of another machine), which can be based on distinguishing zero from non-zero flow only. For capturing “soft” faults (deviating behaviors) that lead, perhaps in combination, to a hard failure or a non-optimal behavior, a different model will be required. The total interruption of the flow requires distinctions between zero and non-zero flows only.

Hence, a transformation 
                           
                              R
                           
                        
                        →Sign from the domain of real numbers, 
                           
                              R
                           
                        , to the domain Sign={−, 0, +} is applied, which introduces a straightforward transformation of the numerical model introduced above to a qualitative model over the Sign domain. Each “qualitative equation” of the latter has a finite number of solutions, i.e. a finite relation over qualitative variables, which can be represented as a table. Checking the consistency of a set of finite relations can be performed by various algorithms, including so-called constraint satisfaction algorithms developed in Artificial Intelligence (see [44]).


                        Fig. 5
                         shows the result of the Sign abstraction of the numerical model: Eqs. (1) and (3) explained above yield the Constraints [1,3] on the qualitative variables, which are stated as both the abstracted qualitative equations and the respective finite relations (remember that flows and speeds cannot be negative). Eqs. (2) and (4) are omitted, because, although required for numerical simulation, they are difficult or impossible to exploit in their qualitative versions, because B(t) and B
                        out(t) can be neither observed nor predicted properly.


                        Fig. 5 also shows the Constraints [5] as the qualitative model of Transportation Connector (TC) obtained from Eq. (5). These virtual components appear between any two connected Material Transporters and machines.

The abstraction of Combination Elements (CE, such as the crate packer outlined in Section 3.2) includes the application of the three model fragments of Fig. 5 to all individual inflows as well as a constraint simply stating the qualitative equality of all inflows (the ratio of the flows drops out, because it is a positive number):
                           
                              
                                 
                                    
                                       in
                                    
                                    
                                       1
                                    
                                 
                                 .
                                 
                                    
                                       q
                                    
                                    
                                       pot
                                    
                                 
                                 (
                                 t
                                 )
                                 ]
                                 =
                                 [
                                 
                                    
                                       in
                                    
                                    
                                       2
                                    
                                 
                                 .
                                 
                                    
                                       q
                                    
                                    
                                       pot
                                    
                                 
                                 (
                                 t
                                 )
                                 ]
                                 =
                                 …
                                 =
                                 [
                                 
                                    
                                       in
                                    
                                    
                                       k
                                    
                                 
                                 .
                                 
                                    
                                       q
                                    
                                    
                                       pot
                                    
                                 
                                 (
                                 t
                                 )
                                 ]
                              
                           
                        This captures, for instance, the fact that one lacking input will stop all other inputs as well. The same applies to the outputs of Separation Elements.

We briefly demonstrate that the inferential power of the model, despite its simplicity, suffices for handling the class of faults and failures under consideration: assume that a Material Transporter MT
                           n
                         with a single speed v
                        in(t)=
                        v
                        out(t) produces an output, i.e. [MT
                           n
                        .out.q
                        act(t)]=+, but has no inflow, [MT
                           n
                        .in.q
                        act(t)]=0. Then the constraints (stated as bracketed numbers) yield:
                           
                              
                                 
                                    
                                       
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          out
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                act
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                       
                                       
                                          [
                                          5
                                          ]
                                          ⇒
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          out
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                pot
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                       
                                    
                                    
                                       
                                       
                                          [
                                          3
                                          ]
                                          ⇒
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          
                                             
                                                v
                                             
                                             
                                                out
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          
                                             
                                                v
                                             
                                             
                                                in
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                       
                                    
                                    
                                       
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          out
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                act
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                          ∧
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          
                                             
                                                v
                                             
                                             
                                                in
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                       
                                       
                                          [
                                          1
                                          ]
                                          ⇒
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          in
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                pot
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                       
                                    
                                    
                                       
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          in
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                pot
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          +
                                          ∧
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                             
                                          
                                          .
                                          in
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                act
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          0
                                       
                                       
                                          [
                                          5
                                          ]
                                          ⇒
                                          [
                                          
                                             
                                                MT
                                             
                                             
                                                n
                                                -
                                                1
                                             
                                          
                                          .
                                          out
                                          .
                                          
                                             
                                                q
                                             
                                             
                                                pot
                                             
                                          
                                          (
                                          t
                                          )
                                          ]
                                          =
                                          0
                                       
                                    
                                 
                              
                           
                        If MT
                           n
                        
                        −1 is operational, which implies [MT
                           n
                        
                        −1.v
                        out(t)]=+, then:
                           
                              
                                 [
                                 
                                    
                                       MT
                                    
                                    
                                       n
                                       -
                                       1
                                    
                                 
                                 .
                                 out
                                 .
                                 
                                    
                                       q
                                    
                                    
                                       pot
                                    
                                 
                                 (
                                 t
                                 )
                                 ]
                                 =
                                 0
                                 ∧
                                 [
                                 
                                    
                                       MT
                                    
                                    
                                       n
                                       -
                                       1
                                    
                                 
                                 .
                                 
                                    
                                       v
                                    
                                    
                                       out
                                    
                                 
                                 (
                                 t
                                 )
                                 ]
                                 =
                                 +
                                 
                                 [
                                 3
                                 ]
                                 ⇒
                                 [
                                 
                                    
                                       MT
                                    
                                    
                                       n
                                       -
                                       1
                                    
                                 
                                 .
                                 in
                                 .
                                 
                                    
                                       q
                                    
                                    
                                       act
                                    
                                 
                                 (
                                 t
                                 -
                                 
                                    
                                       t
                                    
                                    
                                       d
                                    
                                 
                                 )
                                 ]
                                 =
                                 0
                              
                           
                        This means, even without information about the buffers, that the lack is propagated backwards across the models of correct elements (but will be consistent with a “blocked” mode, for instance), as expected.

A solution to fault localization in bottling plants based on the models and consistency-based diagnosis as introduced above has to address some fundamental problems:
                              
                                 •
                                 
                                    Focusing on relevant faults: disruption in the operation of the various machines and conveyors occur frequently, due to manual intervention or physical problems. Most of them are irrelevant, because they do not affect the crucial component, i.e. the filling machine. Hence, there is no use in globally searching the data for evidence for disturbances in the components. Only if the filler is interrupted due to an external cause, a search for this cause is triggered.

Diagnosis with incomplete observations: while many of the controlled machines supply data about their status, not all of them do, and sometimes the messages are not compliant with the standard and cannot be used for diagnostic purposes. In particular, conveyors usually do not provide data. Also, as stated before, the available status data imply only binary (no numerical) information about the presence of a flow of objects.


                                    Coping with delays: interruptions of flows propagate across the components of the plant with non-negligible delays, as captured by the model of Material Transporter in Table 1. The delays can range for fractions of a second, e.g. in the labeling machines, to the order of 15min in the conveyors with large buffers. The space of the relevant time points is practically infinite. This creates a problem for exploiting finite constraint satisfaction techniques for the consistency check that is needed for consistency-based diagnosis. We solved this by a technique for factorizing out time and use timeless constraints for the consistency check.


                                    Handling uncertainty of delays: the delay times are highly uncertain, due to noise (e.g. removed bottles) and unknown states of components (in particular, the number of stored objects in buffers, which is neither measurable nor predictable). One has to assume (conservatively) intervals for the value of the actual delays. This raises the problem of growing intervals upon propagation across several components. Our solution focuses on propagating only the start of some interrupted flow and exploits retrieved observations to narrow down the relevant time intervals.


                           Fig. 6
                            shows the general architecture, modules, and information flow of the diagnosis solution, which exploits the diagnosis models presented in Section 3.3. Firstly, the Symptom Scanner requests the Data Interpreter to check for the presence of a set of symptoms in a certain time period. The Data Interpreter takes the request to search for evidence for these symptoms in a standardized database, and returns all time periods for a confirmed symptom, a negative result, or some undecided status. Currently, the only symptom considered is a stop of the filling machine and the database is scanned for the presence of this kind of symptom only. Whenever a symptom has been detected, it is passed, along with temporal information, to Diagnosis, which generates fault hypotheses that could explain a symptom. It does so, in a loop, by letting the Predictor constrain more values based on the next connected component models. With these values, the Predictor is searching the database for evidence or refuting information in terms of status data of the various machines indicating either a local disturbance or the effect of a propagated one (lack or tailback) in an appropriate time window. From the retrieved data (or, rather their abstract meaning), the DiagnosisEngine, RAZ’R [41], a consistency-based diagnosis engine as mentioned in Section 3.1, generates fault hypotheses, if possible. Otherwise, predictions are continued along the chain of components. In this case, the model of correct behavior generates predictions concerning the behavior of the next machine(s), which are then checked against data retrieved from the database. Propagation is also continued if there is no information available or if it is too weak.

When refuting or confirming observations are found, their temporal extensions are used for the next prediction step, replacing the original predictions. This is important, since model-based temporal prediction has to be very conservative, i.e. generate large intervals due to the uncertainty in the delays of propagated effects in order to guarantee that no evidence is missed. Using the observed time periods wherever available restricts widening of the time intervals significantly.

Each component (Ci) has only two behavior modes OK(Ci) and Faulty(Ci), which have fairly simple models. Besides Constraints [1] and [3], the OK model of a Material Transporter with single input and output that it is operational. This means there is either an unrestricted flow (row 1 in Table 2
                           ) or, otherwise, there is either a lack at the input causing zero output (row 2) or a tailback, which is propagated to the input (row 3). Note that the latter two cases are undesirable, but due to a cause external to the component and, hence, part of its OK mode.

The fault mode of a machine, i.e. Material Transporter without buffer) simply states that there is no potential (and, therefore, no actual flow) (Table 3
                           ) while a conveyor (a Material Transporter with buffer) that is blocked somewhere may still allow an inflow (filling the buffer) or outflow (emptying it), as shown in Table 4
                           .

Models of components with multiple inputs or outputs are slightly more complex, but not different in the underlying principles.

In order to be processed by the model, status messages in the recorded data have to be encoded as value restrictions on model variables. This is straightforward as shown in Table 5
                            for single input and output.

The table indicates that the first three rows are consistent with the OK model (Table 2), while the last one is identical to the fault model (Table 3).

For multiple inputs or outputs, the status message may indicate which of them suffers from a tailback or lack.

We illustrate the operation of the system by considering two steps in the loop (depicted in Fig. 7
                           ). We assume that for component C17, its observed message “Lack” indicates that the actual inflow to the component is zero (C17.in.q
                           act
                           =0) for some time interval i17
                           =[si17, ei17] and non-zero before. Since C17.in.q
                           pot
                           =+(because C17 was not stopped for internal problems and could have taken in objects), the model predicts B16.out.q
                           pot
                           =0 for the conveyor B16, which supplies C17. Conveyors usually do not produce data, and the OK model of B16 propagates the lack, i.e. predicts B16.in.q
                           pot
                           =+ and B16.in.q
                           act
                           =0 for some time interval in i16
                           =[si17, si17]+
                           d
                           16
                           =[si17, si17]+[sd16, ed16]=[si17
                           +sd16, si17
                           +ed16], where d16 is an interval that is guaranteed to contain the actual delay across B16. This implies C15.out.q
                           pot
                           =0 for a subinterval of i16, i.e. C15 was not able to supply the connected conveyor B16.

Having reached the downstream component C15, there are four different cases to be considered:
                              
                                 1.
                                 There are no data available about C15 (either in general or for the relevant period), then its OK model will propagate the lack just as B16 did (and expand the interval further). The respective prediction has the support {OK(B16), OK(C15)}. Whenever the resulting model-based predictions contradict observations in a future step, these two components (and, perhaps, additional ones) may occur in fault hypotheses.

There are data
                                    
                                       
                                          2.1.
                                          
                                             Refuting the predictions (if the status of C15 is “Operating” or “Taliback”, this implies C15.out.q
                                             pot
                                             =+). Then {OK(B16)} is inconsistent and the DiagnosisEngine produces the only fault hypothesis that B16 is the cause of the disturbance.


                                             Consistent with the predictions. Then
                                                
                                                   2.2.1.
                                                   either the data state an internal fault of C15, and the DiagnosisEngine generates the fault hypothesis 
                                                         
                                                            ¬
                                                         
                                                      OK(C15),

or C15 is in state “Lack”. Then there is an observed time interval i15, for which C15.in.q
                                                      act
                                                      =0 and C15.in.q
                                                      pot
                                                      =+. This is the same situation as the one we started from and the system reiterates the steps. This case is depicted in Fig. 7.

The example also motivates the applied technique of temporal factorization: we separate the calculation of the temporal relationships (needed to focus the access to the data base) from the consistency check, which only needs to test whether the respective variable values are consistent. In other words, we directly use the third table in Fig. 5 and ignore the temporal dependency, i.e. we do not associate a temporal index with the values.

Of course, this will cause spurious inconsistencies, if the propagation may infer or retrieve values for the same variable at different times, which could be different. We address this by duplicating components (and, thus, their variables) that the scheme described above may visit more than once. In our application, this is very restricted regarding time and structure, and can be analyzed beforehand.

@&#RESULTS@&#

Firstly we validated the basic component models described in Section 3.2. We implemented them as numerical simulation models in MATLAB/SIMULINK® [45] and compared the simulated behavior (using the solver “ode4” (Runge–Kutta) with a fixed step size of one second) to the behavior of real plants. Every component was modeled using the relevant equations (see Table 1), and the model was tested in isolation to check whether it was adequate and stated in a context-independent manner, which is a prerequisite for compositionality. In a second step, a model of a complete plant was configured using the validated components.

To test the individual components, values of single parameters and variables were varied and the response of the simulated behavior was monitored. For example, the predicted changes in the buffered material B of a component for different values of the input speed v
                        in and the output speed v
                        out are shown in Fig. 8
                        . It is shown that the buffer fills as long as the input speed is higher than the output speed (assuming a sufficient supply), whereas when the input speed reduces to its minimum of 0.1 and the output speed is still high the quantity of buffered objects decreases.

Due to the minimal transportation time td
                         of the component, the buffer is not completely emptied, as long as there is input available. Furthermore, only the objects represented by the variable B
                        out determine the existence of an output flow. Another real characteristic behavior can be reproduced by increasing the input speed whilst keeping the output speed constant. Although v
                        in is still higher than v
                        out, the buffer filling degree remains constant after a certain time, because it is limited by the maximum capacity of the component. Similar results were achieved by testing the other component type models, providing evidence that the models capture the features relevant to the diagnostic task and do not violate context-independence.

The second challenge was validation by comparing the simulated behavior of a plant model to the behavior of a real plant (Plant A). Several test cases were constructed, based on real-world downtime scenarios of the bottling plant whose topology is shown in Fig. 9
                        .

The simulated plant consists of a primary flow of bottles and a secondary object flow of crates. In one test case, the downtime propagation of a failure of the crate washer was simulated and analyzed. This failure affects both object flows. After some delay, missing input occurs at the crate packer. Also the unpacker stops at some point, due to one of its outputs being blocked. The details of the propagation of failure depend on the capacities and filling degrees of the various buffers connecting the machines. For instance, if the crate magazine is empty and all other buffers are filled to a sufficient degree, the lack of crates will rapidly reach the crate packer. This causes blockage of the labeling machine and the bottle filling machine (because the packer is not able to process the bottles) before the lack of bottles in the primary flow (caused by the inoperable unpacker) reaches the filling machine. In contrast, if the crate magazine is completely full, the crate packer keeps working for some time, and the filling machine will stop due to a lack of bottles. Even for this complex scenario, the simulation model reproduces the behavior of the real world plant. Similarly, the characteristics of fault propagation occurring in real plants were predicted for other relevant scenarios.

Secondly we evaluated the diagnosis solution based on the implemented qualitative component models (see Section 3.3). We followed two routes. One was comparison with fault localization on two real plants (Plants “A” and “B”) performed by human experts. Since it is difficult and time-consuming for them to do this based on the recorded data (which is actually what motivated the project), the reference diagnoses were obtained by direct on-site observation. A number of experts observed the plant and immediately tried to identify the causes of filling machine stops. Thus, a protocol was created that contains disturbances of the Bottle Filling machine as symptoms with relevant time intervals, and with manually associated causes of each symptom. This protocol served as the reference symptom cause for assessing the quality of the diagnosis result produced by the diagnosis solution. Obviously this could not be done for longer periods than a few days, but it nevertheless produced a set of more than a hundred relevant cases for the evaluation.

As one cannot expect to encounter all kinds of interesting cases in a limited time (and in the chosen plants), the second way of evaluation was performed by simulation. For this purpose, a model of the real plant A (see Fig. 9) was created for discrete event simulation and named Plant “C”. It was represented in the software tool “Plant Simulation” [46] and its behavior was verified against the real plant. With the help of this simulation environment, we generated data for a set of 77 additional non-trivial virtual cases of disturbances for comparison with the results. The evaluation checked for what we call compliance, i.e. whether the relevant symptoms (filling machine stops) were accurately detected and whether the real (observed or simulated) causes were diagnosed. Table 6
                         summarizes the statistical evaluation of the results.

During the observation period only 67, mostly trivial, filling machine stops of plant A occurred. Unfortunately plant A produced a fairly insufficient database. Bad data included even erroneous state messages of machines. Despite this, 7 of 11 non-trivial symptom causes could be diagnosed correctly.


                        Plant B was designed in accordance with a data acquisition standard (see [47]) which resulted in much better quality of the automatically acquired machine data. Nevertheless, even for this plant some obviously bad data had to be processed. Due to the fact that data was available for four production days, the statistical evaluation of the diagnosis results of plant B can be seen as a representative example indicating the quality of results based on an appropriate database. Indeed, 88.7% of the non-trivial symptom causes were diagnosed correctly.

In sum, the two real plant case studies (plant A and plant B) showed a compliance of 87.1%. So 87.1% were correctly diagnosed.

The data of the simulated plant C have been generated completely and free of errors. Based on this all of the 80 simulated non-trivial symptom causes of plant C were correctly diagnosed.

To illustrate the complexity of the diagnosis task, we present two exemplary non-trivial scenarios from the evaluation. While blockage of machines or conveyors directly downstream or upstream from the filling machine are frequent causes of lacks or tailbacks, disturbances may propagate via several machines and conveyors not only on the main-branch of the production line (involving the bottles) but also via its sub-branches. In the first scenario taken from the simulated plant (“plant C”), a disturbance at the crate washer was the origin of a lack of bottles at the bottle filling machine via the following causal chain displayed in Fig. 9:
                           
                              •
                              the disturbance at the crate washer causes a tailback of crates, which ultimately reaches and stops the crate unpacker;

the stopped crate unpacker interrupts the flow of bottles, causing a lack which propagates successively to the sniffer block, bottle washer, empty bottle inspector, and, finally, to the bottle filling machine.


                        Fig. 10
                         shows a Gantt chart of the failure scenario. This is the main aid today for experts in their diagnosis process. Every line represents the operating states of a certain machine within a defined time interval. The lines marked with arrows are of particular interest because they show the failure propagation through the plant. The manual localization is considered complicated because the disturbance originated from the crate line up to the bottle filling machine. The diagnosis solution correctly localized the crate washer as the origin of the symptom.

The second scenario (shown in Fig. 11
                        ) is taken from the diagnostic data of the real plant A, which was quite poor data quality. It illustrates the capabilities of the model-based diagnosis solution even under such conditions. A defective checkmat (a crate inspection machine) upstream from the crate unpacker caused a tailback of bottles at the bottle filling machine as follows:
                           
                              •
                              a lack of crates propagates and successively stops the crate unpacker, crate washer, crate magazine, and crate packer;

the stopped crate packer produces a tailback of bottles, which propagates via the labeling machine to the bottle filling machine.

Despite the completely non-observable crate line between the crate unpacker and crate packer (Crate flow (CF) section of Fig. 11), the system model produced predictions for this section and enabled the diagnosis system to produce a proper fault localization, namely the upstream process component which contains the defective checkmat, but did not allow further discrimination due to the lack of data. This example shows that the diagnosis solution provides the best possible results even if the available data is incomplete or not available for some components.

The results have triggered significant interest from both end users (breweries, etc.) and suppliers. This demonstrates that the diagnosis solution addresses the needs explained above by localizing the interruptions of transportation causing downtime of the filling machine based on the available data from the machines (collected over a period of days to months) stored in a database. The goal of the research project was to find a solution for automatic fault diagnosis in bottling plants. This solution needed to be affordable for the potential end users, which are mostly small or medium-sized enterprises. Additionally it had to be easily adaptable to different plant layouts and to changes to the plant structure. We met these requirements by following the model-based approach and developing a new method for considering time propagation. This enabled us to use a readily available standard algorithm for consistency-based diagnosis. The necessary flexibility was gained by conceptual separation of the representation of the plant structure and the diagnosis algorithm.

The correctness of the diagnosis (an average of 87.1% was determined for the two real plants that were considered) already makes it a useful tool in practice, but there is still scope for further improvement. Wrong diagnosis results were often caused by errors in the database, inexact manual downtime analysis, or plant-specific critical points which were just too difficult to find automatically (missing observation data for the specific problem). If there are missing data, for example, due to a communication failure of a machine, the diagnosis algorithm may find several fault hypotheses that are compliant with the data. A plant usually comprises machines from different suppliers, all coming with their own control systems and specific data. Since it is not feasible for end users to generate a homogeneous set of data from these different sources, work was undertaken by one of the project partners to establish a standard for production data acquisition (PDA) in bottling plants, resulting in the so-called “Weihenstephaner Standard 2005” (WS2005, [47]). This standard is now widely accepted and will be an essential prerequisite for successful diagnosis solutions in the future. The project’s results have already led to extension of this standard for diagnosis purposes. The extended WS2005 standard includes data points such as:
                        
                           •
                           Operating states of machines according to WS2005.

Maximal output rate setting of machines.

Object counters (input, output, or rejection).

Information about mechanical barriers.

Assignment of jam switches or buffer filling degrees, if available.

Transportation or machine speeds, if available.

The standard specifies an optimal set of data but in practice many machines provide only a small subset or no data at all, different suppliers may interpret and handle the data differently (e.g. counters in a cumulative or incremental way), and erroneous data may even be present.

The LineMod research project discussed here solely considered reasons for filling machine downtimes, and only those within the plant, and thus has a number of limitations:
                        
                           •
                           LineMod focused only on “hard” failures (stop of bottling filling machine) caused by hard faults (zerozero flow). For capturing “soft” faults (e.g. reduced output) which lead, perhaps in combination, to a hard failure or non-optimal behavior, a different model is required.

Many efficiency losses are not caused by technical components but rather by logistic processes downstream or upstream of the plant. To analyze such situations, we need to extend the plant model.

Sometimes machine downtimes could not be assigned to the actual cause, because a machine treated objects incorrectly (e.g. improper cleaning of dirty bottles). The effect of the defective treatment may become evident only after some time period at another machine (e.g. the empty bottle inspector, which will reject a large number of bottles, thus potentially reducing the available input to the filling machine). The impact of the process steps on the objects is not included in the LineMod model, which prevents the algorithm from identifying the real downtime cause.

Filling machine downtimes are often caused by a combination of disturbances of different machines. In such situations, the diagnosis has to generate more sophisticated fault hypotheses.

@&#ACKNOWLEDGMENTS@&#

We would like to thank all colleagues involved in the LineMod project from the Model-based Systems and Qualitative Modeling Group (MQM) and the Department of Food Packaging Technology (LVT). Special thanks go to B. Ertl who produced the first version under high time pressure and to A. Kather for his outstanding work for this project. We are also indebted to the end users and suppliers for their outstanding support. O. Dressler from OCC’M Software, which provided the diagnosis engine and also gave technical support, deserves a special mention and contributed greatly to the success of the project. Finally, we wish to thank the Federal Ministry of Economics and Technology – Germany for their financial support. The LineMod (233 ZBG/1) research project was sponsored via the AiF by the IVLV, Wifoe, and FKM under the program to promote joint industrial research and development (IGF).

@&#REFERENCES@&#

