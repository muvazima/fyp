@&#MAIN-TITLE@&#A new mixed integer program and extended look-ahead heuristic algorithm for the block relocation problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a new mathematical formulation for the block relocation problem (BRP).


                        
                        
                           
                           New formulation has better runtime performance than other formulations.


                        
                        
                           
                           We present the first computational results for two math programs of the BRP.


                        
                        
                           
                           We introduce a new look-ahead algorithm (LA-N) for the BRP.


                        
                        
                           
                           LA-N algorithm generally outperforms all other algorithms from the literature.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Logistics

Block relocation problem

Seaport container terminal

Mixed integer programming

Look-ahead algorithm

@&#ABSTRACT@&#


               
               
                  This paper considers the block relocation problem (BRP), in which a set of identically-sized items is to be retrieved from a set of last-in-first-out (LIFO) stacks in a specific order using the fewest number of moves. The problem is encountered in the maritime container shipping industry and other industries where inventory is stored in stacks. After surveying the work done on the BRP, we introduce “BRP-III”—a new mathematical formulation for the BRP—and show that it has considerably fewer decision variables and better runtime performance than the other formulation in the literature. We then introduce a new look-ahead algorithm (LA-N) that is an extension of the algorithms from the literature and show that the new algorithm generally obtains better solutions than the other algorithms and has minimal CPU runtime.
               
            

Today most overseas shipping of finished consumer goods is done via 20-, 40-, or 45-foot long steel containers aboard deep-sea container vessels. In addition, the amount of meat, fish, fruit, vegetables, and general foodstuffs shipped in refrigerated containers continues to increase. The efficient storage, handling, and retrieval of shipping containers in seaports and on container ships is therefore an important component of global supply chain management.

In this paper, we consider a problem related to the handling of steel shipping containers called the block relocation problem (BRP). The BRP is an important problem at logistics facilities such as seaport container terminals where overhead gantry cranes,straddle carriers, and/or reach stackers sort and stack containerized cargo that awaits a future journey (Fig. 1
                     ).

The BRP is defined as follows. Consider C containers (blocks, items) numbered 1 to C that are temporarily stored as inventory. Due to space limitations, these containers are stacked directly on top of each other in a storage bay consisting of S last-in-first-out (LIFO) stacks. As the time to move this inventory approaches, management learns that the containers must be retrieved from the bay according to the sequence 1,2,3,…,
                     C. In other words, container 1 must be retrieved first; container 2 must be retrieved second, and so on. Containers that have not been retrieved must remain in one of the bay’s S stacks until their retrieval time arrives. The goal is to retrieve all C containers from the bay using the minimum number of moves, where a move is either a direct retrieval, in which a container is permanently taken out of the bay, or a relocation (reshuffle, shift), in which a container is moved from one stack to another stack. A container may only be moved when no other container is above it. Also associated with the problem is a maximum stack height, mxHeight, which gives the maximum number of containers that can be in any stack at any time. This limitation is important when height is limited by a ceiling or other predetermined limit such as the height of a material handling crane. Note that there is essentially no maximum stacking height when mxHeight
                     ⩾
                     C.

The most challenging aspect of the BRP is deciding when and how to relocate containers (blocks) so as to minimize the total number of moves. Hence the name “block relocation problem.” Fig. 2
                      shows three possible solutions to an instance of the BRP where C
                     =9 and S
                     =3. In solutions (i) and (ii), there is no height limit (i.e. mxHeight
                     =9). In solution (iii), there is a height limit mxHeight
                     =5. Solutions (i), (ii), and (iii) use 16, 15, and 17 moves respectively.

This paper is organized as follows. Section 2 reviews the relevant literature. In Section 3, we present “BRP-III”—a new mathematical formulation of the BRP—and compare its performance to the other formulation in the literature. In Section 4, we introduce a new look-ahead algorithm (LA-N) for the BRP that is an extension of the algorithms from the literature. In Section 5, we show that the new algorithm generally obtains better solutions than the other algorithms from the literature and has minimal CPU runtime. We conclude in Section 6.

@&#LITERATURE REVIEW@&#

There are several studies in the literature concerning the optimal storage, handling, and retrieval of items stored in stacks that predate the onset of research on the BRP. Sculli and Hui (1988) consider how the dimensions of a three-dimensional storage area—for example, the number of stacks and the maximum allowed stacking height—affect the number of moves needed to retrieve containers from the storage area. Gupta and Nau (1992) prove the NP-hardness of a more general problem than the BRP, called the blocks-world planning (BWP) problem, in which the final container configuration is any feasible stack configuration, not necessarily an empty bay. de Castilho and Daganzo (1993) develop general expressions for the expected number of moves required to retrieve a container from storage stacks under two different general storage strategies but do not evaluate systems that make decisions regarding individual containers. Kim (1997) computes the expected total number of moves required to empty a yard bay under probabilistic conditions where there is no advanced knowledge of container retrievals and each container is equally likely to be the next one retrieved from the bay. Avriel, Penn, Shpirer, and Witteboon (1998) consider how best to stow containers (assign containers to cells) in container vessels so as to minimize the number of container relocations required when unloading and loading vessels at port.

The BRP as described in Section 1 began receiving attention by academics only recently. Thus far, only a handful of contributions have been made by researchers whose application area is the maritime container shipping industry. For the most recent and comprehensive surveys of the container shipping literature, please see Stahlbock and Voß (2008) and Steenken, Voß, and Stahlbock (2004). Li, Wu, Petering, Goh, and de Souza (2009) is an example of research on container shipping that involves this article’s first author and was recently published in this journal.

The authors are aware of nine previous published and unpublished studies of the BRP. Petering (2004) develops a mathematical formulation for the BRP that is not as economical as the one presented in Section 3.1. Petering, Seo, and Lee (2005) develops a heuristic algorithm for the BRP (which we will call the LA algorithm). However, neither document has been submitted for publication.


                     Kim and Hong (2006) published the first paper on the BRP. They suggest two methods for determining where to relocate blocks. The first method is a branch and bound algorithm, and the second method is a heuristic (which we call the KH algorithm) that uses an estimator for the expected number of additional relocations in each stack. Numerical results show that the number of relocations calculated by the KH algorithm exceed the number found by branch and bound. However, the computational time used by the KH algorithm is far less than that consumed by branch and bound.


                     Aydin (2006) and Aydin and Ünlüyurt (2008) consider the basic BRP and several extensions. They develop a difference heuristic (which we call the DH algorithm) for solving difficult instances of the BRP. They also introduce the concept of a cleaning move. Let us use the term target block (target container) to refer to the next block to be retrieved (i.e. removed) from the storage bay. A cleaning move is the relocation of a block that is not in the target block’s stack. Although cleaning moves are not part of the DH algorithm, the authors show that these moves may reduce the total number of moves needed to empty a storage bay in some cases.


                     Caserta, Schwarze, and Voß (2012) prove that the BRP is NP-hard and develop two mathematical formulations of the BRP. Formulation BRP-I (BRP-II) allows (forbids) cleaning moves. They also independently devise the same LA algorithm that was devised by Petering et al. (2005), and show that this algorithm outperforms the KH algorithm over a range of small- and medium-scale problem instances. Caserta, Voß, and Sniedovich (2011) present a corridor method inspired algorithm (which we call the CM algorithm) for the BRP and show that it outperforms the KH algorithm over a range of small-, medium-, and large-scale problem instances. Caserta, Schwarze, and Voß (2009) develop a binary description of the BRP; devise the name “look-ahead” for the LA algorithm devised in Caserta et al. (2012); and show that the LA algorithm outperforms both the KH and CM algorithms for large-scale problem instances. It should be noted that none of the algorithms KH, DH, LA, or CM allow cleaning moves. Note that we have adopted the name “look-ahead” for both the LA algorithm from the literature and the new LA-N algorithm that we introduce in Section 4. It will later be shown that the LA-N algorithm when N
                     =1 is virtually identical to the LA algorithm.


                     Lee and Lee (2010) present a three-phase heuristic (which we will call the LL algorithm) for optimizing the working plan for a crane to retrieve all the containers from a given storage area, which may have one or more adjacent bays, in a specific order. For the single bay case, the problem is identical to the BRP and it is shown that the LL algorithm outperforms the KH algorithm on several large problem instances.

The purpose of this study is threefold. First, we present “BRP-III”—a new mathematical formulation of the BRP—and show that it outperforms formulation BRP-I from Caserta et al. (2012). Second, we introduce a new look-ahead algorithm (LA-N) that draws upon two ideas: (1) the LA algorithm that was independently devised by Caserta et al. (2012) and Petering et al. (2005) and (2) the cleaning move concept introduced by Aydin (2006) and Aydin and Ünlüyurt (2008). We then show that the LA-N algorithm generally obtains better solutions than all of the non-LA algorithms (including the KH, DH, CM, and LL algorithms) and has minimal CPU runtime. Finally, by performing the most comprehensive comparison of algorithms for the BRP that has been done to date, we also hope to unify the literature on the subject to allow future research on this topic to proceed in an organized fashion.

We now present BRP-III—a new mixed integer linear programming formulation of the block relocation problem—and use CPLEX to compare its performance to the other formulation in the literature—formulation BRP-I devised by Caserta et al. (2012).

“BRP-III”—a new mixed integer programming formulation of the BRP—is presented in Tables 1–4
                        
                        
                        
                        . These tables present the (1) indices, (2) parameters, (3) decision variables, and (4) mathematical program respectively. Indices t and w represent time intervals (turns). A maximum of one container may be moved during a time interval (constraint (11)). The objective is to take the last container, container C, out of the bay as soon as possible, i.e. during the earliest possible time interval. Note that the three-index decision variables take real values, not binary or integer values (Tables 3 and 4). Thus, the number of integer variables has been kept to a minimum.

The constraints are divided into three groups: constraints (1)–(4), constraints (5)–(23), and constraints (24)–(29). The first group of constraints introduces most of the decision variables and shows why some variables can be defined as real variables instead of binary or integer variables. The second group places basic limitations on the values of the decision variables. The third group establishes important relationships between two or more kinds of decision variables.

We now consider the first group of constraints. Constraints (1a)–(1d) allow R
                        
                           c,s,t
                         to be real but force it to be either 0 or 1. Constraints (1e) and (1f) further define the proper relationship between R
                        
                           c,s,t
                         and R
                        
                           s,t
                        , and between R
                        
                           c,s,t
                         and M
                        
                           c,t
                         respectively. Constraints (2a)–(2d) allow P
                        
                           c,s,t
                         to be real but force it to be either 0 or 1. Constraints (2e) and (2f) further define the proper relationship between P
                        
                           c,s,t
                         and P
                        
                           s,t
                        , and between P
                        
                           c,s,t
                         and M
                        
                           c,t
                         respectively. The difference between constraints (1f) and (2f) is that a container is always removed from a stack, but need not be placed onto a stack, during a turn in which it is moved. Indeed, it might be permanently taken out of the bay. Constraint (3a) initializes the X
                        
                           c,s,t
                         variables with the proper values. Constraint (3b) ensures that the X
                        
                           c,s,t
                         variables are updated in the appropriate manner during each time interval based upon the placements or removals of containers during that time interval. Note that R
                        
                           c,s,t
                        , P
                        
                           c,s,t
                        , and initialSetup
                        
                           c,s
                         only take the values 0 or 1, so constraints (3a)–(3c) allow X
                        
                           c,s,t
                         to be real but force it to be either 0 or 1. Constraint (4a) initializes the B
                        
                           c,t
                         variables with the proper values. Constraint (4b) ensures that the B
                        
                           c,t
                         variables are updated in the appropriate manner during each time interval based upon whether containers get further away or closer to the top of their respective stacks during that time interval. Note that F
                        
                           c,t
                        , C
                        
                           c,t
                        , and initialBury
                        
                           c
                         are binary, so constraints (4a)–(4c) allow B
                        
                           c,t
                         to be real but force it to take integer values.

We now consider the second group of constraints. Constraint (5) states that each container can only be in 0 or 1 stacks at any point in time. Constraint (6) states that a stack can accommodate at most mxHeight containers at any point in time. Constraints (7) and (8) ensure that two adjacent stacks never differ in height by more than two containers. These safety constraints are not included in the model devised by Caserta et al. (2012) and are therefore not enforced by the algorithms discussed in Section 4 or the experiments that test this formulation later in this section. Constraint (9) keeps the value of B
                        
                           c,t
                         in the allowable range at all times. This constraint may be redundant. Constraint (10) ensures that each container is moved at least once. This constraint may be redundant. Constraint (11) ensures that no more than one container is moved during each time interval. This constraint, combined with constraints (1b) and (2b), implies that the container that is placed onto a stack (if any) must be the same container that is removed from a stack in any particular turn. Constraint (12) states that there should be exactly one container move during each of the first C time intervals. This constraint is redundant but its inclusion in the formulation may help an optimizer find an optimal solution more quickly. Constraint (13/14) ensures that the maximum “total amount of container movement (closer to/farther from) the top of stacks” during each time interval is mxHeight. Such movement is maximized when a container is (removed from/placed onto) a stack of the maximum height. In such a case, all containers in the stack get one step (closer to/farther from) the top of the stack. Again, constraints (13) and (14) are redundant but may be useful to include in the formulation. Constraint (15) ensures that the “total amount of movement closer to the top of a stack over container c’s lifetime in the bay” equals initialBury
                        
                           c
                        . Constraint (16) states that no more than one container can be taken out of the bay during each turn. Constraint (17) ensures that each container is taken out of the bay exactly once. Constraint (18) states that containers must be taken out of the bay in the proper sequence, i.e. in order of increasing container number. Constraint (19) ensures that no more than one container is removed from a stack during each time interval. Constraint (20) states that exactly one container should be removed from a stack during each of the first C time intervals. This constraint is redundant but its inclusion in the formulation may help an optimizer find an optimal solution more quickly. Constraint (21) states that a placement may only take place during a turn if a removal also takes place during the same turn. Constraint (22) forbids the placing of a container back onto the stack from which it was removed during the same turn. This constraint may help an optimizer find an optimal solution more quickly. Constraint (23) states that a placement of a particular container may only take place during a turn if a removal of the container also takes place during the same turn. This constraint is redundant but its inclusion in the formulation may help the optimizer find an optimal solution more quickly.

We now consider the third group of constraints. Constraint (24) ensures that a container can be removed from a particular stack only if the container is located in that stack. Constraint (25) ensures that only containers on the top of a stack (or that have already taken out of the bay) may be moved. Note that B
                        
                           c,t
                        
                        ⩾2 implies that M
                        
                           c,t
                        
                        =0. On the other hand, B
                        
                           c,t
                        
                        ⩽1 does not impose any restrictions on M
                        
                           c,t
                        . Thus, the only way for binary variable M
                        
                           c,t
                         to be 1 is for B
                        
                           c,t
                         to be either 0 or 1. In other words, container c can be moved during time interval t only if it is either on the top of a stack (B
                        
                           c,t
                        
                        =1) or outside the bay (B
                        
                           c,t
                        
                        =0) at the beginning of time interval t. Constraints (26)–(27) link T
                        
                           c,t
                         to the other decision variables. Constraint (26) states that moving a container is a precondition for taking a container out of the bay. Constraint (27) states that, if a container is removed from a stack but not placed into a stack during a particular time interval, then it must be taken out of the bay during that time interval. Constraints (28a)–(28c) link C
                        
                           c,t
                         to the other decision variables. These constraints state that if any two of X
                        
                           c,s,t
                        , R
                        
                           s,t
                        , and C
                        
                           c,t
                         equal 1, then the third also equals 1. Constraints (29a)–(29c) link F
                        
                           c,t
                         to the other variables. These constraints state that if any two of X
                        
                           c,s,t+1, P
                        
                           s,t
                        , and F
                        
                           c,t
                         equal 1, the third also equals 1.

It should be noted that formulation BRP-III has considerably fewer integer decision variables than the BRP-I formulation presented by Caserta et al. (2012). Table 5
                         shows the number of decision variables in each formulation for different problem instances.

Formulation BRP-I developed by Caserta et al. (2012) and formulation BRP-III introduced here—with the safety constraints (7) and (8) omitted—were coded into C++ using ILOG Concert Technology and tested on small problem instances using CPLEX 12.4. A total of 50 problem instances were considered—10 each with 5, 6, 7, 8, and 9 containers. Text or spreadsheet files containing all instances are available from the authors upon request.


                        Table 6
                         shows the results, which were obtained using a computer with 4gigabytes of RAM, the Windows 7 Home 32-bit operating system, and an Intel Core i7 processor with eight 2.80gigahertz cores. This is the first presentation of computational results for formulation BRP-I developed by Caserta et al. (2012). The first five columns show the values of the main input parameters for each instance and the final five columns show the experimental results when each instance is solved using CPLEX 12.4 with default settings. The “LP relax” columns show the optimal values of the LP relaxations of the two formulations; the values shown for BRP-III—a minimization problem—are the true values and those shown for BRP-I—a maximization problem—have been converted to allow a fair comparison. Parameter W in each instance equals the number of moves needed to empty the bay when decisions are made by the LA-1 algorithm (which is introduced in the next section). This number is an upper bound on the minimum number of moves required to empty the bay; setting W equal to this value prevents the creation of unnecessary decision variables and constraints when the mathematical formulation is built in C++ prior to being solved by CPLEX. Although the time needed to identify an optimal solution could be reduced by providing the feasible solution found by the LA-1 algorithm to CPLEX, the results in Table 6 were obtained without providing a feasible solution to the solver.

The results strongly indicate that formulation BRP-III outperforms formulation BRP-I. The LP relaxation of formulation BRP-III almost always produces a bound that is less tight than that of formulation BRP-I. However, formulation BRP-III has significantly fewer (integer, general) decision variables than BRP-I. This latter fact means that BRP-III achieves shorter LP solution times at each node, and explores fewer nodes, in the branch-and-cut tree. Overall, the runtime used by CPLEX to identify an optimal solution is usually less—and sometimes much less—when model BRP-III is used instead of model BRP-I. Note that the LA-1 algorithm finds the optimal solution in most cases and provides a good upper bound on the optimal number of moves. However, the lower bound obtained by solving the LP relaxation of BRP-III is very poor, and the bound obtained by solving the LP relaxation of BRP-I is not much better.

Unfortunately, the results indicate that a math programming approach is not sufficient for real-world use. Container bays in the real world typically store up to 30 containers. Yet, CPLEX needs almost an hour to find the optimal solution for the 9-container instance 9-1 using formulation BRP-III. Clearly, another approach is needed for solving large problem instances.

The difficulties experienced with math programming led the authors to search for heuristic techniques to address the BRP. This search resulted in the development of a new look-ahead algorithm (LA-N). The new LA-N algorithm extends the basic LA algorithm, that was independently developed by Caserta et al. (2012) and Petering et al. (2005), by allowing for “cleaning moves” (see Aydin (2006) and Aydin & Ünlüyurt (2008)).

We now review the basic LA algorithm from Caserta et al. (2012) and Petering et al. (2005). The LA algorithm is shown below. Note that mxHeight is not mentioned in the algorithm. In other words, it is implicitly assumed that mxHeight
                        ⩾
                        C. Fig. 2i shows the sequence of moves made by the LA algorithm for a 9-container problem instance. Fig. 3
                         illustrates the decisions made by the LA algorithm in different cases.
                           
                              1.
                              Let s
                                 ∗
                                 =the stack containing the target container (i.e. the lowest numbered container remaining in the bay). Only containers in stack s
                                 ∗ may be moved.

Let n
                                 =the container on the top of stack s
                                 ∗. If n is the target container, retrieve it immediately and go to step 1. Otherwise, container n will be relocated and we go to step 3.

Let Low(s)=the lowest numbered container in stack s. Clearly, the top container in stack s will have to be moved before container number Low(s) is retrieved.

Let D
                                 ={s∣s
                                 ≠
                                 s
                                 ∗ and Low(s)>
                                 n}. If D is empty, container n will have to be relocated yet again before finally being retrieved. In order to delay the time of container n’s next relocation, place container n on the stack s
                                 ≠
                                 s
                                 ∗ with the highest Low(s). Otherwise, if D is non-empty, there is a way to relocate container n so it is not relocated again until its retrieval. In this case, relocate container n to the stack in D with the lowest Low(s). This conserves the good destination stacks for future relocations. Go to step 1.

We now describe the LA-N algorithm. The term “LA-N” represents a family of algorithms, each corresponding to a different value of the parameter N. The value of N specifies how many future container retrievals are considered when identifying eligible container relocations. When N
                        =1, the algorithm has a “one container look ahead” and is virtually identical to the basic LA algorithm shown above. In this case, only moves of containers that are in the same stack as the target container are allowed. In other words, no cleaning moves are allowed. For higher values of N, the algorithm has an “N-container look ahead,” meaning that only moves of containers that are in the same stack as one of the next N containers to be retrieved are allowed. Thus, the algorithm allows cleaning moves under certain conditions.

Our description of the LA-N algorithm uses the following notation. Let c
                        ∗
                        =the number of the target container. Let Stack(c)=the stack containing container c. Let s
                        ∗
                        =
                        Stack(c
                        ∗)=the target stack, i.e. the stack containing the target container. Let Top(s)=the container on the top of stack s. Let Stacks[a]=the set of stacks in which the a lowest-numbered containers reside. Let Q represent a set of stacks. Let Top[Q]=the set of containers residing on the tops of the stacks in set Q. Let Top
                        
                           r
                        [Q]=the rth highest element in set Top[Q], i.e. the container with the rth highest number among the containers on the tops of the stacks in set Q. Let Low(s)=the lowest numbered container in stack s. Let Height(s)=the height of stack s, i.e. the number of containers in stack s. These parameters take the following values in the context of the container configuration in the upper-left corner of Fig. 2: c
                        ∗
                        =1, Stack(1)=2, Stack(2)=3, Stack(3)=2, s
                        ∗
                        =2, Top(1)=9, Top(2)=4, Top(3)=5, Stacks[1]={2}, Stacks[2]={2,3}, Stacks[5]={2,3}, Stacks[6]={1,2,3}, Top[{1}]={9}, Top[{1,2}]={9,4}, Top[{1,2,3}]={9,4,5}, Top[Stacks[1]]={4}, Top[Stacks[5]]={4,5}, Top[Stacks[6]]={9,4,5}, Top
                        1[{1,2}]=9, Top
                        2[{1,2}]=4, Top
                        2[Stacks[6]]=5, Top
                        3[Stacks[6]]=4, Low(1)=6, Low(2)=1, Low(3)=2, Height(1)=3, Height(2)=3, Height(3)=3. We now describe the LA-N algorithm in detail.
                           
                              0.
                              Select a value for N (the look ahead).

If c
                                 ∗
                                 =
                                 Top(s
                                 ∗), retrieve container c
                                 ∗ immediately because it is on the top of a stack and repeat step 1. Otherwise, some container is relocated and we go to step 2.

Let N′=min{N, number of containers remaining in the bay} and let r
                                 =1.

If Stacks[N′] includes all S stacks or if all stacks s not in Stacks[N′] are full (i.e. they have mxHeight containers in them), let N′=
                                 N′−1 and repeat step 3. Otherwise, proceed to step 4.

We consider whether or not to relocate container n where n
                                 =
                                 Top
                                 
                                    r
                                 [Stacks[N′]]. If n
                                 =
                                 Top(s
                                 ∗), go to step 6. Otherwise, go to step 5.

Determine if there is a good cleaning move involving container n. Let E
                                 ={s∣Low(s)>
                                 n andHeight(s)<
                                 mxHeight}. If E is empty or if n
                                 =
                                 Low(Stack(n)), there is no good cleaning move involving container n because either (i) it cannot be relocated so as never to be relocated again or (ii) it is already the lowest numbered container in its stack. In this case, let r
                                 =
                                 r
                                 +1 and go to step 4. Otherwise, go to step 6.

Container n will be relocated. Let D
                                 ={s∣Low(s)>
                                 n and Height(s)<
                                 mxHeight}. If D is empty, container n will have to be relocated yet again before finally being retrieved. In order to delay the time of container n’s next relocation, place container n on the stack s with the highest value of Low(s) such that Height(s)<
                                 mxHeight. Otherwise, if D is non-empty, there is a way to relocate container n so it is not relocated again until its retrieval. In this case, relocate container n to the stack in D with the lowest Low(s). This conserves the good destination stacks for future relocations. Go to step 1.

Note the LA-N algorithm’s similarity to the LA algorithm. Indeed, step 1 (6) of the LA-N algorithm is very similar to steps 1–2 (3–4) of the LA algorithm. The main difference between the two algorithms is that the LA-N algorithm initiates cleaning moves (i.e. in-between moves) under certain conditions. In particular, if there exists a container that is (A) on the top of a stack in which one of the N lowest-numbered containers resides and (B) this container can be relocated so it will never have to be relocated again prior to its retrieval, the container is relocated to the stack that is “best” among those stacks meeting criterion B. The order of consideration for cleaning moves begins with the highest-numbered container satisfying criterion A and moves to the lower container numbers satisfying criterion A. Whenever the container under consideration is on top of the target stack, this container is moved no matter what. Step 3 of the LA-N algorithm ensures that at least one container slot is available to accommodate a potential container relocation without violating the maximum height limit. The second difference between the two algorithms is that the LA-N algorithm explicitly accounts for mxHeight in the event there is a limited stack height (mxHeight
                        <
                        C) whereas the LA algorithm does not. Note that the LA-1 algorithm is identical to the LA algorithm except that it also considers the maximum stacking height mxHeight. Fig. 2 illustrates the (i) LA-1 and (ii) LA-2 algorithms on a nine-container instance of the BRP when mxHeight is six or greater. Fig. 2iii illustrates the LA-2 algorithm with mxHeight
                        =5 on the same instance. Fig. 4
                         illustrates the decisions made by the LA-5 algorithm for a 17-container instance.

We now compare the performance of five different algorithms for the BRP—LA-N, KH, DH, CM, and LL—and also consider the performance of the LA-N algorithm for different values of N. The LA-N algorithm is from the current study; the KH algorithm is from Kim and Hong (2006); the DH algorithm is from Aydin (2006) and Aydin and Ünlüyurt (2008); the CM algorithm is from Caserta et al. (2011); and the LL algorithm is from Lee and Lee (2010).


                     Tables 7–9
                     
                     
                      show the computational results that were obtained using a single-core 2.8gigahertz personal computer with 2gigabytes of RAM. Table 7 shows the results when the KH, DH, CM, and LA-N algorithms are tested on a range of small, medium, and large problem instances. Each row corresponds to a different problem size (i.e. scenario) as defined by the initial height of each stack (H) and the number of stacks (S). The initial number of containers C is H
                     *
                     S. A maximum height limitation (mxHeight
                     =2H
                     −1) is enforced by all algorithms. Forty different instances (i.e. initial bay configurations) are considered for each problem size (except 100×100). These are the same forty instances considered by Caserta et al. (2011). Thus, a total of 21*40 problem instances are considered (not including the 100×100 scenario), and each number in the table represents an average value obtained over all instances of a particular problem size rounded to the nearest tenth. For the 100×100 scenario, each algorithm was tested on a different set of 1000 randomly generated instances. Regarding objective value, Table 7 shows the number of relocations, not moves. The values in the KH and CM columns (including runtime) are copied from Caserta et al. (2011), and the values in the DH and LA columns are derived from experiments performed in the current study. Four variants of the LA-N algorithm are tested: LA-1, LA-2, LA-3, and LA-(S
                     −1).

In Table 7, the overall performance of the four algorithms,when ranked by objective value from highest to lowest, is KH, DH, CM, and LA-N. (The LA-N algorithms are aggregated into a single category.) The KH algorithm has the highest number of container relocations in all scenarios except one. The DH algorithm has the second-highest (third-lowest) number of relocations in the majority of scenarios. The CM algorithm has the second-lowest number of relocations in eleven, or half, of the scenarios. Regarding the other half of the scenarios, the CM algorithm has the lowest (third-lowest) number of relocations in 7 (4) scenarios. Finally, the LA-N algorithm has the lowest number of relocations in 15 of the 22 scenarios and the second-lowest number of relocations in the remaining 7 scenarios. Columns six and eight show the average computational time of the CM and “Best LA” algorithms. The CM runtimes are copied from Caserta et al. (2011). Although the same computer was not used to test the CM and LA-N algorithms, the final row indicates that the LA-N algorithm might have a faster runtime than the CM algorithm. Figs. 5–7
                     
                     
                      graphically show the performance of the algorithms on the small, medium, and large instances respectively. Overall, the LA-N algorithm generally outperforms the KH, DH, and CM algorithms across a range of scenarios.


                     Table 7 shows that the LA-N algorithm’s performance varies depending on the “look-ahead” value N. When H
                     =3, the algorithm usually performs best at an intermediate value of N that is neither 1 nor S
                     −1. When 4 ⩽
                     H
                     ⩽10, performance improves monotonically as N increases and the “Best LA” algorithm is LA-(S
                     −1), i.e. the LA-N algorithm with the highest value of N. These findings indicate that cleaning moves are improving the algorithm’s performance in the majority of cases. One glaring exception to this trend is the final scenario: 100×100. In this scenario, performance deteriorates as N increases. Although somewhat counter-intuitive, this result is explained by the fact that there are more opportunities for cleaning moves as N increases. This means that, on average, containers are more heavily concentrated in fewer stacks as N increases. In other words, we are more likely to see very high piles of containers when N increases, especially for extremely large configurations such as 100×100. This increases the risk of having “full” stacks (of height mxHeight
                     =2H
                     −1) that cannot accommodate additional containers. These full stacks add unpredictability to the algorithm that may harm its performance. Indeed, full stacks cause container relocations to be “diverted” to other stacks that ordinarily would not accept relocated containers. Such diversions may significantly add to the total number of moves required to empty a bay. This situation is illustrated by parts (i) and (iii) of Fig. 2 in which the LA-1 algorithm only uses 16 moves but the LA-2 algorithm uses 17 moves to empty the bay for a problem instance in which S
                     =3 (assuming mxHeight
                     =5). In this case, the LA-2 algorithm “mistakenly” begins with the cleaning move of container 5 from stack 3 to stack 1. This leaves only one more open position in stack 1. However, two containers lying above container 1—containers 4 and 3—need to be relocated in order to retrieve container 1. This forces the relocation of the second such container—container 3—to be made from stack 2 to stack 3, which returns stack 3 to an undesirable status—a configuration with three containers with medium, high, and low numbers from top to bottom (3,8,2). Thus, the resulting configuration with the LA-2 algorithm after three moves—[4,5,9,7,6∣1∣3,8,2]—is no better than the resulting configuration with the LA-1 algorithm after two moves—[3,4,9,7,6∣1∣5,8,2]. This explains the higher number of moves used by the LA-2 algorithm versus the LA-1 algorithm.

Additional experimental results, shown in Table 8, indicate that the 40×40 problem size is a threshold. Below this threshold, performance tends to improve as N increases; above this threshold, performance tends to deteriorate as N increases. Surprisingly, Table 8 shows that this trend holds not only for a limited stack height (mxHeight
                     =2H
                     −1) but also for an unlimited stack height (mxHeight
                     =
                     H
                     *
                     S). In other words, for problem instances larger than 40×40, performance gets worse as N increases regardless of the height restriction. We explain this non-intuitive result as follows. Cleaning moves are not always helpful. For example, if a cleaning move’s “fit” is not good (i.e. if the lowest Low(s) is much larger than n in step 6 of the LA-N algorithm), the move might do more harm than good—it might negate opportunities to make two or more additional cleaning moves into the same stack in the future. Furthermore, “bad fitting” cleaning moves are more likely to be made when the range of container numbers is large (e.g. when C is large). Thus, when the bay is very large, it is possible that too many cleaning moves with a bad fit are made too soon when N is high. Therefore, it would be best to keep N as small as possible—equal to 1—for the instances with very large bays.


                     Table 9 shows the results when the KH, LL, and LA-N algorithms are tested on 14 problem instances created by Lee and Lee (2010). Each row in the table corresponds to a different problem instance. The maximum stacking height (mxHeight), initial number of containers in the bay (C), and number of stacks (S) are shown for each problem instance in the second and third columns in the table. Note that only two problem sizes are considered: a 16-stack, 70-container problem with mxHeight
                     =6 and a 16-stack, 90-container problem with mxHeight
                     =8. Note that mxHeight is more restrictive in these instances than the instances considered in Table 7. Regarding objective value, the numbers in the table show the number of moves, not relocations. The values in the KH and LL columns (including runtime) are copied from Lee and Lee (2010), and the values in the LA columns are derived from experiments performed in the current study. Four variants of the LA-N algorithm are tested: LA-1, LA-2, LA-3, and LA-15 (i.e. LA-(S
                     −1)).

In Table 9, the overall performance of the algorithms, when ranked by objective value from highest to lowest, is KH, LL, and LA-N. (The LA-N algorithms are aggregated into a single category.) The KH algorithm has the highest number of moves in all instances. The LL algorithm has the second-highest number of moves in 13 of 14 instances and ties for the lowest number of moves in one instance. Finally, the LA-N algorithm has the lowest number of moves in all instances. Columns six and eight show the average computational time of the LL and “Best LA” algorithms. The LL runtimes are copied from Lee and Lee (2010). Although the same computer was not used to test the LL and LA-N algorithms, it is clear that the LA-N algorithm has a faster runtime than the LL algorithm. The performance of the LA-N algorithm varies depending on the “look-ahead” value N. However, in contrast to Table 7, there is no notable trend linking performance of the LA-N algorithm to the value of N. Indeed, not enough problem instances are considered to discern any trend or pattern. Overall, the LA-N algorithm, regardless of the value of N, outperforms the KH and LL algorithms on all instances.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this paper, we introduced “BRP-III”—a new mathematical formulation of the BRP—and showed that it has considerably fewer decision variables and better runtime performance than formulation BRP-I from Caserta et al. (2012). In doing so, we presented the first computational results for the literature’s only two math programming formulations of the BRP that allow cleaning moves. We also introduced a new look-ahead algorithm (LA-N) for the BRP that uses ideas from existing algorithms in the literature. This new algorithm generally obtains better solutions than the KH, DH, CM, and LL algorithms from the literature, and it also has minimal CPU runtime. The performance of the LA-N algorithm varies depending on the “look-ahead” value N. For small- and medium-sized instances, the algorithm usually performs better when N is large. For extremely large instances, the algorithm performs better when N is 1. Future work on the BRP might consider additional safety constraints that ensure that two adjacent stacks can never differ in height by more than Z containers (constraints (7)–(8) in Table 4). We might also try to find new algorithms that outperform the LA-N algorithms introduced here.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.ejor.2013.05.037.


                     
                        
                           
                              Scanned version of Petering (2004).
                           
                           
                        
                     
                  


                     
                        
                           
                              Pages 1, 2, 55, and 56 of Petering et al. (2005).
                           
                           
                        
                     
                  


                     
                        
                           
                              The .tex source code for supplementary file #1 above. This file was last modified on June 21, 2004.
                           
                           
                        
                     
                  


                     
                        
                           
                              Computer (C++) code, written by M.E.H. Petering in 2004, that implements the basic LA algorithm. This file was last modified on April 27, 2004.
                           
                           
                        
                     
                  


                     
                        
                           
                              Output produced by the C++ code in supplementary file #4 above. This file was last modified on April 26, 2004.
                           
                           
                        
                     
                  

@&#REFERENCES@&#

