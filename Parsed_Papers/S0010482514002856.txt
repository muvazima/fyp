@&#MAIN-TITLE@&#POPPER, a simple programming language for probabilistic semantic inference in medicine

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The POPPER language was developed to explore probabilistic semantics.


                        
                        
                           
                           The application was developed to assist in medical reasoning.


                        
                        
                           
                           The core theory is the same as the Hyperbolic Dirac Net HDN.


                        
                        
                           
                           Like an HDN, it enables bidirectional probabilistic logic and cyclic paths.


                        
                        
                           
                           Unlike the basic HDN, it allows verbal relationships.


                        
                        
                           
                           Unlike the basic HDN, it evolves by, e.g., syllogistic reasoning.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Medical inference

Decision support system

Expert system

SW

Dirac

Hyperbolic

Complex

Bayes Net

Popper

@&#ABSTRACT@&#


               
               
                  Our previous reports described the use of the Hyperbolic Dirac Net (HDN) as a method for probabilistic inference from medical data, and a proposed probabilistic medical Semantic Web (SW) language Q-UEL to provide that data. Rather like a traditional Bayes Net, that HDN provided estimates of joint and conditional probabilities, and was static, with no need for evolution due to “reasoning”. Use of the SW will require, however, (a) at least the semantic triple with more elaborate relations than conditional ones, as seen in use of most verbs and prepositions, and (b) rules for logical, grammatical, and definitional manipulation that can generate changes in the inference net. Here is described the simple POPPER language for medical inference. It can be automatically written by Q-UEL, or by hand. Based on studies with our medical students, it is believed that a tool like this may help in medical education and that a physician unfamiliar with SW science can understand it. It is here used to explore the considerable challenges of assigning probabilities, and not least what the meaning and utility of inference net evolution would be for a physician.
               
            

@&#INTRODUCTION@&#

@&#BACKGROUND@&#

Our suggested Q-UEL universal exchange language for healthcare [1] and for inference [2] is amongst many efforts aimed at a more probabilistic form [3] of the current Semantic Web (SW) [4]. The present report extends the basic Hyperbolic Dirac Net (HDN) [2] that relates to so-called Bayesian approaches [5,6] that are confined to conditional probabilities, i.e., forms like P(A|B, C)=P(A,B,C) / P(B,C) which is essentially the probability of the statement “A if B and C” being true. The HDN is now extended to encompass other relationships than “if”, such as in subject-verb-object, that the SW and Q-UEL provide. However, the methodological emphasis below is on a simple POPPER application and POPPER computer language. In its recent form it is seen in part as a tool (a) to convert Q-UEL tags to a form that makes simpler the building of inference networks and the inference engines that drive them, and, importantly, (b) as an interface by which a medical expert can construct Q-UEL tags (when data mining to obtain probabilistic information is not an easy option). In actuality, POPPER was originally partly developed as a simplest possible “toy system” with which medical students might express and solve inference problems in probabilistic semantics, and the original form goes back to 2009 and is the parent of Q-UEL. The first motivation for Q-UEL was to provide a universal or at least uniform language to extract biomedical information, for automated reasoning systems like POPPER, from the web and the SW in particular. The second motivation was because Q-UEL seemed to meet US Federal demands for a universal exchange language for healthcare in late 2010 [1], including means of securely transporting patient data, and extracting further statistical biomedical information from many millions of consenting patients [1].

It is not obvious even to current SW developers how to assign plausible probability values to semantic statements and how a user should interpret them, and perhaps even less clear how one is supposed to interpret and utilize the changes in the inference net that can result from the action of the rules [3]. The diversity of proposed solutions suggests lack of agreement [1]. The popularity of the Bayes Net (BN) [6] is almost certainly because it is easy to understand its quantitative meaning, utility, and mode of use, as what we call a probabilistic conditional inference (PCI) approach. PCI in general uses basic building blocks that are the probabilities that one or more aspects are the case given that one or more other aspects are the case. As noted above, a conditional probability like P(A|B, C)=P(A, B, C)/P(B, C) has the force of P(“A if B and C”). The aspects A, B, C, etc. are states, events, things, observations, measurements, descriptions, etc. that we call attributes by reference to the attributes of the XML-like Q-UEL language. A PCI net is an estimate of a joint or conditional probability with many attributes when there is insufficient data to calculate the probability directly. Primarily, conditional probabilities with fewer attributes such as P(A|B, C) are multiplied together. For a traditional BN this is according to the rule that the attributes as nodes and the conditional relationships between them as connections must describe a directed acyclic graph (DAG) [6]. The HDN as described in Ref. [2] is also a PCI but uses dual probabilities such as (P(A | B, C), P(B, C | A)), considering two directions of conditionality at the same time, say (0.9, 0.6) [1,2]. This is the value of a POPPER tag 〈A | B, C〉. The perhaps unobvious mathematical consequences are that the HDN is no longer constrained to a DAG. The dual itself is, nonetheless, a notion that should be obvious to physicians. For example, there is the risk factor that obesity presents for type 2 diabetes, and the different risk factor that type 2 diabetes presents for obesity. These are conditional probabilities P(type 2 diabetes | obesity) and P(obesity | type 2 diabetes) though typically expressed on, e.g., a percentage or per millum basis.

While emphasis here is on assigning probabilities to statements subjectively by human experts, it can sometimes be done more objectively and/or automatically by data mining and text analytics. By such means one may often obtain association constants such as K(A; B)=P(A, B)/P(A)P(B)=P(A|B)/P(A)=P(B|A)/P(B), or K(A; B; C)=P(A, B, C)/P(A)P(B)P(C) [2]. The effect of a verb as the relationship between subject and object expressions can often be quantified by an association constant. Association constants form the basis of our K method for building an HDN [2], and K(A; B) appears on Q-UEL tags along with forms such as P(A|B) and P(B|A) to allow many clinical and epidemiological metrics to be calculated [1]. It relates to Bayes Eqs. (1) and (2) in that inference can be framed in terms of P(A) as prior probability and P(A|B) as posterior probability in P(A|B)=K(A; B)P(A). Reference will also be made below to information I(A; B)=lnK(A; B), which the author refers to as Fano mutual information, after Fano [7]. Many authors speak of Fano’s inequality mutual information but, strictly speaking, the only inequality for present purposes is that P(A|B) is not in general equal to P(A). It can be, but then I(A; B)=0 and K(A; B)=1, and A carries no information about B and vice versa. Note that, unlike some other kinds of mutual information, it is important to our use of I(A; B) that it may be greater or less than 0 (and hence K greater or less than 1).

Conditional probabilities such as P(A|B) are often capable of a number of other semantic interpretations, including the causal P(“A is caused by B”), the transformational P(“B becomes A”), the comparative P(“A is greater than B”), and not least the categorical P(“B are A”) and similar set-theoretic interpretations, or to imply relationships where something is propagated, or a chain of effect (Section 5.3). These remain important as valid probabilistic semantics, and are responsible for the remarkably broad range of applicability of a BN. Also, the role of a verb of action as in “physicians treat patients” can almost always be rendered categorically: “physicians are patient-treaters”. However, homely examples are often used below of “dogs chase cats” and “cats chase mice” because “chase” is a good example of a verb of action that not fully interpretable in conditional ways and very difficult to use in chains of inference if its role is rendered categorical. For a probabilistic SW and probabilistic semantic inference (PSI), the vertical bar ‘|’ must also often be replaced by many other kinds of relationships, including verbs of action and prepositions, when perceived linguistically. Traditionally there is no P(dogs|chase|cats) except as one possible canonical format for P(“dogs chase cats”), yet humans have no difficulty in seeing that a probability can be assigned, at least qualitatively. Few would bet a thousand dollars that you will never find a dog that does not chase cats, or even that you would never see a cat chase a dog. But 〈dogs|chase|cats〉 does have special meaning encoding a probability dual in Dirac notation and corresponding algebra [8] used in quantum mechanics (QM) [9,10], albeit that there words like dogs and cats are replaced by physical states, events, observations and measurements and a verb like chase is replaced by an operator. Indeed, a verb is seen a kind of operator in Q-UEL and POPPER, using the term “relationship operator” or relator to describe a relationship in general: hence the R in 〈A|R|B〉. Note that POPPER does not simply see a verbal relationship as some kind of additional condition, but as with QM, R is an operator that can in principle be defined as a matrix.

As well as such a semantic triple, Q-UEL statements can be more elaborate semantic multiples 
                        [1], such as the nested form 〈 〈A|R|B〉 |S| 〈C|T|D〉〈E|U|F〉 〉 , that can represent a tree graph as (the parsed structure of) a sentence. 〈A|
                           R
                        |B〉 relates to the physicist’s spinor or dual spinor, and the above nested is an extension of a physicst’s higher level twistor in 〈⋯〉 format [1,2,10]. POPPER is a simplified language that does not support or utilize all Q-UEL features, but while it does not currently explicitly support the above nested form, it also does not prohibit it. As described in Section 3.7, POPPER metastatements (essentially, match and edit instructions that act on statements to apply logical and definitional rules in inference) derive from such a nested “extended twistor” form. In addition, the POPPER method allows construction of statements with such nested forms, simply by using assignment statements to create them as it would create a new statement as a semantic triple in 〈A|R|B〉 format. However, the resulting forms have not as yet been manipulated in any way that would justify their use. In this report, statements are confined to the 〈A|R|B〉 format. It remains that A, R and B can each be strings of words that can be manipulated by metastatements, and these could have implied nested forms like that above.

Although the literature of probabilistic semantics goes back a long way, it has been overshadowed by use of symbolic logic [11], and only recently has there been a significant increase in interest (see Ref. [12] for discussion and review). The problem of what probabilities to assign in POPPER goes back in part to the work of Karl Popper [13] that addressed more generally what it means to make statements about the world. Dirac himself felt that QM and his methods should also be applicable to many aspects of logical and probabilistic human thought [1,2], but he did not say exactly how. Considering the way in which he extended Schrödinger’s wave mechanics to particle theory [10], it seems likely that he had in mind (albeit under other guises) the hyperbolic imaginary number 
                           h
                         (i.e., 
                           hh
                        =+1) that allows use of empirical classical probabilities [1,2]. Adding the semantic interpretation, however, draws on artificial intelligence [14], and linguistic theory [15,16], relational data mining [17], as well as on Expert Systems [18,19] which have a tradition of innovation for medical decision support [20,21]. While our approach also appears to be such an innovation, 
                           h
                         has been rediscovered in different guises in separate fields many times since Cockle first described it [22], including by Dirac [10]. A largely 
                           h
                        -complex QM has only been described fairly recently [23]. Significantly, the relevance to mental function was quickly posited [24], and before that 
                           h
                        -complex algebra has been of considerable interest to the neural network community (e.g. Ref. [25]). Considering the relevance to quantification of relationships, it is not too surprising that the algebra has also been explored for use in on-line dating recommender systems [26]. Such efforts are relatively recent and may yet converge to a unified field, but at present Dirac’s work remains the comprehensive resource.

By also being miscible with Perl and potentially other programming languages [1], POPPER has some force as a programming language. Nonetheless, this is not POPPER’s primary purpose. A traditional example such as print “Hello world!\n”; for a learner’s first entry into using a computer language can be inserted, but this is not fundamental POPPER. In this report focus is on the basic features required to build inference nets and inference engines, using the following key commands. Using these actual commands relates to POPPER HELPER described in this report, but one could simply prepare a text file as input instead.
                           
                              (1)
                              
                                 Update. Enter a sequence of statements such as 〈type 2 diabetes|
                                    causes
                                 |obesity〉=85%, 55%, although the values can be replaced by a computed expression involving other tags 〈⋯|⋯|⋯〉 as described in this report. Briefly, 85% relates to the percentage probability of the statement as read, and 55% to the statement after subject and object are switched. If followed by, say, 〈obesity|causes
                                 |overeating〉=70%, 85%, the user would already have a very simple (and bidirectional) inference net [2]. Also optionally enter metastatements such as the syllogistic form 〈$A|
                                    are
                                 |$C〉=〈$A|
                                    are
                                 |$B〉 〈$B|
                                    are
                                 |$C〉. These allow statements to evolve from others. These two kinds of statement are the only ones of concern in this report. As long as purely multiplicative (AND) logic is used between tags and programming features (not discussed here) are avoided, the order of statements and metastatements is unimportant as “programming”, although metastatement order can affect the details of inference net evolution in a way that is not necessarily predictable in advance.


                                 Show. More like “Hello world!”, input so far can be displayed on request by the command show, along with the overall probabilities of the implied net computed and displayed at the same time.


                                 Think. On that command, metastatements evolve the network as automated reasoning, along with the evolving overall probabilities computed and displayed at the same time (though the way metastaments are usually constructed means that probabilities may not change). The net usually contacts in the interest of reducing much data and information to knowledge, but another command Ogden, discussed later below, can change that.


                                 Thesaurus. A kind of extension to show, this displays not the input statements but all the connections implied by vocabulary definitions in metastatements. For example, “pays” may be defined by the fact that if $A gives money, and the money is given to $B, then $A pays $B. The thesaurus may contain the relation to other tenses and persons of the verb, if provided in input, and notably the active–passive inverse (here, “is paid by”)
                                    2
                                 
                                 
                                    2
                                    Such connections of meaning are computed prior to, and independent of, any use of think, in which the job of metastatements is more specifically to “deduce” that, say, Jack pays Jill. There is sometime a need to avoid ambiguities (e.g., did someone else really pay Jill?) that make POPPER a little more complicated than the account so far may suggest. Command thesaurus allows the user to check that vocabulary and the logic it implies builds up in the intended manner, and can make the action of metastatements more efficient by providing a direct reference to grammar and related words and phrases.
                                 .

The above describes all the essential features of POPPER for routine use. Simplicity is seen as important even to the developer of a POPPER “program” as above, whereas SW representations have a quite complicated appearance. To that end also, POPPER can be considered as Q-UEL but with statements are confined to the above 〈⋯|⋯|⋯〉 tag format and stripped of features that are required for Q-UEL tags residing on the web. While metastatements allow considerable definitional power, a user usually builds POPPER tags that read like simple sentences in a natural language of user’s choice. Attributes as arguments in expressions are, for example, English words, not potentially elaborate attribute metadata language structures as in Q-UEL [1]. All this is not least because the domain in which Q-UEL and POPPER must work is already complicated enough. Medical use is a natural priority for the SW, but until such time as a human can confer with it as one would with another but extremely expert human, simplicity and intuitive form of the underlying elements may help not only physicians but also developers avoid error.

Complete codes will be made available when POPPER is more polished and the best embodiment for a release version becomes clear. From experience with early ancestral forms of the present approach, and notably the GOR method in bioinformatics [5], it is evident that making source code freely available is the best way for widespread adoption. However, the nature and status of POPPER is currently rather different from such earlier efforts. POPPER is really a method, and a code development environment for research in the area, not yet a fixed application. In some respects, this is necessarily so. First, the best algorithm is not yet clear, because the problems addressed overlap with many of the broader open issues in Artificial Intelligence. Compared with the epidemiological estimate of the incidence or prevalence of tuberculosis (TB) averaged over a large population, a preliminary clinical assessment of whether a specific baby has TB, using evidence based medicine and physician’s reasoning, is more complex. It depends on a variety of types of inference to solve little “puzzles” to do with the specific family members and their situation and past movements. More generally, how much to reduce a network of information and declare it as concise and coherent knowledge (say, in the manner of a deduced system of physical laws that can be briefly stated) is also not so clear, as discussed in this report. To such ends, POPPER replaces interpreter/compiler/executer code by user definable input, not only including metastatements that define format, logic, grammar and vocabulary, but also by exploiting a fundamental relationship between the semantic triple and the dyadic function that can call a user-defined subroutine [1]. An example subroutine given in Section 3.1 appears as input in the current set up, but if it represented a persistently wanted action, it would be moved from input to represent a more permanent feature of the interpreter/compiler.

Nonetheless, a developer should be able to produce a core code from the present text. There is an account given of the most important variables and the most important subroutines in Section 3.1, with programming guidelines and a few code examples. An example is give of a toy subroutine to illustrate what a user might create and use in current POPPER input, or to build a similar application to POPPER anew. An example code also given there for an important core subroutine ProcessTwoTriple. This illustrates well that the action of metastatements is not simply to match and edit one or more statements but to “match” statements that are semantically equivalent, i.e. mean the same thing, even if they look different. However, most of the subroutines are really composed of “housekeeping” details that can be implemented in many ways, and interested readers are likely to have access to text analytic, web and semantic web, and/or decision support suites that also provide the established basics. More important is to follow the relatively simple mathematical theory, including the notion of semantic equivalence that determines the more novel aspects of algorithmic structure, and “insert” the algorithms into other code. Examples inevitably assist comprehension, and many input examples are given with associated theoretical explanation.

Showing the nature of consistency between the probabilistic semantics described here and QM is important because we can borrow the mathematics. It is not obvious that it is applicable to the classical everyday world. There appear to be fundamental differences between standard textbook QM, Dirac’s spinor picture, and purely 
                           h
                        -complex algebra:
                           
                              (1)
                              
                                 
                                    
                                       
                                          Wave
                                          
                                          mechanics
                                          :
                                          
                                             〈
                                             
                                                A
                                                |
                                                B
                                             
                                             〉
                                          
                                          =
                                          c
                                          
                                             
                                                e
                                             
                                             
                                                i
                                                θ
                                             
                                          
                                          =
                                          c
                                          [
                                          
                                          cos
                                          (
                                          θ
                                          )
                                          +
                                          i
                                          
                                          sin
                                          (
                                          θ
                                          )
                                          ]
                                       
                                    
                                    
                                       
                                          Spinor
                                          
                                          wave
                                          
                                          mechanics
                                          :
                                          
                                             〈
                                             
                                                A
                                                |
                                                B
                                             
                                             〉
                                          
                                          =
                                          c
                                          
                                             
                                                e
                                             
                                             
                                                hi
                                                θ
                                             
                                          
                                          =
                                          c
                                          [
                                          
                                          cos
                                          (
                                          θ
                                          )
                                          +
                                          hi
                                          
                                          sin
                                          (
                                          θ
                                          )
                                          =
                                          ]
                                          =
                                          c
                                          [
                                          ι
                                          
                                             
                                                e
                                             
                                             
                                                +
                                                i
                                                θ
                                             
                                          
                                          +
                                          ι
                                          ⁎
                                          
                                             
                                                e
                                             
                                             
                                                −
                                                i
                                                θ
                                             
                                          
                                          ]
                                       
                                    
                                    
                                       
                                          Purely
                                          
                                          hyperbolic
                                          
                                          mechanics
                                          :
                                          
                                             〈
                                             
                                                A
                                                |
                                                B
                                             
                                             〉
                                          
                                          =
                                          c
                                          
                                             
                                                e
                                             
                                             
                                                h
                                                θ
                                             
                                          
                                          =
                                          c
                                          [
                                          
                                          cosh
                                          (
                                          θ
                                          )
                                          +
                                          h
                                          
                                          sinh
                                          (
                                          θ
                                          )
                                          
                                             ]
                                             
                                                =
                                                c
                                             
                                             [
                                          
                                          ι
                                          
                                             
                                                e
                                             
                                             
                                                +
                                                θ
                                             
                                          
                                          +
                                          ι
                                          ⁎
                                          
                                             
                                                e
                                             
                                             
                                                −
                                                θ
                                             
                                          
                                          ]
                                       
                                    
                                 
                              
                           
                        
                     

From each description we can determine many corresponding 〈A|R|B〉 (see below). Constant c is determined by the nature and scale of the system, relating to P(A) and P(B) prior to any observation, and θ=θ(A, B) relates to I(A; B) (see below). Note the spinor projection operators 
                        ι=(1/2) (1+
                           h
                        ) and ι⁎=(1/2) (1−
                           h
                        ) [1], for which notation varies a great deal in physics. Space here does not permit rigorous proofs but they are facilitated by use of the idempotent rule 
                        ιι=ι and ι⁎ι⁎=ι⁎, the annihilation rule 
                        ιι⁎=0 and ι⁎ι=0, and the normalization rule 
                        ι+ι⁎=1. As in QM, asterisk ⁎ indicates complex conjugation, in the present case changing the sign of 
                           h
                        . The first two lines of Eq. (1) describe wave mechanics. Stripped of the notoriously bizarre predictions that wave mechanics provides in the everyday world of human experience, it is the third that is of interest here, and the hyperbolic functions cosh and sinh give the hyperbolic number its name. All three cases in Eq. (1) represent a primitive or “mother” form of symmetry called conjugate symmetry, in which A fully determines B and vice versa, save for the uncertainty principle as commutator [AB−BA]=ih/2π where h is Planck’s constant [8–10]. Note that (A| and |B) in P(A|B) typically share this non-commutative AB≠BA property, because P(A|B)−P(B|A)≠0 (unless P(A)=P(B)). Conjugate symmetry is thought of as broken in an asymmetric field, an interaction such as an observation to determine P(A|B) or P(B|A). Our resulting Hermitian commutator form is simple, the probability dual (P(A|B),P(B|A)) as 〈A|B〉=ι
                        P(A|B)+ι⁎P(BIA)=(1/2)[P(A|B)+P(B|A)]+(1/2)
                           h
                        [P(A|B)−P(B|A)]. Though traditionally probability relates to|〈A|B〉|2 by QM definition, we avoid square roots of probabilities [1,2] when Dirac’s recipe for normalizing and extracting P(A|B) and P(B|A) [8] is applied to the 
                           h
                        -complex case [2]. Now θ=I(A; B) exactly, and 〈A|B〉=[ι
                        P(A)+ι⁎P(B)]e
                        
                           θ
                        =[ι
                        P(A)+ι⁎P(B)]K(A; B) in which P(A) and P(B) relate to c after conjugate symmetry breaking. Dirac’s bra-operator-ket 〈A|R|B〉 with operator R is harder than 〈A|B〉, but the 〈A|B〉 remain the basic formal building blocks. For vectors we have 〈A|=[〈A|X
                        1〉, 〈A|X
                        2〉, 〈A|X
                        3〉⋯] and |B〉=[〈X
                        1|B〉, 〈X
                        2|B〉, 〈X
                        3|B〉, ⋯]
                           T
                         where 
                           T
                         indicates the transpose, interchanging rows and columns in a vector or matrix [1]. 〈A|B〉 is the inner product 〈A||B〉, and we also have the outer product |B〉〈A| which is a matrix, and so can define a relator R. Noting that ι⁎P(A)=〈A|B〉 as (0,P(A)), and so on, a toy example [1] comprised vectors 〈A|=[ι⁎P(A), ι] and |B〉=[ι
                        P(B), ι⁎]
                           T
                        , and matrix 
                           R
                        =[0, ι+ι⁎e
                        
                           I(A;B); ι
                        e
                        
                           I(A;B)+ι⁎, 0]. This already shows how to quantify a new relationship between A and B. Sometimes we will require more elaborate vectors, and matrices with elements ι
                        e
                        
                           I(A;B)+ι⁎e
                        
                           I(A;B)′
                         for an asymmetric association. All this is important when we are interested in managing probability distributions. However, for POPPER purposes this is too complicated, and shortcut approaches of the general kind also used in QM are discussed below.

By analogy with QM we can deduce many things about 
                           h
                        -complex 〈A|R|B〉 that map to natural language, and verify them. The toy vector-matrix example already illustrates that QM rules-of-thumb apply. The most important notions of semantic equivalence mentioned below arise because our operators are usually Hemitian operators defined by R
                        †=R where † is the adjoint operation †=T⁎
                        =⁎
                        
                           T
                        , though typically it is still true that R≠R⁎. Again ⁎ is complex conjugation, and 
                           T
                         is vector or matrix transposition, exchanging rows and columns. Conceptually, it is the relationship at the moment of introducing R between 〈A| and |B〉 that matters, because a Hermitian matrix requires the orthogonal case
                           3
                        
                        
                           3
                           To have 〈A|B〉=0 and 〈A|R|B〉≠0 requires that R essentially “flips” the elements of 〈A| or |B〉 so that 〈A|R is a vector that is not orthogonal to B, or so that R|B〉 is a vector that is not orthogonal to A.
                         〈A|B〉=0 [1], except in a few cases such as with identity operator 
                           I
                        , or when R=xI
                         with x as a real number, and with some of QM’s projection operators. QM Hermitian operators can describe observations; of interest here is when they act as if the QM observables are underlying classical probabilities. They are dubbed relational operators or relators, and our 〈A|R|B〉 lie in the 
                           h
                        -complex plane within the boundary 0→ι→1→ι⁎→0. However, they generate two real eigensolutions when the eigenvalues of 
                           h
                        , +1 and −1, are substituted for 
                           h
                         in turn, and it is these real solutions that represent the values of attributes Pfwd and Pbwd in Q-UEL tags, meaning the probabilities of “A R B” and “B R A” as we would read them as subject-verb-object statements in English etc. As in QM, 〈A|R|A〉=〈A|R|A〉⁎ (note the two A) and is therefore already real, and semantically equates to a reflexive verb. It is real also when R=R⁎=R
                        
                           T
                         in 〈A|R|B〉, as when R is purely real. Then R is said to be trivially Hermitian, i.e., symmetric as in 〈Jack|marries|Jill〉. In general, though, 〈A|R|B〉≠〈B|R|A〉 and the most important semantic equivalence is 〈A|R|B〉=〈B|R|A〉⁎. This gives us both directions of the relationship of A→B and A←B as the arc or edge of a graph as a probabilistic knowledge network. R⁎ corresponds to active–passive inversion of the verb R and analogously for a preposition, e.g. “on” becomes “under”. We have also semantic equivalence in the active–passive inverse 〈A|R|B〉=〈B|R⁎|A〉, as in “enzymes catalyze reactions”≡“reactions are catalyzed by enzymes”.

QM often speaks of an operator of observation projecting a value or a new value, say yielding ‘momentum (eVs/Å):=0.2’, and the probability of that as a kind of statement can be conveniently interpreted as a conditional probability. Projection is written above in terms of the Q-UEL metadata operator:=that states that to the right is a specific embodiment, subset or member, element, range or point, taken from the more general idea, set, list or continuum that is to the left. As can be seen from considering Londoners:=diabetics and diabetics:=Londoners, (a) either way round can be meaningful, (b) it need not be 100% true, and (c) departure from 100% need not be the same in the two cases (which is why the dual is needed). In consequence, that P(A:=a) means P(a|A) makes sense. Distinguish P(cat:=mammal)=P(mammal|cat)=P(“a cat is a mammal”)=1, meaning that we sample cats and find them always to be mammals, from the more obvious Q-UEL attribute use as mammal:=cat. The latter gives P(mammal:=cat)=P(cat|mammal)=P(“a mammal is a cat”)≪1, meaning that we sample mammals and only very rarely find them to be cats. Similarly, in QM, P(momentum:=0.2)=P(0.2|momentum)→0, requiring the infinitely thin but integratable Dirac delta function to make sense of it [10]. To consider this further, QM’s projection operator is alluring
                           4
                        
                        
                           4
                           We may build it or see it as the matrix|X〉〈X| from 〈A|X〉〈X|B〉. It is arguably the simplest case of a Hermitian operator after the 
                                 I
                               or xI
                               type. As with spinor projection operator ι, the idempotent property RR=R applies: no subsequent observation or information as operation R will shake the belief in the value by repeating R. In some cases repeated application of a verb may imply repeated action, as in the proverb “If at first you don’t succeed, try, try, try again”, but it is rare in verbs, and usually only signifies emphasis: “Try, try, try to finish it by tomorrow”.
                        . Consider the definition of a projection operator re-expressed in 
                           h
                        -complex terms as
                           
                              (2)
                              
                                 
                                    〈
                                    
                                       A
                                       
                                          |
                                          
                                             
                                                
                                                   R
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          |
                                       
                                       B
                                    
                                    〉
                                 
                                 
                                 
                                    〈
                                    
                                       A
                                       
                                          |
                                          
                                             
                                                
                                                   R
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          |
                                       
                                       B
                                    
                                    〉
                                 
                                 =
                                 
                                    〈
                                    
                                       A
                                       |
                                       
                                       |
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    〉
                                 
                                 
                                    〈
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       
                                       |
                                       B
                                    
                                    〉
                                 
                                 =
                                 
                                 
                                    〈
                                    
                                       A
                                       |
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    〉
                                 
                                 
                                    〈
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       B
                                    
                                    〉
                                 
                                 =
                                 ι
                                 P
                                 
                                    (
                                    
                                       A
                                       |
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       B
                                    
                                    )
                                 
                                 +
                                 ι
                                 ⁎
                                 P
                                 
                                    (
                                    
                                       B
                                       |
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       A
                                    
                                    )
                                 
                                 =
                                 ι
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       B
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 /
                                 P
                                 
                                    (
                                    B
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 
                                 +
                                 ι
                                 ⁎
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       B
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 /
                                 P
                                 
                                    (
                                    A
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 [
                                 ι
                                 P
                                 
                                    
                                       (
                                       B
                                       )
                                    
                                    
                                       −
                                       1
                                    
                                 
                                 +
                                 ι
                                 ⁎
                                 P
                                 
                                    
                                       (
                                       A
                                       )
                                    
                                    
                                       −
                                       1
                                    
                                 
                                 ]
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       B
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 /
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 [
                                 ι
                                 P
                                 
                                    (
                                    
                                       A
                                       |
                                       B
                                    
                                    )
                                 
                                 +
                                 ι
                                 ⁎
                                 P
                                 
                                    (
                                    
                                       B
                                       |
                                       A
                                    
                                    )
                                 
                                 ]
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       B
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 /
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       B
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    〈
                                    
                                       A
                                       |
                                       B
                                    
                                    〉
                                 
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       B
                                       ,
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                                 /
                                 P
                                 
                                    (
                                    
                                       A
                                       ,
                                       B
                                    
                                    )
                                 
                                 P
                                 
                                    (
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                              
                           
                        and the consequent interpretation of QM’s law of composition of probability amplitudes,
                           
                              (3)
                              
                                 
                                    〈
                                    
                                       A
                                       |
                                       B
                                    
                                    〉
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    〈
                                    
                                       A
                                       |
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                    
                                    〉
                                 
                                 
                                    〈
                                    
                                       
                                          
                                             X
                                          
                                          
                                             i
                                          
                                       
                                       |
                                       A
                                    
                                    〉
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    〈
                                    
                                       A
                                       
                                          |
                                          
                                             
                                                
                                                   R
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          |
                                       
                                       B
                                    
                                    〉
                                 
                                 =
                                 
                                    〈
                                    
                                       A
                                       |
                                       B
                                    
                                    〉
                                 
                                 (
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    (
                                    
                                       P
                                       
                                          (
                                          
                                             A
                                             ,
                                             
                                                
                                                   X
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          )
                                       
                                       P
                                       
                                          (
                                          
                                             B
                                             ,
                                             
                                                
                                                   X
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          )
                                       
                                       /
                                       P
                                       
                                          (
                                          
                                             A
                                             ,
                                             B
                                          
                                          )
                                       
                                       P
                                       
                                          (
                                          
                                             
                                                
                                                   X
                                                
                                                
                                                   i
                                                
                                             
                                          
                                          )
                                       
                                    
                                    )
                                 
                              
                           
                        
                     

Together these imply several interesting things, the most relevant here being the undesirable independencies between A:=Xi and B:=X
                        
                           i
                         despite the constraint of Eq. (3). One might seek to overcome them by using the richer information content of a more general Hermitian matrix corresponding to 〈A|R
                        1〉〈R
                        2|B〉 where R
                        1≠R
                        2. Evidently we can have the notion of projection R
                        1=R and R
                        2=R⁎. For example, rather than being forced to wrestle with the values of P(dogs) and P(cats) in 〈dogs|chase|cats〉, one more usefully considers probabilities of dogs:=chase, cats:=chased⁎, dogs:=chase⁎, cats:=chase as conditional probabilities. Chased⁎ is the passive form of projected R as “are chased by”. The semantic sense is revealed by the question “Do dogs chase cats?” with answers such as “Quite a lot do, maybe 90%”. The obvious limitation is that there is still no guarantee in the algebra itself that dogs and cats are not involved in chasing, but are chasing and being chased by something else. It is still the same kind of issue as in Eqs. (2) and (3). By 〈A|R
                        1〉〈R
                        2|B〉 with R
                        1=R and R
                        2=R⁎, we assume 〈A|R〉〈R|R⁎〉〈R⁎|B〉 with〈R|R⁎〉=1. This determination is the principle of same action (POSA). In POPPER writing “〈A|X〉〈Y|B〉=” will mean that 〈A|X〉 and 〈Y|B〉 will stay bound together in the variable stack (Section 3.1), and metastatements will act on them together, representing a closed universe for this particular X and Y (Section 3.3). Guaranteeing〈R|R⁎〉=1 requires a stronger form as a principle of one-to-one action (POOA). Here, each dog chases one cat:
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             〈
                                             
                                                A
                                                ≔
                                                R
                                                |
                                                B
                                                ≔
                                                R
                                                ⁎
                                             
                                             〉
                                          
                                          =
                                          P
                                          (
                                          A
                                          ≔
                                          R
                                          |
                                          B
                                          ≔
                                          R
                                          ⁎
                                          )
                                          =
                                          P
                                          (
                                          B
                                          ≔
                                          R
                                          ⁎
                                          |
                                          A
                                          ≔
                                          R
                                          )
                                          ,
                                          P
                                          
                                             (
                                             
                                                A
                                                ≔
                                                R
                                             
                                             )
                                          
                                          =
                                          P
                                          (
                                          B
                                          ≔
                                          R
                                          ⁎
                                          )
                                       
                                    
                                    
                                       
                                          
                                             〈
                                             
                                                B
                                                ≔
                                                R
                                                |
                                                A
                                                ≔
                                                R
                                                ⁎
                                             
                                             〉
                                          
                                          =
                                          P
                                          (
                                          B
                                          ≔
                                          R
                                          |
                                          A
                                          ≔
                                          R
                                          ⁎
                                          )
                                          =
                                          P
                                          (
                                          A
                                          ≔
                                          R
                                          ⁎
                                          |
                                          B
                                          ≔
                                          R
                                          )
                                          ,
                                          P
                                          
                                             (
                                             
                                                B
                                                ≔
                                                R
                                             
                                             )
                                          
                                          =
                                          P
                                          (
                                          A
                                          ≔
                                          R
                                          ⁎
                                          )
                                       
                                    
                                 
                              
                           
                        
                     

This is part way to what is wanted. It can also be more formally done with vector-matrix algebra, element by element, but that is what we were trying to avoid. For brevity, suffice it to say that comes to the same as the following particular kind of twistor construction [1,2].
                           
                              (5)
                              
                                 
                                    〈
                                    
                                       A
                                       
                                          |
                                          R
                                          |
                                       
                                       B
                                    
                                    〉
                                 
                                 =
                                 
                                    〈
                                    
                                       
                                          〈
                                          
                                             A
                                             ≔
                                             R
                                             |
                                             B
                                             ≔
                                             R
                                             ⁎
                                          
                                          〉
                                       
                                       |
                                       
                                          〈
                                          
                                             A
                                             ≔
                                             R
                                             ⁎
                                             |
                                             B
                                             ≔
                                             R
                                          
                                          〉
                                       
                                    
                                    〉
                                 
                                 =
                                 ι
                                 
                                    〈
                                    
                                       A
                                       ≔
                                       R
                                       |
                                       B
                                       ≔
                                       R
                                       ⁎
                                    
                                    〉
                                 
                                 +
                                 ι
                                 ⁎
                                 
                                    〈
                                    
                                       A
                                       ≔
                                       R
                                       ⁎
                                       |
                                       B
                                       ≔
                                       R
                                    
                                    〉
                                 
                                 =
                                 ι
                                 [
                                 ι
                                 P
                                 (
                                 A
                                 ≔
                                 R
                                 |
                                 B
                                 ≔
                                 R
                                 ⁎
                                 )
                                 +
                                 ι
                                 ⁎
                                 P
                                 (
                                 B
                                 ≔
                                 R
                                 ⁎
                                 |
                                 A
                                 ≔
                                 R
                                 ⁎
                                 ]
                                 +
                                 ι
                                 ⁎
                                 [
                                 ι
                                 P
                                 (
                                 A
                                 ≔
                                 R
                                 ⁎
                                 |
                                 B
                                 ≔
                                 R
                                 )
                                 +
                                 ι
                                 ⁎
                                 P
                                 (
                                 B
                                 ≔
                                 R
                                 
                                 |
                                 A
                                 ≔
                                 R
                                 ⁎
                                 )
                                 ]
                                 =
                                 ι
                                 P
                                 (
                                 A
                                 ≔
                                 R
                                 |
                                 B
                                 ≔
                                 R
                                 ⁎
                                 )
                                 +
                                 ι
                                 ⁎
                                 P
                                 (
                                 B
                                 ≔
                                 R
                                 
                                 |
                                 A
                                 ≔
                                 R
                                 ⁎
                                 )
                              
                           
                        
                     

This still requires POSA, but not POOA. Examining Eq. (5) reveals an interesting twist. When several 〈A|R|B〉 are brought together to form a joint probability as in 〈?|A〉〈A|R|B〉〈B|S|C〉〈C|T|D〉〈D|?〉, where 〈?|A〉 and 〈D|?〉 are query tags (or preparation-observation tags) with P(?)=1 by definition [1,2], it can be seen that linker probabilities are required to satisfy a chain rule calculation, just as P(B|C) is conceptually required between P(A|B) and P(C|D) to estimate P(A|D). In such cases two joint probabilities result P(A:=R, B:=R⁎) and P(B:=R, A:=R⁎) result. It is Eq. (5) with the assumption that P(B:=R⁎)=P(A:=R⁎)=P(R⁎|B)=P(R⁎|A)=1, i.e., that the entities are certainly capable of receiving the action and that the action does occur. This results in the following useful “ready to go” definition without thinking further about the linkers, although Ref. [2] should be consulted for the corrections at branch points. If not used, one assumes the linking probabilities to be 1. Either way, it is still usually 
                           h
                        -complex.
                           
                              (6)
                              
                                 
                                    〈
                                    
                                       A
                                       
                                          |
                                          R
                                          |
                                       
                                       B
                                    
                                    〉
                                 
                                 =
                                 ι
                                 P
                                 (
                                 A
                                 ≔
                                 R
                                 ,
                                 B
                                 ≔
                                 R
                                 ⁎
                                 )
                                 +
                                 ι
                                 ⁎
                                 P
                                 (
                                 B
                                 ≔
                                 R
                                 ,
                                 A
                                 ≔
                                 R
                                 ⁎
                                 )
                              
                           
                        
                     

The golden rule in POPPER is that if you cannot assign a probability, assign 1. This follows Popper’s Principle of refutation [13]: statements are seen as assertions that await being disproven. It can also represent lack of knowledge, irrelevance, or absurdity. It is consistent with information I=−logP=0 when P=1, and the fact that probability 1 has no effect in a purely multiplicative (logically ANDed) set of statements. Default 1 is consistent with our zeta function approach [1,2]: whether using actual or subject frequencies of observation (or both), P(A)=1 if there is no data or prior opinion. There are no undefined variables in POPPER: the compiler assumes 1 or analogously an identity operator. 1 is implied for anything neglected, as irrelevant, whether it is included in the net, or actually excluded (as most of the universe is). We can neglect in a converse statement like “Cigars like smoking Cuban citizens”: the position is taken that it is absurd, and an assignment of 1 seems reasonable in the dual (0.99, 1).

Conversely, 0 should never be assigned. As with 1, a user can override the rule by assigning any value, but using 0 will cause the net to go to 0 in at least one direction. If so, and the statements used are analogous to a conditional form P(A|B), the Bayes rule P(A|B)P(B)=P(B|A)P(A) then demands 0 in both directions. There are curious equivalences between 0 and 1. Since any probability P less than 0.5 can in principle be re-expressed as greater than 0.5 by some form of negation in statements, i.e. it transforms to 1−P, the smallest effective probability is just 0.5 and the effective information content of network of N statements lies between 0 and 1 bits per statement in each direction, or N in each direction overall (0⋯2N overall). On that reasoning, the commonly used 0.5 is a bad idea for “don’t know”, as it implies maximal refuting knowledge. 1 makes more sense. The value of 〈A|A〉 can arguably [2] be seen on a modular or “clock space” 0 to 1 in which 0≡1. A zero probability is seen as an illusion of confidence in POPPER, because I=−logP=∞. Interpreting zero as a low but non-zero value is, like default 1, consistent with our zeta function approach: whether using actual or subject frequencies of observation (or both), it leads to P(A)≈1/N if we have N actual or virtual observations overall as weight of evidence, but no occurrences of, or belief in, A 
                        [2]. We just keep increasing the weight of refuting evidence as the refuting information log(N). Unfortunately, a meaningful value of P(A)≈1/N is difficult to choose subjectively
                           5
                        
                        
                           5
                           From a traditional statistics viewpoint, the small probability that a naïve robot should see is remarkably 0.05. It corresponds to the use of α=0.05 as the popular decision point for the P-value in traditional z and t tests, that originates in the idea that 1 out of 20 contrary observations is on the borderline of suggesting that a hypothesis is false [28,29]. However, if it had been considered that “Cigars like smoking Cuban citizens” was not absurd but simply untrue, then 0.05 seems too high to human common sense. In practice, one seeks magnitudes that will not imply other extremely unrealistic probabilities when the Bayes rule is applied [2].
                        . The default that POPPER takes when 0 is seen is usually set to 0.00001, because this is on the “epidemiological scale of magnitude” (Section 3.3).

@&#METHODS@&#

The essential workflows can be summarized by the following.
                           
                              Statements of data and knowledge→statement tags→bra-relator-kets as statements as computational variables→relevancy set→static HDN→(with metastatements)→dynamic HDN.

Metastaments about logic, common sense reasoning, grammar and vocabulary definition→metastatement tags→metatstatement set→(acting on static HDN)→dynamic HDN.


                        Section 1.1 provided an orientation to which the following clarifications may be added. POPPER largely evolved from a list of statements as subroutine calls, each seen as of form string 1〈parameter list 1|subroutine name|parameter list 2〉string 2, per line. 〈A|R|B〉 remains a dyadic function in as in Q-UEL [1]. The above evolved into fixed code, but even in current form, the compiler and executer still have the sense of an empty shell. While effort is made that examples below are reasonably realistic, the skeptical user can change laws of logic, vocabulary, word meaning, and grammar as represented by metastatements. The compiler attempts to interpret the user’s preferred format from the source code, working down from the top of the input file, because the user may not wish to base his or her “coding” on Q-UEL. To ensure correct interpretation, it is advised to start with “definitional axioms”. The following snapshot from near the beginning of a test file illustrates the above.
                           
                              
                                 
                                 
                                    
                                       
                                          #####################EXAMPLE DEFINITION OF BASIC ACTION######################
                                       
                                    
                                    
                                       
                                          #〈argument|relator|argument〉 hunts for relator as subroutine if one exists with
                                       
                                    
                                    
                                       
                                          #that name, generating new arguments and relator, otherwise continuing
                                       
                                    
                                    
                                       
                                          #as normal with the same arguments and relator.
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          〈6|more than|3〉
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          sub more_than #This is a toy example of a basic action defined by a subroutine.
                                       
                                    
                                    
                                       
                                          {
                                       
                                    
                                    
                                       
                                          #Compare relative value of two numerical quantities and replace by statement
                                       
                                    
                                    
                                       
                                          #about its truth. $A,$L,$B are the working internal variables for a created
                                       
                                    
                                    
                                       
                                          #statement, and $C,$R,$D and $E,$S,$F etc. for premises (if present).
                                       
                                    
                                    
                                       
                                          #$L is the left-of-equal-sign relator, $R, and $S are those to the
                                       
                                    
                                    
                                       
                                          #premises on the right. Also available globally are $operator, the string
                                       
                                    
                                    
                                       
                                          #of characters between the bra-kets for the two premises, $iotaL
                                       
                                    
                                    
                                       
                                          #and iotaR (the conditional information values in both directions,
                                       
                                    
                                    
                                       
                                          #$inverse{$L}, $inverse{$R}, $inverse{$S} the relator inverses,
                                       
                                    
                                    
                                       
                                          #$synonym{$L}, $synonym{$R}, $synonym{$S} any required relator synonyms, and
                                       
                                    
                                    
                                       
                                          #$definition{$L}, $definition{$R}, $definition{$S} further optional synonyms,
                                       
                                    
                                    
                                       
                                          #usually the automatically generated word or phrase which is the meaning
                                       
                                    
                                    
                                       
                                          #in terms of words from Ogden basic English.
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          my $x=@_[0]; my $relator=@_[1]; my $y=@_[2];
                                       
                                    
                                    
                                       
                                          $A=“$x $relator $y”; $L=‘:=‘;
                                       
                                    
                                    
                                       
                                          if ($x 〉 $y) {$B=‘true’;} else {$B=‘false’};
                                       
                                    
                                    
                                       
                                          $inverse{$L}=‘=:’;
                                       
                                    
                                    
                                       
                                          delete $iotaL{“$x|$relator|$y”}; delete $iotaR{“$y|$relator|$x”};
                                       
                                    
                                    
                                       
                                          $iotaL{“$A|$L|$B”}=0; #Internal use of information −logP(“$A|$L|$B”).
                                       
                                    
                                    
                                       
                                          $iotaR{“$B|$L|$A”}=0; #Internal use of information −logP(“$B|$L|$A”).
                                       
                                    
                                    
                                       
                                          }
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #######AXIOMS (1): UNIVERSAL VARIABLE RELATIONSHIPS#######
                                       
                                    
                                    
                                       
                                          #############################################################################
                                       
                                    
                                    
                                       
                                          #It is built in that different universal variables $A, $B, etc. stand
                                       
                                    
                                    
                                       
                                          #for different things, while any one e.g. $A always stands for the same thing.
                                       
                                    
                                    
                                       
                                          #######AXIOMS (2): DEFINITTIONS BASED ON DISTINGUISHABILITY ##################
                                       
                                    
                                    
                                       
                                          〈$A|$A〉=〈$A|$A〉 #Define the symbol, here ‘=‘, for semantic equivalence.
                                       
                                    
                                    
                                       
                                          〈$A|$A〉=not〈$B|$B〉 #Define the symbol, here ‘not’, for non-equivalence.
                                       
                                    
                                    
                                       
                                          :
                                       
                                    
                                    
                                       
                                          :
                                       
                                    
                                 
                              
                           
                        
                     

The above gives insight into a number of general coding principles and the notation as used inside the application. The two most important kinds of variables used in the interpreter/compiler are two kinds of associative (“hash”) arrays with two corresponding kinds of elements for each statement 〈⋯|⋯.|⋯〉 in the system. They are namely $iotaL{“$A|$L|$B”} and $iotaR{“$B|$L|$A”}, that would evaluate to, for example, $iotaL{“type 2 diabetes|causes|obesity”} and $iotaR{“obesity|causes|type 2 diabetes”}. Note that each $iotaL and $iotaR array element has a semantic triple statement as a key analogous to a standard array index $i in $x[$i], and the element carries as its value the probability associated with each such corresponding direction of reading of the statement. $iotaL and $iotaR are thus, roughly speaking, probability distributions over all the statements, but importantly and in any event, they represent the inference network. Actually, in practice, probabilities are stored in memory as their logarithms. Reflecting the symmetries in the underlying mathematics, L and R are used rather generously in variable names in the code to indicate aspects to do with left and right, but that can be rather confusing as it relates both to left and right arguments in the dual probability and to arguments on each side of a variety of operators. In the Theory, Section 2, R was appropriately used for the relationship operator or relator in general, but the use of $L above relates to the fact that $L is a relator in a statement to the left of the equivalence and assignment operator “=” in input, while $R, $S etc. are relators to the right. Internally $L makes the more common appearance, and so tends to be used in general, because to right of “=” in input there will frequently be no $R etc. but just probability values to assign. In contrast, the names $iotaL and $iotaR signify the left (L) and right (R) statement in the iota algebra format ι
                        P(“A L B”)+ι⁎P(“B L A”) [1,2], e.g., ι
                        P(“type 2 diabetes causes obesity”)+ι⁎P(“obesity causes type 2 diabetes”). Evidently, $iota and $iotaStar would be reasonable alternative names to avoid confusion about L and R. However, the historical basis for the above use of L and R is not inconsistent, because of the symmetry ι
                        P(“A L B”)+ι⁎P(B L A”)=ι
                        P(“A L B”)+ι⁎P(“A R B”).

Strictly speaking, the above already completes what is required to form an inference net, but by itself, it would lack a great deal of meaning. The links due to logic, grammar, vocabulary, etc. between relationship words and phrases in particular, but also between words and phrases in general, provide a second network of meaning, essentially the thesaurus, that is more behind the scenes. This behind-the-scenes content is important for querying the network and for net evolution as described below. As a very simple example, a pharmaceutical chemist would not want to query a network of knowledge for “inhibits” but miss “inhibit”, “is inhibited by”, “are inhibited by”, “is an antagonist to”, “blocks”, “suppresses” “competes with”, and so on. Importantly, the routines that evolve the net will want to know such things too, to see what can be inferred to build the new net. The input program written by the user in POPPER language defines the relationships between words and phrases, but the metastatements used are not really mindlessly applied as match-and-edit instructions. POPPER helps deduce what is semantically equivalent so that something which looks very different but means the same is not neglected. Particularly useful here are associative arrays $inverse{$L} and $synonym{$L}. We can say $inverse{$synonym{$L1}}=$inverse {$synonym{$L2}}, and so on. $definition{$L} is useful as conveniently distinguished from $synonym{$L} to carry comment about meaning and/or a link as an RDF reference to its definition [1,4], i.e., to provide an “encyclopedic” power to a net.

The following gives a list of essential subroutines required, when working through the POPPER HELPER interface described below, which itself essentially represents the subroutines in Class 1. All these subroutines are early features of the system distinguished by starting with upper case alphabetic characters, and exclude subroutines moved from the input file. A subroutine description is indented below the description of the subroutine which most prominently calls it.


                        1. 
                        
                           Command
                        —Read the command in POPPER HELPER that is entered by the user and invoke the subroutine of corresponding name. 
                        Fig. 1 is a screen shot of POPPER HELPER in which subroutine Command resides, and the screen shot shows the main command options each of which corresponds to a subroutine as for CMND$_below.


                        1.1 
                        
                           CMND$_ -
                         These are really multiple subroutines starting with the characters CMND. It means the subroutine to be called by the command entered through POPPER HELPER, such as subroutine CMNDhelp or CMNDopen, using eval(“&CMND$_“) where $_ is the variable containing the command name entered by the user. This allows the user to create and add new commands easily, and the current inbuilt commands work the same way. Subroutine CMNDhelp is called if the command entered was help, and provides the list of command options etc. CMNDopen opens a file (net.txt being the default filename). CMNDupdate calls ExpertBuild (see below) in order for a human expert to provide input to update or create a file. Class 2 subroutines are called both by CMNDopen and CMNDshow, and so compute the values of the static net as well as the thesaurus. CMNDshow displays the static net and its probability values, and CMNDthesaurus displays the thesaurus. Subroutine CMNDShow is actually rather lengthy since it does a final “semantic tidying” including adjusting any statement so that if, for example, a negation of it is of higher probability than the positive form, then the negative form is reported. Since there are several forms of negation this is indeed complex; however, these functionalities are really a matter of “tidying” output according to taste, so they will be addressed elsewhere. Class 2 and 3 subroutines shown below are called by CMNDthink, which essentially transforms the net with metastatements and thesaurus and applies a repeated iteration using class 2 subroutines. Again, see Fig. 1 for a fuller list of commands and corresponding subroutines.


                        1.2. 
                        
                           ExpertBuild
                        —This is invoked by the user selecting command “update” to help create or update a inference network. It gets a statement input by an expert and reads, deduces or requests probabilities associated with it. In response to “dogs chase cats” this subroutine will ask that the prevalence of chasing cats is quantified, ask for the inverse of chase, ask for how many dogs are chased by cats, how many dogs chase something, and so on. It will also ask for an explanation to be added in annotation. The latter is stored with each statement entered.


                        1.2.1. 
                        
                           ShowRelator
                        —Display the last relator such as a verb used in statements entered by the expert and its active–passive inversion along with all the statements containing it and the associated probabilities. This is primarily used by POPPER HELPER in asking questions of form such as “So, most X use Y. What do you mean by most?”, to obtain quantification of explanation.


                        1.2.2. 
                        
                           Quantifier
                        —Words like “all”, “no”, “most” and “few” in a statement imply an appropriate default probability that is returned by subroutine Quantifier, if not otherwise specified. See Fig. 1.


                        2. 
                        
                           InputTriples
                        —This is a large subroutine that processes the POPPER commands on the input file and thus has a variety of tasks to perform, but most important is (a) identifying and storing the triples to the left of equivalence and assignment statements that will form the inference net, and (b) identify and distinguish metastatements that will act on the above. It also processes relationship between commands such as synonym and inverse, and builds the thesaurus. Note that currently the maximum list of expressions from a input line being processed at any time, whether they are statements 〈⋯|⋯|⋯〉 without binding variables $A $B etc. or metastatements that actually use binding variables $A $B etc., is $A,$L,$B,$C,$R,$D,$E,$S,$F corresponding to the syllogistic form 〈$A|$L|$B〉=〈$C|$R|$D〉〈$E|$S|$F〉. The shorter list $A,$L,$B,$C,$R,$D is processed for 〈$A|$L|$B〉=〈$C|$R|$D〉, and minimally $A, $L, $B is processed for 〈$A|$L|$B〉=values. A line that contains no statement delimiters is examined as to whether it is inactive comment (indicated by starting with #) or executable code (Perl in the present case).


                        2.1. 
                        
                           TwoTriplePrimitives, ThreeTriplePrimitives
                        —Check that the input is formally correct and deduce how to recognize triples and important operators if defaults are not being used. Examine the input to deduce the format, i.e. bracket characters such as 〈⋯|⋯|⋯〉, equality and assignment symbol such as “=”, logical operators such as “not”, existential qualifiers (“some”, “all” etc.), based on principles of basic logic and the way binding variables $A, $B, etc are used. Recall that the system does know that $A and $A are the same thing, and that $A and $B are different. The reason for two distinct subroutines is that the principles of recognition and interpretation are rather different in each of these two cases. The default format is used below.


                        2.2. 
                        
                           ProcessOneTriple, ProcessTwoTriple, ProcessThreeTriple
                        —This second of these subroutines is listed below to illustrate the general principles including use of several important variables. Recall that the version used for the present report is capable of processing input lines each containing up to three triples, primarily meaning 〈⋯|⋯|⋯〉=values, 〈⋯|⋯|⋯〉=〈⋯|⋯|⋯〉, and the so-called syllogistic form 〈⋯|⋯|⋯〉=〈⋯|⋯|⋯〉〈⋯|⋯|⋯〉. More complicated cases require building up a required result in steps using these. For example, 〈⋯|⋯|⋯〉=〈⋯|⋯|⋯〉〈⋯|⋯|⋯〉〈⋯|⋯|⋯〉 can be done in two steps. The reason for three distinct subroutines is that actions to be performed are somewhat different in each case. For example, 〈⋯|⋯|⋯〉=〈⋯|⋯|⋯〉 is usually used to define synonyms and active–passive inverse forms, while 〈⋯|⋯|⋯〉=〈⋯|⋯|⋯〉〈⋯|⋯|⋯〉 is common for syllogistic logic and building up definitions and vocabulary, as in 〈$A|pays|$B〉=〈$A|gives|money〉〈money|to|$B〉. All of the above three forms can be used as either statements or metastatements, i.e. with or without binding variables $A, $B, etc., respectively. However, 〈⋯|⋯|⋯〉=values is not accepted for a metastatement in the version used in this report. It does have a meaning to impose values, and other versions do have meaning for 〈⋯|⋯|⋯〉=〈⋯|⋯|⋯〉〈⋯|⋯|⋯〉=values if that is a metastatements. It represents the degree of confidence in a metastatement as a rule that relates and processes statements.


                        2.2.1. 
                        
                           Synonym
                        —Usually, return the original root word or phrase that first defined a relator. In some versions, if the Ogden mode is on, the new relator becomes the root, and if off, it is replaced by the root synonym. This latter was not used in this report and will be discussed elsewhere.


                        2.2.2. 
                        
                           Equivalence
                        —It is possible and legal that a synonym could be cyclically defined as in “A means B means C means A”. Equivalence identifies an appropriate root synonym where two words or phrases were each defined as the synonym of the other.


                        2.2.3. 
                        
                           Build—Build a phrase from many words as implied by three 〈⋯|⋯|⋯〉 in metastatements in the form of a syllogism, or successive application of several such, and pairs of statements 〈⋯|⋯|⋯〉 on which the above initially acts. A phrase is usually a whole subject expression, relationship expression, or object expression in 〈⋯|⋯|⋯〉, and all three expressions can be constructed as phrases at the same time. The result needed is deduced logically from the use of unique and same binding variables in the metastatements. This is one of the more complicated features of POPPER, and will be discussed elsewhere, but a simple example would be the generation of 〈Jack and Jill|go up and down|the hills and valleys〉. Typical of these constructions, it does not necessarily follow that for example, 〈Jack and Jill|went up|the hill〉 is implied by 〈Jack|went up|the hill〉 and 〈Jill |went up|the hill〉 occurring in the inference net. It might not be the same hill. It depends on the interpretation that the user wants, by choice of statements and metastatements.


                        2.2.4. 
                        
                           WordReduction
                        —Reduce many words in a phrase to one word with same meaning. Search the synonyms of the words if necessary. This is a reverse of Build, but easier to understand and to do, as in 〈$A|pays|$B〉=〈$A|gives|money〉〈money|to|$C〉 that creates “pays”.


                        2.2.5. 
                        
                           Interpret
                        —Re-express a word defined by many words into a phrase of those words, and reduce each such word to its root synonym. It is a kind of simpler version of Build as a reverse of WordReduction, converting, say, 〈Jack|pays|Jill〉 to 〈Jack|gives money to|Jill〉.


                        2.2.6. 
                        
                           Update
                        —Literally, update the probability values of a statement 〈⋯|⋯|⋯〉 according to new information. It is possible that a statement exists twice or more in the system as a result of entry by different experts or by net evolution. In that case the assigned probability values, which could differ, must be reconciled into one statement. In addition this subroutine is capable of detecting statements that look different but mean the same thing. In that case they must also be reconciled into one canonical form. This is a fairly complex area which will be discussed elsewhere.


                        2.2.6.1. 
                        
                           WeightOR
                        —This is a logic OR function subroutine called that can be set for various extents of random association, mutual exclusivity etc. Such a logical OR operation can occur between statements 〈⋯|⋯|⋯〉 in input. In the present case, however, it is used as random association OR computed as P(A OR B)=P(A)+P(B)−P(A)×P(B) and it is the formulae used to reconcile probabilities in Update, above. It is applied to achieve the following effect: 〈⋯|⋯|⋯〉updated=〈⋯|⋯|⋯〉old+〈⋯|⋯|⋯〉new−〈⋯|⋯|⋯〉old〈⋯|⋯|⋯〉new.


                        2.2.7. 
                        
                           Memorize
                        —Memorize current values of a string of expressions $A,$L,$B, or $A,$L,$B,$C,$R,$D or $A,$L,$B,$C,$R,$D,$E,$S,$F.


                        2.2.8. 
                        
                           Validate
                        —Compare a string created by Memorize as above with the current value of the string and apply tests to validate that it is a valid transformation preserving semantic equivalence. If it fails, repairs are attempted. This in several respects reflects a more sophisticated routine that is only bought into play if basic methods fail. It also allows for the fact that semantic equivalence does not always allow for probabilistic equivalence, i.e. 〈non-Y|are| non-X〉 is logically equivalent to 〈X|are|Y〉 but not usually in value unless 〈X|are|Y〉=1.


                        3. 
                        
                           IterateThis
                        —Takes a net in memory that CMNDopen and/or CMNDupdate creates, and applies one pass of iteration over the net, as called multiple times by the command think. It performs multiple functions of checking, tidying and reconciling as well as applying metastatements to match and edit statements. This calls class 2 subroutines Interpret, Synonym, WeightOR, plus the following.


                        3.1. 
                        
                           $L - In several respects this is also the conceptual counterpart of CMND$_ except that the commands come through the input that CMNDopen and/or CMNDupdate creates, not through POPPER HELPER. In this case the POPPER interpreter/compiler looks for a subroutine that corresponds to the relator expression, and applies the following code:-

$oldL=" ' " .$L." ' "; $L=~ s//_/g; eval(“&$L($A,$oldL,$B)”);$L=~s/_//g;

It is possible that the search can be on each word in the relator expression, in which case $oldL must be decomposed and the search applied to each word in turn.


                        3.2. 
                        
                           MatchTriple
                        —Look for relevant metastatements that match single statements 〈⋯|⋯|⋯〉 in the net.


                        3.3. 
                        
                           MatchSyllogism
                        —Match metastatements that have syllogistic form to match two statements 〈⋯|⋯|⋯〉 and 〈⋯|⋯|⋯〉 in the net; these need not be located near to each other in storage. In preparation for more complex metastatements matching many statements in the net, this subroutine will also play the role of MatchTriple, which is thus now demoted for “debugging” purposes.


                        3.3.1. 
                        
                           PatternMatch
                        —Perform the pattern match test across all the statements in the inference net.


                        3.3.2. 
                        
                           SimplePremises
                        —When metastatements of syllogistic form and statements have a simple corresponding structure, process them simply and efficiently. When more elaborate cases are detected, the following more advanced procedures are applied.


                        3.3.3. 
                        
                           LinkBrakets
                        
                        —Apply metastatements that reduce two statements with common arguments to one, focusing on the common constant parts.


                        3.3.4. 
                        
                           TransferBoundVariables
                        —Transfer the parts that differ and are matched by binding variables into the resulting statement.


                        3.3.5. 
                        
                           RepairInverse
                        
                        —Syllogistic metastatements might generate a new statements as a conclusion in which the verb or compound verb has no defined inverse. Attempt to deduce one.

As an example of coding approach and use of the variables, the following is a stripped-down simple version of the ProcessTwoTriple subroutine, which processes statements of form 〈A|L|B〉=〈C|R|D〉.


                        
                           
                              
                                 
                                 
                                    
                                       
                                          ##############################PrecessTwoTriple###############################################
                                       
                                    
                                    
                                       
                                          sub ProcessTwoTriple
                                       
                                    
                                    
                                       
                                          {
                                       
                                    
                                    
                                       
                                          # The processing of two triples of form 〈A|L|B〉=〈C|R|D〉 can be regarded as the
                                       
                                    
                                    
                                       
                                          # prototype basic task. Processing one triple 〈A|L|B〉just skips parts of the
                                       
                                    
                                    
                                       
                                          # calculation including in &Update called, as indicated by the global variable
                                       
                                    
                                    
                                       
                                          # $twoTriples=0/1 flag. Note also the $Uvariable flag that distinguishes
                                       
                                    
                                    
                                       
                                          # metastatements with universal binding variables from statements without them.
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          my $A=@_[0];my $L=@_[1];my $B=@_[2];my $C=@_[3];my $R=@_[4];my $D=@_[5];
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          &Memorize($A,$L,$B,$C,$R,$D); #Keep a record of original expressions $A etc.
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          # First, instead obtain any primitive logical definitions if there are universal
                                       
                                    
                                    
                                       
                                          # binding variables $A, $B, etc. present.
                                       
                                    
                                    
                                       
                                          if ($A=~/\$[A–Z]/||$B=~/\$[A–Z]/){return if &TwoTriplePrimitives};
                                       
                                    
                                    
                                       
                                          #Find root synonyms of component words in relator.
                                       
                                    
                                    
                                       
                                          $L=&WordReduction($L); $R=&WordReduction($R);
                                       
                                    
                                    
                                       
                                          #Find root synonyms of whole relator after word reduction;
                                       
                                    
                                    
                                       
                                          if ($L ne “ && exists $synonym{$L}){$L=&Synonym($L);} else {$synonym{$L}=$L;}
                                       
                                    
                                    
                                       
                                          if (exists $synonym{$R}) {$R=&Synonym($R);} else {$synonym{$R}=$R;}
                                       
                                    
                                    
                                       
                                          
                                             #Synonym case.
                                       
                                    
                                    
                                       
                                          
                                             if ($A eq $C && $B eq $D) #Synonym 〈A|L|B〉=〈A|R|B〉
                                       
                                    
                                    
                                       
                                          
                                             
                                             {
                                       
                                    
                                    
                                       
                                          
                                             
                                             if (exists $synonym{$L} &&!exists $synonym{$R})
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             {
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             #If it is R that is not defined…
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             $synonym{$R}=$L;
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             }
                                       
                                    
                                    
                                       
                                          
                                             
                                             else
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             {
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             #No previous synonyms. New root. Assign R to L.
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             #Also, if L is not defined, or both are
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             #defined so assign R to L to resolve conflict.
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             $synonym{$L}=$R;
                                       
                                    
                                    
                                       
                                          
                                             
                                             
                                             }
                                       
                                    
                                    
                                       
                                          
                                             
                                             #Adjust inverses to refer to root synonym
                                       
                                    
                                    
                                       
                                          
                                             
                                             $inverse{$L}=$inverse{$R} if!exists $inverse{$L};
                                       
                                    
                                    
                                       
                                          
                                             
                                             $inverse{$R}=$inverse{$L} if!exists $inverse{$R};
                                       
                                    
                                    
                                       
                                          
                                             
                                             }
                                       
                                    
                                    
                                       
                                          
                                             #Inverse case.
                                       
                                    
                                    
                                       
                                          
                                             if ($A eq $D && $B eq $C)
                                       
                                    
                                    
                                       
                                          
                                             
                                             {
                                       
                                    
                                    
                                       
                                          
                                             
                                             $inverse{$L}=$R if!exists $inverse{$L};
                                       
                                    
                                    
                                       
                                          
                                             
                                             $inverse{$R}=$L if!exists $inverse{$R};
                                       
                                    
                                    
                                       
                                          
                                             
                                             }
                                       
                                    
                                    
                                       
                                          &Validate($A,$L,$B,$C,$R,$D); #Perform validity checks against original form
                                       
                                    
                                    
                                       
                                          # and repair if necessary.
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          return if $Uvariable;
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          $x=&Equivalence(“$A|$L|$B”);$y=&Equivalence(“$C|$R|$D”);
                                       
                                    
                                    
                                       
                                          $equivalence{$x}=$y;$equivalence{$y}=$x;
                                       
                                    
                                    
                                       
                                          $twoTriples=1; #Let &Update know that this is two triples.
                                       
                                    
                                    
                                       
                                          &Update($A,$L,$B,$C,$R,$D);
                                       
                                    
                                    
                                       
                                          }
                                       
                                    
                                 
                              
                           
                        
                     

Established sets of statements and metastatements may be stored under entries in a library, and such a set, when addressing particular medical aspects such as “childbirth” or “pancreatitis” and prior to adding any structure such as logical OR, constitutes a relevancy set. In the present study, the relevancy set was originally a set of statements in an executable user manual, similar to the above example, really a POPPER source code with comment in which the examples can be tested and compared with the description. Examples there addressed a popular BN problem that has many variants (see Section 5 for discussion). This concerns the propagation of tuberculosis (TB) and likelihood that a baby with respiratory distress symptoms has TB. However, this example was modified and hugely extended by hundreds of probabilistic statements considered potentially relevant, many provided by medical students. This “brute force” method was based on the idea that the human brain seems to manage reasoning by assembling and sifting a huge number of potentially but not necessarily relevant facts, and by removal of irrelevant new information as a suspected function of sleep. As described in Sections 4 and 5, it is really the sifting by the combined effect of evolution by metastatements, plus subsequent queries and perhaps addition of new statements and metastatements, that resolve the effect of starting with that somewhat arbitrary mix.

Although POPPER was originally written in part for experts to manipulate and create Q-UEL tags, the version described here can be used without Q-UEL. Q-UEL and POPPER should still be compared, and the relationship is very simple for the commonest type of Q-UEL tag that, ignoring extraneous web management detail, is as follows.


                        〈subject expression Pfwd:=x|relationship expression|object expression:=y〉
                     

where x and y are actual probability values such as 0.9 and 0.35. What it becomes in POPPER source code is the following assignment expression.
                     


                        〈subject expression|relationship expression|object expression〉=(
                        x, y)

Note that in POPPER we do not usually see elaborate “words” as Q-UEL’s XML-like attributes extended by attribute metadata language [1], but if the above did indeed come from a Q-UEL tag with such, then each attribute would be treated as a single complicated word. Direct assignment expressions contain the value explicitly, as a constant: (x, y) is for example the dual (0.9, 03). Writing “=0.9, 0.3” is permitted format and more typical, and note that if x=y, we just write “=x”. More common still is “=90, 30”. Also equivalent are “=(90, 30)”, “=90%, 30%” or “=(90%, 30%)”. These are assumed not to be percentage probabilities if both values are in the range 0…1, but % will override this. The most basic examples are when no value at all is given, when value (1,1)=1 is implied:
                           
                              
                                 〈baby|is|patient 6834〉
                              


                                 〈patient 6834|is|baby〉
                              

An example of an explicitly assigned value in the present study is:
                           
                              
                                 #Example test case, establishing 〈mother coughs|# more than|baby coughs〉.
                              


                                 〈mother coughs|more than|baby’s older sister coughs〉=80,10
                              


                                 〈baby’s older sister coughs|more than|baby coughs〉=60,10
                              

Note that (a) the value is assigned to the statement on the left side of the assignment expression at compile time, and (b) only the left side of assignment expressions appears in the HDN as inference net that the compiler generates, the last appearing valuation of such a statement being used
                           6
                        
                        
                           6
                           Note that there is a degree of execution in the compiler, in the manner of a line-by-line interpreter, since it needs to compute what the values are at that point as it accepts the statement and its value into the net. To add some sophistication to this, Perl code may appear in brackets {…} and statements may have variables such as $x generated by code that will be distinct from binding variables $X in upper case.
                        . The subject and object expressions in POPPER need not simply be nouns or noun phrases (and if required they can be processed according to their true grammatical structure by metastatements).

The “coughs more than” example above could be quantified by observation, but it is more likely to be a subjective estimate. Either way, there is no inconvenience of an absurd converse statement. In contrast, consider


                        〈TB|is prevalent in|Area X in Asia〉=90,
                     

Note the comma: writing only “=90” would imply “=(90,90). The example implies (0.9, 1), taking the position that the converse is absurd (Section 2.4). The normal advantage that 〈A|R|B〉⁎=〈B|R|A〉 became a problem, obliging this view. In such cases, the following device is valid and common.


                        〈TB|is prevalent in|Area X in Asia〉=90,
                     


                        〈Area X in Asia|has high prevalence of|TB〉=90,
                     

Metastatments described below can be used to relate these two relationship expressions as active–passive inverses of each other, and note that the two values assigned above (90) must then be equivalent: 〈A|R|B〉⁎=〈B|R⁎|A〉. As it happens, that would only be done if we are to use the relationships several times, because the above example wrote out what was needed explicitly, for that case. But consider
                           
                              
                                 〈TB|is prevalent in|Area X in Asia〉=90,5
                              


                                 # The 5 implies that we impose a meaning on the inverse,
                              


                                 # that Area X in Asia is prevalent amongst all TB areas.
                              

noting the commenting after #. This broadening of meaning is appropriately dubbed stretching. We can also stretch by explicitly broadening the meaning to give symmetry. Note, though, the lack of comma in the following example of this, since (90, 90)=90 is meant.


                        〈TB|is associated with|Area X in Asia〉=90
                     

As with these examples, difficulties can be avoided by alternative formulations of the statement, but there is dependence on what is intended. For example, another conceptually early statement in the TB example is in regard to the probability that the mother smokes. POPPER allows 〈mother smoking〉=90 analogous in effect to 〈mother|smokes|cigarettes〉=90 which implies (90, 90). However, this would only be appropriate if the problem were whether the baby had respiratory problems, scaling the whole net by 0.9. In most variants of this problem, what is addressed is the chances that the baby has TB. Formally, this requires 〈mother smokes|?〉=90, 1 as a query tag [1,2], but 〈mother|smokes|cigarettes〉=90, 1 does the same job. For example also, the following three are semantically equivalent, but the first would cause problems if the converse was assigned 0, while the others do not require 0.


                        〈carbenoxolone|inhibits|11beta-hydroxysteroid _dehydrogenase〉
                     


                        〈carbbeoxolone|is|11beta-hydroxysteroid_dehydrogenase-inhibitor〉
                     


                        〈11beta-hydroxysteroid_dehydrogenase-inhibitor|carbenolxolone〉
                     

What was really wanted in the net is more likely to be


                        〈carbenoxolone|inhibits|11beta-hydroxysteroid_dehydrogenase〉
                     


                        〈11beta-hydroxy steroid_dehydrogenase|generates|cortisol〉
                     

to conclude that carbenoxolone depresses cortisol production. We are back to the converse as absurd, but we can stretch the interpretation to a symmetrical one:


                        〈carbenoxolone|bindsto|11beta-hydroxysteroid_dehydrogenase〉
                     

There is often a significant difference when the conditional is interpreted causally:


                        〈TB|is caused by|smoking〉=21, 0.001
                     

In 〈TB|is caused by|smoking〉=21,0.001, the value of 21% is because of the stretched interpretation of “is caused by” as “is attributable to”, and the WHO reports that “More than 20% of TB cases worldwide are attributable to smoking” [27]. Conversely, that TB causes smoking with a certain probability might only make sense if we stretch “is caused by” to also embrace the sense “is misattributed to”, and include notion of wrong diagnosis. Where a statement in its converse appears irrevocably absurd or highly implausible, use of 0.001% is preferred, though the general reason is that it seems reasonable because of the magnitude of many smaller epidemiological measures and how they behave in the Bayes rule
                           7
                        
                        
                           7
                           Bayes rule P(TB|S)P(S)=P(SITB)P(TB) set as 0.2P(TB)=0.001P(S), obliges us to consider that smoking is P(S)/T(TB)=0.21/0.001=210 times more prevalent than TB. From 1953 to 2012, the prevalence of TB declined from 0.0526% to 0.0032% [28], so approximately P(S)/T(TB) ranged increased from 334 to 5656. The prevalence of smoking is 10–20%, a sensible result by Bayes rule.
                        . With those considerations, consider
                           
                              
                                 
                                 
                                    
                                       
                                          #Assume the “biomedically naive robot”, and use #0.001% for “seems implausible”.
                                       
                                    
                                    
                                       
                                          〈father|visited|Area X in Asia〉=85, 0.001
                                       
                                    
                                    
                                       
                                          〈damaged lungs with exudative effusions|detectable by|X-ray〉=95, 0.001
                                       
                                    
                                    
                                       
                                          〈dyspnoea|is caused by|TB or lung cancer or bronchitis or emphysema〉=85, 0.001
                                       
                                    
                                    
                                       
                                          〈bronchitis|is caused by|smoking〉=75, 0.001
                                       
                                    
                                    
                                       
                                          〈lung cancer|is caused by|smoking〉=41, 0.001
                                       
                                    
                                    
                                       
                                          〈emphysema|is caused by|smoking〉=11, 0.001
                                       
                                    
                                    
                                       
                                          〈TB|causes|damaged lungs with exudative effusions〉=80, 0.001
                                       
                                    
                                 
                              
                           
                        
                     

In using natural language, our concepts of causality and sets, and the fact that we make the negative form of a statement if we believe it to be nearer the truth, means that the reverse direction of conditionality can be small. It is thus common to apply low probabilities that represent absurdity by 1 (Section 2.4), and compare the effect. However, if low probabilities are estimates based on actual or conceptual populations for which the low probability is seen as a genuine estimate, it should stand. This should be done with caution. An expert might have at one time said that obesity causes type 2 diabetes and the converse is absurd, but this is not necessarily the case [2].

POPPER HELPER is still currently part of the developer’s suite but it provides a simple command line dialogue mode that facilitates human input and at the same time helps with subjective assignments. It is shown in Fig. 1. The human expert enters a semantic triple “subject-verb-object” or “subject-preposition-object”, and then POPPER HELPER works interactively in a command line dialogue with the expert to provide probabilities for symbolic projection (Eq. (5)). For example, in many cases illustrated by 〈dogs|chase|cats〉 one can specify such a triple to the application that interactively asks questions such as “How many dogs chase cats?” P(A:=R|B:=R⁎), “How many cats chase dogs” P(B:=R|A:=R⁎) and so on, to resolve probabilities. The expert is asked to explain his or her choices, which are recorded. The answers can be qualitative, e.g., “most”, “a few”, “hardly any” on a 17 point natural log scale from −28 to +28. With the 0.001% set for lowest probability, the adjustment 0.00001+P(1−0.00001)→P can be applied, and then when probabilities fall below 0.5, negated forms of statements can optionally be used internally. Again, this is largely because in language we make the negative form of a statement if we believe it to be nearer the truth. Computationally, with the internal use of logarithms and avoidance of zero, this is not essential. To apply Eq. (6) including branch corrections in a net (Section 2.4), POPPER HELPER asks the user to answer questions about all the probabilities in many different ways, e.g. “how many cats are chased by something”, in order that reconciliation of many values might approach a more reasonable estimate of this. Using POOA (Section 2.4) suggests that such reconciliation can be by extensively using a geometric mean as “averaged choice”, but the default is the more general POSA assumption. When there seems a likely chance that two sentences X and Y mean the same thing, and when X is the preferred canonical form, then P(X)←P(X)+P(Y)−P(X)P(Y) is used. The above may be extended to include questions involving various negations, which is more complicated and to be described elsewhere.

When objective probabilities can be obtained by data mining, Q-UEL tags carrying them can be used. For example, in Q-UEL-FUNCTION-ZEMI tags, Pfwd and Pbwd attribute values are Fano mutual information, and essentially natural logs of association constants, although actually estimated via zeta functions [1,2]:
                           
                              
                                 
                                 
                                    
                                       
                                          〈Q-UEL-FUNCTION-ZEMI:=’zeta-expected-mutual-information’:=(observed:=5379, expected:=1706.38)
                                       
                                    
                                    
                                       
                                          :=(scalar, real, ‘estimate LOGe(Kassoc)’)
                                       
                                    
                                    
                                       
                                          hypertension:=yes:=’at least’:=average(yes:=+1, no:=−1):=−1.30
                                       
                                    
                                    
                                       
                                          Pfwd:=assoc(nats):=1.14
                                       
                                    
                                    
                                       
                                          
                                             |‘is associated with’|
                                          
                                       
                                    
                                    
                                       
                                          ‘renal failure’:=yes:=’at least’:=average(yes:=+1/no:=−1):=−0.92
                                       
                                    
                                    
                                       
                                          Club:=Virginia
                                       
                                    
                                    
                                       
                                          Pbwd:=assoc(nats):=1.14
                                       
                                    
                                    
                                       
                                          Q-UEL-FUNCTION-ZEMI〉
                                       
                                    
                                 
                              
                           
                        
                     

There is no directional aspect in this case: Pfwd=Pbwd. The above would still be processed to simpler POPPER format: 〈hypertension|is associated with|renal failure〉=e+1.4. The values is “interpreted” at compile time, i.e., e+1.4 is read as exp(+1.4), though in actuality it is really the logarithm that is retained for internal working anyway. Tags with three forms of negation corresponding to the above will normally also be available, if there information is significantly different from zero, so that the four tags available relate to the four probabilities of an odds ratio. The utility of doing it this will be discussed elsewhere, but note that strong pro- and contra-evidence can cancel.

As in a typical programming language, indirect assignments are possible, taking values from other variables, here statements, or expressions of them. For example,
                           
                              
                                 〈overeating|causes|type 2 diabetes 〉=
                              


                                 overeating|causes|obesity〉〈obesity|causes|type 2 diabetes〉
                              


                                 〈patient|pays|insurance company〉=
                              


                                 〈patient|gives|money〉〈money|is given to|insurance company〉
                              

By default, logical AND is implied between the two statements to the right, and if the duals of them are at that point in program flow (v, w) and (x, y), the statements to the left takes the dual (vx, wy). It is a transaction expression, and POOA (Section 2.5) would be usually assumed so that values are chosen to yield the appropriate value of (vx, wy). There is no ambiguity in practice as to this intended meaning and probabilities assigned in the context of the program, given correct programming by the basic rules (Section 3.2). POPPER can recognize logical and related keywords as operators within the statements. There is a corresponding bound form:


                        〈patient|gives|money〉〈money|is given to|insurance company〉=100, 80
                     

It means that these statements will stay together in the statement stack, as a unit. It can, for example be converted to 〈patient|pays|insurance company〉 by a metastatement. AND is again implied here, but there may be operators between the statements to the left of assignment, which is a way to introduce logical OR into the net.

Metastatements are defined and identified by at least one binding variable. This term, and the method used, is essentially the same as in Expert Systems [18]. A Q-UEL and POPPER binding variable starts with $ and is followed by a capital letter. So in 〈$A|is|$B〉 and 〈$As|are|$B〉 the “s” in $As is part of the string to which $A binds, not part of the variable. $ followed by lower case letters is a variable in the HDN as a program, but it is not a binding variable. Notably, the scope of binding variables in general is confined to the one line or expression. What matters per line or expression is that $A must mean the same thing as $A, and $B as $B, and so on, but $A must mean something different to $B, and so on. A metastatement is an operator that acts on one statement or more statements that need not be together in the inference net, converting them to one or more different statements, but usually to one. Metatstatements are placed by the complier in a separate memory space from the statements. Their action is on the stack of statements as variable names as the net is executing and evolving dynamically, not on the input to be compiled. The most important type of metastatement in POPPER is


                        〈Q-UEL-META 〈$A|are|$C〉|=|〈$A|are|$B〉 〈$B|are|$C〉 Q-UEL-META〉
                     

The above tag example would give


                        〈$A|are|$C〉=〈$A|are|$B〉〈$B|are|$C〉
                     

in the source code. Specifically, this is an example of a syllogism. Other examples are:
                           
                              
                                 
                                 
                                    
                                       
                                          #1.Barbara. Verb form 1.
                                       
                                    
                                    
                                       
                                          #E.g.All humans are mammals. All mammals eat food. All humans eat food.
                                       
                                    
                                    
                                       
                                          #Note throughout that the verb $L may be ‘be’ (or one of its synonyms) or its
                                       
                                    
                                    
                                       
                                          #existential ‘may be’.
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          〈$A|$V|$B〉=〈$A|be|$C〉〈$C|$V|$B〉
                                       
                                    
                                    
                                       
                                          #Test case establishing “TB causes harm”.
                                       
                                    
                                    
                                       
                                          〈TB|are|mycobacteria〉=95, 2
                                       
                                    
                                    
                                       
                                          〈mycobacteria|are|actinobacteria〉=99, 1
                                       
                                    
                                    
                                       
                                          〈TB|is|a pathogen〉=70,2
                                       
                                    
                                    
                                       
                                          〈a pathogen|causes|harm〉=95,3
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #1.Barbara. Verb form 2.
                                       
                                    
                                    
                                       
                                          #E.g.All animals eat vegetables. All vegetables are plants. All animals eat plants.
                                       
                                    
                                    
                                       
                                          〈$A|$V|$B〉=〈$A|$V|$C〉〈$C|be|$B〉
                                       
                                    
                                    
                                       
                                          #Test case establishing “TB causes a pathological state”.
                                       
                                    
                                    
                                       
                                          〈TB|causes|harm〉=95,0.001
                                       
                                    
                                    
                                       
                                          〈harm|is|a pathological state〉=100,5
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #2.Celarent.
                                       
                                    
                                    
                                       
                                          #E.g. All humans are mammals. No mammals eat rocks. No humans eat rocks.
                                       
                                    
                                    
                                       
                                          〈$A|not $V|$B〉=〈$A|be|$C〉〈$C|not $V|$B〉
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #But note: All humans eat vegetables. No vegetables are meat. No humans eat meat.
                                       
                                    
                                    
                                       
                                          #Hence, the switch of the general verb with ‘be’ does not follow.
                                       
                                    
                                    
                                       
                                          #Example test case, establishing 〈TB|means not|healthy〉.
                                       
                                    
                                    
                                       
                                          〈TB|is|a disease〉=100,0.1
                                       
                                    
                                    
                                       
                                          〈a disease|means|not healthy〉=97,100
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #3.Darii.
                                       
                                    
                                    
                                       
                                          #E.g.All vegetarians should eat rice and beans. Some humans are vegetarians.
                                       
                                    
                                    
                                       
                                          #Some humans should eat rice and beans.
                                       
                                    
                                    
                                       
                                          #Compare 1. Barbara, 〈$A|$V|$B〉=〈$C|be|$B〉〈$A|$V|$C〉. Note that we may
                                       
                                    
                                    
                                       
                                          #rotate variables in the conclusions to reflect the direct mapping from verbal examples.
                                       
                                    
                                    
                                       
                                          〈$B|may $V|$A〉=〈$B|may be|$C〉〈$C|$V|$A〉
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #Example test case, establishing 〈patients|may have|children〉
                                       
                                    
                                    
                                       
                                          〈patients|may be|mothers〉=10
                                       
                                    
                                    
                                       
                                          〈mothers|have|children〉=98
                                       
                                    
                                    
                                       
                                          〈children|include|baby〉
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          #4. Ferio.
                                       
                                    
                                    
                                       
                                          #E.g.Some humans are vegetarians. No vegetarians eat meat.
                                       
                                    
                                    
                                       
                                          # Some humans do not eat meat. Similar to 3. Darii.
                                       
                                    
                                    
                                       
                                          〈$A|may not $V|$B〉=〈$A|may be|$C〉〈$C|not $V|$B〉
                                       
                                    
                                    
                                       
                                          #Example test case, establishing 〈patients|may not give birth to|babies〉
                                       
                                    
                                    
                                       
                                          〈patients|may be|father〉=40
                                       
                                    
                                    
                                       
                                          〈father|not give birth to|baby〉
                                       
                                    
                                    
                                       
                                          :
                                       
                                    
                                 
                              
                           
                        
                     

The syllogistic form also plays a strong role in defining other relationships and vocabulary, and these are not distinct concepts.


                        #Construction examples relevant to X if Y and Z concepts are…
                     


                        〈$A|is prevalent in|$B〉=〈$B|has prevalence of|$A〉
                     


                        〈$A|is exposed to|$C〉=〈$A|visited|$B〉〈$C|is prevalent in|$B〉
                     

Metastatements work as follows.
                           
                              (1)
                              
                                 Match-and Edit Operations. Exemplifying the action of metastatements in general, syllogism 〈$A|are|$C〉=〈$A|are|$B〉〈$B|are|$B〉 scans the inference net to find and conceptually bring together pairs such as 〈cats|are|mammals〉 and 〈mammals|are|vertebrates〉 from which a new rule 〈cats|are|vertebrates〉 is generated. Its dual value is the product of the dual values of its parents. A metatstatement can match and edit in some detail by using forms such as such as〈the $A 
                                 and $B:=$C|cause|$D〉. To bind to a statement, the binding variables must all correspond to pieces of text in the statement in the same position, a binding variable must have a same name if it binds to same text, and must have a different name if the text is different. There is some laxity allowed for difference in features such as superfluous or repeated whitespace. Should the power of metastatements be inadequate, there is a fallback position for more advanced use. This is the regular expression or regex well known to computer science as a match-and-edit tool. It is applied to the stack of statements essentially as seen in the source code as input. There are several forms expressed in tags that will be described elsewhere.


                                 Transfer of Value. Because a new statement (say s
                                 1) is generated from an old statement or statements s
                                 2, s
                                 3, etc. (say by action of a metastatement, the dual probability (say d
                                 1) for the new statement must be computed from the old, d
                                 2, 
                                 d
                                 3, etc. In the case of the basic metastatement with relator=in configuration s
                                 1=s
                                 2 the value will be transferred as is, i.e., d
                                 1=d
                                 2. The default is that s
                                 2 is destroyed, so that the probabilities and so the quantitative value of the net remains with probability d
                                 2, not its square. The value transferred can be a more complicated calculation, because in the logical law of the contrapositive that implies 〈$A|are|$B〉=〈not $B|are|not $A〉 etc. but only holds under certainty. We can focus for present purposes on forms (s
                                 1=s
                                 2 
                                 and 
                                 s
                                 3) including s
                                 1=s
                                 2 
                                 s
                                 3 where AND is implied by default. The new dual is d
                                 1=d
                                 2
                                 d
                                 3. The important logical OR case is discussed below. Normally s
                                 2 and s
                                 3 are destroyed, so again the probabilities and quantitative information content of the net remains constant.


                                 Transfer of Value with Logical OR, and Reconciliation. With exclusive OR in 〈$A xor $B|are|$C〉=〈$A|are|$C〉〈$A〉xor 〈$B|are|$C〉, the dual d
                                 1=d
                                 2 
                                 xor 
                                 d
                                 3, for mutually exclusive $A and $B in s
                                 1=s
                                 2 
                                 xor 
                                 s
                                 3, is properly d
                                 1=((P(C
                                 |
                                 A)P(A)+P(C|B)P(B))/(P(A)+P(B)), P(A|C)+P(B|C)). It requires association constants to obtain the self-probabilities: P(x)=P(x|y)/K(x; y)). More convenient, therefore, are simpler forms. The superposition OR (SOR) where d
                                 1=d
                                 2+d
                                 3, approximates the above if P(A)≈P(B). SEOR is a semantically equivalent OR, or a synonymous effect OR, which is closely related to a randomly associated OR. The formula used is d
                                 1=d
                                 2+d
                                 3−d
                                 2
                                 d
                                 3. It uses the assumption that s
                                 2 and s
                                 3 
                                 mean the same thing and arise independently. It is also a means of accumulating knowledge from two or more statements s
                                 2, s
                                 3, etc. that are clearly not the same in meaning but support s
                                 1, which is the significance of the term synonymous effect. In this context it is essentially the same idea used to update certainty factors in the pioneering MYCIN system [20]. It is applied when s
                                 2 and s
                                 3 are detected as semantically equivalent forms that have arisen from duplicate entries of statements by experts or have arisen through dynamic inference, and s
                                 1 is the preferred canonical form. Note that s
                                 1←s
                                 1 
                                 or 
                                 s
                                 2 is an iteration with a constantly up-dating value d
                                 1 of s
                                 1 that is independent of the order of the presentation of the statements. It is applied for each pass of applying all the other metastatements, a step in the evolution. Net probabilities will tend to increase.


                                 Ogden Reduction and Expansion. The effect of two or more statements being replaced by less represents simplification of knowledge representation by net contraction. Metastatements can nonetheless be requested to perform the reverse operations resulting in net expansion, or a mix of the two. For example, there is the choice of the much smaller vocabulary of Ogden’s Basic English [16] (Ogden reduction, top down), or to start from Ogden’s vocabulary and build a more complex one (Ogden expansion, bottom up). The spirit of Ogden’s idea rather his exact vocabulary is used, and the terms Ogden expansion and Ogden reduction are used much more generally, since the compiler has no notion that will distinguish the Ogden-related metastatements from any other syllogistic or definitional forms. To allow reversal of contraction, a track is kept of all equivalent relator meanings defined by metadata, in a file called the thesaurus.

@&#RESULTS@&#

POPPER is found to be able to function like a BN and more precisely as a basic HDN which, by its 
                           h
                        -complex character, includes bidirectional probabilistic logic and allows cycles [2]. Extended to include more elaborate relationships has also been shown possible, although to be of particular quantitative and predictive value it is subjected to limitations discussed in Sections 5.1 and 5.2. These may be fundamental, as the examples given there illustrate. The above comments apply, however, to a static net. POPPER also performs automated reasoning on a network by deduction of new rules from old, and thus embraces the probabilistic and symbolic reasoning processes that have traditionally appeared in separate systems. In many respects, therefore, its functions resemble the fairly developments of a probabilistic PROLOG [31]. Note that POPPER statements correspond to PROLOG data and POPPER metastatements to PROLOG program. POPPER has two advantages over such approaches. First, it does have much of the machinery to go beyond simple logical relations and embrace natural linguistic forms. Second, it also has the advantages of 
                           h
                        -complex probability representation that the basic HDN possesses.

The initial inference cycle involves the application of all metatstaments, each once until the process halts. Subsequently, each cycle involves randomizing the order of meatstatement application and each one is applied only if a randomly generated number on the interval 0⋯1 exceeds a specified value, being 0.5 in the present case. In the present study hundreds of statements reduced to 80 after 20 cycles, then no further reduction was found over some 2000 cycles. There could, however, be future jumps to better solutions and there are methods of facilitating this (see Section 5). The total information content of the net tends to be maintained in dynamic inference even though the number of statements may be greatly reduced (or optionally increased), because of the transfer of values in Section 3.7 (2), though it may change with reconciliation as in Section 3.7 (3) Cases like universal-to-existential conversion that will be discussed elsewhere might be expected to increase probability since “some” seen as a hedge suggests that it should do so [1], but in POPPER one could write 〈some $A|are|$B〉=〈A|are|B〉〈$B|are|$A〉 that does not change the overall information content (if, of course, the two statements to the right are deleted).

One obtains islands of “conclusions” that might, or might not, be linked by adding new metastatements, and this is a fairly general finding. Statements of interest can be extracted using queries such as “dyspnoea” and “in baby” etc, as follows.
                           
                              
                                 
                                 
                                    
                                       
                                          Statements referring to dyspnoea and in baby.
                                       
                                    
                                    
                                       
                                          (dyspnoea in baby|be caused by|mother smoking)=98%
                                       
                                    
                                    
                                       
                                          Statements referring to TB and in baby.
                                       
                                    
                                    
                                       
                                          (TB in baby|not be indicated by|exudative effusuions seen in X-ray)=90%
                                       
                                    
                                    
                                       
                                          (TB in baby|indicated by|Area X in Asia)=75%
                                       
                                    
                                    
                                       
                                          (TB in baby|not be caused by|mother smoking)=98%
                                       
                                    
                                    
                                       
                                          Statements referring to dyspnoea and caused by.
                                       
                                    
                                    
                                       
                                          (dyspnoea|be caused by|TB or lung cancer or bronchitis or emphysema)=85%
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          Statements referring to caused by and smoking.
                                       
                                    
                                    
                                       
                                          (lung cancer|be caused by|smoking)=41%
                                       
                                    
                                    
                                       
                                          (bronchitis|be caused by|smoking)=75%
                                       
                                    
                                    
                                       
                                          (emphysema|be caused by|smoking)=11%
                                       
                                    
                                    
                                       
                                          (TB|may not attack|healthy lungs)=71%
                                       
                                    
                                    
                                       
                                          Statements referring to mother and cough.
                                       
                                    
                                    
                                       
                                          (mother coughs|not more than|baby coughs)=52%
                                       
                                    
                                    
                                       
                                          Statements referring to baby and cough.
                                       
                                    
                                    
                                       
                                          NONE
                                       
                                    
                                    
                                       
                                          Statements referring to baby and sleep.
                                       
                                    
                                    
                                       
                                          (baby sleeps|maybe as much as|average baby sleeps)=72%
                                       
                                    
                                    
                                       
                                          Statements referring to baby and heavy.
                                       
                                    
                                    
                                       
                                          (baby|be more heavy than|average baby)=81%
                                       
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          Statements referring to breast feed.
                                       
                                    
                                    
                                       
                                          mother|breast feeds less than|average mother)=66%
                                       
                                    
                                 
                              
                           
                        
                     

@&#DISCUSSION AND CONCLUSIONS@&#

The resulting general finding for a purely multiplicative network at very least describes the collective degree of truth of all the statements in it, looking in one direction of the relationships as written, and the collective degree of truth of all the statements in it looking in other direction of the relationships as written. From the perspective of 1 representing that a statement is an assertion awaiting refutation, −logP for each of these probabilities represents the amount of refuting information, i.e. the evidence against. If for the sake of argument we take 〈dogs|chase|cats〉=(0.8,0.2) and 〈cats|chase|mice〉=(0.9,0.1), then the result for that very simple network is the dual (0.72, 0.02)=(0.8×0.9, 0.2×0.1). As a small network of knowledge, 〈dogs|chase|cats〉〈cats|chase|mice〉 does tell us something about dogs, cats, and mice and their natures by virtue of their relationships, but nothing more. There is, however, one important utility of the overall probabilities of a net. When metastatements are applied to evolve a network, usually into one with less but adequately representative statements, we wish to see that there is no extensive information loss. For example, a syllogism in which the conclusion is existentially qualified (“some”) while the premises are universally qualified (“all”) will lose information. To have more interesting meaning in many medical settings, one must argue for a chain of effect that implies categorical, causal, or transformational relationships in the verbs in statements used.

Chain of effect occurs in many cases, for example spread of disease or contamination in epidemiology, or mechanisms of progression disease such as failure of systems in a chain that that lead to cancers. One way to approach it is by categorization of the relationship, i.e. putting it into an equivalent categorical form, as in 〈dogs|chase|cats〉=〈dogs|are|cat-chasers〉, but to say that 〈dogs|are|cat-chasers〉〈cats-chased|are|mice-chasers〉 requires a linker term 〈cat-chasers|cats-chased〉, or the assumption that this term equals 1 which is a POOA (principle of one-to-one action, Section 2.3) assumption. One can, however, almost always construct a network using statements in a categorical, causal, or transformational form in which the right hand side of the statement matches the left side of the statement that follows it, as in 〈A|R|B〉〈B|S|C〉〈C|T|D〉⋯ With R,S,T,… implying a chain of effect, this brings the net closer to the familiar BN. There is some art in this transformation, but similar challenges and pitfalls apply to building a BN “from scratch” and perhaps more so, since first building a hyperbolic probabilistic semantic network, i.e. with dual probabilities, might help. Consider the following epidemiological problem as a simple static net. There is a breach between a sewage system of a small town and a lake in which local fishermen cast nets for fish for local consumption. An infected person brings into two a new strain of a species of Vibrio bacillus and, via the sewage system, this enters the cycle of sewage to lake to fishing to consumption to sewage. To focus on the key issues, the following is compressed from a more elaborate network at the cost of some rather ugly wording in the arguments, and a simple stretch (Section 3.3) is made to give a symmetrical relationship in the case of statements (1)–(3). Writing out probability duals in full for clarity, we have
                           
                              (1)
                              〈Vibrio|is associated with|sewage〉=0.3,0.3

〈sewage|is associated with|lake X〉=0.1,0.1

〈lake X|is associated with|fish〉=1,1

〈fish|are|contaminated fish〉=0.2,1

〈contaminated fish|are|netted fish〉=0.1,0.2

〈netted fish|are|contaminated eaten fish〉=0.6,0.7

〈contaminated eaten fish|become|sewage〉=0.9, p

In the last line (7), the converse statement that that sewage becomes the contaminated and eaten fish looks at first absurd but, indirectly, that is actually the case and indeed the probability that we are interested in. It suffices to see that (a) since the (1)–(3) are symmetrical values that therefore just multiply the net, we can put them aside to determine p, because (b) statements (2)–(7) start with sewage and terminating with sewage, which imply the cyclic path. Note that (7) does not by itself balance the rest of the cyclic path (2)–(7), because of the otherwise convenient way that the statements were written. Rather, the product of the left side of all duals should balance the product of all those on the right: 0.1×1×0.2×0.1×0.6×0.9=0.1×1×1×0.2×0.7×p. That is because in a cyclic path with all needed and correctly assigned values, the products of probabilities in the two directions are equal, and the overall result for the cycle is that real value. In this case, the cycle has the value 0.00108 and p=0.077 or 7.7%. Including the first statement to represent the overall net gives 0.00032 or 0.032%. A BN, which typically assess a joint probability and, putting aside the fact that it cannot traditionally address a cyclic path, would obtain 0.032%. As a statement about the collective truth of the scenario, this is correct. However, that does not address the larger probability that contaminated fish are actually eaten. Not all fish are contaminated and not all that are netted are contaminated and eaten. Nor is the case that contaminated feces will end up in that troublesome sewage system, e.g., an infected person may travel that day. The estimation of 7.7% is not, however, always the probability of most interest. In the above, 7.7% was initially a missing value that was evaluated to ensure coherence of the net, assuming the other probabilities to be reliable [2]. Had there been a provisional estimate of 0.09 or 9% that was well founded, perhaps objectively by counting, and supposing that all other probabilities in (1)–(7) are similarly well-founded, then there must be some impactful statement that is missing. It must also be p′ x (1, 0.077/0.09)= p′ x (1, 0.856) where p′min≤p′≤1 where p′min is some minimal value that will not imply an unreasonably low value for p or for the collective degree of truth of the network as a whole.

It is clear that the above approach can provide powerful guidelines to net construction but it remains non-trivial. As regards POPPER language as input, a random sample of 15 medical students from the first three semesters were able to understand statements by analogy to the metrics of evidence based medicine and epidemiology, and metastatements by analogy to syllogisms as general rules of reasoning from statements. They understood the independency assumptions in P(A AND B)=P(A)P(B) and the epidemiologist’s chain rule P(A|B)P(B|C)P(C|D)⋯ They had no problem with the idea of probability calculations repeated in two directions of conditionality, having an introductory acquaintance with Bayes rule and being familiar with the “one third” probability diagnostic problem in the Introduction of Ref. [2]. They were also familiar with knowledge networks as “concept maps” linking medical ideas in medical revision textbooks. Hence they had no insurmountable difficulty in interpreting simple epidemiological nets including the above Vibrio example. However, they needed a significant degree of guidance to construct the nets that became a rapidly acquired skill in only 4 cases. The difficulty was not primarily in constructing statements and assigning preliminary probability values to them, but rather in doing so under the constraint of the statements fitting together as in the Vibrio example.

Hence, much easier for the students was the “brute force” strategy used in the large TB example, i.e. of helping throw into the mix (of statements based on the traditional representation of the problem) a large number additional statements that seemed likely to have some relevance. The hope here was that the evolution under the action of metastatements might resolve the issues and at least cast some insight, with statements that were found not to connect up to others to be discarded later. Here, unsurprisingly, the output after net evolution, shown in Section 4.3, caused the biggest conceptual difficulty. There was the promising indication that the baby may be more likely to have respiratory problems from the smoking than from TB
                           8
                        
                        
                           8
                           On examining why this was reached, it could be seen that TB is not well propagated from mother to baby, even via the placenta or breast feeding, assuming that it was passed on to the mother from the father who may have contracted TB in Asia. The practice of avoiding breast feeding if a mother has TB has been discouraged since the late 1990s [30].
                        , but what conclusions can be drawn from above results of the above kind that at first sight may appear a confusing mélange of fragmentary clues? Note that some were generated by inference, but some did not change from input. This fragment problem is not confined to POPPER for many reasons
                           9
                        
                        
                           9
                           Probabilistic inductive logic programming in general, including probabilistic variants of PROLOG, can have similar consequences if all the statements cannot link together in reasoning [31], although depending on the system philosophy it may just manifest as an attempted reasoning path that halts. It is easy to see that in using the classical chain rule P(A|Z)≈P(A|B)P(B|C)P(C|D)⋯P(X|Y)P(Y|Z) but proceeding by symbolically removing replacing P(B|C)P(C|D) by P(B|D) and so on will not complete to P(A|Z) if, say, P(X|Y) has been neglected in hurling a large number of conditional probabilities at the problem. Even for very large complicated nets where brute force addition of many probabilities that would appear to sufficient links somehow to complete evolution, Gödel׳s theorem explicitly gives no guarantees that starting from one point in reasoning will reach any other [32]. And even if it could in theory, it remains essentially a global optimization problem. Any long run does not guarantee reaching an optimal solution in reasonable time. More informed optimization methods may do better, but note that this is space of discrete states represent by discrete jumps, so that a simple gradient method is not helpful. Statements (not just metastatements) expressed as “extended twistors” [1,2] can take efficient account of symmetries in certain problems such as the farmer, fox goose and bag of beans problem [33] but these are relatively special cases.
                        , but even if all the issues were resolved, there remains a fundamental problem. Is the “optimal” solution in the above sense, even if reached, really what was wanted? The overall system involves another reasoning subsystem, one harder to account for, that of the human user.

@&#FUTURE WORK@&#

To overcome the above difficulties, a clue for a way forward is that one can achieve seemingly improved optimization results simply by “bridging the gaps” that POPPER could not cross by adding new statements and/or metastatements in an informed and judicious manner, effectively linking the fragments. This is the opportunity that is presented to a physician or epidemiologist after having queried solutions in the manner described in Section 4. We can, after all, see in the fragmentary islands of rules the statements and/or metastatements that would bridge them. Bringing in the impact of breast feeding could be done by statements that include items of information searched for separately in Section 4, and a statement about breast feeding and TB would be an obvious one. Indeed there naturally seem some omissions that reflect almost all variations on this popular baby-TB scenario (e.g. Refs. [34–37]) attributed to Spiegelhalter and colleagues [38]
                        
                           10
                        
                        
                           10
                           These are notably the baby׳s age, although one may assume that as a “baby” the baby is less than roughly 2 years old, and whether the baby received a BCG vaccine. These might be less critical considering that a young baby׳s underdeveloped immune system may not permit the vaccine to work, or require later revaccination for it to confer significant and sustained protection. However a physician using the system could be the judge as to whether such information should be added.
                        .

In some cases, island fragments arose because the meanings were not detected as related, and that was because relatedness at this level of metadata action is discrete. For example, there was inadvertently an absence of input statements relating to the baby coughing, since all references to the baby were regard to dyspnea, which is broader, but not completely embracing coughing, in meaning. This could be tackled by a hierarchic thesaurus of meaning using higher order metastatements that act on metastatements as we have explored with match-and-edit statements elsewhere [39] perhaps annotated as to meaning in different contexts
                           11
                        
                        
                           11
                           A very coarse but powerful categorization of contexts exists [14,15], as the physical world of space and motion, time, the mental world, and the ownership world, and by specification of animate or inanimate entities, and a few finer specifications as agents, coagents instruments etc. In most natural languages, words are borrowed from the physical world, and it shows up particularly with prepositions. Combining such efforts [14,15], it is possible to work with higher order metastatements as follows, 〈$A|$R by |animate:=agent:=$B〉,〈$A|$R by|inanimate:=conveyance:=$B〉,〈$A|$R with|animate:=accompaniment:=$B〉,〈$A|$R with|inanimate:=instrument:=$B〉,〈$A|$R with|animate:=coagent:=$B〉,〈$A|$R in|surroundings:=$B〉,〈$A|$R from|source:=$B〉,〈$A|$R from|surroundings:=$B〉, and so on. Since animate:=agent:=etc. are not normally and conveniently found in the basic input statements (though they could be), a more elaborate mode of metastatement interaction is required to accommodate this.
                        . Moreover a continuum of meaning in which words have coordinates on a hyperbolic surface seems promising and natural to the HDN, [40–42], as will be described elsewhere. In the interim, a medical user could still use expertise to enter statements and metastatements in all the above cases to fill the gaps that are shown up by the initial queries, repairing the fragmentation. This seems a valid strategy in its own right, especially attractive if extrapolated to an objective, efficient, routine, and highly automated fragmentation joining approach. That awaits a mature medical, and probabilistic, SW, but whatever automated tools are ultimately used, it will be important that medical students and physicians understand the basic principles of the methods, just as they were for decades taught biostatistics to underpin their understanding of medical research and clinical trials.

None declared.

@&#REFERENCES@&#

