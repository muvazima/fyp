@&#MAIN-TITLE@&#Motion-based segmentation of objects using overlapping temporal windows

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We divide a video sequence on overlapping subsequences.


                        
                        
                           
                           On each subsequence we perform over-segmentation, handling efficiently asynchronous trajectories.


                        
                        
                           
                           The number of moving objects is automatically estimated.


                        
                        
                           
                           The segmentation results are aggregated into a final segmentation.


                        
                        
                           
                           Our method is tested on the Berkeley motion segmentation benchmark.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Motion segmentation

Overlapping windows

Ranking

Local subspaces

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

The volume of video data recorded and stored has increased exponentially in the past years. Hence, there is a growing demand for video processing algorithms that can efficiently analyze and interpret the content of a video sequence. An important preliminary step in this direction, is the detection and separation of individual objects in a video. As studies on the human visual system have shown [1,2], motion is an important perceptual cue for the segmentation of objects. Consequently, much of computer vision research has been devoted to motion segmentation algorithms that try to imitate this attribute, by segmenting the objects in a video according to their motion.

Motion segmentation algorithms usually take as input the trajectories of a set of feature points tracked throughout a video. There is a large family of motion segmentation methods, influenced by the factorization algorithm [3], that adopt the affine camera model due to the geometric constraints the trajectories have to satisfy. One such approach is Generalized Principal Component Analysis (GPCA) [4] which uses a set of polynomials of degree n to fit a union of n subspaces. The derivatives of the polynomials at a point, produce a vector normal to the subspace the point belongs. The Local Subspace Affinity (LSA) [5] computes an affinity matrix between subspaces locally fitted to each point and then applies spectral clustering. Another algorithm, Agglomerative Lossy Compression (ALC) [6], assumes that data are drawn from a mixture of degenerate Gaussians. The algorithm proceeds by searching for the segmentation that minimizes the overall coding length of the segmented data. An approach relevant to ours is presented in [7]. In this algorithm, for each trajectory a ranking of a set of putative subspace hypotheses is computed and used to obtain the Ordered Residual Kernel. Next, KPCA and spectral clustering are applied on the produced kernel matrix. Another method is SCC [8] which uses polar curvature to compute an affinity between pairs of trajectories. More recent algorithms are Sparse Subspace Clustering (SSC) [9,10], Spectral Clustering (SC) [11], Low Rank Recovery (LRR) [12] and its expansion Latent LRR (LatLRR) [13]. SSC builds on the theory of sparse representation, utilizing the fact that every trajectory can be written as a sparse linear combination of trajectories of the same motion. Using the sparse representation of each trajectory, an affinity matrix is computed which is used for spectral clustering. The SC algorithm finds the dimension of the ambient space of the data and then applies spectral clustering. The LRR method, given a set of data vectors, finds the lowest rank matrix that can express the vectors as linear combinations of a dictionary. When used for motion segmentation both the dictionary and the original data vectors coincide with the matrix of trajectories. LatLRR is an enhanced version of LRR that uses both observed and unobserved data for the dictionary.

Most of the aforementioned algorithms have been tested on the Hopkins155 dataset [14] and some of them have shown exceptional results. This dataset has certainly helped researchers to evaluate their algorithms, however it is more suitable for generic subspace clustering methods and lacks some of the inherent challenges of motion segmentation. These challenges include long video shots, occlusions between objects and asynchronous as well as erroneous trajectories. To address this issue the authors of [15] have expanded the Hopkins155 dataset and introduced the more realistic Berkeley Motion Segmentation dataset along with an evaluation kit. Many algorithms have been tested on this benchmark including the one presented in [15]. Their method defines an affinity between trajectories even when they have small temporal overlap and then performs spectral clustering with model selection. The algorithm presented in [16] uses the previous method to produce clusters of point trajectories and computes a dense segmentation by exploiting color and edge information. The same authors in [17] adopt a higher order motion model that includes rotation and scaling. Then they perform motion segmentation using spectral clustering on hypergraphs. A different approach is presented in [18] where motion segmentation is modeled as a graph partitioning problem, where each node corresponds to a trajectory. Repulsive weights are set between trajectories that belong to different connected components in their duration. In [19] instead of performing spectral clustering, the discontinuities of spatially neighboring trajectories are detected. Another approach presented in [20] combines image segmentation and optical flow algorithms on GPU to perform fully dense motion segmentation even on long video sequences. The work in [21] follows a Bayesian framework constructing a graph from region trajectories for different frames.

While the latter approaches handle occlusions and asynchronous trajectories most of them become intractable for long video sequences. This stems from the large number of trajectories present in a long or rapidly changing video that can render the respective affinity matrix intractably large. The algorithm proposed in this paper overcomes this difficulty by temporally segmenting a video sequence into overlapping windows where the number of trajectories is manageable. Motion segmentation is performed on each temporal window and the individual results are aggregated into a final segmentation. Beyond that, our algorithm detects automatically the number of moving objects in a video sequence and handles effectively asynchronous trajectories.

In Fig. 1
                      we show a graphical abstract of the method. In the next section we present a mathematical formulation of the motion segmentation problem under the affine camera model. Section 3.1 explains how the proposed algorithm performs motion segmentation on each temporal window while Section 3.2 describes how the individual segmentations are combined to yield the final aggregate segmentation result. Extensive experiments demonstrating the efficacy of the algorithm have been included in Section 4. The same section contains also a detailed comparison of the proposed method against the state of the art methods proposed in [15 and 17].

A tracking algorithm applied on a video sequence of F frames, produces a set Q
                     ={t
                     
                        i
                     }
                        i
                        =1..L
                      of point trajectories. Each trajectory ti
                      has at most 2F elements and contains the 2D image coordinates of a tracked feature point. A trajectory may have missing entries throughout the duration of the video due to occlusions, the camera's limited field of view and mistracking caused by illumination changes. However, for the theoretical analysis of this section we assume that the trajectories {t
                     
                        i
                     }
                        i
                        =1..L
                      are complete. This constraint will be relaxed in the following section.

Under the affine camera model the trajectories of a rigidly moving object, regardless of their duration, lie in an affine subspace of dimension at most 3 [3]. To prove this claim, suppose that M points 
                        
                           
                              
                                 
                                    X
                                    i
                                 
                              
                              
                                 i
                                 =
                                 1.
                                 .
                                 M
                              
                           
                           
                           
                              
                                 
                                    X
                                    i
                                 
                                 ∈
                                 
                                    R
                                    3
                                 
                              
                           
                        
                      following a rigid motion are tracked for F frames. At frame j an affine camera projects {X
                     
                        i
                     }
                        i
                        =1..M
                      on points {x
                     
                        i
                     
                     
                        j
                     }
                        i
                        =1..M
                      of the camera plane according to equation:
                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      x
                                                      1
                                                      j
                                                   
                                                   ⋯
                                                   
                                                      x
                                                      M
                                                      j
                                                   
                                                
                                             
                                          
                                          ⏟
                                       
                                    
                                    
                                       2
                                       ×
                                       M
                                    
                                 
                                 =
                                 
                                    
                                       
                                          Ω
                                          j
                                       
                                       ⏟
                                    
                                    
                                       2
                                       ×
                                       3
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                X
                                                1
                                             
                                             …
                                             
                                                X
                                                M
                                             
                                          
                                       
                                       ⏟
                                    
                                    
                                       3
                                       ×
                                       M
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             
                                                d
                                                j
                                             
                                             …
                                             
                                                d
                                                j
                                             
                                          
                                       
                                       ⏟
                                    
                                    
                                       2
                                       ×
                                       M
                                    
                                 
                                 .
                              
                           
                        
                     
                  

By concatenating the respective equations over F frames the following equation emerges:
                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      x
                                                      1
                                                      1
                                                   
                                                   ⋯
                                                   
                                                      x
                                                      M
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   ⋮
                                                
                                             
                                             
                                                
                                                   
                                                      x
                                                      1
                                                      F
                                                   
                                                   ⋯
                                                   
                                                      x
                                                      M
                                                      F
                                                   
                                                
                                             
                                          
                                       
                                       ⏟
                                    
                                    
                                       U
                                       :
                                       
                                          
                                             2
                                             F
                                             ×
                                             M
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      Ω
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   ⋮
                                                
                                             
                                             
                                                
                                                   
                                                      Ω
                                                      F
                                                   
                                                
                                             
                                          
                                       
                                       ⏟
                                    
                                    
                                       Ω
                                       :
                                       
                                          
                                             2
                                             F
                                             ×
                                             3
                                          
                                       
                                    
                                 
                                 
                                 
                                    
                                       
                                          
                                             
                                                X
                                                1
                                             
                                             ⋯
                                             
                                                X
                                                M
                                             
                                          
                                       
                                       ⏟
                                    
                                    
                                       X
                                       :
                                       
                                          
                                             3
                                             ×
                                             M
                                          
                                       
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      d
                                                      1
                                                   
                                                   ⋯
                                                   
                                                      d
                                                      1
                                                   
                                                
                                             
                                             
                                                
                                                   ⋮
                                                
                                             
                                             
                                                
                                                   
                                                      d
                                                      F
                                                   
                                                   ⋯
                                                   
                                                      d
                                                      F
                                                   
                                                
                                             
                                          
                                       
                                       ⏟
                                    
                                    
                                       D
                                       :
                                       
                                          
                                             2
                                             F
                                             ×
                                             M
                                          
                                       
                                    
                                 
                              
                           
                        
                     where the ith column of U represents trajectory ti
                     . Hence, for a single moving object the column space of U is an affine subspace of dimension at most 3. The dimension is 2 if points {X
                     
                        i
                     }
                        i
                        =1..M
                      lie on a plane and 1 if they are on a line. As a consequence, when X has full rank, any trajectory ti
                      can be expressed as an affine combination of 4 others following the same motion:
                        
                           (3)
                           
                              
                                 
                                    t
                                    i
                                 
                                 =
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       4
                                    
                                 
                                 
                                 
                                    a
                                    j
                                 
                                 
                                    t
                                    
                                       k
                                       j
                                    
                                 
                                 ,
                                 
                                 where
                                 
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       4
                                    
                                 
                                 
                                 
                                    a
                                    j
                                 
                                 =
                                 1
                                 ,
                                 
                                 i
                                 ≠
                                 
                                    k
                                    j
                                 
                                 
                                 j
                                 ∈
                                 
                                    1
                                    ..
                                    4
                                 
                                 .
                              
                           
                        
                     
                  

Consequently, in the general case a 4-tuple of trajectories, belonging to a rigidly moving object, forms a basis for all the trajectories of the object. Our algorithm relies heavily on this observation, since it samples 4-tuples of trajectories. We assume that the sampled 4-tuples will include bases for all the available trajectories. Next, our algorithm computes for each trajectory a ranking vector by sorting these 4-tuples according to the respective reprojection error. If the affine camera model is a valid approximation, the entries in the ranking vector of a trajectory having the lowest error, correspond to 4-tuples following the same motion as the trajectory.

When the available data are corrupted by noise or the affine model is inadequate, Eq. (3) will be only approximately satisfied. In this case, the vector a
                     =[a
                     1,a
                     2,a
                     3,a
                     4]
                        T
                      of affine coefficients will be obtained by minimizing
                        
                           (4)
                           
                              
                                 
                                    J
                                    a
                                 
                                 =
                                 
                                    
                                       
                                          
                                             t
                                             i
                                          
                                          −
                                          
                                             
                                                ∑
                                                
                                                   j
                                                   =
                                                   1
                                                
                                                4
                                             
                                          
                                          
                                          
                                             a
                                             j
                                          
                                          
                                             t
                                             
                                                k
                                                j
                                             
                                          
                                       
                                    
                                    
                                       2
                                       ,
                                    
                                 
                                 subject
                                 
                                 to
                                 
                                 
                                    a
                                    T
                                 
                                 
                                    1
                                    →
                                 
                                 =
                                 1
                              
                           
                        
                     with respect to a, where 
                        
                           1
                           →
                        
                      is the vector of all ones. The minimum of Ja
                      is the residual of embedding ti
                      in the affine subspace spanned by 
                        
                           
                              
                                 t
                                 
                                    k
                                    j
                                 
                              
                           
                           
                              j
                              =
                              1..4
                           
                        
                     .

Our algorithm assumes that a tracker has already been applied on a video shot of F frames and a set of trajectories Q
                        ={t
                        
                           i
                        }
                           i
                           =1..L
                         has been extracted. The duration of each trajectory ranges from 2 up to F frames. The number of trajectories L can be very large depending on the density of the tracking algorithm, the duration of the shot as well as its content. Most existing methods model motion segmentation as a graph partitioning problem where each node represents a trajectory and an affinity between nodes is computed. The graph is usually partitioned using spectral clustering.

However, if L is large enough, spectral clustering can become inapplicable both in terms of computational complexity and memory storage. To avoid this difficulty, the proposed algorithm divides temporally each shot in N overlapping windows {w
                        
                           i
                        }
                           i
                           =1..N
                         of f frames, as Fig. 2
                         illustrates. Subsequently, the algorithm processes each window separately. As we explain in the following section, for every window wi
                         the algorithm uses a small number of complete trajectories throughout the window. In the unlikely case where all the trajectories in wi
                         are incomplete the length of the window is reduced.

At this level of the algorithm, our goal is not to produce a final segmentation. Instead we want to detect segments corresponding to a single object even if objects are oversegmented. Therefore, we defer to impose a hard constraint on the number of objects to Section 3.2.3.

The knowledge of the number of moving objects in each time window wi
                            is essential for the subsequent steps of the algorithm. A rough estimate of this number is initially obtained by considering the set of motion vectors associated with the complete trajectories in wi
                           . Motion between the first and the last frame of wi
                            is considered. The algorithm uses these motion vectors, to extract the number of moving objects in wi
                            and to create for each object a small set of trajectories. These sets will be next used to sample putative subspace hypotheses for the following step of the algorithm.

We employ the center-based clustering algorithm proposed in [23] that returns the number A(w
                           
                              i
                           ) of different motions and a set s
                           
                              j
                           (w
                           
                              i
                           )(j
                           =1..A(w
                           
                              i
                           )) of representative trajectories for every detected object in wi
                           . As Fig. 3a illustrates, some objects may have much more motion vectors compared to others. In this case the method presented in [23] may fail to detect small objects. To rectify this imbalance, a 2D histogram is computed where the axes correspond to the magnitude and angle of the motion vectors while the range for every bin is the same. A constant number of vectors is drawn from each bin. Using this simple scheme a more balanced set of motion vectors is acquired as the example in Fig. 3b shows. In Fig. 3c the clustering algorithm used, successfully separates the selected motion vectors.

This scheme may underestimate the number of objects when they follow similar motions. Therefore, when a window is processed, the algorithm does not impose a hard constraint on the number of objects, assuming that two objects under similar motions in a time window might follow more easily distinguishable motions in another. To this end, in Section 3.2.3, where spectral clustering is performed on a graph corresponding to an oversegmented video sequence, the number of objects A is set to
                              
                                 (5)
                                 
                                    
                                       A
                                       =
                                       
                                          max
                                          i
                                       
                                       A
                                       
                                          
                                             w
                                             i
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Furthermore, in the case of non-translational motions the number of moving objects may be overestimated, since motion vectors of the same object can be quite different. To alleviate this problem, we set the duration of each time window to a small value, where the translational approximation is adequate for most motions. In addition the clustering algorithm used [23] has a penalty parameter for the creation of new clusters. When the value of this parameter is relatively high, one can expect that motion vectors with small differences will be assigned to the same cluster.

At this point we assume that each set of trajectories s
                           
                              j
                           (w
                           
                              i
                           ), that was previously computed, roughly corresponds to a moving object in window wi
                           . From each set s
                           
                              j
                           (w
                           
                              i
                           ), B 4-tuples of trajectories are randomly sampled. Consequently, there will be (A(w
                           
                              i
                           )×
                           B) 4-tuples for window wi
                           . Theoretically, as explained in Section 2, the span of the trajectories in each 4-tuple, coincides with the affine subspace spanned by the trajectories of the respective moving object. Therefore each such 4-tuple is referred to as a motion hypothesis. Due to tracking noise and limitations of the affine camera model, the residual of Eq. (4) will be nonzero even for trajectories of the same object. Moreover, if misclassification errors occur in the clustering of the motion vectors, there can be erroneous motion hypotheses containing trajectories of different objects. Therefore, the residual should not be directly used to correlate a trajectory with a motion hypothesis, since its value can be relatively high or low depending on the motion.

The algorithm takes these limitations into consideration and does not relate directly a trajectory with a motion hypothesis using their residual. Instead, a ranking vector is computed for every trajectory in wi
                           , consisting of the motion hypotheses' indices sorted according to their residual. Concretely, the error vector 
                              
                                 
                                    e
                                    
                                       w
                                       i
                                    
                                 
                                 
                                    
                                       t
                                       k
                                    
                                 
                              
                            is formed for trajectory tk
                            by computing the residuals for every motion hypothesis in window wi
                           :
                              
                                 (6)
                                 
                                    
                                       
                                          e
                                          
                                             
                                                w
                                                i
                                             
                                          
                                       
                                       
                                          
                                             t
                                             k
                                          
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   
                                                      e
                                                      1
                                                      
                                                         
                                                            w
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         t
                                                         k
                                                      
                                                   
                                                
                                                
                                                   
                                                      e
                                                      2
                                                      
                                                         
                                                            w
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         t
                                                         k
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      e
                                                      
                                                         
                                                            A
                                                            i
                                                         
                                                         ×
                                                         B
                                                      
                                                      
                                                         
                                                            w
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         t
                                                         k
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Then by sorting the elements of 
                              
                                 
                                    e
                                    
                                       
                                          w
                                          i
                                       
                                    
                                 
                                 
                                    
                                       t
                                       k
                                    
                                 
                              
                            in descending order, vector 
                              
                                 
                                    
                                       
                                          e
                                          ˜
                                       
                                    
                                    
                                       
                                          w
                                          i
                                       
                                    
                                 
                                 
                                    
                                       t
                                       k
                                    
                                 
                              
                            emerges:
                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                e
                                                ˜
                                             
                                          
                                          
                                             
                                                w
                                                i
                                             
                                          
                                       
                                       
                                          
                                             t
                                             k
                                          
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   
                                                      e
                                                      
                                                         λ
                                                         1
                                                      
                                                      
                                                         
                                                            w
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         t
                                                         k
                                                      
                                                   
                                                
                                                
                                                   
                                                      e
                                                      
                                                         λ
                                                         2
                                                      
                                                      
                                                         
                                                            w
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         t
                                                         k
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      e
                                                      
                                                         λ
                                                         
                                                            
                                                               A
                                                               i
                                                            
                                                            ×
                                                            B
                                                         
                                                      
                                                      
                                                         
                                                            w
                                                            i
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         t
                                                         k
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where
                              
                                 
                                    
                                       
                                          e
                                          
                                             λ
                                             j
                                          
                                          
                                             
                                                w
                                                i
                                             
                                          
                                       
                                       
                                          
                                             t
                                             k
                                          
                                       
                                       ≤
                                       
                                          e
                                          
                                             λ
                                             
                                                j
                                                +
                                                1
                                             
                                          
                                          
                                             
                                                w
                                                i
                                             
                                          
                                       
                                       
                                          
                                             t
                                             k
                                          
                                       
                                       
                                       j
                                       ∈
                                       
                                          
                                             1
                                             ,
                                             …
                                             ,
                                             
                                                A
                                                i
                                             
                                             ×
                                             B
                                             −
                                             1
                                          
                                       
                                    
                                 
                              
                           finally the ranking vector of trajectory tk
                            is:
                              
                                 (8)
                                 
                                    
                                       r
                                       
                                          
                                             t
                                             k
                                          
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   
                                                      λ
                                                      1
                                                   
                                                
                                                
                                                   
                                                      λ
                                                      2
                                                   
                                                
                                                
                                                   ⋯
                                                
                                                
                                                   
                                                      λ
                                                      
                                                         
                                                            A
                                                            i
                                                         
                                                         ×
                                                         B
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

It is roughly expected that the indices of motion hypotheses containing trajectories under the same motion as tk
                            will concentrate on the left part of r(t
                           
                              k
                           ), even if their residual is nonzero. Intuitively, one can also assume that the ranking vectors of trajectories belonging to the same object will be relatively similar, even if the object was not detected and no motion hypotheses from its trajectories were drawn.

It should also be emphasized that a ranking vector can be computed, even if a trajectory is incomplete in the current window. In order to compute the residual of a motion hypothesis for an incomplete trajectory, the algorithm uses only the entries with the same timespan as the trajectory. Using this methodology even trajectories with small or no temporal overlap can be compared through their ranking vectors.

The algorithm uses the ranking vectors to compute an affinity between trajectories. Trajectories are assigned to the same cluster if they are connected with high affinities. Oversegmentation is acceptable at this point as long as each cluster corresponds to a single object.

Various metrics can correlate rankings [24–26], but we use the ORK, since it has successfully been applied on other motion segmentation algorithms [7,27]. The ORK K(m,n) for a pair of trajectories (t
                           
                              m
                           ,t
                           
                              n
                           ) is defined as:
                              
                                 (9)
                                 
                                    
                                       K
                                       
                                          m
                                          n
                                       
                                       =
                                       
                                          1
                                          Z
                                       
                                       
                                          
                                             ∑
                                             
                                                n
                                                =
                                                1
                                             
                                             
                                                D
                                                /
                                                h
                                             
                                          
                                       
                                       
                                       
                                          1
                                          n
                                       
                                       ⋅
                                       
                                          k
                                          ∩
                                          n
                                       
                                       
                                          
                                             r
                                             
                                                
                                                   t
                                                   m
                                                
                                             
                                             ,
                                             r
                                             
                                                
                                                   t
                                                   n
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 Z
                                 =
                                 
                                    
                                       ∑
                                       
                                          n
                                          =
                                          1
                                       
                                       
                                          D
                                          /
                                          h
                                       
                                    
                                 
                                 
                                 
                                    
                                       1
                                       n
                                    
                                 
                              
                           , h is a step parameter, and k
                           ∩
                           
                              n
                           (r(t
                           
                              m
                           ),r(t
                           
                              n
                           )) represents the Difference of Intersection Kernel [28]. The algorithm computes the ORK between all pairs of trajectories in wi
                           , and forms a symmetric L(w
                           
                              i
                           )×
                           L(w
                           
                              i
                           ) affinity matrix K, where L(w
                           
                              i
                           ) is the number of trajectories in window wi
                           .

We use the elements of K as the weights of an undirected graph of L(w
                           
                              i
                           ) nodes, where each one represents a trajectory in window wi
                           . The graph is partitioned by repeatedly selecting a node at random and finding all the nodes that connect to it through a path of high affinities. The algorithm concludes when all nodes are assigned to a subgraph. This procedure is described in Algorithm 1.

More sophisticated partitioning algorithms, such as spectral clustering [29] can be used. Nonetheless, we preferred Algorithm 1, because it does not assume knowledge of the number of subgraphs as a parameter and can detect a subgraph even if its nodes are not fully connected with high affinities. Algorithm 1 only requires that a transitive path exists between the nodes. This attribute is crucial in detecting large objects, since spatially neighboring trajectories of an object tend to have higher affinities compared with more distant ones. Consequently, an algorithm detecting fully connected subgraphs could fragment large objects as the example in Fig. 4
                            illustrates.


                           Algorithm 1 will often oversegment the objects in the window. However, most of the segments will comprise a small number of trajectories and larger ones can absorb them, following the agglomerative scheme described in Algorithm 2. We measure the compatibility between segments using the error metric proposed in Section 3.2.2.

At this point the algorithm has for each temporal window {w
                        
                           i
                        }
                           i
                           =1..N
                         an oversegmentation of its trajectories. To obtain a final segmentation we propose a mechanism to combine the results of consecutive windows and a metric of similarity between segments.
                           Algorithm 1
                           Graph partitioning
                                 
                                    
                                 
                              
                           

Merge Small Segments
                                 
                                    
                                 
                              
                           

The algorithm has processed each temporal window w
                           
                              i
                           ,i∈{1,⋯,N} and produced a separate segmentation for their trajectories. While temporally adjacent windows will often have similar segmentations they cannot be directly merged, since trajectories, and consequently segments, between windows do not have a bijective relation. For example, new objects can enter a scene or segments may vanish due to occlusion.

To associate segments of different windows, we first devise a method that fuses the segmentation choices of two successive windows. On each window we create a new segment containing trajectories that are present only on the other window. For example consider windows w′ and w″ in Fig. 5a. Algorithms 1 and 3 have so far identified segments 
                              
                                 
                                    
                                       S
                                       ′
                                    
                                 
                                 1
                              
                            and 
                              
                                 
                                    
                                       S
                                       ′
                                    
                                 
                                 2
                              
                            in w′ and segment 
                              
                                 
                                    
                                       S
                                       ″
                                    
                                 
                                 1
                              
                            in w″. The initial step of the aggregation if to artificially insert segments 
                              
                                 
                                    
                                       S
                                       ′
                                    
                                 
                                 3
                              
                            and 
                              
                                 
                                    
                                       S
                                       ″
                                    
                                 
                                 2
                              
                           , even though they contain trajectories that are not tracked for w′ and w″ respectively. With these insertions the union of the segments will be the same set of trajectories for both windows. The next step of the algorithm computes the intersection between segments of different windows. This produces new finer segments with the timespan of both windows as illustrated in the examples of Figs. 5b and 6
                           .

The algorithm continues by merging elements of this new set of segments that is now common to both w′ and w″ in order to obtain larger segments that resemble rigid objects. The proposed merging scheme relies on the use of the dissimilarity score presented in Section 3.2.2.

A vital component of our algorithm is the motion dissimilarity score used to determine the affinity between two segments in Algorithms 2 and 4. Let Sp
                            and Sq
                            be any two such segments that contain trajectories 
                              
                                 
                                    t
                                    1
                                    p
                                 
                                 ,
                                 
                                    t
                                    2
                                    p
                                 
                                 ,
                                 …
                                 ,
                                 
                                    t
                                    
                                       L
                                       p
                                    
                                    p
                                 
                              
                            and 
                              
                                 
                                    t
                                    1
                                    q
                                 
                                 ,
                                 
                                    t
                                    2
                                    q
                                 
                                 ,
                                 …
                                 ,
                                 
                                    t
                                    
                                       L
                                       q
                                    
                                    q
                                 
                              
                            respectively. Although Sp
                            and Sq
                            are spatially disjoint they may have an overlapping timespan. Using this overlap, we judge regarding their motion similarity in order to decide whether they correspond to the same solid motion, following the scheme described in Algorithm 3.

Concretely, for Sp
                            we compute the affine fundamental matrix F
                           
                              k
                           (S
                           
                              p
                           ) for every pair of consecutive frames k and k
                           +1, using the M
                           
                              k
                           
                           
                              p
                            available trajectories at each transition as shown in Fig. 7
                           . Then, for Sq
                            we compute at each frame transition the Sampson distance [30] for the available M
                           
                              k
                           
                           
                              q
                            correspondences using the previously computed F
                           
                              k
                           (S
                           
                              p
                           ). These distances form the error vector E(F
                           
                              k
                           (S
                           
                              p
                           ),S
                           
                              q
                           ) that has M
                           
                              k
                           
                           
                              q
                            elements. Concatenating the error vectors for all frame transitions, the algorithm produces a motion dissimilarity vector E(S
                           
                              p
                           ,S
                           
                              q
                           ) where:
                              
                                 (10)
                                 
                                    
                                       E
                                       
                                          
                                             S
                                             p
                                          
                                          
                                             S
                                             q
                                          
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   ⋯
                                                
                                                
                                                   E
                                                   
                                                      
                                                         
                                                            F
                                                            
                                                               k
                                                               −
                                                               1
                                                            
                                                         
                                                         
                                                            
                                                               S
                                                               p
                                                            
                                                         
                                                         ,
                                                         
                                                            S
                                                            q
                                                         
                                                      
                                                   
                                                
                                                
                                                   E
                                                   
                                                      
                                                         
                                                            F
                                                            k
                                                         
                                                         
                                                            
                                                               S
                                                               p
                                                            
                                                         
                                                         ,
                                                         
                                                            S
                                                            q
                                                         
                                                      
                                                   
                                                
                                                
                                                   ⋯
                                                
                                             
                                          
                                       
                                       .
                                    
                                 
                              
                           
                        

Similar to [15], we assume that the peaks of this vector correspond to the time instants that the motions of the segments are most dissimilar. Hence, these maxima are very informative in order to decide whether two segments should remain separated or be merged. To illustrate this point, consider the scenario where two segments follow different motions only for a small number of frames. If we use the peaks of the dissimilarity vector, we could easily distinguish their different motions, while an averaging scheme would fail to keep the segments separated. In addition to this, we must take into consideration that measurements can be erroneous due to mistracking or noisy trajectories especially when few correspondences are available.

To satisfy these observations, we assume that if the number of correspondences M
                           
                              k
                           
                           
                              p
                            used to calculate F
                           
                              k
                           (S
                           
                              p
                           ) is large its computation is more accurate. Hence, the influence of the respective error vector should increase. Under this assumption each error vector E(F
                           
                              k
                           (S
                           
                              p
                           ),S
                           
                              q
                           ) is replicated proportionally to M
                           
                              k
                           
                           
                              p
                            and vector 
                              
                                 
                                    E
                                    ˜
                                 
                                 
                                    
                                       
                                          F
                                          k
                                       
                                       
                                          
                                             S
                                             p
                                          
                                       
                                       ,
                                       
                                          S
                                          q
                                       
                                    
                                 
                              
                            emerges. Since the maximum of this vector can be affected by outliers, we employ a high percentile of 
                              
                                 
                                    E
                                    ˜
                                 
                                 
                                    
                                       
                                          F
                                          k
                                       
                                       
                                          
                                             S
                                             p
                                          
                                       
                                       ,
                                       
                                          S
                                          q
                                       
                                    
                                 
                              
                            as the final dissimilarity score. For our experiments we use the 90th percentile.

Using the metric defined in Section 3.2.2 for every pair of segments, we create a dissimilarity matrix. The algorithm merges segments with a dissimilarity below a predefined threshold. Algorithm 4 describes in detail how we merge the segmentation results of two consecutive windows. It should be emphasized that this mechanism can be applied independent of the other modules of the algorithm. It is useful, whenever parts of a video sequence are processed separately and we want to combine the segmentation results.

Various merging schemes are possible depending on the application, including the schemes illustrated in Fig. 8
                           . The windows are combined in pairs in Fig. 8a while in Fig. 8b we merge the first window with the second. This last scheme would be suitable for instance, if the segmentation algorithm runs parallel to the tracking.

In most cases after all windows are merged into a single one, the number of segments will be greater than the number of objects computed by Eq. (5). Hence, to obtain a final segmentation with the number of segments specified in Eq. (5), spectral clustering [29] is applied. We compute the affinity matrix for spectral clustering using the RBF kernel, where the distance is given by the metric defined in Section 3.2.2.
                              Algorithm 3
                              Dissimilarity Metric
                                    
                                       
                                    
                                 
                              

Aggregate successive windows
                                    
                                       
                                    
                                 
                              

@&#EXPERIMENTS@&#

We evaluate our algorithm on the Berkeley motion segmentation benchmark [15]. It comprises 26 video sequences with lengths ranging from 19 up to 800 frames. The benchmark includes an evaluation kit that measures various metrics of a video's segmentation. The first metric is density which shows the percentage of labeled pixels. The overall clustering error is the percentage of misclassified pixels over all the labeled pixels while the average clustering error represents the percentage of misclassified pixels per object averaged overall objects. The oversegmentation metric shows the number of segments merged to fit the groundtruth. The evaluation code also measures the number of objects detected with less that 10% excluding the background.

We use the tracker proposed in [22] with 4 pixels subsampling and discard trajectories with less than 3 frames length. Every video is temporally divided into windows of 10 frames with 2 frames overlapping unless stated otherwise. Each window is merged with the subsequent one in the tree-like of Fig. 8a.


                     Table 1
                      demonstrates the results of the algorithms proposed in [6,15 and 17]. To the best of our knowledge [17] has the best reported results in the Berkeley motion segmentation dataset. We have not included other methods mentioned in Section 1, because we used the full length of the videos in the dataset. Most of these methods do not report results under this setup either due to computational reasons or because they cannot handle efficiently incomplete trajectories. It should be noted that in entries marked with “*” the marple7 video sequence is excluded to allow comparison with [17] which cannot be applied on this sequence due to computational reasons. In Table 2
                      we show the results of our algorithm as we progressively apply stricter clustering whereas Fig. 9
                      illustrates an example. In general, pixel and object error worsen as oversegmentation increases although our algorithm produces meaningful segmentation even for very strict clustering. To decrease oversegmentation without deteriorating the other metrics we believe that cues complementary to motion would be helpful, especially for cases where segments of the same object have no time overlap due to occlusions.

Furthermore, Table 3
                      contains results for different window sizes. The optimal values are 12 to 14 frames. Oversegmentation increases for larger window sizes because motion vectors of the same object can differ significantly due to non-translational motion. In future work, we plan on introducing a scheme where the window size will be variable within each sequence and adapt to the content of the video. For example in a time interval where fast motion occurs relatively close to the camera the algorithm could benefit from smaller window size. Fig. 10
                      displays indicative results of our method on the dataset. The proposed algorithm, heavily depending on the time segmentation of the input video stream, has results comparable to the state of the art as Tables 1, 2 and 3 demonstrate.

We believe that the most essential advantage of our method is its scalability. Through temporal segmentation we can handle sequences with a large number of trajectories. Fig. 11a displays the number of trajectories for the video sequences after they are sorted. In Fig. 11b the memory utilization for [15,17] and our method is illustrated. The amount of memory used by [17] increases dramatically with the number of trajectories. In fact we were not able to run it for the marple7 sequence, due to memory limitations. On the other hand, the memory usage of our algorithm and [15] is much lower even for videos with a large number of trajectories. When our algorithm processes a video sequence it does not compute an affinity matrix for all the trajectories in the sequence, but only for the trajectories in each window. Therefore, in our case the memory utilization primarily depends of the number of trajectories per window which is a parameter that can be adjusted even at runtime. For example if the number of trajectories is very large the length of a window can be reduced. This attribute of our algorithm is crucial if one is dealing with high definition video, or dynamic scenes where constantly new trajectories enter the scene. In both these cases the number of trajectories will be much larger compared to the dataset used.

We do not include comparative performance measurements, because the current unoptimized MATLAB implementation would not be suggestive. However, Fig. 12
                      displays the computational time for all the sequences for various window sizes. This diagram demonstrates that the computational time decreases for larger windows. It should be noted that our algorithm can be easily parallelized as each window can be processed separately and consecutive windows can also be merged in parallel. All experiments where performed on an AMD FX-8350 processor. As a reference the execution time for the algorithm proposed in [15] was approximately 27h.

@&#CONCLUSIONS@&#

In this paper, we proposed a novel and modular approach to motion segmentation where video sequences are divided in time windows. Initial segmentation is carried out within a time window level and an aggregation mechanism for fusing multiple windows' segmentations has been introduced. Our algorithm has shown promising results and is suitable even for long video sequences.

In future work we plan on experimenting with different affinity metrics, introducing cues complementary to motion and with more challenging videos. Finally, a mechanism where the window size adapts to the content of the sequence will be a promising addition.

@&#REFERENCES@&#

