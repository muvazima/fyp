@&#MAIN-TITLE@&#Tool path generation for multi-axis freeform surface finishing with the LKH TSP solver

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new way of planning SFC type tool path is proposed.


                        
                        
                           
                           Cutting simulation method is proposed to evaluate the scallop error.


                        
                        
                           
                           Tool path planning task is formulated as a TSP and LKH is applied for solution.


                        
                        
                           
                           In LKH, the distance function is redefined to avoid incorrect linking problem.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Tool path planning

Cutting simulation method

traveling salesman problem

LKH

@&#ABSTRACT@&#


               
               
                  In freeform surface finishing, there are three major types of tool path topologies: the direction-parallel type, the contour–parallel type and the space-filling curve (SFC) type. The SFC topology is capable of covering the whole surface with only one path. In this paper, we present a new way of planning the SFC type tool path by formulating the planning task as a traveling salesman problem (TSP). The optimal path is generated in two steps. Firstly, a set of regular cutter contact (CC) points is generated on the input surface. A cutting simulation method is developed to evaluate the scallop error and determine the position of the next CC point in cross-feed direction. This method is free of local surface curvature assumptions and is therefore accurate for big cutters. Secondly, the obtained CC points are input into an efficient TSP solver LHK for the optimal CC point linking sequences. To stop the CC points from diagonal linking or penetrating linking, the Euclidean distance evaluation function for two CC points is redefined in LHK. The proposed tool path generation method is verified with several freeform surface examples; the results show that the method can automatically find the optimal feed direction and it can generate shorter tool path than the traditional SFC method. The feasibility of the proposed method is also verified by a cutting experiment.
               
            

@&#INTRODUCTION@&#

Efficient machining of freeform surfaces has become one of the most important tasks in many manufacturing industries, such as the automobile, consumer electronics, die-making and toy industries  [1]. Generally, the stages to complete freeform surfaces can be classified into roughing and finishing. In roughing process, the machining efficiency is always the first priority. The layer-by-layer machining approach is usually preferred since the tool path is calculated on 2D plane. The finishing process requires the machining efficiency as well as the accuracy. In finishing process, the tool path is organized on the 3D surface. The cutting tool traces a sequence of cutter contact (CC) points to approximate the surface, and the pattern of tracing is called tool path topology  [2]. The tool path topology and the linking strategy of the generated paths directly affect the machining time  [3].

For freeform surfaces finishing, there are three major types of tool path topologies: direction-parallel, ​contour–parallel and space-filling curve (SFC)  [2,4], as shown in Fig. 1
                     . Among the three types, the direction-parallel and the ​contour–parallel tool path topologies are the most widely used. These two topologies are usually calculated in a recursive manner based on the previous path elements.

In the direction-parallel tool path, the path elements are parallel with a reference line. If this line is defined in 2D parametric domain, the resulting path is called the iso-parametric path  [5–10]; and if this line is defined in 3D Euclidean space, the resulting path is called the iso-planar path  [11–14]. For the former path pattern, the reference line is always selected to be to one of the surface boundary curves. For the latter, the selection of the reference line has a direct effect on the total path length  [15]; usually, this line is parallel with the axis of a specified coordinate system. For freeform surfaces, the iso-parametric path is much easier to calculate than the iso-planar path since the latter has to deal with the complex surface–plane intersection problem. For both of the two path patterns, the parallel path elements can be linked in two ways: one-way and zigzag. The choice of one-way or zigzag milling is a trade-off between technological merits (quality) and machining time (productivity)  [16]. It is a general industrial practice that one-way milling is used for machining pre-hardened steel, while zigzag milling is widely used when cast-iron is machined  [1,4].

In the ​contour–parallel tool path, the path generation process can be considered as a successive shrinking process of a reference curve on the surface. Usually, the reference curve is constructed by linking the surface boundaries. The contour–parallel path topology can be further divided into two types according to the different shrinking methods used: the contour–parallel offset and the spiral. In practice, the contour–parallel path is widely used in the 2D layer-by-layer roughing process and is generally considered to be better than the direction-parallel path in context of the cutting load and the amount of air-cutting tool movement  [3,4]. For 2D case, many robust and efficient methods can be used to generate the contour–parallel offset path, such as the Voronoi diagram method  [18,19], the pair-wise intersection detection method  [20,21] and the straight skeleton method  [22,23]. In our previous research in  [24], a linear-performance offset algorithm is proposed by applying the contour profile updating rules. Nevertheless, for freeform surface finishing, the contour–parallel offset path topology is less popular, probably because it is computationally difficult to handle the local/global self-intersections (which often appear in the shrinking process) on irregular 3D surfaces.

In comparison with the direction-parallel or contour–parallel path topologies, the SFC path topology is non-mainstream. Yet it has attracted some research attentions in the last two decades, probably because it has the ability of evenly distributing over the surface with only one path, thus causing fewer tool retractions. The SFC method was first introduced to the tool path planning area by Cox et al.  [25] and Griffiths  [26] as a theoretical attempt. It was later employed and further developed by Anotaipaiboon and Makhanov  [17,27] with concepts of adaptive space-filling curve and curvilinear space-filling curve. Li  [28] further extended the work of Anotaipaiboon and Makhanov, but the case of irregular boundary has not been taken into consideration. In general, three steps are needed to generate the SCF tool path: grid generation, path generation and path correction. In our previous research in  [29], an improved space-filling curve (ISFC) method is proposed and applied to the T-spline surface tool path planning. In this method, the holes on the surface are automatically handled in the pre-image of the T-spline surface and the path direction change problem in traditional SFC has been tackled using the Hermite compensation curve. However, a built-in nature of the method is that the number of the column (or row) of the grids in the grid generation process is required to be even. If this number is odd, then an extra column (or row) of grids are inserted. Such operation will undoubtedly increase the total tool path length.

As a matter of fact, the problem of the SFC methods need to solve is to link the discrete CC points on the surface with one path. Such problem is similar to the traveling salesman problem (TSP). In TSP, a salesman asks the following question: Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city? The problem was first formulated in 1800s and in the last few decades, it was intensively studied by many researchers from mathematics, computer science, chemistry, physics, and other sciences. It belongs to the class of NP-complete problems. The TSP has many applications in real life, such as tour planning, logistics, microchip manufacturing and DNA sequencing. In tool path planning area, TSP has been used in layered manufacturing  [30], drilling  [31], pocketing  [32] and laser cutting  [33]. Even though the problem is computationally difficult, some efficient TSP solvers are now available, including Concorde, LKH, DynOpt, OptaPlanner, TSPGA and so on. So far, LKH holds the record for finding the best tour of the World TSP (http://www.math.uwaterloo.ca/tsp/world/) with 1,904,711 cities. It is implemented in the programming language C and the source code is open and free for academic research.

To overcome the disadvantage of the ISFC, in this paper, we treat the tool path planning task purely as a TSP. At first, the freeform surface is regularly tessellated into a set of CC grids with the proposed cutting simulation method. Each node of a grid is a CC point on the surface. Note that the scallop error between each pair of neighboring CC points must be within the prescribed tolerance. To ensure that, a cutting simulation method is provided to precisely control the positions of the CC points. Then the obtained CC points are input into the powerful TSP solver LKH. To avoid the situation that the generated tool path should pierce through the surface, and also to avoid the diagonal linking of the neighboring CC points, the CC points in the tessellation process are specially indexed and the distance evaluation function between two CC points is redefined in LKH. Theoretically, by using the TSP solver, the cutting tool should find a shortest path on the surface.

The rest of paper is organized as follows. In Section  2, the cutting simulation method is introduced. Based on that, regular CC grids are generated in Section  3. In Section  4, the LKH TSP solver is applied to the obtained CC grids, generating the TSP pattern tool path. Several comparative examples as well as a cutting experiment are given in Section  5. The last section concludes this paper.

In tool path planning, it is important to evaluate the scallop between CC points and based on that, determine the next CC point which satisfies the scallop error requirement in the cross-feed direction. Some mathematical models have been proposed to evaluate the scallop error, such as the classic equations given by Suresh and Yang  [34] and the feasible machining strip evaluation technique by Lee  [35]. One limitation of these models may come from the assumption of using local surface curvature at the current CC point in approximating the neighborhood surface  [35]. Such assumption is usually based on the condition that the tool size is very small, and may introduce extra errors as the tool size grows. In this section, a cutting simulation method is adopted to evaluate the scallop error. This method is free of the above assumption and is therefore accurate when cutters with various sizes are used. A similar form of such method is also used in our previous work to generate the iso-scallop tool path  [36].

Imagine that initially, the surface is planted with dense grasses and the heights of the grasses are set to be the prescribed scallop error. When the tool is placed onto the surface at a given CC point 
                        C
                     , the grasses near point 
                        C
                      will be cut short. These influenced grasses form a cut region on the surface, as shown in Fig. 2
                     . The left heights of the grasses in this region reflect the actual engagement between the tool and the stock material. This region can also be simply represented by a grass ring circled by the critical grasses from the boundary of the region, as shown in Fig. 2.

Theoretically, in the cross-feed direction of 
                        C
                     , another CC point 
                        
                           
                              C
                           
                           
                              t
                           
                        
                      can be found such that when the tool is placed to 
                        
                           
                              C
                           
                           
                              t
                           
                        
                     , the grass rings of 
                        
                           
                              C
                           
                           
                              t
                           
                        
                      and 
                        C
                      make tangent contact, as shown in Fig. 3
                     . However, in practice, it is almost impossible to directly locate such a point 
                        
                           
                              C
                           
                           
                              t
                           
                        
                      due to the irregular surface curvatures and the unpredictable shapes of the grass rings.

In this work, the CC point 
                        
                           
                              C
                           
                           
                              t
                           
                        
                      is found indirectly. As shown in Fig. 4
                     (a), suppose the grass ring of the current CC point 
                        C
                      is calculated, in the cross-feed direction of 
                        C
                     , a target grass 
                        
                           
                              G
                           
                           
                              t
                           
                        
                      can be found. Note that in the neighborhood of 
                        C
                     , the grass ring is considered to be symmetric about cross-feed direction. The target grass is the tangent grass commonly shared by the grass rings of 
                        C
                      and 
                        
                           
                              C
                           
                           
                              t
                           
                        
                     . In the neighborhood of the target grass, a set of CC points can be found such that when the tool is placed onto these CC points, the cutting edge touches right at the top of the grass, as shown in Fig. 4(b). These CC points form a CC ring around the target grass. The target CC point 
                        
                           
                              C
                           
                           
                              t
                           
                        
                      is in the cross-feed direction of 
                        C
                     . In the following, the details of finding 
                        
                           
                              C
                           
                           
                              t
                           
                        
                      will be explained, in which the first step is to find the target grass.

In order to find the target grass in the grass ring, the ring should be determined first. The easiest way to calculate the grass ring is to run intersection tests between all the grasses on the surface and the cutting edge of the current cutter location. However, when the number of grasses is large, the intersection tests would be very time-consuming. To efficiently determine the grass ring, a bisection method is used.

Consider that a grass on the surface can be represented by its root point 
                           G
                         as 
                           
                              (1)
                              
                                 G
                                 
                                    (
                                    u
                                    ,
                                    v
                                    )
                                 
                                 =
                                 S
                                 
                                    (
                                    u
                                    ,
                                    v
                                    )
                                 
                                 ,
                              
                           
                         in which 
                           S
                           
                              (
                              u
                              ,
                              v
                              )
                           
                         is the surface expression. In the neighborhood of a given CC point 
                           C
                        , the surrounding grasses can be represented as 
                           
                              
                                 (2a)
                                 
                                    
                                       
                                          u
                                       
                                       
                                          G
                                       
                                    
                                    =
                                    
                                       
                                          u
                                       
                                       
                                          C
                                       
                                    
                                    +
                                    d
                                    cos
                                    φ
                                    ,
                                 
                              
                              
                                 (2b)
                                 
                                    
                                       
                                          v
                                       
                                       
                                          G
                                       
                                    
                                    =
                                    
                                       
                                          v
                                       
                                       
                                          C
                                       
                                    
                                    +
                                    d
                                    sin
                                    φ
                                    ,
                                 
                              
                           
                         in which (
                           
                              
                                 u
                              
                              
                                 C
                              
                           
                           ,
                           
                           
                              
                                 v
                              
                              
                                 C
                              
                           
                        ) are the parametric coordinates of 
                           C
                         (denoted by 
                           
                              
                                 C
                              
                              
                                 ˆ
                              
                           
                        ), (
                           
                              
                                 u
                              
                              
                                 G
                              
                           
                           ,
                           
                           
                              
                                 v
                              
                              
                                 G
                              
                           
                        ) are the parametric coordinates of a surrounding grass (denoted by 
                           
                              
                                 G
                              
                              
                                 ˆ
                              
                           
                        ), 
                           d
                         is the distance from 
                           
                              
                                 G
                              
                              
                                 ˆ
                              
                           
                         to 
                           
                              
                                 C
                              
                              
                                 ˆ
                              
                           
                         and 
                           φ
                         is the angle between 
                           
                              
                                 C
                              
                              
                                 ˆ
                              
                           
                           
                              
                                 G
                              
                              
                                 ˆ
                              
                           
                         and the 
                           u
                           +
                         line, as shown in Fig. 5
                        . From Eq. (2), it can be seen that a grass 
                           G
                         in the neighborhood 
                           C
                         can also be represented in terms of polar coordinates as 
                           G
                           
                              (
                              φ
                              ,
                              
                              d
                              )
                           
                        .

As shown in Fig. 6
                        , in a particular 
                           φ
                         direction from the CC point 
                           C
                        , when 
                           d
                         varies from 0 to a large value, the intersecting point (if there is one) between the grass and the cutting edge moves along the grass gradually from the root to the top. The critical 
                           d
                         value that makes the grass top intersect the cutting edge can be found through a bisection method as shown in Fig. 7
                        , in which 
                           
                              
                                 d
                              
                              
                                 
                                    lower
                                 
                              
                           
                         is set to be 0 and 
                           
                              
                                 d
                              
                              
                                 
                                    upper
                                 
                              
                           
                         is set to be a relatively large real number. When 
                           d
                           =
                           
                              
                                 d
                              
                              
                                 
                                    lower
                                 
                              
                           
                        , the cutting edge touches the grass at its root; and when 
                           d
                           =
                           
                              
                                 d
                              
                              
                                 
                                    upper
                                 
                              
                           
                        , the cutting edge does not contact with any part of the grass. In Fig. 7, 
                           
                              
                                 d
                              
                              
                                 ε
                              
                           
                         is the resolution of 
                           d
                         in parametric domain. It controls the precision of the calculated critical grass position and also the iterations of bisection.

With the above bisection, when 
                           φ
                         increases from 0 to 
                           2
                           π
                        , all the critical grasses on the boundary of the cut region can be found. In real computational implementation, an increasing step 
                           
                              Δ
                           
                           φ
                         can be set to 
                           φ
                         in order to get a set of discrete critical grasses on the grass ring. For these discrete critical grasses, the target grass 
                           
                              
                                 G
                              
                              
                                 t
                              
                           
                         can be selected in the perpendicular direction of 
                           
                              f
                           
                        , in which 
                           
                              f
                           
                         is the feed direction of CC point 
                           C
                        , as shown in Fig. 4(a). Note that the feed direction of a CC point must be on the tangent plane of the CC point.

The process of finding the target CC point 
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                         according to the target grass 
                           
                              
                                 G
                              
                              
                                 t
                              
                           
                         can be considered as a reverse process of finding the target grass. The CC ring has to be calculated at first. In the neighborhood of 
                           
                              
                                 G
                              
                              
                                 t
                              
                           
                        , the surrounding CC points can be represented as 
                           
                              
                                 (3a)
                                 
                                    
                                       
                                          u
                                       
                                       
                                          C
                                       
                                    
                                    =
                                    
                                       
                                          u
                                       
                                       
                                          G
                                       
                                    
                                    +
                                    d
                                    cos
                                    φ
                                    ,
                                 
                              
                              
                                 (3b)
                                 
                                    
                                       
                                          v
                                       
                                       
                                          C
                                       
                                    
                                    =
                                    
                                       
                                          v
                                       
                                       
                                          G
                                       
                                    
                                    +
                                    d
                                    sin
                                    φ
                                    ,
                                 
                              
                           
                         in which (
                           
                              
                                 u
                              
                              
                                 G
                              
                           
                           ,
                           
                           
                              
                                 v
                              
                              
                                 G
                              
                           
                        ), (
                           
                              
                                 u
                              
                              
                                 C
                              
                           
                           ,
                           
                           
                              
                                 v
                              
                              
                                 C
                              
                           
                        ), 
                           d
                         and 
                           φ
                         have the similar meanings as in Eq. (2).

For particular 
                           d
                         and 
                           φ
                         values, the coordinates of the corresponding CC point (denoted by 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                        ) in the parametric domain can be calculated with Eq. (3). Then the coordinates as well as the normal vector (denoted by 
                           
                              
                                 
                                    n
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                        ) in the 3D space can be calculated through the surface expression 
                           S
                           
                              (
                              u
                              ,
                              
                              v
                              )
                           
                        . 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         could be a candidate CC point for the CC ring, so it is necessary to place a tool on it and then test whether the cutting edge touches the top of the target grass 
                           
                              
                                 G
                              
                              
                                 t
                              
                           
                        . To locate the tool, the local coordinate system (LCS) for 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         should be established first. With the coordinates of 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         and 
                           
                              
                                 
                                    n
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                        , it is only necessary to determine the feed direction of 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                        , which is denoted by 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                        .

If 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         is to be the required target CC point 
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                        , then 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         should be in the perpendicular direction of 
                           
                              f
                           
                        , in which 
                           
                              f
                           
                         is the feed direction of 
                           C
                        , as shown in Fig. 4(a). Theoretically, the feed direction of 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         should be parallel to 
                           
                              f
                           
                        , namely 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                           =
                           
                              f
                           
                         However, as vectors 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                         and 
                           
                              f
                           
                         are on different tangent planes of 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         and 
                           C
                        , they might not be equal. In practice, as shown in Fig. 8
                        , 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                         is calculated by projecting 
                           
                              f
                           
                         onto the tangent plane of 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                        . In Fig. 8, 
                           
                              i
                           
                         and 
                           
                              j
                           
                         are two random orthogonal unit vectors on the tangent plane. With 
                           
                              i
                           
                         and 
                           
                              j
                           
                        , 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                         can be represented as 
                           
                              (4)
                              
                                 
                                    
                                       
                                          f
                                       
                                    
                                    
                                       
                                          r
                                       
                                    
                                 
                                 =
                                 
                                    (
                                    
                                       f
                                    
                                    ⋅
                                    
                                       i
                                    
                                    )
                                 
                                 ⋅
                                 
                                    i
                                 
                                 +
                                 
                                    (
                                    
                                       f
                                    
                                    ⋅
                                    
                                       j
                                    
                                    )
                                 
                                 ⋅
                                 
                                    j
                                 
                                 ,
                              
                           
                         in which ‘
                           ⋅
                        ’ is the dot product operator of two vectors.

With the obtained 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                        , 
                           
                              
                                 
                                    n
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                         and 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                        , the LCS can be built with 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         as its origin, 
                           
                              
                                 
                                    n
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                         and 
                           
                              
                                 
                                    f
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                         as the directions of the 
                           Z
                         and 
                           X
                         axes, respectively. The direction of the 
                           Y
                         axis of the LCS (denoted by 
                           
                              
                                 
                                    b
                                 
                              
                              
                                 
                                    r
                                 
                              
                           
                        ) can be identified using the right hand rule. In the LCS, the tool center point and axis direction can be determined using the generic tool posture equations provided in our previous research  [37]: 
                           
                              
                                 (5)
                                 
                                    
                                       T
                                    
                                    =
                                    
                                       n
                                    
                                    cos
                                    β
                                    +
                                    
                                       (
                                       
                                          f
                                       
                                       cos
                                       θ
                                       +
                                       
                                          b
                                       
                                       sin
                                       θ
                                       )
                                    
                                    sin
                                    β
                                    ,
                                 
                              
                              
                                 (6)
                                 
                                    O
                                    =
                                    C
                                    +
                                    
                                       n
                                    
                                    ⋅
                                    
                                       (
                                       
                                          
                                             R
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             R
                                          
                                          
                                             1
                                          
                                       
                                       /
                                       sin
                                       β
                                       )
                                    
                                    −
                                    
                                       T
                                    
                                    ⋅
                                    
                                       
                                          R
                                       
                                       
                                          1
                                       
                                    
                                    /
                                    tan
                                    β
                                    ,
                                 
                              
                           
                         where 
                           
                              f
                           
                        , 
                           
                              b
                           
                         and 
                           
                              n
                           
                         are the unit vectors of 
                           X
                        -, 
                           Y
                        - and 
                           Z
                        -axis of a LCS, 
                           O
                         is the tool center point and 
                           
                              T
                           
                         is the tool axis unit vector, 
                           β
                         is the tool axis leaning angle formed by 
                           
                              T
                           
                         and 
                           
                              n
                           
                        , 
                           θ
                         is the tool axis rotational angle around the 
                           Z
                        -axis, 
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                         are the corner radius and bottom radius, respectively, as shown in Fig. 9
                        . Eqs. (5) and (6) are derived from the geometry model of a fillet-end mill, which is considered to be the generic tool model. By adjusting 
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                         values, a fillet-end mill can turn into a ball-end or flat-end mill. In Eqs. (5) and (6), the calculated 
                           O
                         and 
                           
                              T
                           
                         ​describe the cutter location.

With the obtained cutter location on CC point 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                        , test can now be run to identify whether the cutting edge intersect the target grass 
                           
                              
                                 G
                              
                              
                                 t
                              
                           
                        . Note that 
                           
                              
                                 C
                              
                              
                                 r
                              
                           
                         is controlled by 
                           d
                         and 
                           φ
                         values. For a particular 
                           φ
                        , the critical 
                           d
                         value can also be found using a similar bisection method to that in Fig. 7, thus the coordinates of the corresponding critical CC point can be determined. Likewise, when 
                           φ
                         increases from 0 to 
                           2
                           π
                        , all the critical CC points can be calculated and they form the CC ring. In the CC ring, the target CC point 
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                         is the one in the perpendicular direction of 
                           
                              f
                           
                        , as shown in Fig. 4(a).

The cutting simulation method introduced in Section  2 allows us to precisely calculate the next CC point in the cross-feed direction according to the current one without using any surface curvature assumptions. This method is accurate regardless of the tool size. Based on this method, regular CC grids that satisfy the scallop error requirement can be generated on the surface. The details are as follows.

In this work, we only take a patch of untrimmed surface 
                        S
                        
                           (
                           u
                           ,
                           
                           v
                           )
                        
                      for example. The path curves are generated in a recursive way. At first, in 
                        u
                     -direction, the 
                        u
                        =
                        0
                      boundary curve is selected to be the primary path. On this curve, a number of sample CC points are evenly picked. Based on the sample CC points, a set of corresponding CC points can be calculated using the cutting simulation method. Theoretically, if these CC points are properly fitted, iso-scallop tool path can be generated. However, in this paper, the iso-parametric method is used since it is the easiest way to constrain the scallop. The CC point that has the minimum 
                        u
                      value is picked and this 
                        
                           
                              u
                           
                           
                              
                                 min
                              
                           
                        
                     -curve is used as the second path. Then the second path is used as the primary path to generate the third path. This process goes recursively until the whole surface is covered. The obtained paths are actually a set of parallel 
                        u
                     -lines in the parametric domain. Then in 
                        v
                     -direction, the same process is recursively carried out and the result is a set of parallel 
                        v
                     -lines. By crossing these two sets of 
                        u
                     - and 
                        v
                     -lines in the parametric domain results in a number of regular grids. Each node of a grid is a CC point if the node is mapped onto the 3D surface, as shown in Fig. 10
                     . Note that if the tool moves along the borders of grids, the scallop left between two adjacent borders should be within the error tolerance, as shown in Fig. 10. For compound or trimmed surfaces, different methods of creating grids should be developed.

To store the coordinates of the obtained CC point, a data structure is defined as follows (described in C++ programming language).


                     
                        
                           
                              
                              
                                 
                                    struct CC_Point {
                                 
                                 
                                    
                                       
                                       double   
                                          x
                                       , 
                                          y
                                       , 
                                          z
                                       ;
                                 
                                 
                                    
                                       
                                       double   
                                          u
                                       , 
                                          v
                                       ;
                                 
                                 
                                    
                                       
                                       int
                                       
                                       
                                          i
                                          u
                                       , 
                                          i
                                          v
                                       ;
                                 
                                 
                                    };
                                 
                              
                           
                        
                     
                  

In this structure, the real numbers 
                        x
                     , 
                        y
                      and 
                        z
                      are the coordinates of the CC point in Euclidean space, the real numbers 
                        u
                      and 
                        v
                      are the coordinates of the CC point in the parametric domain, and the integers 
                        i
                        u
                      and 
                        i
                        v
                      are the corresponding indexes of the 
                        u
                     - and 
                        v
                     -lines in the line sets. For example, if 
                        i
                        u
                        =
                        5
                      and 
                        i
                        v
                        =
                        1
                     , it means the current CC point is the intersection of the 5th 
                        u
                     -line and 1st 
                        v
                     -line in the parametric domain, as shown in Fig. 10. The reason why these two indexes are recorded will be explained in the following section.

The obtained set of CC points can be linked one by one using the traditional zigzag or one-way method according the recorded 
                        i
                        u
                      and 
                        i
                        v
                      values. However, the length of the resulting tool path might not be optimum. In order to generate shorter tool path, in this section, the CC points linking problem are treated purely as a TSP. A powerful TSP solver LKH is employed to get the desired linking sequences of the CC points. Before that, the LKH TSP solver is briefly introduced.

LKH is an effective implementation of the Lin–Kernighan (LK) heuristic by Keld Helsgaun. The LK algorithm is generally considered to be one of the most effective methods for generating optimal or near-optimal solutions for the traveling salesman problem. It belongs to the class of the local optimization algorithms. The algorithm is specified in terms of exchanges (or moves) that can covert one tour into another  [38]. Given a feasible tour, the algorithm repeatedly performs exchanges that reduce the length of the current tour, until a tour is reached for which no exchange yields an improvement  [39]. For example, as shown in Fig. 11
                        , for the local tour A–B–C–D–E–F, if the length of a new tour A–C–B–E–D–F is shorter than current one, it is replaced by the new tour. This process may be repeated many times from initial tours generated in some randomized way.

Helsgaun pointed that Lin and Kernighan’s original heuristic rules suffer from considerable defects. He further modified and extended the LK algorithm by using larger (and more complex) search steps and sensitivity analysis to direct and restrict the search. The new algorithm (LKH) makes it possible to find optimal solutions to large-scale problems and it is much more effective than the old one. It is reported that the running time of the LKH algorithm increases approximately as 
                           
                              
                                 n
                              
                              
                                 2.2
                              
                           
                        , in which 
                           n
                         is the number of cities. With LKH, for a typical 100-city problem the optimal solution is found in less than a second, and for a typical 1000-city problem optimum is found in less than a minute (on a 300 MHz G3 Power Macintosh as reported)  [39].

In the implementation of LKH, more than 40 parameters are defined. The values of these parameters have a great influence on the performance of LKH. Fortunately, Helsgaun had assigned default values to each of the parameters. As stated by Helsgaun himself, these default values have proven to be adequate in many applications. In this work, all the parameters are left untouched except the parameters INITIAL_PERIOD, MAX_TRIALS and RUNS. In LKH, the default INITIAL_PERIOD and MAX_TRIALS values are 
                           n
                           /
                           2
                         and 
                           n
                        , respectively, in which 
                           n
                         is the city number. Helsgaun advices us that for large-scale cases these two values can be set smaller in order to save computation. In this work, when 
                           n
                           <
                           1000
                        , we use the default settings of INITIAL_PERIOD and MAX_TRIALS; otherwise they are both set to be DIMENSION/13, in which DIMENSION is number of cities. As for the parameter RUNS, it specifies the total number of iterations when LKH is executed and has a default value of 10. To speed up the program executing time, RUNS might be set to smaller integers in this work.

In addition to the parameters, several distance functions are predefined to calculate the actual distance between each pair of cities, such as Euclidean distance, Manhattan distance, Geographical distance and so on. However, none of these functions are adequate for the tool path planning task in this work. The Euclidean distance function between each pair of CC points needs to be redefined.

In 3D space, the general Euclidean distance between two arbitrary points 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                              
                                 
                                    y
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                              
                                 
                                    z
                                 
                                 
                                    1
                                 
                              
                              )
                           
                         and 
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                           
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                              
                                 
                                    y
                                 
                                 
                                    2
                                 
                              
                              ,
                              
                              
                                 
                                    z
                                 
                                 
                                    2
                                 
                              
                              )
                           
                         is formulated as
                           
                              (7)
                              
                                 
                                    
                                       d
                                    
                                    
                                       
                                          Euc
                                       
                                    
                                 
                                 
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      1
                                                   
                                                
                                                −
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      y
                                                   
                                                   
                                                      1
                                                   
                                                
                                                −
                                                
                                                   
                                                      y
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      z
                                                   
                                                   
                                                      1
                                                   
                                                
                                                −
                                                
                                                   
                                                      z
                                                   
                                                   
                                                      2
                                                   
                                                
                                                )
                                             
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                         in which 
                           
                              
                                 d
                              
                              
                                 
                                    Euc
                                 
                              
                           
                         is the Euclidean distance. However, when applying LKH to tool path planning, the general distance formula as in Eq. (7) may cause problems such as diagonal linking or penetrating linking of the CC points.

Let us take an arbitrary grid 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                           
                              
                                 C
                              
                              
                                 4
                              
                           
                         on the surface for example, as shown in Fig. 10. When the tool moves along the paths 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 C
                              
                              
                                 4
                              
                           
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                         (or 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                              
                                 C
                              
                              
                                 4
                              
                           
                         and 
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                        ), the scallop left between the two paths is within the error tolerance according the grid generation principles in Section  3. However, when the tool moves diagonally from 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                         to 
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                        , the resulting scallop error is unpredictable. Such diagonal tool moves must be avoided. Nevertheless, with Eq. (7), diagonal linking in LKH is inevitable, since in reality the length of 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                         might be shorter than that of 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                         or 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           
                              
                                 C
                              
                              
                                 4
                              
                           
                         on the 3D surface.

Besides, when the surface is as curved as shown in Fig. 12
                        , terrible things may happen. In Fig. 12, the CC point 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                         should be linked to 
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                        , 
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                        , 
                           
                              
                                 C
                              
                              
                                 4
                              
                           
                         or 
                           
                              
                                 C
                              
                              
                                 5
                              
                           
                         since they are on the same row or column. However, if Eq. (7) is called in LKH to calculate the CC point distance, penetrating linking from 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                         through the surface to 
                           
                              
                                 C
                              
                              
                                 6
                              
                           
                         may happen simply because such linking may result shorter tool path length. Such linking is a disaster for the machining process thus must be avoided.

To solve the above two problems, the recorded indexes in the CC_Point structure are also used in the CC point distance evaluation. With the two indexes, Eq. (7) is modified to 
                           
                              (8)
                              
                                 
                                    
                                       d
                                    
                                    
                                       
                                          Euc
                                       
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       d
                                    
                                    
                                       
                                          Euc
                                       
                                    
                                 
                                 
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                                 ⋅
                                 
                                    foo
                                 
                                 
                                    (
                                    
                                       ‖
                                       
                                          
                                             C
                                          
                                          
                                             1
                                          
                                       
                                       .
                                       i
                                       u
                                       −
                                       
                                          
                                             C
                                          
                                          
                                             2
                                          
                                       
                                       .
                                       i
                                       u
                                       ‖
                                    
                                    +
                                    
                                       ‖
                                       
                                          
                                             C
                                          
                                          
                                             1
                                          
                                       
                                       .
                                       i
                                       v
                                       −
                                       
                                          
                                             C
                                          
                                          
                                             2
                                          
                                       
                                       .
                                       i
                                       v
                                       ‖
                                    
                                    )
                                 
                                 ,
                              
                           
                         in which ‘
                           
                              ‖
                              
                              ‖
                           
                        ’ is the absolute value operator and foo is a simple function defined as 
                           
                              
                                 
                                    foo
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             1
                                             ,
                                          
                                          
                                             if  
                                             x
                                             =
                                             1
                                          
                                       
                                       
                                          
                                             ∞
                                             ,
                                          
                                          
                                             if  
                                             x
                                             ≠
                                             1
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

By substituting Eq. (8) into LKH, a CC point is only allowed to link its neighboring CC point on the same row or column, otherwise the resulting distance is reaching infinite. In this way, the unpredictable scallop error caused by diagonal linking or the trouble caused by penetrating linking can be well eliminated.

The set of CC points obtained in Section  3 are input into LKH, in which the distance function is modified as Eq. (8). The output of LKH is a set of integers identifying the sequences of the corresponding CC points in the to-be-generated tool path. The CC points are then linked one by one according to the obtained sequences and the result is a linked CC trajectory (actually a list of reordered CC points). However, this CC trajectory cannot directly be used to drive the tool. The cutter locations have to be calculated first.

Three kinds of end mills are often used in the freeform surface finishing, which are ball-end mill, fillet-end mill and flat-end mill. Technically, fillet-end mills and flat-end mills are more efficient in case of finishing since they have wider machining strips. In this work, ball-end mills are used because of the simplicities in the geometry. A ball-end mill has a unique feature that its center point is naturally on the normal vector of the CC point regardless of the tool axis direction, so the tool axis directions can be neglected during CC trajectory generation process especially for five-axis tool path planning. And these directions can be assigned to each CC point after the CC trajectory has been generated. This feature is used in this work.

So with the CC trajectory generated by the LKH TSP solver, the coordinates of the tool center point for each CC point can be directly calculated with the degraded form of Eq. (6), as 
                           
                              (9)
                              
                                 O
                                 =
                                 C
                                 +
                                 
                                    n
                                 
                                 ⋅
                                 
                                    
                                       R
                                    
                                    
                                       1
                                    
                                 
                                 ,
                              
                           
                         in which 
                           C
                         is a CC point, 
                           
                              n
                           
                         is the corresponding surface normal at 
                           C
                        , 
                           
                              
                                 R
                              
                              
                                 1
                              
                           
                         is the ball radius of tool and 
                           O
                         is the tool center point. For three-axis machining, as the tool axis is fixed, Eq. (6) is sufficient to calculate the cutter locations from the CC trajectory. However, for five-axis machining, the axis directions have to be determined.

As shown in Fig. 13
                        , a local part of a linked CC trajectory with 7 CC points is demonstrated. Similar to the SFC method, there might be many turns on the trajectory, as on the CC point 
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                         and 
                           
                              
                                 C
                              
                              
                                 5
                              
                           
                         in the figure. Initially, the tool axis direction for a CC point 
                           
                              
                                 C
                              
                              
                                 i
                              
                           
                         in five-axis machining is defined in the following three steps: 
                           
                              •
                              Step 1. Set 
                                    
                                       
                                          
                                             f
                                          
                                       
                                       
                                          
                                             i
                                          
                                       
                                    
                                  to be the projection of 
                                    
                                       
                                          
                                             C
                                          
                                       
                                       
                                          
                                             i
                                          
                                       
                                    
                                    
                                       
                                          
                                             C
                                          
                                       
                                       
                                          
                                             i
                                          
                                          +
                                          
                                             1
                                          
                                       
                                    
                                  on the tangent plane of 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                 , in which 
                                    
                                       
                                          
                                             f
                                          
                                       
                                       
                                          
                                             i
                                          
                                       
                                    
                                  is the feed direction of 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                  and 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                  is the successor of 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                 .

Step 2. Build the LCS for 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                  using the rules introduced in Section  2.2.

Step 3. Define the tool axis 
                                    
                                       
                                          
                                             T
                                          
                                       
                                       
                                          
                                             i
                                          
                                       
                                    
                                  in the 
                                    X
                                    Z
                                  plane of the LCS with an leaning angle of 
                                    β
                                 , as shown in Figs. 9 and 13.

However, as shown in Fig. 13, for the turns 
                           
                              
                                 C
                              
                              
                                 3
                              
                           
                         and 
                           
                              
                                 C
                              
                              
                                 5
                              
                           
                        , there might be violent tool axis direction changes. These direction changes of the tool axes might be harmful to the machined surface quality. To smooth the tool axis directions, especially on the turns, two additional steps are appended as follows: 
                           
                              •
                              Step 4. Calculate all the tool axes for all the CC points on the CC trajectory using the above three steps.

Step 5. Modify each tool axis using the equation 
                                    
                                       (10)
                                       
                                          
                                             
                                                
                                                   T
                                                
                                             
                                             
                                                
                                                   i
                                                
                                             
                                             
                                                ′
                                             
                                          
                                          =
                                          
                                             (
                                             
                                                
                                                   
                                                      T
                                                   
                                                
                                                
                                                   
                                                      i
                                                   
                                                
                                             
                                             +
                                             
                                                
                                                   
                                                      T
                                                   
                                                
                                                
                                                   
                                                      i
                                                   
                                                   +
                                                   
                                                      1
                                                   
                                                
                                             
                                             )
                                          
                                          /
                                          2
                                          .
                                       
                                    
                                 
                              

In Eq. (10), the new tool axis direction for each CC point is calculated by averaging its initial values with its successor. Note that 
                           
                              
                                 
                                    T
                                 
                              
                              
                                 
                                    i
                                 
                              
                              
                                 ′
                              
                           
                         is a unit vector, so the resulting 
                           
                              
                                 
                                    T
                                 
                              
                              
                                 
                                    i
                                 
                              
                              
                                 ′
                              
                           
                         should be unitized. The modification takes obvious effect for the CC points one before the turns, as 
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 C
                              
                              
                                 4
                              
                           
                         shown in Fig. 13; for other CC points, the effect might not be that obvious. All the tool axis directions are modified in this way except the last one. The last tool axis direction stays its initial value.

With the above five steps and Eq. (10), the cutter locations for five-axis machining can be determined. The cutter locations are written into a file for post-processing. Be noted that in this work, the chord errors along the tool path are not taken into consideration.

The proposed tool path generation method in this work is implemented in C/C++ programming language, in which LKH is compiled as a dynamic linking library (DLL). The source code of LKH is downloaded from Keld Helsgaun’s personal website (http://www.akira.ruc.dk/~keld/). The test program is run on a Lenovo T400 model laptop with dual-core CPU @ 2.53 GHz and 3 GB RAM. Several non-uniform rational B-spline (NURBS) surface examples are used to verify the proposed method.

In the first example, a special designed surface is tested. This surface is special because its 
                           v
                           0
                         boundary curve (about 110 mm) is much longer than its 
                           v
                           1
                         boundary curve (about 36 mm), as shown in Fig. 14
                        (a). In this example, the radius of the ball-end mill is 5 mm and the maximum scallop error is set to be 0.1 mm for better demonstration purpose. With these setting, a set of regular CC points are generated with the cutting simulation method, as shown in Fig. 14(b). The number of the CC points is 3248.

Because of the specialness of the surface, the CC points near the 
                           v
                           1
                         curve are much more crowded than that near the 
                           v
                           0
                         curve. Specifically, as shown in Fig. 14(b), the densities of the CC points on different 
                           v
                        -curves are very different, while those on different 
                           u
                        -curves do not differ much. So if the traditional iso-parametric tool paths are planned on this surface in 
                           v
                        -direction, many redundant paths will be resulted near the 
                           v
                           1
                         curve, which will reduce the machining efficiency. However, if the iso-parametric tool paths are planned in 
                           u
                        -direction, fewer redundant paths will be resulted. Obviously, for this surface, the 
                           u
                        -direction is the optimal feed direction for iso-parametric tool path if tool retractions are not considered, especially for the area of the surface near the 
                           v
                           1
                         curve.


                        Fig. 14(c) shows the optimal linked CC trajectory with the proposed method. For this case, it takes about 50 s (one RUNS) for the program to find the optimal path. From Fig. 14(c), it can be seen that if the above tool path planning problem is treated as a TSP, the optimal linking sequences of the CC points can be found automatically with LKH. And for different areas of the surface, the linking directions are different. For example, as shown in Fig. 14(c), for the right rectangular area (c.1), the CC points are linked in 
                           u
                        -direction, simply because the CC points in 
                           u
                        -direction are much denser than that in 
                           v
                        -direction, as shown in the top enlarged view. However, for the left rectangular area (c.2), the CC points are linked in 
                           v
                        -direction. It can be seen in the bottom enlarged view of Fig. 14(c) that in this area, the CC points are likely to be evenly distributed in both directions and LKH finds shorter path in 
                           v
                        -direction. In sum, LKH finds the better path globally. Fig. 15
                         gives a top view of the path. It can be guessed that for some extreme cases, LKH may find the optimal paths the same as the traditional zigzag paths. In these cases, the zigzag paths are naturally the optimal paths. Another thing we may learn from Fig. 15 is that the trajectory is close, which means that any point on the trajectory can be used as the start point in machining.

In the second example, a bowl-like surface is tested. The surface is about 
                           90
                           ×
                           90
                           
                           
                              
                                 
                                    mm
                                 
                              
                              
                                 2
                              
                           
                         in size and is concave in the middle, as shown in Fig. 16
                        (a). On this surface, three types of paths are generated and compared. The radii of the ball-end mills and the maximum scallop errors are all set to be 5 mm and 0.1 mm, respectively. Fig. 16(b) shows the traditional iso-parametric path linked in the zigzag way. This path is in 
                           u
                        -direction and the total length of the path is 5246 mm. Actually, we have also generated the zigzag path on this surface in 
                           v
                        -direction and the length of the 
                           v
                        -direction path is 5546 mm. Fig. 16(c) shows the ISFC path generated with the method in our previous research  [29] except that the T-spline surface is replaced with NURBS surface and the turns on the path are not handled. Fig. 16(d) shows the TSP path generated with the method in this work. The total length of the ISFC path is 5517 mm, while that value for the TSP path is 5094 mm. In this case, the TSP path is about 8.3% shorter than the ISFC path, and 3% shorter than the shortest zigzag path.

The numbers of the turns for ISFC and TSP paths are counted as 330 and 283, respectively. For this case, the proposed method in this work can generate fewer turns. In Fig. 16(c), it can be seen that there are many rush turns on the ISFC path, while in Fig. 16(d), fewer rush turns are observed on the TSP path. These rush turns will burden the servo system in real machining process. By further comparing the path patterns in Fig. 16(c) and (d), it can be seen that the feed directions on the ISFC path on different surface areas seem to be in chaos; while for the TSP path, in the middle concave area of the surface, the feed is in 
                           v
                        -direction, and for the surrounding convex area, the feed is in 
                           u
                        -direction. Be noted that the above comparisons are also listed in Table 1
                        .

A cutting experiment is done on a five-axis machine tool to verify the proposed method with the surface shown in Fig. 16(a). The radius of the ball-end mill is also set to be 5 mm. However, the maximum scallop error is set to be 0.02 mm in the cutting experiment. With these setting, the resulting number of CC points is 13786. For this case, LKH takes about 5 min (one RUNS) to find the optimal tour, which is acceptable. Theoretically, the leaning angle 
                           β
                         as discussed in Section  4.3 should be set as small as possible to avoid the violent tool axis changes on the path turns. However, leaning angles close to 0 will cause the undesirable tool tip cutting problem, which must be avoided. In this experiment, 
                           β
                         is set to be 1°. This value can be adjusted if necessary.

The generated cutter locations are sent to a simple postprocessor developed by ourselves. The output NC file is then imported into the Mikron UCP 600 model five-axis machine tool. It took about 40 min to machine the surface with feed speed at 500 mm/min on an aluminum stock. Fig. 17
                        (a) shows the finishing process with the TSP path and Fig. 17(b) shows the finished surface. From Fig. 17(b), the textures on the path turns can be seen clearly. These textures are further enlarged under a microscope, as shown in Fig. 17(c) and d. From Fig. 17(c) and (d), it can be seen that the scallop shapes on different kinds of path turns are changing as expected.

@&#CONCLUSIONS@&#

For freeform surface finishing, three types of tool path topologies are often used: the direction-parallel type, the contour–parallel type and the space-filling curve type. In this paper, a new way of planning the SFC type tool path is presented by treating the problem as a traveling salesman problem, which is well known in combinatorial optimization. The proposed tool path is generated in two steps:

In the first step, the input surface is discretized into a set of regular CC points. A cutting simulation method is developed to evaluate the scallop error and position the next CC point in the cross-feed direction. This method is free of local surface curvature assumptions and therefore is accurate and suitable for cutters with bigger size. Based on this method, iso-parametric curves that satisfy the scallop error requirement are successively generated across the surface in both 
                        u
                     - and 
                        v
                     -directions. The regular CC points are obtained by crossing the orthogonal parametric curves.

In the second step, the CC points are input into the effective TSP solver LKH for the optimal linking sequences. To solve the problems such as diagonal linking or penetrating linking of the CC points, a special data structure is designed for the CC points; and based on the structure, the Euclidean distance evaluation function for the CC points is redefined. With this function, in LKH, a CC point is only allowed to link its neighboring CC points on the same row on column. In this way, the linking problems can be solved.

The generated tool path is verified with several freeform surface examples. Results show that the proposed TSP path can automatically find the optimal feed direction on the surface. Comparative example also shows that the proposed method can generate shorter tool path than the traditional zigzag method or the recent ISFC method. The real cutting practice further verifies the feasibility of the proposed method.

The work presented in this paper shows the possibility of generating the TSP type tool path. In order to put the proposed method into real CAM software systems, some problems need to be noticed. The first problem is the turns on the tool path. In our previous research.  [29], turns as well as uncut areas are handled by the Hermite compensation curve. The same method can also be used in this work. Additionally, in this work, ball-end mills are used. It is still a challenge to popularize the proposed method to fillet-end and flat-end mills. Further work should also be done on gridding of compound or trimmed surfaces and for larger scale cases with millions of CC points.

@&#ACKNOWLEDGMENTS@&#

This work was financially supported by Science Fund for Creative Research Groups of National Natural Science Foundation of China (No. 51221004), the Postdoctoral Science Fund of China (No. 2015M570503) and Specialized Research Fund for the Doctoral Program of Higher Education (No. 20120101110055). The authors are also grateful to Professor Keld Helsgaun for his LKH and the advices for improving the performance of LKH in this work.

@&#REFERENCES@&#

