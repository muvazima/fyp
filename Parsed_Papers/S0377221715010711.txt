@&#MAIN-TITLE@&#A novel approach for nurse rerostering based on a parallel algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a parallel algorithm to solve the Nurse Rerostering Problem.


                        
                        
                           
                           A unique problem decomposition allows an efficient parallelization.


                        
                        
                           
                           Our parallel algorithm provides the same quality 15 × faster than the sequential one.


                        
                        
                           
                           The source code of the parallel algorithm is on https://github.com/CTU-IIG/NRRPGpu.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Nurse rerostering problem

Personnel/human resources rescheduling

List-based heuristic

Parallel/GPU algorithm

Homogeneous/heterogeneous model

@&#ABSTRACT@&#


               
               
                  This paper addresses the Nurse Rerostering Problem (NRRP) that arises when a roster is disrupted by unexpected circumstances. The objective is to find a feasible roster having the minimal number of changes with respect to the original one. The problem is solved by a parallel algorithm executed on a graphics processing unit (GPU) to significantly accelerate its performance. To the best of our knowledge, this is the first parallel algorithm solving the NRRP on GPU. The core concept is a unique problem decomposition allowing efficient parallelization. Two parallel algorithms, homogeneous and heterogeneous, are proposed (available online), and their performance evaluated on benchmark datasets in terms of quality of the results compared to the state-of-the-art results and speedup. In general, higher acceleration was obtained by the homogeneous model with speedup 12.6 and 17.7 times on the NRRP dataset with 19 and 32 nurses respectively. These results encourage further research on parallel algorithms to solve Operational Research problems.
               
            

@&#INTRODUCTION@&#

This paper is focused on an NP-hard combinatorial problem that occurs in healthcare (Clark, Moule, Topping, & Serpell, 2015). Practically, work of nurses in every hospital is organized into shifts and, therefore, a roster has to be created to determine the assignment of shifts to nurses in a given planning horizon. However, the roster usually has to be changed during the planning horizon, e.g. if a nurse gets sick. The original roster must then be modified to ensure sufficient healthcare service. Typically, the roster is not completely rebuilt, since nurses affected by roster disruptions have to cancel or reschedule their already planned free time activities, which is very unpopular, and may significantly increase personnel costs. Therefore, the criterion typically involves minimization of the number of changes relative to the original roster. A suitable solution arrived at manually may take hours, which is unacceptable when the solution must be found quickly. The problem is known as the nurse rerostering problem (NRRP), and this paper presents a parallel approach that solves the NRRP faster and with the same quality as conventional sequential approaches.

@&#RELATED WORKS@&#

Existing related works fall into two categories. Section 1.1.1 summarizes research related to NRRP directly, whereas Section 1.1.2 summarizes the more general operational research (OR) domain in the context of graphic processing unit (GPU) computing.

NRRP falls into the human resources/personnel scheduling domain, which includes a lot of other OR problems, as discussed in several surveys (Clark et al., 2015; Van den Bergh, Beliën, Bruecker, Demeulemeester, & Boeck, 2013). Although NRRP occurs very often, the number of papers addressing the problem is relatively small, e.g. Clark et al. (2015) found only eight papers dealing with NRRP. Most of these were published by Moz and Pato (2004, 2007), Pato and Moz (2008). The first one, Moz and Pato (2004), is based on multi-commodity network flow models formulated as integer linear programming (ILP) problems. This approach has the disadvantage common to exact methods: the time required to obtain a solution grows significantly for larger instances. To address this, Moz and Pato (2007) introduced a heuristic minimizing the number of changes in the original roster. This heuristic was based on a construction of the roster by iterative assignments of the shifts in a given order. To improve the quality of the solutions, this constructive heuristic was encapsulated by a genetic algorithm that shuffled the order of the shifts to be assigned. This extension provided improved quality for 10 percent of the solutions. However, the quality improvement was outweighed by the significant increase of computational time. In Pato and Moz (2008), a bi-objective rerostering problem was solved using the Pareto genetic heuristic. In addition to the number of changes, the deviation from the number of shifts originally assigned to a given nurse was considered as a second objective. The computational times were longer than in Moz and Pato (2007), since the primary focus of Pato and Moz (2008) was the quality of the solutions. However, Pato and Moz (2008) evaluated 31 of 68 NRRP instances (Pato & Moz, 2013) only.


                           Kitada, Morizawa, and Nagasawa (2011) proposed a method to find an optimal schedule of the NRRP with a minimum number of changes, based on a recursive search algorithm to generate feasible solutions of the NRRP. However, their method was proposed and evaluated for instances with only a single absence.

The previous works addressed NRRP within one department, i.e., employing nurses from other departments was not possible. In contrast, Lilleby, Schittekat, Nordlander, Hvattum, and Andersson (2012) considered NRRP over more departments, and proposed a stochastic model to optimize several objectives, e.g. to improve nurse utilization, decrease personnel cost, and build robust competence of the nurses to make them substitutable across departments.

Other papers addressing NRRP were published by Maenhout and Vanhoucke. The latest, Maenhout and Vanhoucke (2013), describes an evolutionary algorithm derived from immunology, the artificial immune system algorithm (AISA). AISA provides similar quality as an evolutionary algorithm (EA) from their previous paper, Maenhout and Vanhoucke (2011) (AISA outperforms EA by 0.04 percent). However, the experiments in Maenhout and Vanhoucke (2013) showed that some NRRP instances are better solved by AISA than EA, and vice versa. In Maenhout and Vanhoucke (2011) EA was combined with local search methods using network flow techniques. The solution of the NRRP was represented by the best individual, which is organized in nurse-day view (Cheang, Li, Lim, & Rodrigues, 2003). Local search methods are applied after the recombination operators (a crossover and a mutation) to improve the quality of the individuals. The different strategies of the algorithm were tested on 1000 generated NRRP instances. The average computational times were 13–268 seconds per NRRP instance, depending on the strategy used.

Maenhout and Vanhoucke’s of EA in Maenhout and Vanhoucke (2011) outperformed their implementation of Moz and Pato’s algorithm from Moz and Pato (2007), when applied on the same dataset from Maenhout and Vanhoucke (2011). However, Maenhout and Vanhoucke (2011) and Moz and Pato (2007) cannot be directly compared due to dissimilarities in the problem statement (see Section 2 in Moz and Pato (2007) and Section 3 in Maenhout and Vanhoucke (2011)). For example, a disruption in Moz and Pato (2007) was defined such that a nurse cannot be assigned to any shift on the same day, except a day-off, whereas (Maenhout & Vanhoucke, 2011) defined a disruption such that a nurse can be assigned to any shift except the absented one on the same day, e.g. a nurse may be absent for an early shift, but assigned to a late or night shift on the same day. Moreover, different hard constraints and objectives were considered in the papers (e.g. the objective in Moz and Pato (2007) was only for the minimal number of changes, whereas Maenhout and Vanhoucke (2011) considered three objectives: the minimal number of changes, the effort to meet nurses preferences, and balancing the workload among the nurses). Furthermore, Maenhout and Vanhoucke (2011) presented results in an aggregated form only and, therefore, the results of the particular instances and their execution times cannot be compared.

Current state-of-the-art approaches applied to real life NRRP instances generally require long computational time. This drawback may be addressed by an accelerated approach, e.g. using a parallel algorithm.

There has been a growing interest in the use of GPUs for non-graphic applications, as demonstrated in Owens et al. (2007), Brodtkorb, Hagen, and Saetra (2013), Brodtkorb, Hagen, Schulz, and Hasle (2013), Schulz, Hasle, Brodtkorb, and Hagen (2013). A few OR problems have already been solved using GPU. The most important metric of any GPU/parallel algorithm performance is its speedup, the ratio of the computational time needed for the sequential and GPU/parallel version of the algorithm.


                           Janiak, Janiak, and Lichtenstein (2008) applied a tabu search algorithm to the traveling salesman problem, and showed that only instances incorporating more than 50 cities ensured a speedup. Smaller instances were better solved sequentially on a CPU, as there is a large overhead of data preparation for a GPU. The maximal speedup, achieved on the instances with 100 cities, was only 12 percent. They also applied the tabu search algorithm to a permutation flowshop scheduling problem (PFSP), achieving an approximately four times speedup on GPU.

The tabu search algorithm was also investigated for PFSP in Czapinski and Barnes (2011), where the GPU implementation significantly outperformed the CPU, achieving an 89 fold speedup. However, the solutions were not evaluated for quality. The same authors also applied the tabu search algorithm to a quadratic assignment problem in Czapinski (2013), where each instance of the parallel algorithm running had slightly different parameters to ensure diversity of the solutions. The overhead caused by communication between CPU and GPU was largely eliminated, as the entire algorithm was launched on the GPU, and they achieved up to 70 times speedup. In contrast to Czapinski and Barnes (2011), the quality was evaluated with respect to the best known solutions, and the parallel algorithm was shown to be capable of providing optimal or best known solutions.

A parallel algorithm based on the variable neighborhood search algorithm was applied to a vehicle routing problem (Coelho et al., 2012). The speedup achieved ranged from 2.7 to 16.2, depending on the specific instance evaluated. Another work published recently by Riise and Burke (2015) concentrates on problems that can be modeled as a permutation of distinct elements. The authors show how a local search technique can benefit from parallel move evaluation by applying a number of independent improving moves simultaneously. This technique was benchmarked on instance of the traveling salesman problem and the authors achieved speedup higher than 100. Dynamic programming exploiting the GPU applied to a knapsack problem was described in Boyer, Baz, and Elkihel (2012), and showed that average speedup for 40,000–100,000 objects was approximately 26, while smaller instances achieved speedup approximately 20. The resource constrained project scheduling problem (RCPSP) has been already solved on GPU (Bukata, Šůcha, & Hanzálek, 2015), where GPU outperformed the CPU version for both speedup and quality of solutions, due to an effective schedule evaluation and GPU-optimized tabu search algorithm. In addition, data transfers were reduced to a minimum since the entire algorithm ran on the GPU. The solution quality was comparable to existing algorithms solving the RCPSP.

All the above papers, except Bukata et al. (2015), have one common feature: the combinatorial problems solved on the GPU have either simple constraints and/or a simple evaluation criterion. However, NRRP does not fulfill these requirements. Moreover, the outcomes are commonly evaluated by self-comparison. To verify the applicability of GPU computing for OR, parallel algorithms need to be able to exploit the computing performance of GPUs, and the algorithms must be evaluated on standard benchmarks.

To the best of our knowledge, NRRP has not been previously solved on a GPU. Indeed, there does not appear to have been any parallel approach applied to this problem. To design the parallel algorithm solving the NRRP, preserving the solution quality and significantly reducing computational time, the state-of-the-art papers discussed above were considered. The algorithm from Moz and Pato (2007) provided the inspiration for the design of a new parallel algorithm. Moreover, benchmark instances from that paper published by Pato and Moz (2013) provide a convenient mechanism to compare the quality of the sequential and parallel version fairly.

In general, designing a GPU parallel algorithm for the NRRP is non-trivial due to the GPU architecture features, and the requirement that the algorithm be versatile with respect to different NRRP sizes and robust with respect to the number of disruptions in the original roster. Therefore, we propose a unique problem decomposition allowing efficient parallelization. We compare two models of the parallel algorithm: when the entire algorithm runs on a GPU (homogeneous) and when the algorithm is partially solved on the CPU and partially on the GPU (heterogeneous). The homogeneous model provides average speedup 12.6 and 17.7 times for NRRP datasets with 19 and 32 nurses, respectively, in comparison to the same algorithm performed sequentially, whereas the heterogeneous model provides average speedup of 2.3 and 2.4 times for the same datasets. Our results were compared to the best known solutions of the benchmark instances, and provide the same solution quality on most of these with significantly shorter computational time.

The principles of GPU computing are outlined in Section 2 and the NRRP is formally defined in Section 3. Our proposed sequential algorithm is presented in Section 4, and the design of the homogeneous and heterogeneous models of that algorithm is discussed in Sections 5 and 6. The performance of both models is validated with respect to state-of-the-art approaches in Section 7 on NRRP benchmark datasets (Pato & Moz, 2013). Our conclusions in Section 8 are followed by two appendices. The nomenclature used in this paper is summarized in Appendix A, while experiments on memory models are presented in Appendix B.

This section briefly describes the basic concepts of GPU computing that are necessary to understand the following sections. If the reader is experienced in this area, this section may be skipped, on the other hand, more information can be found, for example, in Cook (2013).

GPU accelerators cannot be programmed in the same way as classical CPUs. They have a different architecture requiring a different programming approach. Parallel algorithms for GPUs can be developed using computer unified device architecture (CUDA), which is a parallel computing toolkit and programming model supported by NVIDIA® GPUs (see a detailed description in NVIDIA CUDA C Programming Guide, version 5.5 (2013)). CUDA is based on single instruction multiple threads (SIMT) parallelization, i.e., threads are initiated on a GPU to process different data using the same code (kernel). The threads are grouped into CUDA blocks, organized into a grid of the CUDA blocks executing the same kernel. From a hardware point of view (see Fig. 1
                     ), the blocks of threads are launched on streaming multiprocessors (SM). More CUDA blocks can be executed on one SM simultaneously if the capacity of the resource, e.g. the memory size, is sufficient. The kernels are executed on each SM in batches of 32 threads called warps. Warp execution is handled by a built-in warp scheduler.

GPU algorithms must also respect that warps within a CUDA block are executed asynchronously, although all the warps within one block can be synchronized by an instruction _ syncthreads(). This mechanism is called barrier synchronization and it is required when each thread has to await an update of variables by all threads, since the final value is needed to continue. However, excessive usage of _ syncthreads() decreases the performance, which must be considered along with SIMT thread mapping.

Another important aspect is branch divergence of the code. This occurs when threads in a warp reach an instruction that cannot be executed in parallel by all the threads, e.g. an if-else statement. The two branches are processed sequentially in non-deterministic order: the threads executing one branch are evaluated in parallel, and then the remaining threads performing the other branch are evaluated (also in parallel). Branch divergence should be minimized as much as possible to increase speedup.

Another influencing factor for GPU algorithms performance is the memory model. There are many types of GPU memory (see below), each with different parameters. Thus, design of the memory model is not a trivial task (see Table 1
                      showing the parameters for the Geforce 650 Ti GPU). Bandwidth refers to the amount of data per second that can be moved to or from a given memory, i.e., it is closely related to a device throughput. Memory latency is the number of cycles representing the maximum time needed to access a memory. The last parameter is memory size.

Particular types of GPU memory are illustrated by yellow boxes in Fig. 1. Global memory is used for communication between a host (CPU) and a device (GPU) and for storage of larger data structures. Its advantages are accessibility for read/write operations by all threads and its size (see Table 1). On the other hand, access to this memory has high latency. Constant and texture memories are optimized to maintain data in a specific format, i.e., constants and 2D arrays (such as images), which are shared and accessible by all threads. Both are read-only memories, and latencies can be shortened for the case when the data is cached. Shared memory has very fast access compared to global memory and it is used to exchange shared data among the threads within one CUDA block. However, the size is very limited (see Table 1). Registers store elementary variables needed by each thread in a CUDA block, and their size is strongly limited. Therefore, thread specific data structures that cannot fit into registers are stored in a local memory, which has similar properties to the global memory, except the thread scope and caching.

There are three ways to eliminate latencies related to memory access:

                        
                           1.
                           To use coalescing that is based on the threads within a CUDA block accessing consecutive addresses of global memory. Multiple thread memory requests are joined into a single request.

Memory access can be also accelerated using the L1 and L2 caches (illustrated in Fig. 1).

Latencies can be avoided by warp switching provided by the warp scheduler, i.e., computation of another warp commences, while the current warp is waiting for data.

Hence, the memory model of GPU parallel algorithms must be carefully designed with respect to all the above memory limitations and advantages, since this will have a significant impact on performance.

GPU parallel algorithms can be heterogeneous or homogeneous (see Fig. 2
                     ). Homogeneous algorithms perform all computations on the device, whereas heterogeneous algorithms perform the main logic on the host and only computationally intensive parts are accelerated by the GPU. The heterogeneous model is executed repeatedly, illustrated by the reverse arrow in Fig. 2a. In general, the heterogeneous model is used when the entire algorithm cannot be executed in parallel, and is potentially affected by communication between the host and the device, so this overhead should be minimized.

The NRRP considered in this paper is the same as in Moz and Pato (2007) and it is defined as follows (see a summary of the nomenclature in Appendix A): let E be the set of scheduled employees, i.e., the nurses of one department/unit in a hospital. The set of employees is fixed, i.e., one is not able to hire another nurse from a different department to solve NRRP. Each employee e ∈ E has to meet some requirements, e.g., focused on days-off: let minDaysOffe
                      be the minimal number of days-off in every seven consecutive days of the roster for nurse e ∈ E.

The planning horizon is given by a set of days, D. The healthcare provided by the nurses is organized into shifts where a set of shifts types, S, consists of: early, late, night and day-off, denoted as 
                        
                           E
                           ,
                           L
                           ,
                           N
                           ,
                           F
                           ,
                        
                      respectively, where 
                        F
                      is considered as a virtual shift type. Each shift type except 
                        F
                      takes 8 hours. The shifts are assigned in an original roster, R
                     0, of dimension |E| · |D|. The statement 
                        
                           
                              R
                              
                                 e
                                 ,
                                 d
                              
                              0
                           
                           =
                           s
                        
                      denotes that nurse e ∈ E has shift type s ∈ S on day d ∈ D. However, R
                     0 is disrupted by unexpected circumstances. These disruptions are formally defined by a set of absences, A, where absence a ∈ A is given by a pair, (e, d), e ∈ E and d ∈ D. Absence means that nurse e is not able to serve any of the shifts except the day-off on day d. These absences are reflected in a modified roster, R, created from R
                     0. The modified roster R must guarantee minimal healthcare coverage, which may be lower than for R
                     0. Let RS be a matrix of requested shift types, so that RS
                     
                        s, d
                      is equal to the minimal number of shift type s assigned on day d in R. To ensure a continuity of rosters (see constraints (c
                     2) and (c
                     3) below), part of the roster from the previous planning horizon, Rprev
                     , must be known.


                     R
                     0 must comply with a set of constraints, e.g. the restrictions given by a labor code, a collective agreement, contracts, preferences of the nurses, etc. However, not all of these constraints are considered in NRRP, since the main and the most important goal is to retain the original roster as much as possible. Therefore, R must fulfill the following set of hard constraints:

                        
                           (c
                              1)
                           A nurse cannot be assigned to more than one shift per day.

Nurses must have at least the minimal number of days-off in every seven consecutive days of the roster according to their average workload: at least two days-off for nurses with average workload of 35 hours per week and 1 day-off for nurses with average workload of 42 hours per week.

Nurses must have a minimal rest of at least 16 hours between two consecutive shifts, i.e., sequences of consecutive shifts 
                                 
                                    LE
                                    ,
                                    NE
                                    ,
                                    NL
                                 
                               are forbidden.
                           

The set of absences, A, has to be respected.

Shifts in R must be the same as shifts in R
                              0 before the first (earliest) absence.

The minimal number of requested shifts, defined by RS, must be provided in R.

The objective function Z(R) is defined as the number of changes in R compared to R
                     0.

This section describes our proposed sequential approach to NRRP, inspired by Moz and Pato (2007). This approach forms the basis of the parallel algorithm described in Section 5. The sequential algorithm (see Algorithm 1, the complete source code is available online in Bäumelt, Dvořák, Šůcha, and Hanzálek (2015b)) is a list based constructive heuristic. The list of roster positions RP is indexed by position i from zero. Each roster position 
                        
                           R
                           
                              P
                              i
                              
                           
                        
                      contains a unique pair, (e, d), for nurse e ∈ E and day d ∈ D. Each pair, (e, d), refers to shift s such that 
                        
                           
                              R
                              
                                 e
                                 ,
                                 d
                              
                              0
                           
                           =
                           s
                        
                     .

The basic concept of the sequential algorithm is to process pairs (e, d) from a given RP, and assign the shifts to the modified roster R such that Z(R) is minimized. Processing of one RP (lines 4–25 in Algorithm 1) is an algorithm run, and the number of performed runs is stored in an auxiliary counter run. The algorithm may be summarized as follows.


                     Step 1 (see lines 4–6 of Algorithm 1): Variables related to a single run of the algorithm are initialized, and position i is set to an initial position iinit
                     , that refers to the number of shifts in R
                     0 affected by constraint (c
                     5). These shifts are assigned by function initRoster to R together with the days-off given by absences A. RP is created as described in Section 4.1.


                     Step 2: Shifts are assigned to R one by one in the order given by RP, starting from position iinit
                     . Each assignment of shift s given by 
                        
                           R
                           
                              P
                              i
                              
                           
                        
                      must comply with constraints (c
                     1)–(c
                     6) applied on R and it is realized according to the hierarchical rules:

                        
                           
                              [Rule 1]
                           
                           Try to assign shift s to nurse e who was scheduled on day d on this shift in R
                              0, i.e., 
                                 
                                    
                                       R
                                       
                                          e
                                          ,
                                          d
                                       
                                       0
                                    
                                    =
                                    s
                                 
                              .

Try to assign shift s to nurse e′ ∈ {E∖e} who was not scheduled on day d on this shift in R
                              0, but to whom the assignment 
                                 
                                    R
                                    
                                       
                                          e
                                          ′
                                       
                                       ,
                                       d
                                    
                                 
                               satisfies (c
                              3) wrt R
                              0 from both sides, i.e., (c
                              3) is met by 
                                 
                                    (
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                          −
                                          1
                                       
                                       0
                                    
                                    ,
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                       
                                    
                                    )
                                 
                               and 
                                 
                                    (
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                       
                                    
                                    ,
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                          +
                                          1
                                       
                                       0
                                    
                                    )
                                 
                              .

Try to assign shift s to nurse e′ ∈ {E∖e} who was not scheduled on day d on this shift in R
                              0, but to whom the assignment to 
                                 
                                    R
                                    
                                       
                                          e
                                          ′
                                       
                                       ,
                                       d
                                    
                                 
                               satisfies (c
                              3) wrt R
                              0 from one side, i.e., (c
                              3) is met by 
                                 
                                    (
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                          −
                                          1
                                       
                                       0
                                    
                                    ,
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                       
                                    
                                    )
                                 
                               or 
                                 
                                    (
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                       
                                    
                                    ,
                                    
                                       R
                                       
                                          
                                             e
                                             ′
                                          
                                          ,
                                          d
                                          +
                                          1
                                       
                                       0
                                    
                                    )
                                 
                              .

Try to assign shift s to an arbitrary nurse on day d without any constraint violation in R.

When shift s cannot be assigned applying Rules 1–4, backtrack is performed (see Section 4.2). Otherwise, all the shifts given by RP are assigned and a feasible R is found. Each algorithm run considers a different RP and for that reason, each run can provide a different R. The best modified roster over all runs is stored in Rbest
                     . The stopping condition is the maximal number of performed runs, given by constant maxRuns.

In our proposed Algorithm 1, the list of roster positions, RP, is created either by a local search (function performLocalSearch in line 8) or by function generateRosterPositions (line 10). In the second case, elements of RP are randomly permuted, and all roster positions that cannot be modified with respect to constraint (c
                        5) are shifted left in RP as much as possible. Moz and Pato (2007) organized RP randomly or by a genetic algorithm. However, a direct implementation of the genetic algorithm would increase branch divergence in the parallel algorithm significantly and, therefore, we propose a local search that eliminates this drawback.
                        
                     

The key concept of the local search (function performLocalSearch in Algorithm 2) is to explore the solution space near Rbest
                         derived from 
                           
                              R
                              
                                 P
                                 
                                 
                                    b
                                    e
                                    s
                                    t
                                 
                              
                              ,
                           
                         i.e., to improve the quality of the best solution found. The local search modifies a copy of 
                           
                              R
                              
                                 P
                                 
                                 
                                    b
                                    e
                                    s
                                    t
                                 
                              
                           
                         to obtain a new RP for the current run. The modification is realized by swapping two elements 
                           
                              R
                              
                                 P
                                 i
                                 
                              
                           
                         and 
                           
                              R
                              
                                 P
                                 
                                    i
                                    ′
                                 
                                 
                              
                              ,
                           
                         where i′ refers to an index of the second position in RP, chosen randomly. The swap is made with probability pLS
                        , given as the input parameter of function performLocalSearch.

The method used to generate RP for the current run is controlled by the applyLS flag. This flag as well as probability pLS
                         are determined by function updateLocalSearchParameters (line 24 in Algorithm 1) using two auxiliary variables that are updated inside the same function. Variable runsNoSuccess is a counter of runs without improvement of Z(Rbest
                        ) that is initialized to 0. The counter is also reset to 0 when Rbest
                         is updated. When no feasible R is found or it is not better than the current best (Z(R) ≥ Z(Rbest
                        )), runsNoSuccess is incremented. If runsNoSuccess exceeds the given threshold and 
                           
                              
                                 R
                                 
                                    b
                                    e
                                    s
                                    t
                                 
                              
                              ≠
                              null
                              ,
                           
                         
                        applyLS is set to true and RP is generated by function performLocalSearch. The second auxiliary variable, runsOfSameProbability, refers to a counter of runs, when the local search has been performed having the same pLS
                         and Rbest
                         has not been updated. If runsOfSameProbability is greater than the given threshold, it is reset to 0 and pLS
                         is decreased to half. When pLS
                         is under 0.1 percent, the local search is switched off, and in the next run RP is generated in a standard manner. Decreasing pLS
                         during the local search is an analogy to controlled cooling in the simulated annealing algorithm.

When Rules 1– 4 cannot be used to assign shift s given by 
                           
                              R
                              
                                 P
                                 i
                                 
                              
                              ,
                           
                         a backtrack (Algorithm 3) is performed over RP (line 17 in Algorithm 1), such that all the structures are rolled back to the state before assigning the shift, given by 
                           
                              R
                              
                                 P
                                 
                                    i
                                    −
                                    1
                                 
                                 
                              
                           
                         and elements 
                           
                              R
                              
                                 P
                                 i
                                 
                              
                           
                         and 
                           
                              R
                              
                                 P
                                 
                                    i
                                    −
                                    1
                                 
                                 
                              
                           
                         are swapped. Consequently, Algorithm 1 continues by processing Step 2 on the decremented position, i. The backtrack from Moz and Pato (2007) cannot be applied, since it considers all permutations of roster positions and, therefore, would be too memory consuming for the GPU. Our backtrack method performBacktrack is based on swapping of roster positions in RP. The backtrack is applied so long as the backtracking counter backtrack does not exceed a given threshold, maxBacktracks, and i > iinit
                         to avoid violation of constraint (c
                        5). When both conditions are not fulfilled, applyBT is set to false and the current run is completed with no feasible solution.

This section explains the crucial issues of designing the homogeneous model of the parallel algorithm that is the main contribution of this paper. Sections 5.1–5.3 describe key concepts, while Section 5.4 explains the whole parallel algorithm pseudocode. The memory model is discussed in Section 5.5.

Due to single instruction multiple threads (SIMT) mapping and the long latency of global memory, naive parallelization will not provide the expected speedup of the parallel algorithm. A simple basic rule for design of an efficient GPU algorithm is to employ as many threads as possible. In our case, the smallest independent data element to be processed by a single thread is the modified roster of one nurse. The key concept of this problem decomposition lies in the unique mapping of each nurse to an individual thread and the efficient processing of Rules 1–4 from Step 2 in Algorithm 1
                         (see Sections 5.2 and 5.3).

The list of roster positions, RP, is replaced with several partial lists stored in RPP (see Fig. 3). RPP is an array of |E| partial lists of roster positions 
                           
                              R
                              P
                              
                                 P
                                 e
                                 
                              
                              =
                              
                                 
                                    (
                                    R
                                    P
                                    
                                       P
                                       
                                          e
                                          ,
                                          i
                                       
                                       
                                    
                                    )
                                 
                                 
                                    i
                                    ∈
                                    〈
                                    0
                                    ,
                                    |
                                    D
                                    |
                                    −
                                    1
                                    〉
                                 
                              
                           
                        . Each element of the partial list 
                           
                              R
                              P
                              
                                 P
                                 
                                    e
                                    ,
                                    i
                                 
                                 
                              
                           
                        
                        
                           
                              =
                              d
                           
                         refers to shift 
                           
                              s
                              =
                              
                                 R
                                 
                                    e
                                    ,
                                    d
                                 
                                 0
                              
                           
                         in the original roster. Elements of 
                           
                              R
                              P
                              
                                 P
                                 e
                                 
                              
                           
                         are organized in the same order as in the RP. Practically, RPP splits the original RP into lists dedicated to each particular nurse e ∈ E as illustrated in Fig. 3.

However, |E| threads still cannot fully utilize the GPU and efficiently hide the memory access latencies. Thus, we need to find a more effective way to exploit the computational power of the GPU. Since a single run of the main while loop in Algorithm 1 is independent of the other runs, all the runs can be executed concurrently, each with its own RPP. We refer to m as the number of instances of the algorithm executed at the same time, so that m · |E| threads are used to solve one NRRP instance. Consequently, mb
                         denotes the number of instances of the algorithm per one CUDA block, so each CUDA block contains mb
                         · |E| threads. The values of m and mb
                         are chosen with respect to the size of the NRRP instance and the number of SMs on the GPU.

From decomposition described previously we have, in principle, sufficient number of threads to fully occupy the GPU. However, the decomposition itself does not guarantee full utilization of the GPU due to branch divergence, which is mostly appreciable in Step 2 of Algorithm 1. Rule 1 decides whether shift s given by 
                           
                              R
                              
                                 P
                                 i
                                 
                              
                           
                         can be assigned to the original employee e on day d, while the remaining Rules 2–4 search for an employee satisfying the given rule. Hence, shift s can be assigned directly or, in the worst case, the algorithm must evaluate the assignment to |E| nurses for Rules 2–4. From the computational time point of view, there is a significant imbalance between the execution of Rule 1 and Rules 2–4, which produces significant branch divergence. Therefore, to eliminate this, Algorithm 1 must be reorganized as shown in Fig. 4
                        . Part Alloc corresponds to Step 0 in Algorithm 1. Step 1 initializing a new run is shown as Part Init. Step 2 has been split into two parts: Part A reads the shifts to be assigned, and Part B provides the evaluation of the shift assignments with respect to the hierarchical rules from Step 2. Consequently, the shifts are assigned to the nurses in Part C, which incorporates Steps 3 and 4. Following this reorganization, one run consists of Part Init and sequences of 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                           
                         executed in a while loop.

Our sequential algorithm (Fig. 4a) is organized in steps and corresponds to Algorithm 1. Our reorganized sequential algorithm (Fig. 4b) is similar to the homogeneous and heterogeneous models of the parallel algorithm, as illustrated in Fig. 4c and d, respectively. The homogeneous model is described in the rest of the section, and the differences of the heterogeneous model are detailed in Section 6.

To minimize branch divergence, the parallel algorithm considers two modes. Let firstRule be a boolean variable defining which mode the current sequence of 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                           
                         is performed in, i.e., how Part A and Part C are executed by threads to prepare and update data for Part B. The most computationally intensive Part B evaluates the application of Rules 1–4 independently on the current mode, as demonstrated in Fig. 5
                        
                         for one run of one instance of the parallel algorithm. Row 0 in the upper left corner shows which shifts are assigned by Part Init with respect to constraints (c
                        4) and (c
                        5). Each of the subsequent rows refers to a single execution of the sequence 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                           
                        . The left side of each row shows which roster positions are processed in the current sequence (circles in RPP and R
                        0), and the current R after completing Part C is shown on the right.

The first sequence of 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                           
                         (see row 1 in Fig. 5) starts at position i = iinit
                         = 1 in the firstRule mode. In Part A, each thread takes the appropriate 
                           
                              R
                              P
                              
                                 P
                                 
                                    e
                                    ,
                                    i
                                 
                                 
                              
                           
                         and determines the shift, s, to be assigned. In Part B, each thread evaluates the assignment of shift s to employee e on day d by penalization:

                           
                              (1)
                              
                                 
                                    p
                                    e
                                    
                                       n
                                       e
                                    
                                    =
                                    
                                       {
                                       
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                             
                                             
                                                
                                                   iff
                                                   
                                                   Rule
                                                   
                                                   1
                                                   
                                                   succeeded
                                                
                                             
                                             
                                                
                                                   (occurs
                                                   
                                                   in
                                                   
                                                   the
                                                   
                                                   f
                                                   i
                                                   r
                                                   s
                                                   t
                                                   R
                                                   u
                                                   l
                                                   e
                                                   
                                                   
                                                   mode)
                                                
                                             
                                          
                                          
                                             
                                                
                                                   1
                                                   ,
                                                
                                             
                                             
                                                
                                                   iff
                                                   
                                                   Rule
                                                   
                                                   2
                                                   
                                                   succeeded
                                                
                                             
                                             
                                                
                                                   (occurs
                                                   
                                                   in
                                                   
                                                   the
                                                   
                                                   ¬
                                                   
                                                   f
                                                   i
                                                   r
                                                   s
                                                   t
                                                   R
                                                   u
                                                   l
                                                   e
                                                   
                                                   
                                                   mode)
                                                
                                             
                                          
                                          
                                             
                                                
                                                   2
                                                   ,
                                                
                                             
                                             
                                                
                                                   iff
                                                   
                                                   Rule
                                                   
                                                   3
                                                   
                                                   succeeded
                                                
                                             
                                             
                                                
                                                   (occurs
                                                   
                                                   in
                                                   
                                                   the
                                                   
                                                   ¬
                                                   
                                                   f
                                                   i
                                                   r
                                                   s
                                                   t
                                                   R
                                                   u
                                                   l
                                                   e
                                                   
                                                   
                                                   mode)
                                                
                                             
                                          
                                          
                                             
                                                
                                                   3
                                                   ,
                                                
                                             
                                             
                                                
                                                   iff
                                                   
                                                   Rule
                                                   
                                                   4
                                                   
                                                   succeeded
                                                
                                             
                                             
                                                
                                                   (occurs
                                                   
                                                   in
                                                   
                                                   the
                                                   
                                                   ¬
                                                   
                                                   f
                                                   i
                                                   r
                                                   s
                                                   t
                                                   R
                                                   u
                                                   l
                                                   e
                                                   
                                                   
                                                   mode)
                                                
                                             
                                          
                                          
                                             
                                                
                                                   ∞
                                                   ,
                                                
                                             
                                             
                                                otherwise
                                             
                                             
                                                
                                                   (occurs
                                                   
                                                   in
                                                   
                                                   both
                                                   
                                                   modes)
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Part C in the firstRule mode assigns shifts having 
                           
                              p
                              e
                              n
                              =
                              0
                              ,
                           
                         with others marked as unassigned. If all the shifts loaded in Part A are assigned to the original employees, the run remains in the firstRule mode and position i is incremented. If at least one of the shifts is not assigned (see row 1, where shift 
                           E
                         from 
                           
                              R
                              
                                 2
                                 ,
                                 2
                              
                              0
                           
                         is evaluated by thread 2 to 
                           
                              p
                              e
                              
                                 n
                                 2
                              
                              =
                              ∞
                           
                        ), the run continues in the ¬firstRule mode (row 2).

In the ¬firstRule mode, Part A reads shift s that has not been previously assigned (
                           E
                         in row 2) for all the threads. Part B evaluates the assignment of shift s to all the nurses concurrently, using Eq. (1). Shift s is assigned in Part C to the employee having the minimal penalization < ∞. In our example, shift 
                           E
                         is assigned to nurse 1. If more employees had the same minimal penalization, a random one is chosen. Subsequently (see row 3), the instance of the algorithm either continues in the ¬firstRule mode if there is another unassigned shift on the current position i or, as in our example, it is switched back to the firstRule mode and position i is incremented.

In summary, branch divergence was strongly reduced by this efficient model, since the code of Part B is independent of position i, the current mode (represented by the firstRule flag) and the executed run (given by the run counter).

This section describes the proposed homogeneous model of the parallel algorithm in detail. Its pseudocode is shown in Algorithm 4 for one thread execution of one instance of the parallel algorithm (the complete source codes are published online in Bäumelt, Dvořák, Šůcha, & Hanzálek (2015a)).

At the beginning of Part Alloc (lines 1–5), the necessary variables are initialized. Variables common to all the instances of the algorithm (line 1) are assigned first, then the specific variables for one instance of the algorithm (line 2). Memory space is allocated (function allocateGPUResources) with respect to the size of the NRRP instance and the number of available streaming multiprocessors on the GPU. Thread mapping is determined by function mapThreads, since it is the same during the entire execution of the instance of the algorithm.


                        Part Init (lines 7–17) initializes each algorithm run and checks the stop condition (Section 5.4.3). Initialization is performed by function initAll, similar to Algorithm 1, and the modified roster, R, is initiated. All the elements of the binary matrix, isOccupied, are reset. Matrix isOccupied has the same dimensions as R and keeps information about whether the roster position in R is already occupied by any shift or not, to ensure the assignment of one shift to one roster position (constraint (c
                        1)). Function initAll also clears vector unassigned, which is used to store all the roster positions of the unassigned shifts in the firstRule mode. The auxiliary variable unassignedRP employed as a buffer for one chosen unassigned shift is cleared. The initial position, iinit
                        , is determined, and RPP is created similarly to Algorithm 1 (Section 5.4.1). When Part Init is completed, sequences of 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                           
                         are executed in parallel in the while loop (lines 6–53 in Algorithm 4).


                        Part A (lines 18–23) reads shift, s, to be assigned for each thread. Shift s is given by either 
                           
                              R
                              P
                              
                                 P
                                 
                                    e
                                    ,
                                    i
                                 
                                 
                              
                           
                         (in firstRule mode) or by unassignedRP (in ¬firstRule mode). Part B (lines 24–25), represented by function evaluateShiftAssignmentAccordingRules, returns pene
                         defined by Eq. (1) with respect to the input data, i.e., the shift assignment given by employee e, shift s, day d, the current modified roster R, original roster R
                        0, a part of the previous roster Rprev
                        , and isOccupied.


                        Part C (lines 26–53) assigns shift s to the modified roster R (Section 5.3). All shifts that cannot be assigned to their original positions are accumulated in unassigned in firstRule mode. Subsequently, shifts from unassigned are chosen one by one to unassignedRP in the ¬firstRule mode. If unassignedRP cannot be assigned to R, function performBacktrack (Section 5.4.2) is executed. Otherwise, the assigned shift is removed from unassigned and the run is processed on position i until this vector is empty. When the incremented position i exceeds the length of 
                           
                              R
                              P
                              
                                 P
                                 e
                                 
                              
                           
                         (equal to the number of days |D|) and the current run is feasible (line 44), a new solution has been found. The objective function, Ze
                        (R), for employee e is calculated by function computeObjectiveFunction. Subsequently, the current objective function value given by ∑∀e ∈ E
                        
                        Ze
                        (R) is compared to Z(Rbest
                        ) and the better one is preserved by function chooseBetter. Finally, variable run is incremented to start execution of the new run.

Some sections of the code for one instance of Algorithm 4 are executed only if 
                           
                              e
                              =
                              0
                              ,
                           
                         e.g. lines 47–52. These sections are executed by a single thread, since it does not make sense to execute them in parallel. Furthermore, note the presence of a lock symbol, 
                           
                        , in the code (lines 50 and 52). This presents critical sections of the code, where the access of the multiple instances of the algorithm must be controlled via locks (Section 5.5.1). It is also important to stress that the execution of the threads within one CUDA block have to be synchronized in order to preserve the data consistency. This is realized by the barrier synchronization _ syncthreads() (e.g. line 17).


                        Algorithm 4, along with the description above, explains one instance of the parallel algorithm. To illustrate the relationship between the multiple instances of the algorithm, an example of an NRRP instance with 
                           
                              |
                              E
                              |
                              =
                              4
                           
                         and 
                           
                              |
                              D
                              |
                              =
                              4
                           
                         is shown in Fig. 6. Each row corresponds to one of m instances of the algorithm. The numbers in the circles in each row represent different values of position i. The first run in the first instance of the algorithm is resolved within five iterations of the sequence 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                              ,
                           
                         then the next run is started (gray circle). The second row illustrates the second instance of the algorithm that terminated the first run at position 
                           
                              i
                              =
                              1
                              ,
                           
                         returning no solution. The last row shows an instance of the algorithm that repeats position 
                           
                              i
                              =
                              1
                           
                         three times, since the firstRule mode produces two unassigned roster positions that are stored into unassigned. These shifts are assigned by two consequent sequences of 
                           
                              {
                              PartsA
                              ,
                              B
                              ,
                              C
                              }
                           
                         in the ¬firstRule mode. In general, parallel execution of the instances of the algorithm can be executed asynchronously wrt i, i.e., the different positions can be explored by the different instances of the parallel algorithm at the same time.

The only difference in generating RPP compared to RP is the parallel execution (line 12 in Algorithm 4). Each thread, e, is responsible for generating its partial list of roster positions, 
                              
                                 R
                                 P
                                 
                                    P
                                    e
                                    
                                 
                                 ,
                              
                            by the same strategy as in Algorithm 1. Similarly, the local search (Section 4.1) is executed in parallel by function performLocalSearch (line 13 in Algorithm 4), i.e., each thread, e, applies the local search on its partial list of roster positions, 
                              
                                 R
                                 P
                                 
                                    P
                                    e
                                    
                                 
                                 ,
                              
                            initialized by 
                              
                                 R
                                 P
                                 
                                    P
                                    e
                                    
                                       b
                                       e
                                       s
                                       t
                                    
                                 
                              
                           .

There are two differences of function performBacktrack in the parallel algorithm from its usage in the sequential algorithm: it is performed on 
                              
                                 R
                                 P
                                 
                                    P
                                    e
                                    
                                 
                              
                            instead of RP, and line 3 in Algorithm 3 is skipped to avoid branch divergence, i.e., all the structures except the partial list of roster positions are unchanged. Consequently, the current run is restarted with updated 
                              
                                 R
                                 P
                                 
                                    P
                                    e
                                    
                                 
                              
                            from function performBacktrack and the remaining structures are initialized by function initAll.

The runs are executed in parallel by m instances of the algorithm until the total number of runs is more than or equal to maxRuns. The stop condition implemented by a terminateAlg flag is realized by lines 16 and 18 in Algorithm 4. When be executed by line 6 or 16 only, a deadlock occurs, since one instance of the algorithm passes the stop condition and leaves the while loop, whereas the other instances of the algorithm will be caught by the barrier synchronization in line 17, waiting for the instance that has already terminated.

There are several memory types on the GPU (Section 2) and it must be decided which part of the data will be stored in which memory, since the speedup is highly dependent on this decision as shown in Appendix B. Naively, the maximum speedup could be obtained by placing all the data into the registers, shared memory, or cached data, which have significantly shorter latencies than global memory. However, we have two different algorithm workspaces, the global workspace needs to keep the data belonging to all the instances of the algorithm (e.g. Z(Rbest
                        )) and a local workspace that needs to store the specific data for each instance of the algorithm (e.g. position i). Nevertheless, distribution of the data in the memory is not straightforward (see Table 2
                        ), since it depends on the size of an NRRP instance, the parameters of the GPU, and the frequency of data access. In our case, part of the specific data has to be stored in the global memory because of its size (pen, unassigned), while some local copies of the global data (e.g. R
                        0, A, Rprev
                        ) can be placed in shared memory to accelerate their access.

Coalescing and caching of the data has to be considered to shorten memory latencies. In our case, coalescing can be only applied for copying data from the global memory to the shared memory using the allocateGPUResources function. Operations related to RPP cannot be coalesced due to the random order of elements in each 
                           
                              R
                              P
                              
                                 P
                                 e
                                 
                              
                           
                        . The only way to accelerate access to global memory is to utilize the cache. Therefore, the amount of data in global memory was minimized as much as possible to increase the chance of caching.

The memory model is summarized in Table 2. Each row contains the type of memory, the variable name, data type, size in bytes, and a short description. There are five data types, uint for unsigned 32 bit integers, bool[] for binary arrays, bool for booleans represented in the GPU as uint, float for single precision floating point data, and roster[] for roster arrays. Each item of roster[] corresponds to one shift. Each shift is indexed by its uint index consuming 4 bytes. The number of shift types, |S|, is bounded in the NRRP instance and they are binary encoded as 
                           
                              F
                              ↦
                              00
                              ,
                              E
                              ↦
                              01
                              ,
                              L
                              ↦
                              10
                              
                              and
                              
                              N
                              ↦
                              11
                           
                        . Therefore, the roster arrays may be compressed c times, where 
                           
                              c
                              =
                              
                                 ⌊
                                 32
                                 /
                                 ⌈
                              
                              
                                 log
                                 2
                              
                              
                                 |
                                 S
                                 |
                                 ⌉
                                 ⌋
                              
                           
                        . In our case, 16 consecutive shifts can be compressed to 4 bytes (
                           
                              c
                              =
                              16
                           
                        ). Table 2 distinguishes what memory is shared over all instances of the algorithm in the CUDA block and what is specific for each. In the latter case, the size is multiplied by mb
                         (the number of the instances of the algorithm per CUDA block).

For parallel design, shared data over all instances of the algorithm, e.g. Rbest
                           , has to be modified exclusively by one thread to ensure consistency. Those instructions that require a mechanism for protecting access to the shared resource via locks are marked in Algorithm 4 by 
                              
                           . These include updating the best NRRP solution (line 50) and incrementing the total runs counter run (line 52), where the access is controlled via atomic operations provided by the CUDA framework itself.

This section describes the design of the heterogeneous model of the parallel algorithm (Fig. 4d, the complete source codes are available online in Bäumelt et al. (2015a)). First, one must decide which part of the algorithm will be executed in parallel on the GPU, and which will stay on the CPU. In this case, Part B was moved to GPU, since it consumes 76 percent of the total computing time. Therefore, the upper bound of the speedup is 
                        
                           100
                           /
                           (
                           100
                           −
                           76
                           )
                           ∼
                           4.17
                        
                      times, if zero computational time of the GPU execution is assumed.

The largest bottleneck of this model from the speedup point of view is the communication between host and device. The basic concept is to minimize the communication by performing it in a batch process. The rosters prepared for evaluation by Part A are accumulated on the host until the maximum data size is exceeded. The data is then copied from CPU to GPU memory space, and the kernel of Part B is launched. When the parallel evaluation is completed, the resulting pen for all shift assignments are copied back to the host, and Part C assigns the shifts to R.

The experiments were performed on a PC with AMD Phenom II X4 945@3 gigahertz CPU, 4 gigabyte of RAM, and NVIDIA® GTX 650 Ti GPU. This is just a common mid-class GPU for gaming, providing 768 cores and 1 gigabyte of global memory (a full specification of the GPU in GeForce GTX 650 Ti (2014)). The algorithm was developed in CUDA framework version 5.5 in Microsoft Visual Studio 2010.

The performance of our proposed approach was verified for speedup and quality on two datasets D19 and D32 (Pato & Moz, 2013). D19 contains 32 instances with 19 nurses, and D32 consists of 36 instances with 32 nurses. These datasets are consistent with the NRRP problem statement described in Section 3. The number of absences in the particular NRRP instances differs from 1 to 59. The NRRP instances are organized into groups indicated by Roman numerals in their names, corresponding to the number of weeks from the end of the planning horizon which can be modified, e.g. II.5_19 has absences in the third and fourth week, i.e., the two weeks can be modified with respect to constraint (c
                        5); III.2_32 has absences in the second, third and fourth week, etc. D32 also contains one extra group of instances V.1_32–V.4_32 that have a larger set of absences.

To eliminate randomness of our algorithms caused by generating lists of roster positions, all of the following experiments were evaluated over 20 samples, where a sample corresponds to execution of the algorithms with the following parameters: 
                           
                              m
                              a
                              x
                              R
                              u
                              n
                              s
                              
                              =
                              
                                 10
                                 5
                              
                              ,
                              m
                              a
                              x
                              B
                              a
                              c
                              k
                              t
                              r
                              a
                              c
                              k
                              s
                              =
                              5
                              ×
                              
                                 10
                                 3
                              
                           
                        . The parameters relevant for parallel algorithms were set experimentally to 
                           
                              m
                              =
                              1200
                              ,
                              
                                 m
                                 b
                              
                              =
                              2
                           
                        . The results are shown in Tables 3–6, where the computational time is the average computational time per sample, and the value of the objective function is the best over all the samples.

We compared our results to the best sequential algorithm from Moz and Pato (2007) (HH
                           PMX
                        ), also evaluated on 20 samples for each NRRP instance. HH
                           PMX
                         contains GA with a population of 400 individuals evolved over 2000 generations. Moz and Pato evaluated HH
                           PMX
                         using an Intel Pentium IV@2.6 gigahertz CPU with 256 megabytes of RAM. We also compared our results to the optimal solutions (Moz & Pato, 2007) obtained by ILP (solved in CPLEX 7.0), where the consumed
                         time was not provided.

The speedup of the parallel algorithms are shown in Tables 3 and 4 for dataset D19 and D32, respectively, where the rows correspond to the particular NRRP instances evaluated on 20 samples. For each NRRP instance, computational times tseq, thom
                        , and thet
                         are provided for the reorganized sequential CPU algorithm (Fig. 4b), homogeneous parallel GPU algorithm (Fig. 4c), and heterogeneous parallel GPU algorithm (Fig. 4d), respectively, since all are based on the same code (Algorithm 4). The derived speedup 
                           
                              s
                              p
                              e
                              e
                              d
                              u
                              
                                 p
                                 
                                    h
                                    o
                                    m
                                    
                                 
                              
                              =
                              
                                 t
                                 
                                    s
                                    e
                                    q
                                    
                                 
                              
                              /
                              
                                 t
                                 
                                    h
                                    o
                                    m
                                    
                                 
                              
                           
                         and 
                           
                              s
                              p
                              e
                              e
                              d
                              u
                              
                                 p
                                 
                                    h
                                    e
                                    t
                                    
                                 
                              
                              =
                              
                                 t
                                 
                                    s
                                    e
                                    q
                                    
                                 
                              
                              /
                              
                                 t
                                 
                                    h
                                    e
                                    t
                                    
                                 
                              
                           
                         are shown on the right of the tables.

A number of relationships are evident:

                           
                              •
                              As expected in average, tseq
                                  > thet
                                  > thom
                                  and, therefore, speeduphom
                                  > speeduphet
                                  > 1.

D19 was accelerated on average by speeduphom
                                  = 12.63 and speeduphet
                                  = 2.35, while D32 shows speeduphom
                                  = 17.71 and speeduphet
                                  = 2.26.


                                 speeduphet
                                  is approximately similar for both datasets due to the communication overhead between the host and the device.


                                 speeduphom
                                  on D32 is higher than speeduphom
                                  on dataset D19, i.e., the parallel algorithm was more efficient for larger instances.

Speedup increases with the number of weeks from the end of the planning horizon which can be modified (the roman numbering) for both datasets.

This section evaluates the quality of the solutions produced by our proposed algorithms, particularly the parallel GPU algorithms. The objective function outcomes are shown in Tables 5 and 6 for D19 and D32, respectively. The results are given by a pair of values: Z(Rbest
                        ) and the computational time needed to achieve this quality, and are summarized in the footer of the tables where # feasible (# optimal) stands for the total number of feasible (optimal) solutions of instances over the entire dataset. To make a fair comparison from the CPU aspect, each sequential algorithm was allowed more computational time than the parallel one proportional to the speedup derived from the previous subsection.

The outcomes verify that

                           
                              •
                              The reorganization (Fig. 4b) has no influence on the quality of the results compared to the performance of the sequential algorithm (Fig. 4a).

Our sequential and parallel algorithms produced results of similar quality.

The similar quality was provided by our parallel algorithms compared to optimal results received by ILP (Moz & Pato, 2007). Moreover, the similar quality of the results was achieved in comparison to HH
                                    PMX
                                  that provided the best quality of the results over all heuristic approaches in Moz and Pato (2007). The computing times of HH
                                    PMX
                                  and our sequential algorithms cannot be compared due to the different performance of the computers.

@&#CONCLUSION@&#

This work
                      proposes a parallel approach for solving the nurse rerostering problem (NRRP) employed to shorten the computational time required. The basic concepts, principles, and limitations to design a parallel algorithm for GPU have been explained. Two models (homogeneous and heterogeneous) of parallel algorithm were described. Our proposed algorithms (available online Bäumelt et al., 2015a, 2015b) were evaluated for speedup and quality on NRRP benchmark instances from Pato and Moz (2013), and show we are able to achieve the same quality of the results with significantly shorter computational time compared to the sequential algorithm. The homogeneous model with 19 nurses was accelerated almost 13 times on average, while instances involving 32 nurses were solved almost 18 times faster. Moreover, the quality of our results is similar to the state-of-the-art results published in Moz and Pato (2007).

In summary, there are three key elements that must be considered to solve OR problems in parallel.

                        
                           1.
                           It makes sense to accelerate solving of nontrivial problems, whose computational time consumed by sequential approaches is unacceptable.

The choice of algorithm to address the problem is very important. Briefly, the larger the part that can be executed in parallel relative to the sequential part, the higher speedup can be expected. For example, GA is very appropriate for its data parallelism, whereas an iterative algorithm has to be executed sequentially.

The parallel algorithm applied to the solved problem must be designed with respect to the chosen architecture, i.e., the parallel algorithm can be proposed for the GPU or for more cores of the CPU. Each architecture has its specific features and limitations strongly influencing the performance of the parallel algorithm.

Our proposed parallel algorithm applied to NRRP may be employed as a local search of the large neighborhood for NRP. The evaluation of explored rosters by the local search in NRP is executed repeatedly and independently on each other, and therefore is highly appropriate to be accelerated on GPU. Similarly, other assignment problems may be solved by our proposed parallel algorithms on GPU, e.g. crew scheduling, or home health care scheduling, since they consist of the NRP and the vehicle routing problem, which has already been solved on GPU (e.g. Coelho et al., 2012). The range of related problems is even wider, since most OR problems/subproblems with solutions based on list scheduling algorithms could be accelerated on GPU in a similar way.

Rapid progress of GPUs performance can be expected. Moreover, huge potential is provided by the modern all-in-one chips such as NVIDIA® Tegra X1, since it already incorporates a GPU (256 cores) and 64-bit CPU (8 cores). Thus, the parallel power of GPU can be effectively combined with advantages of classical CPU architecture, when it is more appropriate for the solved problem. This all-in-one chip is able to deliver unmatched performance within a high energy efficiency that will be mostly employed in smartphones and other mobile devices. We expect that this or similar accelerators will be massively produced and available in off-the-shelf mobile devices and computers. The trend in GPU’s growing importance was also confirmed by Brodtkorb, Hagen, Schulz et al. (2013) who concluded in their survey focused on GPU computing in OR, that it was clear that GPUs will play a significant role in all of computational science in the near future, and therefore, it is important to consider how to utilize these new architectures.

@&#ACKNOWLEDGMENTS@&#

This work was supported by public funding ARTEMIS FP7 EU under Project DEMANES 295372 and by the Ministry of Education of the Czech Republic under Project GACR P103/12/1994. We gratefully acknowledge the support of NVIDIA® Corporation for the donation of the GPUs.

We would also like to thank to anonymous reviewers, whose comments significantly contributed to the paper’s quality.


                        
                           
                              
                                 
                                 
                                 
                                    
                                       
                                          
                                             
                                                e
                                                ,
                                                
                                                   e
                                                   ′
                                                
                                             
                                          
                                       
                                       Index for the employees (nurses), auxiliary index for the employees (nurses)
                                    
                                    
                                       
                                          
                                             d
                                          
                                       
                                       Index for the days from the planning horizon
                                    
                                    
                                       
                                          
                                             s
                                          
                                       
                                       Index for the shifts
                                    
                                    
                                       
                                          
                                             E
                                          
                                       
                                       Set of employees (nurses)
                                    
                                    
                                       
                                          
                                             D
                                          
                                       
                                       Set of days from the planning horizon
                                    
                                    
                                       
                                          
                                             S
                                          
                                       
                                       Set of shifts
                                    
                                    
                                       
                                          
                                             
                                                R
                                                0
                                             
                                          
                                       
                                       Matrix representing the original roster, 
                                             
                                                R
                                                
                                                   e
                                                   ,
                                                   d
                                                
                                                0
                                             
                                           contains shift 
                                             
                                                s
                                                ∈
                                                S
                                             
                                           assigned to employee 
                                             
                                                e
                                                ∈
                                                E
                                             
                                           on day 
                                             
                                                d
                                                ∈
                                                D
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                R
                                                
                                                   p
                                                   r
                                                   e
                                                   v
                                                
                                             
                                          
                                       
                                       Matrix representing the previous original roster (before 
                                             
                                                R
                                                0
                                             
                                          )
                                    
                                    
                                       
                                          
                                             
                                                R
                                                ,
                                                
                                                   R
                                                   
                                                      b
                                                      e
                                                      s
                                                      t
                                                   
                                                
                                             
                                          
                                       
                                       Matrix representing the modified roster, the best found modified roster
                                    
                                    
                                       
                                          
                                             
                                                R
                                                S
                                             
                                          
                                       
                                       Matrix of the requested shift types, 
                                             
                                                R
                                                
                                                   S
                                                   
                                                      s
                                                      ,
                                                      d
                                                   
                                                
                                             
                                           expresses how many shifts of type 
                                             
                                                s
                                                ∈
                                                S
                                             
                                           is requested on day 
                                             
                                                d
                                                ∈
                                                D
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                m
                                                i
                                                n
                                                D
                                                a
                                                y
                                                s
                                                O
                                                f
                                                
                                                f
                                             
                                          
                                       
                                       Minimal number of the days-off in each seven consecutive days
                                    
                                    
                                       
                                          
                                             A
                                          
                                       
                                       Matrix of absences in the original roster 
                                             
                                                R
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                R
                                                P
                                             
                                          
                                       
                                       List of the roster positions corresponding to shifts to be assigned to all employees 
                                             
                                                e
                                                ∈
                                                E
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                R
                                                P
                                                P
                                             
                                          
                                       
                                       List of the roster positions corresponding to shifts to be assigned to a particular employee 
                                             
                                                e
                                                ∈
                                                E
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                R
                                                
                                                   P
                                                   
                                                   
                                                      b
                                                      e
                                                      s
                                                      t
                                                   
                                                
                                                ,
                                             
                                          
                                          
                                             
                                                R
                                                P
                                                
                                                   P
                                                   
                                                   
                                                      b
                                                      e
                                                      s
                                                      t
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                R
                                                P
                                                ,
                                             
                                          
                                          
                                             
                                                R
                                                P
                                                P
                                             
                                           that leads to the best found solution 
                                             
                                                R
                                                
                                                   b
                                                   e
                                                   s
                                                   t
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                i
                                                ,
                                             
                                          
                                          
                                             i
                                          ’
                                       Index for the position in 
                                             
                                                R
                                                P
                                             
                                           and 
                                             
                                                R
                                                P
                                                P
                                                ,
                                             
                                           auxiliary index for the position in 
                                             
                                                R
                                                P
                                             
                                           and 
                                             
                                                R
                                                P
                                                P
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                i
                                                
                                                   i
                                                   n
                                                   i
                                                   t
                                                
                                             
                                          
                                       
                                       Initial index for the position in 
                                             
                                                R
                                                P
                                             
                                           and 
                                             
                                                R
                                                P
                                                P
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                p
                                                e
                                                
                                                   n
                                                   e
                                                
                                             
                                          
                                       
                                       Penalization for the shift assignment of shift 
                                             s
                                           to employee 
                                             e
                                           on day 
                                             d
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                Z
                                                
                                                   (
                                                   R
                                                   )
                                                
                                                ,
                                                Z
                                                
                                                   (
                                                   
                                                      R
                                                      
                                                         b
                                                         e
                                                         s
                                                         t
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       Objective function, the best value of the objective function
                                    
                                    
                                       
                                          
                                             
                                                r
                                                u
                                                n
                                             
                                          
                                       
                                       Counter of the runs of the algorithm
                                    
                                    
                                       
                                          
                                             
                                                m
                                                a
                                                x
                                                R
                                                u
                                                n
                                                s
                                             
                                          
                                       
                                       Maximum number of runs of the algorithm
                                    
                                    
                                       
                                          
                                             m
                                          
                                       
                                       Number of parallel instances of the algorithm
                                    
                                    
                                       
                                          
                                             
                                                m
                                                b
                                             
                                          
                                       
                                       Number of parallel instances of the algorithm per one CUDA block
                                    
                                    
                                       
                                          
                                             
                                                i
                                                s
                                                O
                                                c
                                                c
                                                u
                                                p
                                                i
                                                e
                                                d
                                             
                                          
                                       
                                       Binary matrix of the already assigned roster positions, iff 
                                             
                                                i
                                                s
                                                O
                                                c
                                                c
                                                u
                                                p
                                                i
                                                e
                                                d
                                                
                                                   
                                                   
                                                      e
                                                      ,
                                                      d
                                                   
                                                
                                                =
                                                1
                                                ,
                                             
                                           no shift can be assigned to 
                                             
                                                R
                                                
                                                   e
                                                   ,
                                                   d
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                u
                                                n
                                                a
                                                s
                                                s
                                                i
                                                g
                                                n
                                                e
                                                d
                                             
                                          
                                       
                                       Vector of roster positions that cannot be assigned to 
                                             R
                                           to the original nurses given by 
                                             
                                                R
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                u
                                                n
                                                a
                                                s
                                                s
                                                i
                                                g
                                                n
                                                e
                                                d
                                                R
                                                P
                                             
                                          
                                       
                                       One roster positions 
                                             
                                                (
                                                e
                                                ,
                                                d
                                                )
                                             
                                           that cannot be assigned to 
                                             R
                                           to the original nurses given by 
                                             
                                                R
                                                0
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                f
                                                i
                                                r
                                                s
                                                t
                                                R
                                                u
                                                n
                                             
                                          
                                       
                                       Boolean to distinguish the first run from others
                                    
                                    
                                       
                                          
                                             
                                                f
                                                i
                                                r
                                                s
                                                t
                                                R
                                                u
                                                l
                                                e
                                             
                                          
                                       
                                       Boolean representing the mode of the current run of the algorithm instance
                                    
                                    
                                       
                                          
                                             
                                                f
                                                e
                                                a
                                                s
                                                i
                                                b
                                                l
                                                e
                                             
                                          
                                       
                                       Boolean representing the feasibility of the NRRP solved by one instance of the algorithm, i.e., feasibility of 
                                             R
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                t
                                                e
                                                r
                                                m
                                                i
                                                n
                                                a
                                                t
                                                e
                                                A
                                                l
                                                g
                                             
                                          
                                       
                                       Boolean representing the flag to terminate the execution of the entire parallel algorithm
                                    
                                    
                                       
                                          
                                             
                                                a
                                                p
                                                p
                                                l
                                                y
                                                L
                                                S
                                             
                                          
                                       
                                       Boolean representing whether the local search will be applied or not to generate 
                                             
                                                R
                                                P
                                                ,
                                             
                                          
                                          
                                             
                                                R
                                                P
                                                P
                                             
                                           in the next run
                                    
                                    
                                       
                                          
                                             
                                                p
                                                
                                                   L
                                                   S
                                                
                                             
                                          
                                       
                                       Value of the probability to swap two elements in the list of roster positions (when the local search is applied)
                                    
                                    
                                       
                                          
                                             
                                                r
                                                u
                                                n
                                                s
                                                O
                                                f
                                                S
                                                a
                                                m
                                                e
                                                P
                                                r
                                                o
                                                b
                                                a
                                                b
                                                i
                                                l
                                                i
                                                t
                                                y
                                             
                                          
                                       
                                       Counter of runs with probability 
                                             
                                                p
                                                
                                                   L
                                                   S
                                                
                                             
                                           (when the local search is applied)
                                       
                                    
                                    
                                       
                                          
                                             
                                                r
                                                u
                                                n
                                                s
                                                N
                                                o
                                                S
                                                u
                                                c
                                                c
                                                e
                                                s
                                                s
                                             
                                          
                                       
                                       Counter of runs without improvement of 
                                             
                                                Z
                                                (
                                                
                                                   R
                                                   
                                                      b
                                                      e
                                                      s
                                                      t
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                a
                                                p
                                                p
                                                l
                                                y
                                                B
                                                T
                                             
                                          
                                       
                                       Boolean representing whether the backtrack will be applied or not in the next run
                                    
                                    
                                       
                                          
                                             
                                                b
                                                a
                                                c
                                                k
                                                t
                                                r
                                                a
                                                c
                                                k
                                             
                                          
                                       
                                       Backtracking counter
                                    
                                    
                                       
                                          
                                             
                                                m
                                                a
                                                x
                                                B
                                                a
                                                c
                                                k
                                                t
                                                r
                                                a
                                                c
                                                k
                                                s
                                             
                                          
                                       
                                       Threshold for the backtracking counter
                                    
                                    
                                       
                                          
                                             
                                                t
                                                
                                                   s
                                                   e
                                                   q
                                                   
                                                
                                             
                                          
                                       
                                       Computational time of the sequential algorithm
                                    
                                    
                                       
                                          
                                             
                                                
                                                   t
                                                   
                                                      h
                                                      o
                                                      m
                                                      
                                                   
                                                
                                                ,
                                             
                                          
                                          
                                             
                                                t
                                                
                                                   h
                                                   e
                                                   t
                                                   
                                                
                                             
                                          
                                       
                                       Computational time of the homogeneous and the heterogeneous model of the parallel algorithm
                                    
                                    
                                       
                                          
                                             
                                                s
                                                p
                                                e
                                                e
                                                d
                                                u
                                                
                                                   p
                                                   
                                                      h
                                                      o
                                                      m
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       Speedup of the homogeneous model of the parallel algorithm
                                    
                                    
                                       
                                          
                                             
                                                s
                                                p
                                                e
                                                e
                                                d
                                                u
                                                
                                                   p
                                                   
                                                      h
                                                      e
                                                      t
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       Speedup of the heterogeneous model of the parallel algorithm
                                    
                                 
                              
                           
                        
                     


                        
                           
                              
                                 
                                 
                                 
                                    
                                       NRRP
                                       Nurse Rerostering Problem
                                    
                                    
                                       D19
                                       Dataset of the NRRP instances with 19 nurses (Pato & Moz, 2013)
                                       
                                    
                                    
                                       D32
                                       Dataset of the NRRP instances with 32 nurses (Pato & Moz, 2013)
                                    
                                    
                                       NRP
                                       Nurse Rostering Problem
                                    
                                    
                                       PFSP
                                       Permutation Flowshop Scheduling Problem
                                    
                                    
                                       RCPSP
                                       Resource Constrained Project Scheduling Problem
                                    
                                    
                                       CPU
                                       Central Processing Unit
                                    
                                    
                                       GPU
                                       Graphical Processing Unit
                                    
                                    
                                       CUDA
                                       Compute Unified Device Architecture
                                    
                                    
                                       SIMT
                                       Single Instruction Multiple Data
                                    
                                    
                                       SM
                                       Streaming Multiprocessor
                                    
                                    
                                       EA
                                       Evolutionary Algorithm
                                    
                                    
                                       GA
                                       Genetic Algorithm
                                    
                                    
                                       HH
                                             
                                                
                                                
                                                   P
                                                   M
                                                   X
                                                
                                             
                                          
                                       
                                       Sequential GA from Moz and Pato (2007)
                                       
                                    
                                    
                                       AISA
                                       Artificial Immune System Algorithm
                                    
                                 
                              
                           
                        
                     

The memory model was tuned to provide the most efficient version of the parallel algorithm for speedup. Our experiments show the relationship between the memory model and speedup. The speedup of each memory model was compared to the final memory model (Section 5.5, shown in Fig. B.7
                      as black). This memory model was the best for the homogeneous and heterogeneous model for both datasets.

Seven different memory models (see Fig. B.7) were averaged over the NRRP instances for the particular dataset. Each memory model was developed from the previous one (illustrated by arrows between patterns in the legend), e.g. the falling model was based on the horizontal model, etc. The horizontal model considered three locks. The first lock controls access to the best solution (line 50 in Algorithm 4), the second protects incrementing of run (line 52), and the third (line 51) enforces the correct updating of the local search parameters, e.g. runsNoSuccess. However, this line of the code in the algorithm is not marked by 
                        
                     , since the lock for the local search was omitted in all the memory models except the horizontal. This is still acceptable, since in the worst case the local search will be not switched on and off after an exact number of runs, but approximately after a given number of runs, due to concurrent access of the instances of the parallel algorithm. This change leads to a very significant increase of the speedup in the falling memory model (approximately 5 percent without any influence on the quality of the solutions). A further 5 percent was gained by moving the variables from global to shared memory. That is, R
                     0 in the crossed model, R in the rising model, isOccupied in the circled model, A in the vertical model, and Rprev
                      in the final (black) model.

@&#REFERENCES@&#

