@&#MAIN-TITLE@&#An enhanced branch-and-bound algorithm for the talent scheduling problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The talent scheduling problem is formulated as an IP model.


                        
                        
                           
                           An enhanced B&B algorithm is proposed for the problem.


                        
                        
                           
                           We employ a novel lower bound and memoization technique in the B&B.


                        
                        
                           
                           Two new dominance rules are employed to reduce the search space.


                        
                        
                           
                           Our algorithm outperforms the existing best approach.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

scheduling

Talent scheduling

Branch-and-bound

Dynamic programming

Dominance rules

@&#ABSTRACT@&#


               
               
                  The talent scheduling problem is a simplified version of the real-world film shooting problem, which aims to determine a shooting sequence so as to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we devise a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is enhanced by several accelerating techniques, including preprocessing, dominance rules and caching search states. Extensive experiments over two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the impacts of different parameter settings, algorithm components and instance generation distributions are disclosed by some additional experiments.
               
            

@&#INTRODUCTION@&#

The scenes of a film are not generally shot in the same sequence as they appear in the final version. Finding an optimal sequence in which the scenes are shot motivates the investigation of the talent scheduling problem, which is formally described as follows. Let 
                        
                           S
                           =
                           {
                           
                              s
                              1
                           
                           ,
                           
                              s
                              2
                           
                           ,
                           …
                           ,
                           
                              s
                              n
                           
                           }
                        
                      be a set of n scenes and 
                        
                           A
                           =
                           {
                           
                              a
                              1
                           
                           ,
                           
                              a
                              2
                           
                           ,
                           …
                           ,
                           
                              a
                              m
                           
                           }
                        
                      be a set of m actors. All scenes are assumed to be shot on a given location. Each scene sj
                      ∈ S requires a subset a(sj
                     ) ⊆ A of actors and has a duration d(sj
                     ) that commonly consists of one or several days. Each actor ai
                      is required by a subset s(ai
                     )⊆S of scenes. We denote by Π the permutation set of the n scenes and define ei
                     (π) (respectively, li
                     (π)) as the earliest day (respectively, the latest day) in which actor i is required to be present on location in the permutation π ∈ Π. Each actor ai
                      ∈ A has a daily wage c(ai
                     ) and is paid for each day from ei
                     (π) to li
                     (π) regardless of whether he (or she) is required in the scenes. The objective of the talent scheduling problem is to find a shooting sequence (i.e., a permutation π ∈ Π) of all scenes that minimizes the total paid wages.


                     Table 1
                      presents an example of the talent scheduling problem, which is reproduced from de la Banda, Stuckey, and Chu (2011). The information of a(sj
                     ) and s(ai
                     ) is determined by the m × n matrix M shown in Table 1(a), where cell M
                     
                        i, j
                      is filled with an “X” if actor ai
                      participates in scene sj
                      and with a “ · ” otherwise. Obviously, we can obtain a(sj
                     ) and s(ai
                     ) by 
                        
                           a
                           
                              (
                              
                                 s
                                 j
                              
                              )
                           
                           =
                           
                              {
                              
                                 a
                                 i
                              
                              |
                              
                                 M
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              =
                              X
                              }
                           
                        
                      and 
                        
                           s
                           
                              (
                              
                                 a
                                 i
                              
                              )
                           
                           =
                           
                              {
                              
                                 s
                                 j
                              
                              |
                              
                                 M
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              =
                              X
                              }
                           
                           ,
                        
                      respectively. The last row gives the duration of each scene and the rightmost column gives the daily cost of each actor. If the shooting sequence is 
                        
                           π
                           =
                           {
                           
                              s
                              1
                           
                           ,
                           
                              s
                              2
                           
                           ,
                           
                              s
                              3
                           
                           ,
                           
                              s
                              4
                           
                           ,
                           
                              s
                              5
                           
                           ,
                           
                              s
                              6
                           
                           ,
                           
                              s
                              7
                           
                           ,
                           
                              s
                              8
                           
                           ,
                           
                              s
                              9
                           
                           ,
                           
                              s
                              10
                           
                           ,
                           
                              s
                              11
                           
                           ,
                           
                              s
                              12
                           
                           }
                           ,
                        
                      we can get a matrix M(π) shown in Table 1(b), where in cell M
                     
                        i, j
                     (π) a sign “X” indicates that actor ai
                      participates in scene sj
                      and a sign “–” indicates that actor ai
                      is waiting at the filming location. The cost of each scene is presented in the second-to-last row and the total cost is 604. The cost incurred by the waiting status of the actors is called holding cost, which is shown in the last row of Table 1(b). The optimal solution of this instance is 
                        
                           
                              π
                              *
                           
                           =
                           
                              {
                              
                                 s
                                 5
                              
                              ,
                              
                                 s
                                 2
                              
                              ,
                              
                                 s
                                 7
                              
                              ,
                              
                                 s
                                 1
                              
                              ,
                              
                                 s
                                 6
                              
                              ,
                              
                                 s
                                 8
                              
                              ,
                              
                                 s
                                 4
                              
                              ,
                              
                                 s
                                 9
                              
                              ,
                              
                                 s
                                 3
                              
                              ,
                              
                                 s
                                 11
                              
                              ,
                              
                                 s
                                 10
                              
                              ,
                              
                                 s
                                 12
                              
                              }
                           
                        
                      whose total cost and holding cost are 434 and 53, respectively.

The talent scheduling problem was originated from Adelson, Norman, and Laporte (1976) and Cheng, Diamond, and Lin (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage. They proposed a simple dynamic programming algorithm to solve their problem. Cheng et al. (1993) studied a film scheduling problem in which all scenes have identical duration. They first showed that the problem is NP-hard even if each actor is required by two scenes and the daily wage of each actor is one. Next, they devised a branch-and-bound algorithm and a simple greedy hill climbing heuristic to solve their problem. Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.

The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages. However, it is a simplified version of the movie shoot scheduling problem (MSSP) introduced by Bomsdorf and Derigs (2008). In the MSSP, we need to deal with a couple of practical constraints, such as the precedence relations among scenes, the time windows of each scene, the resource availability, and the working time windows of actors and other film crew members. Recently, Liang, Zhang, Qin, Guo, and Lim (2014) proposed a branch-and-bound algorithm to solve the talent scheduling problem and achieved better results than de la Banda et al. (2011).

In literature, there exist several meta-heuristics developed for the problem introduced by Cheng et al. (1993). Nordström and Tufekci (1994) provided several hybrid genetic algorithms for this problem and showed that their algorithms outperform the heuristic approach in Cheng et al. (1993) in terms of both solution quality and computation speed. Fink and Voß (1999) treated this problem as a special application of the general pattern sequencing problem, and implemented a simulated annealing algorithm and several tabu search heuristics to solve it.

The talent scheduling problem is a very challenging combinatorial optimization problem. The current best exact approach by de la Banda et al. (2011) can only optimally solve small- and medium-size instances. In this paper, we propose an enhanced branch-and-bound algorithm for the talent scheduling problem, which uses the following two main techniques:

                        
                           •
                           
                              Dominance rules. When a partial solution represented by a node in the search tree can be dominated by another partial solution, this node need not be further explored and can be safely discarded.


                              Caching search states. The talent scheduling problem can be solved by dynamic programming algorithm (see de la Banda et al. (2011)). It is beneficial to incorporate the dynamic programming states into the branch-and-bound framework by a memoization technique. In the branch-and-bound tree, each node is related to a dynamic programming state. If the search process explores a certain node whose already confirmed cost is not smaller than the value of its corresponding cached state, this node can be pruned.

There are three main contributions in this paper. Firstly, we formulate the talent scheduling problem as a mixed integer linear programming model so that commercial mathematical programming solvers can be applied to the problem. Secondly, we propose an enhanced branch-and-bound algorithm whose novelties include a new lower bound, caching search states and two problem-specific dominance rules. Thirdly, we achieved the optimal solutions for more benchmark instances by our algorithm. The experimental results show that our branch-and-bound algorithm is superior to the current best exact approach by de la Banda et al. (2011).

The remainder of this paper is organized as follows. In Section 2, we present the mixed integer linear programming model for the talent scheduling problem. Next, we describe our branch-and-bound algorithm in Section 3, including the details on a double-ended search strategy, the computation of the lower bound, a preprocessing step, the state caching process and the dominance rules. The computational results are reported in Section 4, where we used our algorithm to solve over 200,000 benchmark instances. Finally, we conclude our study in Section 5 with some closing remarks.

The talent scheduling problem is essentially a permutation problem. It tries to find a permutation (i.e., a schedule) 
                        
                           π
                           =
                           (
                           π
                           (
                           1
                           )
                           ,
                           …
                           ,
                           π
                           (
                           n
                           )
                           )
                           ∈
                           Π
                           ,
                        
                      where π(k) is the kth scene in permutation π, such that the total cost C(π) is minimized. The value of C(π) is computed as:

                        
                           
                              
                                 
                                    
                                       
                                          C
                                          
                                             (
                                             π
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             m
                                          
                                          c
                                          
                                             (
                                             
                                                a
                                                i
                                             
                                             )
                                          
                                          ×
                                          (
                                          
                                             l
                                             i
                                          
                                          
                                             (
                                             π
                                             )
                                          
                                          −
                                          
                                             e
                                             i
                                          
                                          
                                             (
                                             π
                                             )
                                          
                                          +
                                          1
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                  

We set the parameter 
                        
                           
                              m
                              
                                 i
                                 ,
                                 j
                              
                           
                           =
                           1
                        
                      if 
                        
                           
                              M
                              
                                 i
                                 ,
                                 j
                              
                           
                           =
                           X
                        
                      and 
                        
                           
                              m
                              
                                 i
                                 ,
                                 j
                              
                           
                           =
                           0
                        
                      otherwise. The total holding cost can be easily derived as:

                        
                           
                              
                                 
                                    
                                       
                                          H
                                          
                                             (
                                             π
                                             )
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             m
                                          
                                          c
                                          
                                             (
                                             
                                                a
                                                i
                                             
                                             )
                                          
                                          ×
                                          (
                                          
                                             l
                                             i
                                          
                                          
                                             (
                                             π
                                             )
                                          
                                          −
                                          
                                             e
                                             i
                                          
                                          
                                             (
                                             π
                                             )
                                          
                                          +
                                          1
                                          −
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             m
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          d
                                          
                                             (
                                             
                                                s
                                                j
                                             
                                             )
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                  

Apparently, for this problem minimizing the total cost is equivalent to minimizing the total holding cost (de la Banda et al., 2011).

We create two dummy scenes s
                     0 and 
                        
                           s
                           
                              n
                              +
                              1
                           
                        
                      to represent the first and the last scenes to be shot, namely, 
                        
                           π
                           
                              (
                              0
                              )
                           
                           =
                           
                              s
                              0
                           
                        
                      and 
                        
                           π
                           
                              (
                              n
                              +
                              1
                              )
                           
                           =
                           
                              s
                              
                                 n
                                 +
                                 1
                              
                           
                        
                     . The starting days for shooting s
                     0 and 
                        
                           s
                           
                              n
                              +
                              1
                           
                        
                      are equal to zero and 
                        
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              n
                           
                           d
                           
                              (
                              
                                 s
                                 j
                              
                              )
                           
                           +
                           1
                           ,
                        
                      respectively. The durations of s
                     0 and 
                        
                           s
                           
                              n
                              +
                              1
                           
                        
                      are both equal to zero. The talent scheduling problem can be formulated into an integer linear programming model using the following decision variables:

                        
                           
                              x
                              
                                 k, j
                              : a binary variable that equals 1 if scene sj
                               is scheduled immediately after scene sk
                              , and 0 otherwise.


                              tj
                              : the starting day for shooting scene sj
                              .


                              ei
                              : the earliest shooting day that requires actor ai
                              .


                              li
                              : the latest shooting day that requires actor ai
                              .

The integer programming model is given by:

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          (
                                          IP
                                          )
                                          
                                          
                                       
                                    
                                    
                                       
                                          min
                                          
                                          
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             m
                                          
                                          c
                                          
                                             (
                                             
                                                a
                                                i
                                             
                                             )
                                          
                                          
                                             (
                                             
                                                l
                                                i
                                             
                                             −
                                             
                                                e
                                                i
                                             
                                             +
                                             1
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          s.t.
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             x
                                             
                                                0
                                                ,
                                                j
                                             
                                          
                                          =
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             x
                                             
                                                k
                                                ,
                                                n
                                                +
                                                1
                                             
                                          
                                          =
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                                ,
                                                k
                                                ≠
                                                j
                                             
                                             
                                                n
                                                +
                                                1
                                             
                                          
                                          
                                             x
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          =
                                          1
                                          ,
                                          
                                          ∀
                                          
                                          1
                                          ≤
                                          k
                                          ≤
                                          n
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                0
                                                ,
                                                k
                                                ≠
                                                j
                                             
                                             n
                                          
                                          
                                             x
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          =
                                          1
                                          ,
                                          
                                          ∀
                                          
                                          1
                                          ≤
                                          j
                                          ≤
                                          n
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                                ,
                                                k
                                                ≠
                                                j
                                             
                                             n
                                          
                                          
                                             t
                                             j
                                          
                                          
                                             x
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          =
                                          
                                             t
                                             k
                                          
                                          +
                                          d
                                          
                                             (
                                             
                                                s
                                                k
                                             
                                             )
                                          
                                          ,
                                          
                                          ∀
                                          
                                          0
                                          ≤
                                          k
                                          ≤
                                          n
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             t
                                             0
                                          
                                          =
                                          0
                                          ,
                                          
                                             t
                                             
                                                n
                                                +
                                                1
                                             
                                          
                                          =
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                             
                                             n
                                          
                                          d
                                          
                                             (
                                             
                                                s
                                                j
                                             
                                             )
                                          
                                          +
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (8)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             e
                                             i
                                          
                                          ≤
                                          
                                             t
                                             j
                                          
                                          ,
                                          
                                          ∀
                                          
                                          1
                                          ≤
                                          i
                                          ≤
                                          m
                                          ,
                                          
                                          1
                                          ≤
                                          j
                                          ≤
                                          n
                                          ,
                                          
                                          
                                             m
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          =
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (9)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             t
                                             j
                                          
                                          +
                                          d
                                          
                                             (
                                             
                                                s
                                                j
                                             
                                             )
                                          
                                          −
                                          1
                                          ≤
                                          
                                             l
                                             i
                                          
                                          ,
                                          
                                          ∀
                                          
                                          1
                                          ≤
                                          i
                                          ≤
                                          m
                                          ,
                                          
                                          1
                                          ≤
                                          j
                                          ≤
                                          n
                                          ,
                                          
                                          
                                             m
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          =
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (10)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             x
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          ,
                                          
                                          ∀
                                          
                                          0
                                          ≤
                                          k
                                          ≤
                                          n
                                          ,
                                          
                                          1
                                          ≤
                                          j
                                          ≤
                                          n
                                          +
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             e
                                             i
                                          
                                          ,
                                          
                                             l
                                             i
                                          
                                          ,
                                          
                                             t
                                             j
                                          
                                          ≥
                                          0
                                          
                                          and
                                          
                                          integer
                                          ,
                                          
                                          ∀
                                          
                                          1
                                          ≤
                                          i
                                          ≤
                                          m
                                          ,
                                          
                                          0
                                          ≤
                                          j
                                          ≤
                                          n
                                          +
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                  

The objective (1) is to minimize the total cost, where 
                        
                           
                              l
                              i
                           
                           −
                           
                              e
                              i
                           
                           +
                           1
                        
                      is the number of days in which actor ai
                      is present on location. Constraints (2) and (3) ensure that the first and the last scenes are s
                     0 and 
                        
                           
                              s
                              
                                 n
                                 +
                                 1
                              
                           
                           ,
                        
                      respectively. Constraints (4) and (5) guarantee that every scene has exactly one immediate successor and one immediate predecessor, respectively. Constraints (6) state that the starting day of scene sj
                      is determined by the starting day of its predecessor scene sk
                     . Moreover, these constraints prevent sub-tours from occurring. Constraints (8) and (9) ensure that the earliest and the latest shooting days that require actor ai
                      are determined by the starting days of scenes in which he (or she) is involved.

Observe that Constraints (6) are nonlinear. To linearize them, we introduce a set of additional variables z
                     
                        k, j
                     (0 ≤ k ≤ n, 1 ≤ j ≤ n, k ≠ j), and set 
                        
                           
                              z
                              
                                 k
                                 ,
                                 j
                              
                           
                           =
                           
                              t
                              j
                           
                           
                              x
                              
                                 k
                                 ,
                                 j
                              
                           
                        
                     . We know that 
                        
                           
                              z
                              
                                 k
                                 ,
                                 j
                              
                           
                           =
                           
                              t
                              j
                           
                        
                      if 
                        
                           
                              x
                              
                                 k
                                 ,
                                 j
                              
                           
                           =
                           1
                        
                      and 
                        
                           
                              z
                              
                                 k
                                 ,
                                 j
                              
                           
                           =
                           0
                        
                      otherwise. Thus, z
                     
                        k, j
                      can be restricted by the following four linear constraints:

                        
                           (12)
                           
                              
                                 
                                    
                                       
                                          
                                             z
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          ≥
                                          0
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (13)
                           
                              
                                 
                                    
                                       
                                          
                                             z
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          ≤
                                          
                                             t
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (14)
                           
                              
                                 
                                    
                                       
                                          
                                             z
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          ≥
                                          
                                             t
                                             j
                                          
                                          +
                                          L
                                          
                                             (
                                             
                                                x
                                                
                                                   k
                                                   ,
                                                   j
                                                
                                             
                                             −
                                             1
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (15)
                           
                              
                                 
                                    
                                       
                                          
                                             z
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          ≤
                                          L
                                          
                                             x
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     where L is a sufficiently large positive number. Accordingly, Constraints (6) can be rewritten as:

                        
                           (16)
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                1
                                                ,
                                                k
                                                ≠
                                                j
                                             
                                             n
                                          
                                          
                                             z
                                             
                                                k
                                                ,
                                                j
                                             
                                          
                                          =
                                          
                                             t
                                             k
                                          
                                          +
                                          d
                                          
                                             (
                                             
                                                s
                                                k
                                             
                                             )
                                          
                                          ,
                                          
                                          ∀
                                          
                                          0
                                          ≤
                                          k
                                          ≤
                                          n
                                       
                                    
                                 
                              
                           
                        
                     The objective (1) and Constraints (2)–(5), (7)–(16) constitute an integer linear programming model (ILP) for the talent scheduling problem. This ILP is quite difficult to be optimally solved by commercial integer programming solvers, e.g., ILOG CPLEX. Preliminary experiments revealed that only very small-scale instances, e.g., 
                        
                           n
                           =
                           10
                        
                      and 
                        
                           m
                           =
                           5
                           ,
                        
                      can be optimally solved by CPLEX 12.1. This is mainly because the linear relaxation of the ILP model cannot provide a high-quality lower bound for the problem.

Branch-and-bound is a general technique for optimally solving various combinatorial optimization problems. The basic idea of the branch-and-bound algorithm is to systematically and implicitly enumerate all candidate solutions, where large subsets of fruitless candidates are discarded by using upper and lower bounds, and dominance rules. In this section, we describe the main components of our proposed branch-and-bound algorithm, including a double-ended search strategy, a novel lower bound, the preprocessing stage, the state caching strategy and two dominance rules. For the rest of this discussion, we choose minimizing the total holding cost as the objective of the talent scheduling problem.

The solutions of the talent scheduling problem can be easily presented in a branch-and-bound search tree. Suppose we aim to find an optimal permutation π
                        *
                        
                           
                              =
                              (
                              
                                 π
                                 *
                              
                              
                                 (
                                 1
                                 )
                              
                              ,
                           
                         
                        π
                        *(2), 
                           
                              …
                              ,
                           
                         
                        π
                        *(n)). A typical branch-and-bound process first determines the first k scenes to be shot, denoted by a partial permutation 
                           
                              (
                              
                                 π
                                 ^
                              
                              
                                 (
                                 1
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 k
                                 )
                              
                              )
                              ,
                           
                         at level k of the search tree. Then, it generates 
                           
                              n
                              −
                              k
                           
                         branches, each trying to explore a node by assigning a scene to 
                           
                              π
                              (
                              k
                              +
                              1
                              )
                           
                        . At some tree node at level 
                           
                              k
                              +
                              1
                              ,
                           
                         there is a known partial permutation 
                           
                              (
                              
                                 π
                                 ^
                              
                              
                                 (
                                 1
                                 )
                              
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 2
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 k
                                 +
                                 1
                                 )
                              
                              )
                           
                         and a set of 
                           
                              n
                              −
                              k
                              −
                              1
                           
                         unscheduled scenes. If the lower bound LB to the value of the solutions that contain the partial permutation 
                           
                              (
                              
                                 π
                                 ^
                              
                              
                                 (
                                 1
                                 )
                              
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 2
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 k
                                 +
                                 1
                                 )
                              
                              )
                           
                         is not less than the current best solution value (i.e., an upper bound UB), then the branch to the node associated with 
                           
                              
                                 π
                                 ^
                              
                              
                                 (
                                 k
                                 +
                                 1
                                 )
                              
                           
                         can be safely discarded. Once the search process reaches a node at level n of the tree, a feasible solution is obtained and the current best solution may be updated accordingly.

The above search methodology can be called the single-ended search strategy. As did by Cheng et al. (1993) and de la Banda et al. (2011), we can employ a double-ended search strategy that alternatively fixes the first and the last undetermined positions in the permutation. That is to say, the double-ended search determines a scene permutation following the order 
                           
                              π
                              (
                              1
                              )
                              ,
                              π
                              (
                              n
                              )
                              ,
                              π
                              (
                              2
                              )
                              ,
                              π
                              (
                              n
                              −
                              1
                              )
                           
                         and so on. When using the double-ended search strategy, a node in some level of the search tree corresponds to a partially determined permutation with the form 
                           
                              (
                              
                                 π
                                 ^
                              
                              
                                 (
                                 1
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 k
                                 −
                                 1
                                 )
                              
                              ,
                              π
                              
                                 (
                                 k
                                 )
                              
                              ,
                              …
                              ,
                              π
                              
                                 (
                                 l
                                 )
                              
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 l
                                 +
                                 1
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 n
                                 )
                              
                              )
                              ,
                           
                         where 1 ≤ k ≤ l ≤ n and the value of π(h) (k ≤ h ≤ l) is undetermined. We denote by B the set of scenes scheduled at the beginning of the permutation, namely 
                           
                              B
                              =
                              {
                              
                                 π
                                 ^
                              
                              
                                 (
                                 1
                                 )
                              
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 2
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 k
                                 −
                                 1
                                 )
                              
                              }
                              ,
                           
                         and by E the set of scenes scheduled at the end, namely 
                           
                              E
                              =
                              {
                              
                                 π
                                 ^
                              
                              
                                 (
                                 l
                                 +
                                 1
                                 )
                              
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 l
                                 +
                                 2
                                 )
                              
                              ,
                              …
                              ,
                              
                                 π
                                 ^
                              
                              
                                 (
                                 n
                                 )
                              
                              }
                           
                        . The remaining scenes are put in a set Q, namely 
                           
                              Q
                              =
                              S
                              −
                              B
                              −
                              E
                           
                        . Moreover, for convenience, we denote by 
                           
                              B
                              →
                           
                         and 
                           
                              E
                              →
                           
                         the partially determined scene sequences at the beginning and at the end of a permutation, i.e., 
                           
                              
                                 B
                                 →
                              
                              =
                              
                                 (
                                 
                                    π
                                    ^
                                 
                                 
                                    (
                                    1
                                    )
                                 
                                 ,
                                 …
                                 ,
                                 
                                    π
                                    ^
                                 
                                 
                                    (
                                    k
                                    −
                                    1
                                    )
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 E
                                 →
                              
                              =
                              
                                 (
                                 
                                    π
                                    ^
                                 
                                 
                                    (
                                    l
                                    +
                                    1
                                    )
                                 
                                 ,
                                 …
                                 ,
                                 
                                    π
                                    ^
                                 
                                 
                                    (
                                    n
                                    )
                                 
                                 )
                              
                           
                        .
                     

The double-ended search strategy is beneficial to solving the talent scheduling problem. As pointed out by de la Banda et al. (2011), more accurate lower bounds can be obtained by increasing the number of fixed actors. The actor required by the scenes in both B and E is labeled fixed since the total number of his/her on-location days is fixed and his/her cost in the final schedule already becomes known (Cheng et al., 1993). We do not need to consider any fixed actor in the later stages of the search process, which certainly reduces the size of the problem. Let 
                           
                              a
                              
                                 (
                                 Q
                                 )
                              
                              =
                              
                                 ∪
                                 
                                    s
                                    ∈
                                    Q
                                 
                              
                              a
                              
                                 (
                                 s
                                 )
                              
                           
                         be the set of actors required by at least one scene in Q⊆S. The set of all fixed actors can be defined by 
                           
                              F
                              =
                              a
                              (
                              B
                              )
                              ∩
                              a
                              (
                              E
                              )
                           
                        .

A generic double-ended branch-and-bound framework is given in Algorithm 1
                        . The operator “○” in lines 3, 11 and 15 indicates concatenating two partially determined scene sequences. The function 
                           
                              search
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         returns the optimal solution to the talent scheduling problem with known 
                           
                              B
                              →
                           
                         and 
                           
                              E
                              →
                           
                        ; we denote this problem by 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                        . The optimal solution of the talent scheduling problem can be achieved by invoking 
                           
                              search
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                           
                        ) with 
                           
                              B
                              =
                              E
                              =
                              ∅
                           
                         and 
                           
                              Q
                              =
                              S
                           
                        . The function evaluate(solution) returns the objective value of solution. The function 
                           
                              lower
                              _
                              bound
                              (
                              
                                 B
                                 →
                              
                              ∘
                              s
                              ,
                              Q
                              −
                              
                                 {
                                 s
                                 }
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         provides a valid lower bound to problem 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ∘
                              s
                              ,
                              Q
                              −
                              
                                 {
                                 s
                                 }
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                              ,
                           
                         where the set B of scenes is scheduled before scene s and the set 
                           
                              S
                              −
                              B
                              −
                              {
                              s
                              }
                           
                         of scenes is scheduled after scene s. If the lower bound (LB) at some branch-and-bound tree node is greater than the upper bound (UB), we discard this node (see lines 12–14, Algorithm 1). Note that UB is a global variable. The branch-and-bound search tries to schedule each remaining scene s immediately after 
                           
                              
                                 B
                                 →
                              
                              ,
                           
                         and then swaps the roles of 
                           
                              B
                              →
                           
                         and 
                           
                              E
                              →
                           
                         to continue building the search tree (see line 15, Algorithm 1). Note that we use 
                           
                              R
                              (
                              
                                 B
                                 →
                              
                              )
                           
                         to denote the reverse sequence of 
                           
                              B
                              →
                           
                        . For example, if 
                           
                              P
                              
                                 (
                                 
                                    B
                                    →
                                 
                                 ,
                                 Q
                                 ,
                                 
                                    E
                                    →
                                 
                                 )
                              
                              =
                              P
                              
                                 (
                                 
                                    (
                                    1
                                    ,
                                    2
                                    )
                                 
                                 ,
                                 
                                    {
                                    3
                                    ,
                                    4
                                    }
                                 
                                 ,
                                 
                                    (
                                    5
                                    ,
                                    6
                                    )
                                 
                                 )
                              
                              ,
                           
                         then 
                           
                              P
                              
                                 (
                                 R
                                 
                                    (
                                    
                                       E
                                       →
                                    
                                    )
                                 
                                 ,
                                 Q
                                 ,
                                 R
                                 
                                    (
                                    
                                       B
                                       →
                                    
                                    )
                                 
                                 )
                              
                              =
                              P
                              
                                 (
                                 
                                    (
                                    6
                                    ,
                                    5
                                    )
                                 
                                 ,
                                 
                                    {
                                    3
                                    ,
                                    4
                                    }
                                 
                                 ,
                                 
                                    (
                                    2
                                    ,
                                    1
                                    )
                                 
                                 )
                              
                           
                        .

The problem 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         corresponds to a node in the search tree. Its lower bound 
                           
                              lower
                              _
                              bound
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         can be expressed as:

                           
                              
                                 
                                    
                                       
                                          
                                             lower
                                             _
                                             bound
                                             
                                                (
                                                
                                                   B
                                                   →
                                                
                                                ,
                                                Q
                                                ,
                                                
                                                   E
                                                   →
                                                
                                                )
                                             
                                             =
                                             c
                                             o
                                             s
                                             t
                                             
                                                (
                                                
                                                   B
                                                   →
                                                
                                                ,
                                                
                                                   E
                                                   →
                                                
                                                )
                                             
                                             +
                                             lower
                                             
                                                (
                                                B
                                                ,
                                                Q
                                                ,
                                                E
                                                )
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                              ,
                           
                         called past cost, is the cost incurred by the path from the root node to the current node, and 
                           
                              lower
                              (
                              B
                              ,
                              Q
                              ,
                              E
                              )
                           
                         provides a lower bound to future cost, i.e., the holding cost to be incurred by scheduling the scenes in Q. We discuss the past cost 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         in this section and leave the description of 
                           
                              lower
                              (
                              B
                              ,
                              Q
                              ,
                              E
                              )
                           
                         in Section 3.4.

When 
                           
                              B
                              →
                           
                         and 
                           
                              E
                              →
                           
                         have been fixed, a portion of holding cost, namely 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                              ,
                           
                         is determined regardless of the schedule of the scenes in Q. The past cost 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         is incurred by the holding days that can be confirmed by the following three ways:

                           
                              1.
                              For the actor ai
                                  ∈ a(B) ∩ a(E), the number of his/her holding days in any complete schedule can be fixed (Cheng et al., 1993).

For the actor 
                                    
                                       
                                          a
                                          i
                                       
                                       ∈
                                       a
                                       
                                          (
                                          B
                                          )
                                       
                                       ∩
                                       a
                                       
                                          (
                                          Q
                                          )
                                       
                                       −
                                       a
                                       
                                          (
                                          E
                                          )
                                       
                                       ,
                                    
                                  the number of his/her holding days in the time period for completing scenes in B can be fixed.

For the actor 
                                    
                                       
                                          a
                                          i
                                       
                                       ∈
                                       a
                                       
                                          (
                                          E
                                          )
                                       
                                       ∩
                                       a
                                       
                                          (
                                          Q
                                          )
                                       
                                       −
                                       a
                                       
                                          (
                                          B
                                          )
                                       
                                       ,
                                    
                                  the number of his/her holding days in the time period for completing scenes in E can be fixed.

Furthermore, we use cost(s, B, E) to represent the newly confirmed holding cost incurred by placing scene s ∈ Q at the first unscheduled position, namely the position after any scene in B and before any scene in 
                           
                              S
                              −
                              B
                              −
                              {
                              s
                              }
                           
                        . Note that cost(s, B, E) is irrelevant to the orders of scenes in B and E. Obviously, we have 
                           
                              c
                              o
                              s
                              t
                              
                                 (
                                 
                                    B
                                    →
                                 
                                 ∘
                                 
                                    {
                                    s
                                    }
                                 
                                 ,
                                 
                                    E
                                    →
                                 
                                 )
                              
                              =
                              c
                              o
                              s
                              t
                              
                                 (
                                 
                                    B
                                    →
                                 
                                 ,
                                 
                                    E
                                    →
                                 
                                 )
                              
                              +
                              c
                              o
                              s
                              t
                              
                                 (
                                 s
                                 ,
                                 B
                                 ,
                                 E
                                 )
                              
                              ,
                           
                         which implies that the past cost of a tree node is the sum of the past cost of its father node and the newly confirmed holding cost incurred by branching. As a result, the lower bound function can be rewritten as:

                           
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             lower
                                             _
                                             bound
                                             (
                                             
                                                B
                                                →
                                             
                                             ∘
                                             s
                                             ,
                                             Q
                                             −
                                             
                                                {
                                                s
                                                }
                                             
                                             ,
                                             
                                                E
                                                →
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             =
                                             c
                                             o
                                             s
                                             t
                                             
                                                (
                                                
                                                   B
                                                   →
                                                
                                                ,
                                                
                                                   E
                                                   →
                                                
                                                )
                                             
                                             +
                                             c
                                             o
                                             s
                                             t
                                             
                                                (
                                                s
                                                ,
                                                B
                                                ,
                                                E
                                                )
                                             
                                             +
                                             lower
                                             
                                                (
                                                B
                                                ∪
                                                
                                                   {
                                                   s
                                                   }
                                                
                                                ,
                                                Q
                                                −
                                                
                                                   {
                                                   s
                                                   }
                                                
                                                ,
                                                E
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The value of cost(s, B, E) is incurred by the following two types of actors:


                        Type 1. If actor ai
                         is included in neither a(B) ∩ a(E) nor a(s) but is still present on location during the days of shooting scene s (i.e., ai
                         ∉ a(B) ∩ a(E), ai
                         ∉ a(s) and 
                           
                              
                                 a
                                 i
                              
                              ∈
                              a
                              
                                 (
                                 B
                                 )
                              
                              ∩
                              a
                              
                                 (
                                 Q
                                 −
                                 
                                    {
                                    s
                                    }
                                 
                                 )
                              
                           
                        ), he/she must be held during the shooting days of scene s.


                        Type 2. If actor ai
                         is not included in a(B) ∩ a(E) but is included in a(E), and scene s is his/her first involved scene (i.e., ai
                         ∉ a(B) and ai
                         ∈ a(s) and ai
                         ∈ a(E)), the shooting days of those scenes in 
                           
                              Q
                              −
                              {
                              s
                              }
                           
                         that do not require actor ai
                         can be confirmed as his/her holding days.
                     

To demonstrate the computation of 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         and cost(s, B, E), let us consider a partial schedule presented in Table 2, where 
                           
                              
                                 B
                                 →
                              
                              =
                              
                                 (
                                 
                                    s
                                    1
                                 
                                 ,
                                 
                                    s
                                    2
                                 
                                 )
                              
                              ,
                           
                        
                        
                           
                              
                                 E
                                 →
                              
                              =
                              
                                 (
                                 
                                    s
                                    5
                                 
                                 ,
                                 
                                    s
                                    6
                                 
                                 )
                              
                           
                         and 
                           
                              Q
                              =
                              S
                              −
                              B
                              −
                              E
                              =
                              {
                              
                                 s
                                 3
                              
                              ,
                              
                                 s
                                 4
                              
                              }
                           
                        . In the columns “
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                        ”, “cost(s
                        3, B, E)” and “cost(s
                        4, B, E)”, we present the corresponding holding cost associated with each actor. For example, the value of 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         can be obtained by summing up the values in all cells of the column “
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                        ”. Since actor a
                        1 is a fixed actor, his/her holding cost must be 
                           
                              c
                              
                                 (
                                 
                                    a
                                    1
                                 
                                 )
                              
                              
                                 (
                                 d
                                 
                                    (
                                    
                                       s
                                       2
                                    
                                    )
                                 
                                 +
                                 d
                                 
                                    (
                                    
                                       s
                                       4
                                    
                                    )
                                 
                                 )
                              
                           
                         no matter how the scenes in Q are scheduled. Actor a
                        2 is involved in B and Q but is not involved in E, so we can only say that the holding cost of this actor is at least c(a
                        2)d(s
                        2). Similarly, actor a
                        3 has an already incurred holding cost c(a
                        3)d(s
                        5). For actors a
                        4 and a
                        5, we cannot get any clue on their holding costs from this partial schedule and thus we say their already confirmed holding costs are both zero. Suppose scene s
                        4 is placed at the first unscheduled position. Since actors a
                        2 and a
                        4 must be present on location during the period of shooting scene s
                        4, the newly confirmed holding cost is 
                           
                              c
                              o
                              s
                              t
                              
                                 (
                                 
                                    s
                                    4
                                 
                                 ,
                                 B
                                 ,
                                 E
                                 )
                              
                              =
                              
                                 (
                                 c
                                 
                                    (
                                    
                                       a
                                       2
                                    
                                    )
                                 
                                 +
                                 c
                                 
                                    (
                                    
                                       a
                                       4
                                    
                                    )
                                 
                                 )
                              
                              d
                              
                                 (
                                 
                                    s
                                    4
                                 
                                 )
                              
                           
                        . If we suppose scene s
                        3 is placed at the first unscheduled position, the newly confirmed holding cost is only related to actor a
                        3, namely, 
                           
                              c
                              o
                              s
                              t
                              
                                 (
                                 
                                    s
                                    3
                                 
                                 ,
                                 B
                                 ,
                                 E
                                 )
                              
                              =
                              c
                              
                                 (
                                 
                                    a
                                    3
                                 
                                 )
                              
                              d
                              
                                 (
                                 
                                    s
                                    4
                                 
                                 )
                              
                           
                        .

Define 
                           
                              o
                              (
                              Q
                              )
                              =
                              a
                              (
                              S
                              −
                              Q
                              )
                              ∩
                              a
                              (
                              Q
                              )
                           
                         as the set of actors required by scenes in both Q and 
                           
                              S
                              −
                              Q
                           
                         (de la Banda et al., 2011). Then, cost(s, B, E) can be mathematically computed by:

                           
                              (17)
                              
                                 
                                    
                                       
                                          
                                             c
                                             o
                                             s
                                             t
                                             (
                                             s
                                             ,
                                             B
                                             ,
                                             E
                                             )
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             d
                                             (
                                             s
                                             )
                                             ×
                                             c
                                             (
                                             o
                                             (
                                             B
                                             )
                                             −
                                             o
                                             (
                                             E
                                             )
                                             −
                                             a
                                             (
                                             s
                                             )
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             +
                                             
                                             
                                                ∑
                                                
                                                   
                                                      s
                                                      ′
                                                   
                                                   ∈
                                                   Q
                                                   −
                                                   
                                                      {
                                                      s
                                                      }
                                                   
                                                
                                             
                                             d
                                             
                                                (
                                                
                                                   s
                                                   ′
                                                
                                                )
                                             
                                             
                                                ×
                                                (
                                                c
                                             
                                             
                                                (
                                                
                                                   (
                                                   a
                                                   
                                                      (
                                                      s
                                                      )
                                                   
                                                   −
                                                   o
                                                   
                                                      (
                                                      B
                                                      )
                                                   
                                                   )
                                                
                                                ∩
                                                o
                                                
                                                   (
                                                   E
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             −
                                             
                                             c
                                             (
                                             
                                                (
                                                a
                                                
                                                   (
                                                   s
                                                   )
                                                
                                                −
                                                o
                                                
                                                   (
                                                   B
                                                   )
                                                
                                                )
                                             
                                             ∩
                                             o
                                             
                                                (
                                                E
                                                )
                                             
                                             ∩
                                             a
                                             
                                                (
                                                
                                                   s
                                                   ′
                                                
                                                )
                                             
                                             )
                                             )
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where c(G) is the total daily cost of all actors in G⊆A, i.e., 
                           
                              c
                              
                                 (
                                 G
                                 )
                              
                              =
                              
                                 ∑
                                 
                                    a
                                    ∈
                                    G
                                 
                              
                              c
                              
                                 (
                                 a
                                 )
                              
                           
                        .

We use Table 3 to explain Expression (17). All actors can be classified into 16 patterns according to whether they are required by the scenes in sets B, {s}, 
                           
                              Q
                              −
                              {
                              s
                              }
                           
                         and E. If an actor is required by at least one scene in some set, the corresponding cell in columns 2–5 is filled with a sign “
                           X
                        ”; otherwise it is filled with a sign “ · ”. In columns 6–12, if an actor is included in some actor set, the corresponding cell is filled with “1”; otherwise, it is filled with “0”. For example, for pattern 2 actors that has 
                           
                              (
                              B
                              ,
                              {
                              s
                              }
                              ,
                              Q
                              −
                              {
                              s
                              }
                              ,
                              E
                              )
                              =
                              (
                              ·
                              ,
                              X
                              ,
                              X
                              ,
                              X
                              )
                              ,
                           
                         we can derive that all actors of this pattern must be included in sets 
                           
                              o
                              (
                              E
                              )
                              ,
                              a
                              (
                              s
                              )
                              ,
                              a
                              (
                              s
                              )
                              −
                              o
                              (
                              B
                              )
                           
                         and 
                           
                              (
                              a
                              (
                              s
                              )
                              −
                              o
                              (
                              B
                              )
                              )
                              ∩
                              o
                              (
                              E
                              )
                           
                         and cannot exist in sets o(B), 
                           
                              o
                              (
                              B
                              )
                              −
                              o
                              (
                              E
                              )
                           
                         and 
                           
                              o
                              (
                              B
                              )
                              −
                              o
                              (
                              E
                              )
                              −
                              a
                              (
                              s
                              )
                           
                        .

From Table 3, we can observe that set 
                           
                              o
                              (
                              B
                              )
                              −
                              o
                              (
                              E
                              )
                              −
                              a
                              (
                              s
                              )
                           
                         only contains type 1 actors that have pattern 
                           
                              (
                              B
                              ,
                              {
                              s
                              }
                              ,
                              Q
                              −
                              {
                              s
                              }
                              ,
                              E
                              )
                              =
                              (
                              X
                              ,
                              ·
                              ,
                              X
                              ,
                              ·
                              )
                           
                        . Thus, the first component of Expression (17) corresponds to type 1 actors. Set 
                           
                              (
                              a
                              (
                              s
                              )
                              −
                              o
                              (
                              B
                              )
                              )
                              ∩
                              o
                              (
                              E
                              )
                           
                         contains type 2 actors that have either pattern 
                           
                              (
                              B
                              ,
                              {
                              s
                              }
                              ,
                              Q
                              −
                              {
                              s
                              }
                              ,
                              E
                              )
                              =
                              (
                              ·
                              ,
                              X
                              ,
                              X
                              ,
                              X
                              )
                           
                         or pattern 
                           
                              (
                              B
                              ,
                              {
                              s
                              }
                              ,
                              Q
                              −
                              {
                              s
                              }
                              ,
                              E
                              )
                              =
                              (
                              ·
                              ,
                              X
                              ,
                              ·
                              ,
                              X
                              )
                           
                        . The second component of Expression (17) is the holding cost of type 2 actors during the shooting days for the scenes in 
                           
                              Q
                              −
                              {
                              s
                              }
                           
                        .

The holding costs of all fixed actors will not change in the later stages of the search. We use set AN
                         to contain all non-fixed actors, namely 
                           
                              
                                 A
                                 N
                              
                              =
                              
                                 {
                                 
                                    a
                                    i
                                 
                                 ∈
                                 A
                                 :
                                 
                                    a
                                    i
                                 
                                 ∉
                                 a
                                 
                                    (
                                    B
                                    )
                                 
                                 ∩
                                 a
                                 
                                    (
                                    E
                                    )
                                 
                                 }
                              
                           
                        . When solving problem 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                              ,
                           
                         we only need to consider the actors in AN
                        . As did by de la Banda et al. (2011), the problem 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         can be further simplified as:

                           
                              •
                              We remove from AN
                                  all actors that are required by only one scene. This is because such actors will not bring about extra holding cost.

We exclude from AN
                                  all non-fixed actors that are not required by the scenes in Q.

If scenes s
                                 1 and s
                                 2 satisfy 
                                    
                                       a
                                       
                                          (
                                          
                                             s
                                             1
                                          
                                          )
                                       
                                       ∩
                                       
                                          A
                                          N
                                       
                                       =
                                       a
                                       
                                          (
                                          
                                             s
                                             2
                                          
                                          )
                                       
                                       ∩
                                       
                                          A
                                          N
                                       
                                       ,
                                    
                                  then we replace them with a single scene with duration 
                                    
                                       d
                                       
                                          (
                                          s
                                          )
                                       
                                       =
                                       d
                                       
                                          (
                                          
                                             s
                                             1
                                          
                                          )
                                       
                                       +
                                       d
                                       
                                          (
                                          
                                             s
                                             2
                                          
                                          )
                                       
                                    
                                  since they can be regarded as duplicate scenes. The correctness of merging duplicate scenes has been proved by de la Banda et al. (2011).

The example shown in Table 4
                         illustrates the preprocessing steps. In the problem given by Table 4(a), actor a
                        4 is fixed and actor a
                        5 is not required by the scenes in 
                           
                              Q
                              =
                              {
                              
                                 s
                                 1
                              
                              ,
                              
                                 s
                                 2
                              
                              ,
                              
                                 s
                                 3
                              
                              ,
                              
                                 s
                                 4
                              
                              }
                           
                        . Therefore, we can remove actors a
                        4 and a
                        5 to make 
                           
                              
                                 A
                                 N
                              
                              =
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    2
                                 
                                 ,
                                 
                                    a
                                    3
                                 
                                 }
                              
                           
                        . Now since 
                           
                              a
                              
                                 (
                                 
                                    s
                                    2
                                 
                                 )
                              
                              ∩
                              
                                 A
                                 N
                              
                              =
                              a
                              
                                 (
                                 
                                    s
                                    3
                                 
                                 )
                              
                              ∩
                              
                                 A
                                 N
                              
                              =
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    2
                                 
                                 ,
                                 
                                    a
                                    3
                                 
                                 }
                              
                              ,
                           
                         we can merge scenes s
                        2 and s
                        3. After these preprocessing steps, we get a simplified problem as shown in Table 4(b), where 
                           
                              s
                              2
                              ′
                           
                         is the scene created by merging scenes s
                        2 and s
                        3.

In de la Banda et al. (2011), the authors proposed a lower bound to the future cost. They generated two lower bounds using (
                           
                              o
                              (
                              B
                              )
                              −
                              F
                              ,
                           
                         
                        Q) and (
                           
                              o
                              (
                              E
                              )
                              −
                              F
                              ,
                           
                         
                        Q) as input information, and claimed that the sum of these two lower bounds is still a lower bound (denoted by L
                        0) to the future cost. The reader is encouraged to refer to de la Banda et al. (2011) for the details of this lower bound.

In this section, we present a new implementation of lower(B, Q, E). Suppose σ is an arbitrary permutation of the scenes in Q. We define xi
                         as the holding cost of actor ai
                         during the period of shooting the scenes in Q with the order specified by permutation σ. If lower(B, Q, E) = 
                           
                              
                                 min
                                 σ
                              
                              
                                 {
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          A
                                          N
                                       
                                    
                                 
                                 
                                    x
                                    i
                                 
                                 }
                              
                              ,
                           
                         we get the minimum possible future cost. However, it is impossible to get the value of 
                           
                              
                                 min
                                 σ
                              
                              
                                 {
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          A
                                          N
                                       
                                    
                                 
                                 
                                    x
                                    i
                                 
                                 }
                              
                           
                         unless all σ are checked. Instead, we propose a method to produce a lower bound to 
                           
                              
                                 min
                                 σ
                              
                              
                                 {
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          A
                                          N
                                       
                                    
                                 
                                 
                                    x
                                    i
                                 
                                 }
                              
                           
                        .

If an actor ai
                         satisfies ai
                         ∉ a(B), ai
                         ∉ a(E) and ai
                         ∈ a(Q), the lowest possible holding cost of this actor during the period of shooting the scenes in Q may be zero. Therefore, we only consider the actors in set 
                           
                              
                                 A
                                 N
                                 ′
                              
                              =
                              
                                 (
                                 o
                                 
                                    (
                                    B
                                    )
                                 
                                 −
                                 F
                                 )
                              
                              ∪
                              
                                 (
                                 o
                                 
                                    (
                                    E
                                    )
                                 
                                 −
                                 F
                                 )
                              
                              ⊆
                              
                                 A
                                 N
                              
                           
                        . For any two different actors 
                           
                              
                                 a
                                 i
                              
                              ,
                              
                                 a
                                 j
                              
                              ∈
                              
                                 A
                                 N
                                 ′
                              
                              ,
                           
                         we can derive a constraint 
                           
                              
                                 x
                                 i
                              
                              +
                              
                                 x
                                 j
                              
                              ≥
                              
                                 c
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              ,
                           
                         where c
                        
                           i, j
                         is a constant computed based on the following four cases:
                        
                     


                        Case 1: 
                           
                              
                                 a
                                 i
                              
                              ,
                              
                                 a
                                 j
                              
                              ∈
                              o
                              
                                 (
                                 B
                                 )
                              
                              −
                              F
                           
                        . Let 
                           
                              
                                 a
                                 i
                              
                              
                                 (
                                 s
                                 )
                              
                              =
                           
                         “X” if actor ai
                         is required by scene s and 
                           
                              
                                 a
                                 i
                              
                              
                                 (
                                 s
                                 )
                              
                              =
                           
                         “ · ” otherwise. For any scene s ∈ Q, the tuple (ai
                        (s), aj
                        (s)) must have one of the following four patterns: (X, X), (X, · ), ( ·, X), ( ·, · ). First, we schedule all scenes with pattern (X, X) immediately after the scenes in B and schedule all scenes with pattern ( ·, ·) immediately before the scenes in E. Second, we group the scenes with (X, · ) and the scenes with ( ·, X) into two sets. Third, we schedule these two set of scenes in the middle of the permutation, creating two schedules as shown in Table 5. If only actors ai
                         and aj
                         are considered, the optimal schedule must be either one of these two schedules. The value of c
                        
                           i, j
                         is set to the holding cost of the optimal schedule related to only actors ai
                         and aj
                        . For the schedule in Table 5(a), if we define 
                           
                              
                                 S
                                 1
                              
                              =
                              
                                 {
                                 s
                                 ∈
                                 Q
                                 |
                                 
                                    (
                                    
                                       a
                                       i
                                    
                                    
                                       (
                                       s
                                       )
                                    
                                    ,
                                    
                                       a
                                       j
                                    
                                    
                                       (
                                       s
                                       )
                                    
                                    )
                                 
                                 =
                                 
                                    (
                                    X
                                    ,
                                    ·
                                    )
                                 
                                 }
                              
                              ,
                           
                         then the holding cost is c(aj
                        ) × d(S
                        1), where 
                           
                              d
                              
                                 (
                                 
                                    S
                                    1
                                 
                                 )
                              
                              =
                              
                                 ∑
                                 
                                    s
                                    ∈
                                    
                                       S
                                       1
                                    
                                 
                              
                              d
                              
                                 (
                                 s
                                 )
                              
                           
                        . Similarly, for the schedule in Table 5(b), we have a holding cost c(ai
                        ) × d(S
                        2), where 
                           
                              
                                 S
                                 2
                              
                              =
                              
                                 {
                                 s
                                 ∈
                                 Q
                                 |
                                 
                                    (
                                    
                                       a
                                       i
                                    
                                    
                                       (
                                       s
                                       )
                                    
                                    ,
                                    
                                       a
                                       j
                                    
                                    
                                       (
                                       s
                                       )
                                    
                                    )
                                 
                                 =
                                 
                                    (
                                    ·
                                    ,
                                    X
                                    )
                                 
                                 }
                              
                           
                        . Accordingly, we set 
                           
                              
                                 c
                                 
                                    i
                                    ,
                                    j
                                 
                              
                              =
                              min
                              
                                 {
                                 c
                                 
                                    (
                                    
                                       a
                                       j
                                    
                                    )
                                 
                                 ×
                                 d
                                 
                                    (
                                    
                                       S
                                       1
                                    
                                    )
                                 
                                 ,
                                 c
                                 
                                    (
                                    
                                       a
                                       i
                                    
                                    )
                                 
                                 ×
                                 d
                                 
                                    (
                                    
                                       S
                                       2
                                    
                                    )
                                 
                                 }
                              
                           
                        .


                        Case 2: 
                           
                              
                                 a
                                 i
                              
                              ,
                              
                                 a
                                 j
                              
                              ∈
                              o
                              
                                 (
                                 E
                                 )
                              
                              −
                              F
                           
                        . We schedule all scenes with pattern (X, X) immediately before the scenes in E and schedule all scenes with pattern ( ·, ·) immediately after the scenes in B. The remaining analysis is similar to that in Case 1.


                        Case 3: 
                           
                              
                                 a
                                 i
                              
                              ∈
                              o
                              
                                 (
                                 B
                                 )
                              
                              −
                              F
                           
                         and 
                           
                              
                                 a
                                 j
                              
                              ∈
                              o
                              
                                 (
                                 E
                                 )
                              
                              −
                              F
                           
                        . We schedule all scenes with pattern (X, · ) immediately after the scenes in B and schedule all scenes with pattern ( ·, X) immediately before the scenes in E. If there does not exist a scene with pattern (X, X), the holding cost may be zero and thus c
                        
                           i, j
                         is set to zero; otherwise c
                        
                           i, j
                         is set to min {c(ai
                        ), c(aj
                        )} × d(S
                        0), where 
                           
                              
                                 S
                                 0
                              
                              =
                              
                                 {
                                 s
                                 ∈
                                 Q
                                 |
                              
                              
                                 (
                                 
                                    a
                                    i
                                 
                                 
                                    (
                                    s
                                    )
                                 
                                 ,
                                 
                                    a
                                    j
                                 
                                 
                                    (
                                    s
                                    )
                                 
                                 )
                              
                              =
                           
                         ( ·, · ) }, which can be observed from Table 6.


                        Case 4: 
                           
                              
                                 a
                                 i
                              
                              ∈
                              o
                              
                                 (
                                 E
                                 )
                              
                              −
                              F
                           
                         and 
                           
                              
                                 a
                                 j
                              
                              ∈
                              o
                              
                                 (
                                 B
                                 )
                              
                              −
                              F
                           
                        . This case is the same as Case 3.

A valid lower bound to the future cost (i.e., the value of lower(B, Q, E)) can be obtained by solving the following linear programming model:

                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             
                                                (
                                                L
                                                B
                                                )
                                             
                                             
                                             
                                             
                                                z
                                                
                                                   L
                                                   B
                                                
                                             
                                             =
                                          
                                       
                                       
                                          
                                             min
                                             
                                             
                                             
                                                ∑
                                                
                                                   
                                                      a
                                                      i
                                                   
                                                   ∈
                                                   
                                                      A
                                                      N
                                                      ′
                                                   
                                                
                                             
                                             
                                                x
                                                i
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                          
                                             
                                             
                                                x
                                                i
                                             
                                             +
                                             
                                                x
                                                j
                                             
                                             ≥
                                             
                                                c
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                             
                                             ,
                                             
                                             ∀
                                             
                                             
                                                a
                                                i
                                             
                                             ,
                                             
                                                a
                                                j
                                             
                                             ∈
                                             
                                                A
                                                N
                                                ′
                                             
                                             ,
                                             i
                                             ≠
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                x
                                                i
                                             
                                             ≥
                                             0
                                             ,
                                             
                                             ∀
                                             
                                             
                                                a
                                                i
                                             
                                             ∈
                                             
                                                A
                                                N
                                                ′
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The value of zLB
                         must be a valid lower bound to 
                           
                              
                                 min
                                 σ
                              
                              
                                 {
                                 
                                    ∑
                                    
                                       i
                                       ∈
                                       
                                          A
                                          N
                                       
                                    
                                 
                                 
                                    x
                                    i
                                 
                                 }
                              
                           
                        . If the daily holding cost of actor ai
                         is an integral number, decision variable xi
                         should be integer. When all variables xi
                         are integers, the model (LB) is an NP-hard problem since it can be easily reduced to the minimum vertex cover problem (Karp, 1972). If all variables xi
                         are treated as real numbers, this model can be solved by a liner programming solver. For some instances, the (LB) model needs to be solved a very large number of times. To save computation time, we apply the following two heuristic approaches to rapidly produce two lower bounds, i.e., L
                        1 and L
                        2, to zLB
                        . Obviously, L
                        1 and L
                        2 are also valid lower bounds to the future cost.


                        Approach 1: Sum up the left-hand-side and righ-hand-side of Eq. (19), generating 
                           
                              
                                 (
                                 |
                              
                              
                                 A
                                 N
                                 ′
                              
                              
                                 |
                                 −
                                 1
                                 )
                              
                              
                                 ∑
                                 
                                    
                                       a
                                       i
                                    
                                    ∈
                                    
                                       A
                                       N
                                       ′
                                    
                                 
                              
                              
                                 x
                                 i
                              
                              ≥
                              
                                 ∑
                                 
                                    
                                       a
                                       i
                                    
                                    ,
                                    
                                       a
                                       j
                                    
                                    ∈
                                    
                                       A
                                       N
                                       ′
                                    
                                    ,
                                    i
                                    ≠
                                    j
                                 
                              
                              
                                 c
                                 
                                    i
                                    ,
                                    j
                                 
                              
                           
                        . The valid lower bound L
                        1 is defined as:

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                L
                                                1
                                             
                                             =
                                             
                                                ∑
                                                
                                                   
                                                      a
                                                      i
                                                   
                                                   ,
                                                   
                                                      a
                                                      j
                                                   
                                                   ∈
                                                   
                                                      A
                                                      N
                                                      ′
                                                   
                                                   ,
                                                   i
                                                   ≠
                                                   j
                                                
                                             
                                             
                                                c
                                                
                                                   i
                                                   ,
                                                   j
                                                
                                             
                                             /
                                             
                                                (
                                                |
                                             
                                             
                                                A
                                                N
                                                ′
                                             
                                             
                                                |
                                                −
                                                1
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Approach 2: Sort c
                        
                           i, j
                         in descending order. If we select a c
                        
                           i, j
                        , we call the corresponding xi
                         and xj marked. Beginning from the largest c
                        
                           i, j
                        , we select all c
                        
                           i, j
                         whose xi
                         and xj
                         are not marked until all xi
                         are marked. The valid lower bound L
                        2 equals the sum of all selected c
                        
                           i, j
                        . This approach was termed the greedy matching algorithm (Drake & Hougardy, 2003). To demonstrate the process of computing L
                        2, we consider the following six constraints:

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                x
                                                1
                                             
                                             +
                                             
                                                x
                                                2
                                             
                                             ≥
                                             2
                                             ,
                                             
                                             
                                                x
                                                1
                                             
                                             +
                                             
                                                x
                                                3
                                             
                                             ≥
                                             7
                                             ,
                                             
                                             
                                                x
                                                1
                                             
                                             +
                                             
                                                x
                                                4
                                             
                                             ≥
                                             6
                                             ,
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                x
                                                2
                                             
                                             +
                                             
                                                x
                                                3
                                             
                                             ≥
                                             12
                                             ,
                                             
                                             
                                                x
                                                2
                                             
                                             +
                                             
                                                x
                                                4
                                             
                                             ≥
                                             8
                                             ,
                                             
                                             
                                                x
                                                3
                                             
                                             +
                                             
                                                x
                                                4
                                             
                                             ≥
                                             5
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        We first select 
                           
                              
                                 c
                                 
                                    2
                                    ,
                                    3
                                 
                              
                              =
                              12
                           
                         and mark x
                        2 and x
                        3. Then, we can only select 
                           
                              
                                 c
                                 
                                    1
                                    ,
                                    4
                                 
                              
                              =
                              6
                           
                         since x
                        1 and x
                        4 have not been marked. Now all xi
                         are marked and the value of L
                        2 equals 18.

In our algorithm, we set lower(B, Q, E) = max {L
                        0, L
                        1, L
                        2}.

In de la Banda et al. (2011), the talent scheduling problem was solved by a double-ended dynamic programming (DP) algorithm, where a DP state is represented by ⟨B, E⟩. The DP algorithm stores the best value of each examined state, denoted by 〈B, E〉.value, which equals the minimum past cost of all search paths associated with sets B and E.

We embed this DP process in our branch-and-bound framework by use of memoization technique (Michie, 1968). More precisely, when the search process reaches a tree node 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                              ,
                           
                         it first checks whether the value of 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         is less than the current 〈B, E〉.value. If so, it updates 〈B, E〉.value by 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                        ; otherwise, the current node must be dominated by some node and therefore can be safely discarded.

A better state representation for the DP algorithm is ⟨o(B), o(E), Q⟩, where 
                           
                              Q
                              =
                              S
                              −
                              B
                              −
                              E
                           
                        ; this was discussed by de la Banda et al. (2011) as follows. The cost of scheduling the scenes in 
                           
                              Q
                              =
                              S
                              −
                              B
                              −
                              E
                           
                         depends on o(B) and o(E) rather than B and E. Suppose 
                           
                              
                                 B
                                 →
                              
                              
                                 Q
                                 →
                              
                              
                                 E
                                 →
                              
                           
                         and 
                           
                              
                                 
                                    B
                                    ′
                                 
                                 →
                              
                              
                                 Q
                                 →
                              
                              
                                 
                                    E
                                    ′
                                 
                                 →
                              
                           
                         are two permutations of S, where B, Q, E, B′ and E′ are the corresponding sets of scenes. If 
                           
                              o
                              
                                 (
                                 B
                                 )
                              
                              =
                              o
                              
                                 (
                                 
                                    B
                                    ′
                                 
                                 )
                              
                           
                         and 
                           
                              o
                              
                                 (
                                 E
                                 )
                              
                              =
                              o
                              
                                 (
                                 
                                    E
                                    ′
                                 
                                 )
                              
                              ,
                           
                         then the holding costs incurred by 
                           
                              Q
                              →
                           
                         in these two permutations are equal. Moreover, if there are two states ⟨o(B), o(E), Q⟩ and ⟨o(B′), o(E′), Q⟩ that have 
                           
                              o
                              
                                 (
                                 B
                                 )
                              
                              =
                              o
                              
                                 (
                                 
                                    E
                                    ′
                                 
                                 )
                              
                           
                         and 
                           
                              o
                              
                                 (
                                 E
                                 )
                              
                              =
                              o
                              
                                 (
                                 
                                    B
                                    ′
                                 
                                 )
                              
                              ,
                           
                         they are equivalent due to the symmetric property of the problem. Thus, we only need to memoize the state ⟨o(B), o(E), Q⟩ that satisfies o(B) ≤ o(E). We compare o(B) with o(E) based on the lexicographical order of the actor indices. For example, given 
                           
                              o
                              
                                 (
                                 B
                                 )
                              
                              =
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    2
                                 
                                 ,
                                 
                                    a
                                    4
                                 
                                 ,
                                 
                                    a
                                    5
                                 
                                 }
                              
                           
                         and 
                           
                              o
                              
                                 (
                                 E
                                 )
                              
                              =
                              
                                 {
                                 
                                    a
                                    1
                                 
                                 ,
                                 
                                    a
                                    3
                                 
                                 ,
                                 
                                    a
                                    6
                                 
                                 ,
                                 
                                    a
                                    7
                                 
                                 }
                              
                              ,
                           
                         we have o(B) ≤ o(E) since the index of a
                        2 is less than that of a
                        3.

We also use the memoization technique to prune the search tree node. The process of checking whether a given node associated with problem 
                           
                              P
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         can be pruned is depicted in Algorithm 2
                        . All states are stored in a hash table hashTable. This algorithm first designates a storage slot in the hash table for state ⟨o(B), o(E), Q⟩ using function hash(
                        o(B), o(E), Q
                        ). This hash function is used to map the search key to an index; the index gives the place in the hash table where the corresponding record should be stored. First, we transform our state to a search key. Let us consider an example with four actors and five scenes. If 
                           
                              (
                              o
                              (
                              B
                              )
                              ,
                              o
                              (
                              E
                              )
                              ,
                              Q
                              )
                              =
                              (
                              {
                              1
                              ,
                              3
                              ,
                              4
                              }
                              ,
                              {
                              2
                              ,
                              4
                              }
                              ,
                              {
                              1
                              ,
                              2
                              ,
                              3
                              ,
                              4
                              }
                              )
                              ,
                           
                         its binary code (i.e., search key) is 1011010111110, where {1, 3, 4}, {2, 4} and {1, 2, 3, 4} correspond to 1011, 0101 and 11110, respectively. Note that o(B) and o(E) are two sets of actors and Q is a set of scenes. Second, we get the corresponding decimal number of the binary code. Third, we calculate “the decimal number mod C”, where C is the number of storage slots, to obtain the index of the storage space. In each storage space, a value is stored.

If the storage slot contains the state and the current value of the state is less than or equal to 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                              ,
                           
                         the algorithm returns true, implying that the given node can be pruned (see lines 4–5, Algorithm 2). Next, it checks whether the state 
                           
                              〈
                              o
                              (
                              B
                              )
                              ,
                              o
                              (
                              E
                              )
                              ,
                              Q
                              −
                              {
                              s
                              }
                              〉
                           
                         (s ∈ Q) exists in the hash table and has a value less than or equal to 
                           
                              c
                              o
                              s
                              t
                              (
                              
                                 B
                                 →
                              
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         (see lines 7–12, Algorithm 2). If such state exists, the given node can also be pruned. The correctness of this pruning condition is guaranteed by Property 1, which was derived from the second theorem in de la Banda et al. (2011).

                           Property 1
                           Suppose 
                                 
                                    
                                       B
                                       →
                                    
                                    
                                       Q
                                       →
                                    
                                    
                                       E
                                       →
                                    
                                 
                               and 
                                 
                                    
                                       
                                          B
                                          ′
                                       
                                       →
                                    
                                    
                                       
                                          Q
                                          ′
                                       
                                       →
                                    
                                    
                                       
                                          E
                                          ′
                                       
                                       →
                                    
                                 
                               are two permutations of S, where B, Q, E, B′, Q′ and E′ are the corresponding sets of scenes. If 
                                 
                                    o
                                    
                                       (
                                       B
                                       )
                                    
                                    =
                                    o
                                    
                                       (
                                       
                                          B
                                          ′
                                       
                                       )
                                    
                                    ,
                                 
                              
                              
                                 
                                    o
                                    
                                       (
                                       E
                                       )
                                    
                                    =
                                    o
                                    
                                       (
                                       
                                          E
                                          ′
                                       
                                       )
                                    
                                    ,
                                 
                               
                              Q⊆Q′ and the scenes in 
                                 
                                    Q
                                    →
                                 
                               follow the order in which they appear in 
                                 
                                    
                                       
                                          Q
                                          ′
                                       
                                       →
                                    
                                    ,
                                 
                               then the holding cost incurred by 
                                 
                                    Q
                                    →
                                 
                               is not greater than that incurred by 
                                 
                                    
                                       Q
                                       ′
                                    
                                    →
                                 
                              .

Ideally, the hash function should assign each state to a unique storage slot, i.e., no hash collisions happen. However, this ideal situation is rarely achievable due to the huge number of states and the inadequate storage space. When solving the talent scheduling problem, we do not have sufficient storage space to store the exponential number of search states and therefore different states may be assigned by the hash function to the same storage slot, leading to hash collisions. To resolve this issue, we employ a mechanism called direct mapped caching scheme. Assume the direct mapped cache consists of C slots, each of which can only store one item. If an item is to be stored in a slot that already contains another item (i.e., a hash collision occurs), it may either replace the existing item or be discarded, which is decided by function replace(index, pc). Several previous articles, such as Hilden (1976) and Pugh (1988), have discussed the replacement strategies implemented in replace(index, pc). In this work, we tried latest and greedy caching strategies. The first strategy deals with the hash collisions by simply overwriting the cache slot while the second one stores in the cache slot the item that has smaller value. If we choose the latest caching strategy, replace(index, pc) always returns true. If the greedy caching strategy is selected and the new state has a value less than that of the existing state, replace(index, pc) returns true.

The direct mapped caching scheme can effectively prune the search nodes using limited storage space. When a state is revisited again but it has been removed from the cache during the previous stages, the search can still continue to explore its corresponding subtree. In Section 4, we experimentally analyze the impact of different values of C and the two replacement strategies on the performance of our branch-and-bound algorithm.

Dominance rules were widely used in branch-and-bound algorithms (Braune, Zäpfel, & Affenzeller, 2012; Kellegöz & Toklu, 2012; Ranjbar, Davari, & Leus, 2012; Zhang, Qin, Zhu, & Lim, 2012) and dynamic programming algorithms (Dumas, Desrosiers, Gelinas, & Solomon, 1995; Mingozzi, Bianco, & Ricciardelli, 1997; Rong & Figueira, 2013) for eliminating search states. The purpose of dominance rules is to identify the partial solution represented by a node in the search tree that is dominated by another partial solution. The dominated partial solution need not be further explored and can be safely pruned. In our branch-and-bound algorithm, two new dominance rules are introduced to reduce the search space.

At a branch-and-bound tree node associated with problem 
                              
                                 P
                                 (
                                 
                                    B
                                    →
                                 
                                 ,
                                 Q
                                 ,
                                 
                                    E
                                    →
                                 
                                 )
                                 ,
                              
                            we suppose that scene s
                           1 is the scene to be scheduled immediately after B and scene s
                           2 belongs to 
                              
                                 Q
                                 −
                                 {
                                 
                                    s
                                    1
                                 
                                 }
                              
                           . If a(s
                           1) ∪ o(B) ⊇ a(s
                           2) ∪ o(B) and a(s
                           1) ∪ o(E) ⊆ a(s
                           2) ∪ o(E), then the branch associated with scene s
                           1 can be ignored.


                           Tables 7
                            and 8
                           
                            are used to explain this dominance rule. In Table 7, 
                              
                                 Q
                                 =
                                 
                                    {
                                    
                                       s
                                       1
                                    
                                    ,
                                    
                                       s
                                       2
                                    
                                    }
                                 
                                 ∪
                                 
                                    Ω
                                    1
                                 
                                 ∪
                                 
                                    Ω
                                    2
                                 
                                 ,
                              
                            where Ω
                           1 and Ω
                           2 are two arbitrary subsets of 
                              
                                 Q
                                 −
                                 {
                                 
                                    s
                                    1
                                 
                                 ,
                                 
                                    s
                                    2
                                 
                                 }
                              
                            and 
                              
                                 
                                    Ω
                                    1
                                 
                                 ∩
                                 
                                    Ω
                                    2
                                 
                                 =
                                 ∅
                              
                           . Actors in AN
                            can be classified into twelve patterns according to whether they are required by the scenes in sets B, E, {s
                           1} and {s
                           2}. Since we do not need the information related to Ω
                           1 and Ω
                           2, all cells in columns 4 and 6 remain empty. Similar to Table 3, the numbers 1 and 0 in the right part of Table 7 indicate whether an actor is included in the corresponding actor set.

In the absence of the information in columns 4 and 6, we cannot directly judge whether pattern 4 actors are included in o(B) and whether pattern 8 actors are included in o(E). However, we know that all remaining actors are non-fixed and must be required by the scenes in Q. In other words, if some pattern 4 and 8 actors are kept in AN
                           , then they must be required by some scene in Ω
                           1 ∪ Ω
                           2. Therefore, we fill the corresponding cells with “1” (see the numbers in bold in Table 7).

We list in the left part of Table 8 all actor patterns that satisfy the conditions a(s
                           1) ∪ o(B)⊇a(s
                           2) ∪ o(B) and a(s
                           1) ∪ o(E)⊆a(s
                           2) ∪ o(E). Table 8 shows that branching to scene s
                           1 is dominated by branching to scene s
                           2. After exchanging the positions of scenes s
                           1 and s
                           2, the holding costs for pattern 1, 4–5, 8–9 and 12 actors remain unchanged while the holding costs for pattern 3 and 6 actors are probably reduced. Thus, scheduling scene s
                           2 immediately after B must result in less or equal holding cost than scheduling scene s
                           1 at that position.

At a branch-and-bound tree node associated with problem 
                              
                                 P
                                 (
                                 
                                    B
                                    →
                                 
                                 ,
                                 Q
                                 ,
                                 
                                    E
                                    →
                                 
                                 )
                                 ,
                              
                            we suppose that s
                           1 is the scene to be scheduled immediately after B and s
                           2 belongs to 
                              
                                 Q
                                 −
                                 {
                                 
                                    s
                                    1
                                 
                                 }
                              
                           . If a(s
                           1) ∪ o(B)⊇a(s
                           2) ∪ o(B) and 
                              
                                 c
                                 
                                    (
                                    
                                       (
                                       a
                                       
                                          (
                                          
                                             s
                                             1
                                          
                                          )
                                       
                                       ∪
                                       o
                                       
                                          (
                                          B
                                          )
                                       
                                       )
                                    
                                    ∩
                                    
                                       (
                                       a
                                       
                                          (
                                          
                                             s
                                             2
                                          
                                          )
                                       
                                       ∪
                                       o
                                       
                                          (
                                          E
                                          )
                                       
                                       )
                                    
                                    )
                                 
                                 −
                                 c
                                 
                                    (
                                    a
                                    
                                       (
                                       
                                          s
                                          2
                                       
                                       )
                                    
                                    ∪
                                    o
                                    
                                       (
                                       B
                                       )
                                    
                                    )
                                 
                                 >
                                 0
                                 ,
                              
                            then the branch associated with scene s
                           1 can be ignored.
                        

We list in the left part of Table 9 all actor patterns that satisfy the conditions a(s
                           1) ∪ o(B)⊇a(s
                           2) ∪ o(B). The right part of Table 9 is the result of shifting scene s
                           2 immediately before scene s
                           1 and immediately after B. From Table 9, we can get the following four observations: (1) the holding costs for pattern 5 actors remain unchanged; (2) the holding costs for pattern 1, 3, 8–10 and 12 actors are probably reduced; (3) the holding cost of each actor ai
                            with pattern 2 or 4 is probably increased by c(ai
                           )d(s
                           2); (4) the holding cost of each pattern 6 actor ai
                            is definitely decreased by c(ai
                           )d(s
                           2). If the decreased amount (related to pattern 6 actors) is greater than the increased amount (related to pattern 2 and 4 actors), then shifting scene s
                           2 immediately before scene s
                           1 must lead to a cost reduction. Given that a(s
                           1) ∪ o(B)⊇a(s
                           2) ∪ o(B) is satisfied, the set a(s
                           1) ∪ o(B)) ∩ (a(s
                           2) ∪ o(E) includes pattern 1, 3, 5–6 and 9 actors and the set a(s
                           2) ∪ o(B) includes patterns 1–5, and 9 actors. This means both a(s
                           1) ∪ o(B)) ∩ (a(s
                           2) ∪ o(E) and a(s
                           2) ∪ o(B) include pattern 1, 3, 5, 9 actors. So we can derive that 
                              
                                 c
                                 
                                    (
                                    
                                       (
                                       a
                                       
                                          (
                                          
                                             s
                                             1
                                          
                                          )
                                       
                                       ∪
                                       o
                                       
                                          (
                                          B
                                          )
                                       
                                       )
                                    
                                    ∩
                                    
                                       (
                                       a
                                       
                                          (
                                          
                                             s
                                             2
                                          
                                          )
                                       
                                       ∪
                                       o
                                       
                                          (
                                          E
                                          )
                                       
                                       )
                                    
                                    )
                                 
                                 −
                                 c
                                 
                                    (
                                    a
                                    
                                       (
                                       
                                          s
                                          2
                                       
                                       )
                                    
                                    ∪
                                    o
                                    
                                       (
                                       B
                                       )
                                    
                                    )
                                 
                              
                            is equal to the cost of all pattern 6 actors minus the cost of all pattern 2 and 4 actors. Thus, if a(s
                           1) ∪ o(B)⊇a(s
                           2) ∪ o(B) and 
                              
                                 c
                                 
                                    (
                                    
                                       (
                                       a
                                       
                                          (
                                          
                                             s
                                             1
                                          
                                          )
                                       
                                       ∪
                                       o
                                       
                                          (
                                          B
                                          )
                                       
                                       )
                                    
                                    ∩
                                    
                                       (
                                       a
                                       
                                          (
                                          
                                             s
                                             2
                                          
                                          )
                                       
                                       ∪
                                       o
                                       
                                          (
                                          E
                                          )
                                       
                                       )
                                    
                                    )
                                 
                                 −
                                 c
                                 
                                    (
                                    a
                                    
                                       (
                                       
                                          s
                                          2
                                       
                                       )
                                    
                                    ∪
                                    o
                                    
                                       (
                                       B
                                       )
                                    
                                    )
                                 
                                 >
                                 0
                                 ,
                              
                            scheduling scene s
                           2 immediately after B must result in less or equal holding cost than scheduling scene s
                           1 at that position.

Our enhanced branch-and-bound algorithm for the talent scheduling problem is given by Algorithm 3
                        , where the value of past cost z is initialized to zero at the root node. The preprocessing stage is realized by function 
                           
                              preprocess
                              (
                              Q
                              ,
                              
                                 A
                                 N
                              
                              )
                           
                         (see line 9, Algorithm 3). The state caching technique is adopted through function 
                           
                              check
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              )
                           
                         (see line 10, Algorithm 3), where the details of this function is described in Algorithm 2. The function isDominated
                        
                           
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              ,
                              
                                 A
                                 N
                              
                              ,
                              z
                              ,
                              s
                              )
                           
                         employs the proposed two dominance rules to check whether branching to some scene s is dominated by other branches. In function isDominated
                        
                           
                              (
                              
                                 B
                                 →
                              
                              ,
                              Q
                              ,
                              
                                 E
                                 →
                              
                              ,
                              
                                 A
                                 N
                              
                              ,
                              z
                              ,
                              s
                              )
                              ,
                           
                         we check in turn whether s can be dominated by the scene in 
                           
                              Q
                              −
                              {
                              s
                              }
                           
                        . If scene s can be dominated, then this function returns true and thus the corresponding node can be eliminated. The function lower
                        
                           
                              (
                              B
                              ∪
                              {
                              s
                              }
                              ,
                              Q
                              −
                              {
                              s
                              }
                              ,
                              E
                              )
                           
                         returns a valid lower bound to the future cost of the problem at some search node.

Our algorithm was coded in C++ and compiled using the g++ compiler. All experiments were run on a Linux server equipped with an Intel Xeon E5430 CPU clocked at 2.66 gigahertz and 8 gigabytes RAM. The algorithm only has two parameters, namely the number (C) of cached states and the caching strategy used. After some preliminary experiments, we set 
                        
                           C
                           =
                           
                              2
                              25
                           
                        
                      and chose the greedy caching strategy when solving the benchmark instances. In this section, we first present our results for the benchmark instances and then compare them with the results obtained by the best two existing approaches. Finally, we exhibit by experiments the impacts of the parameters on the overall performance of the algorithm. All computation times reported here are in CPU seconds on this server. All instances and detailed results are available in the online supplement to this paper at: http://www.tigerqin.com/publicatoins/talent-scheduling-problem.
                     
                     
                  

In order to evaluate our algorithm, we conducted experiments using two benchmark data sets (Types 1 and 2), downloaded from http://people.eng.unimelb.edu.au/pstuckey/talent/. The Type 1 data set was introduced by Cheng et al. (1993) and Smith (2005), including seven instances, namely MobStory, film103, film105, film114, film117, film118 and film119. Since these instances have small sizes, ranging from 18 × 8 (18 scenes by 8 actors) to 28 × 8, they were easily solved to optimality. Table 10 shows the results obtained by our branch-and-bound algorithm, the constraint programming approach in Smith (2005) and the dynamic programming algorithm in de la Banda et al. (2011). From this table, we can see that our algorithm reduced the number of subproblems significantly for each instance with much less computational efforts. In our branch-and-bound algorithm, a subproblem corresponds to a search tree node. Note that the results taken from Smith (2005) were produced on a PC with 1.7 gigahertz Pentium M processor, and the results from de la Banda et al. (2011) were produced on a machine with Xeon Pro 2.4 gigahertz processors and 2 gigabytes RAM.

The Type 2 data set was provided by de la Banda et al. (2011). Following a manner almost identical to that used by Cheng et al. (1993), de la Banda et al. (2011) randomly generated 100 instances for each combination of 
                           
                              n
                              ∈
                              {
                              16
                              ,
                              18
                              ,
                              20
                              ,
                              …
                              ,
                              64
                              }
                           
                         and 
                           
                              m
                              ∈
                              {
                              8
                              ,
                              10
                              ,
                              12
                              ,
                              …
                              ,
                              22
                              }
                              ,
                           
                         for a total of 200 instance groups and 20,000 instances. They tried to solve these instances using their dynamic programming algorithm with a memory bound of 2 gigabytes. For each instance, if the execution did not run out of memory, they recorded the running time and the number of subproblems generated. They reported the average running time and the average number of subproblems for each Type 2 instance group with more than 80 optimally solved instances; these two average values were computed based on the optimally solved instances.
                     

We tried to solve all Type 2 instances using our branch-and-bound algorithm with a time limit of 10 minutes and a memory of 2 gigabytes. Our algorithm requires some memory to store the information of the search tree and a limited number of states. The amount of memory available can fully satisfy this requirement and thus the out-of-memory exception did not occur. Table 11 gives the number of instances optimally solved in each Type 2 instance group, where an underline sign (“_”) is added to the cell associated with the instance group with less than 80 optimally solved instances. For an instance group, if our algorithm optimally solved 80 or more instances while the dynamic programming algorithm failed to achieve so, the number in its corresponding cell is marked with an asterisk (*). From this table, we can see that our algorithm managed to optimally solve all instances with the number of scenes (n) not greater than 32 or the number of actors (m) not greater than 10. However, the dynamic programming algorithm by de la Banda et al. (2011) only optimally solved more than 80 out of 100 instances for the instance groups with n ≤ 26. Their approach even did not optimally solve all instances with 
                           
                              m
                              =
                              8
                           
                         and 
                           
                              n
                              =
                              64
                           
                        . In this table, 89 out of 200 instance groups are marked with asterisks, which clearly indicates that more Type 2 benchmark instances were successfully solved to optimality by our branch-and-bound algorithm. Although our machine is slightly more powerful, this cannot account for the dramatic difference in the number of optimally solved instances, it is reasonable to conclude that our branch-and-bound algorithm is more efficient than the dynamic programming algorithm.


                        Tables 12–13 show the average running time and the average number of search nodes, respectively, over all optimally solved instances for each instance group. Like in Table 11, the instance groups with less than 80 optimally solved instances are marked with “_”. From Table 13, we can easily find that the average number of search nodes generated for each instance group with “_” exceeds 3,000,000.
                        
                        
                        
                     

To further compare our results with those reported by de la Banda et al. (2011), we pictorially show in Fig. 1 the ratio of the average number of subproblems (i.e., search nodes) generated by our algorithm to that generated by the dynamic programming algorithm. Each point in these curves corresponds to an instance group whose average number of subproblems was reported by de la Banda et al. (2011). On average, the number of subproblems generated by our algorithm is less than 22 percent of that generated by the dynamic programming algorithm, which should be attributed to the use of the new lower bound and domination rules. Moreover, we can observe some trends from these curves. The ratio first decreases as the number of scenes increases, which implies that our algorithm can eliminate more subproblems. Then, the ratio increases with the number of scenes. This is because hash collisions happened more frequently, reducing the opportunities of pruning search nodes and therefore increasing the number of subproblems.

We take the value of C from {0, 25, 210, 215, 220, 225}, where 
                           
                              C
                              =
                              0
                           
                         means that cache is not used. Considering the two caching strategies, we have 12 parameter combinations in total. We tested these 12 parameter combinations using a portion of the Type 2 instances. Specifically, the first 5 instances were selected from each instance group, for a total of 1000 instances. We also imposed a time limit of 10 minutes on each execution of our algorithm. The results of those optimally solved instances were recorded for analysis.
                        
                     


                        Fig. 2 illustrates the number of optimally solved instances under each parameter setting. This figure shows that more caching states lead to more optimally solved instances under both caching strategies. Under the latest caching strategy, the number of instances optimally solved increases from 854 (
                           
                              C
                              =
                              0
                           
                        ) to 922 (
                           
                              C
                              =
                              
                                 2
                                 25
                              
                           
                        ). Under the greedy caching strategy, this number increases from 854 to 939. When C is relatively small (e.g., C ≤ 215), hash collisions occur frequently and the latest caching strategy leads to slightly better performance than the greedy caching strategy. The greedy caching strategy may store more states associated with the subproblems at the early level of the search tree, which cannot be used to effectively prune the nodes. We conjecture that since the latest caching strategy stores the newly encountered states and a certain state is revisited in short period with high probability, the pruning can occur with more opportunities and then the number of subproblems is reduced. When C is large (e.g., C ≥ 220), the greedy caching strategy leads to more optimally solved instances than the latest caching strategy. This may be because a smaller state value in the caching slot is likely to eliminate more subproblems during the search process.

To further test the impacts of different parameter settings on the average number of subproblems generated, we selected five Type 2 instance groups, namely 40 × 18, 46 × 16, 52 × 14, 58 × 12 and 64 × 10. All instances in these five groups can be optimally solved using our branch-and-bound algorithm within 10 minutes of running time. We pictorially show the results associated with some parameter settings in Fig. 3. We can clearly observe that the average number of subproblems generated decreases as the number of cached states increases. This is in accordance with our intuition since more cache slots store more states, which helps prune more search nodes and therefore reduces the number of subproblems. This figure also reveals that the greedy caching strategy outperforms the latest caching strategy in terms of the average number of subproblems generated when 
                           
                              C
                              =
                              
                                 2
                                 20
                              
                           
                         or 
                           
                              C
                              =
                              
                                 2
                                 25
                              
                              ,
                           
                         while the latest caching strategy generally generates fewer subproblems when C is small, i.e., 
                           
                              C
                              =
                              
                                 2
                                 10
                              
                           
                         or 
                           
                              C
                              =
                              
                                 2
                                 15
                              
                           
                        . As a result, we adopted the greedy caching strategy and 
                           
                              C
                              =
                              
                                 2
                                 25
                              
                           
                         in the final implementation of our branch-and-bound algorithm.

We studied the impacts of the new lower bounds and the dominance rules by removing one type of component in turn and executing the resulting algorithm on the 1000 selected instances used in the previous section. Therefore, we have four versions of the branch-and-bound algorithm, which are:

                           
                              1.
                              B&B1 that uses only the lower bound from de la Banda et al. (2011) and does not include the dominance rules;

B&B2 that uses both the lower bound from de la Banda et al. (2011) and our newly proposed lower bounds, but does not include the dominance rules;

B&B3 that uses only the lower bound from de la Banda et al. (2011) and includes the dominance rules;

B&B4 that uses the lower bound from de la Banda et al. (2011), our newly proposed lower bounds and the dominance rules.

The computational results are presented in Tables 14–15, where the numbers of instances optimally solved by B&B1 – B&B4 are 561, 625, 895 and 938, respectively. These results imply that the introduction of the dominance rules and the newly proposed lower bounds increases the performance of the branch-and-bound algorithm significantly. Obviously, compared with the new lower bounds, the dominance rules contribute more for the better performance of the enhanced branch-and-bound algorithm.

Finally, we generated some new instances and evaluated the impacts of the distributions of “X”. The instance generation procedure is described as follows:

                           
                              1.
                              The first 5 instances are selected from each instance group provided by de la Banda et al. (2011), for a total of 1000 instances.

The values of d(sj
                                 ) and c(ai
                                 ) and the number (ni
                                 ) of scenes that require actor ai
                                  in each new instance are the same as those in its corresponding instance generated by de la Banda et al. (2011).

We generate ni
                                  random numbers between 1 and n using Binomial (p = 0.3) and Poisson (
                                    
                                       λ
                                       =
                                       ⌈
                                       n
                                       ⌉
                                    
                                 ) random number generators. These numbers indicate the set of scenes in which actor ai
                                  is in. If the random number generator generates a number that has already been included in the set, we discard it and generate another one until ni
                                  different numbers are generated. That is, we generate two new instances from each of the selected instance, for a total of 2000 new instances.

From these new instances, we observe that an actor usually participates in a set of consecutive scenes. In Tables 16–17, we present an example generated by de la Banda et al. (2011) and a new instance generated using the Binomial (p = 0.3) random number generator. Experimental results shown in Table 18
                         reveal that our enhanced branch-and-bound algorithm can handle these new instances very efficiently. All these 2,000 instances have been optimally solved within several seconds.

@&#CONCLUSIONS@&#

In this paper, we proposed an enhanced branch-and-bound algorithm to solve the talent scheduling problem, which is a very challenging combinatorial optimization problem. This algorithm uses a new lower bound and two new dominance rules to prune the search nodes. In addition, it caches search states for the purpose of eliminating search nodes. The experimental results clearly show that our algorithm outperforms the current best approach and achieved the optimal solutions for considerably more benchmark instances.

We present a mixed integer linear programming model for the talent scheduling problem in Section 2. A possible future research direction is to design mathematical programming algorithms for the talent scheduling problem, such as branch-and-cut algorithm and branch-and-bound coupled with Lagrangian relaxation and sub-gradient methods.

@&#ACKNOWLEDGMENTS@&#

The research was partially supported by the National Natural Science Foundation of China (Grant No. 71571077, 71320107001) and Guangdong Natural Science Funds (No. 2014A030310312). A preliminary version of this paper appeared in the Proceedings of the 27th International Conference on Industrial, Engineering and Other Applications of Applied Intelligent Systems (IEA-AIE 2014).

@&#REFERENCES@&#

