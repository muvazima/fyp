@&#MAIN-TITLE@&#An adaptive large neighborhood search algorithm for a selective and periodic inventory routing problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We consider a Selective Periodic Inventory Routing problem (SPIRP).


                        
                        
                           
                           It is about the logistics of waste vegetable oil collection for biodiesel production.


                        
                        
                           
                           Partial collection of waste oil accumulating at the source nodes is not permitted.


                        
                        
                           
                           A periodic weekly routing schedule is generated to satisfy production requirements.


                        
                        
                           
                           We propose an Adaptive Large Neighborhood Search algorithm (ALNS) for SPIRP.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Routing

Periodic inventory routing

Adaptive large neighborhood search

Waste vegetable oil collection

@&#ABSTRACT@&#


               
               
                  We study a selective and periodic inventory routing problem (SPIRP) and develop an Adaptive Large Neighborhood Search (ALNS) algorithm for its solution. The problem concerns a biodiesel production facility collecting used vegetable oil from sources, such as restaurants, catering companies and hotels that produce waste vegetable oil in considerable amounts. The facility reuses the collected waste oil as raw material to produce biodiesel. It has to meet certain raw material requirements either from daily collection, or from its inventory, or by purchasing virgin oil. SPIRP involves decisions about which of the present source nodes to include in the collection program, and which periodic (weekly) routing schedule to repeat over an infinite planning horizon. The objective is to minimize the total collection, inventory and purchasing costs while meeting the raw material requirements and operational constraints. A single-commodity flow-based mixed integer linear programming (MILP) model was proposed for this problem in an earlier study. The model was solved with 25 source nodes on a 7-day cyclic planning horizon. In order to tackle larger instances, we develop an ALNS algorithm that is based on a rich neighborhood structure with 11 distinct moves tailored to this problem. We demonstrate the performance of the ALNS, and compare it with the MILP model on test instances containing up to 100 source nodes.
               
            

@&#INTRODUCTION@&#

Recovery and reuse of waste and end-of-life products provide significant environmental and economic benefits. While collection of recoverable material from various sources can be costly for a processing facility, efficient management of the collection operations may determine the economic viability of the recovery operations. In this study, we consider a facility that collects and processes waste vegetable oil for reuse as raw material, and thus needs an effective periodic collection plan. The problem originates from a case study about a company in Istanbul that collects waste vegetable oil from different locations in the city to use the oil in biodiesel production (see Aksen, Kaya, Salman, & Akça (2012)). Biodiesel, which is a nontoxic and biodegradable alternative fuel, is a substitute for petroleum. While the cost of virgin oil used in the production of biodiesel constitutes 85% of the total production cost, Gonzalez, Encinar, and Rodriguez-Reinares (2005) and Predojević (2008) state that collecting and using waste vegetable oil costs almost half the price of using virgin vegetable oil.

The source nodes for the collection of waste vegetable oil include businesses that consume cooking oil in large volumes, such as restaurants, hotels, and catering companies. The biodiesel production facility makes an agreement with the selected source nodes, and specifies on which days of the week their accumulated waste oil will be collected. Waste oil accumulates with different rates at source nodes, and the uncollected amount is stored until the next visit of the collection vehicle. The facility has a predetermined daily production plan, and needs to procure vegetable oil as raw material input to follow the plan. This creates the daily input requirements. The facility can satisfy its vegetable oil need either by waste vegetable oil collection or by purchasing virgin oil. The latter has a much higher marginal cost, but also the former has a significant cost due to vehicle dispatching, driver wages, fuel consumption, etc. Daily vehicle routes should be determined to realize the collection at the minimum possible cost. Moreover, the amount of waste vegetable oil accumulating at the source nodes might be more than the capacity of the collection vehicle or the amount needed for production. In such cases visiting all source nodes is not necessary or not feasible. Hence, the facility manager is faced with the following threefold decision problem:
                        
                           1.
                           Which of the source nodes to select for the collection program.

How many vehicles to use each day and which periodic (weekly) routing schedule to repeat over an infinite planning horizon so as to collect the waste oil accumulating at the selected source nodes.

How much virgin oil to purchase on each day in order to meet the daily input requirements for biodiesel production.

The objective is to minimize the total collection, inventory and purchasing costs while meeting the production requirements and operational constraints. This considerably hard routing and scheduling problem has been recently defined as the Selective and Periodic Inventory Routing Problem (SPIRP) by Aksen et al. (2012) in 2012. The authors introduced a commodity flow-based mixed integer linear programming (MILP) formulation, and solved it on a real-world case with 25 hospitals treated as waste oil accumulation nodes. In this paper, we propose an Adaptive Large Neighborhood Search (ALNS) method to solve large size SPIRP instances in less than one hour. It includes a variety of move operators that are adapted to the characteristics of SPIRP. To the best of our knowledge, this is the first metaheuristic algorithm developed for SPIRP.

The rest of the paper is organized as follows. Section 2 reviews the existing literature on periodic, inventory, and selective vehicle routing problems. The definition of SPIRP and its MILP model are given in Section 3. In Section 4, we elaborate the proposed ALNS method. In Section 5, we test the ALNS method and compare its performance with that of the exact solution of the MILP model. Finally, Section 6 provides concluding remarks and discusses possible directions for future work.

@&#LITERATURE REVIEW@&#

The economic and environmental impact of recycling and remanufacturing of end-of-life products has led to a number of studies in the OR literature (see e.g. Van Wassenhove, Beullens, & Van Oudheusde (2004), Bloemhof-Ruwaard, Fleischmann, Beullens, & Van Wassenhove (2001), Antunes, de Souza, & Teixeira (2004), Zobolas, Tarantilis, Ioannou, Repoussis, & Paraskevopoulos (2009), Benjamin & Beasley (2010)). Belien, De Boeck, and Van Ackere (2011) reviewed solid waste collection problem types with a particular focus on vehicle routing problems in the literature, and give a classification of the solution methods proposed for each problem type. The periodic vehicle routing problem (PVRP) (see Francis, Smilowitz, & Tzur (2008), Christofides & Beasley (1984) and Baldacci, Bartolini, Mingozzi, & Valletta (2011)) and the inventory routing problem (IRP) (see Dror & Ball (1987), Campbell, Clarke, Kleywegt, & Savelsbergh (1998)) are two of the most related research streams to our study. The first formal definition of PVRP was made by Russell and Igo (1979) in 1979 as the “Assignment Routing Problem”. They introduced a MILP model for this problem. Christofides and Beasley (1984) defined PVRP as the generalization of vehicle routing problems over a planning horizon where each customer has a number of visit requirements over the horizon. In the literature, several variants of the PVRP have been analyzed and solved (see, among others, Cordeau, Gendreau, & Laporte (1997) for the PVRP with time windows, Hadjiconstantinou & Baldacci (1998) and Vidal, Crainic, Gendreau, Lahrichi, & Rei (2012) for the multi-depot PVRP, Angelelli & Speranza (2002) for the PVRP with intermediate facilities). Francis, Smilowitz, and Tzur (2006) extended the PVRP to make the visit frequency a decision of the problem and call it the PVRP with Service Choice (PVRP-SC). Gulczynski, Golden, and Wasil (2011) introduce practical real-world variants of the PVRP. They handle these variants with a hybrid heuristic which joins a mixed integer programming (MIP) based improvement heuristic with a modified record-to-record travel algorithm. PVRP literature admits that the problem is computationally hard. Research in this area has favored metaheuristics and mathematical programming based approaches, recognizing the need to adopt an integrated approach to the PVRP. We refer the reader to a literature review of the PVRP and its extensions which has been published in 2008 by Francis et al. (2008).

On the other hand, the IRP combines the periodic routing problem with inventory control such that customers have a daily usage rate of a product and the product must be supplied on a periodic basis before its stock depletes. In their review paper which presents the state of the art of the IRP as of 2006, Moin and Salhi (2007) explained that the inventory allocation and vehicle routing decisions are interrelated. This means that the marginal profit (revenue minus delivery cost) for each customer can be computed only if the routing cost information is available. Marginal profit information helps decide which customers to supply by how much (the inventory allocation decision). Then again, the delivery cost for each customer depends on the vehicle routes, which in turn requires information about customer selection. Hence, inventory and routing activities should be modeled simultaneously.

Heuristics have been traditionally the main tool applied in solving the IRP since the solution of moderately sized problems have been so far beyond the capability of exact methods. Earlier, Dror and Levy (1986) had adapted VRP heuristics to the solution of a weekly IRP. Anily and Federgruen (1990) had proposed the first clustering algorithm for the IRP. Clustering heuristics have been proposed more recently also by Campbell and Savelsbergh (2004). Bertazzi (2008) dealt with direct deliveries to simplify the problem. The first branch-and-cut algorithm for a single-vehicle IRP was proposed in Archetti, Bertazzi, Laporte, and Speranza (2007). Solyalı and Süral (2011) provided a stronger formulation for the problem in Archetti et al. (2007) by using shortest path networks to represent customer replenishments. Abdelmaguid, Dessouky, and Ordonez (2009) considered an IRP in which demand backlogging decisions are either unavoidable or more economical, and they have to be coordinated with other inventory holding and vehicle routing decisions over a specific planning horizon. The authors introduced constructive and improvement heuristics for solving this type of IRPs. Raa and Aghezzaf (2009) considered an IRP with deterministic constant demand rates where backlogging is prohibited. This leads to a long-term cyclic IRP involving limited storage capacities, driving time restrictions, and constant inventory replenishment intervals. The solution approach proposed for this particular IRP combines several heuristic procedures within a column generation framework. Yu, Chen, and Chu (2008) studied a multi-period IRP with split delivery, where the delivery of each customer in each period over a given planning horizon can be split and performed by multiple vehicles to reduce transportation costs. The authors worked on an approximate mathematical model of the problem whose solution only defines the quantity delivered to each customer, the quantity transported through each directed arc of the given network, and the number of times each directed arc is visited by a vehicle. This approximate model is solved using a Lagrangian relaxation method embedded in surrogate subgradient optimization procedure. Recently, Coelho and Laporte (2013) obtained the exact solution of multi-period IRPs with multiple products and multiple vehicles using a branch-and-cut algorithm.

At this point we would like to refer the interested reader to a very recent comprehensive review of the IRP literature composed by Coelho, Cordeau, and Laporte (2014). The review which covers the IRP literature from 1983 through 2013 categorizes IRPs with respect to their structural variants and with respect to the certainty regarding customer demand information. The presented classification scheme of the problem involves 34 papers on the basic versions of the IRP, 29 papers on extensions of the basic versions, and 20 papers on one or another version of the stochastic IRP.

Customer selection is another important aspect of the SPIRP. There are various studies in the literature that consider customer selection in routing problems. In one of the earlier publications, Aksen and Aras (2006) studied a selective single depot vehicle routing problem in order to maximize the total net profit which is equal to the sum of the revenues obtained from the visited nodes minus the traveling costs. They proposed a greedy heuristic called the iterative marginal profit analysis, which applies the classical Clarke-Wright parallel savings algorithm (Clarke & Wright, 1964) in a loop and discards unprofitable nodes one by one until there remains none. Aras, Aksen, and Tekin (2011) analyzed a selective multi-depot vehicle routing problem with pricing for the collection of used products from dealers, and developed a tabu search heuristic for its solution. Archetti, Feillet, Hertz, and Speranza (2009) and Archetti, Bianchessi, and Speranza (2013) studied two routing problems with profits, namely the capacitated team orienteering problem and the capacitated profitable tour problem. They proposed exact and heuristic procedures for these problems. Zhang, Che, Cheang, Lim, and Qin (2013) considered the multiperiod vehicle routing problem with profits. They proposed a memetic algorithm to optimize both the selection of customers to be visited and the routing decisions. We refer the readers to Archetti, Speranza, and Vigo (2013) for a general survey of vehicle routing problems with profits.

As routing problems become more or more complicated to address real life situations, solution methods with a higher degree of sophistication emerge. Contemporary heuristic optimization studies have shown the effectiveness of large neighborhood search mechanisms especially on routing and scheduling problems. The basic idea of these algorithms is to search larger and richer neighborhoods in order to escape local optima. Large neighborhoods span a larger portion of the solution space, which in turn helps to find better objective values. However, this characteristic is a disadvantage in terms of computational time. To offset this drawback, the investigation of large neighborhoods has been limited to a subset of the search space. Adaptive Large Neighborhood Search (ALNS) algorithm is in the class of such algorithms. It uses several moves interchangeably throughout the iterations unlike many other metaheuristics. The chance of a particular move to be used for the next iteration depends on its past performance. If it updates the best or the current solution, the probability of that move to be chosen in later iterations increases. Coelho, Cordeau, and Laporte (2012) latterly developed an ALNS algorithm to solve the IRP as a special case of a broader problem including transshipments. After creating the vehicle routes by ALNS operators, the algorithm determines delivery quantities by using an exact minimum cost network flow algorithm. Also we propose in this paper an ALNS method that can solve SPIRP instances with up to 100 source nodes in less than one hour or faster.

In this section, we describe the SPIRP and recall its mathematical model proposed by Aksen et al. (2012). The problem is defined on a complete directed graph with a set of source nodes and a depot. The real road shortest path distances d
                     
                        ij
                      are defined for each arc (i,
                     j) in the graph. The problem has a cyclic planning horizon over a period of seven days. The source node i represents an accumulation point where waste vegetable oil accumulates at a rate of a
                     
                        it
                      in each period t. The source nodes can be visited by a homogeneous fleet of vehicles having a fixed capacity Q. Each vehicle tour must start and end at the depot (node 0) which represents the biodiesel production facility. When a source node is visited in a certain period t, the total waste oil accumulated there since the last visit by a vehicle has to be collected, meaning that partial collection is not an option. The facility requires r
                     
                        t
                      amount of oil in period t in order to produce enough biodiesel in compliance with the given production plan. The required amount can be procured by collecting waste oil from source nodes, by purchasing virgin oil, by using the waste oil inventory buildup at the depot, or by any combination of these three alternatives. A traveling cost c per unit distance traveled, a purchasing cost p per liter of virgin vegetable oil, a holding cost h per liter of waste oil per period, and a unit vehicle operating cost v per period are used in the calculation of the total cost function of the facility.

The Selective and Periodic Inventory Routing Problem (SPIRP) is to find a periodic collection schedule that repeats itself in every cycle. This schedule identifies the set of source nodes to be visited and the associated vehicle routes in each period. The objective is to minimize the sum of travel, vehicle operating, inventory holding and purchasing costs while satisfying the production requirements and vehicle capacity constraints. SPIRP is NP-hard since it generalizes several well-known NP-hard optimization problems related to routing and lot-sizing (Aksen et al., 2012). Aksen et al. (2012) developed a MILP model to solve SPIRP. The MILP formulation determines the visiting schedule that reveals which nodes are selected and visited in each period using binary variables. Inventory balance equations record the collected amounts and the amount of accumulation of waste oil at the source nodes according to the visiting schedule. Inventory balance at the depot of the facility ensures that requirements are met. For the vehicle routing decisions, the MILP model uses a single commodity flow formulation to ensure connectivity and subtour elimination. Continuous variables represent the flow of the commodities along the arcs traveled by vehicles. Flow balance constraints in the model incorporate the binary node selection variables.

The index sets, parameters, and decision variables of the model are defined in Aksen et al. (2012) as follows.
                           
                              
                                 
                                 
                                    
                                       
                                          Index Sets
                                       
                                    
                                    
                                       
                                          I
                                          =0,1,…,
                                          n:the set of n source nodes and the depot 0,
                                    
                                    
                                       
                                          IC
                                          =1,…,
                                          n:the set of n source nodes only (a subset of I),
                                    
                                    
                                       
                                          T
                                          =1,…,
                                          τ:the set of τ periods in the cyclic planning horizon.
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          Parameters
                                       
                                    
                                    
                                       
                                          c:traveling cost per unit distance.
                                    
                                    
                                       
                                          d
                                          
                                             ij
                                          :distance from node i to node j, (i,
                                          j
                                          ∈
                                          I,
                                          d
                                          
                                             ij
                                           ≠d
                                          
                                             ji
                                          ).
                                    
                                    
                                       
                                          a
                                          
                                             it
                                          :waste vegetable oil accumulation amount in period t at node i, (i
                                          ∈
                                          IC,
                                          t
                                          ∈
                                          T).
                                    
                                    
                                       
                                          r
                                          
                                             t
                                          :waste oil requirement of the company per period, t
                                          ∈
                                          T.
                                    
                                    
                                       
                                          h:inventory holding cost per period for storing one liter oil at the depot.
                                    
                                    
                                       
                                          v:operating cost per vehicle.
                                    
                                    
                                       
                                          p:virgin vegetable oil purchasing price per liter.
                                    
                                    
                                       
                                          Q:vehicle capacity in liters.
                                    
                                    
                                       
                                          A
                                          
                                             i
                                          : total weekly accumulation of waste oil at node i, (i
                                          ∈
                                          IC). It serves as the Big-M number in the model. It is calculated by the formula 
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      i
                                                   
                                                
                                                =
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      t
                                                      ∈
                                                      T
                                                   
                                                
                                                
                                                   
                                                      a
                                                   
                                                   
                                                      it
                                                   
                                                
                                             
                                          .
                                    
                                    
                                       
                                          
                                       
                                    
                                    
                                       
                                          Decision variables
                                       
                                    
                                    
                                       
                                          X
                                          
                                             ijt
                                          :binary variable indicating if arc (i,
                                          j) is traversed by a vehicle in period t, (i,
                                          j
                                          ∈
                                          I,
                                          t
                                          ∈
                                          T).
                                    
                                    
                                       
                                          Y
                                          
                                             it
                                          :binary variable indicating if node i has been visited in period t, (i
                                          ∈
                                          IC,
                                          t
                                          ∈
                                          T).
                                    
                                    
                                       
                                          Z
                                          
                                             i
                                          :binary variable indicating if node i has been visited at least once during a cycle. It becomes 0 if node i is not visited at all, (i
                                          ∈
                                          IC).
                                    
                                    
                                       
                                          F
                                          
                                             ijt
                                          :the amount of waste oil flow from node i to node j in period t, (i,
                                          j
                                          ∈
                                          I,
                                          t
                                          ∈
                                          T).
                                    
                                    
                                       
                                          W
                                          
                                             it
                                          :the amount of waste oil collected from node i in period t, (i
                                          ∈
                                          IC,
                                          t
                                          ∈
                                          T).
                                    
                                    
                                       
                                          I
                                          
                                             it
                                          :ending inventory of waste oil by the end of period t at node i, (i
                                          ∈
                                          I,
                                          t
                                          ∈
                                          T).
                                    
                                    
                                       
                                          I
                                          
                                             i0:initial inventory of waste oil at the beginning of the cycle at node i, (i
                                          ∈
                                          I).
                                    
                                    
                                       
                                          S
                                          
                                             t
                                          :the amount of waste oil purchased by the collecting company in period t, (t
                                          ∈
                                          T).
                                    
                                 
                              
                           
                        
                     


                        MILP formulation
                        
                           
                              (1)
                              
                                 
                                    min
                                 
                                 TC
                                 =
                                 c
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          I
                                          ,
                                          j
                                          ≠
                                          i
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                 
                                 
                                    
                                       d
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 +
                                 v
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       0
                                       it
                                    
                                 
                                 +
                                 h
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                 
                                 
                                    
                                       I
                                    
                                    
                                       0
                                       t
                                    
                                 
                                 +
                                 p
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                 
                                 
                                    
                                       S
                                    
                                    
                                       t
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          I
                                          ,
                                          j
                                          ≠
                                          i
                                       
                                    
                                 
                                 
                                    
                                       F
                                    
                                    
                                       ijt
                                    
                                 
                                 -
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          I
                                          ,
                                          i
                                          ≠
                                          j
                                       
                                    
                                 
                                 
                                    
                                       F
                                    
                                    
                                       jit
                                    
                                 
                                 =
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       F
                                    
                                    
                                       ijt
                                    
                                 
                                 ⩽
                                 
                                    
                                       
                                          Q
                                          -
                                          
                                             
                                                a
                                             
                                             
                                                jt
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       F
                                    
                                    
                                       ijt
                                    
                                 
                                 ⩽
                                 Q
                                 -
                                 
                                    
                                       W
                                    
                                    
                                       jt
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 
                                 ∀
                                 j
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       F
                                    
                                    
                                       ijt
                                    
                                 
                                 ⩾
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 -
                                 
                                    
                                       A
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       
                                          1
                                          -
                                          
                                             
                                                X
                                             
                                             
                                                ijt
                                                ,
                                             
                                          
                                       
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          I
                                          ,
                                          j
                                          ≠
                                          i
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       jit
                                    
                                 
                                 =
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          I
                                          ,
                                          j
                                          ≠
                                          i
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 =
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       i
                                       0
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       0
                                       it
                                    
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (9)
                              
                                 Q
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       0
                                       it
                                    
                                 
                                 ⩾
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 ⩽
                                 
                                    
                                       A
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       I
                                    
                                    
                                       it
                                    
                                 
                                 ⩽
                                 
                                    
                                       A
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       
                                          1
                                          -
                                          
                                             
                                                Y
                                             
                                             
                                                it
                                                ,
                                             
                                          
                                       
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       I
                                    
                                    
                                       it
                                    
                                 
                                 =
                                 
                                    
                                       I
                                    
                                    
                                       it
                                       -
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       a
                                    
                                    
                                       it
                                    
                                 
                                 
                                    
                                       Z
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                       I
                                    
                                    
                                       i
                                       0
                                    
                                 
                                 =
                                 
                                    
                                       I
                                    
                                    
                                       i
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                       I
                                    
                                    
                                       0
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       I
                                    
                                    
                                       0
                                       t
                                       -
                                       1
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 +
                                 
                                    
                                       S
                                    
                                    
                                       t
                                    
                                 
                                 -
                                 
                                    
                                       r
                                    
                                    
                                       t
                                    
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       i
                                    
                                 
                                 ⩽
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       i
                                    
                                 
                                 ⩾
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 +
                                 
                                    
                                       X
                                    
                                    
                                       jit
                                    
                                 
                                 ⩽
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 j
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (18)
                              
                                 
                                    
                                       X
                                    
                                    
                                       i
                                       0
                                       t
                                    
                                 
                                 ⩽
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 ,
                                 ∀
                                 i
                                 ∈
                                 IC
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       X
                                    
                                    
                                       0
                                       it
                                    
                                 
                                 ⩽
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 ,
                                 ∀
                                 i
                                 ∈
                                 IC
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (22)
                              
                                 
                                    
                                       Z
                                    
                                    
                                       i
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                    
                                       F
                                    
                                    
                                       ijt
                                    
                                 
                                 ⩾
                                 0
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (24)
                              
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 ⩾
                                 0
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (25)
                              
                                 
                                    
                                       I
                                    
                                    
                                       it
                                    
                                 
                                 ⩾
                                 0
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (26)
                              
                                 
                                    
                                       I
                                    
                                    
                                       i
                                       0
                                    
                                 
                                 ⩾
                                 0
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                              
                           
                        
                        
                           
                              (27)
                              
                                 
                                    
                                       S
                                    
                                    
                                       t
                                    
                                 
                                 ⩾
                                 0
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        The objective function in (1) is the sum of the transportation, vehicle operating, inventory holding, and oil purchasing costs incurred by the facility in the planning horizon. Constraints (2) are used to balance the flow at each source node i. Constraints (3) and (4) control the upper bounds on the flow variables F
                        
                           ijt
                         by considering the vehicle capacity and the amount of waste oil collected from node j when a vehicle travels from node i to node j in period t. Constraints (5) control the lower bounds on flow variables. They make sure that if a vehicle travels from i to j in period t, all accumulated oil at node i is collected. Constraints (6) and (7) are incoming and outgoing degree balance constraints for each source node i, ensuring that the incoming/outgoing degree of node i be equal to 1 if node i is visited in period t, and equal to 0 otherwise. They couple the binary variables Y
                        
                           it
                         with X
                        
                           ijt
                        . Constraints (8) are the degree balance constraints for the depot. They impose the incoming and outgoing degrees to be the equal. Constraints (9) ensure that the number of vehicles dispatched in a period is sufficient to carry the collected amount with respect to the total vehicle capacity. Constraints (10) make sure that the collection amount at node i in period t is 0 if it is not visited in that period. Constraints (11)–(16) calculate the inventory at the source nodes and the depot. Constraints (11) prevent partial collection of waste oil at a source node i by making sure that the inventory at node i is zero at the end of period t if it is visited in that period. Constraints (12) control the ending inventory at each source node i in each period t and couple the integer variables Z
                        
                           i
                        , the daily accumulation of waste oil a
                        
                           it
                         and the amount of waste oil W
                        
                           it
                         collected from node i in period t. If i is not visited in t, then W
                        
                           it
                         will be 0 and the inventory increases by a
                        
                           it
                        . However, when i is not included in the schedule at all, meaning Z
                        
                           i
                        
                        =0, its inventory level stays constant. Constraints(13) make sure that the beginning and ending inventories of the planning horizon are equal for each node i. Constraints (14) are the inventory balance constraints for the depot. Constraints (15) and (16) couple the binary decision variables Z
                        
                           i
                         to Y
                        
                           it
                         so that if node i is visited in any period, then Z
                        
                           i
                         becomes 1. To tighten the model, constraints (17) have been added to break subtours of size two, and constraints (18) and (19) to avoid visits to a node which is not in the schedule. Constraints (20)–(27) enforce binary integrality and nonnegativity on the respective decision variables.


                        Aksen et al. (2012) also introduced a partial relaxation of the MILP model-denoted by PLR-to generate stronger lower bounds for SPIRP. They first converted the binary routing variables X
                        
                           ijt
                         to continuous variables between 0 and 1. Secondly, they added the following additional constraints. The integer variable V
                        
                           t
                         represents the number of vehicles dispatched in period t.
                           
                              (28)
                              
                                 0
                                 ⩽
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 ⩽
                                 1
                                 
                                 ∀
                                 i
                                 ∈
                                 I
                                 ,
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (29)
                              
                                 
                                    
                                       V
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       0
                                       jt
                                    
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (30)
                              
                                 
                                    
                                       V
                                    
                                    
                                       t
                                    
                                 
                                 ∈
                                 
                                    
                                       Z
                                    
                                    
                                       0
                                    
                                    
                                       +
                                    
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        Eqs. (29) and (30) strengthen the model by imposing integrality on V
                        
                           t
                         variables which are actually the sum of X
                        0jt
                         variables over j. Furthermore, instead of using Eqs. (17)–(19) as tightening constraints, the following Eqs. (31) and (32) are used.
                           
                              (31)
                              
                                 
                                    
                                       X
                                    
                                    
                                       ijt
                                    
                                 
                                 ⩽
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        
                        
                           
                              (32)
                              
                                 
                                    
                                       X
                                    
                                    
                                       jit
                                    
                                 
                                 ⩽
                                 
                                    
                                       Y
                                    
                                    
                                       it
                                    
                                 
                                 
                                 ∀
                                 i
                                 ∈
                                 IC
                                 ,
                                 
                                 ∀
                                 j
                                 ∈
                                 I
                                 ,
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                                 ,
                                 
                                 i
                                 
                                 ≠
                                 
                                 j
                              
                           
                        It is reported in Aksen et al. (2012) that this partial linear relaxation (PLR) model provides quite strong lower bounds for the test instances with 25 source nodes within a time limit of one hour.

We propose a new relaxation of the original MILP model in (1)–(27) to generate easy-to-compute lower bounds especially for larger SPIRP instances. We eliminate the routing part of the problem by removing the flow and routing variables (F
                        
                           ijt
                         and X
                        
                           ijt
                        ) and constraints (2)–(8), (17)–(19), (20)–(23). Instead, we add the cost of direct travel from and to the depot by fractional vehicles. The number of vehicles in each period t is represented by a new integer variable V
                        
                           t
                        . Constraint (9) is replaced with (33)–(35).
                           
                              (33)
                              
                                 
                                    
                                       V
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       R
                                    
                                    
                                       t
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          IC
                                       
                                    
                                 
                                 
                                    
                                       W
                                    
                                    
                                       it
                                    
                                 
                                 /
                                 Q
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (34)
                              
                                 
                                    
                                       V
                                    
                                    
                                       t
                                    
                                 
                                 ∈
                                 
                                    
                                       Z
                                    
                                    
                                       0
                                    
                                    
                                       +
                                    
                                 
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        
                        
                           
                              (35)
                              
                                 0
                                 ⩽
                                 
                                    
                                       R
                                    
                                    
                                       t
                                    
                                 
                                 ⩽
                                 1
                                 
                                 ∀
                                 t
                                 ∈
                                 T
                              
                           
                        We modify the objective function to underestimate the routing costs as follows. For each customer visited in a period t, we divide its collected amount by the vehicle capacity Q to find the fraction of a vehicle occupied by this customer’s load. We relax the problem so that the load of each customer can be carried by a fractional vehicle. The fractional vehicle should travel at least the distances d
                        0i
                         to get from the depot to customer i and d
                        
                           i0 to return back to the depot. In total a slack vehicle capacity of QR
                        
                           t
                         will remain. Since the slack capacity, i.e., the empty storage space (empty capacity) of the vehicles should also travel out of the depot and come back to it, we can bound the distance traveled to and from the depot by min
                           i∈IC
                        (d
                        0i
                        
                        +
                        d
                        
                           i0). By defining minimum distance parameters Min{d
                        0i
                        } and Min{d
                        
                           i0} representing the distances between the depot and the closest customers in each direction, we can add c(Min{d
                        0i
                        }+
                        Min{d
                        
                           i0})R
                        
                           t
                         to the objective to underestimate the routing cost of the empty vehicle capacity. We modify the vehicle operating cost and transportation cost parts of the objective function as follows:
                           
                              (36)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                vV
                                             
                                             
                                                t
                                             
                                          
                                          +
                                          c
                                          (
                                          Min
                                          {
                                          
                                             
                                                d
                                             
                                             
                                                0
                                                i
                                             
                                          
                                          }
                                          +
                                          Min
                                          {
                                          
                                             
                                                d
                                             
                                             
                                                i
                                                0
                                             
                                          
                                          }
                                          )
                                          
                                             
                                                R
                                             
                                             
                                                t
                                             
                                          
                                          +
                                          c
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   i
                                                   ∈
                                                   IC
                                                
                                             
                                          
                                          (
                                          
                                             
                                                d
                                             
                                             
                                                i
                                                0
                                             
                                          
                                          +
                                          
                                             
                                                d
                                             
                                             
                                                0
                                                i
                                             
                                          
                                          )
                                          
                                             
                                                
                                                   
                                                      W
                                                   
                                                   
                                                      it
                                                   
                                                
                                             
                                             
                                                Q
                                             
                                          
                                       
                                    
                                 
                              
                           
                        We observed that the relaxation without routing model (denoted as RR in the sequel) provides tighter lower bounds than PLR in all of the instances with 30 or more customers. The performance of RR will be discussed further in Section 5.

Recent heuristics in the literature based on Large Neighborhood Search (LNS) present a noticeable success in the fields of transportation and scheduling. The success of the method comes mostly from its ability to search a more complicated neighborhood in comparison to the previous methods applied in these fields. Searching in a larger neighborhood increases the chance of finding better solutions (Pisinger & Ropke, 2010). Especially when the problem has tight constraints, searching a small neighborhood may easily fail to explore the solution space thoroughly. The incumbent in such a search scheme has a great chance to get stuck at a feasible local optimum. Using large neighborhoods expands the search to a larger space and may find high quality local optima. However, this benefit comes at the expense of longer run time. LNS was first introduced by Shaw (1998) in 1998 to solve the capacitated VRP, one of the most studied combinatorial optimization problems. LNS starts with an initial solution and applies one destroy and one repair method in each iteration to improve the objective value. To reduce the computation time, Shaw (1998) proposed to begin with a smaller neighborhood and gradually increase the size of the neighborhood.


                     Ropke and Pisinger (2006) modified LNS by defining several destroy-and-repair methods, and coined the name Adaptive Large Neighborhood Search (ALNS). When compared to LNS, ALNS is capable of making more drastic changes to the current solution by exploring an even larger search space. For time efficiency, one of the predefined neighborhood structures (‘neighborhoods’ in short) is randomly selected at each iteration rather than applying all of them in sequence. In addition, ALNS dynamically controls the probability of selecting a neighborhood according to its performance history in the search process (Pisinger & Ropke, 2010).

Considering the remarkable success of ALNS in rich routing problems, we decided to apply an ALNS algorithm to our SPIRP. It adapts the algorithm proposed by Coelho et al. (2012)-an ALNS heuristic for the Inventory Routing Problem with Transshipments (IRPT)-to our problem. The ALNS heuristic in Coelho et al. (2012) differs from the previous ones in terms of the implementation of destroy-and-repair moves. Coelho et al. (2012) do not follow the rule of applying a repair move and a destroy move successively in each iteration. For some iterations, they apply only destroy moves or only repair moves. In our ALNS implementation, we use the moves they described; however, after each move we apply a repair step. Furthermore, the differences in the characteristics of IRPT and SPIRP create the need for different types of repair operators. SPIRP is distinguished from IRPT in its source node selectivity, flexibility on the number of vehicle dispatches, not allowing transshipments in between source nodes, lack of certain inventory policies, and inclusion of the outsourcing (purchasing) option. The detailed structure of the ALNS algorithm is explained next.

The ALNS algorithm is described in four main components in Coelho et al. (2012). We will follow the same format.

These are designed so as to make a number of changes to the current solution. In our algorithm, a variety of moves modify the selection of the source nodes, the visits to a source node in the periodic schedule, the number of vehicles, the inventory levels, the virgin oil purchases, and the sequence of nodes in a route. These changes may require recalculating all the objective function elements; i.e., ending inventories, total transportation cost, purchasing amounts, and total vehicle operating cost after each move.

In each iteration of the algorithm, the neighborhood to be explored is selected by a roulette-wheel mechanism. Each neighborhood has a weight which represents its share in the wheel. The weights are determined according to the past performance of the neighborhoods in producing new current solutions. Let w
                           
                              ν
                            be the weight assigned to neighborhood ν depending on its past performance. Then the neighborhood is chosen with probability 
                              
                                 
                                    
                                       w
                                    
                                    
                                       ν
                                    
                                 
                                 /
                                 
                                    
                                       ∑
                                    
                                    
                                       k
                                       =
                                       1
                                    
                                    
                                       #
                                       neig
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       k
                                    
                                 
                              
                            (#neigh=number of neighborhoods defined for ALNS).

At the beginning, each neighborhood has the same probability of being chosen. The runtime of the algorithm is divided into several phases containing the same number of iterations, namely φ. At the end of each phase, the weights of the neighborhoods w
                           
                              ν
                            are updated according to their performance in the current phase. The performance of each neighborhood—represented by π
                           
                              ν
                            for neighborhood ν—is recorded on a scorecard. At the beginning of each phase, scores are reset to 0. After each iteration, the score of the neighborhood used at that iteration is updated as shown below, where σ
                           1, σ
                           2 and σ
                           3 are integer numbers satisfying σ
                           1
                           >
                           σ
                           2
                           >
                           σ
                           3, s′ is the new solution, s
                           best is the best solution, s is the current solution, and f(s) is the objective function to be minimized. SA stands for simulated annealing.
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                if
                                              
                                             f(s′)<
                                             f(s
                                             best) 
                                                then
                                             
                                          
                                       
                                       
                                          
                                             
                                             π
                                             
                                                ν
                                             :=
                                             π
                                             
                                                ν
                                             
                                             +
                                             σ
                                             1
                                          
                                       
                                       
                                          
                                             
                                                else if
                                              
                                             f(s′)<
                                             f(s) 
                                                then
                                             
                                          
                                       
                                       
                                          
                                             
                                             π
                                             
                                                ν
                                             :=
                                             π
                                             
                                                ν
                                             
                                             +
                                             σ
                                             2
                                          
                                       
                                       
                                          
                                             
                                                else if
                                              
                                             s′ is accepted as the next current solution by the SA criterion 
                                                then
                                             
                                          
                                       
                                       
                                          
                                             
                                             π
                                             
                                                ν
                                             :=
                                             π
                                             
                                                ν
                                             
                                             +
                                             σ
                                             3
                                          
                                       
                                       
                                          
                                             
                                                else
                                             
                                          
                                       
                                       
                                          
                                             
                                             π
                                             
                                                ν
                                             :=
                                             π
                                             
                                                ν
                                             
                                          
                                       
                                       
                                          
                                             
                                                end if
                                             
                                          
                                       
                                    
                                 
                              
                           The main idea here is that the better the new solution, the larger the increment on the score of the chosen neighborhood ν. At the end of each phase, the weights are updated as follows:
                              
                                 
                                    
                                       
                                          w
                                       
                                       
                                          ν
                                          ,
                                          j
                                          +
                                          1
                                       
                                    
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            w
                                                         
                                                         
                                                            ν
                                                            j
                                                         
                                                      
                                                   
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            o
                                                         
                                                         
                                                            ν
                                                            j
                                                         
                                                      
                                                      =
                                                      0
                                                      ,
                                                   
                                                
                                                
                                                   
                                                      (
                                                      1
                                                      -
                                                      η
                                                      )
                                                      
                                                         
                                                            w
                                                         
                                                         
                                                            ν
                                                            j
                                                         
                                                      
                                                      +
                                                      η
                                                      
                                                         
                                                            π
                                                         
                                                         
                                                            ν
                                                         
                                                      
                                                      /
                                                      
                                                         
                                                            o
                                                         
                                                         
                                                            ν
                                                            j
                                                         
                                                      
                                                   
                                                   
                                                      otherwise
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           Here, o
                           
                              νj
                            is the number of times neighborhood ν is used in the current phase j, w
                           
                              νj
                            is the weight of neighborhood ν in the current phase j and η
                           ∈[0,1] is a reaction factor controlling how much the last phase affects the current weights. In our implementation the weights of all moves start with equal values. The phase length φ in our algorithm is 200 iterations. The score updates σ
                           1, σ
                           2, σ
                           3 take on values 10, 5, and 2, respectively. The reaction factor η is fixed to 0.7.

The acceptance criterion for the new solution s′ is as it is in simulated annealing (SA). Let u be a uniformly distributed random variable between 0 and 1, θ the temperature parameter. The temperature is started at θ
                           start and it is decreased by a cooling factor ϕ at each iteration, where 0<
                           ϕ
                           <1.
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                if
                                              
                                             f(s′)<
                                             f(s)
                                       
                                       
                                          
                                             
                                             s
                                             ←
                                             s′
                                       
                                       
                                          
                                             
                                                else if
                                              
                                             
                                                
                                                   u
                                                   <
                                                   
                                                      
                                                         e
                                                      
                                                      
                                                         -
                                                         (
                                                         f
                                                         (
                                                         
                                                            
                                                               s
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                         )
                                                         -
                                                         f
                                                         (
                                                         s
                                                         )
                                                         )
                                                         /
                                                         θ
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                             s
                                             ←
                                             s′
                                       
                                       
                                          
                                             
                                                else
                                             
                                          
                                       
                                       
                                          
                                             Keep s as the current solution of the next iteration.
                                       
                                       
                                          
                                             
                                                end if
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

We initialize the starting temperature θ
                           start to 100,000 and the cooling factor ϕ to 0.99977, which leads to an iteration limit of 50,000. For larger instances with over 50 source nodes, the cooling factor becomes 0.9996, causing the iteration limit to rise to 100,000. These values have been decided as a result of a pilot parameter tuning analysis. Moreover, we have a time limit of one hour (3600seconds) as a stopping criterion to avoid long CPU times. The pseudo code of our ALNS algorithm is given in the Appendix.

ALNS iteratively makes gradual route improvements over an initial solution. We observed that a relatively better initial solution produces better final results compared to a random initial solution. In order to start with a good initial solution, we exploit the optimal solution of the relaxation without routing model RR (see Section 3.3). The RR model gives us for each source node a visiting schedule during the planning horizon. Then, Clark and Wright parallel savings algorithm (CW-PSA) (Clarke & Wright, 1964) is used to determine the routes of each period. On top of that, to find a better initial solution, we apply the following route improvement heuristics. These local search heuristics are known to perform well in the VRP literature (Toth & Vigo, 2002).


                        Intraroute 2-Opt: Two edges are removed from the tour and the two remaining segments are reconnected (see Fig. 1
                        ).


                        Intraroute 3-Opt: Three edges are removed from the tour and the three remaining segments are reconnected in all possible ways (see Fig. 2
                        ).


                        Interroute 2-Opt: Two edges from two different routes are replaced by two new edges (see Fig. 3
                        ).


                        Interroute 1-0 move: A source node is moved from one route to another (see Fig. 4
                        ).


                        Interroute 1-1 and 2-2 exchanges: Two source nodes or two pairs of source nodes are exchanged between two routes (see Fig. 5
                        ).


                        Interroute 1-1-1 rotation: Three routes are considered. A source node from each one is shifted to the next route in a cyclic fashion (see Fig. 6
                        ).

SPIRP is highly complicated as it merges lot-sizing and routing decisions in one problem. Even a minor modification of the solution can create considerable changes. Due to the periodic structure of the problem, most of the moves affect more than a single period. Even in simple moves the time to restructure the solution is substantial. Relatively complicated moves are even more time consuming. For instance, new routes are constructed from scratch for several periods. However, thanks to the outsourcing option in the problem definition, a number of the moves can be applied without causing infeasibility in the solution.

We adopt the moves that are utilized by Coelho et al. (2012) for the IRPT. After each move we apply a repair step to reform a new feasible solution and recalculate the costs. This repair step involves the application of the route improvement heuristics already described in Section 4.2.

Several moves are performed ρ times in a single iteration, where ρ
                        ∈{1,2,3} is a randomly chosen integer. The probability of ρ to be 1 is 5/9, 2 is 3/9 and 3 is 1/9. Since the probability of ρ
                        =1 is higher, in most iterations the moves are performed only once, as in the classical approach in metaheuristics. However, with lesser probabilities, ρ might be also 2 or 3 which transforms a move into a larger move that can search a larger solution space. Each move impacts the schedule of either one or several source nodes. The source nodes on which a move is applied are chosen randomly from among a particular subset of the source nodes or according to a predefined rule. Considering the characteristics of the moves, we define the following four subsets:
                           
                              
                                 Subset 1: Source nodes not included in the current solution, i.e., those which are not visited at all.


                                 Subset 2: Source nodes that are visited once in the current solution.


                                 Subset 3: Source nodes that are visited more than once but not in each period in the current solution.


                                 Subset 4: Source nodes that are visited in all periods of the planning horizon.

Although a move modifies only the source node list of a single period, updating the routes, inventory levels and purchase amounts of several periods might be necessary. Before defining the moves, we explain the types of repair procedures the solution goes through after a move.

We first define the two common steps of the repair procedures.


                           
                              Route Improvement Step
                           : If the total collected amount in period t is lower than the total vehicle capacity with one less vehicle, then check if the number of vehicles can be reduced. For this purpose, solve the pertinent VRP in that period t from scratch using CW-PSA and apply the route improvement heuristics.


                           
                              Source Node Insertion Step
                           : Check whether there is a vehicle with enough slack capacity to collect the current waste oil amount of the given source node i in period t. If there is, insert node i in the route of that vehicle according to the cheapest insertion rule. If there is not enough slack capacity, dispatch a new vehicle that will carry only the waste oil amount of node i and apply the Route Improvement Step.
                        

Next we define five types of repair procedures.


                           
                              Repair 1
                           :

This type of repair is used in the case a source node i which is in Subset 3 or 4 is removed from a period t. It still stays in the solution, but is visited in another period t′. The amount originally collected from i in period t is transferred to period t′. So, it becomes necessary to update both periods t and t′. The source node list and the routing list of period t are updated. Since the total collected amount decreases with the removal of a source node, the Route Improvement Step is applied to period t to check the possibility of reducing the number of vehicles and improving the routes routing. In the next visiting period t′, determine the particular vehicle k that visits the newly moved node i. First check whether vehicle k has enough slack capacity to carry the additional collection amount from i. If there is enough slack capacity in k, update only the total collected amount and the slack capacity of k. If there is not, apply the Source Node Insertion Step for that period t′.

After this repair procedure, the total collected amount in the planning horizon stays the same, but the collected amounts change in two periods (t and t′). The total purchased amount and its cost stay the same too, but the inventory levels for each period and the inventory cost change. Furthermore, since some routes are modified, the transportation cost changes. Finally, the vehicle operating cost changes if the number of used vehicles increases.


                           
                              Repair 2
                           :

This type of repair is used in the case a move inserts a source node i which is in Subset 2 or 3 into a given period t. Since the source node was already in the solution for at least one other period before insertion, the new collected amount in the inserted period t is transferred from the next visiting period t′ (t′>
                           t). The total collected amount in period t′ is decreased by the amount transferred to t and the slack capacity of the vehicle that visits i in period t′ is decreased by the same amount. The Source Node Insertion Step is applied for period t and the Route Improvement Step is applied for period t′.

After these updates, the total collected amount in the planning horizon stays the same, but the collected amounts for periods t and t′ change. The total purchase amount does not change, hence the purchasing cost stays the same. However, with altered collection amounts in the two periods t and t′, the inventory levels and thus the inventory cost change. Also since some routes get modified, the transportation cost has to be recomputed. Finally, the vehicle operating cost changes if the number of used vehicles increases.


                           
                              Repair 3
                           :

This type of repair is used in the case a move deletes a source node i which is in Subset 2, 3 or 4 (i.e., which is visited at least once) from all periods. For the periods from which node i is to be removed, the source node list and the routing list are updated. Then, the Route Improvement Step is applied. Since node i is removed from the solution altogether, the facility might fall short of meeting the production requirements if there is not enough waste oil collected. In this case, it will purchase virgin oil as required. Hence, the purchasing cost might increase. Inventory levels drop, and thus the inventory cost decreases. Since node i is not anymore to be visited, the transportation cost decreases too. Finally, the vehicle operating cost changes if the number of used vehicles decreases.


                           
                              Repair 4
                           :

This type of repair is used in the case a move inserts a source node i which is in Subset 1 (i.e., which is not visited at all in the current solution) into a random period t. For that period, the Source Node Insertion Stepis applied. If the facility was purchasing virgin oil before the insertion, the amount of waste oil that accrues at the newly inserted node i during the entire planning horizon is subtracted from the total amount of purchased oil without allowing negative purchase. In that case the purchasing cost goes down, but the inventory level, and thus the inventory cost increases. Moreover, the transportation cost definitely rises since a new source node is visited. The vehicle operating cost may also rise if one more vehicle is needed.


                           
                              Repair 5
                           :

This type of repair is used in the case a move exchanges all the source nodes of a period t with the source nodes of another period t′. All the routes of these two periods are destroyed. Because the original amounts collected from the source nodes in periods t and t′ alter completely, it is highly possible that all of the periods get affected by this exchange. We first restructure periods t and t′ from scratch with their newly assigned source nodes. To this end, we use the CW-PSA followed by the route improvement heuristics, and create the routes in these two periods anew. Although the nodes visited in the other periods stay the same, due to possible changes in the collected amounts, we reconstruct the routes in those periods as well in the same manner. Total collection volume stays the same, but collected amounts in almost all periods change. The total amount purchased does not change; hence, the purchasing cost stays the same. However, with different collection amounts, the inventory levels and inventory costs change for each period. Furthermore, since all the routes in the current solution will be updated by this repair procedure, the transportation and vehicle operating costs are very likely to change as well.

The 11 moves each of which constitutes a separate neighborhood in our ALNS algorithm are described below. Note that the pseudo code of the algorithm is given in the Appendix.
                              
                                 1.
                                 
                                    Randomly removeρvisits Randomly select a period t
                                    ∈
                                    T and remove from it one arbitrary source node i which belongs to either Subset 3 or 4. Apply then Repair 1. Repeat this move ρ times.


                                    Randomly insertρvisits Randomly select a source node i from Subset 2 or Subset 3, and a random period t
                                    ∈
                                    T in which i is not visited. Insert i into the chosen period by applying Repair 2. Repeat this move ρ times.


                                    Remove the worst source node Consider all the visits of a particular source node from Subset 2, 3 or 4 such that the objective value will improve (decrease) the most when that node is removed from the visiting schedule. The source nodes from Subsets 2, 3 and 4 are removed one by one, and the most cost-effective removal is chosen. After this destroy operation, apply Repair 3.


                                    Insert the best source node Choose a source node i from Subset 1, and add it to a period t
                                    ∈
                                    T in such a way that the objective value will improve the most when i is included in the visiting schedule. Apply then Repair 4.


                                    Shaw removal Randomly select a period t
                                    ∈
                                    T and a source node i from Subset 3 or 4 which is visited in t. Consider the distance from i to the closest node in the same period t and call it dist
                                    
                                       min
                                    . Remove all those nodes which are: (i) in Subset 3 or 4; (ii) located within the range of (2dist
                                    
                                       min
                                    ) from the selected node i; and (iii) visited in t. Following the removal of each such node, apply Repair 1.


                                    Shaw insertion Randomly select a period t
                                    ∈
                                    T and a source node i from Subset 3 or 4 which is not visited in t. Consider the distance from i to the closest node in the same period t and call it dist
                                    
                                       min
                                    . Insert into t all those nodes which are: (i) in Subset 2 or 3; (ii) located within the range of (2dist
                                    
                                       min
                                    ) from the selected node i; and (iv) not visited in t. Following the insertion of each such node, apply Repair 2.


                                    Removeρsource nodes Randomly select a source node i from Subset 2, 3 or 4 and remove it from all periods t
                                    ∈
                                    T. Apply then Repair 3. Repeat this move ρ times.


                                    Insertρsource nodes Randomly select a source node i from Subset 1 (i.e., one which is not visited in the current solution) and insert it into a randomly selected period t
                                    ∈
                                    T. Apply then Repair 4. Repeat this move ρ times.


                                    Empty one period Randomly select a period t
                                    ∈
                                    T and remove all source nodes visited in that period. For the removed nodes from Subset 2, apply Repair 3 and for the ones from Subset 3 or 4, apply Repair 1.


                                    Swap routes Randomly select two periods t and t′∈
                                    T, and swap all their source nodes. Apply then Repair 5.


                                    Randomly moveρvisits Randomly select a period t
                                    ∈
                                    T and a source node i from Subset 2 or 3 visited in that period. Remove node i from t and insert it into another arbitrary period t′∈
                                    T, t′≠t. First, insert the selected node i into period t′ and apply Repair 2. Second, remove the same node i from period t and apply Repair 1. Repeat this move ρ times.

In the next section, we first detail how we gathered real life data for our problem. We then present the results of our computational study.

We solved 54 SPIRP instances having real-world data originating from a case study about a biodiesel production facility in Istanbul, Turkey. The instances involve 20–100 source nodes and a 7-day cyclic planning horizon. To evaluate the performance of the ALNS algorithm, we generated lower bounds by solving the associated partial linear relaxation model PLR (see Section 3.2) and the relaxation without routing model RR (see Section 3.3). Moreover, we also solved the MILP model given in (1)–(27) in Section 3.1 to compare ALNS against the commercial solver Cplex 12 on small size SPIRP instances with at most 40 source nodes. Aksen et al. (2012), who formulated SPIRP for the first time, observe that Cplex performs poorly on instances with 40 nodes. Therefore we do not tabulate the Cplex solutions (upper bounds) of the MILP models of larger instances, but report only their average optimality gaps. In the following sections, we describe the data, present the results and provide some analyses on the performance of the moves in ALNS.

We chose 20, 25, 30, 35, 40, 50, 60, 80, and 100 restaurants as potential candidates to be included in the waste oil collection program. The restaurants and the recycling facility constitute a complete collection network. The restaurants are the source nodes, and the recycling facility is the depot. The asymmetric shortest path distances between each origin and destination pair on this complete network have been obtained from Google Maps. These distances multiplied by the unit traveling cost c correspond to the asymmetric arc costs of our complete collection network. All restaurants are located on the Asian side of Istanbul, while the depot is situated in Gebze, about 50kilometer east of Istanbul on the northern shore of the Sea of Marmara. Fig. 7
                         shows the source nodes’ geographical distribution on the eastern side of the Bosphorus. The reason why most of the nodes appear to be close to each other is that hotels and restaurants are not dispersed homogenously over the Asian side of Istanbul in reality.

Besides the distances, there are several other input parameters such as the costs of inventory holding, transportation, purchasing, and vehicle operating; the vehicle capacity, the daily waste oil accumulation rates at each restaurant, and the daily waste oil requirement of the facility. These were obtained from various information sources on the web and through private communication with the facility manager.

For the daily accumulation rates a
                        
                           it
                         we prepared a simple questionnaire to be able to estimate realistic values. The questionnaire shows that large size restaurants accumulate approximately 50liters of waste oil per day, medium size restaurants around 30liters/day and small size restaurants about 15liters/day. These values are taken into account to generate relevant a
                        
                           it
                         values. For each day t
                        ∈{1,…,7}, a
                        
                           it
                         values are derived from a normal distribution with means 15, 30 and 50 according to the restaurant type of the instance with variances 5, 15 and 25, respectively. We created a wide array of test instances to assess the performance of our algorithm in different real life scenarios.

The facility policy is to adopt a uniform vehicle type for its collection operations. We used the light commercial vehicle Fiat Fiorino Cargo. Its fuel and operating costs (parameters c and v in the MILP model) are given in Table 1
                        . The driver wages, vehicle leasing costs, and the retail price of Euro 4 diesel were inquired in August 2013. They may show deviations from the current actual values.

Since virgin oil can also be used as raw material in biodiesel production, we assume that the purchasing price p is at most the wholesale price of virgin vegetable oil, which is around 3.50TL (Turkish Lira) per liter. We also run our algorithm with another p value, namely 2.50TL per liter. The cost of storing one liter of waste oil in the containers of the facility, namely h has been calculated as the daily interest rate times the highest purchasing price. This results in h
                        =0.02TL per day.

We tested our proposed ALNS algorithm with three levels of waste oil requirements: low, medium, and high. These levels were calculated according to the total weekly accumulation at the restaurants chosen as source nodes. They were determined under the hypothetical obligation of collecting about 50%, 75% and approximately 100% of the total weekly accumulation, respectively. Total requirements were then divided by the cycle length 7 which yields the daily requirement values. We assumed that the daily requirements do not vary across the 7-day production cycle.

Overall 54 SPIRP test instances have been generated for this real-world waste oil collection problem. They vary from one another in the number of source nodes (n), the daily requirement values (r
                        
                           t
                        ), and in the virgin oil purchasing price p. Test instance names are indicative of these specifications. For example, the name (20n-270r-2.5p) means that n is 20, r
                        
                           t
                         is 270 liters for each day, and p is 2.50TL per liter.

All experiments and scenario analyses were conducted on a workstation equipped with Intel Xeon E5-2643 3.30GHz Quad-Core processor and 32GB RAM. The operating system of this PC is 64-bit Windows 7 Professional Service Pack 1. The ALNS algorithm was coded in JAVA and compiled with version 10.15.2.0. For every instance, we performed 10 parallel ALNS runs by converting Java files to jar files and starting the same 10 jar files through the comment window. In this way, the computing load is distributed among all processor cores. Out of the 10 run results, the one yielding the lowest is recorded as the best objective value and the total time to execute all 10 parallel runs is reported as the CPU time of the algorithm for each instance.

The 64-bit version of the mathematical modeling suite GAMS 23.7 and the solver Cplex 12.3 were used to solve the MILP, PLR, and RR models of the test instances. Cplex 12.3 was employed with the following options turned on: nodelim 50000000; threads 0; parallelmode 1; workmem 30000; nodefileind 2 (GAMS/Cplex 12 Solver Manual). With these options the computing load of Cplex is also distributed onto the four cores (eight threads) of the Xeon Quad-Core processor.

We solved the MILP model subject to a time limit of 2.0, 2.5, 3.0, 3.5 and 4.0hours for the instances with respectively 20, 25, 30, 35 and 40 source nodes. For larger instances we set the time limit of the Cplex solver to 5.0hours. The upper bounds of the MILP solutions serve as a benchmark for the solution quality of our ALNS algorithm. To evaluate the performance of our algorithm further, we obtained lower bounds on the test instances from the solutions of the respective PLR and the RR models. Cplex was run on the PLR model for 1.00, 1.25, 1.50, 1.75, and 2.00hours for instances with respectively 20, 25, 30, 35, and 40 source nodes. For source node counts of 50 and above we let Cplex run for 5.00hours on the PLR model. Finally, the RR model is solved to optimality in less than 100seconds in 47 of 54 instances. In the remainder we set the time limit to half an hour at the end of which the optimality gap of the RR model drops below 0.01%.

The ALNS algorithm was applied to 54 instances described in Section 5.1. To evaluate the quality of the ALNS solutions, three different lower bound methods were employed. The best possible solution, i.e., the maximum of the lower bounds produced by the Cplex solver for the MILP, PLR or RR models of a given SPIRP instance implies a theoretical lower bound on the actual optimal solution of that instance. On the other hand, the minimum of the best ALNS objective value and the best feasible objective value of the MILP model found by Cplex implies a theoretical upper bound on the actual optimal solution. So we utilize two performance indicators for our ALNS algorithm, namely (i) the maximum of the MILP, PLR and RR lower bounds, and (ii) the best feasible objective value of the MILP model.

In our test results, we report the following:
                           
                              
                                 
                                 
                                 
                                    
                                       
                                          TC
                                          
                                             ALNS
                                          :
                                       The best feasible objective value obtained in 10 parallel ALNS runs.
                                    
                                    
                                       
                                          TC
                                          
                                             MILP
                                          :
                                       The best feasible objective value, i.e., final upper bound obtained by solving the MILP model for a preset time limit.
                                    
                                    
                                       
                                          CPU
                                          
                                             ALNS
                                          :
                                       The CPU time of 10 parallel ALNS runs in total.
                                    
                                    
                                       
                                          CPU
                                          
                                             MILP
                                          :
                                       The CPU time of the MILP model, i.e., the preset time limit.
                                    
                                    
                                       
                                          LB
                                          
                                             MILP
                                          :
                                       The lower bound of the MILP model obtained after CPU
                                          
                                             MILP
                                           seconds.
                                    
                                    
                                       
                                          LB
                                          
                                             PLR
                                          :
                                       The lower bound of the PLR model obtained after CPU
                                          
                                             MILP
                                          /2(CPU
                                          
                                             MILP
                                          ) seconds for small (large) size instances.
                                    
                                    
                                       
                                          LB
                                          
                                             RR
                                          :
                                       The optimal objective value of the RR model.
                                    
                                    
                                       
                                          BestLB:
                                       The final gap between and the best lower bound BestLB. It is given by the formula 
                                             
                                                
                                                   
                                                      
                                                         
                                                            TC
                                                         
                                                         
                                                            MILP
                                                         
                                                      
                                                      -
                                                      BestLB
                                                   
                                                   
                                                      BestLB
                                                   
                                                
                                             
                                          .
                                    
                                    
                                       
                                          Gap
                                          
                                             ALNS
                                          :
                                       The final gap between TC
                                          
                                             ALNS
                                           and the best lower bound BestLB. It is given by the formula 
                                             
                                                
                                                   
                                                      
                                                         
                                                            TC
                                                         
                                                         
                                                            ALNS
                                                         
                                                      
                                                      -
                                                      BestLB
                                                   
                                                   
                                                      BestLB
                                                   
                                                
                                             
                                          .
                                    
                                    
                                       
                                          Gap
                                          
                                             MILP−ALNS
                                          :
                                       The final gap between TC
                                          
                                             MILP
                                           and TC
                                          
                                             ALNS
                                          . It is given by the formula 
                                             
                                                
                                                   
                                                      
                                                         
                                                            TC
                                                         
                                                         
                                                            MILP
                                                         
                                                      
                                                      -
                                                      
                                                         
                                                            TC
                                                         
                                                         
                                                            ALNS
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            TC
                                                         
                                                         
                                                            MILP
                                                         
                                                      
                                                   
                                                
                                             
                                          .
                                    
                                 
                              
                           
                        First, we benchmark the performance of the ALNS algorithm and the MILP model on small size instances. For instances with n
                        =20 and n
                        =25 nodes, the exact model gives better objective values. When the number of the nodes increases to 30, ALNS starts to outperform the MILP model. The methods are evaluated on the basis of the best lower bound BestLB. Table 2
                         presents the experimental results for the small size instances. Starting with 25 nodes, the RR model finds tighter (higher) lower bounds than the other two lower bound methods. For n
                        =20 and n
                        =25, the MILP model finds near optimal solutions with less than 2.5% gap. The average gap is no more than 1.53%. Even though ALNS cannot yield better solutions than the MILP model for 10 of these 12 instances, it performs nearly as good in very short times. The longest CPU time of ALNS is 35seconds when n
                        ⩽25.


                        Table 3
                         summarizes the performance comparison of the two methods with respect to n in small size instances. We observe that ALNS proves successful not only in terms of time efficiency, but also solution quality when the number of nodes is 30 or higher. Gap
                        
                           MILP−ALNS
                         starts with negative values, but it quickly gets bigger in larger instances. Among 18 instances with 30⩽
                        n
                        ⩽40, ALNS finds the better objective value for 14 of them while the MILP model achieves this in four instances. For n
                        =40, ALNS improves the MILP model’s upper bounds (best feasible objective values) by 15.39% in average. It outperforms the MILP solution in all six instances. In addition, the average solution times of ALNS are only a fraction of the preset times of the MILP model.

We tested our algorithm also on large instances to solve more realistic problems in reasonable times as shown in Table 4
                        . Because the MILP model does not perform well in large instances even after 5.0hours, we present here only the ALNS objective values. To assess the solution quality of ALNS, we use the lower bounds obtained from the MILP, PLR and RR models. The RR lower bound model conspicuously outperforms the other two by yielding the highest lower bound in all 24 large size instances. The ALNS algorithm runs with 7.14% optimality gap on average. As a matter of fact, this constitutes a theoretical maximum possible gap for ALNS. Since the best lower bounds could still be loose-meaning that they could be far below the true optimal objective values, the actual average optimality gap of the ALNS might be less than 7.14%. However, we cannot comment further about this because we do not know the true optimal solutions of the large size instances.

It is our understanding that the MILP model fails to compete with the ALNS algorithm in large size instances. Average Gap
                        
                           MILP−ALNS
                         is equal to 26.3%, 58.4%, 73.5% and 90.4% for n
                        =40, 50, 60, 80 and 100, respectively. Especially when there are 100 source nodes, the best MILP upper bounds obtained in 5.0hours of run time vary between 10 and 14 times the objective values found by ALNS in less than one hour.

The last column of Table 4 shows the value of n
                        vis/n for each large size instance. This is the percentage ratio of visited source nodes to the number of available source nodes. We observe that this ratio is dependent on the level of waste oil requirement r
                        
                           t
                        . The higher the requirement is, the more nodes are included in the visiting schedule. For n
                        =50 which is the smallest problem size in our second test set, the virgin oil price p has also an effect on the ratio of visited nodes. For the same low or medium oil requirement, the ratio n
                        vis/n increases as the purchasing option becomes more expensive. However, p does not make a difference in the selection of the source nodes when the waste oil requirement reaches its peak level. In that case the facility collects the entire oil accumulating at all source nodes anyway.

In this section, we discuss some details about the performance of our ALNS algorithm. First of all, we see that as n increases, the average gap of ALNS exhibits an upward trend. This is also true for the CPU time consumption of the algorithm on a large scale. As the problem size gets bigger than 80 source nodes, the average solution time spikes rapidly as shown in Fig. 8
                        . While the algorithm completes its runs in less than 10seconds for n
                        =20, it takes close to one hour for two of the largest test instances. However, the longest time of our algorithm for the largest instance is even less than the solution time of the MILP model for the smallest instance. In solution time comparison, the ALNS algorithm is clearly superior to the MILP model.

We also observe a similar upward trend in CPU times for all instances with different n values when the raw material requirement levels r
                        
                           t
                         are raised, which can be seen in Table 5
                        . For the same n value, higher r
                        
                           t
                         level increases the CPU time of the algorithm. With lesser requirements, the facility has more choices to apply different moves. As the requirement level increases, the selective part of the problem weakens and the moves designed for this characteristic of the problem become ineffective. The algorithm has difficulty in finding the appropriate moves that can be applied to the current solution. Also the extensive randomness of the algorithm affects the CPU time negatively when the solution space gets smaller. If it was for most other metaheuristics, the CPU time might decrease as the solution space shrinks since those methods try to cover a local area completely. Another factor causing the CPU times to grow with high requirements is the reconstruction of the routes in the repair steps. Applying the parallel savings and improvement heuristics to construct new routes takes much more time since almost all source nodes need to be visited.

We next analyze each move separately. To conduct our analysis, we formed a test bed of nine instances each with a different n value. We removed the moves one by one and then solved each instance with the resulting reduced algorithm that has one less move type. We observe that each time a particular move is removed, the solution quality deteriorates. This justifies the benefit of all the move types we have included in our ALNS algorithm. However, while removing some moves leads to great worsening in the objective value, some others affect the solution less. The exclusion of the moves #3 and #7 (“Remove ρ source nodes” and “Remove the worst source node”) affects the solution quality relatively more than the exclusion of others.

Furthermore, we evaluate the effectiveness of the moves in finding (i) a better incumbent solution, (ii) a better current solution, and (iii) a new solution accepted with simulated annealing, as presented in Table 6
                        . These values are cumulative over 10 runs of all 54 test instances. Compared to other moves, “Remove the worst source node” is seen to be more effective in finding a new incumbent solution and also a better current solution. The moves “Insert the best source node” and “Swap routes” also seem more successful in updating both the incumbent and the current solutions. As stated before, the diverse characteristics of its moves are one of the strongest features of the ALNS algorithm. Even though some moves show more success, it is not possible to obtain as good solutions without the synergy of the other moves. We also record the percentages of the solution updates during the algorithm. The incumbent solution is updated in only 0.16% of the iterations. This is quite anticipated since it is the best solution found thus far during the execution of the algorithm. On the other hand, the current solution is updated in almost half of the iterations. Overall in 2/3 of the iterations of the ALNS runs, a new solution is accepted as the next current solution.

According to Table 6 several moves appear to perform better. Nevertheless, our analysis suggests that all moves included in the design of the algorithm make a contribution to its performance either by intensifying or by diversifying the search as a result of their structural characteristics.

@&#CONCLUSIONS@&#

This study provides an effective heuristic solution method to a selective and periodic inventory routing problem (SPIRP) for a biodiesel production facility that collects waste vegetable oil. The facility manager has to decide which of the present source nodes to include in the collection program, which periodic routing schedule to repeat over an infinite horizon, how much virgin oil to purchase on each day, and how many vehicles to operate in which routes. The objective of the problem is to minimize the sum of collection, inventory holding, and purchasing costs subject to production requirements and operational constraints. SPIRP was first described in a recent paper by Aksen et al. (2012). The solution of the MILP model proposed for this problem does not supply acceptable gaps for problem instances with more than 30 source nodes in a reasonable time. Besides, the near optimal solutions found by that MILP model take quite long CPU times even for small size instances.

We develop an adaptive large neighborhood search (ALNS) algorithm with a rich set of moves for this reverse logistics problem. The typical features of an ALNS are large neighborhoods, adaptive selection probabilities of the moves which are updated according to their past efficacy, a roulette-wheel selection mechanism, and a Simulated Annealing-based acceptance criterion for the neighborhood solutions. We solve 54 SPIRP instances of size 20 to 100 source nodes. For smaller instances with up to 40 nodes, we compare our results with those of the MILP model. When there are less than 30 source nodes, ALNS cannot perform as well as MILP. However, for 30 and above, ALNS outperforms MILP considerably. For instances with 40 source nodes, ALNS improves the MILP solutions by 15.4% on average. The maximum CPU time spent by ALNS is 240seconds, while the Cplex solution of the MILP model cannot match the respective ALNS solution even at the end of four hours.

For larger instances which have 50–100 source nodes, we evaluate the performance of ALNS on the basis of the lower bounds obtained from three models, namely MILP, PLR and RR. PLR was proposed earlier as a partial relaxation model of the MILP. Among the three, the new relaxation without routing model RR yields the highest lower bounds in all 24 large size instances. Our proposed heuristic ALNS achieves an average worst-case optimality gap of 7.14% (4.15%) and an average solution time of 484seconds (40seconds) for large size (small size) instances.

For future research, one could envisage a richer SPIRP that has such problem characteristics as a heterogeneous vehicle fleet, maximum tour durations, multiple collection facilities, and stochastic rates of waste oil accumulation at the source nodes.

@&#ACKNOWLEDGMENT@&#

The authors would like to acknowledge the constructive comments and suggestions of two anonymous referees on the initial draft of this paper. They are also grateful to Dr. Richard Wong for a new objective function in the relaxation without routing model, which significantly tightened the lower bounds of the test instances.


                     
                        
                           
                              
                              
                                 
                                    
                                       Pseudo code of the ALNS algorithm for SPIRP
                                    
                                 
                                 
                                    
                                       1: All weights are set to 1 and all scores are set to 0.
                                 
                                 
                                    
                                       2: s
                                       ←initial solution
                                 
                                 
                                    
                                       3: s
                                       best
                                       ←
                                       s
                                    
                                 
                                 
                                    
                                       4: θ
                                       ←
                                       θ
                                       start
                                    
                                 
                                 
                                    
                                       5: 
                                          while
                                        
                                       iterations
                                       ⩽50,000 
                                          or
                                        
                                       time
                                       ⩽3600seconds
                                 
                                 
                                    
                                       6: 
                                       s′←
                                       s
                                    
                                 
                                 
                                    
                                       7: Select a move using the roulette-wheel mechanism based on the weights of the current phase j.
                                 
                                 
                                    
                                       8: Apply the move to s′ and update the number of times it is used.
                                 
                                 
                                    
                                       9: 
                                       
                                          if
                                        
                                       
                                       f(s′)<
                                       f(s) 
                                          then
                                       
                                    
                                 
                                 
                                    10: 
                                       s
                                       ←
                                       s′
                                 
                                 
                                    11: 
                                       
                                          if
                                        
                                       
                                       f(s)<
                                       f(s
                                       
                                          best
                                       ) 
                                          then
                                       
                                    
                                 
                                 
                                    12: 
                                       
                                       s
                                       
                                          best
                                       
                                       ←
                                       s
                                    
                                 
                                 
                                    13: 
                                       Increase the performance score of the selected move by σ
                                       1.
                                 
                                 
                                    14: 
                                       
                                          else
                                       
                                    
                                 
                                 
                                    15: 
                                       Increase the performance score of the selected move by σ
                                       2;
                                 
                                 
                                    16: 
                                       
                                          end if
                                       
                                    
                                 
                                 
                                    17: 
                                       
                                          else
                                       
                                    
                                 
                                 
                                    18: 
                                       
                                          if
                                       
                                       
                                       s′ is accepted by the simulated annealing criterion 
                                          then
                                       
                                    
                                 
                                 
                                    19: 
                                       
                                       s
                                       ←
                                       s′
                                 
                                 
                                    20: 
                                       Increase the performance score of the selected move by σ
                                       3.
                                 
                                 
                                    21: 
                                       
                                       
                                          end
                                        
                                       if
                                    
                                 
                                 
                                    22: 
                                       
                                          end
                                        
                                       if
                                    
                                 
                                 
                                    23: 
                                       
                                          if
                                        the end of the segment, 200 iterations, is reached 
                                          then
                                       
                                    
                                 
                                 
                                    24: 
                                       Update the weights of all moves and reset their scores.
                                 
                                 
                                    25: 
                                       
                                          end
                                        
                                       if
                                    
                                 
                                 
                                    26: 
                                       θ
                                       ←
                                       ϕ
                                       ×
                                       θ;/∗ update of the cooling temperature ∗/
                                    
                                 
                                 
                                    27: 
                                       
                                          end
                                        
                                       if
                                    
                                 
                                 
                                    28: Every 200 iterations, perform intraroute 2-Opt, intraroute 3-Opt, interroute 2-Opt, interroute 1-1-1 rotation, interroute 1-0 move, interroute 1-1 and 2-2 exchanges to improve the route.
                                 
                                 
                                    29: 
                                          end
                                        
                                       while
                                    
                                 
                                 
                                    30: 
                                          return
                                        
                                       s
                                       
                                          best
                                       
                                    
                                 
                              
                           
                        
                     
                  

@&#REFERENCES@&#

