@&#MAIN-TITLE@&#Illumination invariant optical flow using neighborhood descriptors

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Optical flow approach robust towards illumination changes and texture variability.


                        
                        
                           
                           Accurate multiscale TV-l1 approach for both small and large displacements.


                        
                        
                           
                           Accurate results for very different scenes with constant algorithm parameters.


                        
                        
                           
                           High performance was obtained on the Middlebury, KITTI and MPI Sintel databases.


                        
                        
                           
                           The algorithm enabled mosaicing of endoscopic images under different modalities.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Optical flow

Neighborhood descriptors

Bilateral filtering

Image registration

Endoscopic image mosaicing

@&#ABSTRACT@&#


               
               
                  Total variational (TV) methods using l
                     1-norm are efficient approaches for optical flow determination. This contribution presents a multi-resolution TV-l
                     1 approach using a data-term based on neighborhood descriptors and a weighted non-local regularizer. The proposed algorithm is robust to illumination changes. The benchmarking of the proposed algorithm is done with three reference databases (Middlebury, KITTI and MPI Sintel). On these databases, the proposed approach exhibits an optimal compromise between robustness, accuracy and computation speed. Numerous tests performed both on complicated data of the reference databases and on challenging endoscopic images acquired under three different modalities demonstrate the robustness and accuracy of the method against the presence of large or small displacements, weak texture information, varying illumination conditions and modality changes.
               
            

@&#INTRODUCTION@&#

Dense optical flow estimation has gained an immense interest in the field of computer vision since last few decades. It has been successfully used in various applications like object detection [1,2], image segmentation [3,4], structure from motion [5,6], image registration [7–11] and image mosaicing [12–14]. In general, optical flow algorithms are supposed to mimic human visual perception by estimating the motion of objects and/or of complete scene parts. However, robust optical flow computation is challenging due to strong scene variability in terms of texture, illumination conditions, topology differences, local deformations, large displacements and occlusions. In addition, artifacts caused by the image acquisition conditions like the blur caused by camera motion and the defocus or refocus of the lens foster these challenges and lead to an inaccurate estimation of the optical flow field. Therefore, obtaining a dense and accurate optical flow field under challenging scene and image acquisition conditions is still an open problem in computer vision.

It is beyond the scope of this paper to present an overview on the entire dense optical flow methods. We have therefore mainly focused on illumination invariant methods and the methods that are based on non-local regularization for the accurate estimation of optical flow fields.

The majority of dense optical flow algorithms are motivated by the foundation work of Horn and Schunck [15]. This method uses a variational framework that minimizes an energy including a data-fidelity term and a regularizer. The data-term is formulated as a brightness constancy assumption (BCA) which means that the degree of similarity between two pixels or regions depends on their intensity likeness. This classical data-term has been successfully used when the brightness constancy assumption is fulfilled [7,8,16,17]. However, in many scenes with varying illumination conditions this assumption does not hold true. This may occur in both classical photography (where local or global illumination changes appear in images due to shadows, camera viewpoint changes, moving objects in the scene or day light variations) and in medical images (for example, due to vignetting artifacts, organ specularity and different image acquisition protocols). Some algorithms [9,18,19] use a gradient constancy assumption (GCA) as a complementary term along BCA to deal with illumination changes between image pairs. Ali et al. [20,21] introduced a structure constancy assumption (SCA) integrated with the BCA assumption in the data-term. Structure estimates of the objects are used in the latter approaches using eigenvalue information from Hessian images. Ali et al. in  [22] used 2nd order Riesz wavelet transform for enhancing the edge structures and used a diffusion tensor to relax the strict structure based data-term. A non-local filtering was used in their optical flow estimation algorithm for robustly preserving the edge pixels.

Efforts have also been made in preserving the motion discontinuities along the object boundaries. Due to the quadratic nature of its regularizer and data-term, the classical Horn–Schunck model [15] does not preserve flow discontinuities along the edges and is unable to handle outliers in the data-term. Most recent approaches [8,9,16–20,23] use l
                        1-penalization for both the data term and the regularization term. The l
                        1 data fidelity term is robust to outliers and the non-smooth regularizer allows for flow discontinuities along the edges. However, the preservation of flow discontinuities along the edges can still be improved. Wedel et al. [17] performed a structure–texture decomposition of images to allow for discontinuities along the edges. This decomposition is based on the Rudin–Osher–Fatemi (ROF) model proposed in [24] for image denoising. Werlberger et al. [25] suggested to replace the isotropic TV-regularization with an image driven anisotropic Huber-regularizer. A non-local smoothing approach using the bilateral filtering was directly integrated in the regularization term in [23,26]. Sun et al. [27,28] proposed a similar approach, using non-local cues for a heuristic median filtering based approach for refining optical flow fields. Such non-local weight uses 3 different correlation measures, namely: spatial, color and occlusion of a pixel of interest with respect to the neighboring pixels.

In many real scenes, it is important to model a data-term which is invariant to illumination changes. A major drawback of the data-term modeling of most of the TV-approaches lies in their inability to accurately estimate optical flow field in image pairs with large illumination variability. The recent trend in optical flow field computation is estimation of flow fields in real scenes with large illumination changes. This is also the aim of this contribution.

@&#RELATED WORK@&#

In the literature, self-similarity patterns have been successfully used for handling illumination variations [23,26]. Nearest neighbor fields (NNF) using PatchMatch [29] for optical flow estimation was used by [30] for handling large displacements. However, due to the non-convex formulation and integration of several steps like outlier rejection, multi-label graph-cut and fusion, this NNF based model [30] is computationally expensive. A fast and parallelizable patch based minimization problem using zero-mean normalized cross-correlation (ZNCC) as a matching cost (data-term) between the patches was formulated in [23]. Coarse-to-fine energy minimization strategy was used for handing large displacements. A similar approach using truncated ZNCC was also formulated by Werlberger et al. [26]. It has been shown in [23] that the ZNCC based matching cost is more robust to illumination changes in comparison to the brightness constancy assumption (BCA).

The method in [31] (MLDP) proposed an illumination robust approach by modifying the local directional pattern [32] that uses binary feature descriptors (8-bit descriptors) as matching cost. The author used weighted median filtering for refining the flow vectors similar to [27]. However, the results of the MLDP method in [31] showed that it is sensitive to large change in multiplicative factor and gamma correction factor (these parameters are also defined at the beginning of Section 5 in Eq. (24)). In the literature, the census transform (census-T) and the rank transform (rank-T) have been proven to be the most robust methods in case of illumination changes. However, their invariance to illumination behavior comes with a compromise in the accuracy [33]. Both of these methods are based on the signatures obtained from the ordering of the intensity values in a patch of neighboring pixels. In both transforms, originally proposed by Zabih and Woodfill [34], there is a loss of information when either the rank of the pixels (in rank-T) or a binary signature of the patch around the pixels (in census-T) are stored. Demetz et al. [35] proposed to use a novel complete rank transform (CRT) which possess more local image information and maintain the illumination invariance property of original rank or census transform. Classical patch-based data terms, such as the Census-T, fail in dealing with the scale changes due to the strong changes in their local appearance. Ranftl et al. [36] proposed a scale-invariant census descriptor by sampling the radial stencils with different radii.

The goal of this paper is to propose a non-local TV algorithm (NLTV) that is robust to illumination changes. The proposed method uses a descriptor matching cost and a non-local regularizer. The descriptors are based on the self-similarity measure of each pixel with respect to their neighboring pixels. The cost is built such that most of the information about a pixel is retained. Such descriptors are computed at each level of a multi-resolution pyramid and then used in a coarse-to-fine energy minimization strategy to handle large displacements.

Our main contribution in this paper includes: (1) the use of neighborhood descriptors as a data-term in the l
                        1 optimization scheme. These descriptors are created within a defined search-space demonstrating their self-similarity property. A matching cost is established to compute such descriptors. (2) Integration of these descriptor matching in a first-order primal dual scheme using NLTV regularization, and (3) the use of three well-known public optical flow datasets to benchmark the proposed algorithm. Several tests on images acquired under difficult imaging conditions and scene variability have also been done. This provides an additional support to our claim for improved robustness of our algorithm.

The paper is organized as follows: Section 2 gives the details on creating neighborhood descriptors, describes the data-term formulation, integrates the bilateral filtering technique into the regularizer and proposes a minimization scheme that is parallelizable using primal-dual approach in convex optimization. Section 3 gives an overview of the proposed optical flow algorithm using neighborhood descriptors (ROF-NND). In Section 4, we benchmark the ROF-NND algorithm with the publicly available Middlebury [37], KITTI [38] and MPI Sintel [39] flow benchmarks. Section 5 demonstrates robustness tests of the algorithm to illumination changes and gives a comparison to some illumination invariant methods proposed in the literature. Section 6 is used to confirm the accuracy and robustness of the proposed algorithm with respect to large displacements. In Section 7, we test the ability of our proposed optical flow method for image mosaicing in the context of difficult medical application (endoscopy). Finally, Section 8 concludes the paper.

This section details the different aspects of the variational optical flow approach proposed in this paper. After an introduction highlighting the interest of n-dimensional normalized neighborhood descriptors (NND) used as the data-term in an optical flow computation, we focus on three major parts of the method, namely, (i) the linearization of the data-term based on n-dimensional NND, (ii) the regularization of the flow field with classical bilateral filtering and (iii) the first-order primal-dual approach for the minimization of the data-energy constrained with the non-local regularization.

Data-terms in variational approaches are based on either classical BCA alone or GCA complementing the classical BCA. Such data-terms however do not allow for robust and accurate optical flow computation when strong illumination changes arise. The census-T and the rank-T are robust to illumination changes but usually suffer from information loss in the matching cost. As a result, they are less accurate than many of the accurate dense optical flow methods. Neighborhood descriptors (NDs) are used in order to reach a balance between robustness to illumination changes and optical flow accuracy. Such a descriptor holds self-similarity property of images.

Self-similarity of an image can be computed as the sum of square differences (SSD) between the two patches of the same size. A central patch is first defined with a neighborhood window then n-connected neighborhood patches are extracted by centering the same window on these 
                           
                              n
                              −
                           
                        connected pixels of the window. Below we have explained with diagrams, the steps used to establish this self-similarity property for building NDs.

NDs are vectors computed for a n-connected neighborhood centered at pixel x. The principle of the neighborhood descriptors is illustrated in Fig. 1
                        . As sketched in Fig. 1(a), a neighborhood window 
                           W
                         is associated with each pixel x. For simplicity, we have used a square window 
                           W
                         of size 
                           
                              2
                              k
                              +
                              1
                              ×
                              2
                              k
                              +
                              1
                           
                         (i.e. with 
                           
                              
                                 (
                                 2
                                 k
                                 +
                                 1
                                 )
                              
                              2
                           
                         pixels and a connectivity 
                           
                              n
                              =
                              {
                              
                                 
                                    (
                                    2
                                    k
                                    +
                                    1
                                    )
                                 
                                 2
                              
                              −
                              1
                              }
                              ,
                           
                         ∀k ≥ 1). So, for a given pixel x of image 
                           
                              I
                              (
                              x
                              )
                              ∈
                              Ω
                              :
                              Ω
                              ⟶
                              R
                              ,
                           
                         centered at window 
                           W
                         (dark blue dot in Fig. 1(a)), there is an n-connectivity associated with it (represented by the light blue dots in Fig. 1(b) for 
                           
                              n
                              =
                              8
                           
                        ). As an example, if 
                           
                              k
                              =
                              1
                              ,
                           
                         then 
                           W
                         will be of size 3 × 3 and 
                           
                              {
                              
                                 x
                                 1
                              
                              ,
                              
                                 x
                                 2
                              
                              ,
                              …
                              ,
                              
                                 x
                                 8
                              
                              }
                           
                         are the neighborhood pixels of x in 
                           W
                         as shown in Fig. 1(b), where a patch 
                           
                              P
                              i
                           
                         is associated with each light blue dot. These patches 
                           
                              P
                              i
                           
                         are centered on the pixels 
                           
                              
                                 x
                                 i
                              
                              ∈
                              W
                           
                        . Fig. 1(b) (on the right) represents patch 
                           
                              
                                 P
                                 3
                              
                              ,
                           
                         centered on x
                        3 which has 8 neighbors 
                           
                              p
                              
                                 
                                    x
                                    3
                                 
                              
                              j
                           
                         with j ∈ [1, 8]. The neighborhood windows 
                           W
                         and patches Pi
                         have the same size and contain an identical n number of neighbors. 
                           
                              {
                              
                                 p
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 1
                              
                              ,
                           
                        ...,
                           
                              
                                 p
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 j
                              
                              ,
                           
                        ..., 
                           
                              
                                 p
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 n
                              
                              
                                 }
                              
                           
                         with j ∈ [1, n] are the neighborhood pixels in patch 
                           
                              P
                              i
                           
                        . Fig. 1(c) and 1(d) illustrates the shift between window 
                           W
                         and the two patches 
                           
                              P
                              3
                           
                         and 
                           
                              P
                              5
                           
                         respectively. Now, for computing the similarity measure 
                           
                              C
                              
                                 P
                                 i
                              
                           
                         between the window 
                           W
                         centered on x in image I(x) and the shifted versions represented by patches 
                           
                              P
                              i
                           
                         centered on x
                        
                           i
                         in I(x), we estimate the sum of squared differences between the grey-levels of corresponding pixels in 
                           W
                         and 
                           
                              P
                              i
                           
                        . This correspondence between neighbors of 
                           W
                         and 
                           
                              P
                              i
                           
                         is illustrated by the parallel arrows in Fig. 1(c) and (d). Mathematically, the similarity measure of window 
                           W
                         and patch 
                           
                              P
                              i
                           
                         can be written as:

                           
                              (1)
                              
                                 
                                    
                                    
                                       C
                                       
                                          P
                                          i
                                       
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          j
                                          =
                                          0
                                       
                                       n
                                    
                                    
                                       
                                          (
                                          I
                                          
                                             (
                                             
                                                x
                                                j
                                             
                                             )
                                          
                                          −
                                          I
                                          
                                             (
                                             
                                                p
                                                
                                                   x
                                                   i
                                                
                                                j
                                             
                                             )
                                          
                                          )
                                       
                                       2
                                    
                                    ,
                                    
                                    with
                                    
                                    
                                       x
                                       j
                                    
                                    ∈
                                    W
                                    
                                    and
                                    
                                    
                                       p
                                       
                                          
                                             x
                                             i
                                          
                                       
                                       j
                                    
                                    ∈
                                    
                                       P
                                       i
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 x
                                 0
                              
                              
                                 (
                                 =
                                 x
                                 )
                              
                           
                         and 
                           
                              
                                 p
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 0
                              
                              
                                 (
                                 =
                                 
                                    x
                                    i
                                 
                                 )
                              
                           
                         are the center pixels in the window 
                           W
                         of image I(x) and patch 
                           
                              P
                              i
                           
                         of the shifted image I(x
                        
                           i
                        ) respectively. The 
                           
                              C
                              
                                 P
                                 i
                              
                           
                         values can be physically interpreted as follows: it can be seen in Eq. (1) that each 
                           
                              C
                              
                                 P
                                 i
                              
                           
                         relates to the mean grey-level variation in a direction defined by the pixels in 
                           W
                         and 
                           
                              P
                              i
                           
                         (centered at x and 
                           
                              
                                 x
                                 i
                              
                              =
                              
                                 p
                                 
                                    
                                       x
                                       i
                                    
                                 
                                 0
                              
                           
                         respectively). When these grey-level variations correspond to the object edges or texture in different directions (e.g. 8 directions for 
                           
                              n
                              =
                              8
                           
                         in Fig. 1), a set of 
                           
                              C
                              
                                 P
                                 i
                              
                           
                        -values can be seen as a local structure information measured at the pixel of interest x.

A non-negative monotonically decreasing Gaussian function, similar to the one used by Perona and Malik [40] for anisotropic diffusion, is used to normalize the neighborhood descriptors in the range [0, 1]:

                           
                              (2)
                              
                                 
                                    
                                    
                                       
                                          C
                                       
                                       
                                          P
                                          i
                                       
                                       
                                          
                                          ′
                                       
                                    
                                    
                                       (
                                       x
                                       )
                                    
                                    =
                                    
                                    
                                       exp
                                       
                                          −
                                          
                                             
                                                
                                                   C
                                                   
                                                      P
                                                      i
                                                   
                                                
                                                
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             
                                                σ
                                                
                                                   x
                                                
                                                2
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              σ
                              
                                 x
                              
                              2
                           
                         is the local measure of the mean change in grey value information in the 4-connected neighborhood pixels based on SSD between the neighborhood window 
                           W
                         and the 4-shifted patches. We define this connectivity as 
                           
                              k
                              =
                              0
                           
                         and with 4-possible patch shifts i.e., at 
                           
                              {
                              
                                 x
                                 1
                              
                              ,
                              
                                 x
                                 2
                              
                              ,
                              
                                 x
                                 3
                              
                              ,
                              
                                 x
                                 4
                              
                              }
                              ∈
                              W
                              ,
                           
                         the mean of the local variation at a point x can be computed as:

                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                σ
                                                x
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      1
                                                      4
                                                   
                                                   
                                                      ∑
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      4
                                                   
                                                   
                                                      ∑
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      n
                                                   
                                                   
                                                      
                                                         (
                                                         I
                                                         
                                                            (
                                                            
                                                               x
                                                               j
                                                            
                                                            )
                                                         
                                                         −
                                                         I
                                                         
                                                            (
                                                            
                                                               p
                                                               
                                                                  x
                                                                  i
                                                               
                                                               j
                                                            
                                                            )
                                                         
                                                         )
                                                      
                                                      2
                                                   
                                                   )
                                                
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        with x
                        0 and 
                           
                              p
                              
                                 x
                                 i
                              
                              0
                           
                         being the centers of the original image I(x) and the shifted image I(x
                        
                           i
                        ) respectively.

In Fig. 2
                        , a 4-connected neighborhood of a 3 × 3 window centered at pixel x is taken and is shown in light blue which will result in 4-patches (patch 
                           
                              P
                              3
                           
                         shown for x
                        3, i.e. shifted pixel on the top). This connectivity is fixed for the calculation of σ
                        
                           x
                         used in Eq. (2). The mean SSD between pixels for the fixed 3 × 3 window with the four patches can be computed locally at each pixel of interest x by using Eq. (3). σ
                        
                           x
                         value is computed for only 4-connections in a fixed 3 × 3 window, i.e., along horizontal and vertical directions of the images, while descriptors 
                           
                              C
                              
                                 P
                                 i
                              
                           
                         are built with n number of connectivity usually greater than 4.

In the case of strong global illumination or strong artifacts like specular reflections in an image, an increase in connectivity of neighboring pixels could have an adverse effect on local image structures or edge information. So, a local σ
                        
                           x
                         value (relating to a variance measure) computed with a 4-connectivity in the original image is used for the normalization of the neighborhood descriptors 
                           
                              C
                              
                                 P
                                 i
                              
                           
                        . This is independent of the size of neighboring window 
                           W
                         used to form the descriptors. As a result, the effect of strong illumination (both local or global) in the estimated 
                           
                              C
                              
                                 P
                                 i
                              
                           
                        s for a given window 
                           W
                         is reduced. Thus the significance of using σ
                        
                           x
                         is that at the edge pixels in the proximity of x, σ
                        
                           x
                         value is stronger and hence it will increase the response of the function 
                           
                              
                                 
                                    C
                                 
                                 
                                    P
                                    i
                                 
                                 
                                    
                                    ′
                                 
                              
                              
                                 (
                                 x
                                 )
                              
                           
                         in Eq. (2) favoring the more contrasted edges over less contrasted ones.

The n-dimensional normalized neighborhood descriptor vector 
                           
                              
                                 
                                    D
                                    a
                                    NND
                                 
                                 →
                              
                              
                                 (
                                 I
                                 ,
                                 x
                                 ,
                                 n
                                 )
                              
                           
                         computed for pixel x of image I(x) is thus given as:

                           
                              (4)
                              
                                 
                                    
                                    
                                       
                                          D
                                          a
                                          NND
                                       
                                       →
                                    
                                    
                                       (
                                       I
                                       ,
                                       x
                                       ,
                                       n
                                       )
                                    
                                    =
                                    
                                       (
                                       
                                          C
                                          
                                             P
                                             1
                                          
                                          
                                             
                                             ′
                                          
                                       
                                       
                                          (
                                          x
                                          )
                                       
                                       ,
                                       …
                                       ,
                                       
                                          C
                                          
                                             P
                                             i
                                          
                                          
                                             
                                             ′
                                          
                                       
                                       
                                          (
                                          x
                                          )
                                       
                                       
                                          )
                                          ,
                                          …
                                          ,
                                          
                                             C
                                             
                                                P
                                                n
                                             
                                             
                                                
                                                ′
                                             
                                          
                                          
                                             (
                                             x
                                             )
                                          
                                          )
                                       
                                       )
                                    
                                    .
                                 
                              
                           
                        In Eq. (4) each value 
                           
                              
                                 
                                    C
                                 
                                 
                                    P
                                    i
                                 
                                 
                                    
                                    ′
                                 
                              
                              
                                 (
                                 x
                                 )
                              
                              ,
                              i
                              ∈
                              
                                 [
                                 1
                                 ,
                                 n
                                 ]
                              
                           
                         represents a component of the n-dimensional neighborhood descriptor vector 
                           
                              
                                 D
                                 a
                                 NND
                              
                              →
                           
                        .

The effect of NND is illustrated on a part of RubberWhale image of the Middlebury training dataset [37] having shadowed areas (in red rectangles of Fig. 3
                        ). Fig. 3(b) and (c) gives the neighborhood descriptor images respectively computed for the window and patch center pairs (x, x
                        7) and (x, x
                        8) following the neighborhood numbering convention in Fig. 1. Thus, the pixel values in images of Fig. 3(b) (c) correspond to the vector components NND(I, x, 7) and NND(I, x, 8) respectively for 
                           
                              k
                              =
                              1
                           
                         (i.e. Fig. 3(b) has edge information in the diagonal direction, while Fig. 3(c) has edge information in the vertically upward direction). It can be observed in Fig. 3(b) and (c) that each neighborhood descriptor has different information which is dependent upon their gradient and that each NND component has its own response also according to the structure (texture or object edge) and their orientation. A Gaussian function used to compute the NND descriptors decreases the sensitivity of the effect of both strong uniform and non-uniform illuminations in an image in different directions of the neighborhood pixels x
                        
                           i
                        ’s. It can be seen in the red rectangles of Fig. 3(b) and (c) that the shadow has only a weak impact on these two NND components. As a consequence, when comparing the content of the red rectangles in Fig. 3(e) and (f), the flow field obtained by including the NND in the data-cost is very close to the ground truth optical flow (see Fig. 3(d)). For both the results NLTV has been used as the regularizer. A remarkable improvement can be seen for NND descriptors (refer Fig. Fig. 3(f)) over the classical BCA data-term (refer Fig. 3(e)).

As also confirmed by the results in Sections 4–6, the proposed neighborhood descriptors used in data-terms exhibit simultaneously several interesting properties (brightness, gradient and structure constancy) providing invariance to illumination changes and increased accuracy relative to many TV-l
                        1 based approaches in the literature. The advantage of NND over census-T can be explained as follows. The census-T is based on binary signatures giving for each pixel an information about the orientation of the gradient in a given neighborhood, whereas NND vectors include gradient information in several directions for each pixel. Unlike the census-T, NND vectors hold actually a structure information which leads to a detailed description of image regions around pixels of interest. Similarly, NND vectors include more detailed information than the Rank-T and the CRT methods. Indeed, such rank transform compute local description based on the comparison of a pixel with a surrounding neighborhood region. In contrary, NND vectors are determined by comparing two neighborhood regions (not only pixels) for all possible orientations in the local neighborhood (see Fig. 1). This again leads to a richer set of information.

The neighborhood descriptors are separately computed for the source (Is
                        ) and target (It
                        ) images and are used in the data-term for optimizing the flow field, i.e. for superimposing the homologous pixels of Is
                         and It
                        . The coordinates of the superimposed pixels are x in source Is
                         and 
                           
                              x
                              +
                              
                                 u
                                 x
                              
                           
                         in target It
                        , where u
                        
                           x
                         is the displacement vector at x. Instead of directly using grey-level values, the proposed total variational scheme aims at minimizing the absolute difference of the corresponding n-dimensional vectors computed for Is
                        (x) and 
                           
                              
                                 I
                                 t
                              
                              
                                 (
                                 x
                                 +
                                 
                                    u
                                    x
                                 
                                 )
                              
                           
                        .

Let 
                           
                              u
                              =
                              
                                 (
                                 u
                                 ,
                                 v
                                 )
                              
                              :
                              Ω
                              →
                              
                                 R
                                 2
                              
                           
                         be the flow field between Is
                         and It
                         with their corresponding descriptors 
                           
                              
                                 
                                    D
                                    a
                                    NND
                                 
                                 →
                              
                              
                                 (
                                 
                                    I
                                    s
                                 
                                 ,
                                 x
                                 ,
                                 n
                                 )
                              
                           
                         and 
                           
                              
                                 
                                    D
                                    a
                                    NND
                                 
                                 →
                              
                              
                                 (
                                 
                                    I
                                    t
                                 
                                 ,
                                 x
                                 +
                                 
                                    u
                                    x
                                 
                                 ,
                                 n
                                 )
                              
                           
                         respectively. In Eq. (5), the absolute difference is computed between the corresponding components NND(Is
                        , x, i) and 
                           
                              D
                              a
                              NND
                              (
                              
                                 I
                                 t
                              
                              ,
                              x
                              +
                              
                                 u
                                 x
                              
                              ,
                              i
                              )
                           
                         of the NND. As in Section 2.1, n (dimension of the NND vector) is also the number of pixels both in the neighborhood patch 
                           P
                         centered on x in Is
                         and in the corresponding patch with pixels 
                           
                              x
                              +
                              
                                 u
                                 x
                              
                           
                         in image It
                        .

                           
                              (5)
                              
                                 
                                    
                                       E
                                       
                                          d
                                          a
                                          t
                                          a
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          x
                                          ∈
                                          Ω
                                       
                                    
                                    
                                       {
                                       
                                          1
                                          n
                                       
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          n
                                       
                                       ∣
                                       NND
                                       
                                          (
                                          
                                             I
                                             s
                                          
                                          ,
                                          x
                                          ,
                                          i
                                          )
                                       
                                       −
                                       NND
                                       
                                          (
                                          
                                             I
                                             t
                                          
                                          ,
                                          x
                                          +
                                          
                                             u
                                             x
                                          
                                          ,
                                          i
                                          )
                                       
                                       ∣
                                       }
                                    
                                 
                              
                           
                        This gives a robust data-term which will suppress the outliers due to various imaging artifacts and scene ambiguities. This increased robustness is due to the presence of a large quantity of information contained in each descriptor. A small mismatch in one descriptor will not penalize the whole data-term thus resulting in a more accurate and robust data-term than the classical approaches [9,15,25]. Eq. (5) has to be linearized using first-order Taylor’s series expansion to permit a convex formulation. After linearization, we can rewrite the energy associated with the data-term as:

                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             E
                                             
                                                d
                                                a
                                                t
                                                a
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   x
                                                   ∈
                                                   Ω
                                                
                                             
                                             {
                                             
                                                1
                                                n
                                             
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             ∣
                                             NND
                                             
                                                (
                                                
                                                   I
                                                   s
                                                
                                                ,
                                                x
                                                ,
                                                i
                                                )
                                             
                                             −
                                             NND
                                             
                                                (
                                                
                                                   I
                                                   t
                                                
                                                ,
                                                x
                                                +
                                                
                                                   u
                                                   
                                                      x
                                                   
                                                   0
                                                
                                                ,
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             +
                                             ∇
                                             NND
                                             
                                                (
                                                
                                                   I
                                                   t
                                                
                                                ,
                                                x
                                                +
                                                
                                                   u
                                                   
                                                      x
                                                   
                                                   0
                                                
                                                ,
                                                i
                                                )
                                             
                                             
                                                (
                                                
                                                   u
                                                   x
                                                
                                                −
                                                
                                                   u
                                                   
                                                      x
                                                   
                                                   0
                                                
                                                )
                                             
                                             ∣
                                             }
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              u
                              
                                 x
                              
                              0
                           
                         is a close approximation of u
                        
                           x
                         and 
                           
                              ∇
                              =
                              
                                 
                                    [
                                    
                                       ∂
                                       
                                          ∂
                                          x
                                       
                                    
                                    ,
                                    
                                       ∂
                                       
                                          ∂
                                          y
                                       
                                    
                                    ]
                                 
                                 T
                              
                           
                        .

The data-term in the total variational approach is attached to an optical flow regularizer [7,9,15]. The role of the regularizer is to enforce a continuous optical flow in image regions with homogeneous pixel values, while preserving flow field discontinuities at edge pixels. The discontinuities in the flow field can be robustly preserved when scene information are incorporated in the regularizer. This technique is well established as non-local regularization [23,26,27,36,41]. The regularization term in our total variational scheme uses an approach similar to that proposed in [27]:

                           
                              (7)
                              
                                 
                                    
                                    
                                       E
                                       s
                                    
                                    
                                       (
                                       u
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          x
                                          ∈
                                          Ω
                                          ,
                                       
                                    
                                    
                                       ∑
                                       
                                          ∀
                                          
                                             x
                                             ′
                                          
                                          ≠
                                          x
                                          ∈
                                          
                                             N
                                             x
                                          
                                       
                                    
                                    
                                       w
                                       x
                                       
                                          x
                                          ′
                                       
                                    
                                    ∣
                                    
                                       u
                                       x
                                    
                                    −
                                    
                                       u
                                       
                                          x
                                          ′
                                       
                                    
                                    ∣
                                    .
                                 
                              
                           
                        In Eq. (7), 
                           
                              w
                              x
                              
                                 x
                                 ′
                              
                           
                         is the weight assigned to each pixel x′ in the neighborhood 
                           
                              N
                              x
                           
                         of pixels centered on x. The weight 
                           
                              w
                              x
                              
                                 x
                                 ′
                              
                           
                         is defined as the correlation entity based on (i) the spatial distance and (ii) the color distance of the center pixel x with the neighborhood pixels 
                           
                              
                                 x
                                 ′
                              
                              ∈
                              
                                 N
                                 x
                              
                           
                        :

                           
                              (8)
                              
                                 
                                    
                                    
                                       w
                                       x
                                       
                                          x
                                          ′
                                       
                                    
                                    =
                                    
                                       e
                                       
                                          −
                                          
                                             ∣
                                             x
                                             −
                                             
                                                x
                                                ′
                                             
                                             
                                                ∣
                                                2
                                             
                                          
                                          /
                                          
                                             2
                                             
                                                β
                                                1
                                                2
                                             
                                          
                                       
                                    
                                    .
                                    
                                       e
                                       
                                          −
                                          
                                             ∣
                                             I
                                             
                                                (
                                                x
                                                )
                                             
                                             −
                                             I
                                             
                                                (
                                                
                                                   x
                                                   ′
                                                
                                                )
                                             
                                             
                                                ∣
                                                2
                                             
                                          
                                          /
                                          
                                             2
                                             
                                                β
                                                2
                                                2
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        where {β
                        1, β
                        2} are normalization factors and I(x) is the color vector in the CIE Lab color space. Edges are preserved since, for further away pixels (
                           
                              ∣
                              x
                              −
                              
                                 x
                                 ′
                              
                              ∣
                           
                         large) and for pixels which are not in the same region as the pixel of interest x (large color differences 
                           
                              ∣
                              I
                              
                                 (
                                 x
                                 )
                              
                              −
                              I
                              
                                 (
                                 
                                    x
                                    ′
                                 
                                 )
                              
                              ∣
                           
                        ), the value of weight 
                           
                              w
                              x
                              
                                 x
                                 ′
                              
                           
                         will be small. The weight 
                           
                              w
                              x
                              
                                 x
                                 ′
                              
                           
                         will thus prevent from smoothing of the edge pixels.

The error in the data-term in Eq. (6) is constrained with the smoothness term of Eq. (7) and has to be minimized in order to obtain the displacement vectors between image pairs (Is, It
                        ). The Energy 
                           
                              E
                              (
                              u
                              )
                           
                         to be minimized can be represented by following classical equation:

                           
                              (9)
                              
                                 
                                    E
                                    
                                       (
                                       u
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          x
                                          ∈
                                          Ω
                                       
                                    
                                    λ
                                    
                                       E
                                       
                                          d
                                          a
                                          t
                                          a
                                       
                                    
                                    
                                       (
                                       u
                                       )
                                    
                                    +
                                    
                                       E
                                       s
                                    
                                    
                                       (
                                       u
                                       )
                                    
                                 
                              
                           
                        In Eq. (9), the minimization of 
                           
                              E
                              (
                              u
                              )
                           
                         leads to the flow field u between source Is
                         and target It
                         and the weight λ sets the trade-off between the data and the regularization term (setting the value of λ is discussed at end of Section 3). The minimization of the energy function 
                           
                              E
                              (
                              u
                              )
                           
                         using a primal-dual model in convex optimization has been well established in the literature of variational optical flow [7,8,42]. However, some key steps relating to the minimization of 
                           
                              E
                              (
                              u
                              )
                           
                         in Eq. (9) are discussed below which adapts such a primal-dual optimization for the proposed energy formulation incorporating non-local regularization.

With the positive scalar weights 
                           
                              w
                              x
                              
                                 x
                                 ′
                              
                           
                         in the neighborhood 
                           
                              
                                 N
                                 x
                              
                              ,
                           
                         the non-local regularizer 
                           
                              
                                 E
                                 s
                              
                              
                                 (
                                 u
                                 )
                              
                           
                         in Eq. (7) is convex in u. Since the flow field at each pixel u
                        
                           x
                         has to be evaluated for all other pixels in the given neighborhood 
                           
                              
                                 N
                                 x
                              
                              ,
                           
                         we introduce a linear operator 
                           
                              K
                              :
                              
                                 R
                                 
                                    2
                                    .
                                    ∣
                                    Ω
                                    ∣
                                 
                              
                              →
                              
                                 R
                                 
                                    2
                                    .
                                    ∣
                                    Ω
                                    ∣
                                    ∣
                                    
                                       N
                                       x
                                    
                                    ∣
                                 
                              
                           
                         defined as [23]:

                           
                              (10)
                              
                                 
                                    K
                                    u
                                    =
                                    
                                       (
                                       
                                          
                                             
                                                
                                                   
                                                      u
                                                      1
                                                   
                                                   −
                                                   
                                                      u
                                                      
                                                         1
                                                         ,
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                ⋯
                                             
                                             
                                                ⋯
                                             
                                             
                                                
                                                   
                                                      u
                                                      
                                                         ∣
                                                         Ω
                                                         ∣
                                                      
                                                   
                                                   −
                                                   
                                                      u
                                                      
                                                         1
                                                         ,
                                                         1
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                ⋮
                                             
                                             
                                                ⋱
                                             
                                             
                                             
                                                ⋮
                                             
                                          
                                          
                                             
                                                ⋮
                                             
                                             
                                             
                                                ⋱
                                             
                                             
                                                ⋮
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      u
                                                      1
                                                   
                                                   −
                                                   
                                                      u
                                                      
                                                         m
                                                         ,
                                                         n
                                                      
                                                   
                                                
                                             
                                             
                                                ⋯
                                             
                                             
                                                ⋯
                                             
                                             
                                                
                                                   
                                                      u
                                                      
                                                         ∣
                                                         Ω
                                                         ∣
                                                      
                                                   
                                                   −
                                                   
                                                      u
                                                      
                                                         m
                                                         ,
                                                         n
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       )
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              
                                 {
                                 
                                    u
                                    
                                       1
                                       ,
                                       1
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    u
                                    
                                       m
                                       ,
                                       n
                                    
                                 
                                 }
                              
                              ∈
                              
                                 N
                                 x
                              
                              
                                 (
                              
                              
                                 N
                                 x
                              
                              →
                              
                                 R
                                 
                                    m
                                    ×
                                    n
                                 
                              
                           
                        ) represents the neighborhood flow vectors around each pixel of flow field u and subscript 
                           
                              {
                              1
                              ,
                              …
                              ,
                              ∣
                              Ω
                              ∣
                              }
                           
                         in u is the array of pixel indexes of the estimated flow field u itself. The smoothness term can now be represented as a function of 
                           
                              K
                              u
                           
                         since the smoothness spans in all the neighboring pixels so 
                           
                              
                                 E
                                 s
                              
                              
                                 (
                                 u
                                 )
                              
                           
                         can be re-written as 
                           
                              
                                 E
                                 s
                              
                              
                                 (
                                 K
                                 u
                                 )
                              
                              ,
                           
                         such that:

                           
                              (11)
                              
                                 
                                    
                                       E
                                       s
                                    
                                    
                                       (
                                       K
                                       u
                                       )
                                    
                                    =
                                    
                                       ∑
                                       
                                          x
                                          ∈
                                          Ω
                                       
                                    
                                    
                                       ∑
                                       
                                          
                                             x
                                             ′
                                          
                                          ∈
                                          
                                             N
                                             x
                                          
                                       
                                    
                                    ∣
                                    
                                       w
                                       x
                                       
                                          x
                                          ′
                                       
                                    
                                    
                                       (
                                       
                                          u
                                          x
                                       
                                       −
                                       
                                          u
                                          
                                             x
                                             ′
                                          
                                       
                                       )
                                    
                                    ∣
                                    .
                                 
                              
                           
                        Thus, the minimization problem of Eq. (9) can be redefined as,

                           
                              (12)
                              
                                 
                                    
                                    
                                       min
                                       u
                                    
                                    
                                       {
                                    
                                    
                                       λ
                                       
                                          E
                                          
                                             d
                                             a
                                             t
                                             a
                                          
                                       
                                       
                                          (
                                          u
                                          )
                                       
                                       +
                                       
                                          E
                                          s
                                       
                                       
                                          
                                             (
                                             K
                                             u
                                             )
                                          
                                          }
                                       
                                    
                                 
                              
                           
                        with Edata
                         and Es
                         as the convex functions. Due to the l
                        1-norm on the data-term and the regularizer, the individual energies are not differentiable. This makes the minimization of Eq. (12) non-trivial. Additionally, the presence of the linear operator K in the smoothness term increases computational complexity. We have therefore used a duality based approach [8] and reformulated Eq. (12) into a saddle-point min-max problem as below:

                           
                              (13)
                              
                                 
                                    
                                    
                                       min
                                       u
                                    
                                    
                                       max
                                       q
                                    
                                    
                                       {
                                    
                                    
                                       λ
                                       
                                          E
                                          
                                             d
                                             a
                                             t
                                             a
                                          
                                       
                                       
                                          (
                                          u
                                          )
                                       
                                       +
                                       
                                          〈
                                          K
                                          u
                                          ,
                                          q
                                          〉
                                       
                                       −
                                       
                                          E
                                          s
                                          *
                                       
                                       
                                          
                                             (
                                             q
                                             )
                                          
                                          }
                                       
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              E
                              s
                              *
                           
                         is the convex conjugate of the convex function Es
                        , 
                           
                              q
                              ∈
                              
                                 R
                                 
                                    2
                                    ∣
                                    Ω
                                    ∣
                                    ∣
                                    
                                       N
                                       x
                                    
                                    ∣
                                 
                              
                           
                         is the dual variable which lies in the closed convex set 
                           
                              S
                              q
                           
                         and ⟨.⟩ is the dot product. Eq. (13) is convex in u and concave in dual variable q. The convex set 
                           
                              S
                              q
                           
                         is defined as non-negative entries of the bilateral filter weights in Eq. (8):

                           
                              (14)
                              
                                 
                                    
                                    
                                       S
                                       q
                                    
                                    =
                                    
                                       {
                                       
                                          w
                                          x
                                          
                                             x
                                             ′
                                          
                                       
                                       ,
                                       ∀
                                       x
                                       ∈
                                       Ω
                                       ,
                                       ∀
                                       
                                          x
                                          ′
                                       
                                       ∈
                                       N
                                       }
                                    
                                 
                              
                           
                        The relaxed proximal point algorithm (PPA) [43–45] is used in order to solve the saddle-problem in Eq (13). Let τ and α be the positive scalars such that 
                           
                              τ
                              α
                              =
                              ∥
                              
                                 K
                                 T
                              
                              K
                              ∥
                           
                         and 
                           
                              (
                              
                                 u
                                 ^
                              
                              ,
                              
                                 q
                                 ^
                              
                              )
                           
                         be the initial estimates (usually set to zero), and then the iteration scheme can be divided into following steps [45]:

                           
                              I. PPA step:

The primal-variable solution is given by:

                                    
                                       (15)
                                       
                                          
                                             
                                                
                                                   u
                                                   ˜
                                                
                                                k
                                             
                                             =
                                             
                                                argmin
                                                
                                                   u
                                                   ∈
                                                   
                                                      S
                                                      u
                                                   
                                                
                                             
                                             
                                                {
                                                λ
                                                
                                                   E
                                                   
                                                      d
                                                      a
                                                      t
                                                      a
                                                   
                                                
                                                
                                                   (
                                                   u
                                                   )
                                                
                                                +
                                                
                                                   τ
                                                   2
                                                
                                                ∥
                                                u
                                                −
                                                
                                                   [
                                                   
                                                      u
                                                      k
                                                   
                                                   −
                                                   
                                                      1
                                                      τ
                                                   
                                                   
                                                      K
                                                      T
                                                   
                                                   
                                                      q
                                                      k
                                                   
                                                   ]
                                                
                                                
                                                   ∥
                                                   2
                                                   2
                                                
                                                }
                                             
                                             ,
                                          
                                       
                                    
                                 where 
                                    
                                       S
                                       u
                                    
                                  is the convex set of u, 
                                    
                                       
                                          u
                                          ˜
                                       
                                       k
                                    
                                  is the current estimate, 
                                    
                                       
                                          u
                                          k
                                       
                                       =
                                       
                                          u
                                          ^
                                       
                                    
                                  is an initial estimate, u is the update values (usually null at the beginning of the algorithm) and KT
                                  is the adjoint linear operator. Eq. (15) can be alternatively written in the form of proximal operator as:

                                    
                                       (16)
                                       
                                          
                                             
                                             
                                                
                                                   u
                                                   ˜
                                                
                                                k
                                             
                                             =
                                             
                                                
                                                   prox
                                                
                                                u
                                             
                                             
                                                (
                                                
                                                   u
                                                   k
                                                
                                                −
                                                
                                                   1
                                                   τ
                                                
                                                
                                                   K
                                                   T
                                                
                                                
                                                   
                                                      q
                                                      ˜
                                                   
                                                   k
                                                
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 And the dual-variable estimate 
                                    
                                       
                                          q
                                          ˜
                                       
                                       k
                                    
                                  is given by:

                                    
                                       (17)
                                       
                                          
                                             
                                             
                                                
                                                   q
                                                   ˜
                                                
                                                k
                                             
                                             =
                                             
                                                argmin
                                                
                                                   q
                                                   ∈
                                                   
                                                      S
                                                      q
                                                   
                                                
                                             
                                             
                                                {
                                                λ
                                                
                                                   E
                                                   s
                                                   *
                                                
                                                
                                                   (
                                                   q
                                                   )
                                                
                                                +
                                                
                                                   α
                                                   2
                                                
                                                ∥
                                                q
                                                −
                                                
                                                   [
                                                   
                                                      q
                                                      k
                                                   
                                                   +
                                                   
                                                      1
                                                      α
                                                   
                                                   K
                                                   
                                                      (
                                                      2
                                                      
                                                         
                                                            u
                                                            ˜
                                                         
                                                         k
                                                      
                                                      −
                                                      
                                                         u
                                                         k
                                                      
                                                      )
                                                   
                                                   ]
                                                
                                                
                                                   ∥
                                                   2
                                                   2
                                                
                                                }
                                             
                                             .
                                          
                                       
                                    
                                 The proximal operator form for Eq. (17) is:

                                    
                                       (18)
                                       
                                          
                                             
                                             
                                                
                                                   q
                                                   ˜
                                                
                                                k
                                             
                                             =
                                             
                                                
                                                   prox
                                                
                                                q
                                             
                                             
                                                (
                                                
                                                   q
                                                   k
                                                
                                                +
                                                
                                                   1
                                                   α
                                                
                                                K
                                                
                                                   
                                                      u
                                                      ˜
                                                   
                                                   
                                                      k
                                                      +
                                                      1
                                                   
                                                
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 
                              

II. Relaxation step (update):

This step is used to generate the new iterate 
                                    
                                       u
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                 :

                                    
                                       (19)
                                       
                                          
                                             
                                             
                                                u
                                                
                                                   k
                                                   +
                                                   1
                                                
                                             
                                             =
                                             
                                                u
                                                k
                                             
                                             −
                                             γ
                                             
                                                (
                                                
                                                   u
                                                   k
                                                
                                                −
                                                
                                                   
                                                      u
                                                      ˜
                                                   
                                                   k
                                                
                                                )
                                             
                                             .
                                          
                                       
                                    
                                 In our case, 
                                    
                                       γ
                                       =
                                       2
                                    
                                  in Eq. (19) so, 
                                    
                                       
                                          u
                                          
                                             k
                                             +
                                             1
                                          
                                       
                                       =
                                       2
                                       
                                          
                                             u
                                             ˜
                                          
                                          k
                                       
                                       −
                                       
                                          u
                                          k
                                       
                                    
                                 .

Now, in order to minimize Eqs. (15) and (17) which are convex, first order optimality condition is used (i.e. 
                           
                              
                                 
                                    ∂
                                    
                                       
                                          u
                                          ˜
                                       
                                       k
                                    
                                 
                                 
                                    ∂
                                    u
                                 
                              
                              =
                              0
                           
                         and 
                           
                              
                                 
                                    ∂
                                    
                                       
                                          p
                                          ˜
                                       
                                       k
                                    
                                 
                                 
                                    ∂
                                    q
                                 
                              
                              =
                              0
                           
                        ). This results in following equations for Eqs. (15) and (17) respectively:

                           
                              (20)
                              
                                 
                                    
                                    λ
                                    
                                       
                                          ∂
                                          
                                             E
                                             
                                                d
                                                a
                                                t
                                                a
                                             
                                          
                                       
                                       
                                          ∂
                                          u
                                       
                                    
                                    +
                                    τ
                                    
                                       (
                                       u
                                       −
                                       
                                          u
                                          k
                                       
                                       )
                                    
                                    +
                                    
                                       K
                                       T
                                    
                                    
                                       q
                                       k
                                    
                                    =
                                    0
                                 
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                    
                                    α
                                    
                                       (
                                       q
                                       −
                                       
                                          q
                                          k
                                       
                                       )
                                    
                                    −
                                    K
                                    
                                       u
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                    =
                                    0
                                    .
                                 
                              
                           
                        Due to the non-differentiability of Edata
                        , we have done a thresholding step for solving u in Eq. (20) by re-defining the linear equation in Eq. (6). Suppose 
                           
                              d
                              :
                              =
                              NND
                              
                                 (
                                 
                                    I
                                    s
                                 
                                 ,
                                 x
                                 ,
                                 i
                                 )
                              
                              −
                              NND
                              
                                 (
                                 
                                    I
                                    t
                                 
                                 ,
                                 x
                                 +
                                 
                                    u
                                    
                                       x
                                    
                                    0
                                 
                                 ,
                                 i
                                 )
                              
                           
                         and 
                           
                              C
                              u
                              =
                              ∇
                              NND
                              
                                 (
                                 
                                    I
                                    t
                                 
                                 ,
                                 x
                                 +
                                 
                                    u
                                    
                                       x
                                    
                                    0
                                 
                                 ,
                                 i
                                 )
                              
                              
                                 (
                                 
                                    u
                                    x
                                 
                                 −
                                 
                                    u
                                    
                                       x
                                    
                                    0
                                 
                                 )
                              
                           
                         then Eq. (15) can be solved for u as:

                           
                              (22)
                              
                                 
                                    
                                    u
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            u
                                                            ˜
                                                         
                                                         k
                                                      
                                                      −
                                                      
                                                         1
                                                         τ
                                                      
                                                      λ
                                                      C
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      if
                                                      
                                                      C
                                                      u
                                                      +
                                                      d
                                                      >
                                                      
                                                         1
                                                         τ
                                                      
                                                      λ
                                                      ∣
                                                      C
                                                      
                                                         ∣
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            u
                                                            ˜
                                                         
                                                         k
                                                      
                                                      +
                                                      
                                                         1
                                                         τ
                                                      
                                                      λ
                                                      C
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      if
                                                      
                                                      C
                                                      u
                                                      +
                                                      d
                                                      <
                                                      −
                                                      
                                                         1
                                                         τ
                                                      
                                                      λ
                                                      ∣
                                                      C
                                                      
                                                         ∣
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     u
                                                                     ˜
                                                                  
                                                                  k
                                                               
                                                               −
                                                               
                                                                  1
                                                                  τ
                                                               
                                                               λ
                                                               C
                                                               d
                                                            
                                                         
                                                         
                                                            
                                                               1
                                                               +
                                                               
                                                                  1
                                                                  τ
                                                               
                                                               λ
                                                               ∣
                                                               C
                                                               
                                                                  ∣
                                                                  2
                                                               
                                                            
                                                         
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        In Eq. (22), 
                           
                              
                                 
                                    u
                                    ˜
                                 
                                 k
                              
                              =
                              
                                 u
                                 k
                              
                              −
                              
                                 
                                    
                                       K
                                       T
                                    
                                    
                                       q
                                       k
                                    
                                 
                                 τ
                              
                           
                        . Note that we solve Eq. (22) for u which is actually the current value that has to be determined. u can be represented by 
                           
                              
                                 u
                                 ˜
                              
                              k
                           
                         which is used to update 
                           
                              u
                              
                                 k
                                 +
                                 1
                              
                           
                         in Eq. (19). Since the estimation of u (refer Eq. (20)) is dependent on the dual variable q, it is important to solve Eq. (21) for q. The dual variable q lies in the closed convex set 
                           
                              S
                              q
                           
                         so for each point there exists a unique solution for q in 
                           
                              S
                              q
                           
                         (i.e. closest to the optimal solution of q in Euclidean sense). The point-wise projection Pr. of the gradient solution in Eq. (21) onto the convex set 
                           
                              S
                              q
                           
                         is:

                           
                              (23)
                              
                                 
                                    
                                    
                                       q
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                    =
                                    
                                       
                                          Pr
                                          .
                                       
                                       
                                          S
                                          q
                                       
                                    
                                    
                                       {
                                       σ
                                       K
                                       
                                          u
                                          
                                             k
                                             +
                                             1
                                          
                                       
                                       +
                                       
                                          q
                                          k
                                       
                                       }
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              σ
                              =
                              
                                 1
                                 α
                              
                           
                         and the positive scalars τ in Eq. (20) and σ in Eq. (23) take the same value: 0.22.

A global overview of the coarse to fine approach is presented in Algorithm 1
                     . The source and target images, Is
                      and It
                     , are downsampled from level (scale) 
                        
                           j
                           =
                           1
                        
                      to 
                        
                           j
                           =
                           
                              N
                              
                                 s
                                 c
                                 a
                                 l
                                 e
                                 s
                              
                           
                        
                     . The value of the downsampling factor αscale
                      is set to 0.7. The number of downsampled scales are such that the height and width of images 
                        
                           I
                           s
                           j
                        
                      and 
                        
                           I
                           t
                           j
                        
                      remains greater or equal to 16 pixels at a given scale j. The normalized n-dimensional vectors 
                        
                           
                              NND
                              →
                           
                           
                              (
                              
                                 I
                                 s
                              
                              ,
                              x
                              ,
                              n
                              )
                           
                        
                      and 
                        
                           
                              
                                 D
                                 a
                                 NND
                              
                              →
                           
                           
                              (
                              
                                 I
                                 t
                              
                              ,
                              x
                              ,
                              n
                              )
                           
                        
                      are computed for all pixels x of source image Is
                      and target image It
                      (see Eqs. (1)–(5) in Section 2.1) for all the scales. At scale j, the source and target images and their corresponding NND vectors are represented as 
                        
                           
                              I
                              s
                              j
                           
                           ,
                        
                     
                     
                        
                           
                              I
                              t
                              j
                           
                           ,
                        
                     
                     
                        
                           
                              
                                 D
                                 a
                                 
                                    NND
                                    j
                                 
                              
                              →
                           
                           
                              (
                              
                                 I
                                 s
                              
                              ,
                              x
                              ,
                              n
                              )
                           
                        
                      and 
                        
                           
                              
                                 
                                    NND
                                 
                                 j
                              
                              →
                           
                           
                              (
                              
                                 I
                                 t
                              
                              ,
                              x
                              ,
                              n
                              )
                           
                        
                      respectively.

The energy minimization using the primal-dual approach in convex optimization is done in a coarse-to-fine strategy. The start of this minimization (coarsest level) is done with the initialization of 
                        
                           
                              
                                 u
                                 ˜
                              
                              
                                 N
                                 s
                                 c
                                 a
                                 l
                                 e
                                 s
                              
                           
                           =
                           0
                        
                      (i.e. primal solution of Eq. (20)). Similarly, the dual variable p in Eq. (23) is also set to zero for this level. The flow field at finer levels 
                        
                           u
                           
                              j
                              −
                              1
                           
                        
                      are computed as the up-scaled version of the previous scale j giving an initial flow fields to the finer pyramid levels. This flow field obtained at each level j (u
                     
                        j
                     ) is then used to warp the source image 
                        
                           I
                           s
                           j
                        
                      and superimpose it on target 
                        
                           I
                           t
                           j
                        
                     . The data-terms at each level j is computed using Eq. (6). Also, at each level j, a non-local weight 
                        
                           w
                           
                              x
                           
                           
                              x
                              ′
                           
                        
                      using Eq. (8) is computed exploiting the CIE-Lab representation of 
                        
                           I
                           s
                           j
                        
                      and 
                        
                           I
                           i
                           j
                        
                     . This is done to perform a non-local regularization of the flow field in the primal-dual energy minimization scheme.

The formulated l
                     1 total variation energy in Eq. (10) is solved in Niter
                      iterations using the primal-dual approach in convex optimization presented in Section 2.4. The flow field u
                     
                        j
                      updated in this way is then used to warp 
                        
                           I
                           s
                           j
                        
                      on target 
                        
                           I
                           t
                           j
                        
                      and the l
                     1 variation energy in Eq. (10) is solved in the third warp to obtain the final flow field u
                     
                        j
                      at level j. This flow field is then upsampled to level 
                        
                           j
                           −
                           1
                        
                      by the re-scaling factor αscale
                     . A median filter of size [3, 3] is applied during each upscaling procedure to smooth the obtained flow field which will result in minimization of interpolation error.

The parameter values in Algorithm 1 are the following: an 8-connected neighborhood (
                        
                           k
                           =
                           1
                        
                      and 
                        
                           n
                           =
                           8
                        
                     ) and patches 
                        P
                      with a size of 3 × 3 were used to compute the 8-dimensional neighborhood vectors required for the data-term in Eq. (9). The energy of the non-local regularizer in Eq. (9) was dependent on the neighborhood weights 
                        
                           w
                           
                              x
                           
                           
                              x
                              ′
                           
                        
                      having following parameter values in Eq. (8): 
                        
                           
                              β
                              1
                           
                           =
                           5
                        
                      and 
                        
                           
                              β
                              2
                           
                           =
                           7
                        
                     . These values were set experimentally on Middlebury dataset for which they provided better accuracy than at other tested values. The relative importance of the data-term with respect to the regularizer is adjusted with 
                        
                           λ
                           =
                           90
                        
                     . The value of parameters τ in Eq. (20) and σ in Eq. (23) were both set to 0.22 for solving iteratively the l
                     1-variation energy in Eq. (9) using the primal-dual approach presented in Section 2.4. It is worth noting that these parameter values were kept constant for all the tests presented in Sections 4–7 involving different image datasets. The method of parameter adjustment (i.e. the choice of the parameter values) is detailed in Section 4.1.

Three reference datasets were used to benchmark the proposed algorithm. These publicly available datasets include 1) the Middlebury flow dataset [37], 2) the KITTI flow dataset [38] and 3) the MPI Sintel dataset [39]. These databases cover a large variability in scene (such as illumination conditions), image quality (sharp or blurred textures) and in displacement (small/large flow vector magnitudes).

Three quantitative measures [37,38] of the optical flow quality were employed both to adjust the parameters listed in the algorithm overview (Section 3) and to benchmark the algorithm. The first and the second error measures are the average angular error (AAE) in degrees and the average end-point error (AEPE) computed with all pixels. The third measure corresponds to the percentage of bad pixels (% BP) in the non-occluded areas (Out-Noc). The Middlebury flow database benchmark is based on both the AAE and AEPE values for all pixels, while the KITTI flow benchmark is based on % BP in the non-occluded areas (Out-Noc) at 3 pixels AEPE threshold (% BP3). The MPI Sintel benchmark consists of clean and final pass sets, the latter being more challenging. Algorithms are evaluated for this dataset based on the overall AEPE in the whole test sequence for each pass separately.

The aim of this paper is to highlight the robustness of our method (ROF-NND algorithm) for small displacements, large displacements, different textures and illumination varying scenes. To do so, it was compared with two types of algorithms, namely: baseline TV-l
                     1 algorithms suited for small displacement [8,9,17] and TV-l
                     1 algorithms that are robust to illumination changes and that have convincing performance for large displacements [23,31,35,36,46]. However, our main focus is on illumination robustness of the compared methods.

This section presents the method used to adjust three important parameters of the proposed algorithm, namely the size of neighborhood window 
                           W
                         and that of patches 
                           P
                         (both determined by the same k, refer Section 2.1) leading to a robust data-term, the λ-parameter (relative importance between the data-term and the regularizer) ensuring an accurate flow estimation and the downsampling factor αscale
                         in the multiresolution approach enabling computation of optical flow for large displacements.

The Middlebury data-base consists of various image types (synthetic images, hidden textures in real scenes, indoor and outdoor scenes, etc.) combining moderate optical flow displacements and large texture variations in image pairs. The texture variability of these images is particularly useful for adjusting the λ-parameter in order to achieve the optical flow accuracy for a large range of texture variations. Using eight training image pairs (with known ground truth) of this dataset we experimentally verified that with λ ∈ [90–120] the AEPE and AAE errors were the least and close to respectively 0.30 pixels and 3.54°. This accuracy in a large weight interval suggests that the λ parameter in our algorithm can be set constant for a large number of image types (this will be confirmed in the results of Sections 4–6 in which very different image types are treated with 
                           
                              λ
                              =
                              90
                           
                        ).

Among the parameters of the data-term to be set, the size of the neighborhood patch 
                           P
                         and the window 
                           W
                         has the greatest impact on the robustness of the method. The size of 
                           P
                         and 
                           W
                         depend on k since an area of 
                           
                              (
                              2
                              k
                              +
                              1
                              )
                              ×
                              (
                              2
                              k
                              +
                              1
                              )
                           
                         pixels leads to NND vector with a dimension of 
                           
                              [
                              
                                 
                                    (
                                    2
                                    k
                                    +
                                    1
                                    )
                                 
                                 2
                              
                              −
                              1
                              ]
                           
                         when k is > 0. For the particular case of 
                           
                              k
                              =
                              0
                              ,
                           
                         a four-connected neighborhood is considered (i.e. 4 dimensional NND vectors). In order to determine the optimal value of the parameter k, tests were performed on the Middlebury training dataset (with synthetic and hidden texture images), on the KITTI training dataset with illumination changes (image pairs
                           
                              #
                              11
                              ,
                              #
                              15
                              ,
                              #
                              44
                              ,
                              #
                              74
                           
                        ) and on the large displacement image pairs 
                           
                              (
                              #
                              117
                              ,
                              #
                              144
                              ,
                              #
                              147
                              ,
                              #
                              181
                              )
                           
                         of the same dataset. It can be observed from Fig. 4
                        (a) for the Middlebury dataset, when k lies in [0, 3], the smallest AEPE and AAE errors are obtained for 
                           
                              k
                              =
                              1
                              ,
                           
                         
                        i.e. for 8-dimensional NND and a patch size of 3 × 3. The errors are the highest for a 4-connected neighborhood (
                           
                              k
                              =
                              0
                           
                        ). For the KITTI dataset (refer to Fig. 4(b)), in the image pairs with illumination changes the % of bad-pixels does not change significantly from 
                           
                              k
                              =
                              1
                           
                         to 
                           
                              k
                              =
                              3
                           
                        . However, for large displacements in the same dataset, the % of bad-pixels is 5% less with 
                           
                              k
                              =
                              2
                           
                         and 7% less for 
                           
                              k
                              =
                              3
                           
                         in comparison to the same error when k is set to 1. But, this accuracy is obtained at the expense of high computational time as shown by the plot in Fig. 4(c). The computational time grows significantly with the increase of the value of k (refer to Fig. 4(c)). With the above observations, it becomes clear that choosing an 8-connected neighborhood (i.e. 
                           
                              k
                              =
                              1
                           
                        ) leads to the best compromise between accuracy and computational time.

In the proposed multi-resolution approach, the down-sampling factor αscale
                         has to be chosen such that large displacements can be treated while maintaining the optical flow errors in acceptable limits. Fig. 5
                         illustrates the impact of the value of αscale
                         ∈ [0.5, 0.9] on the optical flow computation speed and accuracy using one of the large displacement image pairs of the KITTI dataset (average values are given for pair numbers 117, 144, 147 and 181). For 
                           
                              
                                 α
                                 
                                    s
                                    c
                                    a
                                    l
                                    e
                                 
                              
                              =
                              0.6
                              ,
                           
                         the average percentage of bad pixels is over 30%. This error grows significantly when αscale
                         decreases. However, for 
                           
                              
                                 α
                                 
                                    s
                                    c
                                    a
                                    l
                                    e
                                 
                              
                              =
                              0.7
                           
                         this percentage value is 24.17 % and remains almost constant when αscale
                         increases. This experiment shows that 
                           
                              
                                 α
                                 
                                    s
                                    c
                                    a
                                    l
                                    e
                                 
                              
                              =
                              0.7
                           
                         leads to the best compromise between the number of down-sampled images in the coarse-to-fine approach and the percentage of erroneous pixels. When αscale
                         increases, the computation time grows exponentially while the improvement of the percentage of erroneous pixels remains small. The values plotted in Fig. 5 show that, when going from 
                           
                              
                                 α
                                 
                                    s
                                    c
                                    a
                                    l
                                    e
                                 
                              
                              =
                              0.9
                           
                         to 
                           
                              
                                 α
                                 
                                    s
                                    c
                                    a
                                    l
                                    e
                                 
                              
                              =
                              0.7
                              ,
                           
                         the computation times is divided by 3 while the percentage of bad pixels only increases by 1%

The Middlebury dataset [37] consists of 8 image pairs having known ground truth (GT) in the training dataset and 8 image pairs without available flow field ground truth in the test dataset (evaluated online). These sets include data with the hidden texture, synthetic image and stereo pairs. Since this dataset was built for the estimation of small motion fields associated with varying texture conditions, it is interesting for robustness evaluation of the proposed algorithm for small displacements.

A visual representation of the results on 8 images of the Middlebury training dataset is shown in Fig. 6
                        . The algorithm is robust to both for hidden texture dataset (first row of images in Fig. 6) and for synthetic dataset (second row of images). Both AEPE and AAE are given in bracket below their color-code flow representation in Fig. 6. The small errors obtained for a standard dataset are a first indication of the accuracy of the proposed method.

An online benchmarking of the proposed algorithm was done with the Middlebury test dataset using the parameters given in Section 3. The performances of the proposed algorithm are compared to those of other approaches chosen to cover a large variety of TV-l
                        1 implementations. The overall average errors of the proposed algorithm (ROF-NND) and the chosen reference methods for 8-image pairs (available online) is given in Table 1
                        . The MDP-flow2 method [46] is on top of this chart with the least error among all the methods in comparison. However, this accuracy is obtained at the expense of the computational time (342 s is required to compute the flow field in Urban image pair). Most of the top performing algorithms (corr-flow [23], Classic-NL [28], MLDP [31] or OFH [47]) in Table 1 have high accuracy but exhibit a very high computational time. The proposed method (ROF-NND) gives a competitive result which is similar to that of the non-local approach of Werlberger et al. [26] while leading to a much smaller computational time (of only 10 s) in comparison to the most accurate algorithms. ROF-NND is more accurate than improved TV-l
                        1 approaches such as Aniso. Huber-L1 [25], TV-L1-improved [17] and HAOF [9]. Additionally, the proposed method also outperforms CRTflow method [35] which is based on complete rank transform.

The KITTI optical flow test dataset [38] consists of 194 color image pair obtained with a wide-view camera fixed on a moving vehicle. These image pairs have challenging characteristics of an outdoor scene like with illumination variability, large perspective changes, repeated texture patterns and with large displacements. The results obtained by the proposed optical flow algorithm for the outdoor scene were compared to those of other methods based on total variational approach and particularly suited for large displacements.

As seen in Table 2
                        , the NLTGV-SC method [36] which uses a second-order variant of the TGV based non-local regularization has the least BP3 percentage and AEPE: respectively 5.93% and 1.6 pixels for non-occluded image regions (Noc) and 11.96% and 3.8 pixels for image regions with occlusion (occ). This method uses a scale invariant census transform based approach. However, the NLTV-SC method using a first-order TV approach was mentioned in [36] to have a higher percentage of BP3 of 9.19%. Comparing the results of the latter method (NLTV-SC) with the proposed ROF-NND method in this paper is more relevant since both of these methods are based on TV-regularization. However, the results given for the NLTV-SC method give an idea of the performance of our method relative to TGV variants. The MLDP [31] and CRTflow [35] methods exhibit accurate results for the KITTI data-set. The proposed method with 
                           
                              k
                              =
                              2
                           
                         has only 10.44% of BP3 for non-occluded pixels (see Table 2) which is very competitive with the MLDP and the CRT-flow methods. Compared to the the proposed approach, the C-NL and C-NL-fast methods [27,28] lead to higher computational time and without improving the flow field accuracy (these methods have larger % of BP3 and AEPE). The fast edge preserving method [49] using plane-fitting for flow field refinement gives close to real-time performance on GPU while having an acceptable accuracy which is better than that of the classical HS implementation of Sun et al. [27]. The baseline TV-l
                        1 approaches are the least accurate ones with % of bad pixels above 30%.

The MPI Sintel dataset [39] consists of different image sequences. For our comparison we used the final pass sequences to benchmark the proposed algorithm on this complicated dataset. The 12 final pass sequences consist of image pairs with large displacements, specular reflections, blur due to camera defocus/refocus, motion blur and atmospheric effects such as fog and smoke. In Table 3
                        , three criteria were used to evaluate the algorithms: i) the overall average-end-point errors computed with all flow field vectors of the dataset (AEPE all), ii) the overall AEPE of pixels with displacement vectors in the [0, 10] pixel interval (s0–10) and in the [10, 40] pixel interval (s10–40) and iii) the runtime.

For all of these three criteria, the results in Table 3 show that the proposed method has better performance than the recent TV-l
                        1 baseline methods [25,27,28,48]. It can be noted in the Table 3 that the second-order variant of TGV (NLTGV-SC method [36]) is no more the most accurate method in the comparison, in contrast to the KITTI benchmark. Moreover, for s0–10 (AEPE for small displacements), NLTGV-SC method has a large error of 1.587 pixles which is more than many other methods in the comparison Table 3. The NLTV-SC approach has slightly higher errors than the proposed method on this dataset. MLDP has the smallest overall AEPE of 8.287 pixels while Classic-NL-fast has the smallest AEPE for s0–10 (1.092) and Classic-NL has the least for s10–40 (1.113 pixels). The smallest overall AEPE of 8.287 pixels, the smallest AEPE for “small” displacements (s0-10) of 1.092 pixels and the least AEPE for “large” displacements (s10–40) of 1.113 pixels were recorded for the MLDP, the Classic-NL-fast and the Classic-NL methods respectively. The proposed method has no criterion with the smallest value, but when comparing its s0–10 (1.221 pixels) and s10–40 (4.7 pixels) errors to those of other methods it exhibits often the best results globally. The SimpleFlow approach [48] recorded the highest errors on this dataset with a value of 13.364 pixels for the overall AEPE.

The proposed algorithm has consistently performed well in comparison to the state-of-the-art methods on all the three publicly available benchmark datasets [37–39]. On the Middlebury test dataset, the proposed method has an overall AEPE of 0.39 pixels and an overall AAE of 3.81 pixels which are smaller than many baseline methods [9,17,25,28,35]. On the same dataset other methods are more accurate [23,26,46,47] than ours, but this performance is reached at the expense of computation time which is by far higher than that of the proposed approach.

On the KITTI data-set, recent top-level methods (MLDP [31], CRTflow [35] and NLTGV-SC [36]) were more accurate than the proposed method, but this accuracy is again obtained at the expense of computation speed: the MLDP method ([31], 160 s) is 8 times slower than our ROF-NDD method with 
                           
                              k
                              =
                              1
                           
                         (20 s), while the CRTflow ([35], 18 s) and the NLTGV-SC ([36], 16 s) methods require a GPU implentation to reach the CPU time of our CPU algorithm version. However, with 
                           
                              k
                              =
                              2
                              ,
                           
                         our method has an accuracy very close to the CRTflow method [35] but with an increased computational time of 50 s with a CPU implementation. It is to be noted that the CRTflow method [35] has much higher overall AEPE and overall AAE on Middlebury dataset than the proposed method. Moreover, the proposed method again performed better in comparison to the baseline TV-L1 methods [9,25,27,49].

For the KITTI images, the NLTGV-SC method [36] based on the second order variant of the TGV regularization was the most accurate one. But, on MPI sintel dataset, this method was not the top performing method. The overall AEPE of the NLTGV-SC method is 8.746 pixels. However, the same value obtained for its TV version (NLTV-SC) is 9.855 while the proposed method has an overall AEPE of 9.286 pixels only. MLDP [31] and MDP-flow2 [46] methods are the most accurate on the Sintel dataset. The proposed method gave more accurate results compared to many of other methods including the baseline methods [25,27,28,48].

From the benchmarking experiments performed on three standard datasets, we can conclude that our algorithm can efficiently handle illumination variations and scenes with large blur, local deformations and low textures with no compromise in computational speed (only 10 s for Urban image pair of Middlebury dataset, 30 s for KITTI dataset and 50 s for MPI Sintel dataset).

An evaluation of the proposed ROF-NDD method has been done with the image pair Grove2 of the Middlebury training dataset to compare its behavior to that of other self-similarity based approaches under changing illumination conditions. In Eq. (24), 
                        
                           I
                           
                              i
                              n
                           
                           i
                        
                      stands for the second image of the Grove pair, with i = R, G or B representing the red, green or blue color channel. Eq. (24) is used to compute an image 
                        
                           I
                           
                              o
                              u
                              t
                           
                           i
                        
                      simulating illumination changes as proposed in reference illumination robust optical flow contributions [31,33]. Parameter a > 0, m > 0 and γ > 0 correspond to an additive term, a multiplicative factor and a gamma correction respectively. The same parameter values are used for all channels.

                        
                           (24)
                           
                              
                                 
                                 
                                    I
                                    
                                       o
                                       u
                                       t
                                    
                                    i
                                 
                                 =
                                 u
                                 i
                                 n
                                 t
                                 8
                                 
                                    (
                                    255
                                    .
                                    
                                       
                                          (
                                          
                                             
                                                m
                                                .
                                                
                                                   I
                                                   
                                                      i
                                                      n
                                                   
                                                   i
                                                
                                                +
                                                a
                                             
                                             255
                                          
                                          )
                                       
                                       γ
                                    
                                    )
                                 
                                 ,
                              
                           
                        
                     In Eq. (24), uint8 represents the function converting a real value to an unsigned byte integer and the values of the channels of image 
                        
                           I
                           
                              i
                              n
                           
                           i
                        
                      and the simulated image 
                        
                           I
                           
                              o
                              u
                              t
                           
                           i
                        
                      are all in the [0, 255] interval. The flow field between the pair consisting of the non-modified image and the illumination modified image is computed for different values of parameters m, a and γ. Modified images 
                        
                           I
                           
                              o
                              u
                              t
                           
                           i
                        
                      are shown in Fig. 7
                     . Severe scene illumination changes can be observed in Fig. 7(b)–(d). However, the strongest change can be seen for the gamma correction (
                        
                           γ
                           =
                           3.5
                        
                     ) in Fig. 7(d).


                     Fig. 8
                      gives the error quantification of the proposed method compared to some recent illumination invariant dense optical flow methods [23,31,33]. The AEPE and AAE are plotted in Fig. 8 for each value of the additive term a, the multiplicative term m and the gamma correction γ. It can be observed that for the additive term (refer to Fig. 8(a) and (b)), all the methods are robust to such illumination changes which lead to a very small deviation of the errors when the value of a increases. However, such robustness is not observed for the MLDP method [31] when the multiplicative term m varies as shown in Fig. 8 (c) and (d). For this method, a large deviation can be noted for both the AEPE and AAE criteria at 
                        
                           m
                           =
                           {
                           0.6
                           ,
                           1.6
                           ,
                           1.8
                           ,
                           2.0
                           }
                        
                     . The accuracy of proposed method, the census transform [33] and the correlation flow approach [23] is not affected by the tested changes in m. However, for all methods, a strong impact of the gamma correction can be noticed for both the AEPE value in Fig. 8(e) and the AAE criterion in Fig. 8(f). While the proposed method has the least deviation in both the AEPE and AAE errors, the MLDP method has the highest deviation except for γ > 1.4 and γ < 0.8. For 
                        
                           γ
                           =
                           2.9
                           ,
                        
                      the AEPE and AAE errors of MLDP method reached almost 1 pixel and nearly 6 degrees respectively. The correlation flow and census-T methods are by far less affected by gamma changes than the MLDP approach, but still remain more affected than the proposed method.

The KITTI training data-set was used in order to examine the robustness of the proposed method exhibiting illumination changes in a real scenes. This set of images are reference data for validating the robustness against illumination changes 
                        2
                     
                     
                        2
                        
                           http://www.dagm.de/symposien/special-sessions/
                        
                     . Table 4
                      quantifies the accuracy (at a AEPE threshold of 3 pixels is classically used to determine both percentage of bad pixels and overall AEPE values) of numerous state-of-the-art algorithms and allows for a comparison with the proposed ROF-NDD method. It can be observed in Table 4 that the MLDP method (with an average of 21.03% of bad pixels) and the proposed ROF-NDD approach (25.16% of bad pixels in average) gave the most and the second most accurate results respectively for the illumination changes of the KITTI dataset sequences. Correlation flow [23] has an accuracy very close the proposed method, while the base-line methods [15] and [28] recorded higher average values for the percentage of bad pixel (47.32% and 29.7% respectively). The MLD-flow2 method [46], which has the smallest error in the Middlebury dataset, has also a much higher percentage of average BP3 and average AEPE (42.80%, 14.85 pixels) compared to the proposed method (25.16%, 6.68 pixels).

Classically, in order to handle large displacements in the scene, many algorithms (like variational approaches) use coarse-to-fine approaches. However, the accuracy of numerous algorithms still largely depends on their ability to handle scene variabilities at different scales. In the proposed approach, neighborhood descriptors were used so that the energy minimization is not only based on pixels value taken individually or locally in small image regions, but rather depends on extended neighborhood pixels information. Unlike, the census or rank based approaches where signatures are used for a local neighborhood, the neighborhood descriptors used in our approach are based on patch based similarity functions which are measured as patch distances between the window of a pixel of interest and all the patches obtained with all possible connectivity of this centered pixel (refer to Eq. (1)). This means that the descriptors hold the complete information of the pixel of interest with respect to its surrounding pixels. Moreover, a monotonically decreasing function is used further in Eq. (2)) to make the descriptors robust to outliers (like the ones caused by strong illumination variabilities).

Large displacement tests are performed with the KITTI data-set in order to observe the usefulness of the accuracy of the proposed descriptor as the data-term constrained with non-local regularization in the energy minimization scheme. The patch-size or neighborhood window (i.e. value of k) plays a significant role in obtaining improved accuracy due to the following reasons: 1) the increased patch-size will be able to handle occlusions efficiently and 2) in large displacements, constructing patches at each pyramid level will assist in handling largely displaced pixels. Our experiments showed that increasing the scale factor αscale
                      > 0.7 did not change the result much for large displacement sequences. The large displacement KITTI training dataset classically used in the literature allow for a comparison of the proposed approach with some well-known reference methods given in Table 5
                     .

As can be seen in Table 5, the proposed ROF-NND method with 
                        
                           k
                           =
                           2
                        
                      (i.e. with NND vectors of dimension 24) led to the best results in the comparison tests (the average bad-pixel percentage is 22.5% at an AEPE threshold of 3 pixels). However, increasing k also increases exponentially the computation time. It is noticeable in Table 5 that the proposed algorithm remains competitive when diminishing the neighborhood size to bring it to the value adjusted in Section 4.1 (
                        
                           k
                           =
                           1
                        
                     ) and systematically used in most of the tests with ROF-NND method. With 
                        
                           k
                           =
                           1
                           ,
                        
                      the average bad-pixel percentage of 23.35% put our method in the third place of the ranking given in Table 5. This accuracy is close to that of the MLDP method [31] resulting in an average percentage of BP3 of 23.32 %.

Visual results are presented in Fig. 9
                     . It can be observed in the error images that the MDP-flow2 approach [46] (MDP in Fig. 9) and the MLDP method [31] have numerous pixels in red indicating large AEPE errors. The proposed method (ROF-NND) has much smaller errors. The error diminishing can be observed in the AEPE image of the last (bottom) row including more blue pixels with small errors. In the AEPE bar charts given in the last column for the four methods, the blue and red colors again represent small and larger values respectively. It can be noticed that with the proposed approach (two last rows on the bottom) the number of occurrences of orange to red pixels (high end point errors) is lower than the MDP-flow2 approach [46] (second row from the top) and the MLDP method [31] (third row).

Image mosaicing is a useful approach for extending the field of view (FOV) of a scene. Registering consecutive images of a video-sequence is an unavoidable task for mosaic building. While for many scene types robust and accurate registration algorithms exist, this task remains a challenging problem for other scenes like medical endoscopy (see the work in [12–14,20,51,52] showing that image mosaicing using the images of video-sequences is still an open problem in medical endoscopy). The images of such scenes include strong texture variability, regions without textures, artifacts (e.g. specular reflection or blur), inhomogeneous scene illumination etc. The aim of this section is to show the potential of the proposed ROF-NND algorithm to compute the optical flow between such challenging endoscopic images. The determined flow fields are used to register consecutive images of the video-sequence [12,53] and to build mosaics by placing all images in a common coordinate system (e.g. that of the first image of the sequence).

In gastroscopy, an endoscope scans the inner epithelium of the stomach (see Fig. 10
                        ). Inflammations in the antrum region (aperture region corresponding to the junction of the stomach and the intestine) may be early signs of potential lesions which can notably degenerate into cancer. As visible in Fig. 10(a) and (b), a unique image only shows a part of the antrum. A large FOV (as that in Fig. 10(c)) facilitates diagnosis and examination traceability through mosaics screening and archiving. However, the major challenge is to register these images robustly as they are poorly textured and also affected by specular reflections indicated by rectangles in Fig. 10(c). The proposed algorithm is able to robustly register all the image pairs required to build the mosaic of the pyloric antrum region which is shown in Fig. 10(c). In order to facilitate the analysis of the quality of the registration, blending techniques were not applied during the placement of the registered images into the mosaic coordinate system. The images borders, which remain visible with this procedure, show that there is effectively no structure discontinuity, as required in visually coherent mosaics.

Lesion diagnosis on the inner bladder wall is done using the standard white light (WL) modality. Bladder image registration in WL modality (see Fig. 11
                        (a) and (c)) is challenging due to the high intra- and inter-patient texture variability, changing illumination conditions due to viewpoint changes, vignetting effects, motion blur and image defocus. Moreover, urologists or surgeons can also switch on a complementary fluorescence [54,55] (FL, see Fig. 11(b)) modality facilitating the detection of some lesion types imperceptible when using the WL modality. The texture and contrast of the FL and WL modalities are very different. Registering image pairs of these two modalities with the same optical flow algorithm having constant parameters is a real challenge.


                        Fig. 11(a) and (b) shows mosaics acquired under the WL and FL modalities and built by registering consecutive image pairs with the proposed ROF-NND algorithm which uses the parameter settings adjusted in Section 4.1 and given in algorithm 1 of Section 3. An additional mosaic is shown in Fig. 11(c) with visually large texture variability compared to the bladder texture presented in Fig. 11(a) under WL modality. No image discontinuity is perceptible in this mosaic, even for non-consecutive image pairs. The accuracy of the proposed optical flow method is visually validated at the places where blue arrows indicate continuity and alignment of structures in the mosaic. The green curve represents the trajectory of the registered image centers (i.e., the projection of the 3D endoscope trajectory into the mosaic plane).

In this article, we have formulated the data cost as l
                     1 minimization of self-similarity neighborhood descriptors between two images. Different self-similarity descriptors have been used in the past. However, either these methods are not exploited for their robustness against illumination changes or they are shown to achieve invariance to illumination changes at the expense of the algorithm accuracy. In this paper, we have used an accurate and robust NND descriptors in a total variational vectored energy minimization framework along with a non-local TV regularizer. Moreover, the proposed algorithm has been validated on three well-known flow benchmark datasets. Dedicated tests for accuracy and robustness check of the algorithm were done on complicated scene conditions which include severe illumination changes. The flexibility of the algorithm was demonstrated on large displacements. It has been shown that the method is robust in all these scene conditions and gives improved accuracy compared to the baseline variational methods. It is also competitive with regard to the most accurate methods in recent literature with most often less computational cost. An application to the mosaicing of low textured endoscopic datasets also validates the robustness and the accuracy of the proposed method. Our future work will consist in using a second-order variant of the TGV regularizer to constrain the proposed data-cost. In addition to that, we plan to use GPU programming in order to achieve faster computation of flow fields. We are also interested in doing extensive experimental analysis of the implemented methods on other complicated scenes such as underwater and aerial panoramic acquisitions.

This work is co-funded by the Agence nationale de la recherche (ANR) and the Conseil Régional de Lorraine (CRL) in the framework of CyPaM2 project (ANR-11-TECS-001).

@&#REFERENCES@&#

