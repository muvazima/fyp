@&#MAIN-TITLE@&#A column generation approach for solving the examination-timetabling problem


@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a student-centric ETP with improve exam spread by dynamically allowing more versions of exams.


                        
                        
                           
                           We propose two column generation algorithms to solve exam-timetabling problems.


                        
                        
                           
                           Both models include dynamic spreading of exams by using spreading costs.


                        
                        
                           
                           Second model has post-processing: either by heuristic or integer program(IP).


                        
                        
                           
                           Model 2 performs marginally better than Model 1, but is less scalable.


                        
                        
                           
                           Student spreading costs for existing data sets were improved at the cost of more exam versions.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Timetabling

Examination-timetabling problem

Column generation

Exam spreading

@&#ABSTRACT@&#


               
               
                  In this paper, we approach the Examination-Timetabling Problem (ETP) from a student-centric point of view. We allow for multiple versions of an exam to be scheduled to increase the spreading of exams for students. We propose two Column Generation (CG) algorithms. In the first approach, a column is defined as an exam schedule for every unique student group, and a Pricing Problem (PPs) is developed to generate these columns. The Master Program (MP) then selects an exam schedule for every unique student group. Instead of using branch-and-price, we heuristically select columns. In the second approach, a column consists of a mask schedule for every unique student group, and a PP is developed to generate the masks. The MP then selects the masks and schedules exams in the mask slots. We compare both models and perform a computational experiment. We solve the ETP at KU Leuven campus Brussels (Belgium) for the business engineering degree program and apply the models to two existing datasets from the literature.
               
            

@&#INTRODUCTION@&#

Examination timetabling is a recurring and time-consuming task in educational institutions (Qu, Burke, McCollum, Merlot, & Lee, 2008), and is defined as “the scheduling for the exams of a set of university courses, avoiding overlap of exams of courses having common students, and spreading the exams for the students as much as possible” (Schaerf, 1999). Examination timetabling has to deal with many requirements, which include: no clashes for students, a fair exam schedule with sufficient study time in between exams, preferences of lecturers, and availability of classrooms. Within those requirements, two types of constraints can be distinguished (Qu et al., 2008), namely soft and hard constraints. Some survey articles also define them as first-order and higher-order constraints (Schaerf, 1999) or primary and secondary constraints (Carter, 1986). Hard constraints (equivalent to first-order and primary constraints) are constraints that must be satisfied at all times. Soft constraints (equivalent to higher-order or secondary constraints) only need to be satisfied as much as possible. Qu et al. (2008) point out that the extent to which soft constraints are met, defines the quality of a timetable. This quality aspect is also the key difference between search and optimization problems as described by Schaerf (1999). Search problems only try to find a feasible solution by satisfying the hard constraints, while optimization problems try to find an optimized feasible solution. The main difference between the search and optimization problems is therefore the capability to incorporate soft constrains. This paper presents two models that handle the latter type of Examination-Timetabling Problems (ETPs). However, contrary to the definition by Schaerf (1999) and the examination-timetabling literature in general, many universities schedule several versions of the same exam to further satisfy the soft constraints. Multiple versions of the same exam are created (1) to ensure that students do not have two exams at the same time, and (2) to improve the exam spread. Our models incorporate a trade-off between multiple versions of exams and the soft constraints such as spreading.

The many requirements imposed on ETPs impede manual timetabling. Automated timetabling has therefore been a highly researched topic in operational research (Qu et al., 2008). However, ILP models of ETPs cannot be solved with modern-day computers, as the number of variables in the LP model is too large. On top of that, examination timetabling has been proven to be NP-complete when introducing certain characteristics (Cooper & Kingston, 1996). For example, imposing constraints concerning the equal spread of exams, or dealing with the many different students who have shared courses increases the complexity of the problem immensely.

This paper addresses the above issues from a more student-centric point of view. A trade-off function is used to create timetables for each student group separately, while trying to minimize extra exam versions being created. Existing methodologies schedule exams while trying to minimize the total spreading cost. We propose two algorithms that decompose the problem by using a Column Generation (CG) approach. Our first algorithm defines a column to be a complete examination timetable for every student group. The second algorithm defines a column to be a timetable containing examination time slots or mask slots without specifying the exams themselves. It constructs the final timetables by scheduling exams and taking the mask slots into account. The second model needs a post-processing step to construct the final timetables. The algorithms thus transfer a different part of the problem's complexity to the sub-problems. We compare both approaches in a computational experiment. We also apply both models to two existing datasets from the literature.

The remainder of this paper is organized as follows: in the second section, we state our problem description and link this to the existing literature. We also give a brief overview of the techniques used to solve the ETP. The third section presents our first CG approach and the fourth section our second. We report the results in the fifth section. The last section concludes the paper with the most important findings and with directions for future research.

In this section, we present the ETP and the existing methodologies. We focus on the requirements defined in well-known problems and on existing literature related to the application of CG to ETPs.

Educational institutions basically have two systems of offering classes to students. The first is the curriculum-based system in which the student follows a predefined curriculum for which the timetable has already been created (Demeester, Bilgin, De Causmaecker, & Van Den Berghe, 2012). The other system is a post-enrollment system, in which the timetables are produced after the students have selected their courses. In curriculum-based universities, it is easier to produce examination timetables because exams are only shared between several homogeneous groups. In post-enrollment universities, exams are shared between many different students who all have different curricula. European universities are typically a curriculum-based environment, but are incorporating more and more post-enrollment elements. Students follow a curriculum, but can make changes to their curriculum to widen their scope, to slow down or increase the pace, etc. In this setup, we aim to automate the examination timetabling, while optimizing exam spread for students and minimizing the number of times an exam is scheduled. For our problem setting, we define a unique curriculum as a set of exams for a unique student group. Exams in these sets can be shared across multiple unique curricula. If multiple students take the exact same set of exams, they form a unique student group. The group is indivisible, so exams are always scheduled for an entire student group. Multiple groups can take the exam at the same time, but this is not a requirement. Multiple versions of an exam are therefore possible. An exam version is an instance of an exam scheduled at a specific time slot. The number of versions is equal to the number of time slots for which the exam is planned.

The ETP is well known in the timetabling literature. Many articles in the proceedings of the PATAT (Practice and Theory on Automated Timetabling) conferences relate to this topic. Subsequently, a EURO (European Association of Operational Research) Working group on Automated TimeTabling (WATT) was established (Burke, Jackson, Kingston, & Weare, 1997). Qu et al. (2008) give an elaborate review of the problem and discuss several datasets: the Toronto dataset (a, b, c, d, and e), the Nottingham dataset (a and b), and the Melbourne dataset (I and II). An elaborate overview of the studies performed per type of problem is also provided. In 2007, PATAT and WATT issued an international competition specifying a problem now known as the ITC2007 problem (Queen's University of Belfast 2007) where the goal function, soft constraints, hard constraints, and datasets were defined.

In this section, we discuss the requirements of our problem definition and link them to requirements of the existing problems in the literature.

The model should try to spread the exams as evenly as possible for every student group. Many other studies have incorporated this, ranging from a static approach such as not having two consecutive exams on the same day or overnight (Burke, Newall, & Weare, 1998; Qu et al., 2008; Wijgers & Hoogeveen, 2007), to a more dynamic approach attributing spreading costs relative to the number of time slots between two exams. Problems Toronto c, Toronto e, and Nottingham a include a static spreading requirement in which students cannot have two (consecutive) exams on the same day. Problems Toronto d, Nottingham b, Melbourne I, and Melbourne II extend this and penalize consecutive exams on the same day and overnight. Laporte and Desroches (1984) introduced a dynamic spreading approach and utilized a cost parameter ws
                            for each pairwise combination of exams that are s time slots apart. These costs have been defined as 
                              
                                 
                                    w
                                    1
                                 
                                 =
                                 16
                              
                           , 
                              
                                 
                                    w
                                    2
                                 
                                 =
                                 8
                              
                           , 
                              
                                 
                                    w
                                    3
                                 
                                 =
                                 4
                              
                           , 
                              
                                 
                                    w
                                    4
                                 
                                 =
                                 2
                              
                           , and 
                              
                                 
                                    w
                                    5
                                 
                                 =
                                 1
                              
                           . The Toronto b problem evaluates the exam spread using the same dynamic spreading costs. Bullnheimer (1998) achieves dynamic spreading by maximizing study time instead of minimizing spreading costs. The ITC2007 problem both requires static and dynamic spreading. The total cost takes into account the number of times students have two subsequent exams as well as the number of times students have two or more exams within a predefined number of time slots. The Toronto a problem does not include any spreading measures. We employ a dynamic spreading cost as defined by Laporte and Desroches (1984). Our problem relates best to the Toronto b set, of which we will use two instances to test the performance of the models presented in this article.

To honor the first requirement, one could schedule a new version of an exam for every unique student group, but this is undesirable. Every version requires new exams to be drawn up by the lecturer and requires other practicalities such as the presence of lecturers at the examination of every version. Contrary to standard ETPs, most European universities schedule multiple versions of an exam. We did not encounter any previous research that incorporated this into the automated-timetabling algorithms. Surely, in current methodologies multiple versions of exams can be created for different student groups to ease the scheduling, but not dynamically. Our models optimize a trade-off between scheduling an exam more than once and maximizing exam spread. Since this trade-off is not present in the literature, our article does not relate to the existing datasets for this aspect.

Given a finite number of rooms with a finite capacity, the total capacity must be respected. The exam capacity is equal to the maximum number of students that can take an exam at the same time slot. This is a very common constraint in the literature but not every study takes this into account. Only Toronto e and the Nottingham sets specify that the total room capacity should not be exceeded (Qu et al., 2008). Contrary to these aggregated capacities, the ITC2007 problem requires that exams are assigned to rooms and that individual room capacities must be respected. Our models do not schedule exams to individual rooms. We therefore use aggregated room capacities.

Extensive overviews of ETP-solving methodologies are available in several survey articles. Carter (1986) discusses the application of graph theory to ETPs, with a focus on heuristics that use graph-coloring. Schaerf (1999) defines the difference between school timetabling problems, University Course Timetabling Problems (UCTPs), and ETPs. The article also includes a list of previous survey articles. For ETPs, Schaerf (1999) reviews direct heuristics, graph-coloring, simulated annealing, genetic algorithms, and several other methods. Burke and Petrovic (2002) contribute to the literature with an overview of these topics and also discuss constraint-based techniques, tabu search, hyper heuristics, and population-based techniques such as evolutionary algorithms and ant algorithms. Qu et al. (2008) update this effort. Many techniques have thus already been applied to the ETP.

Mixed Integer or Integer Programming (MIP or IP) formulations are straightforward to set up, but they are constrained in their operation by the size of the problem. Examples are an application at the university of Kuwait (Al-Yakoob, Sherali, & Al-Jazzaf, 2010) and a quadratic programming model by Bullnheimer (1998). Direct heuristics mostly mimic human action and improve an initial integer solution by altering one element at a time (Schaerf, 1999). Laporte and Desroches (1984) use a heuristic that first solves a basic MIP and then takes care of classroom requirements and the need to spread the exams. Dimopoulou and Miliotis (2001) use a heuristic algorithm to first schedule the exams and then improve the solution to satisfy other constraints in a similar manner to Laporte and Desroches (1984). Recently, Arbaoui, Boufflet, and Moukrim (2015) present new preprocessing stages and an improved MIP model for the examination timetabling problem of ITC2007. The preprocessing stages exploit an exam-based conflict graph, together with hard constraints and room capacities, to reveal implicit conflict constraints between exams even when they have no students in common.

Graph-coloring formulations have been applied since 1967 (Qu et al., 2008). In these formulations, exams are represented by vertices and time slots by colors. Two nodes are connected by an edge when they share resources and cannot be scheduled for the same time slot. When coloring the graph, two adjacent vertices cannot receive the same color. Two exams that share, for example, the same students cannot be scheduled on the same day (Mehta, 1981). Carter (1986) focuses his review article on possible tactics concerning which node to color first. Wijgers and Hoogeveen (2007) use graph coloring to create “sub-exam schedules”, a list of non-clashing exams for each time slot in their CG algorithm. Qu, Burke, and McCollum (2009) create a hyper-heuristic which selects the best method for coloring the nodes. The basic graph-coloring problem was also solved using CG by Mehrotra and Trick (1996), which makes it possible to solve large-scale basic ETPs where only a clash-free exam schedule has to be found. A recent example of a graph-coloring-based heuristic applied to an ETP, is the work of Kahar and Kendall (2010). They also compare the different requirements for the different ETP definitions. Abdul-Rahman et al. (2014b) assign a score for the difficulty of scheduling each examination using an adaptive linear combination of two graph-coloring heuristics and examinations are scheduled in an order based on this value.

Another category of solution methods consists of local search approaches. They are often combined with population-based techniques to search the solution space around initial feasible solutions. Popular local search techniques are simulated annealing (Zhang, Liu, M'Hallah, & Leung, 2010), great deluge (Kahar & Kendall, 2014), and tabu search (Kendall & Hussin, 2005; Pais & Amaral, 2011; White, Xie, & Zonjic, 2004). Examples of population-based methods are genetic algorithms (Burke, Eckersley, McCollum, Petrovic, & Qu, 2010), memetic algorithms (Al-Betar, Khader, & Abu Doush, 2014), ant-colony algorithms (Dowsland & Thompson, 2004), particle swarm optimization (Marie-Sainte, 2015), and bee colony algorithms (Alzaqebah & Abdullah, 2014; Alzaqebah & Abdullah, 2015; Sabar, Ayob, Kendall, & Qu, 2012). A comparison between different meta-heuristics applied to the ETP can be found in an article by Azimi (2004). The graph-coloring problem was also solved using local search approaches (Burke et al., 2010, 2007, 2005; Qu et al., 2009). Recently, Abdul-Rahman, Burke, Bargiela, McCollum, and Özcan (2014a) present a local search heuristic that decomposes the examinations into two sets: a set of difficult to schedule and a set of easy to schedule examinations. These sets are dynamically updated during the construction of a timetable to ensure earlier assignment of examinations that lead to infeasibilities in subsequent attempts. Moreover, the examinations within each set are ordered using different strategies based on graph coloring heuristics. Li, Bai, Shen, and Qu (2015) propose an evolutionary ruin and stochastic rebuild search algorithm in which optimization is achieved by an iterative process of component evaluation, solution disruption and stochastic constructive repair.A last class of frequently used methods are hyper-heuristics, which combine different simpler heuristics. Instead of using only one heuristic, the problem at hand instructs the algorithm which (part of a) lower-level heuristic might be the most effective (Qu et al., 2009). Hyper-heuristics are increasingly utilized to generalize the method for solving ETPs (Demeester et al., 2012; Gogos, Alefragis, & Housos, 2010; Malik, Othman, Ayob, & Hamdan, 2011; Sabar et al., 2011; Soghier & Qu, 2013, Burke, Qu, & Soghier, 2014, Qu, Nam, Bai, & Kendall, 2015).

In addition to the previous categories, some authors are also researching the possibility of parallelizing the optimization process of the ETP, to make greater use of distributed computing (Komar, Grbic, & Cupic, 2011; Mansour and Sleiman-Haidar, 2011). Algorithms are designed to break up and work on different parts of the problem in parallel to speed up the optimization process.

Our models are based on CG. A Master Problem (MP) selects partial solutions (grouped decisions) that are grouped into one decision variable or a column. CG tries to solve large-scale Linear Programs (LPs) by only looking at a part of the possible columns and generating new columns that improve the goal function value. It decomposes the problem into a Restriced Master Problem (RMP) that constructs a solution, given available feasible columns, and a subproblem that generates new columns. Except for a technical report by Wijgers and Hoogeveen (2007), CG has not yet been applied to the ETP. CG can be defined as an algorithm that permits solving LP problems containing a huge number of variables of which many are non-basic. It deals with the complexity through decomposition and iterative improvement of a feasible solution. The technique has already been applied to other scheduling problems like the UCTP which is a problem similar to the classic ETP. For instance, CG has successfully been applied to a UCTP in Italy (Qualizza & Serafini, 2005). Wijgers and Hoogeveen (2007) first try to minimize the number of time slots using a CG approach. Their goal is to find a non-clashing schedule, indicating that no student has two exams at the same time. In their research, a column represents a schedule of non-clashing exams for one time slot. The model tries to minimize the number of columns (time slots) needed so that all exams are scheduled and students have a complete examination timetable. Note that this method does not assign a column to a specific time slot, as a column is generated for a random time slot. In the second part of their research, Wijgers and Hoogeveen (2007) are able to include availability of lecturers and to avoid a situation where students have two exams in one day. The columns (or schedules) are defined slightly differently. A column is now a schedule for one day and contains two time slots, so that the student day constraint is easy to incorporate. In order for lecturers to express their availability, columns are specific to a certain day. The model no longer minimizes the number of time slots, but it minimizes the artificial cost associated with choosing a schedule under the constraints mentioned above. The authors were unable to incorporate a dynamical spread of the exams. This inability is a direct result of the definition of a column. The spreading of exams is nevertheless very important for students. Our method therefore differs from the method of Wijgers and Hoogeveen. We transfer the complexity of the dynamic approach of minimizing spreading costs to the Pricing Problem (PP). A column is defined per unique student group, for which the spreading cost is calculated. The Master problem (MP) then selects a combination of columns that minimizes the weighted spreading and exam version costs, taking into account the room capacities. To avoid a situation in which some exams get an excessive number of exam versions (whereas others have only one version) we also assign a penalty to the maximum number of exam versions over all exams. In this way additional exam versions are spread over all exams.

In this section, we present the first model. We first define the columns that are used and we discuss the MP. Then, we cover the reduced cost of a column in this model and present a PP to generate these columns. We conclude this section with an overview of the algorithm that heuristically selects the columns in a process we call “fixing”.

Our first model is the most intuitive. We use a complete schedule for a unique student group s as a column with index q. A column consists of a binary matrix 
                           A
                        
                        
                           
                              sq
                           
                         where the columns represent the time slots and the rows represent the exams taken by student group s. The elements of the matrix, namely asqet
                        , denote that exam e is scheduled at time slot t when the element equals 1, and 0 otherwise.

                           
                              (3.1)
                              
                                 
                                    
                                       
                                          
                                             
                                                time
                                                
                                                slots
                                             
                                             :
                                          
                                       
                                       
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   2
                                                
                                                
                                                   3
                                                
                                                
                                                   4
                                                
                                                
                                                   5
                                                
                                                
                                                   6
                                                
                                                
                                                   7
                                                
                                                
                                                   8
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             exam
                                             
                                             e
                                             
                                             
                                                {
                                                
                                                   =
                                                   
                                                      
                                                         
                                                            a
                                                         
                                                      
                                                      
                                                         
                                                            b
                                                         
                                                      
                                                   
                                                   
                                                   
                                                      A
                                                      sq
                                                   
                                                   =
                                                
                                             
                                          
                                       
                                       
                                          
                                             (
                                             
                                             
                                             
                                             
                                                
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                             
                                             
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The above example (3.1) shows a matrix for a fictional unique student group that has exams a and b within a period of eight time slots. In the example, a
                        
                           sqa5 and a
                        
                           sqb1 equal 1, indicating that the student group takes exam a at time slot 5 and exam b at time slot 1. Each exam schedule column has a cost representing the fictional spreading cost. This cost 
                           
                              c
                              
                                 s
                                 q
                              
                              S
                           
                         is defined in the PP in Section 3.4.

This model's MP will select the most beneficial combination of exam schedules, one for each unique student group. The MP trades off the cost of additional exam versions against the cost of a worse schedule for students, and treats the room capacity as a hard constraint. The MP is shown in (3.2)–(3.11) and uses the following definitions:

                           Sets and indices


                           
                              E
                           
                           
                              Is the set of exams, index e.

Is the set of student groups, index s.

Is the subset of exams for unique student group s, ∀s ∈ S: Es
                                 ⊆E.

Is the subset of student groups that take exam e, ∀e ∈ E: Se
                                 ⊆S, index s
                              

Is the set of time slots, index t.

Is the set of schedules (columns) generated for student group s, index q.

Binary, equals 1 if timetable q for student group s schedules exam e at time slot t.

Cost of scheduling an extra exam version.

Cost of the maximum additional exam versions over all exams.

Cost of choosing schedule q for unique student group s, a function of study-time fairness.

Number of students in student group s.

Number of student groups taking exam e.

Total exam capacity of rooms.

Binary, equals 1 if schedule q is chosen for student group s.

Binary, equals 1 if exam e has a version scheduled at time slot t.

Number of student groups in Se
                                  not taking a scheduled version of exam e at time slot t.

Maximum number of additional exam versions.

Dual prices for scheduling an exam e at time slot t due to version costs.

Dual prices for not scheduling student groups when a version for exam e at time slot t is scheduled.

Dual price for scheduling at time slot t, due to room capacities.

Dual price for scheduling a timetable for student group s.

The goal function in Eq. (3.2) minimizes the total cost of exam versions and of the students’ schedules. The first two terms are the costs for scheduling exams. During preliminary testing of this model, we encountered unbalanced outcomes. Some exams had up to six versions in a certain test case, while others had only one. We therefore added a variable N to the MP, which counts the maximum number of additional versions of any exam in the solution. The first term attributes a cost to N. The second term attributes a cost to the number of groups not taking an exam at the same time slot as the other student groups taking that exam. We use this as a proxy for extra exam version costs, as the absent student groups in one time slot will need at least one additional version of that exam at another time slot. We thus attribute the cost of an exam version to this. The last term incurs the total spreading costs for students. We weigh the cost of the student group exam schedules by the number of students in that group. The set of constraints in Eq. (3.3) forces a version to be scheduled at a time slot if at least one student group takes the exam at that time slot. We use a binary variable 
                           
                              ϵ
                              
                                 e
                                 t
                              
                              V
                           
                         to assign a version of an exam when at least one unique student group has exam e at time slot t. A big-M constraint is used, because this aggregated formulation of master constraints reduces the tailing-off effect traditionally found in CG (Vanderbeck, 2005). This, however, does result in a less tight lower bound when relaxing the MP (Bosch & Trick, 2005). Instead of an arbitrary big value for M, we limit this effect by using the number of student groups taking that exam. In constraint (3.4), we then count the number of absent student groups for each exam version that is scheduled. Constraint (3.5) ensures that the total room capacity is not violated. For each student group, the MP will select exactly one exam schedule, which is ensured by (3.6). The dual prices used in the PP are listed next to each constraint. The integer constraints are defined in (3.8) and (3.10) for, respectively, the selection of columns and the scheduling of exam versions. We exclude scheduling exam versions on Saturday afternoons and on Sundays. Furthermore, a cost cN
                         is incurred to variable N in the goal function and we add (3.7) and (3.11). These additions make sure that N equals the maximum number of additional versions over all exams and that it is minimized in the goal function.

To obtain the dual prices, we relax the IP to an LP and replace (3.8) and (3.9) with (3.12) and (3.13). The relaxation enables the algorithm to calculate dual variables and a reduced cost ksq
                         of a column q for student group s. The cost for a new exam schedule is defined by 
                           
                              c
                              
                                 s
                                 q
                              
                              S
                           
                        . The reduced cost ksq
                         of column q for student group s, is given by (3.14) and is minimized in the PP to find new columns that can decrease the goal function value of the MP. A new column will only be added to the MP when its reduced cost is negative, i.e., when the beneficial impact outweighs the cost of the column).

                           
                              (3.12)
                              
                                 
                                    
                                       α
                                       
                                          s
                                          q
                                       
                                    
                                    ∈
                                    
                                       [
                                       
                                          0
                                          ,
                                          1
                                       
                                       ]
                                    
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    ,
                                    
                                    ∀
                                    q
                                    ∈
                                    
                                       Q
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (3.13)
                              
                                 
                                    
                                       ϵ
                                       
                                          e
                                          t
                                       
                                       V
                                    
                                    ∈
                                    
                                       [
                                       
                                          0
                                          ,
                                          1
                                       
                                       ]
                                    
                                    ,
                                    
                                    ∀
                                    e
                                    ∈
                                    E
                                    ,
                                    
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (3.14)
                              
                                 
                                    
                                       k
                                       
                                          s
                                          q
                                       
                                    
                                    =
                                    
                                       c
                                       
                                          s
                                          q
                                       
                                       S
                                    
                                    −
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ∑
                                       
                                          e
                                          ∈
                                          
                                             E
                                             s
                                          
                                       
                                    
                                    
                                       a
                                       
                                          s
                                          q
                                          e
                                          t
                                       
                                    
                                    
                                       (
                                       
                                          
                                             λ
                                             
                                                e
                                                t
                                             
                                             T
                                          
                                          −
                                          
                                             λ
                                             
                                                e
                                                t
                                             
                                             N
                                          
                                          +
                                          
                                             n
                                             s
                                             S
                                          
                                          
                                             λ
                                             t
                                             R
                                          
                                       
                                       )
                                    
                                    −
                                    
                                       λ
                                       s
                                       S
                                    
                                 
                              
                           
                        
                     

Every iteration, the algorithm searches for a new column (exam schedule) for every unique student group that has the largest possible gain, i.e., the largest negative reduced cost). The columns make it possible to transfer some of the requirements to the PP, which results in a less complex MP. The transferred requirements are the two constraints of exam spreading for students. In this section, we model the PP as an IP to search for new columns by minimizing the reduced cost.

We use a cost definition as defined in (3.15), created by Laporte and Desroches (1984) and formalized by Qu et al. (2009). Parameter C is a cost factor and I is the ideal number of time slots between two exams. The exponent in (3.15) measures the difference between the ideal number of time slots and the actual number of time slots between two exams. If a student has more time slots between two exams, the exponent will be negative, which results in a cost lower than 1. If a student group has fewer time slots between exams, the exponent is positive and a larger cost will be incurred. By defining a variable parameter I per student group, one can adapt this to the number of exams in that unique curriculum. However, to adhere to existing literature, we use the cost definition as defined in the article by Qu et al. (2009). The method defines costs with 
                           
                              C
                              =
                              2
                           
                         and 
                           
                              I
                              =
                              5
                           
                        , for study times up to 5 time slots.

                           
                              (3.15)
                              
                                 
                                    
                                       c
                                       
                                          
                                             t
                                             ′
                                          
                                          ,
                                          t
                                       
                                       
                                          s
                                          p
                                          r
                                          e
                                          a
                                          d
                                       
                                    
                                    =
                                    
                                       C
                                       
                                          I
                                          −
                                          
                                             (
                                             
                                                t
                                                −
                                                
                                                   t
                                                   ′
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     

We use Eq. (3.16) to calculate the impact of scheduling an exam e at time slot t on the reduced cost for student group s.

                           
                              (3.16)
                              
                                 
                                    
                                       K
                                       
                                          e
                                          t
                                       
                                    
                                    =
                                    −
                                    
                                       λ
                                       
                                          e
                                          t
                                       
                                       T
                                    
                                    −
                                    
                                       n
                                       s
                                       S
                                    
                                    
                                       λ
                                       t
                                       R
                                    
                                 
                              
                           
                        
                     

The PP that tries to find a new column for student group s is formulated in (3.17)–(3.23). The model uses the previous definitions with the following additions:

                           Parameters


                           
                              Ket
                              
                           
                           
                              Impact on reduced cost for scheduling exam e at time slot t
                              

Binary, equals 1 if exams are scheduled at time slots t and 
                                    
                                       t
                                       +
                                       u
                                    
                                 
                              

Binary, equals 1 if exam e is scheduled at time slot t
                              

Goal function (3.17) minimizes the reduced cost. We use constraint (3.18) to make sure that every exam from the curriculum is scheduled exactly once and use constraint (3.19) to exclude these exams being scheduled at the same time slot. Constraint (3.20) takes into account the spreading costs when two exams are scheduled u time slots apart. Constraint (3.21) does the opposite and is a valid inequality to solve the MIP faster. We define the domain of the binary variables in (3.22) and (3.23).

The elements asqet
                         of the columns' matrix 
                           A
                        
                        
                           
                              sq
                           
                         are determined using (3.24). The cost 
                           
                              c
                              
                                 s
                                 q
                              
                              S
                           
                         of the column is determined by the spreading costs and is given in (3.25).

                           
                              (3.24)
                              
                                 
                                    
                                       a
                                       
                                          s
                                          q
                                          e
                                          t
                                       
                                    
                                    =
                                    
                                       κ
                                       
                                          e
                                          t
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3.25)
                              
                                 
                                    
                                       c
                                       
                                          s
                                          q
                                       
                                       S
                                    
                                    =
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          1
                                          .
                                          .
                                          5
                                          :
                                          t
                                          +
                                          u
                                          ≤
                                          
                                             |
                                             T
                                             |
                                          
                                       
                                    
                                    
                                       c
                                       u
                                       
                                          s
                                          p
                                          r
                                          e
                                          a
                                          d
                                       
                                    
                                    
                                       δ
                                       
                                          t
                                          u
                                       
                                    
                                 
                              
                           
                        
                     

Transferring the complexity of the spreading costs to the PP increases the flexibility to incorporate many requirements such as the spreading of exams. When testing the model, we found that the PP is still somewhat time-consuming on modern-day computers, demanding on average half of a second of computation time.

The algorithm for the first model is based on a standard CG-scheme. The MP selects the individual exam schedules (columns) for student groups and schedules exam versions when the selected exam schedules require them. The dual prices from the relaxed MP are used in the PP to create a new exam schedule for a student group that is added to the MP. Fig. 1 outlines the algorithm in a flowchart. CG must start with a feasible solution so that at least all hard constraints are satisfied. This can be achieved using methods such as the clique-partitioning method of Liu, Zhang, and Chin (2011), which provides a feasible starting solution. Another possibility is to use a dummy solution that satisfies all constraints, but that is only selected at a big-M cost. We start by solving the relaxed RMP using a set of dummy columns that give us a first solution. This results in the necessary dual prices needed in the PP to search for new columns, or exam schedules. New columns that improve the RMP will be added to the RMP if the reduced cost ksq
                         of the column is strictly negative. If new columns are found, the RMP including these new columns is rerun, resulting in new dual prices. We then start the search for new columns again for every student group. This process is repeated until no columns are found and our relaxed RMP is fully solved.

An optimal relaxed MP does not necessarily contain the columns needed in an optimal integer MP-solution. For this to be guaranteed, a time consuming branch-and-price algorithm is needed as discussed in Barnhart, Johnson, Nemhauser, Savelsbergh, and Vance (1998). Our algorithm heuristically selects a time slot at which a version for an exam is scheduled. The time slot of an exam that has the highest value of 
                           
                              ϵ
                              
                                 e
                                 t
                              
                              V
                           
                         in the relaxed MP is fixed. New columns are then generated, while forcing exams to be scheduled at those time slots. Extra versions from existing columns are still allowed, but at an extra cost. Fixing a time slot for exams is done in batches, after which the new columns are generated. If a time slot is fixed for a specific exam, other exams that share students are excluded from being fixed at that time slot. Exams that share students with exams in the current batch of fixing, must also wait for the next batch so that new columns can be found for those student groups. In one batch of fixing examination time slots, time slots are fixed for as many as possible exams. The order of fixing for exams is determined by the number of potential conflicts with other exams. The exams with the highest number of potential conflicts are fixed first. We define a potential-exam-conflict matrix with dimensions E × E. The elements 
                           
                              y
                              
                                 
                                    e
                                    1
                                 
                                 
                                    e
                                    2
                                 
                              
                           
                         count the number of potential conflicts between the two exams by counting the number of shared student groups, and is defined in (3.26), where xes
                         equals 1 if student group s takes exam e, and 0 otherwise.

                           
                              (3.26)
                              
                                 
                                    
                                       y
                                       
                                          
                                             e
                                             1
                                          
                                          ,
                                          
                                             e
                                             2
                                          
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          S
                                       
                                    
                                    
                                       x
                                       
                                          e
                                          
                                             s
                                             1
                                          
                                       
                                    
                                    
                                       x
                                       
                                          e
                                          
                                             s
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This matrix is inspired by the conflict matrix proposed by Cole (1964), in which the elements 
                           
                              c
                              
                                 
                                    e
                                    1
                                 
                                 ,
                                 
                                    e
                                    2
                                 
                              
                           
                         equal 1 if exam e
                        1 has students groups in common with exam e
                        2. Contrary to this binary logic, the elements in our matrix count the number of potential conflicts. We define the number of potential conflicts for an exam e
                        1 as 
                           
                              Y
                              
                                 e
                                 1
                              
                           
                         in (3.27).

                           
                              (3.27)
                              
                                 
                                    
                                       Y
                                       
                                          e
                                          1
                                       
                                    
                                    =
                                    
                                       ∑
                                       
                                          
                                             e
                                             2
                                          
                                          ∈
                                          E
                                          ∖
                                          
                                             {
                                             
                                                e
                                                1
                                             
                                             }
                                          
                                       
                                    
                                    
                                       y
                                       
                                          
                                             e
                                             1
                                          
                                          
                                             e
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                     

For exam e
                        1, we fix the time slot with the highest value of 
                           
                              ϵ
                              
                                 
                                    e
                                    1
                                 
                                 t
                              
                              V
                           
                        . We also remove the exam from our potential-exam-conflict matrix, since it has already been scheduled. Next, we reoptimize the RMP to take into account the newly fixed examination time slot.

This process is repeated until all exams have been fixed (and thus received a timetable). Finally, the RMP is solved as an IP to obtain the final values for 
                           
                              ϵ
                              
                                 e
                                 t
                              
                           
                         and αsq
                         and the goal function value.

In this section, we discuss our second model. This model uses a mask with “mask slots” as a column. A mask slot is a time slot at which the student group is scheduled to take an exam from its curriculum.

Column q for unique student group s is a vector 
                           V
                        
                        
                           
                              sq
                           
                        . Its binary elements vsqt
                         define the mask slots at time slots t for student group s. If vsqt
                         equals 1, student group s will take an exam at time slot t. In the example (4.1) below, student group s takes its three exams at the first, fourth, and eighth time slot. The number of assigned time slots is always equal to the number of exams in the curriculum Es
                        .

                           
                              (4.1)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                
                                                   time
                                                   
                                                   slots
                                                
                                                :
                                             
                                             
                                             
                                                
                                                   
                                                      1
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      3
                                                   
                                                   
                                                      4
                                                   
                                                   
                                                      5
                                                   
                                                   
                                                      6
                                                   
                                                   
                                                      7
                                                   
                                                   
                                                      8
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                V
                                                sq
                                             
                                             =
                                             
                                                [
                                                
                                                   
                                                      
                                                         1
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         1
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         0
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                
                                                ]
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Every column has a cost, which is equal to the spreading costs 
                           
                              c
                              
                                 s
                                 q
                              
                              S
                           
                         as discussed in Section 3.2.

The MP assigns versions of exams to time slots and minimizes the number of versions by using masks as columns. We again select the most beneficial combination of columns in order to schedule the exam versions at the time slots when student groups are available. Explicitly assigning exam versions for student groups would result in a very large MP. We tested the idea of assigning exam e to student group s and time slot t with binary variable 
                           
                              ϵ
                              
                                 e
                                 s
                                 t
                              
                           
                        , which proved to be very time-consuming when imposing integrality constraints. Instead, we implicitly schedule exams for student groups. Exams are “overscheduled” when an exam version is scheduled, but the student group cannot take the exam at the scheduled time slot. Overscheduling can be the result of one of the following two reasons: either the student group does not have a mask slot scheduled at that time slot, or another exam version from that student group's curriculum is already scheduled at that time slot. We minimize the number of times exams are overscheduled for a student group. For each time slot t, variable Yst
                        counts the number of overscheduled exams for the curriculum of student group s. As the overscheduling results in extra versions to be created at another time slot, we attribute a cost of scheduling extra exam versions. This has two effects. Firstly, this approach loses the ability to differentiate the cost of each version depending on the weight exam in a student's curriculum. Secondly, as the scheduling of exam versions for students is done implicitly, the goal function does not calculate the total costs in the same manner as the first model. The actual total cost is calculated in a post-processing step (see Section 4.6). The MP minimizes the total cost that consists of the cost of overscheduling exam versions and the spreading costs for students. The MP is described in (4.2)–(4.11) and uses the following definitions:


                        
                           Sets


                           
                              E
                           
                           
                              Is the set of exams, index e
                              

Is the set of student groups, index s
                              

Is the set of exams for unique student group s, ∀s ∈ S: Es
                                 ⊆E
                              

Is the set of student groups that take exam e, ∀e ∈ E: Se
                                 ⊆S, index s
                              

Is the set of time slots, index t
                              

Is the set of masks (columns) generated for student group s, index q
                              

Cost of scheduling an extra exam version

Cost of the maximum additional exam versions over all exams

Cost of choosing mask schedule q for unique student group s, equals spreading costs for students

Number of students in student group s

Total exam capacity of rooms

Binary, equals 1 if an exam can be scheduled for student group s at time slot t in mask q
                              

Binary, equals 1 if schedule q is chosen for student group s
                              

Binary, equals 1 if exam e has a version scheduled on time slot t
                              

Maximum number of additional exam versions

Continuous variable, number of overscheduled exams for student group s at time slot t
                              

Dual price for a mask slot for student group s at time slot t, due to overscheduling

Dual price for scheduling at mask slot t, due to room capacities

Dual price for scheduling a timetable for student group s
                              

The goal function (4.2) minimizes the total costs. As in Model 1, we weigh the spreading cost of the columns according to the number of students in the student group. Constraint (4.3) makes sure that every exam has at least one exam version. Decision variable Yst
                         is calculated in constraint (4.4). We are unable to use aggregation on this constraint to counteract the tailing-off effect, as our dual prices would only offer information either per time slot or per student group to the PP. In (4.5) we include the room capacity constraint. Constraint (4.6) imposes that every student group is associated with exactly one mask schedule. Integrality definitions for mask selection variables and exam version variables are included in (4.8) and (4.10). During testing, we again found unbalanced solutions in exam versions as was the case in Model 1. We therefore added decision variable N, which counts the maximum number of additional versions over all exams in the solution. We add the cost of the maximum additional exam versions to the goal function and add constraint (4.7). We also define the domain of N in (4.11).

This formulation has some drawbacks. Because exam versions are not explicitly assigned to groups, there is no guarantee that a student group receives a complete exam schedule. In the students’ mask slots, some exams from their set of exams may be scheduled multiple times whereas it is possible that others are not scheduled at all. Therefore, post-processing of the results is required.

To obtain the dual prices, the integrality constraints (4.8) and (4.10) are replaced with (4.12) and (4.13). Model 2 leads to the reduced cost ksq
                         for a new column q for student group s, specified in (4.14). The cost at which the new exam schedule for student group s is selected is defined by 
                           
                              c
                              
                                 s
                                 q
                              
                              S
                           
                        .

                           
                              (4.12)
                              
                                 
                                    
                                       α
                                       
                                          s
                                          q
                                       
                                    
                                    ∈
                                    
                                       [
                                       
                                          0
                                          ,
                                          1
                                       
                                       ]
                                    
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    ,
                                    
                                    ∀
                                    q
                                    ∈
                                    
                                       Q
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (4.13)
                              
                                 
                                    
                                       ϵ
                                       
                                          e
                                          t
                                       
                                       V
                                    
                                    ∈
                                    
                                       [
                                       
                                          0
                                          ,
                                          1
                                       
                                       ]
                                    
                                    ,
                                    
                                    ∀
                                    e
                                    ∈
                                    E
                                    ,
                                    
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (4.14)
                              
                                 
                                    
                                       k
                                       
                                          s
                                          q
                                       
                                    
                                    =
                                    
                                       c
                                       
                                          s
                                          q
                                       
                                       S
                                    
                                    −
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       (
                                       
                                          
                                             λ
                                             
                                                s
                                                t
                                             
                                             E
                                          
                                          +
                                          
                                             n
                                             s
                                             S
                                          
                                          
                                             λ
                                             t
                                             R
                                          
                                       
                                       )
                                    
                                    
                                       v
                                       
                                          s
                                          q
                                          t
                                       
                                    
                                    −
                                    
                                       λ
                                       s
                                       
                                          S
                                          
                                       
                                    
                                 
                              
                           
                        
                     

We use a PP similar to the first PP proposed for Model 1 in Section 3.2 to find a column with the largest negative reduced cost. The PP is now only concerned with the mask slots in which the exams are to be scheduled. The spreading costs are calculated as in (3.15). The impact of creating a mask slot at time slots t on the reduced cost is defined in (4.15).

                           
                              (4.15)
                              
                                 
                                    
                                       K
                                       t
                                    
                                    =
                                    −
                                    
                                       λ
                                       
                                          s
                                          t
                                       
                                       S
                                    
                                    −
                                    
                                       n
                                       s
                                       S
                                    
                                    
                                       λ
                                       t
                                       R
                                    
                                 
                              
                           
                        
                     

The PP for student group s is formulated in (4.16)–(4.21). The model uses the previous definitions with in addition:


                        
                           Parameters


                           
                              Kt
                              
                           
                           
                              Impact on reduced cost for scheduling a mask slot at time slot t
                              

Binary, equals 1 if mask slots are scheduled at time slots t and 
                                    
                                       t
                                       +
                                       u
                                    
                                 
                              

Binary, equals 1 if a mask slot is scheduled at time slot t
                              

Goal function (4.16) minimizes the reduced cost. Constraint (4.17) enforces that the new column contains exactly as many mask slots as there are exams in the student group's curriculum. The program links the variables for calculating the spreading costs in (4.18). Constraint (4.19) is a valid inequality to speed up the solving process. In (4.20) and (4.21), we define the problem as a binary IP.

The elements vsqt
                         of the columns' matrix 
                           V
                        
                        
                           
                              sq
                           
                         are determined using (4.22). The cost 
                           
                              c
                              
                                 s
                                 q
                              
                              S
                           
                         of the column is determined by the spreading costs and is given in (4.23).

                           
                              (4.22)
                              
                                 
                                    
                                       v
                                       
                                          s
                                          q
                                          t
                                       
                                    
                                    =
                                    
                                       κ
                                       t
                                    
                                 
                              
                           
                        
                        
                           
                              (4.23)
                              
                                 
                                    
                                       c
                                       
                                          s
                                          q
                                       
                                       S
                                    
                                    =
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ∑
                                       
                                          u
                                          ∈
                                          1
                                          .
                                          .
                                          5
                                          :
                                          t
                                          +
                                          u
                                          ≤
                                          
                                             |
                                             T
                                             |
                                          
                                       
                                    
                                    
                                       c
                                       u
                                       
                                          s
                                          p
                                          r
                                          e
                                          a
                                          d
                                       
                                    
                                    
                                       δ
                                       
                                          t
                                          u
                                       
                                    
                                 
                              
                           
                        
                     

As discussed in Section 4.2, Model 2 does not assign exam versions explicitly to student groups. The program does not give an exam schedule for each unique group of students, nor does it guarantee a complete schedule. Hence, it is necessary to revise the solution of the MP. We perform the post-processing using two approaches: a heuristic approach and a binary IP approach. Both approaches assign an exam version to a student group and start from the solution given by the integer formulation of the MP. This solution contains a mask schedule for every unique student group and the time slots for which the exams have an exam version.

To illustrate the heuristic approach, we use the following example. Student group 1 takes exams 1, 2, 3, and 4, and student group 2 takes exams 1, 2, and 3. Exam 1 has a version at time slot 1 (
                           
                              
                                 ϵ
                                 
                                    11
                                 
                                 V
                              
                              =
                              1
                           
                        ), exam 2 at time slot 3 (
                           
                              
                                 ϵ
                                 
                                    23
                                 
                                 V
                              
                              =
                              1
                           
                        ), exam 3 at time slots 5 and 7 (
                           
                              
                                 ϵ
                                 
                                    35
                                 
                                 V
                              
                              =
                              
                                 ϵ
                                 
                                    37
                                 
                                 V
                              
                              =
                              1
                           
                        ), and exam 4 at time slot 5 (
                           
                              
                                 ϵ
                                 
                                    45
                                 
                                 V
                              
                              =
                              1
                           
                        ). Student group 1 takes its exams at time slots 1, 3, 5, and 7 (
                           
                              
                                 α
                                 
                                    1
                                    q
                                 
                              
                              =
                              1
                           
                         and 
                           
                              
                                 V
                                 
                                    1
                                    q
                                 
                              
                              =
                              
                                 [
                                 
                                    
                                       
                                          1
                                       
                                       
                                          0
                                       
                                       
                                          1
                                       
                                       
                                          0
                                       
                                       
                                          1
                                       
                                       
                                          0
                                       
                                       
                                          1
                                       
                                    
                                 
                                 ]
                              
                           
                        ); student group 2 takes its exams at time slots 1, 5, and 7 (
                           
                              
                                 α
                                 
                                    2
                                    q
                                 
                              
                              =
                              1
                           
                         and 
                           
                              
                                 V
                                 
                                    2
                                    q
                                 
                              
                              =
                              
                                 [
                                 
                                    
                                       
                                          1
                                       
                                       
                                          0
                                       
                                       
                                          0
                                       
                                       
                                          0
                                       
                                       
                                          1
                                       
                                       
                                          0
                                       
                                       
                                          1
                                       
                                    
                                 
                                 ]
                              
                           
                        ).

In the heuristic, we use a matrix 
                           X
                         in which the columns represent the time slots and the rows represent the unique student groups. The elements of the matrix xst
                         represent the exam student group s has at time slot t. The elements in curly brackets are not fixed and will be changed by the heuristic. The post-processing heuristic works as follows:


                        Step 1 For every element mst
                        , create a set containing all exams that are currently assigned to time slot t for group s. If no mask slot exists, the element is equal to the empty set. Otherwise, the element is a series of exams that have versions at that time slot. This is shown for the example below. Note that exam 2 does not have a version planned in a mask slot for student group 2. This is solved in step 3.

                           
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          
                                             
                                                
                                                   {
                                                   1
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   2
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   
                                                      3
                                                      ,
                                                      4
                                                   
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                          
                                          
                                             
                                                
                                                   {
                                                   1
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     

The following 3 steps are repeated until no more moves can be made.


                        Step 2 In each row, fix the exams for which only one version is planned in that row and drop the other exams from the series in the fixed element mst
                        . In our example, this results in the matrix below. If there are multiple exams in the same time slot with only one version scheduled, first fix the exams for which there already exists a version at that time slot; then fix the exam with the most versions in the same time slot for other student groups.

                           
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                2
                                             
                                             
                                                0
                                             
                                             
                                                4
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     


                        Step 3 For each group s, add the exams in Es
                         that are not planned in a mask slot to the series that are not yet fixed. In our example, we must add exam 2 to the elements for student group 2.

                           
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                2
                                             
                                             
                                                0
                                             
                                             
                                                4
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   3
                                                   }
                                                
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   
                                                      3
                                                      ,
                                                      2
                                                   
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   
                                                      3
                                                      ,
                                                      2
                                                   
                                                   }
                                                
                                             
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     


                        Step 4 In each element, fix the exams if a version already is fixed in that column. If multiple exams from an element are already fixed at that time slot, then choose the exam with the highest number of student groups already taking it. In our example, nothing needs to be done. Return to step 2.


                        Step 2bis We fix exam 3 in the last time slot for the first student group.

                           
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                2
                                             
                                             
                                                0
                                             
                                             
                                                4
                                             
                                             
                                                0
                                             
                                             
                                                3
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   
                                                      3
                                                      ,
                                                      2
                                                   
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   
                                                      3
                                                      ,
                                                      2
                                                   
                                                   }
                                                
                                             
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     


                        Step 3bis No exams are missing.


                        Step 4bis Exam 3 exists at the last time slot, so we fix exam 3 in the second row at the last time slot and remove it from the other elements in that row.

                           
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                2
                                             
                                             
                                                0
                                             
                                             
                                                4
                                             
                                             
                                                0
                                             
                                             
                                                3
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                
                                                   {
                                                   2
                                                   }
                                                
                                             
                                             
                                                0
                                             
                                             
                                                3
                                             
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     


                        Step 2tris We fix exam 2 in the fifth time slot for the second student group.

                           
                              
                                 
                                    X
                                    =
                                    
                                       [
                                       
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                2
                                             
                                             
                                                0
                                             
                                             
                                                4
                                             
                                             
                                                0
                                             
                                             
                                                3
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                2
                                             
                                             
                                                0
                                             
                                             
                                                3
                                             
                                          
                                       
                                       ]
                                    
                                 
                              
                           
                        
                     

All exams are fixed, so the heuristic is stopped. The result of the heuristic is a matrix that contains a complete examination timetable for every student group.

Using the solution from Model 2, we can create an IP that assigns exams explicitly to student groups and time slots. The column selection variables αsq
                         resulting from the MP are now parameters. The IP used is described in (4.24)–(4.32), and has the same definitions as the MP in Section 4.2 with the following alterations:


                        
                           Parameters


                           
                              αsq
                              
                           
                           
                              Binary, equals 1 if schedule sq is chosen for student group s in the integer MP of Model 2

Binary, equals 1 if exam e is scheduled at time slot t for unique student group s
                              

s.t.

                           
                              (4.25)
                              
                                 
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ϵ
                                       
                                          e
                                          t
                                          s
                                       
                                       P
                                    
                                    =
                                    1
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    ,
                                    ∀
                                    e
                                    ∈
                                    
                                       E
                                       s
                                    
                                 
                              
                           
                        
                        
                           
                              (4.26)
                              
                                 
                                    
                                       ϵ
                                       
                                          e
                                          t
                                          s
                                       
                                       P
                                    
                                    −
                                    
                                       ∑
                                       
                                          q
                                          ∈
                                          
                                             Q
                                             s
                                          
                                       
                                    
                                    
                                       v
                                       
                                          s
                                          q
                                          t
                                       
                                    
                                    
                                       α
                                       
                                          s
                                          q
                                       
                                    
                                    ≤
                                    0
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    ,
                                    ∀
                                    e
                                    ∈
                                    
                                       E
                                       s
                                    
                                    ,
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (4.27)
                              
                                 
                                    
                                       ϵ
                                       
                                          e
                                          t
                                          s
                                       
                                       P
                                    
                                    −
                                    
                                       ϵ
                                       
                                          e
                                          t
                                       
                                       V
                                    
                                    ≤
                                    0
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    ,
                                    ∀
                                    e
                                    ∈
                                    
                                       E
                                       s
                                    
                                    ,
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (4.28)
                              
                                 
                                    
                                       ∑
                                       
                                          e
                                          ∈
                                          
                                             E
                                             s
                                          
                                       
                                    
                                    
                                       ϵ
                                       
                                          e
                                          t
                                          s
                                       
                                       P
                                    
                                    ≤
                                    1
                                    ,
                                    
                                    ∀
                                    s
                                    ∈
                                    S
                                    ,
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (4.29)
                              
                                 
                                    
                                       ∑
                                       
                                          t
                                          ∈
                                          T
                                       
                                    
                                    
                                       ϵ
                                       
                                          e
                                          t
                                       
                                       V
                                    
                                    −
                                    N
                                    ≤
                                    1
                                    ,
                                    
                                    ∀
                                    e
                                    ∈
                                    E
                                 
                              
                           
                        
                        
                           
                              (4.30)
                              
                                 
                                    
                                       ϵ
                                       
                                          e
                                          t
                                       
                                       V
                                    
                                    ∈
                                    
                                       {
                                       
                                          0
                                          ,
                                          1
                                       
                                       }
                                    
                                    ,
                                    
                                    ∀
                                    e
                                    ∈
                                    E
                                    ,
                                    
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (4.31)
                              
                                 
                                    
                                       ϵ
                                       
                                          e
                                          t
                                          s
                                       
                                       P
                                    
                                    ∈
                                    
                                       {
                                       
                                          0
                                          ,
                                          1
                                       
                                       }
                                    
                                    ,
                                    
                                    ∀
                                    e
                                    ∈
                                    
                                       E
                                       s
                                    
                                    ,
                                    s
                                    ∈
                                    S
                                    ,
                                    
                                    ∀
                                    t
                                    ∈
                                    T
                                 
                              
                           
                        
                        
                           
                              (4.32)
                              
                                 
                                    N
                                    ≥
                                    0
                                 
                              
                           
                        
                     

Goal function (4.24) minimizes the totals cost of exam versions. We impose in constraint (4.25) that every exam a student group takes is scheduled. Constraint (4.26) ensures that an exam is assigned to a student group only if there is a mask slot for the student group. In (4.27), an exam version is created if an exam is scheduled for a student group at that time slot. Constraint (4.28) makes sure that only one exam is planned for a student group at a given time slot. Similar to the approach used in Model 1, we try to level the additional exam versions by means of (4.29). We define the problem as a binary IP in (4.30) and (4.31), and define the domain of N in (4.32).

In the IP post-processing approach, we only use the mask schedules to find a solution as opposed to the heuristic post-processing approach, which also uses the exam version data. If we were to impose the already scheduled versions in the integer MP, we would unnecessarily constrain the post-processing MIP.


                        Fig. 2
                         illustrates the algorithm for Model 2. The CG algorithm is equivalent to the first model, but with another fixing strategy and the addition of a post-processing step. Post-processing can be performed by using the heuristic or by using the IP model. During testing, we noticed strong tailing-off effects, especially for larger values of cV
                         and cN
                        . Since we were unable to counter this effect by aggregating constraints (as in Model 1), we chose to cut off the CG-process by using the Lagrangian bound as a lower bound on the optimal solution of the MP (Lübbecke & Desrosiers, 2005). The process is stopped if this bound is within 5 percent of the RMP's current goal function value.

In this model, we cannot fix exams by fixing columns for student groups. We therefore fix exam versions in order of the number of potential conflicts. Exams with a higher number of potential conflicts are fixed first. We construct a potential-exam-conflict matrix, similar to the conflict matrix in Model 1, in which elements 
                           
                              z
                              
                                 
                                    e
                                    1
                                 
                                 
                                    e
                                    2
                                 
                              
                           
                         count the number of potential conflicts between exams e
                        1 and e
                        2. Only exams that do not have potential conflicts with exams that were scheduled during this fixing loop, are allowed to be fixed. After the RMP has fixed a time slot for all exams, additional columns are generated for the last time. After this step, the RMP is solved as an IP. Next, because student groups are still assigned implicitly to exam versions, post-processing is required. During this step, we remove the fixing of all exam decision variables.

@&#RESULTS@&#

In the following section, we test our algorithms on our own datasets containing one real-life dataset and three randomly generated sets. We also apply our algorithms to two datasets from the Toronto problem. We first present the test set-up. The results of our own datasets are then used to discuss and compare both approaches. Next, we present
                      the results for the datasets from the literature. We conclude with a brief
                     
                      general discussion of the results.

The models are applied to a test case at the KU Leuven campus Brussels, Belgium. Data were collected for the bachelor and master degree of the Business Engineering program for the academic year 2011–2012. At that moment, 178 students were enrolled, which encompasses three bachelor years and two master years. We test our models using the data of the first semester of 2012. Next to this HUB dataset, we have also created three small random datasets X1, X2, and X3. These datasets have been created by randomly selecting 0 or 1 for each combination of 20 unique student groups and the preset number of exams. The number of students in each unique student group is also randomly selected. Finally, we compare our results with the best results reported in the literature for the STA83 and YOR83 instances from the Toronto dataset. By removing the total room capacity constraint, our models reduce to the Toronto b problem with multiple versions of exams. Table 1 shows a summary of relevant metrics of these datasets. We use the conflict density as a proxy of the complexity of the dataset, as proposed by Cole (1964). A higher ratio leads to a higher probability of arising conflicts when scheduling exams. We provide online access to our datasets at http://econ.kuleuven.be/gert.woumans/public.

We first present the results for our own test instances for different parameters of cV
                         and cN
                        . For completeness, in Table 2 we show all results for both models, i.e., the three different metrics by which we can assess the quality of an exam schedule: the average spreading cost for a student, the average number of exam versions per exam, and the maximum number of additional exam versions. We also report the total wall clock time. Fig. 3 provides graphs of these results to illustrate how the models optimize for different parameters. Note that for the HUB dataset, the first model was also able to produce a timetable with no additional versions for any exam, if we keep cV
                         at 200 and increase cN
                         to 400.


                        Figs. 3 and 4 show the results for respectively the average spreading costs and the average number of exam versions. Each row of graphs represents a different dataset and each column represents a different value of cN
                        . Our goal was to develop an examination-timetabling approach capable of trading off multiple exam versions with lower spreading costs. Fig. 3 shows that in most cases, the average student spreading cost increases for higher exam version cost in both models. The opposite reaction for the average spreading costs is exhibited in Fig. 4.
                     

Generally, as the number of exam versions decreases with rising exam version costs, the spreading costs for students increase, which is the expected trade-off. Both models, however, have their strong point: while the first model somewhat favors lower spreading costs, the second model visibly favors fewer exam versions. Table 2 shows similar results for the maximum number of additional exam versions N. Model 2 generally produces timetables with lower or equal values of N. We believe this is due to the post-processing phase in the second model, which adds extra flexibility.

To assess the overall performance of the algorithm, we compare the total cost. Fig. 5 shows the integer goal function values for the instances HUB, X1, X2, and X3. In general, Model 2 produces timetables with lower total costs and has a performance advantage of 5.2 percent when compared to the first model. For datasets X1 and X3, Model 2 results in a lower cost of 15 percent and 26 percent respectively when compared to the first model. However, for the HUB and X2 datasets, Model 2 has a performance disadvantage of 6 percent and 14 percent respectively when compared to the first model.

From these results, we conclude that the second model slightly outperforms the first one in terms of solution quality. Both models however have different CG processes. Figs. 6
                         and 7 show the typical CG process for respectively Model 1 and Model 2. The graphs represent the relaxed goal function value of the RMP and the Lagrangian lower bound. The graph for the second model clearly displays the tailing-off effect that is typically associated for CG each time the CG process is restarted after fixing a series of examination dates. We remedied this by aggregation in Model 1 and by using a stop criterion for Model 2. Both graphs show spikes in the goal function value when fixing examination time slots. As a result Model 1 is notably faster than Model 2, due to the absence of the
                         tailing-off effect.

We also test the second model using the post-processing heuristic. The results of the heuristic are compared to IP as post-processing technique in Table 3, which presents the resulting number of versions, the maximum number of extra exam versions, and the total cost for exams for dataset X1 with parameters 
                           
                              
                                 c
                                 V
                              
                              =
                              10
                           
                         and 
                           
                              
                                 c
                                 N
                              
                              =
                              100
                           
                        . The results for other instances are similar. In general, the heuristic results in only a slightly different result as compared to integer programming as post-processing technique. The heuristic has a higher number of maximum additional exam versions and the same number of average exam versions.

We test our models on two existing instances from the Toronto dataset (Carter, Laporte, & Lee, 1996) : STA83 and YOR83 with different parameters values. For the second model, we used the IP post-processing technique. Model 1 takes between 1.5 and 2.5 hours to solve an instance of the STA83 set and between 13 and 15 hours for an instance of the YOR83 set, while the second model needs between 2 and 8 hours to solve an instance of the STA83 set. Model 2 was not able to solve the larger YOR83 set due to computational time constraints. Table 4 summarizes the results.Model 1 produces results within the specified time limit for all parameters and datasets, while Model 2 is only able to do this for the STA83 dataset, but not for the instances of the YOR83 dataset. Model 2’s MP is very time-consuming for datasets of this size and is unable to reach the step that fixes examination dates.

The first model is sensitive to the cost parameters relative to the size of the problem, to produce a good trade-off. Cost parameters need to be sufficiently large, for the trade-off to be visible. In the existing literature, the best average spreading costs, while scheduling each exam only once, are 156.9 (Burke et al., 2010) for the STA83 set and 34.64 (Demeester et al., 2012) for the YOR83 set. For the first dataset, the models show a small improvement of up to 3 percent in spreading cost by allowing more exam versions to be scheduled. For the second dataset, this was 7 percent. The second model produces timetables with a lower total cost as compared to the first model for the STA83 set.

@&#DISCUSSION@&#

Both models are successful in making a trade-off between spreading and exam costs and thus in creating high-quality examination timetables, especially for smaller-sized test instances. The results show a good response of the models to changing parameters. For the existing STA83 set, both models are able to give a better spreading cost to students as compared to the best solution found in the literature, but not for all instances and at the cost of multiple exam versions. The second model performed better in terms of total costs. For the larger YOR83 set, only the first model was able to obtain a solution, whereas the second model exceeded the CPU-time limit of 400 hours. These results show that our models are well suited for smaller-sized problems such as the HUB datasets, but are unsuited to solve larger problems such as the YOR83 dataset. The number of student groups increases the number of columns that are generated for each iteration, increasing the size of the MP significantly. Our heuristic method of fixing examination dates also appeared to be unsuited to address the fractional solutions from the CG-process with problems of this size. We believe this is due to the increase in potential conflicts, and the chain of potential conflicts with other exams. The increase in fractional solutions and the nature of the current fixing process makes it more difficult to find solutions with no additional exam versions for large datasets. Note that for small datasets it is possible to find solutions that schedule exams only once.

The difference between the two models underlines the decision of which complexity to transfer to the PP. Without a branch-and-price algorithm that guarantees an optimal solution, the second model's MP has increased flexibility in finding solutions because of a reduced transfer in complexity. Whereas the first model is more straightforward and is always able to produce feasible timetables, the second model produces timetables with lower total costs. The relaxed MP produces fractional solutions, resulting in an artificially low number of versions for every exam. In the integer MP, this was of course not allowed. As our fixing of variables in the MP is performed heuristically, Model 2 benefits from the increased flexibility it offers during the post-processing for planning the final exam versions. Model 1 is constrained by the scheduled exams in the generated columns that cannot be changed afterwards. Our attempt to counteract the tailing-off effect typically associated with CG (by using an aggregated constraint formulation in Model 1) was successful. The use of a Lagrangian bound stopping-criterion in the second model, does limit time consumption, but does not resolve the tailing-off effect.

@&#CONCLUSION@&#

In this paper, we look at examination timetabling from a student-centric point of view. Instead of scheduling an exam once while optimizing the exam spread for students, we optimize the exam spread by scheduling exams multiple times for different student groups if this is sufficiently beneficial for the exam spread. The cost of the exam spread is measured using the method developed by Laporte and Desroches (1984). We optimize a trade-off function by weighing the costs of better spreading for a student versus the cost of scheduling multiple versions of an exam. To our knowledge, no other author has designed models to make a trade-off between exam spreading and the number of exam versions, even though this is quite common in colleges and universities. We propose two Column Generation (CG) models to solve the Examination-Timetabling Problem (ETP). The objective is to schedule exams in time slots, so that the required number of exam versions is minimal while maintaining a fair schedule for each student. Each model uses a different definition of a column that serves as a schedule for a unique student group.

The first model defines a column to be a complete examination timetable for a unique student group. CG requires the integrality constraint to be relaxed during the generation of columns. The first model counters fractional solutions by heuristically fixing exams at certain time slots during the CG process, based on the number of potential conflicts with other exams. It allows finding new columns for other student groups while taking into account the already fixed columns and their scheduled exams.

The second model uses mask slot schedules as columns. These mask slot schedules define when students will take an exam. The Master Program (MP) decides which exam is scheduled at what time slot, and implicitly schedules exam versions for student groups. Both models fix exams at certain time slots and allow for finding new columns that take the already fixed exams into account. Model 2, however, needs post-processing to schedule all exams for all students. We developed an IP as well as a heuristic for this post-processing phase.

We test our models on both real-life data from KU Leuven campus Brussels (Belgium) and a number of randomly generated test instances. Both models find high-quality solutions for all instances of our own datasets within an acceptable time limit, with the second model producing the timetables with the lowest total cost. Model 1 has a tendency to favor low spreading costs over fewer exam versions, resulting in higher total costs. Some performance concerns remain with respect to solving large-scale ETPs. The algorithms are applied to two datasets from the Toronto b problem: the STA83 set and the YOR83 set. The first model is able to find good solutions for both datasets for various cost parameters, while the second model was only able to find a solution for the STA83 set within the given time limit. The models are able to produce timetables that improve spreading costs for students, at the cost of additional exam versions. The size of the problem hinders the MP and also hinders the current method of fixing examination dates to adhere to integrality constraints. We conclude that for larger dimensions our models are not suited, especially when solutions with no additional exams are required. The results show that spreading costs can be strongly reduced by allowing multiple versions of exams.

Both CG models would benefit strongly from an efficient and exact branch-and-price algorithm that would extend the current models. Other possible research directions include to speed up the proposed algorithm by focusing on better starting solutions and alternative pricing rules to aid the CG process. Our models can easily be extended to include new requirements to the pricing problems. Requirements that apply within a group's schedule and that are unrelated to specific exams can easily be added to the pricing problem of both Model 1 and Model 2. For example, one could specify that a specific student group can have no more than two exams in one week due to a learning disability. It might also be fruitful to study the adaptability of the existing solution methods from the literature to incorporate the trade-off presented in this article.

To summarize, in this paper we implemented the common practice of scheduling exams multiple times, which is beneficial to the spreading costs for students. We developed two CG algorithms and compared them using a computational experiment in which the second algorithm outperformed the first one. The results described in this paper indicate that CG could be a valuable method in solving the ETP by means of decomposition.

@&#REFERENCES@&#

