@&#MAIN-TITLE@&#Evaluation of automatic feature detection algorithms in EEG: Application to interburst intervals

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A software to improve algorithms for feature detection in neonatal EEG is proposed.


                        
                        
                           
                           The clustering quality of feature detectors with EEG rating is quantified.


                        
                        
                           
                           The method is tested on a modular definition of interburst intervals detectors.


                        
                        
                           
                           The power supply filter can be removed with little effect on the detection quality.


                        
                        
                           
                           Detectors are robust compared with the standard deviation thresholding of the EEG.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

EEG

Interburst intervals

Signal analysis

Cluster Validity Index

Clustering

@&#ABSTRACT@&#


               
               
                  In this paper, we present a new method to compare and improve algorithms for feature detection in neonatal EEG. The method is based on the algorithm׳s ability to compute accurate statistics to predict the results of EEG visual analysis. This method is implemented inside a Java software called EEGDiag, as part of an e-health Web portal dedicated to neonatal EEG.
                  
                     EEGDiag encapsulates a component-based implementation of the detection algorithms called analyzers. Each analyzer is defined by a list of modules executed sequentially. As the libraries of modules are intended to be enriched by its users, we developed a process to evaluate the performance of new modules and analyzers using a database of expertized and categorized EEGs. The evaluation is based on the Davies–Bouldin index (DBI) which measures the quality of cluster separation, so that it will ease the building of classifiers on risk categories. For the first application we tested this method on the detection of interburst intervals (IBI) using a database of 394 EEG acquired on premature newborns. We have defined a class of IBI detectors based on a threshold of the standard deviation on contiguous short time windows, inspired by previous work. Then we determine which detector and what threshold values are the best regarding DBI, as well as the robustness of this choice. This method allows us to make counter-intuitive choices, such as removing the 50Hz filter (power supply) to save time.
               
            

@&#INTRODUCTION@&#

Through electrodes placed on the scalp, the EEG sensors directly record the spontaneous electrical activities of the cerebral cortex. It gives information on the ongoing neurological status of a patient and remains a major diagnostic tool in neurology for many conditions such as epilepsy, sleep disorders, coma, etc. In some cases, long term recordings are needed, generating heavy files and requiring tedious analysis. Extracting the relevant information automatically may considerably help physicians to detect abnormal patterns such as seizures or other neurological dysfunctions. Various analysis methods can be employed [1] and the calculated data have to be compared to the visual analysis by an expert. Such computer aided diagnosis systems have been developed for seizure detection in epilepsy.

The EEG is also used on newborns to detect seizures that are often clinically silent in infants and has specific applications to evaluate cerebral injury and cerebral maturation in premature infants. Neonatal EEG analysis is a highly specialized task and few experts are available to perform this time consuming activity. Therefore, an automated system for computer aided diagnosis would be significantly valuable for neonatal intensive care units.

The goal of this work was to develop a new method to evaluate the performance of specifically developed algorithms for neonatal EEG, using a database of expertised and classified tracings. For the first application, we tested this framework for interburst intervals (IBIs) detection in preterm born infants׳ EEGs.

In premature infants, the normal background EEG activity has specific features including spontaneously discontinuous signals with periods of electrical activity alternating with periods of quiescence – called IBIs. The diagnostic and prognostic value of neonatal EEG abnormalities in premature infants are well established [2,3]. IBI duration has been shown to be related to the maturational process of cortical folding [4]. Prolonged IBIs, as measured by the longest IBI, have been shown to be related to abnormal brain maturation in premature infants [5]. The presence of IBIs is also highly abnormal in full-term infants with birth asphyxia.

However, systematic assessement of IBIs duration is not of current use as the manual measurement of IBIs is a problematic and time-consuming task. This difficulty might be alleviated by recourse to their automated detection, as several recent studies have shown [6–8]. The validation of the detectors is performed visually on several EEG sequences, comparing intervals marked by experts with the intervals automatically detected and then by calculating their specificity and sensitivity. We propose a complementary approach that takes into account the life cycle of the EEG record in the medical routine. The EEG is sent to a neurologist, who analyzes the signal (without scoring intervals one by one) and proposes a diagnostic opinion. Finally the EEG, the diagnosis and some patient data are registered in a database. Therefore, our aim is to compare statistically different algorithms to optimize their settings without recourse from a second detailed visual analysis process. For this purpose, we have developed a component-based approach implementation of several algorithms (see [22] for a review on component-based implementations). Indeed, signal analysis is rarely based on a unique and simple algorithm. It can be described by a set of sequential operations allowing the elimination of useless information, the extraction of information from different sources, their agregation and transformation in a concise form, that is easy for physicians to interpret. We have implemented this analysis pipeline, called an analyzer, as a sequence of modules, where each module corresponds to an operation on the EEG or derived data.

The comparison between the different algorithms is based on two criteria: the quality and the speed of the signal. While the speed criterion is easy to define, the quality criterion is normally more difficult to express. Generally, the quality is evaluated by manually comparing the individual IBIs visually marked by the specialist to the automatically detected IBIs (see for example [9]). This is useful for rejecting bad algorithms and bad settings, but it is too time-consuming to be used on high number of EEGs. Moreover, our experiments have shown that the IBI detection is partly subjective as there may be discussions between specialists determining the beginning and end of an IBI. The overall impression based on the global appreciation of the IBIs is more reliable. And because feature detection is not an end in itself but a means to assess risks on brain development, it is not clear that the detail of each feature, taken one by one, allows for better classification of risk categories for patients.

Ultimately, we propose an additional quality criterion to the specificity/sensitivity criteria. It is based on the ability of the feature׳s detection algorithms to produce discriminative information, predictive of a pathological EEG. For this, we use the Davies–Bouldin index (see Section 2.4 for the details) which measures the quality of cluster separation, so that it will ease the building of classifiers on risk categories.

Our paper is structured as follows. We present our framework and software to define and run analyzers in Section 2, as well as the methodology and criteria quality that we use to evaluate different analyzers. In Section 3 we illustrate our methodology on the automated evaluation of several analyzers for IBIs detection based on the algorithm proposed by Jennekens in [6], and we provide our future work direction. We conclude this paper in Section 4.

A database of 416 EEG and relative information on infants was created as part of the LIFT cohort. All surviving children born between January 2003 and December 2004 at less than 35 weeks of gestation in a systematic follow up (see [10]) were enrolled. Written consent was obtained from their parents before the children were included in the LIFT cohort, which was registered at the French CNIL (The National Commission for Information Technology and Civil Liberties, or Commission Nationale de l׳Informatique et des Libertés, No. 851117) ethics committee, allowing clinical data collection from the patients’ records.

The EEG signals were recorded (Alliance, Nicolet Biomedical) with adapted electrodes (cups) with reduced neonatal montages using 8 or 11 scalp electrodes depending on head size, in accordance with the international 10–20 system for a duration of 30–45min. The EEG abnormalities were assessed according to the established classifications used routinely in France: each EEG was interpreted according to the guidelines of the French Neurophysiological Society. An EEG is considered as normal (normal background activity for the corrected age, no abnormal features), moderately abnormal or doubtful (increased discontinuity with longer IBI less than 50% more than the maximal value for age, abnormal delta brushes, dysmature patterns, positive temporal sharp waves, positive rolandic sharp waves of less than 1 per minute), severely abnormal or pathological (excessive discontinuity with maximal IBI duration above 50% of the maximal value for corrected age, seizures, positive rolandic sharp waves with more than 2 per minute). Clinical information on the status at birth and the outcome was registered. For analysis purposes, a visual inspection of each EEG was performed to reject low quality tracings with too many artifacts that may impair IBI detection. 22 EEGs were rejected (around 5%) to obtain the base of 394 EEGs used in this work. The EEGs were anonymised.

Alongside proprietary software developed by EEG manufacturers where users have little control, few platforms exist for researchers to validate their algorithms. EEGLab and Brainstorm [11,12] on the MATLAB platform (from Mathworks Inc.) are examples of such platforms. With EEGDiag we developed a Java application embedded in the e-health Web portal “BBEEG portal” dedicated to neonatal EEG. EEGDiag represents an intermediary approach between proprietary softwares and research oriented platforms. EEGDiag is designed for researchers and physicians. EEGDiag is downloadable from the web browser (at http://bbeeg.chu-angers.fr/portal, users can register by clicking on “Vous pouvez créer un compte”) and functional on any workstation of NICUs subscribed to the BBEEG portal.

But EEGDiag is not just an application, but also a framework based on the plug-in and observer design patterns. Thus, EEGDiag is used in three situations: as a stand-alone application during routines in NICUs, as a Web service in the BBEEG portal thanks to the underlying Java framework, and for clinical/biomedical engineering research. Finally, EEGDiag and its underlying framework allows:
                           
                              •
                              implemention, testing and comparison of different algorithms on EEGs in a user-friendly way,

establish the best default setting for each algorithm by testing different tunings on a large EEG database,

build indices and risk categories from detected features,

provide results in a short time and in an easily readable form for routine usage.

Each algorithm is decomposed into elementary operations and can be modeled by a graph describing the sequence of these operations. This has enabled us to achieve a graphic modeling tool (see 
                        
                        
                        Fig. 3) that easily generates new algorithms. Such a tool proved particularly beneficial when teaching its use as it allows a better understanding of the underlying processes by looking at the effect of the adding or removing one of the elementary operations. In addition, this component-based approach allows a better reusability of algorithms and facilitates the integration of new modules. Each module-based algorithm is called an “analyzer”.


                        EEGDiag works with different EEG formats. The analyzers’ results are displayed in a specific window (see Fig. 1) and can be exported in a csv file. A “tools” menu enriches analyzers with new features based on a plug-in mechanism: provided one follows a well-defined framework, the user can add new modules and tools in the form of Java (⁎. jar) libraries (see Fig. 2).


                        EEGDiag is composed of the Java libraries built during the project. SeriesCommon.jar is the base library, since it contains all the data structures for handling the time and interval series (the read/write operations rely on a double-buffer technique to avoid too much disk access). AnalyzerFramework.jar and BBEEG-ToolFramework.jar are frameworks to enrich the application of new modules (jar libraries), new algorithms (XML files) and tools (jar libraries). Several free libraries available on the Internet were used, especially Java Simple Plugin Framework (JSPF, see [13]) for dynamic loading of modules and tools, and Better Swing Application Framework (BSAF, see [14]) to simplify the separation of concern (user interface and functional aspects).

Preanalysis steps are necessary to improve the quality of the results. As we wanted to study the impact of these operations on the final results (mainly quality and speed of analysis), we choose a pipeline approach. We defined an EEG analyzer as an ordered list of EEG processing modules. Each module performs an operation (e.g. signal transformation like filters and smoothers or signal analysis like IBI detection or frequency decomposition) and completes its operation before sending its results to the next module. An analyzer can be described graphically by a flow chart where a box is a module or by an XML-file (like in Fig. 3) that provides the ordered list of modules to the analyzer thread. This thread also holds a data source and a state (running, stopped, paused). The data source is either an EEG (mainly in European Data Format) or a csv/Excel file that contains the location of the EEG files to analyze. In the latter case, the analyzer works in batch mode: it loops on all the EEG provided by the csv/Excel file. An analyzer algorithm simply consists of running each module in the list one after the other. It can be stated as follows:
                           
                              •
                              Initialize text report.


                                 Current=the first module in the list.


                                 Input(Current)=the data source embedded in an EEG reader.

Run Current module and append text report with Current report.

While (analyzer is in running state) and (Current is not the last module in the list) do:
                                    
                                       
                                          Last=Current;


                                          Current=next module in the list;


                                          Input(Current)=Output(Last);

Run Current module and append text report with Current report;

Set the analyzer state in stopped state and return text report.

Each time a module is run, it processes the input to produce the output, builds a graphical report with different statistics (inside a panel) and finally returns a text version of the report. In Section 3, we present and evaluate two analyzers used to detect IBIs.

Each EEG in our database has been visually analyzed and categorized as “normal” (N), “doubtful” (D) or “pathological” (P). Therefore we have three clusters of visually inspected EEG (N, D and P).

Given an analyzer A, features related to brain maturation of newborn in an EEG can be extracted and a vector of m variables computed from the features can be built. For example, IBI detection produces for each EEG an array of intervals (the IBIs) from which we compute IBIs statistics such as the mean duration, the max duration, the total duration, etc. Therefore, we can associate each EEG to a labeled point in IR
                           m
                        , where the label is its category (N, D or P). For a database with n EEG, we obtain a set of n points partitioned in three clusters N, D and P. The choice of the analyzer and its parameters can shift these points, distorting the three clusters.

We propose an evaluation of an analyzer A overall quality based on its ability to produce the least amount of overlap in the clusters. The unsupervised evaluation of the partitioning obtained by chosen methods and the parameters when the categories are not known (unsupervised classification) is an important issue in automatic clustering. Many authors have then defined cluster quality or validity indices to optimize parameters and compare same class algorithms (like fuzzy clustering, agregation algorithms, etc., see for example [15–17]). Our problem is slightly different: we know which cluster each point belongs to and our goal is to optimize the feature detection pipeline so that the points inside the clusters will facilitate the building of classification models without knowing the models that will be used beforehand. A good analyzer will minimize the intra-class inertia (the points inside a cluster have the least possible dispersion) and maximize the inter-class inertia (the centers of each cluster are as distant as possible from each other). To measure this ability we choose the Davies–Bouldin index (DBI), defined by its authors in [18], because it was well suited to our purpose as we have a known number of clusters. DBI is calculated as
                           
                              (1)
                              
                                 D
                                 B
                                 I
                                 =
                                 
                                    1
                                    M
                                 
                                 
                                    ∑
                                    
                                       i
                                       =1
                                    
                                    M
                                 
                                 
                                    
                                       max
                                    
                                    
                                       j
                                       =
                                       1
                                       ,
                                       ..
                                       .
                                       ,
                                       M
                                    
                                 
                                 
                                    
                                       R
                                    
                                    
                                       i
                                       j
                                    
                                 
                              
                           
                        with
                           
                              (2)
                              
                                 
                                    
                                       R
                                    
                                    
                                       i
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             I
                                          
                                          
                                             i
                                          
                                       
                                       +
                                       
                                          
                                             I
                                          
                                          
                                             j
                                          
                                       
                                    
                                    
                                       d
                                       
                                          (
                                          
                                             
                                                
                                                   c
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   c
                                                
                                                
                                                   j
                                                
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        and
                           
                              (3)
                              
                                 
                                    
                                       I
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    1
                                    
                                       
                                          
                                             n
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       =1
                                    
                                    
                                       
                                          
                                             n
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 d
                                 
                                    (
                                    
                                       
                                          
                                             x
                                          
                                          
                                             i
                                             ,
                                             k
                                          
                                       
                                       ,
                                       
                                          
                                             c
                                          
                                          
                                             i
                                          
                                       
                                    
                                    )
                                 
                              
                           
                        where 
                           
                              
                                 x
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                         is the kth point of the ith cluster and c
                        
                           i
                         is the center of the ith cluster. Given the generalized inner product 
                           
                              〈
                              
                                 x
                                 ,
                                 y
                              
                              〉
                           
                           =
                           
                              
                                 x
                              
                              t
                           
                           M
                           
                           y
                        , where M is a Hermitian positive-definite matrix, the distance is defined by 
                           d
                           (
                           x
                           ,
                           y
                           )
                           =
                           
                              〈
                              
                                 x
                                 ,
                                 y
                              
                              〉
                           
                        . Different distances are commonly used to compute DBI and here we use the Euclidian distance, where M is the identity matrix. Another useful distance is the Mahalanobis distance, where M is the inverse of the covariance matrix computed on the whole set. If the Mahalanobis distance better reflects the distribution of the labeled points, it is not appropriate for our data. Indeed, each time we run a given analyzer for a given value with one of its parameters, we obtain points in IR
                           m
                         that are different from those obtained with an other value of the same parameter. Therefore, the covariance matrix is different from one experiment to another, including the Malahanobis distance. Because we want to compare the analyzers between them, if all other variables are equal (ceteris paribus assumption), we use the Euclidean distance.


                        DBI varies in [0,+∞[ and the lower the value of DBI, the better the clusters are regrouped (low intra-class inertia) and separated (high inter-class inertia). Therefore, DBI is an index for the quality of clustering with our analyzers: the lower the value of DBI, the better the analyzer will separate the clusters.

Finally, in order to evaluate an analyzer and its settings, we apply the following procedure to the database of n categorized EEG. Denoted by A(p) an analyzer A with its vector of parameters p and P={p
                        1,p
                        2,p
                        3,…,p
                        
                           q
                        }, the set in which p can take its values, we have:

For i=1,…,q
                     

Create the table T
                        
                           i
                        
                     

For j=1,…,n
                        
                           
                              Build the feature’s list from EEG j with analyzer A(p
                                 
                                    i
                                 )

Compute the statistics from detected features

Store these statistics in the jth row of T
                                 
                                    i
                                 
                              

End For
                           
                              Compute the associated Davies–Bouldin index DBI
                                 
                                    i
                                 
                              

End For

Thereby, we have built q tables (one per parameter’s vector) each containing the results of the analysis of n EEG. Each row of T
                        
                           i
                         is a point in the variable’s space categorized N, D or P: therefore we have a total of n points in the 3 clusters N, D and P. Then we calculate for each analyzer A(p
                        
                           i
                        ) a quality index DBI
                        
                           i
                         and we retain the parameter’s vector p
                        
                           i
                         such that DBI
                        
                           i
                         is minimum. The default settings for analyzer A will be p
                        
                           i
                         for its use with an automatic classifier, without a definitive choice for a given method of classification. DBI calculations and DBI curve building are done using free statistical software R with the clusterSim package from Marek Walesiak and Andrzej Dudek (Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland).

@&#EXPERIMENTS@&#

We based our study on the algorithm proposed by Jennekens et al. [6], as described below. First, two filters are used to eliminate baseline shifts and interference from the power supply and a third filter is used to smooth the signal. Then an averaged p
                        
                           c
                        (i) signal power is computed for each EEG channel in successive windows. The averaged signal power minus the baseline shift is an equivalent of the standard deviation. We have built two analyzers, using the standard module library defined in EEGDiag (see 
                        Fig. 4), from the Jennekens algorithm: the ST (for “Standard deviation Thresholded”) and the STF (for “Standard deviation Thresholded Filtered”) analyzers. ST is the STF without a pre-processing 50Hz IIR filter, which studies the effects of its removal. An IBI will be detected on one EEG channel if the standard deviation is lower than a given threshold V
                        
                           T
                         during a minimum amount of time. The global detection of IBIs is finally computed as the intersection of each channel’s IBIs. The modules used to detect IBIs are as follows:
                           
                              •
                              
                                 Filter module: Each channel is filtered at 50Hz (corresponding to the frequency of electricity supply within the European Union) with a second order Butterworth designed IIR filter (removed in the ST analyzer).


                                 Smoother module: Each channel can be smoothed with a moving window using the simple average, the weighted average or the median. For this work, the moving simple average proved to be sufficient.


                                 Standard Deviation module: Each channel is processed to produce an estimate of the standard deviation on overlapped windows, a standard deviation series.


                                 IBI Channel Detector module “Standard deviation threshold”: This is a three step algorithm: (i) for each resulting standard deviation series. If the standard deviation value is lower than a given V
                                 
                                    T
                                  threshold (in μV) the corresponding time interval is aggregated to the previous time interval; (ii) regroup all intervals separated by less than 
                                    
                                       
                                          m
                                       
                                       
                                          2
                                       
                                    
                                 =0.5s; and (iii) eliminate all intervals shorter than m
                                 1=1s.


                                 IBI EEG Detector module: The intersection of IBIs between all the EEG channels is computed, and only the IBIs of a length greater than m
                                 3=1s are retained.

The choice of the duration’s parameters m
                                 1, m
                                 2 and m
                                 3 were taken from Jennekens.

We now present some details on the modules used by the different IBIs analyzers, as well as our choice for their parameters (maximum IBI lengths, the different moving window lengths, etc.).

We denote by 
                           
                              
                                 X
                              
                              
                                 c
                              
                           
                           (
                           i
                           )
                         the ith value of the filtered EEG on a channel c∈{Fp1, Fp2, Fz, T3, C3, Cz, C4, T4, Pz, O1, O2}, with 
                           i
                           =0,...,
                           n
                           −
                           1
                        . All the EEG are recorded with a sampling rate of 250Hz, therefore 
                           
                              
                                 X
                              
                              
                                 c
                              
                           
                           (
                           i
                           )
                         is associated with the time stamp 
                           
                              
                                 t
                              
                              
                                 i
                              
                           
                           =
                           i
                           /250
                           
                           s
                        .

The “smoother module” applies a moving average to the EEG; it produces for all c the signal 
                           
                              
                                 Y
                              
                              
                                 c
                              
                           
                           (
                           i
                           )
                         where
                           
                              (5)
                              
                                 
                                    
                                       Y
                                    
                                    
                                       c
                                    
                                 
                                 (
                                 i
                                 )
                                 =
                                 
                                    1
                                    
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             1
                                          
                                       
                                       +
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             2
                                          
                                       
                                       +
                                       1
                                    
                                 
                                 
                                    ∑
                                    
                                       k
                                       =
                                       i
                                       −
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             1
                                          
                                       
                                    
                                    
                                       k
                                       =
                                       i
                                       +
                                       
                                          
                                             n
                                          
                                          
                                             a
                                             2
                                          
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       c
                                    
                                 
                                 (
                                 k
                                 )
                              
                           
                        for 
                           i
                           =0,...,
                           n
                           −
                           1
                        . Default settings are n
                        
                           a1=n
                        
                           a2=10.

The next step for the analyzer’s algorithm is calculating the signal’s standard deviation on fixed-size windows. Denoted by 
                           
                              
                                 n
                              
                              
                                 b
                              
                           
                         the window size and by Δn the increment from one window to the next, the windows are given by 
                           [0,
                           
                              
                                 n
                              
                              
                                 b
                              
                           
                           [
                           ,
                           [
                           Δ
                           n
                           ,
                           Δ
                           n
                           +
                           
                              
                                 n
                              
                              
                                 b
                              
                           
                           [,...,[
                           k
                           .
                           Δ
                           n
                           ,
                           k
                           .
                           Δ
                           n
                           +
                           
                              
                                 n
                              
                              
                                 b
                              
                           
                           [
                        , where 
                           k
                           =0,1,...,
                           
                              
                                 n
                              
                              
                                 k
                              
                           
                           −
                           1
                         and 
                           
                              
                                 n
                              
                              
                                 k
                              
                           
                        equals 
                           n
                           /
                           Δ
                           n
                         is the number of windows. Therefore the standard deviation 
                           
                              
                                 
                                    ν
                                    ^
                                 
                              
                              
                                 c
                              
                           
                           (
                           k
                           )
                         on each channel c is computed using the iterative formulae:
                           
                              (6)
                              
                                 
                                    
                                       
                                          ν
                                          ^
                                       
                                    
                                    
                                       c
                                    
                                 
                                 
                                    
                                       (
                                       k
                                       )
                                    
                                    2
                                 
                                 =
                                 
                                    1
                                    
                                       
                                          
                                             n
                                          
                                          
                                             b
                                          
                                       
                                       −
                                       1
                                    
                                 
                                 
                                    ∑
                                    
                                       i
                                       =
                                       k
                                       .
                                       Δ
                                       n
                                    
                                    
                                       k
                                       .
                                       Δ
                                       n
                                       +
                                       
                                          
                                             n
                                          
                                          
                                             b
                                          
                                       
                                       −
                                       1
                                    
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       c
                                    
                                 
                                 
                                    
                                       (
                                       i
                                       )
                                    
                                    2
                                 
                                 −
                                 
                                    1
                                    
                                       
                                          
                                             n
                                          
                                          
                                             b
                                          
                                       
                                       (
                                       
                                          
                                             n
                                          
                                          
                                             b
                                          
                                       
                                       −
                                       1)
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                k
                                                .
                                                Δ
                                                n
                                             
                                             
                                                k
                                                .
                                                Δ
                                                n
                                                +
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      b
                                                   
                                                
                                                −
                                                1
                                             
                                          
                                          
                                             
                                                Y
                                             
                                             
                                                c
                                             
                                          
                                          (
                                          i
                                          )
                                       
                                       )
                                    
                                    2
                                 
                              
                           
                        for 
                           k
                           =0,...,
                           
                              
                                 n
                              
                              
                                 k
                              
                           
                           −
                           1
                        . The time stamp associated with 
                           
                              
                                 
                                    ν
                                    ^
                                 
                              
                              
                                 c
                              
                           
                           (
                           k
                           )
                         is the time interval’s lower bound on which it is calculated, i.e. 
                           
                              
                                 t
                              
                              
                                 k
                              
                           
                           =
                           k
                           .
                           Δ
                           n
                           /250
                        . Default setting for n
                        
                           b
                         is 50, and we vary the increment Δn between 5 and 50 to study its effect. For Δn<n
                        
                           b
                         we have overlapped consecutive windows and for Δn=n
                        
                           b
                         we obtain contiguous and non-overlapped windows (like in Jennekens algorithm).

From the standard deviation series per channel, an IBI channel detector builds for every channel c, independently from the other channels, a series of IBIs denoted 
                           
                              
                                 S
                              
                              
                                 I
                                 B
                                 I
                              
                           
                           (
                           c
                           )
                         by applying a threshold to the standard deviation or to its variation.

The “Standard deviation threshold” module is a three-steps algorithm:
                           
                              
                                 
                                 
                                    
                                       • Initiate k to 0 and empty 
                                             
                                                
                                                   S
                                                
                                                
                                                   I
                                                   B
                                                   I
                                                
                                             
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    
                                       • While 
                                             k
                                             <
                                             
                                                
                                                   n
                                                
                                                
                                                   k
                                                
                                             
                                             −
                                             1
                                           do
                                    
                                    
                                       
                                          - if 
                                             |
                                             
                                                
                                                   
                                                      ν
                                                      ^
                                                   
                                                
                                                
                                                   c
                                                
                                             
                                             (
                                             k
                                             )
                                             |
                                             <
                                             
                                                
                                                   V
                                                
                                                
                                                   T
                                                
                                             
                                           then
                                    
                                    
                                       
                                          ⁎ 
                                             
                                                
                                                   t
                                                
                                                
                                                   b
                                                   e
                                                   g
                                                   i
                                                   n
                                                
                                             
                                             =
                                             
                                                
                                                   t
                                                
                                                
                                                   k
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          ⁎ While 
                                             k
                                             <
                                             
                                                
                                                   n
                                                
                                                
                                                   k
                                                
                                             
                                             −
                                             1
                                           and 
                                             |
                                             
                                                
                                                   
                                                      ν
                                                      ^
                                                   
                                                
                                                
                                                   c
                                                
                                             
                                             (
                                             k
                                             +
                                             1)|<
                                             
                                                
                                                   V
                                                
                                                
                                                   T
                                                
                                             
                                           do 
                                             k
                                             ←
                                             k
                                          +1
                                    
                                    
                                       
                                          ⁎ 
                                             
                                                
                                                   t
                                                
                                                
                                                   e
                                                   n
                                                   d
                                                
                                             
                                             =
                                             
                                                
                                                   t
                                                
                                                
                                                   k
                                                   +
                                                   1
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          ⁎ add interval 
                                             [
                                             
                                                
                                                   t
                                                
                                                
                                                   b
                                                   e
                                                   g
                                                   i
                                                   n
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   e
                                                   n
                                                   d
                                                
                                             
                                             ]
                                           to 
                                             
                                                
                                                   S
                                                
                                                
                                                   I
                                                   B
                                                   I
                                                
                                             
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    
                                       • for each interval in 
                                             
                                                
                                                   S
                                                
                                                
                                                   I
                                                   B
                                                   I
                                                
                                             
                                             (
                                             c
                                             )
                                          , if the upper bound of an interval is less than m
                                          2 seconds from the lower bound of the next interval, merge the two intervals;
                                    
                                    
                                       • for each interval in 
                                             
                                                
                                                   S
                                                
                                                
                                                   I
                                                   B
                                                   I
                                                
                                             
                                             (
                                             c
                                             )
                                          , if the length of the interval is less than m
                                          1 seconds remove the interval.
                                    
                                 
                              
                           
                        
                     


                        
                           
                              
                                 S
                              
                              
                                 I
                                 B
                                 I
                              
                           
                           (
                           c
                           )
                         is the resulting list of IBIs ordered in time. The default settings for m
                        1 and m
                        2 are respectively 1s and 0.5s.

Finally, the IBI EEG detector computes the intersection between each list of IBIs (one list per channel) and keeps only the IBIs with lengths greater than m
                        3 seconds. The result is a list of interburst intervals lasting at least m
                        3 seconds that are simultaneously present on all channels. The list of bursts is deduced from the list of IBIs. The default setting for m
                        3 is 1s. We have observed that the most critical parameter is the threshold V
                        
                           T
                         and the increment 
                           Δ
                           n
                         have important effects on analysis speed. We will therefore have V
                        
                           T
                         vary in [1,150]μV and 
                           Δ
                           n
                         in [5,50] to study their impacts on the quality and the speed of the IBIs detection analyzers using the methodology presented in Section 2, the other parameters retaining the values presented above.

@&#RESULTS@&#

We have seen in Section 1 that statistics on IBIs and bursts proved to be good indicators of abnormality (see too [19,20]). We will therefore study the categorization of the EEG by variables that can be computed from the detected IBIs. We define the following variables for the list of IBI/burst intervals: MAX the duration of the longest interval, MEAN the mean duration of intervals (for a given EEG, the sum of the duration of the intervals divided by the number of intervals), TOT the total duration of intervals (the sum of all interval’s durations), PER the percentage of intervals in the EEG (i.e. TOT divided by EEG duration). Because the EEGs were expertized by using visual detection of IBIs and not bursts, we focus in this study on IBI variables.

Thus we have computed these variable values from the IBIs detected by the analyzers ST (standard deviation thresholded) and STF (same as ST but with a 50Hz filter preprocessing) for each value of the threshold V
                        
                           T
                         (in μV) in {1,2,…,150} and for each window increment Δn in {5,10,20,30,40,50}. We recorded too the total computation time on all the EEG database for each value of V
                        
                           T
                         and Δn. This experiment was conducted on a computer with a dual core 2.9GHz CPU and 8GB memory. An example of the result (when using IBI variables TOT, PER, MAX and MEAN) is provided in 
                        Fig. 5.

We first observed that the choice of variables among TOT, PER, MAX or MEAN had little effect on the results and no effect on the parameter settings. Results for Δn=10 are presented in 
                        Table 1: we give each analyzer the minimum value reached by the Davies–Bouldin index (DBI), the associated threshold value and the associated total computation time (in seconds, for 394 EEG), respectively denoted DBI
                        ⁎, V
                        
                           ⁎
                        
                        
                           T
                         and T
                        
                           ⁎
                        , taking into account different combinations of IBI variables.

We observed the stability of the results. DBI achieves its minimum with each analyzer for the same threshold value, regardless of the variables’ choice. For a given analyzer, the variation of DBI
                        ⁎ with the different sets of variables is very low (a magnitude of 1e−4). We observed the same result by plotting the curves DBI(V
                        
                           T
                        ): all the curves look the same, for their respective analyzer, as the ones in 
                        Fig. 6, which illustrates the variation of DBI for the two analyzers when a point is defined using all the IBI variables (MEAN, MAX, TOT, PER). We obtained similar results for the other values of Δn.
                     

Secondly, the standard deviation based algorithm ST has a clustering quality (i.e. a Davies–Bouldin index value) practically equal to STF when STF is much slower (1.6 times the ST analysis time). It appears that the 50Hz filter is not mandatory when the IBI detection algorithm is used in conjunction with an automatic EEG classifier. This is particularly visible in 
                        Table 2, which shows the best settings for V
                        
                           T
                         and Δn to achieve the best values of the DBI. We observe that for Δn in {20,30,40,50} the ST analyzer gives better DBI values than STF.

One can see that the DBI curves are nearly convex around DBI
                        ⁎. For each analyzer, there is an interval of the threshold in which DBI varies very little. The robustness of the analyzer is relative to the length of this interval regarding the threshold. We calculate the interval in which DBI varies by less than 5% of DBI
                        ⁎ and the interval is defined by the first inflexion point in the curve (the first value of V
                        
                           T
                         for which the variation of DBI is about 5%). Results are shown in 
                        Table 3. Whatever the interval definition, V
                        
                           ⁎
                        
                        
                           T
                         is near from the center of the interval: little variations of V
                        
                           T
                         under or above V
                        
                           ⁎
                        
                        
                           T
                         have few effects on DBI.

Finally, we observe the competition between speed and quality: STF with Δn=5 and V
                        
                           T
                        =49 allows the best value of the Davies–Bouldin index to be achieved (DBI≈2.12) for an analysis time of 1.65 times that of ST with settings Δn=10 and V
                        
                           T
                        =48 for DBI≈2.13.

@&#SUMMARY@&#

The purpose of this work was to develop a valid method to compare algorithms dedicated to neonatal EEG and embedded in a web-based platform. The algorithms were tested on our EEG database where each tracing was rated by visual analysis. We chose the Davies–Bouldin index (DBI) to perform this comparison.

By these means we produce a criterion that quantifies the clustering quality of the information coming from feature detectors regarding the EEG rating. The Davies–Bouldin index (DBI) measures the separation between scatter plots in terms of inertia. Therefore, we define the quality of an analyzer by the value of DBI: the lower the DBI, the better the quality of the analyzer. The default settings can be adjusted to optimize this index.

We tested our method with two previously described IBI detectors inspired from the work of Jennekens et al. [6]. These two IBI detectors, called ST and STF, are built using the modules provided inside the EEGDiag application. STF is based on a threshold of the signal standard deviation on overlapping (or contiguous) short time windows, ST is the version of STF without the 50Hz filter.

The use of such an index allowed us to make some counter-intuitive choices. For example, most EEGs in the database were contaminated by the 50Hz electricity supply; all analysis pipelines were applied with a 50Hz filter due to this contamination. Approximatively a third of the total analysis time is usually spent manually applying this filter. When compared using DBI, ST and STF analyzers proved to be equivalent when Δn≥10.

With a large number of EEGs, it is promising to use data mining techniques to accurately classify EEGs and then patients in regards to their neurological diagnosis. Machine learning techniques [23], such as neural networks or support vector machines [21,24,25], could help in this complex task. Our evaluation methodology allows rapid and objective comparison of various algorithms for automated detection of other types of features, like delta brushes.

None declared.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the Agence Nationale de la Recherche TECSAN 2010 grant “BB EEG Platform” (ANR-10-TECS-0009). The authors thank Ciara Sigmon (student in Western Washington University) for her proofreading, Baptiste Omarini and François-Xavier Deschamps (University Hospital of Angers, France) for the realization of the BBEEG web portal, and our reviewers for helpful comments.

@&#REFERENCES@&#

