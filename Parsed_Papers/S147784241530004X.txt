@&#MAIN-TITLE@&#Compiling and verifying SC-SystemJ programs for safety-critical reactive systems

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Introduction of safety-critical subset of the SystemJ language called Safety-Critical (SC) SystemJ.


                        
                        
                           
                           Automata-based compilation approach for the SC-SystemJ language.


                        
                        
                           
                           A tool-chain for verifying correctness properties (e.g. liveness and safety) of the SC-SystemJ programs and generating executable from the verified code for deployment.


                        
                        
                           
                           The new compiler generates both faster and smaller executable compared to the original SystemJ compiler.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

SystemJ

SC-SystemJ

Safety-critical

Model-checking

Verification

Compilation

@&#ABSTRACT@&#


               
               
                  Most of today's embedded systems are very complex. These systems, controlled by computer programs, continuously interact with their physical environments through network of sensory input and output devices. Consequently, the operations of such embedded systems are highly reactive and concurrent. Since embedded systems are deployed in many safety-critical applications, where failures can lead to catastrophic events, an approach that combines mathematical logic and formal verification is employed in order to ensure correct behavior of the control algorithm. This paper presents What You Prove Is What You Execute (WYPIWYE) compilation strategy for a Globally Asynchronous Locally Synchronous (GALS) programming language called Safey-Critical SystemJ. SC-SystemJ is a safety-critical subset of the SystemJ language. A formal big-step transition semantics of SC-SystemJ is developed for compiling SC-SystemJ programs into propositional Linear Temporal Logic formulas. These LTL formulas are then converted into a network of Mealy automata using a novel and efficient compilation algorithm. The resultant Mealy automata have a straightforward syntactic translation into Promela code. The resultant Promela models can be used for verifying correctness properties via the SPIN model-checker. Finally there is a single translation procedure to compile both: Promela and C/Java code for execution, which satisfies the De-Bruijn index, i.e. this final translation step is simple enough that is can be manually verified.
               
            

@&#INTRODUCTION@&#


                     What You Prove Is What You Execute (WYPIWYE) is a paradigm first proposed by Berry [1] for execution of safety-critical systems – systems in which incorrect program behavior can lead to serious damage including loss of life. The WYPIWYE paradigm has been successfully applied to compilation of languages with a formal semantics such as Esterel [2], Lustre [3] and Signal [4]. The usual approach to verifying properties of a program is via a model-checker [5,6]. Model-checking properties on controllers developed in synchronous languages have been successful since these languages are based on a formal semantics. The semantics for both sequential and concurrent computation allows one to generate models or embed the compiler generated code into model-checkers, which can then be used to verify properties of programs. Model-checking, with its complete state exploration and counter example (witness) generation, greatly complements the standard programming approach of unit testing for bug detection in safety-critical programs. In this paper we extend the WYPIWYE approach to safety-critical programs developed in Globally Asynchronous Locally Synchronous (GALS) [7] languages, in particular SystemJ. GALS is an extension of the synchronous Model of Computation (MoC), wherein a number of synchronous islands are composed asynchronously to achieve a given task.

Although a rigorous study of verification of GALS systems is important in itself, our motivation for verification is derived from practical needs. In this paper we verify properties on GALS programs designed in the Safety-Critical SystemJ (SC-SystemJ) programming language, which is a subset of the SystemJ language [8] suitable for verifying functional correctness properties of safety-critical systems. The SystemJ language extends Esterel style synchrony with CCS/CSP [9,10] style asynchrony and rendezvous channel communication between synchronous program islands. Java is used for data computation. SystemJ is based on formal semantics and is being used to design different types of embedded systems [11,12] including those used in industrial automation and control. Those systems, consist of components, especially, embedded controllers that need safety and real-time guarantees within a larger context. During our study of industrial control systems (manufacturing and home automation systems) we found that the critical control components usually use pure (binary) signals due to the nature of controlled system. Thus designers only use binary signals and channels for programming the critical low-level control components, while Java data-support is used to build higher level of intelligence such as high-level decision making and cloud support. SystemJ currently lacks the tools to verify these safety-critical parts of the overall system, leaving a large gap, which in our studies we found cannot be fulfilled using unit testing alone. Static (design time) guarantees are essential to forward looking manufacturers. Thus, following this pressing industrial demand for verification tools of critical control dominated components, in this paper we provide a technique for WYPIWYE control dominated SC-SystemJ GALS program compilation.

The main advantage of the compilation techniques presented in this paper is the ability to verify properties of programs before deployment. The technique presented in this paper transforms SC-SystemJ program into an intermediate format; a network of Finite State Machines (FSMs). Promela [13] code is generated from this intermediate format. These Promela models, which capture the behavior of the SC-SystemJ program, are used for verifying the functional correctness properties via the SPIN model-checker [14]. The verified model is then used for carrying out a simple syntactic translation into ‘C/Java’ executable, thereby guaranteeing the WYPIWYE paradigm as stated by Berry [1].

The proposed WYPIWYE tool-chain flow for generating WYPIWYE executables is shown in Fig. 1
                     . The tool-chain flow is as follows:
                        
                           1.
                           
                              An informal (natural language) and control logic and (optionally) plant model descriptions are converted into SC-SystemJ programs.

Here, control logic is a program, controlling operations of the system. On the other hand, plant is the environment, providing input stimuli to this control system. Control logic and plant model are then combined together to form a single SC-SystemJ program, making the overall system a closed loop control system for verification. This technique is required for verifying certain types of functional properties of a system, which make certain assumptions on the environment, i.e. the system will halt when the heat or air conditioning is not working. On the other hand, system can be left open, i.e. without a plant model, for verifying the properties which should hold regardless of the event generated from the environment, e.g., verifying the absence of deadlocks in the control logic.


                              Apply inductive semantic transition rules to translate the SC-SystemJ program into a propositional Linear Temporal Logic (LTL) formula.

The SC-SystemJ program (optionally combined with a plant) is first converted into a propositional LTL formula. These formulas are then converted into a network of Labeled Generalized Büchi Automata (LGBA) [15], a type of finite state machine that accepts infinite input sequence. Finally, a novel algorithm (cf. Algorithm 3) is applied to transform these automata into a network of deterministic Mealy automata.


                              Generate a network of Promela processes and verify properties on the program.

The network of Mealy automata generated in Step-2 is then converted into a network of Promela processes, which is given as an input to the SPIN model checker. Properties specified in LTL formulas are checked on these Promela processes.


                              Generate an executable.

If all specified properties are verified with SPIN in Step-3, then the SC-SystemJ control logic is directly compiled into executable C or Java code, using a straightforward syntactic translation technique, and deployed on the target execution platform. If the verification stage fails, a witness (fault trace) is generated and can be used to update the control logic or original specification of the system.

The next section further discusses our motivation behind introducing the SC-SystemJ, a safety-critical subset of the SystemJ language.

@&#MOTIVATION@&#

One of the major features of the SystemJ language is the ability to perform data-computations using Java, which appeals to many traditional software developers who are already familiar with imperative and object-oriented programming concepts. For example, developers are allowed to implement complex data-structures in the program using Java's full-featured standard libraries.

Since SystemJ programs are compiled into Java source code, all the data-oriented computations described in Java can also be easily included in the back-end code for execution. While such features make the SystemJ language very flexible, enabling programming to target a wide range of application domains, it is not well suited for designing safety-critical systems because:
                        
                           (1)
                           
                              Garbage collection (GC) is a necessity in the object-oriented programming model of Java. Typical data-computations described in Java often require allocating memory at runtime for newly created objects. GC is an automatic memory management process, which de-allocates memory occupied by those objects when they are no longer used by the program. It is a well-known problem that a tight bound of the worst-case GC cycle time is difficult to find, and the results are largely overestimated [16].


                              Conflicts with the SystemJ semantics due to Java threading model makes the SystemJ program hard to analyze. For example, SystemJ programmers are able to create Java threads at runtime, and even perform inter-process communication with SystemJ's native concurrent processes (called clock-domains and reactions). Yet, there is no semantic rule defining how these processes should run and interact with the Java threads. Such semantic ambiguity introduced by Java is obviously unwanted in the verification of the SystemJ programs.

This paper introduces a subset of the SystemJ language called SC-SystemJ to address the aforementioned issues by restricting the use of Java constructs in the SystemJ language. More precisely, SC-SystemJ does not allow creating any Java objects in the program, and only supports primitive data types int and short. This avoids the requirements for triggering GC as well as of spawning additional threads at runtime, making SC-SystemJ suitable for developing safety-critical applications.

Semantics of the SystemJ language is based on Micro-Step Structural Operational Semantics (SOS) [17]. Micro-step semantics provide a way to compile SystemJ programs into an efficient executable while preserving the GALS model of computation (MoC) of the designed system. It gives a precise view of how the program would execute, in the presence of GALS concurrent processes (unlike Java threads), by defining a sequence of elementary nodes for every SystemJ kernel statement [8]. However, the constructed intermediate format based on the micro-step semantics is too fine-grained, i.e. the size of the state space generated during verification is large, which can increase the verification time quite significantly. Moreover, one cannot easily correlate the program state in the intermediate format generated from the micro-step semantics [8] with the exact location in the SystemJ program. This makes the formulation of correctness properties particularly difficult in the verification process. As it will be seen in later sections, the intermediate format used by SC-SystemJ has a direct correlation with the states in the program, specified explicitly by the programmer using SC-SystemJ statements.

Our main contributions in this paper are: (1) a novel correct-by-construction approach generating network of finite state automata from SC-SystemJ GALS programs automatically and (b) a novel automaton generation approach that scales well for GALS programs.

The rest of the paper is organised as follows: Section 3 describes the related work. Section 4 familiarizes the reader to SC-SystemJ and its MoC informally. A brief introduction to Linear Temporal Logic (LTL) is given in Section 5 as a background to assist with the understanding of the transition semantics of the SC-SystemJ program described in Section 6. Next, generation of Mealy automata for synchronous and GALS programs as well as corresponding C (for execution) and Promela (for verification) code is presented in Section 7. Section 8 gives the verification results of benchmark programs. Finally, we conclude in Section 9.

@&#RELATED WORK@&#

Significant amount of research literature targets verification and WYPIWYE compilation of programs designed in synchronous languages like Esterel which SC-SystemJ extends. Halbawachs et al. [18] present an approach of using observer-based verification for synchronous programs. But, they only concentrate on safety properties – verifying that something bad never happens. Observer based verification of imperative Esterel programs is also carried out in [5], but unlike Halbwachs et al., authors in [5] automatically generate observers in Esterel from LTL properties. The advantage of using observer-based verification over LTL properties is flexibility – the user can program complex observers in the programming language itself and safety property verification using observers can be translated into reachability analysis [18]. The earlier versions of Esterel compilers [19], such as v2 and v3, also generate an automaton for an entire Esterel program. However, both these versions of Esterel compilers have been abandoned, because they carried out a syntactic translation of the source code using textual (or bit-state) regular expression matching, which lead to a large explosion in state space [20,21], thereby making the compiler run out of memory during compilation. The circuit (netlist) based compilers [22] designed to overcome the non scalable nature of automaton Esterel compilers convert netlist descriptions of Esterel programs into FSMs. These FSMs are then reduced using bisimulation equivalence and verified using observers. In contrast, our approach does a semantic analysis for building automaton and produces Promela processes from the SC-SystemJ program for verification based on using the SPIN model-checker. Moreover, it supports both; safety and liveness (i.e. something good eventually happens) property verification of GALS programs developed in SC-SystemJ.

The approach to automatically generating Promela code for verification of SC-SystemJ programs is not new. Ramesh et al. [23] developed a toolset for converting Communicating Reactive State Machines (CRSM) to Promela code for verification of GALS programs. Although, similar to our approach on a cursory look, their approach differs from ours in the way rendezvous communication between synchronous program islands interplays with reactivity. Whereas, our approach can be extended to real-time verification [24], their approach cannot. This is mainly due to their approach of giving up on reactions to input events at crucial moments during the rendezvous. Similar problem is inherited in Communicating Reactive Processes (CRP) [25], which is another GALS extension of Esterel. A number of other attempts have been made previously of encapsulating synchronous programs into asynchronous models. For example, [26–28] all verify GALS systems, by performing a shallow embedding of the compiled synchronous programs into Promela or some other model-checking engine designed to verify asynchronous system. In all these cases the communication between synchronous program islands is not programmed by the system designer, but rather added to the program at the verification stage using some specific features of the model-checker at hand. This breaks WYPIWYE philosophy, which is the goal of the presented work.

SC-SystemJ is a subset of the SystemJ programming language [8] following the GALS MoC. SC-SystemJ incorporates both Esterel style synchronous constructs and a variant of CCS/CSP style asynchronous constructs to ease design of complex systems. A SC-SystemJ program consists of a set of clock-domains (CDs), which run asynchronously at unrelated logical clock ticks (from here on referred to as tick). CDs synchronize and communicate with each other using point-to-point channels with variant of CSP style rendezvous for synchronization and data transfer. Each CD itself consists of one or more processes, called reactions, executing in lockstep, with the CD's tick. In Fig. 2
                     , Reaction11, Reaction12, etc. are synchronous parallel reactions. The reactions are combined and controlled using the synchronous parallel composition operator (
                        ∥
                     ). Reactions within the same CD communicate using the synchronous broadcast mechanism over objects called signals. Finally, a SC-SystemJ program interacts with its environment through a set of input and output signals. Asynchronous statements, CDs, and channels, are together responsible for the control-flow of SC-SystemJ programs. As explained previously, SC-SystemJ only allows primitive data-types for verification and any computation on these data types is considered instantaneous in terms of advancement of logical clock (no tick consumption).

A complete list of SC-SystemJ kernel statements is shown in Table 1
                     . Sequential SC-SystemJ statements are separated by a semicolon “;” similar to C and Java. Signals and channels are declared with the signal and channel statements, respectively. An optional associative and commutative operator op in the valued signal declaration statement is used to combine multiple emissions of signal values in the same tick. The tick boundaries are explicitly specified with pause, which can optionally be labeled with an arbitrary token L. As it will be seen later, these labels signify explicit states in the SC-SystemJ program. It should be noted that pause or any other statements enclosing pause are the only statements that consume logical time in SC-SystemJ. Signals are emitted using the emit statement, which sets their statuses to true for one tick. Signals can be assigned with a value using the hash (#) operator followed by the assignment operator (=). Signal values persist over ticks until they are overwritten with another hash/assignment operators. When a clock-domain pauses, all the output signals emitted in the current tick become available to the environment, and all the input signals to be processed in the next tick are captured from the environment. The while statement is a temporal loop that must contain at least one pause inside its body. There are also statements that allow programmers to change control-flow of a program based on presence of absence of the SC-SystemJ signal statuses. For example, the present-else statement is similar to if-else in traditional programming languages, but it branches program execution depending on the status of a signal or the evaluation of signal expressions. The abort(S) p; q statement preempts the on-going execution of a program body p if the signal expression S is evaluated to true. As a result, a program enters q and continues execution. Whenever the signal expression is evaluated to true, suspend preempts the program body, which it is enclosing, for one logical tick. But, unlike abort, suspend does not completely terminate the enclosing program body, and the program continues execution in the following tick from where it was last paused. SC-SystemJ reactions are composed using the synchronous parallel operator (
                        |
                        |
                     ) and make transition in lock-steps with the clock-domain's tick. Unlike SystemJ, use of Java computation is restricted in SC-SystemJ, and they cannot be directly used in the SC-SystemJ program. Programmers can still describe full-fledged Java-based data operations inside the extern function call. However, verification of the program logic using extern function call is not accommodated in this work, and left as future work.

A number of derived statements can be constructed with the kernel statements. For example, waiting for a signal σ can be expressed with the construct await(σ) as follows:
                        
                           (1)
                           
                              await
                              (
                              σ
                              )
                              ≔
                              abort
                              (
                              σ
                              )
                              while
                              (
                              true
                              )
                              pause
                              ;
                           
                        
                     
                  

Reactions in two asynchronously running clock-domains communicate via rendezvous style message passing over channel. A reaction in the sending clock-domain passes data over a channel using the send statement. On the other hand, the data can be received by a reaction in the receiving clock-domain using the receive statement. Lastly, data transferred through a channel or signal can be retrieved using the hash (#) operator.

Being an extension of Esterel, unsurprisingly, SC-SystemJ programs are also finite state machines (FSM). But unlike Esterel, which creates a single Mealy machine, following the pure synchronous MoC, SC-SystemJ programs are a network of mealy automaton. We further explain this concept using a simple manufacturing conveyor belt control system designed in SC-SystemJ shown in Fig. 3
                     .


                     Fig. 3 (a) shows a conveyor belt control system described in SC-SystemJ. The program consists of two clock-domains: CD1 and CD2, where CD1 detects an incoming item on a conveyor belt via signal in1 (line 6). CD1 then retrieves the value of the signal using the hash operator (#) (line 16) indicating the item's destination and sends it to CD2 via channel C. CD1 also stops emitting signal count1 upon arrival of the item (lines 9–14) to advise a status of the system to an environment (e.g. a monitoring computer). Upon receiving the message via channel (line 27), CD2 relays the item's path to a mechanical arm, which picks up the item and places it to the next manufacturing unit, via signal mv_belt (line 29). Similar to CD1, CD2 stops emitting signal count2 to an environment (line 32) when the item is removed from the conveyor belt (line 30).


                     Fig. 3 (b) gives the execution trace of this SC-SystemJ program. The circles in the figure show the states of the program. The filled in circles show the states of the first CD, while the empty ones show the states of the second CD. The two traces are completely unrelated – running at their individual ticks. CD1 starts from the dummy start state denoted 
                        
                           
                              st
                           
                           
                              1
                           
                        
                     . In the first logical tick, CD1 is in both: states S0 and S1 (
                        ∧
                      is the logical conjunction symbol) together. States S0 and S1 correspond to the two labels S0 and S1 annotated to the await and pause statements, respectively, in Fig. 3(a). Since, the await statement is derived from the pause construct (see Eq. (1)the labels correspond to the pause, which indicate the completion of the logical tick. Once, the input signal in1 is available in this tick, progress is made to internal states (denoted by $1 and $2), which rendezvous with the second CD. Upon successful completion of the rendezvous the sent signal is emitted in the state $2 and the transition is made back to the state 
                        S
                        0
                        ∧
                        S
                        1
                     . Similar behavior can be observed for the second CD.

There are a number of important points to note from this trace:
                        
                           •
                           
                              Big-step execution of CDs: We are only concerned with the state-transitions. For example, when we are in the await statements of the first CD together, we are in states 
                                 S
                                 0
                                 ∧
                                 S
                                 1
                              , it is of no concern how we reached this state, i.e., if we executed S0 before S1 or vice-versa. The important point is that at the end of tick we are in both states S0 and S1. These are called big-step semantics. This is in complete contrast to the micro-step semantics of the original SystemJ described by Malik et al. [8] required to reach 
                                 S
                                 0
                                 ∧
                                 S
                                 1
                               at the end of the logical tick, which are interleaved. Big-step semantics are amenable to verification [2] and correct by construction code generation. Micro-step semantics on the other hand are good for compiler construction, but inadequate for verification due to the concentration on very low-level details.


                              Interleaved CD execution: The Mealy automata representing each of the CDs together form a network similar to that described in CSP [10]. This network of Mealy automata progress in an interleaved manner. This unrelated progress in terms of logical ticks makes each CD suitable for distribution across multiple machines.


                              No synchronous rendezvous transition: Unlike CSP/CCS, the network of automaton in SC-SystemJ do not share a common synchronous rendezvous transition (see Fig. 3(b)). Unlike CSP/CCS, where each process in the network is sequential, GALS inherently consists of hierarchical parallelism – notice that each CD may itself be composed of multiple synchronous parallel reactions. Blocking rendezvous in GALS model is impossible to implement [29] without loss of distribution or reactivity and hence, we take a slightly different approach to rendezvous – blocking at the logical tick level (cf. Section 6.2.1).

A brief introduction on Linear Temporal Logic (LTL) is presented in this section in order to help readers understand semantics of the SC-SystemJ language. LTL is a temporal logic, which has been used for many years as a language to build a formal specification of the concurrent programs. Temporal logic like LTL consists of a set of propositions, for example ‘the program is in an idle state’, which can be qualified in terms of time, for example ‘the program will always eventually go out of the idle state’. One or more propositions combined with usual boolean operators (e.g. conjunction and disjunction) form an LTL formula, which is used for establishing formal reasoning about the concurrent programs represented as infinite sequences of states. Such LTL formulas are used by various types of verification tools, such as model-checkers, in order to verify the program (system) properties such as deadlock freedom and freedom from starvation.

Formally, LTL is evaluated over the infinite sequence of states (or labels) 
                        π
                        =
                        
                           
                              q
                           
                           
                              0
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              1
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              2
                           
                        
                        ,
                        …
                     , where for all i, there exists a transition 
                        
                           
                              q
                           
                           
                              i
                           
                        
                        →
                        
                           
                              q
                           
                           
                              i
                              +
                              1
                           
                        
                      and π
                     
                        i
                      is the suffix of π starting from the ith state, i.e. 
                        
                           
                              q
                           
                           
                              i
                           
                        
                        ,
                        
                           
                              q
                           
                           
                              i
                              +
                              1
                           
                        
                        ,
                        …
                     . A well-formed LTL formula consists of atomic propositions, generally specified in alphabets x, y, or p, boolean (logical) operators, such as and (
                        ∧
                     ), or (
                        ∨
                     ), and not (
                        ¬
                     ), and temporal operators for describing time, such as next (
                        X
                     ) and until (
                        U
                     ). When every atomic proposition 
                        p
                        ∈
                        P
                      is an LTL formula, then all of the following are also LTL formulas: 
                        ¬
                        p
                     , 
                        
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                        
                        ∧
                        
                           
                              p
                           
                           
                              2
                           
                        
                     , 
                        X
                        p
                      and 
                        
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                        
                        U
                        
                           
                              p
                           
                           
                              2
                           
                        
                      where
                        
                           
                              π
                              ⊨
                              p
                              
                              iff
                              
                              p
                              ∈
                              
                                 
                                    q
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                              p
                              ∈
                              P
                              π
                              ⊨
                              ¬
                              p
                              
                              iff
                              
                              π
                              ⊭
                              p
                              π
                              ⊨
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ∨
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              
                              iff
                              
                              π
                              ⊨
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              
                              or
                              
                              π
                              ⊨
                              
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                              
                              π
                              ⊨
                              X
                              p
                              
                              iff
                              
                              
                                 
                                    π
                                 
                                 
                                    1
                                 
                              
                              ⊨
                              p
                              π
                              ⊨
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              U
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              
                              iff
                              
                              ∃
                              i
                              ≥
                              0
                              
                              s
                              .
                              t
                              .
                              
                              
                                 
                                    π
                                 
                                 
                                    i
                                 
                              
                              ⊨
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              
                              and
                              
                              
                                 
                                    π
                                 
                                 
                                    j
                                 
                              
                              ⊨
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                              ∀
                              j
                              ,
                              
                              0
                              ≤
                              j
                              <
                              i
                              .
                           
                        
                     
                  

For a given infinite sequence of states π, a proposition p is true if and only if 
                        p
                        ∈
                        
                           
                              q
                           
                           
                              0
                           
                        
                        ,
                        where
                        
                        p
                        ∈
                        P
                     . In this case, it is said π entails (⊨) p. The boolean operators ∨ and 
                        ¬
                      imply logical disjunction and negation, respectively. For example, LTL formula 
                        
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                        
                        ∨
                        
                           
                              p
                           
                           
                              2
                           
                        
                      holds for an infinite sequence of states π when either one of the propositions p
                     1 
                     or p
                     2 hold at q
                     0. Also 
                        ¬
                        p
                      holds for π when p does not hold at q
                     0. Temporal operator 
                        X
                        p
                      states that the proposition p holds in the next state. On the other hand 
                        
                           
                              
                                 p
                              
                              
                                 1
                              
                           
                        
                        U
                        
                           
                              p
                           
                           
                              2
                           
                        
                      states that the proposition p
                     1 holds from q
                     0 
                     until p
                     2 holds in some q
                     
                        j
                      where 
                        j
                        ≥
                        0
                     . Graphical illustrations of these temporal operators are shown in Fig. 4
                     .

There are also a number of other LTL operators which can be derived from the kernel LTL operators shown above: 
                        
                           
                              ⊤
                              ≡
                              p
                              ∨
                              ¬
                              p
                              ⊥
                              ≡
                              ¬
                              ⊤
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ∧
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              ≡
                              ¬
                              (
                              ¬
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ∨
                              ¬
                              
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                              
                              )
                              F
                              p
                              ≡
                              ⊤
                              U
                              p
                              G
                              p
                              ≡
                              ¬
                              F
                              ¬
                              p
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ⟹
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              ≡
                              ¬
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ∨
                              
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                              
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ⟺
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                              ≡
                              (
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              ⟹
                              
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                              
                              )
                              ∧
                              (
                              
                                 
                                    
                                       p
                                    
                                    
                                       2
                                    
                                 
                              
                              ⟹
                              
                                 
                                    
                                       p
                                    
                                    
                                       1
                                    
                                 
                              
                              )
                           
                        
                     
                  

The boolean true and false operators are denoted by 
                        ⊤
                      and 
                        ⊥
                     , respectively. The logical conjunction (∧) is constructed using combinations of logical negations (
                        ¬
                     ) and a logical disjunction (∨). Two additional temporal operators 
                        F
                      and 
                        G
                      are also frequently used. For example, 
                        F
                        p
                      states that the proposition p will eventually hold in the future, whereas 
                        G
                        p
                      states that p holds globally. Fig. 5
                      shows two infinite paths, which illustrate these temporal operators. Lastly, operators 
                        ⟹
                      and 
                        ⟺
                      are used for logical implication and equivalence, respectively.

This paper employs LTL for two major reasons: (1) to build a formal property specification of the SC-SystemJ programs, and (2) to model behavior of SC-SystemJ CDs.

Formal specification is used to verify the properties of SC-SystemJ programs. In order to verify SC-SystemJ programs, however, a transition system first needs to be derived, which is a formal model used for describing the behavior of SC-SystemJ CDs. In this paper, the transition system of a CD is derived inductively using the control-flow and data-flow semantics of the SC-SystemJ statements. These semantics are described in LTL. Therefore, the resultant transition system is also an LTL formula. 
                        Definition 1
                        
                           Transition system: Every SC-SystemJ CD is a Mealy machine 
                              (
                              Q
                              ,
                              st
                              ,
                              I
                              ,
                              O
                              ,
                              Y
                              ,
                              A
                              ,
                              T
                              )
                            where:
                              
                                 •
                                 
                                    Q is the set of states


                                    
                                       st
                                       ∈
                                       Q
                                     is the starting state


                                    I is the set of input signals


                                    O is the set of output signals


                                    Y is the set of internal signals


                                    A is the set of actions


                                    T is the transition relation: 
                                       T
                                       ⊆
                                       Q
                                       ×
                                       B
                                       (
                                       I
                                       ∪
                                       O
                                       ∪
                                       Y
                                       )
                                       ×
                                       
                                          
                                             2
                                          
                                          
                                             O
                                          
                                       
                                       ×
                                       
                                          
                                             2
                                          
                                          
                                             Y
                                          
                                       
                                       ×
                                       
                                          
                                             2
                                          
                                          
                                             A
                                          
                                       
                                       ×
                                       Q
                                    . 
                                       B
                                       (
                                       i
                                       )
                                     is a Boolean expression over the symbols in 
                                       I
                                       ∪
                                       O
                                       ∪
                                       Y
                                    .

The system defined above consists of all the states of the CD as well as the transition relations between these states. The generation of this system, which will be presented in the following section, is inductively derived from the SC-SystemJ statements. The resultant transition system is a single LTL formula, which describes all possible executions of a SC-SystemJ CD. On the other hand, the asynchronous composition of CDs is given in terms of a transition system (rather than giving it inductively), because, although an inductive definition of the asynchronous composition is possible, the result is a single automaton, which can no longer be distributed across different machines to extract parallelism. Furthermore, as will be presented in Section 8, well developed model-checking tools, such as SPIN [13], already provide efficient asynchronous composition of a network of automata and, hence, building such a network suffices for both verification and code generation.

The transition semantics of the SC-SystemJ language is inspired by [30]. In their work, Schneider gives an inductive definition of the transition semantics of the purely synchronous language, called Quartz [31]. In this paper, his definitions of Quartz language have been extended (and in some places corrected) to GALS systems with addition of delayed signal semantics, i.e. system always reacts to the internally emitted signals from the previous tick, as well as new data-flow semantics. Moreover, while transition system of Quartz is used for proving properties of Quartz via interactive theorem provers, this paper focuses on WYPIWYE program compilation.

Every SC-SystemJ transition system consists of control flow and data flow. For ease of understanding, the control flow semantics and the data flow semantics are described separately.

The pause construct is the only construct in SC-SystemJ programs to demarcate the end of logical tick and also represent the states of the program. Every pause construct in the SC-SystemJ program is labelled either by the programmer or internally by the compiler. This label on the pause construct indicates the state of the program. For example, the program is in some state l if the control-flow is in a statement with label l. Formally, all the reachable states in some statement S are defined as
                              
                                 (2)
                                 
                                    in
                                    (
                                    S
                                    )
                                    ≔
                                    
                                       
                                          
                                             ⋁
                                          
                                          
                                             l
                                             ∈
                                             labels
                                             (
                                             S
                                             )
                                          
                                       
                                    
                                    l
                                 
                              
                           
                        

Additionally, there are four types of control-flow predicates, which are used to describe the state of execution of SC-SystemJ statement S: 
                              Definition 2
                              
                                 
                                    Inst
                                    (
                                    S
                                    )
                                 : Given a SC-SystemJ statement S, Inst(S) defines all the conditions where the control-flow instantaneously terminates.

Informally, control-flow never encounters pause inside S.
                              Definition 3
                              
                                 
                                    Enter
                                    (
                                    S
                                    )
                                 : Given a SC-SystemJ statement S, Enter(S) defines all the conditions where the control flow enters S.

Informally, control-flow encounters one or more pause statements inside S.
                              Definition 4
                              
                                 
                                    Term
                                    (
                                    S
                                    )
                                 : Given a SC-SystemJ statement S, Term(S) defines all the conditions where the control flow terminates (exits) S.

Informally, control-flow leaves all pause constructs inside S.
                              Definition 5
                              
                                 
                                    Move
                                    (
                                    S
                                    )
                                 : Given a SC-SystemJ statement S, Move(S) defines all the conditions where the control flow moves from some state inside S to another state inside S.

Informally, control-flow moves from one or more pause statements in S to another 
                              pause
                              (
                              s
                              )
                            in S. Finally, there is also the possibility that the control flow loops on the same state(s). This is called stutter. Formally, stutter is defined as follows (X is the next-time operator):
                              
                                 (3)
                                 
                                    stutter
                                    (
                                    S
                                    )
                                    ≔
                                    
                                       
                                          
                                             ⋀
                                          
                                          
                                             l
                                             ∈
                                             labels
                                             (
                                             S
                                             )
                                          
                                       
                                    
                                    (
                                    l
                                    ⟺
                                    Xl
                                    )
                                 
                              
                           
                        

For a SC-SystemJ statement S, given 
                              st
                              ⟹
                              Term
                              (
                              S
                              )
                              ∨
                              ¬
                              in
                              (
                              S
                              )
                            holds, the transition system 
                              T
                              (
                              st
                              ,
                              S
                              )
                            in the disjunctive normal form (DNF) is defined as follows:
                              
                                 (4)
                                 
                                    T
                                    (
                                    st
                                    ,
                                    S
                                    )
                                    ≔
                                    (
                                    
                                       
                                          
                                             
                                                (
                                                st
                                                ∧
                                                Inst
                                                (
                                                S
                                                )
                                                ∧
                                                ¬
                                                Xin
                                                (
                                                S
                                                )
                                                )
                                                ∨
                                             
                                          
                                          
                                             
                                                (
                                                st
                                                ∧
                                                Enter
                                                (
                                                S
                                                )
                                                )
                                                ∨
                                             
                                          
                                          
                                             
                                                (
                                                ¬
                                                st
                                                ∧
                                                ¬
                                                Xin
                                                (
                                                S
                                                )
                                                )
                                                ∨
                                             
                                          
                                          
                                             
                                                Move
                                                (
                                                S
                                                )
                                             
                                          
                                       
                                    
                                    )
                                 
                              
                           For given SC-SystemJ statement S, Eq. (4) is applied inductively until its disjunctive normal form contains no control-flow predicates. Eq. (4) is only valid under the assumption that in the starting state st, program is not running. Furthermore, in Eq. (4) the four clauses indicate:
                              
                                 (1)
                                 
                                    Instantaneous transition: The program S can make an instantaneous transition from st if there are no pause statements in the CD.


                                    Entering transition: The program can settle at the first pause encountered in the program.


                                    Terminate transition: The program can terminate.


                                    Move transition: The program can move from some pause statement inside S to some other pause statement inside S.

The inductive definitions for the SC-SystemJ statements are shown in Figs. 6 and 7
                           
                           . The conditions whether the SC-SystemJ statement can be instantaneously terminated are defined by Inst as shown in Fig. 6(a). When Inst is applied to a signal or channel declaration, the inductive definition evaluates them to ⊤, which means true. It is trivial to see this since it is already known that pause is the only SC-SystemJ statement, which consumes a logical tick. Inst of the signal emission statement 
                              emit
                              
                              γ
                            gives 
                              X
                              γ
                           , which means that the proposition (i.e. emission of the signal) holds in the next state. On the other hand, because pause cannot terminate instantaneously, its induction rule gives 
                              ⊥
                           . The Inst of present statement is defined as disjunction of two conjunctive clauses, since always only one of the clauses will be evaluated to 
                              ⊤
                           . The first clause checks for the presence of the signal σ while other checks for its absence 
                              ¬
                              σ
                           . The Inst rule does not check σ for the abort and suspend statements. Inst of sequential (
                              s
                              1
                              ;
                              s
                              2
                           ) and synchronous parallel statements (
                              s
                              1
                              ∥
                              s
                              2
                           ) checks whether both s1 and s2 can be instantaneously terminated i.e. contain no pause statements. Hence, they are both expanded to logical conjunction of Inst of s1 and s2, respectively. Finally, Inst of while is evaluated to Inst(s). Note that since while block should contain at least one pause (Section 4), 
                              Inst
                              (
                              while
                              (
                              true
                              )
                              
                              s
                              )
                            should never evaluate to ⊤ for any correct SC-System program.


                           Enter condition of SC-SystemJ statements is shown in Fig. 6(b). Control-flow cannot enter (i.e. consume a logical tick) the signal and channel declarations and emit statements. Hence, Enter of these statements are evaluated to 
                              ⊥
                           . On the other hand, 
                              Enter
                              (
                              l
                              :
                              pause
                              )
                            results in Xl, which means the CD will settle at state labelled l at the end of current program transition. Inductive definitions of Enter for abort, suspend and while are simply Enter of their enclosing bodies. Similar to Inst, Enter of present is expanded to disjunction of two conjunctive clauses and their evaluations are dependent on the status of the signal σ. For the sequential statement 
                              s
                              1
                              ;
                              s
                              2
                           , the inductive rule has two clauses, which check whether control-flow can settle on s1 or instantaneously terminate s1 and settle on s2. Finally, Enter of the parallel statement 
                              s
                              1
                              ∥
                              s
                              2
                            has three clauses: whether control-flow can settle at either one of them or on both simultaneously.

The rest of definitions are shown in Fig. 7, where Term and Move are defined in Fig. 7(a) and (b), respectively. By definition (see Eq. (4)), Term(s) requires that program control-flow to have previously settled on s and now terminate (exit) s. Hence, Term of all instantaneous statements are evaluated to 
                              ⊥
                           . Then one can easily see that 
                              Term
                              (
                              l
                              :
                              pause
                              )
                              ≔
                              l
                           . Term of present checks whether the control-flow can terminate present (s1) or else (s2) branch similar to Inst and Enter. Note that signal checks for σ are not necessary in these clauses since the control-flow is already in the body of the present-else statement. On the other hand, abort can only be terminated when; the control-flow is in the body of abort 
                           and the signal σ is present, or it exits the abort body normally. For suspend, control-flow can only terminate the body when the signal is absent, i.e. 
                              ¬
                              σ
                            holds. Term of sequential and parallel statements are defined similar to Enter. Term rules check for every possible combination of terminating conditions for these statements. Lastly, the while loop can never be terminated hence it is evaluated to 
                              ⊥
                           .

Program s can Move from one state to another if there are at least two pauses in s or a single pause in a loop. Therefore, Move of all statements that violate these conditions are evaluated to 
                              ⊥
                           . Move of present is similar to Term except that there are additional next time conditions (
                              ¬
                              Xin
                              (
                              s
                              2
                              )
                            and 
                              ¬
                              Xin
                              (
                              s
                              1
                              )
                           ), which make sure that the control-flow does not jump to the other branches. Note that abort can only Move when the signal σ is absent. For suspend, control-flow stutters when 
                              σ
                              =
                              ⊤
                            and control-flow is already inside the body of suspend. Control-flow can move inside suspend when 
                              σ
                              =
                              ⊥
                           . Move of the sequential statement 
                              s
                              1
                              ;
                              s
                              2
                            is defined as three disjunctive clauses: (1) the program control-flow can move inside s1 while not in s2, (2) vice-versa, and (3) it terminates s1 and enters s2. There are five conditions for which control-flow can move inside the parallel statement 
                              s
                              1
                              ∥
                              s
                              2
                           : (1) when it is currently only in s1, (2) only in s2, (3) in both s1 and s2 simultaneously, (4) in both s1 and s2 and s1 terminates, and (5) in both s1 and s2 and s2 terminates. Lastly for the while statement, the control-flow either can move inside the loop body or terminate the body and re-enter the loop, i.e., 
                              Term
                              (
                              s
                              )
                              ∧
                              Enter
                              (
                              s
                              )
                           .

These inductive rules are applied to the SC-SystemJ program until DNF of Eq. (4) consists of only atomic propositions such as program labels and signals.

Definitions for the SC-SystemJ data statements are shown in Fig. 8
                           . Note that only Inst of these statements are shown in Fig. 8(a) since none of their executions consume a tick, i.e. they are instantaneous statements. Hence, Move, Enter and Term of these statements are all 
                              ⊥
                           . Programmers specify associative and commutative operator z in the signal declaration statement for combining multiple emissions of the same valued signal. This operator combines multiple values, which are emitted multiple times in a single program transition, into a single value. Signal value is assigned to an evaluated result of an expression using the hash operator #. Conditional data expressions can be checked using the if-else statement. Lastly, an external function can be called using extern function with optional arguments dataexpr
                           
                              n
                            separated by commas.


                           Inst of every data-flow statement results in a unique proposition γ in the equivalent LTL formula. For instance, all of the data statements except if-else are defined as 
                              X
                              γ
                           , which means that γ holds in the next state. Indeed, similar to 
                              Inst
                              (
                              emit
                              
                              γ
                              )
                            shown in Fig. 6(a), a result of data computations is also delayed by one tick. Inst of if-else in the data-flow semantics is akin to present-else statement in Fig. 6(a) except that Inst of s1 and s2 are logically connected with γ instead of the signal proposition σ. Let D be a set of data computations in the SC-SystemJ program, then a function 
                              f
                              :
                              γ
                              →
                              d
                           , such that 
                              d
                              ∈
                              D
                           , maps a proposition γ to a valuation d as shown in Fig. 8(b). Here, a valuation of some expression is denoted by 
                              
                                 
                                    [
                                    [
                                    expr
                                    ]
                                    ]
                                 
                                 
                                    σ
                                 
                              
                            whose result is assigned to a signal σ, whereas 
                              [
                              [
                              expr
                              ]
                              ]
                            returns a result without assignment. For the mapping of γ
                           2, operator 
                              op
                            
                           
                              
                                 
                                    z
                                 
                                 
                                    σ
                                 
                              
                              :
                              v
                              →
                              
                                 
                                    Z
                                 
                                 
                                    ≥
                                    0
                                 
                              
                              ,
                              
                                 
                                    z
                                 
                                 
                                    σ
                                 
                              
                              ∈
                              {
                              +
                              ,
                              ⁎
                              }
                            is defined as 
                              dataexpr
                              +
                              
                                 
                                    c
                                 
                                 
                                    σ
                                 
                              
                            for 
                              d
                              =+
                            and 
                              dataexpr
                              ⁎
                              
                                 
                                    c
                                 
                                 
                                    σ
                                 
                              
                            for 
                              d
                              =
                              ⁎
                           , where c
                           
                              σ
                            is the current value of a signal σ. Finally, the mapping of γ
                           4 returns a function λ whose mapping is dependent on the host language's function (C or Java). These inductive rules build the transition system in Eq. (4) or equivalently the system defined in Definition 1. Given that the transition system for a CD is described, we are now ready to define properties of the SC-SystemJ CD; primarily determinism and reactivity.

The following definitions are applied to a single SC-SystemJ CD, which is a pure synchronous program. 
                              Definition 6
                              
                                 Reactivity: A transition system M is reactive if in any of its state q and for any monomial b involving its input symbols, there is a transition out of q with 
                                    
                                       
                                          b
                                       
                                       
                                          ′
                                       
                                    
                                  as the guard such that b satisfies guard 
                                    
                                       
                                          b
                                       
                                       
                                          ′
                                       
                                    
                                 .

Consider two simple transition systems as shown in Fig. 9
                           , each composed of two states S1 and S2 and two inputs a and b. In this example, both output signals and actions for all transitions are ∅, and omitted for simplicity. The system shown in Fig. 9(a) is reactive because it can take a transition out of both states with every combination of input signals i.e. 
                              a
                              ∧
                              b
                              ,
                              ¬
                              a
                              ∧
                              b
                              ,
                              a
                              ∧
                              ¬
                              b
                            and 
                              ¬
                              a
                              ∧
                              ¬
                              b
                           . On the other hand, the system in Fig. 9(b) is non-reactive since there are certain combinations of the input signals, e.g. 
                              ¬
                              a
                              ∧
                              ¬
                              b
                           , which do not have a corresponding outgoing transition from the states S1 or S2. 
                              Definition 7
                              
                                 Determinism: A transition system M is deterministic if in any of its state q if there are two outgoing distinct transitions 
                                    (
                                    q
                                    ,
                                    
                                       
                                          b
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          O
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          A
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             q
                                          
                                          
                                             1
                                          
                                       
                                    
                                    )
                                  and 
                                    (
                                    q
                                    ,
                                    
                                       
                                          b
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          O
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          Y
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          A
                                       
                                       
                                          2
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             q
                                          
                                          
                                             2
                                          
                                       
                                    
                                    )
                                 , then 
                                    
                                       
                                          
                                             b
                                          
                                          
                                             1
                                          
                                       
                                    
                                    ∧
                                    
                                       
                                          b
                                       
                                       
                                          2
                                       
                                    
                                  is false.

Consider another pair of transition system shown in Fig. 10
                           . Both transition systems can take a transition to either state S2 or state S3 from state S1 depending on an input symbol a. Similar to Fig. 9, output signals and actions are omitted in this figure, since they are all ∅. In Fig. 10(a), there are two distinct transitions from S1 with the guards a and 
                              ¬
                              a
                           , respectively. Since there is only one unique input symbol for the transition to S2 and S3, the system is deterministic. On the other hand, Fig. 10(b) is non-deterministic, since the system can make transition to either S2 and S3 for the same input a.

Given two transition systems, 
                           M
                           =
                           (
                           
                              
                                 Q
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 st
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 I
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 O
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 A
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 
                                    T
                                 
                                 
                                    1
                                 
                              
                           
                           )
                         and 
                           N
                           =
                           (
                           
                              
                                 Q
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 st
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 I
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 O
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 A
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 
                                    T
                                 
                                 
                                    2
                                 
                              
                           
                           )
                        , then the asynchronous composition is defined as follows: 
                           M
                           >
                           <
                           N
                           =
                           (
                           
                              
                                 Q
                              
                              
                                 1
                              
                           
                           ×
                           
                              
                                 Q
                              
                              
                                 2
                              
                           
                           ,
                           (
                           
                              
                                 st
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 
                                    st
                                 
                                 
                                    2
                                 
                              
                           
                           )
                           ,
                           
                              
                                 
                                    I
                                 
                                 
                                    1
                                 
                              
                           
                           ∪
                           
                              
                                 I
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 
                                    O
                                 
                                 
                                    1
                                 
                              
                           
                           ∪
                           
                              
                                 O
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 
                                    Y
                                 
                                 
                                    1
                                 
                              
                           
                           ∪
                           
                              
                                 Y
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 
                                    A
                                 
                                 
                                    1
                                 
                              
                           
                           ∪
                           
                              
                                 A
                              
                              
                                 2
                              
                           
                           ,
                           T
                           )
                        , where
                           
                              (5)
                              
                                 T
                                 ≔
                                 (
                                 
                                    
                                       
                                          
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             )
                                             ,
                                             
                                                
                                                   b
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   O
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Y
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   A
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             )
                                             |
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   b
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   O
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Y
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   A
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             ∈
                                             
                                                
                                                   T
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       
                                       
                                          
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             )
                                             ,
                                             
                                                
                                                   b
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                             
                                                
                                                   O
                                                
                                                
                                                   2
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Y
                                                
                                                
                                                   2
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   A
                                                
                                                
                                                   2
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             |
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                             
                                                
                                                   b
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                             
                                                
                                                   O
                                                
                                                
                                                   2
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Y
                                                
                                                
                                                   2
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   A
                                                
                                                
                                                   2
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             ∈
                                             
                                                
                                                   T
                                                
                                                
                                                   2
                                                
                                             
                                          
                                       
                                       
                                          
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             )
                                             ,
                                             
                                                
                                                   
                                                      b
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                             ∧
                                             
                                                
                                                   b
                                                
                                                
                                                   2
                                                
                                             
                                             ,
                                             (
                                             
                                                
                                                   
                                                      O
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             ∪
                                             
                                                
                                                   
                                                      O
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             ,
                                             (
                                             
                                                
                                                   
                                                      Y
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             ∪
                                             
                                                
                                                   
                                                      Y
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             ,
                                             (
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      1
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             ∪
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             ,
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   1
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      2
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                          
                                       
                                       
                                          
                                             |
                                             (
                                             
                                                
                                                   q
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   b
                                                
                                                
                                                   i
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   O
                                                
                                                
                                                   i
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   Y
                                                
                                                
                                                   i
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   A
                                                
                                                
                                                   i
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             
                                                
                                                   
                                                      q
                                                   
                                                   
                                                      i
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                             )
                                             ∈
                                             
                                                
                                                   T
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                             i
                                             =
                                             1
                                             ,
                                             2
                                          
                                       
                                    
                                 
                                 )
                              
                           
                        
                     

Note that Eq. (5) is different from asynchronous product defined in CCS [9], which consists of the so-called rendezvous transition (simultaneous transition of both the automata with shared communication actions). The handshake mechanism in the SC-SystemJ model is implemented using input and output signals and hence does not have a rendezvous transition. The implementation of SC-SystemJ channel is described in the following section.

The channel implementation in SC-SystemJ does not halt the complete CD, which differs from CCS/CSP [9,32] and CRSM [33]. Instead, SC-SystemJ channel is implemented using the four phase handshake mechanism via signals as shown in Fig. 11
                           . In Fig. 11, two CDs, called ‘Sender’ and ‘Receiver’, implement channel communication using signals called ACK and REQ. For each channel declaration, there is also a corresponding pair of ACK and REQ signals declared. These signals are hidden to the SC-SystemJ programmers in order to prevent their intervention in channel communications between CDs. The channel send and receive statements are rewritten into a sequence of SC-SystemJ kernel statements as shown in Algorithms 1 and 2, respectively, – note that the presented handshake mechanism, in these algorithms, leads to blocking at the logical tick level rather than halting the CD. 
                              Algorithm 1
                              Rewrite for 
                                    send
                                    
                                    C
                                  to a four phase handshake. 
                                    
                                       
                                          
                                          
                                          
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   abort 
                                                   ACK
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      wait
                                                      
                                                      for
                                                      
                                                      receiver
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               2
                                                            
                                                         
                                                         
                                                            
                                                         
                                                         
                                                            
                                                               3
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                  while
                                                                  (
                                                                  true
                                                                  )
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                  |
                                                                  
                                                                  pause
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      busy
                                                      
                                                      wait
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                             
                                                
                                                   4
                                                
                                                
                                                   abort 
                                                   !ACK
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      try
                                                      
                                                      to
                                                      
                                                      rendezvous
                                                      
                                                      with
                                                      
                                                      receiver
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               5
                                                            
                                                         
                                                         
                                                            
                                                         
                                                         
                                                            
                                                               6
                                                            
                                                         
                                                         
                                                            
                                                         
                                                         
                                                            
                                                               7
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                  while
                                                                  (
                                                                  true
                                                                  )
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                  |
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                              emit
                                                                              
                                                                              REQ
                                                                              ;
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              
                                                                              pause
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      emitting
                                                      
                                                      request
                                                      
                                                      to
                                                      
                                                      receiver
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Rewrite for 
                                    receive
                                    
                                    C
                                  to a four phase handshake. 
                                    
                                       
                                          
                                          
                                          
                                          
                                             
                                                
                                                   1
                                                
                                                
                                                   abort 
                                                   !REQ
                                                
                                                /⁎wait for sender ⁎/
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               2
                                                            
                                                         
                                                         
                                                            
                                                         
                                                         
                                                            
                                                               3
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                  while
                                                                  (
                                                                  true
                                                                  )
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                  |
                                                                  
                                                                  pause
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      busy
                                                      
                                                      wait
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                             
                                                
                                                   4
                                                
                                                
                                                   abort 
                                                   REQ
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      try
                                                      
                                                      to
                                                      
                                                      rendezvous
                                                      
                                                      with
                                                      
                                                      sender
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               5
                                                            
                                                         
                                                         
                                                            
                                                         
                                                         
                                                            
                                                               6
                                                            
                                                         
                                                         
                                                            
                                                         
                                                         
                                                            
                                                               7
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      |
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                  while
                                                                  (
                                                                  true
                                                                  )
                                                               
                                                            
                                                            
                                                               
                                                                  
                                                                  |
                                                                  
                                                                     
                                                                        
                                                                           
                                                                              
                                                                              emit
                                                                              
                                                                              ACK
                                                                              ;
                                                                           
                                                                        
                                                                        
                                                                           
                                                                              
                                                                              pause
                                                                           
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      /
                                                      ⁎
                                                      emitting
                                                      
                                                      acknowledgement
                                                      
                                                      to
                                                      
                                                      sender
                                                      
                                                      ⁎
                                                      /
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

The main reason for rewriting the channel statements is to preserve reactivity 
                           [2] and scalability of the SC-SystemJ program. Reactive system, by definition, is the system which has at least a single state transition for every given input signal that results in the production of a set of output signals [2]. Therefore, unlike CSP, SC-SystemJ CD blocks only at the logical tick on send and receive statements and allows other reactions to capture the inputs, perform internal transitions and produce the output signals. Ramesh [29] has shown the impossibility of robust channel communication when preemption is involved during rendezvous (e.g. via abort construct in SC-SystemJ) in CRP [25] programs. The problem is addressed by relaxing reactivity of the program, which discards inputs from the environment at certain crucial times during rendezvous between communicating nodes. On the other hand, SC-SystemJ CD does not discard any inputs during channel communication.

In contrast to the previous approaches, SC-SystemJ CDs are reactive even though preemption may occur during the rendezvous. Consequently, there are three possible scenarios that might arise from SC-SystemJ channel implementation as shown in Fig. 12
                           . 
                              
                                 Scenario-1
                              
                              
                                 Both CDs complete rendezvous without any preemption. This is the case when the program is written such that there are no statements nor input events from the environment that can preempt rendezvous operation between reactions in different CDs. Fig. 12(a) illustrates such a scenario. Consider the black and grey circles which show the execution traces of the sender and the receiver CDs, respectively. The sender first enters a busy wait state, waiting for the signal ACK coming from the receiver as shown in Algorithm 1 lines 1–3. Unlike the sender, the receiver can preempt the busy wait state since it checks for the absence of the signal REQ. The receiver then continuously emits the acknowledgement signal (ACK) until it receives the signal REQ (Algorithm 2 lines 4–7) from the sender. The signal ACK preempts the sender and it enters a state that continuously emits REQ. Finally, the receiver first completes the rendezvous followed by the sender (denoted by done in Fig. 12(a)).

One CD preempts during rendezvous and re-enters the rendezvous state. It is clear from the Algorithms 1 and 2 that CDs will eventually finish rendezvous provided that there is no execution path in the program such that the preempted reaction never reenters the same rendezvous point. Fig. 12(b) shows this case where the sender CD preempts before the receiver catches the REQ signal. CDs then synchronize later when the sender re-enters the rendezvous state.

One CD preempts during rendezvous and never re-enters the rendezvous state. This can result in deadlock where the sender or receiver never finish the rendezvous. Fig. 12(c) illustrates this scenario where the sender preempts while it is in the REQ state and the receiver remains blocked in the ACK state.

Deadlock is possible for Scenario-3 since preemption can arbitrarily change the execution order of channel communication statements. For instance, consider the example program in Fig. 13
                            where the signal O will almost always be emitted iff signal A is always absent. Consider the scenario wherein signal A preempts the second CD while both CDs are in the rendezvous state of channel C2. Consequently, both CDs are now at different rendezvous points such that CD2 will try to rendezvous with CD1 on C1 due to the enclosing loop, while CD1 is still blocked, waiting to complete a rendezvous on C2. Therefore, CD1 and CD2 will never be synchronized resulting in a deadlock.

Such deadlock detection can be checked through functional verification, using safety properties. Alternatively, one can use a programming style to write all rendezvous statements in separate synchronous parallel reactions without any preempting statements enclosing them.

SC-SystemJ GALS program comprises a network of CDs, which run asynchronously and communicate with each other, when necessary, in order to achieve a common goal. In this section, a sketch of a proof for the reactivity of a network of CDs is given. Asynchronous composition of reactive CDs may introduce non-deterministic behavior, which is also discussed in the upcoming section. 
                              Theorem 1
                              
                                 Given two transition systems M and N representing reactive CDs CD
                                 1 
                                 and CD
                                 2, respectively, then asynchronous composition of CD
                                 1 
                                 and CD
                                 2 (Eq. 
                                 (5)) resulting in the transition system K, is also reactive.

Eq. (5) states that the transition system resulting from the composition of two asynchronous CDs can have one of three possible state transitions: (1) transition of the first CD, (2) transition of the second CD, and (3) transition of both CDs. Furthermore, Definition 6 states that there is always a transition out of any of the states in M or N for any combination of input events. Then for any state in the transition system K, there is also at least one outgoing transition for any given input.□

On the other hand, given two CDs, which are deterministic, their asynchronous composition might be non-deterministic. To illustrate this, consider the example shown in Fig. 14
                           . Two transition systems representing CDs named CD1 and CD2 are shown in Fig. 14(a). Each CD consists of three states. States A and D are the initial states of CD1 and CD2, respectively. Each CD makes only a single transition from the initial state and settles on the resultant state forever. According to Definition 7, each of these CDs is deterministic and reactive; there are two distinct transitions out of the initial states, which are guarded by input symbols a, 
                              ¬
                              a
                            and b, 
                              ¬
                              b
                           , respectively. On the other hand, when these CDs are combined using the asynchronous composition given in Eq. (5), the resultant transition system is non-deterministic as shown in Fig. 14(b). For example, for an input symbol a, from the transition system in Fig. 14(b) can possibly make transition to one of three states from its initial state (A, D): (1) to (B, D) when only CD1 makes a transition or (2) to (A, F) when only CD2 makes a transition or (3) to (B, F) when both CD1 and CD2 make transitions. This is due to the fact that CDs can interleave (i.e. a CD can make a state transition while others do not) in the asynchronous composition. In other words, state transitions of one CD do not depend on others.

Determinism of SC-SystemJ programs can be categorized into two types: (1) weak determinism as described in [34] states that deterministic behavior of programs is based on the consistency of the program's response to a set of given inputs by only observing its outputs, and (2) strong determinism 
                           [34] states that internal state of the program should also be deterministic. We illustrate these concepts using the SC-SystemJ program shown in Fig. 15
                           . Here, CD1 tries to synchronize with CD2 in a loop (line 3) via a channel named C. CD2 blocks until the input signal A becomes present, which then emits O2 (line 13). However, when the execution of receive completes (line 11), CD2 can also emit O1. In order to ensure weak determinism, the observed behavior of the system should be deterministic [34], i.e., for the same sequence of inputs the system should always generate the same sequence of outputs. Under this assumption, the program in Fig. 15 is non-deterministic since for the same input A the system generates two different outputs; sometimes O1 only, and sometimes both O1 and O2. However, at the same time [34] also defines strong determinism where the internal behavior of the system should also be deterministic such that reactivity combined with strong determinism ensures that there exists a unique transition (reaction) from any given statements (states), whatever the inputs. Referring back to the example in Fig. 15, internal signals are used to implement receive C statement (line 11), such as REQ and ACK (Algorithm 2). This, together with the boolean expression 
                              B
                              (
                              I
                              ∪
                              O
                              ∪
                              Y
                              )
                            in the transition relation T given in Definition 1, results in two distinct transitions: 
                              B
                              (
                              {
                              A
                              ,
                              
                                 
                                    
                                       REQ
                                    
                                    
                                       C
                                    
                                 
                              
                              }
                              )
                            for emitting both O1 and O2 and 
                              B
                              (
                              {
                              A
                              ,
                              ¬
                              
                                 
                                    
                                       REQ
                                    
                                    
                                       C
                                    
                                 
                              
                              }
                              )
                            for emitting only O2. Therefore, under assumption of the strong determinism, each CD in Fig. 15 is deterministic.

The previous section described semantics of the SC-SystemJ language. In this section, we will use the inductive rules to generate a Mealy automaton, which adheres to the transition system specified in Eq. (4). This automaton is used to generate both Promela as well as C/Java code for verification via the SPIN model-checker and execution on a target platform, respectively.

The generation of the Mealy automaton for individual CD is carried out in two steps. In the first step, a Labeled Generalized Büchi automaton (LGBA) is created using the tableau approach (Gerth et al. [15]) from the LTL formula describing the SC-SystemJ CD (Fig. 1). LGBA is created as an input source to build a deterministic Mealy automaton, which is a state transition system for the SC-SystemJ CD. The tableau algorithm to generate the LGBA is not given here since it is not the contribution of this paper and readers are referred to [15] for the complete algorithm. In the second step, a novel algorithm is used to transform the LGBA into a Mealy automaton representing a state transition system for a single CD. The background required to understand the LGBA created from the LTL formula is given next:
                           Definition 8
                           
                              Generalized Büchi Automaton (GBA) is a quadruple 
                                 (
                                 Q
                                 ,
                                 I
                                 ,
                                 →
                                 ,
                                 F
                                 )
                              , where Q is the finite set of states, 
                                 I
                                 ⊆
                                 Q
                               are the initial states, 
                                 →
                                 ⊂
                                 Q
                                 ×
                                 Q
                               is the transition relation and 
                                 F
                                 ⊆
                                 
                                    
                                       2
                                    
                                    
                                       
                                          
                                             2
                                          
                                          
                                             Q
                                          
                                       
                                    
                                 
                               is a set of sets of accepting states, where 
                                 F
                               may be empty.

GBA accepts an infinite input sequence 
                           σ
                           =
                           
                              
                                 q
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 q
                              
                              
                                 1
                              
                           
                           …
                         such that, 
                           
                              
                                 q
                              
                              
                                 0
                              
                           
                           ∈
                           I
                         and, for each 
                           i
                           ≥
                           0
                           ,
                           
                              
                                 q
                              
                              
                                 i
                              
                           
                           →
                           
                              
                                 q
                              
                              
                                 i
                                 +
                                 1
                              
                           
                        . An accepting execution σ is an execution such that, for each acceptance set 
                           
                              
                                 F
                              
                              
                                 i
                              
                           
                           ∈
                           F
                        , there exists at least one state 
                           q
                           ∈
                           
                              
                                 F
                              
                              
                                 i
                              
                           
                         that appears infinitely often. Fig. 16
                         shows an example of GBA with examples of three runs 
                        
                           
                              
                                 σ
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 σ
                              
                              
                                 2
                              
                           
                         and σ
                        3. Note that double circled state S
                        1 denotes an accepting state. Here, σ
                        1 and σ
                        2 are the accepted execution traces since they both visit S
                        1 infinitely often. On the other hand σ
                        3 is rejected, because S
                        1 appears only once in the execution trace.
                           Definition 9
                           
                              A Labeled Generalized Büchi Automaton (LGBA) is a triple 
                                 (
                                 A
                                 ,
                                 D
                                 ,
                                 L
                                 )
                              , where 
                                 A
                               is the GBA, 
                                 D
                               is the domain of propositions and 
                                 L
                               is the labelling fuction: 
                                 L
                                 :
                                 Q
                                 →
                                 
                                    
                                       2
                                    
                                    
                                       D
                                    
                                 
                              .

LGBA is another variant of Büchi automaton whose input is associated with labels instead of states. Formally, a LGBA accepts a word 
                           ζ
                           =
                           
                              
                                 x
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 x
                              
                              
                                 1
                              
                           
                           …
                         from D
                        
                           ω
                         iff there exists an accepting execution 
                           σ
                           =
                           
                              
                                 q
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 q
                              
                              
                                 1
                              
                           
                           ,
                           …
                         of 
                           A
                        , such that for each 
                           i
                           ≥
                           0
                           ,
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ∈
                           L
                           (
                           
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                           
                           )
                        .

From [15], it is known that the generated LGBA using the tableau method only accepts the language (i.e. ζ) that satisfies the LTL formula. In order to demonstrate the conversion from LTL formula representing the SC-SystemJ CD to a LGBA, the transition system for a simple SC-SystemJ single CD program in Fig. 17(a) is shown in Fig. 17(b) where the program locations are specified using labels L1, L3 and L4. Such symbolic transition system is built from the SC-SystemJ CD using the transition relation given in Eq. (4), where each clause represents instantaneous, enter, terminate and move transition of the SC-SystemJ CD, respectively.

The first (Inst) clause of this formula indicates that no instantaneous transition can be taken from the starting state st, since the program consists of pause statements. Therefore, the first clause in Fig. 17(b) is 
                           ⊥
                        . The second (Enter) clause states that from the starting state st the next transition will be to states 
                           L
                           1
                           ∧
                           L
                           3
                         with emission of signal B if signal A is present. Otherwise, the program will only make a transition to the state L3. The third (Term) clause states that the program terminates if it makes a transition away from all of the states: L1, L3 and L4. Finally, the program will make a move from either one of 
                           L
                           3
                           ∧
                           L
                           1
                         or L3 to L4 before terminating (clause 4). This behavior is clearly evident from the program in Fig. 17(a).

A derivation tree for Inst clause for the program in Fig. 17
                        (a) is shown in Fig. 18
                        , which is read in a bottom-up fashion. Given the program p in Fig. 17(a), control-flow first encounters the synchronous parallel operator 
                           ∥
                         with reactions 
                           s
                           1
                         and 
                           s
                           2
                        , which is rewritten to a logical conjunction as given by the inductive rule for Inst (Fig. 6(a)). Assume that the inductive rule is first applied to the reaction 
                           s
                           1
                         (the order of application is inconsequential) in which case two signal declaration statements for A and B are performed sequentially before the present statement. Declaring signals is instantaneous, i.e. it does not consume a tick, hence these statements both result in 
                           ⊤
                        . 
                           Inst
                           (
                           present
                           )
                         in the reaction 
                           s
                           1
                         results in 
                           A
                           ∧
                           XB
                           ∧
                           ⊥
                           ∨
                           ¬
                           A
                        , see the inductive rule in Fig. 6(a). The result of the derivation for 
                           s
                           1
                         is then 
                           A
                           ∧
                           XB
                           ∧
                           ⊥
                           ∨
                           ¬
                           A
                        . Next, since 
                           Inst
                           (
                           pause
                           )
                         is 
                           ⊥
                        , one can easily see that 
                           Inst
                           (
                           s
                           2
                           )
                         is also 
                           ⊥
                        . Finally, 
                           ⊥
                         is connected to the rest of the formula with a conjunction therefore, the overall result of the derivation for 
                           Inst
                           (
                           s
                           1
                           ∥
                           s
                           2
                           )
                         is also 
                           ⊥
                        .

A derivation tree for the second clause, i.e. Enter, of Fig. 17(b) is shown in Fig. 19
                        . Here, Enter of two parallel reactions, 
                           s
                           1
                         and 
                           s
                           2
                        , is further decomposed into three clauses connected with logical disjunction (Fig. 6(b)). However, since it is already known that Inst of the reaction 
                           s
                           2
                         is 
                           ⊥
                        , the only interesting clauses are the first and the last one, which are 
                           Enter
                           (
                           s
                           2
                           )
                           ∧
                           Inst
                           (
                           s
                           1
                           )
                           ∧
                           ¬
                           Xin
                           (
                           s
                           1
                           )
                         and 
                           Enter
                           (
                           s
                           1
                           )
                           ∧
                           Enter
                           (
                           s
                           2
                           )
                        , respectively. Induction rule for 
                           Enter
                           (
                           s
                           1
                           )
                         gives ⊤ until it reaches the present statement. According to Fig. 6(b), 
                           Enter
                           (
                           present
                           (
                           A
                           )
                           {
                           emit
                           
                           B
                           ;
                           
                           L
                           1
                           ;
                           pause
                           }
                           )
                         gives 
                           A
                           ∧
                           XL
                           1
                           ∧
                           XB
                        . Similarly, it can be easily seen that 
                           Enter
                           (
                           s
                           2
                           )
                         is 
                           ¬
                           XL
                           4
                           ∧
                           XL
                           3
                        . It is already known, from the previous derivation for Inst (Fig. 18), that 
                           Inst
                           (
                           s
                           1
                           )
                         is 
                           ¬
                           A
                        . Finally, 
                           in
                           (
                           p
                           )
                         collects all labels inside the program body 
                           p
                        , see Eq. (2), thus, 
                           ¬
                           Xin
                           (
                           s
                           1
                           )
                         is rewritten to 
                           ¬
                           XL
                           1
                        .

Deriving the Term transition is quite trivial, which is shown in Fig. 20
                        . in(p) simply collects all labels inside the program body p. The resultant formula is a logical conjunction of these labels.

Derivation of the Move transition is given in Fig. 21
                        . Since 
                           Move
                           (
                           s
                           1
                           )
                         results in 
                           ⊥
                        , 
                           Move
                           (
                           s
                           1
                           ∥
                           s
                           2
                           )
                         is simplified to two clauses, which are shown as (1) in Fig. 21. Inductive definition for 
                           Move
                           (
                           s
                           2
                           )
                         further requires rewriting 
                           Move
                           (
                           L
                           1
                           :
                           
                           pause
                           ;
                           L
                           2
                           :
                           
                           pause
                           )
                         whose result is shown as (2). Finally 
                           Term
                           (
                           s
                           1
                           )
                        , results in L1, and after applying Eq. (2) to the remaining control predicates (i.e. in) the final formula (3) is shown in Fig. 21.


                        Fig. 22
                         shows the LGBA generated by the tableau approach of [15], which accepts only the words that satisfy the transition relation in Fig. 17(b). The propositional formula satisfied in each state is shown in the table in Fig. 22. These states are labelled from the set 
                           
                              
                                 2
                              
                              
                                 D
                              
                           
                         on the binary domain of propositions (including inputs and guarded actions). Note that the labelling function 
                           L
                         is more in the spirit of satisfiability solving rather than the one given by [15], wherein the states are labelled with all subsets of 
                           
                              
                                 2
                              
                              
                                 D
                              
                           
                         excluding the negative propositions satisfied by that state.

Consider the LTL formula in Fig. 17(b) and its non-deterministic LGBA in Fig. 22. The false (
                           ⊥
                        ) formula representing 
                           Inst
                           (
                           p
                           )
                         transition is never accepted in the generated automaton. The 
                           Enter
                           (
                           p
                           )
                         (second clause in Fig. 17(b)) is satisfied by the transitions from N6 to N9. Similarly, the third (Term) and fourth (Move) clauses are satisfied by the transitions from N5 to N9 and the rest, respectively. Note that at this stage, all actions (e.g. signal emissions and data computations) appear as propositional variables in the LGBA states. For example, the proposition P1 in the state N7 implies that “the signal B is being updated to ⊤”. It is also interesting to note that the acceptance state (N9) has an empty set as its label and hence, all the accepted words are finite prefixes. Moreover, it is possible that unreachable states can be generated in the LTL formula and the corresponding LGBA depending on how the program is written. Note that all nodes that have an incoming guard from a fictional (or dummy) state called Init are initial states. For example, N16, N15, … N6 in Fig. 22 are initial states. As it will be explained below, they are used internally by the compiler when generating a deterministic Mealy machine.

The LGBA is further processed by the compiler such that for each state in the LGBA, all the propositions other than the state labels are pushed onto the outgoing edges. For example, outgoing edges of N7 and N6 are annotated with the propositions P1, A and 
                           ¬
                           A
                        , respectively. These propositions are then removed from the propositional formulas in the original states. If the propositional formula in a state consists of only state labels, all its outgoing edges are annotated with ⊤ (e.g. outgoing edges of N17, N16, etc.). The result of this process is a graph, which is shown in Fig. 23(a). 
                           Algorithm 3
                           Psuedo-code for generating deterministic Mealy automaton from the LGBA. 
                                 
                              
                           

Reachability analysis. 
                                 
                              
                           

Optimising the paths and extract actions from guards.
                                 
                              
                           

In the next step, the generated graph is taken as an input, and then reduced to a deterministic Mealy automaton, representing the transition system of the SC-SystemJ program. The pseudo-code for generating the Mealy automaton is shown in Algorithm 3. It has five main parts: 
                           
                              Merging equivalent nodes:
                           
                           
                              In this part of the algorithm, lines 1–16, the nodes with the same label, i.e. nodes that satisfy the same proposition, are merged into a single node. The result of such a translation from Fig. 23(a) is shown in Fig. 23(b). Nodes N16 and N15 are updated, with the edges of the nodes N11 and N8, respectively, since each of them satisfies the same propositional formula. Nodes N7 and N6 are also merged together since they both satisfy proposition st (c.f. Fig. 23
                                 ). Note that any outgoing edges to the accepting node N9 are removed after merging the nodes because their proposition is empty (∅). For example, an outgoing edge from N11 to N9 is removed after merging with N16.

This procedure is shown in Algorithm 3; lines 16–27. For each node in the graph, all the edges from the node Init are removed. In addition, all those initial nodes that are disconnected from Init are added to the set init_nodes for use in the next step. Fig. 23(c) shows the resultant graph after removing Init in this step.

In the third step, which is shown at lines 28–32 in Algorithm 3, the algorithm searches for all the initial nodes (bar the single node with label st), that could not be merged in step-1 and tries to find nodes in the intermediate graph that satisfy these sub-formulas. If such nodes are found, the initial nodes are merged into these newly discovered nodes and their guards are updated, else the remaining nodes (and their paths to the accepting node) are discarded.

A simple reachability analysis is performed in this step (line 33 in Algorithm 3), which removes all the non-reachable nodes from st. This process is further elaborated in Algorithm 4. The algorithm iterates through all the node in the graph and checks whether each node can be reachable from st by recursively calling a function reachable_st as shown in lines 5 and 9–20. If the current node has no direct parent(s), i.e. 
                                    node
                                    .
                                    incoming
                                    =
                                    ∅
                                 , this function returns (1) ⊤ if the current node is a starting node st (line 11–12), or (2) 
                                    ⊥
                                  if the current node is not st (line 13–14). Otherwise, the function recursively traverses the graph backwards, starting from the current node's immediate parent(s) (line 16–19), until it returns ⊤ or 
                                    ⊥
                                 . Algorithm 4 then checks the final value returned from reachable_st at line 5. The result of this analysis is a set of nodes N, which are reachable from st (line 7). For example, the path from N5 in Fig. 23(c) is removed after this step.

Next, all state transitions from any given node, guarded by the status(es) of the internal signals, are checked whether they can ever be taken (line 34 in Algorithm 3). If guards are evaluated to false with respect to the emitted signals from the immediate predecessor state transitions, its paths to the accepting nodes are discarded. Detailed algorithm of this process is shown in Algorithm 5. Here, an input to the function is a set of nodes in the LGBA. First part of this algorithm extracts propositions in node.guards that implies guarded actions on each incoming edge. A set of these propositions are then added to the set actions, which is a field of the newly created data-structure called fsm_node (lines 4–6). All the actions in node.guards are then replaced with boolean true, i.e. 
                                    ⊤
                                 . fsm_node is created for every node in the graph and added to a set fsm (line 8).

Next part of the algorithm collects all the signals emitted from the guarded actions fsm_node.actions to a set S (line 11). All the signals checked on the outgoing guards are also collected to a set sig_guards as shown at line 14. Then if any one of the signals in sig_guards cannot be emitted from the previous transitions, i.e. 
                                    sig
                                    _
                                    guards
                                    ⊈
                                    S
                                 , the subsequent node is removed from the set fsm (line 16). Lastly, the accepting node (e.g. N9 in Fig. 23(c)) is removed from the graph (line 14). The result of this translation is shown in Fig. 24
                                 (a) obtained from the compiler for the LGBA in Fig. 22.

The generated Mealy automaton is an intermediate representation of the SC-SystemJ clock-domain, which can be compiled to: (1) a Promela process for verification by the SPIN model-checker or (2) C/Java code for execution. The verification step is not mandatory in the compilation process and it can be bypassed. As an example, the generated C code is shown in Fig. 24(b) for the Mealy automaton in Fig. 24(a). Edges in the automaton are annotated with 
                           
                              
                                 Guard
                              
                              
                                 Actions
                              
                           
                        . The transition is taken whenever the Guard is satisfied, and the corresponding Actions are performed. The generated C code is embedded inside another program, at a minimum inside a machine interface that communicates with the environment.

Converting the generated Mealy automaton to C code is trivial. In Fig. 24(b), all the signal statuses are declared using the basic data types (lines 5 and 6) where bool is just a type synonym for int. The whole clock-domain logic is encapsulated in a function called CD0 (lines 8–33). Calling this function results in a state transition of this clock-domain from one state to another. Current state of the clock-domain is represented as a label, whose address is stored as a value in the variable CD0_L (line 7). For example, suppose that the current state of the clock-domain is N7 (line 23), then the program will jump to this label upon calling CD0() from the main function (line 36). Next, guards of the outgoing edges of the state N7 are tested using if statements (lines 24 and 28). If the status of signal A is true, corresponding action is performed that emits the output signal B (line 29). Otherwise, the program makes transition with an empty action ∅. Finally, the function returns after storing the label of the next state into CD0_L (lines 26 and 31).

Java code can also be generated from the final Mealy automaton in a very similar manner as C except that the current state of the clock-domain, e.g. N7, N16, etc., are stored in a primitive variable rather than a label. Then state transition is performed using a switch statement on this variable.

One important aspect of generating a network of Mealy automata for the SC-SystemJ GALS program is that all clock-domains are compiled individually. Therefore, generating a Mealy automaton of one clock-domain is independent from others. These resultant set of Mealy automaton are then put together as a network of Mealy automata communicating via channels. An example program with two clock-domains, communicating via channel named C, is shown in Fig. 25
                        (a) and the corresponding compiled C code in Fig. 25(b).

The generated C code is a result of channel rewrite rules shown in Algorithm 1 for send and Algorithm 2 for receive statement, respectively. Since channel rendezvous is implemented using pure signals, ACK and REQ are also treated as signals and declared as C_ack and C_req, respectively (lines 7 and 8). When the program first enters send C in the first clock-domain (CD0), it blocks until the presence of the signal ACK (lines 1–3 in Algorithm 1). This is shown in the compiled C code in lines 25–28 in Fig. 25(b). In this case, CD0 takes a self-loop transition, which results in re-entering the same state as shown in line 27. Once ACK becomes true, CD0 makes a transition to N12 (lines 29–33). N12 denotes the second abort statement in Algorithm 1 (lines 4–7). While CD0 is waiting for the absence of ACK, it emits the signal REQ (line 16 in Fig. 25(b)). Finally, CD0 terminates when REQ becomes false (line 22), and then settles in the state N21 (lines 12 and 13). The behavior of the second clock-domain (CD1) follows Algorithm 2, and its execution trace is almost identical to CD0.

SPIN [13] is a model-checker capable of checking propositional linear temporal logic (LTL) properties of distributed systems. These distributed systems are modelled in a language called Promela [13]. Promela processes are sequential processes that communicate via channels like those in CCS [9] or via shared variables. Channel communication halts the process when sending to a full channel or receiving from an empty channel, whereas shared variable communication never halts. For the compilation of SC-SystemJ channels, shared variables are used due to their logical tick-level blocking semantics as described in Section 6.2. In Promela, statements in different processes can be arbitrarily interleaved. But, this arbitrary interleaving can be controlled using atomic execution of statements. All statements encapsulated inside an atomic block are executed together. The SC-SystemJ compiler uses this atomic construct to emulate the SC-SystemJ big-step semantics and to reduce the state space explosion problem when model-checking a network of clock-domains.

Usually, the model-checker needs to explore all possible program execution paths when verifying properties of a program. When verifying safety properties of the SC-SystemJ program, input signals can be left open and not closed by the plant model (Section 1). As a result, states in the generated automaton can have multiple outgoing edges with guards, checking for different combinations of input signal statuses, e.g. whether an input signal A is present or not. Normally, the model-checker will explore all possible paths in the program using a backtracking algorithm. In Promela, backtracking is performed on if … fi statements in the case when more than one if condition is evaluated to true. Therefore, all input signals in SC-SystemJ programs need to be converted into simple truths, true, in the if conditions (guards) so that SPIN would traverse all paths in the generated state space using its backtracking algorithm. Any paths whose guards consist of non-emitted internal signals (and hence 
                           ⊥
                        ) are automatically removed at compile time as explained in Section 7.1.

Referring back to the example in Fig. 17(a), the translation to Promela code from the corresponding Mealy automaton is very straightforward. Fig. 26
                        (b) shows the compiler generated Promela code for the Mealy automaton in Fig. 26(a) replicated from Fig. 17(a). Every transition in the Mealy automaton is translated into an atomic block in Promela (lines 6–10, 12–17, 19–24 and 26–33) with jumps (goto) to the next state as the final statement. Semantics of Promela dictates that the control can only switch from one clock-domain to another upon the completion of the atomic block. Similar to its C counterpart, every state transition from one state to another in the Mealy automaton is equivalent to one of the branches of the Promela if … fi statement. Hence, each if expression is the guard of the corresponding transition in the Mealy automaton. If one of the if condition is evaluated to true, corresponding action is performed such as emitting signals or executing data actions. When more than one condition is true, backtracking is performed as explained previously.

In case of a network of clock-domains, the channels are implemented as shared variables instead of using the built-in Promela message passing mechanism. It is mainly because Promela's sending and receiving operations over the single queue channel completely halt the Promela process from running until the synchronization completes which is in contrast to the transition semantics in Eq. (5). Furthermore, this hinders implementing GALS system as demonstrated in the following example:


                        
                           
                        
                     

Here, CD-B tries to synchronize with CD-S through the channel named P. At the same time, CD-B also checks for the presence of the input signal A from the environment and emits O if A becomes available. Suppose this rendezvous is implemented using Promela's built-in halting channel. When CD-B enters receive P, the entire clock-domain will halt until it completes rendezvous with CD-S. As a result, CD-B may miss any incoming input signal A from the environment, which makes this program non-reactive thereby violating SC-SystemJ semantics.


                        Fig. 27
                         shows the generated Promela code for the GALS program shown in Fig. 25(a). As one can see, the generated code is similar to the C version in Fig. 25(b). For example, ACK and REQ signals, used for implementing rendezvous, are declared as boolean variables. Furthermore, each state is represented as labels and the Promela process, i.e. clock-domain, can perform state transition by jumping to one of these labels using the goto statement. In Promela, however, processes run concurrently and interleaving of clock-domains is automatically done by the SPIN scheduler at boundaries of atomic blocks. Therefore, there is no need to store the labels, unlike C code where it is used for continuing execution of previously executing clock-domain.

In this section, the proof of equivalence of the Promela model and the SC-SystemJ program is given using observational equivalence [9]. First, the following formal definitions of the SC-SystemJ transition system are given:
                           Definition 10
                           
                              Run: Let M be a transition system. Then a run of M is defined to be an infinite sequence of states 
                                 π
                                 =
                                 
                                    
                                       q
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 
                                    
                                       q
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 …
                              .


                              Language: Let M be a transition system. Then the language of M, denoted L(M), is meant to be the set of all possible runs of M.

Let observers O
                        
                           p
                         and O
                        
                           s
                         observe the transition of the Promela process and the SC-SystemJ clock-domain, respectively. Let S
                        
                           s
                         denote the set of both input and output signals for the interface of the SC-SystemJ clock-domain as well as the internally declared signals. A clock-domain observer is defined as a transition system O
                        
                           s
                         over S
                        
                           s
                         that can observe any possible run over S
                        
                           s
                        . The observer O
                        
                           s
                         is synchronously composed with the transition system of the SC-SystemJ clock-domain and observes after each synchronous reaction, sampling all the signals in S
                        
                           s
                        . Similarly, S
                        
                           p
                         is defined as the set of variables in the Promela process that corresponds to S
                        
                           s
                         in the SC-SystemJ clock-domain.

An observer O
                        
                           p
                         on the Promela process is defined as a transition system over S
                        
                           p
                         that can observe any possible run over S
                        
                           p
                        . The observer O
                        
                           p
                         is composed synchronously with the Promela process, observing only after the completion of the Promela process transition, defined at boundaries of the atomic blocks. Indeed, the observer cannot observe inside the atomic section. Now the following can be stated under the assumption that the SC-SystemJ program is correct, i.e., each clock-domain is reactive and deterministic. 
                           Definition 12
                           
                              Trace equivalence: Let M and N be two transition systems with the same alphabet. M and N are trace equivalent, denoted 
                                 M
                                 ≈
                                 N
                              , if they have the same language 
                                 L
                                 (
                                 M
                                 )
                                 =
                                 L
                                 (
                                 N
                                 )
                              .


                              Let 
                              
                                 M
                                 =
                                 (
                                 
                                    
                                       Q
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       st
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       I
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       O
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       Y
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          T
                                       
                                       
                                          1
                                       
                                    
                                 
                                 )
                               
                              and 
                              
                                 N
                                 =
                                 (
                                 
                                    
                                       Q
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       st
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       I
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       O
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       Y
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       A
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       
                                          T
                                       
                                       
                                          2
                                       
                                    
                                 
                                 )
                              , be a clock-domain and its Promela translation, respectively. Let O
                              1 
                              and O
                              2 
                              be the observers for 
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          s
                                       
                                    
                                 
                                 ⊆
                                 
                                    
                                       
                                          I
                                       
                                       
                                          1
                                       
                                    
                                 
                                 ∪
                                 
                                    
                                       
                                          O
                                       
                                       
                                          1
                                       
                                    
                                 
                                 ∪
                                 
                                    
                                       Y
                                    
                                    
                                       1
                                    
                                 
                               
                              and 
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          p
                                       
                                    
                                 
                                 ⊆
                                 
                                    
                                       
                                          I
                                       
                                       
                                          2
                                       
                                    
                                 
                                 ∪
                                 
                                    
                                       
                                          O
                                       
                                       
                                          2
                                       
                                    
                                 
                                 ∪
                                 
                                    
                                       Y
                                    
                                    
                                       2
                                    
                                 
                               
                              on M and N, respectively and L
                              1 
                              and L
                              2 
                              be the languages they observe. Then the following holds: 
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                               
                              and by 
                              
                                 Section 12, 
                                 M
                                 ≈
                                 N
                               
                              with respect to O
                              
                                 s
                               
                              and O
                              
                                 p
                              .

Since the model of the SC-SystemJ clock-domain is contained within the Promela process and invoked from inside the Promela process the proof is by construction. The two observers O
                              
                                 s
                               and O
                              
                                 p
                               observe observables (words) with the same alphabet, i.e., 
                                 s
                                 ∈
                                 L
                                 (
                                 M
                                 )
                                 ⟺
                                 s
                                 ∈
                                 L
                                 (
                                 N
                                 )
                              . First, we need to prove that 
                                 s
                                 ∈
                                 L
                                 (
                                 M
                                 )
                                 ⟹
                                 s
                                 ∈
                                 L
                                 (
                                 N
                                 )
                              . O
                              
                                 s
                               can only observe signals in S
                              
                                 s
                               generated by M at the end of the tick, which is an atomic transition (due to big-step semantics). These global variables are updated inside the atomic block and are observable only at goto where they remain unchanged in Promela hence, S
                              
                                 p
                              =S
                              
                                 s
                               at the end of tick. Next, we prove 
                                 s
                                 ∈
                                 L
                                 (
                                 N
                                 )
                                 ⟹
                                 s
                                 ∈
                                 L
                                 (
                                 M
                                 )
                              . O
                              
                                 p
                               observes only global variables (in S
                              
                                 p
                              ) produced by N, moreover, O
                              
                                 p
                               cannot observe any internal transition of the atomic block. Furthermore, non-execution of N does not change the set S
                              
                                 p
                               and hence, infinite runs of a Promela program without execution of N in between two runs of N is equivalent to two consecutive runs of the N and hence, 
                                 s
                                 ∈
                                 L
                                 (
                                 M
                                 )
                                 ⟺
                                 s
                                 ∈
                                 L
                                 (
                                 N
                                 )
                              .□


                              Let 
                              
                                 M
                                 =
                                 {
                                 
                                    
                                       M
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 }
                               
                              and 
                              
                                 N
                                 =
                                 {
                                 
                                    
                                       N
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       N
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 …
                                 }
                               
                              be a transition system for a network of clock-domains and its Promela translation, respectively. Let sets 
                              
                                 OS
                                 =
                                 {
                                 
                                    
                                       O
                                    
                                    
                                       s
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       O
                                    
                                    
                                       s
                                       12
                                    
                                 
                                 ,
                                 …
                                 }
                               
                              and 
                              
                                 OP
                                 =
                                 {
                                 
                                    
                                       O
                                    
                                    
                                       p
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       O
                                    
                                    
                                       p
                                       21
                                    
                                 
                                 ,
                                 …
                                 }
                              , be the observers for M and N, respectively and sets 
                              
                                 L
                                 1
                                 =
                                 {
                                 
                                    
                                       L
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       12
                                    
                                 
                                 ,
                                 …
                                 }
                               
                              and 
                              
                                 L
                                 2
                                 =
                                 {
                                 
                                    
                                       L
                                    
                                    
                                       2
                                    
                                 
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       21
                                    
                                 
                                 ,
                                 …
                                 }
                              , be the languages they observer. Then the following holds: 
                                 
                                    
                                       
                                          ⋀
                                       
                                       
                                          k
                                          ∈
                                          |
                                          L
                                          1
                                          |
                                       
                                    
                                 
                                 L
                                 
                                    
                                       1
                                    
                                    
                                       k
                                    
                                 
                                 =
                                 L
                                 
                                    
                                       2
                                    
                                    
                                       k
                                    
                                 
                               
                              and by 
                              
                                 Section 12, 
                                 M
                                 ≈
                                 N
                               
                              with respect to OS and OP.

Proof follows from Section 7.1.□

It is worth mentioning that the above proofs hold in the absence of fairness guarantees. But, since the interface signals in a set S
                        
                           p
                         does not change for a non-executing run of N one cannot guarantee rendezvous without fairness and hence, weak fairness 
                        [35], i.e., every process that is almost always enabled should be executed infinitely often is an essential (but not complete) condition for a successful rendezvous completion.

In this section we describe how our compilation strategy addresses classical issues that can occur in compilation of synchronous programs, which are written in reactive languages such as Esterel [2] and SystemJ [8]. Herein, we use examples from the standard literature on synchronous languages to describe the issues and their solutions. 
                           
                              Instantaneous loops:
                           
                           
                              These occur in the synchronous subset of SC-SystemJ programs. These are loops without any pause statement inside their body. As a result, once a clock-domain enters this loop, it cannot ever consume a tick or make a transition to another state. For example, while(true) emit S; is an instantaneous loop. If the induction rule for 
                                    Inst
                                    (
                                    while
                                    (
                                    true
                                    )
                                    
                                    s
                                    )
                                  results in ⊤, it means that the body of the loop s can be terminated instantaneously without consuming any tick. Therefore, the compiler can statically detect instantaneous loops, by making sure that Inst transition of any loop is always 
                                    ⊥
                                 .

Causal problems do not occur in SC-SystemJ programs with delayed signal communication semantics. This is ensured by the inductive rules in Figs. 6 and 7 where the emission of the signal, i.e. 
                                    Inst
                                    (
                                    emit
                                    
                                    γ
                                    )
                                 , only satisfies the proposition in the next instant 
                                    X
                                    γ
                                 . Furthermore, the inductive rules for all other signal checking statements, e.g. present and abort, are reduced to a logic, which has only current time (i.e. non-X) propositions of the corresponding signal σ. Consequently, the generated SC-SystemJ transition system can only react on the signal emissions from the previous instant.

In SC-SystemJ one can write static and dynamic deadlocks – independent of input signals or dependent on input signals, respectively. Example of dynamic asynchronous deadlock is given in Fig. 13. Example of static synchronous deadlock is: 
                                    
                                 
                              

In the above example, the clock-domain can make no progress, although the program itself is correct. In this paper, a singular approach has been taken to solve these problems – using the SPIN model-checker with safety properties, i.e. verifying that something bad will never happen, specified as an LTL formula, to guarantee freedom from static and dynamic deadlocks. This approach is appropriate rather than performing such checks inside the compiler because complete state space analysis is still needed for detecting deadlocks, which is model-checking.

It is well known that the worst case complexity of the generation of LGBA and the resultant size is exponential, due to the combinatorial explosion caused due to synchronous parallel composition of states. Moreover, the method of semantic tableaux used to generate the LGBA tests for satisfiability of any arbitrary formula, by converting it into a disjunctive normal form, can grow exponentially large. However, in this work, no resource constraint problems, especially running out of memory, are encountered during compilation, because:
                           
                              (1)
                              
                                 DNF transition rules: The transition system (Eq. (4)) for each clock-domain and the corresponding inductive rules are already in a disjunctive normal form, which directly supports the disjunctive partitioning of the transition relations.


                                 Single non-nested next-time operator: Since, the resultant LTL formula representing the transition system only ever contains non-nested next-time operator X, the resultant LGBA can only ever have a depth of 2 [15], which again significantly reduces the state space.


                                 Storing only complete formulas in conjunction with tail-recursion: A general tableaux method stores all rules solving satisfiability. The tableaux method described in [15] only stores the completely expanded (satisfied formulas), the internal states generated when satisfying the formula can be discarded using tail-recursive procedures, which reduce the exponential growth in stack space.

Large GALS programs can be compiled into Mealy automata without running out of memory by employing the aforementioned techniques. Nevertheless, the worst case runtime complexity and the resulting compilation time grows exponentially with the length of the LTL formula ψ considered as a string. Fortunately, the transition system lends itself well to parallel processing. Each clause of the DNF representation of the transition system can be converted into the LGBA in parallel as identified by [36]. Lastly, LGBA generation for separate clock-domains itself can also be carried out in parallel.

@&#EXPERIMENTAL RESULTS@&#

In this section, a set of SC-SystemJ benchmark programs is used in order to show the experimental results of verifying LTL property specifications on various types of GALS programs. The first experiment measures the compilation time, size of SC-SystemJ source code and results of functional verification via SPIN. Next, the executable code generated from the automata and AGRC-based SystemJ [8] compilers are compared in terms of size and average execution time between the start and the end of the clock-domain ticks, i.e. average reaction time of clock-domains. The examples include washing machine controller [37], conveyor controller [37], robot motion controller [37] and a dual-chamber pacemaker [38]. All these examples are converted into SC-SystemJ from their original description in CRSM [37] or UPPAAL [38]. Promela code generated from the SC-SystemJ compiler is then verified against liveness properties or safety properties. The LTL properties specified are shown in Table 2
                     . The first three properties in the table are liveness properties, while the others are safety properties. A procedure for verifying liveness properties is as follows; (1) plant model is synchronously composed (
                        |
                        |
                     ) with the control logic, generating input stimuli for the system, and (2) the translated automaton is verified in SPIN. On the other hand, inputs signals are left completely open for verifying the safety properties.

Washing machine controller [37] example is a pure synchronous program that consists of two main reactions: the washer and the drier. Each reaction awaits for an input signal from a user, which activates its washing or drying operation. The property verified on the system is that both reactions never activate at the same time, i.e. signals WASHING and DRYING, which indicate start of washing and drying operation respectively, are not emitted in the same instant. Robot motion controller [37] consists of a camera and motion controllers, which continuously locate an object, move to the location, and pick up that object. The system consists of two clock-domains, one for each controller. The property verified on the system is that the object should be picked before receiving the next object's location. Conveyor controller is the example program described in Section 4, which is inspired from its CRSM version in [37]. It consists of two mechatronic components, a conveyor and a mechanical arm each modelled as a SC-SystemJ clock-domain, connected together into a mechanism for sorting items. Once an object is placed, the first clock-domain sends this information to the second clock-domain, which moves the conveyor belt until the object is displaced off the conveyor by the mechanical arm. In this case, it is checked whether the system correctly counts the number of items on the conveyor when the sender and receiver exchange messages.
                           1
                           This image was obtained from: http://www.texasheart.org/HIC/Topics/Proced/icdtopic.cfm.
                        
                     

A dual-chamber implantable pacemaker is a case-study in safety critical system design using SC-SystemJ adopted directly from the one modelled by [38] in UPPAAL. A pacemaker is a small device that monitors patient's heart rate and artificially generates electrical pulses in case when it does not detect a heartbeat within a set time period. As shown in Fig. 28
                        (a) the heart has two major types of tissues, which governs its electrical conduction system and controls the cardiac cycle. The Sinoatrial (SA) node, which is located in the upper wall of the right atrium, periodically generates electrical pulses, which causes both the atria to contract, allowing the blood to enter the ventricles. The Atrioventricular (AV) node delays the electrical pulses from SA node that allows the blood to be fully filled in the ventricles before both chambers contract to pump blood out of the heart. Two main components of the pacemaker are shown in Fig. 28(b).

The pacemaker developed in SC-SystemJ is able to sense two types of activities called Atrial Sense (AS) and Ventricular Sense (VS) from the SA and AV nodes, respectively. They indicate activation of these two heart tissues that controls rate of blood pumping out of the heart. A heart disease or degraded functionality of the heart due to aging can cause abnormal heart rhythms, which may result in either inefficient or too much blood supply to the body. When the heart operates normally, a pacemaker receives AS and VS one after another within a predetermined period. Whenever the pacemaker detects absence of VS or AS within those time, it generates artificial pulses called Ventricular Pacing (VP) or Atrial Pacing (AP). Lower Rate Interval (LRI) component is responsible for generating AP after sensing ventricular event (VS or VP) if AS is not generated by the heart after certain time. Conversely, Atrio Ventricular Interval (AVI) component generates VP after atrial even (AS or AP) if VS is not generated by the heart after a certain time period. In order to check the correctness of design, the system is verified against LTL properties in order to guarantee generation of the event VP and AP in case when AS or AP and VS or VP are not detected within a deadline, respectively.

Collected data from the verification of the SC-SystemJ models for the pacemaker and other examples are shown in Tables 2 and 3
                        . All benchmark programs were run on the desktop machine with the following specification: Intel Core i5 CPU 660 at 3.33Ghz, 4GB memory and Windows 7 64-bit operating system. Pacemaker consists of two clock-domains (LRI and AVI) each containing three main reactions. This example contains a large number of nested conditional and pause statements that resulted in increased number of states as well as possible state transitions in the system. It took 118.76s to compile this example. Verification report generated from SPIN showed that the example consists of a total number of 62 states and required to perform 248 transitions to verify the first LTL property for the pacemaker as shown in Table 2, whereas only 160 transitions were needed to be traversed to verify the second LTL property. These significant reductions in the number of states and transitions can be attributed to the atomic construct, without which the same behavior requires 16,369 states, 106,115 transitions and 14,253 states, 56,025 transitions for verifying each LTL property, respectively. Robot motion controller and the mechanical conveyor/arm examples are also two clock-domains systems, but they are much simpler in terms of complexity of control flow and hence result in both fewer number of states and transitions to verify the LTL properties by SPIN. Each of these SC-SystemJ program is 32 and 39 lines long and take 0.182 and 0.172s to compile, respectively. This reduction in compilation time is due to the fact that there are fewer number of parallel reactions in each of these examples resulting in lesser compilation effort in creating parallel composition of states (Section 7.5). It is interesting to see that there are more states and transitions needed in verifying Conveyor (72 and 210) than Robot (27 and 55). This is because the environment is completely open for verifying safety property in Conveyor, while closed for verifying liveness property in Robot. On the other hand, washing machine controller, which is a pure synchronous program, took more time to compile (2.29s) compared to Robot or Conveyor example since it uses more parallelisms in the program. However, in this example, there are fewer number of states as well as transitions required for verifying the property as indicated by SPIN (Table 2). It was expected as there is no asynchrony in this example that would increase complexity for verifying the properties in SPIN. Nevertheless, these numbers are comparable to that of Robot since the open-loop verification approach is used in this example (i.e. safety property).


                        Fig. 29
                        (a) compares the generated executable code sizes from the automata (SC-SystemJ) and AGRC (SystemJ) [8] compilers, respectively. All the benchmark programs are first compiled into Java source code, which are then compiled into class files using the Java version 1.8 compiler. The automata compiler generates on average 3.3× smaller code than the AGRC compiler. There are two main reasons for this: (1) in the automata semantics, proposed in this paper, control-flow of a program is just state transitions from one state to another that are explicitly specified by programmers using the pause statements. On the other hand, the AGRC semantics defines a sequence of fine grained micro-steps for individual SC-SystemJ statements between the pause statements. As a result, the AGRC compiler generates additional code for these micro-step executions, which leads to overall increased code size. (2) The automata compiler optimises the generated code by removing unreachable paths in the FSM.


                        Fig. 29 (b) shows the average reaction time of clock-domains in the benchmark programs. Reaction time indicates the time taken for a clock-domain to execute 1 tick (or equivalently an FSM transition). All benchmarks were run on a Core i5 CPU 660 3.33Ghz desktop with 4GB RAM and using the Java program profiler called VisualVM [39] in such way that the total execution time of a clock-domain tick is divided by the number of executions. Furthermore, the presented results are collected by running each CD 1 million times. As one can see from the figure, the average reaction times of the programs compiled using the automata compiler are faster, on average 2.1×, than when the same programs are compiled using the AGRC compiler. Again, this is because the AGRC compiler generates fine grained control-flow for the clock-domain execution (micro-step). Moreover, in the AGRC-based approach, status and value of the signals are accessed via getter and setter method calls, whereas in the automata-based approach, they are more efficiently accessed via direct reference to the Java class fields.

@&#CONCLUSIONS AND FUTURE WORK@&#

In this paper, a novel approach for generation of What You Prove Is What You Execute (WYPIWYE) Globally Asynchronous Locally Synchronous (GALS) programs designed in SC-SystemJ is presented. The approach produces a network of finite state Mealy machine from SC-SystemJ programs automatically, which are then translated into Promela for verification using Linear Temporal Logic (LTL) properties or executable C/Java code. The presented approach is scalable, i.e., the compiler does not run out of memory when compiling SC-SystemJ programs unlike previously described approaches to compilation of purely synchronous languages. This scalability has been achieved by translating SC-SystemJ programs into LTL formulas and then applying novel translation algorithms. The SC-SystemJ compiler generates both smaller and faster executable than the original SystemJ compiler. In the future work, we plan to investigate how to optimize the compiler to reduce runtime complexity.

@&#REFERENCES@&#

