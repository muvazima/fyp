@&#MAIN-TITLE@&#Assembly-based conceptual 3D modeling with unlabeled components using probabilistic factor graph

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a novel 3D CAD tool for conceptual design exploration.


                        
                        
                           
                           Interactive concept exploration through assembly-based 3D modeling paradigm.


                        
                        
                           
                           Automated component suggestion algorithm based on probabilistic factor graph.


                        
                        
                           
                           Creative reuse of 3D models available on vast online repositories.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Conceptual 3D modeling

Factor graph

Assembly-based modeling

@&#ABSTRACT@&#


               
               
                  This work presents a novel and intuitive assembly based 3D modeling interface to support conceptual design exploration activities. In the presented modeling interface, unlabeled segmented components of the objects are assembled to create new 3D models. The development of the interface is motivated by two aspects. First, the focus is on novice users since they stand to gain the most from intuitive interfaces. Second, the intent is on creative reuse of a growing number and variety of 3D models available on vast online repositories like Turbosquid and Trimble 3D warehouse. Specifically, we have devised an automated component suggestion algorithm based on a probabilistic factor graph. This algorithm helps the user to easily browse and select components from a database that are most compatible with the current state of 3D models being assembled. The component suggestion algorithm incorporates various aspects such as shape similarity, repetitions of shapes, and adjacency relationships. Our new suggestive interface overcomes several limitations of traditional CAD interfaces by helping the users to quickly create and explore new conceptual designs. We present results on the conceptual design of several products.
               
            

@&#INTRODUCTION@&#

Computer Aided Design (CAD) is omnipresent in multiple industrial domains such as automotive and aerospace. In terms of market size, the CAD market is one of the established, largest, and growing areas in software markets with a market cap of $7 billion in 2011  [1]. CAD is used for representation, knowledge management, communication, and visualization of design information at various stages of engineering design process. CAD plays a significant role in all the stages of design process. If the past is prologue, the role that CAD tools play in the engineering design value chain will likely to grow in scope, scale, and complexity. Although, the currently available CAD tools allow significant degree of control in 3D shape creation by requiring the user to specify exact shape parameters in a structured manner, they are not well suited for early conceptual design exploration and ideation activities.

For conceptual design, the current CAD systems have two major disadvantages: (1) inability to reuse existing design solutions as inspiration and (2) assumption that users know exact parameters and geometric details of the 3D model. Conceptual design exploration process is a creative and open-ended process in which designers initially do not have a clear mental picture of what their design looks like. They only have a rough idea of the design and through unexpected changes of direction during the generation of solution components they come up with the final solution concept. Another observation in conceptual design is that users usually derive inspiration from elements of existing designs and combine them with some new ideas to generate innovative concepts. Deriving inspiration from existing design accelerates the design process and enhances the creativity of the users. Therefore, CAD systems for conceptual design exploration should not only allow easy and intuitive (unexpected change in goal) exploration of possible design space but also enable one to reuse existing solutions as inspiration. Additionally, such interfaces should be simple to interact with and should not rely on the user providing geometrically accurate information.

In this paper, we present an assembly based modeling interface for conceptual design exploration. A key advantage of assembly based modeling system is that users focus on component selection and assembly rather than the creation of new geometry from scratch. The modeling interface suggests the modeler with possible additional components for the current shape through an unsupervised component suggestion algorithm. The component suggestion algorithm is based on probabilistic factor graph and leads to considerable speedup in conceptual shape synthesis. We used shape similarity, size, repetition, and adjacency relation to define factors for the factor graph. These factors help to determine plausible components from a repository of models that could then be assembled to create designs. The marginal probability distribution computed from the factor graph is used to score and rank components. The ranked component list is provided to the user within the interface as sources of suggestions for faster, intuitive, and easy shape synthesis.

Overall, this paper makes following contributions: 
                        
                           1.
                           A probabilistic factor graph based model that encapsulates the relationship between unlabeled components in a shape database.

An unsupervised dynamic component suggestion algorithm that guides the user by suggesting most relevant components at a given stage of assembly.

Development of a novel assembly based CAD modeling interface to guide a user to perform conceptual design assemblies.

In next section, we discuss related works on component suggestion algorithms and assembly based design systems. A brief overview of the whole approach is given in Section  3. Section  4 describes processing steps on database 3D models to compute various attributes and relationships. In Section  5, the factor graph is described in detail. Experimental results are presented in Section  6. Finally, possible future applications and limitations of our approach is discussed in Section  7.

@&#RELATED WORK@&#

The techniques pertinent to assembly based design systems and design suggestion algorithms are briefly reviewed below.


                     Assembly based design systems
                  

Many research papers focus on reusing existing 3D models to synthesize new models. Kreavoy et al.  [2] developed a system that can swap similar components of different models in a point-and-click way using precomputed compatible segmentation. However, this approach is restricted to models with similar shape or structure. Kanai et al.  [3] described techniques for manually inserting arbitrary components into a target surface by: (1) first cutting a suitable hole in the target, (2) aligning the component with the hole, (3) defining a boundary correspondence, (4) and then finally blending the two surfaces. Funkhouser et al.  [4] tried to automate the aforementioned steps via “intelligent scissor” cutting, ICP alignment, and automatic generation of smooth fillet surfaces. Various methods based on Poisson  [5,6] and bi-Laplacian  [7,8] are proposed to generate smoother transitions and handle differences in scale.

Another type of method proposed by Hassner et al.  [9] uses graph cut based tool to combine components from different models. To increase user’s participation, SnapPaste interface  [10] can automatically “snap” a component to a suitable target hole where the user would like it to be. A soft-ICP alignment parameterized by the cursor speed is used to drive the snapping, and a smooth blend surface is geometrically obtained. Note that, for each of aforementioned tools, the user must specify a global orientation for the component to be inserted as well as the target hole. Similarly, MeshMixer system  [11,12] adopts a “drag-and-drop” type interactive tool to automatically perform global orientation using a parameterization of the component boundary, which is then projected onto the target surface via local parameterization. As all the computations are efficient, the user can interactively drag the component across the target surface with real-time visual feedback. In our implementation, we use CGAL library   [13]
                     with Boolean union operation for component assembly interface. Note that the users have the freedom to save the assembled models as a set of disconnected components, or they could also choose to use Boolean union operation to merge the components into one unified model.


                     Component suggestion algorithms
                  

An important step in assembly based modeling is the selection of relevant components to be assembled into a user specified base model. A key challenge in this task is to select relevant and plausible components from a given repository of shapes, usually with thousands of 3D models. To address this problem, component suggestion algorithms have been proposed. These algorithms speed-up component selection process by suggesting components with high probability based on certain criteria.

As a pioneer of assembly based 3D modeling, Funkhouser et al.  [4] proposed an example based modeling approach allowing the user to search a model library and assemble desired models from segments of retrieved shapes. Their method requires users to search for the particular component they would like to add. Talton et al.  [14] presented a data-driven approach that supports open-ended 3D modeling. The key aspect of their method is that it requires the existence of a parametric space from which models are drawn. Other research works similar to ours are  [15–18]. In 2010, Chaudhuri and Koltun  [15] proposed a data-driven approach that gives suggestions for additional component based on model’s current geometrical attributes.

Chaudhuri et al.  [16] improved the results of their previous work by introducing Bayesian network to represent semantic and stylistic relationships between components. Kalogerakis et al.  [17] further improved the results by adding consideration of latent variables in the probabilistic graphical model. Chaudhuri et al.  [18] described a modeling system that achieve high-level design goal by using semantic attributes expressed in linguistic terms. Although, the aforementioned approaches provide useful suggestions, the major disadvantage of these methods is that they require labeled segmented components. The component labeling in a supervised framework becomes very tedious in the case of a database with high numbers parts and shapes. Label-based methods have scaling disadvantages. In case of large databases, labeling is a significant overhead. In our paper, we address this disadvantage. Additionally, a labeling based framework will require a user to label an alien/new part for which user wants to generate a suggestion list. A novice user without the knowledge of labeling schema might label the part wrong! In such cases, the labeling based approach could have additional disadvantages. In this paper, we propose a factor graph based component suggestion algorithm that does not require labeled components to generate suggestions and the user is free to interact with the system to create conceptual designs.

@&#OVERVIEW@&#

Using a diverse set of 3D models in the database, our method generates component suggestion list to guide users during assembly based modeling process. Users can interactively combine components from the suggestion list in the developed modeling interface (Fig. 1
                     ). Our interface allows users to add components from any alien source as well. The suggestion list automatically updates every time a component is added to the assembly.

We propose a probabilistic factor graph approach to identify most relevant components in the database to generate the overall component suggestion list. The suggestion list is generated based on the plausibility of the components that could be assembled to the current state of the model present in interface workspace. A non-parametric factor graph model is learned using 3D models and their unlabeled segmented components in the database. We utilize geometric similarities, sizes, repetitions, and adjacency relationships of database 3D models and components to develop a valid and robust factor graph model. The geometric similarity between the shapes is captured using light field shape descriptor  [19]. Other shape attributes and relationships are computed and used to define factor edges between the components. The probability distribution defined over the components is marginalized to obtain scores for each component. The components are then ranked and provided as suggestion list.

Factors defined to generate component suggestions are adjacency factors and multiplicity factors. The pairwise adjacency factors represent the likelihood of two components appearing next to each other. For example, the rollers and leg of office chair are very likely to occur together and hence should have a high mutual adjacency factor. The multiplicity factor embodies the relationship between similar components appearing multiple times in a 3D model. Consider the example of office chair, an occurrence of a roller should call for more rollers to be added to the assembly, as having a single roller is highly unlikely. Using these factors, our approach incorporates high-level semantic and geometric relationships between the components.

Given a set of different components to assemble, our interface can assemble them into a composite model. In our system, we developed a component assembly framework inspired from constructive solid geometry. The primary task of component assembly is to insert a selected component to the current state of the model and combine them into one unified model. In solid modeling, two major representation schemes are constructive solid geometry (CSG) and boundary representations (B-rep)  [20]. In our framework, we use the Nef-polyhedra data structure provided in CGAL  [13]. This data structure supports the Boolean operations (union, difference, and intersection) between two parts with arbitrary shape. By implementing the union operation, we could smoothly and precisely connect different components placed together into a single composite model. Additionally, users could also choose to store the assembled model as is, without merging the disconnected components using union operation.

The first step in providing meaningful suggestions to the users is to create a database of diverse 3D models. The models in the database have to be segmented into consistent components. Defining attributes of the 3D models and the components helps to learn useful semantic and geometric relationship between the components of the 3D models. These attributes were later used to learn a probabilistic model involving factor graphs. The probability distribution established in the model served as a tool to generate meaningful suggestions for the assembly based design process. In this section, the creation of database and computation of attributes is described in detail.

The database consists of 3D models in the form of triangular surface mesh. The database models are obtained from vast online repositories, such as 3D Content Central  [21], Trimble 3D Warehouse  [22], Princeton Shape Benchmark  [23], and NTU 3D Model Database  [19]. The probabilistic model, described in this paper, learns an independent model for each domain of models, such as tables, chairs, airplanes, coffee-makers, cars, etc. Our key observation is that, even though, the structures of the models in each domain have considerable variability, the component characteristics and their mutual relationships are very similar in a particular domain. By learning these characteristics of components and their mutual relationship in a particular domain, we could generate highly relevant component suggestions to guide the users during modeling task.

The database stores the 3D models and their components obtained using part-based segmentation. Database models are stored using indexes that allow for efficient query and retrieval of 3D models and their components. The 3D models are stored as plain text files containing sets of vertices and faces. The file is indexed using a model number. Similarly, each component file is indexed by a component number and the corresponding model number.

The segmentation of 3D models into components was done using the semi-automatic segmentation method presented by Shapira et al.  [24]. An important point to note is that the components were not labeled in the database. Unlike many other closely related works  [16–18], our method does not require the components to be labeled beforehand. For each particular domain, large number of 3D models are saved in the database. The large size of the database ensures high variability and diversity in each domain. As stated earlier, each domain was dealt independently in our framework. Hereafter, in this paper, database models and database components would refer to models and components belonging to a single domain unless stated otherwise.

The size of a 3D model and its components encode meaningful relationships. The size information is repeatedly used in several steps of the component suggestion algorithm. In order to ensure proper utilization of size information of the stored 3D models, the 3D models in the database were appropriately scaled. Scaling was done to mitigate the ill effects of high variability in 3D model sizes collected from different online repositories. Even very similar 3D models in the database initially were of drastically different sizes. The scaling was done before the models were segmented to generate components. Scaling the models ensured that the segmented components were also of relatively similar size. However, to afford modeling flexibility we provide an option for scaling any given component in the interactive assembly interface.

Scaling factor for a model was chosen to be the standard deviation of the 
                           
                              
                                 ℓ
                              
                              
                                 2
                              
                           
                        -norms of mean-centered uniformly sampled points on the surface of the model. The uniformly sampled points were obtained using the method described by Osada et al.  [25]. In this method, the number of points sampled on a triangle in the mesh is proportional to the area of the triangle. After scaling and segmenting the models, the sizes of the model and its components were computed. To compute the size of a model or a component, the uniformly sampled points were used. Principal Component Analysis (PCA) was performed on the sampled point set to obtain the principal directions. The minimum sized bounding box for the point set with its edges along the principal direction was used to determine the model’s or component’s size. The volume 
                           V
                         of the bounding box was stored as the representative of the size of the model or component. The number of sample points 
                           
                              
                                 N
                              
                              
                                 s
                              
                           
                         was chosen to be 1000 for each component. For whole 3D models, 
                           
                              
                                 N
                              
                              
                                 s
                              
                           
                         was chosen to be 
                           1000
                           ×
                           
                              
                                 J
                              
                              
                                 ˆ
                              
                           
                        , where 
                           
                              
                                 J
                              
                              
                                 ˆ
                              
                           
                         denotes average number of segmented components for the models in the database.

Adjacency relationships is another significant element of our component suggestion algorithm. To understand the importance of it, let us consider an example. When a user begins an interactive modeling session by placing a chair seat in the modeling workspace, the component suggestion algorithm should suggest components in the database that are more likely to be adjacent to the seat, such as the legs, the backseat, and the armrest. Adjacency relationships define if two components of a model are in contact with each other. We use model size information and sampled points on the models (described in the previous subsection) to compute the adjacency relations among the components in the database. Two components are treated as adjacent if the distance between any pair of points (one on each component) is less than 5% of the cube root of 3D model size. Mathematically, components 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         and 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                         of the model 
                           
                              
                                 M
                              
                              
                                 i
                              
                           
                         are said to be adjacent if there exist sample points 
                           
                              p
                           
                         on 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         and 
                           
                              q
                           
                         on 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                        , such that: 
                           
                              (1)
                              
                                 
                                    ‖
                                    
                                       p
                                    
                                    −
                                    
                                       q
                                    
                                    ‖
                                 
                                 ≤
                                 0.05
                                 ×
                                 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                    
                                    
                                       1
                                       /
                                       3
                                    
                                 
                              
                           
                         where 
                           
                              ‖
                              ⋅
                              ‖
                           
                         denotes 
                           
                              
                                 ℓ
                              
                              
                                 2
                              
                           
                        -norm and 
                           
                              
                                 V
                              
                              
                                 i
                              
                           
                         represents the size of model 
                           
                              
                                 M
                              
                              
                                 i
                              
                           
                         which is essentially the volume of 
                           
                              
                                 M
                              
                              
                                 i
                              
                           
                        ’s bounding box. Using this equation, all pairs of adjacent components in the models of the database are determined and stored.

The shape similarity between components is very crucial metric for capturing the semantic aspects and relationships between the models in the database. Since the components in the database were not labeled, the shape similarity metric was used to identify similar components. To determine the similarity between the components of the database 3D models, various shape descriptors or their combinations can be used  [26,27]. In this paper, Light Field Descriptors (LFD), developed by Chen et al.  [19], was used for determining shape similarity. LFD is based on visual-similarity based approach and is robust against translation, rotation, scaling, noise, decimation, and model degeneracy. The 
                           
                              
                                 ℓ
                              
                              
                                 1
                              
                           
                        -norm 
                           
                              
                                 D
                              
                              
                                 j
                                 k
                              
                           
                         between descriptors of two components 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         and 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                         provides a measure of how dissimilar the components are. Assuming half-normal distribution of the 
                           
                              
                                 ℓ
                              
                              
                                 1
                              
                           
                         distances, the shape similarity was defined as follows: 
                           
                              (2)
                              
                                 ρ
                                 
                                    (
                                    
                                       
                                          S
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          S
                                       
                                       
                                          k
                                       
                                    
                                    )
                                 
                                 =
                                 1
                                 +
                                 exp
                                 
                                    (
                                    −
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      D
                                                   
                                                   
                                                      j
                                                      k
                                                   
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                       
                                          2
                                          
                                             
                                                σ
                                                
                                                   (
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     

The standard deviation 
                           σ
                           
                              (
                              
                                 
                                    S
                                 
                                 
                                    j
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    k
                                 
                              
                              )
                           
                         was obtained using a threshold value of 
                           τ
                           =
                           5
                           %
                         of the 
                           
                              
                                 ℓ
                              
                              
                                 1
                              
                           
                         distances among any pair of components containing either 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         or 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                        . This definition causes the standard deviation to be represented as a function of components 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         and 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                        . The threshold value 
                           τ
                         can be adjusted to tune the similarity measure based on the number of components in the database  [28]. It allows choosing the standard deviation such that a fraction of the smallest 
                           
                              
                                 ℓ
                              
                              
                                 1
                              
                           
                         distances is captured within the range 
                           
                              [
                              0
                              ,
                              σ
                              
                                 (
                                 
                                    
                                       S
                                    
                                    
                                       j
                                    
                                 
                                 ,
                                 
                                    
                                       S
                                    
                                    
                                       k
                                    
                                 
                                 )
                              
                              ]
                           
                        . The similarity value between any pair of components varies in the range 
                           
                              [
                              1
                              ,
                              2
                              ]
                           
                        ; larger value representing higher similarity.

The structure of probabilistic factor graph underlying our component suggestion algorithm is described in the next section.

We model the probability distribution over the set of components to be added to assembly using factor graphs. Factor graph consists of two types of nodes—variable nodes and factor nodes. At any given point of time during the assembly process, the current state of the assembled model is represented as observed variables. Each component of the assembly corresponds to one observed variable in the factor graph. Factor graph also has latent variables, which represents the plausible components that could be added to the assembly. Both observed variables and latent variables constitute the set of variable nodes. The variable nodes in the factor graph is updated each time the designer adds a component to the overall assembly. The factor nodes represent unary, pairwise, and higher order factors. They describe the relationship among different variable nodes/components. In our implementation, we introduced two types of factors—adjacency factors and multiplicity factors.

In our factor graph implementation, we define a pairwise factor named adjacency factors 
                           
                              
                                 ψ
                              
                              
                                 
                                    adj
                                 
                              
                           
                           
                              (
                              ⋅
                              ,
                              ⋅
                              )
                           
                        . Adjacency factors are calculated using the adjacency relations and shape similarity information (described in Sections  4.3 and 4.4). The adjacency factor represents how likely it is for a pair of components to appear adjacent to one another. More likely pairs were assigned a higher value for the factor and vice versa. The basic idea behind the definition of adjacency factor is that if a pair of components is very similar to each other’s adjacent components, they are more likely to appear next to each other, and hence the corresponding factor should have a high value. To calculate adjacency factor between two components, we make use of the shape similarity between one component and the adjacent components of the other. The adjacency factor between the components 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         and 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                         in the database can be computed as: 
                           
                              (3)
                              
                                 
                                    
                                       ψ
                                    
                                    
                                       
                                          adj
                                       
                                    
                                 
                                 
                                    (
                                    
                                       
                                          S
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          S
                                       
                                       
                                          k
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    (
                                    
                                       
                                          max
                                       
                                       
                                          
                                             
                                                S
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                T
                                             
                                             
                                                j
                                             
                                          
                                       
                                    
                                    ρ
                                    
                                       (
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             k
                                          
                                       
                                       )
                                    
                                    +
                                    
                                       
                                          max
                                       
                                       
                                          
                                             
                                                S
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                T
                                             
                                             
                                                k
                                             
                                          
                                       
                                    
                                    ρ
                                    
                                       (
                                       
                                          
                                             S
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    )
                                 
                              
                           
                         where 
                           
                              
                                 T
                              
                              
                                 j
                              
                           
                         and 
                           
                              
                                 T
                              
                              
                                 k
                              
                           
                         represents the sets of components which are adjacent to components 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         and 
                           
                              
                                 S
                              
                              
                                 k
                              
                           
                        , respectively. For a component 
                           
                              
                                 
                                    
                                       S
                                    
                                    
                                       ˆ
                                    
                                 
                              
                              
                                 j
                              
                           
                         added to the assembly from an alien source, the set of adjacent components is not known. In such cases, the adjacency factor was computed as: 
                           
                              (4)
                              
                                 
                                    
                                       ψ
                                    
                                    
                                       
                                          adj
                                       
                                    
                                 
                                 
                                    (
                                    
                                       
                                          
                                             
                                                S
                                             
                                             
                                                ˆ
                                             
                                          
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          S
                                       
                                       
                                          k
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       max
                                    
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                       ∈
                                       
                                          
                                             T
                                          
                                          
                                             k
                                          
                                       
                                    
                                 
                                 ρ
                                 
                                    (
                                    
                                       
                                          
                                             
                                                S
                                             
                                             
                                                ˆ
                                             
                                          
                                       
                                       
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                         Further, the adjacency factor between two components from alien sources was set to 1. Fig. 2
                         shows a factor graph with adjacency factors among the set of components of a table.

Using adjacency information for ranking components is reasonable because users tend to assemble components in sequential manner. Priority is given first to assemble components adjacent to existing components in the assembly. It was assumed that the database 3D models contains no disconnected components, i.e. each component is adjacent to at least one other component in a 3D model. Based on the adjacency factor definition and the no-disconnected components assumption, the value of the adjacency factor always lies in the range 
                           
                              [
                              1
                              ,
                              2
                              ]
                           
                        . A higher value indicates more probability for the pair to appear adjacent to each other.

Multiplicity factor 
                           
                              
                                 ψ
                              
                              
                                 
                                    mult
                                 
                              
                           
                           
                              (
                              ⋅
                              )
                           
                         was used to encode multiple appearances of components in a model. For example, two wings of an airplane and four similar legs of a table. These models consist of components that appear more than once in the model. The basic idea is that if one or few of the repeated components are included in the assembled model, multiplicity factor tries to boost the ranking of similar components. Multiplicity factor can be an unary, a pairwise, or a higher order factor. The order of the factor depends on the number of replications of a component in a model.

To compute multiplicity factor, we first define sets of components called kin sets. The property of a kin set (
                           K
                        ) is that for all pairs of components 
                           
                              
                                 S
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                         in it, 
                           ρ
                           
                              (
                              
                                 
                                    S
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    j
                                 
                              
                              )
                           
                           ≥
                           
                              
                                 ρ
                              
                              
                                 K
                              
                           
                        . Here, 
                           
                              
                                 ρ
                              
                              
                                 K
                              
                           
                         is a threshold value for shape similarity metric 
                           ρ
                           
                              (
                              ⋅
                              ,
                              ⋅
                              )
                           
                        . In our implementation, 
                           
                              
                                 ρ
                              
                              
                                 K
                              
                           
                         was set to a value of 1.1. For every 3D model in the database, we identify the largest possible disjoint kin sets (
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                        ’s) of its components, giving preference to sets with larger cardinality. Similarly, we find kin sets in assembly models (including the latent variables, described in Section  5.3).

The components in the assembly model are distributed into largest possible disjoint kin sets (
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                        ’s). Then, for each kin set 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                        , its most similar counterpart kin set 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         was identified in the database. If a 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                         included one or more components from the database, the corresponding 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         was simply determined to be the one that included few or all of those components, preferring larger 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         over smaller ones. For a 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                         with all components from alien sources, 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         was identified as the set to which it can be unionized to form a larger kin set. If no such kin set 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         existed in the database, the multiplicity factor for 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                         was set to 1.

The multiplicity factor for a 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                         with a corresponding 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         in the database was computed as follows: 
                           
                              (5)
                              
                                 
                                    
                                       ψ
                                    
                                    
                                       
                                          mult
                                       
                                    
                                 
                                 
                                    (
                                    
                                       
                                          K
                                       
                                       
                                          v
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       
                                          (
                                          
                                             
                                                2
                                             
                                             
                                                
                                                   |
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         v
                                                      
                                                   
                                                   |
                                                
                                                
                                                   (
                                                   
                                                      |
                                                      
                                                         
                                                            K
                                                         
                                                         
                                                            v
                                                         
                                                      
                                                      |
                                                   
                                                   −
                                                   1
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                ∑
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                
                                                ∈
                                                
                                                ξ
                                                
                                                   (
                                                   
                                                      
                                                         K
                                                      
                                                      
                                                         v
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                          ρ
                                          
                                             (
                                             
                                                
                                                   S
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   S
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                          )
                                       
                                    
                                    
                                       γ
                                    
                                 
                              
                           
                        where 
                           
                              
                                 γ
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                |
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      v
                                                   
                                                
                                                |
                                             
                                             −
                                             1
                                             ,
                                          
                                          
                                             if  
                                             
                                                |
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      v
                                                   
                                                
                                                |
                                             
                                             <
                                             
                                                |
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      u
                                                   
                                                
                                                |
                                             
                                          
                                       
                                       
                                          
                                             0
                                             ,
                                          
                                          
                                             otherwise ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              |
                              ⋅
                              |
                           
                         represents cardinality of a set, and 
                           ξ
                           
                              (
                              
                                 
                                    K
                                 
                                 
                                    v
                                 
                              
                              )
                           
                         represents a set of all unordered pairs of elements from the set 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                        . The above equation computes the multiplicity factor as the arithmetic mean of similarities of all possible pairs of components in the set raised to the power of 
                           γ
                        . The lower limit of the multiplicity factor is 1. Fig. 3
                         shows a factor graph with multiplicity factor among the set of few similar components in a table model.

For the sets 
                           
                              
                                 K
                              
                              
                                 v
                              
                           
                         with corresponding 
                           
                              
                                 K
                              
                              
                                 u
                              
                           
                         such that 
                           
                              |
                              
                                 
                                    K
                                 
                                 
                                    u
                                 
                              
                              |
                           
                           =
                           1
                        , the exponent 
                           γ
                         is 0 by definition. It leads to a multiplicity factor value of 1. Setting the default value of multiplicity factor to 1 for all sets with 
                           
                              |
                              
                                 
                                    K
                                 
                                 
                                    u
                                 
                              
                              |
                           
                           =
                           1
                         reduces the computational cost by a considerable extent. While calculating the probability using product of factors, such sets can be ignored and only the sets with 
                           
                              |
                              
                                 
                                    K
                                 
                                 
                                    u
                                 
                              
                              |
                           
                           >
                           1
                         can be taken into consideration. It reduces the computation cost during the execution of the algorithm, as the occurrence of multiple similar components in models are less frequent. However, the number of unique components in a model can be quite large.

In our implementation of the factor graph, each variable node represents a discrete random variable, which can take any value from the set of all components in the database 
                           
                              {
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    S
                                 
                                 
                                    J
                                 
                              
                              }
                           
                         or from any alien source 
                           
                              {
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    
                                       
                                          S
                                       
                                       
                                          ˆ
                                       
                                    
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              }
                           
                        . The variables representing the components in the existing state of the model were treated as observed variables (
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                        ’s). To suggest components that can be assembled to the current state of the model, few latent variables (
                           
                              
                                 y
                              
                              
                                 j
                              
                           
                        ’s) are also included in the factor graph. These latent variables represent the components that would be used by the user later in the overall assembly process. The latent variables can take on values from the set of components in the database only. An important point to note here is that the learned model is non-parametric. It uses the components in the database as values of latent variables to produce suggestion list.

The number of latent variables is set based on manageable real-time computational cost and the state of the assembled model. During the starting phase of the assembly, a large number of latent variables can be used. On the other hand, towards the end of the assembly process, a small number of latent variables should be used. The phase (start, mid-way, or end) can be determined by comparing the number of components assembled and the average number of components in the models of the database. The number of latent variables is highly correlated with the computational cost. A higher number of latent variables leads to higher computational time. In our implementation, to keep the algorithm real-time, we use 2, 3, or 4 latent variables in every phase of the assembly based modeling process. Fig. 4
                         shows an example of factor graph with three observed and two latent variables. Note that the factors shown in the figure are only for an illustrative purpose; the structure of the graph and factors might vary depending on the values taken by the variables.

To recommend components, the marginal probability of the latent variables are used as score. For computing the marginal probability, the probability distribution over a latent variable in the factor graph is marginalized. Let 
                           X
                           =
                           
                              {
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    N
                                 
                              
                              }
                           
                         represents the set of observed variables and 
                           Y
                           =
                           
                              {
                              
                                 
                                    y
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    y
                                 
                                 
                                    M
                                 
                              
                              }
                           
                         represents the set of latent variables. The conditional probability 
                           P
                           
                              (
                              Y
                              |
                              X
                              )
                           
                         can be computed as the product of all the factors divided by normalizing constant: 
                           
                              (6)
                              
                                 P
                                 
                                    (
                                    Y
                                    |
                                    X
                                    )
                                 
                                 =
                                 
                                    
                                       P
                                       
                                          (
                                          Y
                                          ,
                                          X
                                          )
                                       
                                    
                                    
                                       P
                                       
                                          (
                                          X
                                          )
                                       
                                    
                                 
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       Z
                                       
                                          (
                                          X
                                          )
                                       
                                    
                                 
                                 
                                    
                                       
                                          (
                                          
                                             
                                                ∏
                                             
                                             
                                                
                                                   (
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         S
                                                      
                                                      
                                                         k
                                                      
                                                   
                                                   )
                                                
                                                
                                                ∈
                                                
                                                ξ
                                                
                                                   (
                                                   X
                                                   ∪
                                                   Y
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                ψ
                                             
                                             
                                                
                                                   adj
                                                
                                             
                                          
                                          
                                             (
                                             
                                                
                                                   S
                                                
                                                
                                                   j
                                                
                                             
                                             ,
                                             
                                                
                                                   S
                                                
                                                
                                                   k
                                                
                                             
                                             )
                                          
                                          )
                                       
                                    
                                    
                                       α
                                    
                                 
                                 
                                    
                                       
                                          (
                                          
                                             
                                                ∏
                                             
                                             
                                                
                                                   
                                                      T
                                                   
                                                   
                                                      i
                                                   
                                                
                                                
                                                ∈
                                                
                                                K
                                                
                                                   (
                                                   X
                                                   ∪
                                                   Y
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                ψ
                                             
                                             
                                                
                                                   mult
                                                
                                             
                                          
                                          
                                             (
                                             
                                                
                                                   T
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          )
                                       
                                    
                                    
                                       β
                                    
                                 
                              
                           
                        where the normalizing constant 
                           Z
                           
                              (
                              X
                              )
                           
                         is a function of the observed variables, 
                           ξ
                           
                              (
                              ⋅
                              )
                           
                         is the set of all unordered pair of elements of the argument set, and 
                           K
                           
                              (
                              ⋅
                              )
                           
                         is the set of all kin sets. 
                           α
                         and 
                           β
                         are the exponents used to tune the probability by adjusting weights between two types of factors. In our implementation, 
                           α
                         was set to 1 and 
                           β
                         was set to 0.6. The numerator of the above expression includes the product of all the factors appearing in factor graph comprising of both observed and latent variables.

The marginal probability distribution over a latent variable can be computed by marginalizing the conditional probability in Eq. (6). The marginal probability distribution for each latent variable would be the same, as the latent variables are indistinctive from each other. However, the distribution changes if the number of latent variables in the factor graph is modified. Using appropriate number of latent variables is necessary for portraying real scenario accurately and having a decent real-time computational performance. Marginalizing over any one of the latent variable (suppose 
                           
                              
                                 y
                              
                              
                                 1
                              
                           
                        ) would provide the score for each of the component. The marginal distribution over the latent variable 
                           
                              
                                 y
                              
                              
                                 1
                              
                           
                         is given as: 
                           
                              (7)
                              
                                 P
                                 
                                    (
                                    
                                       
                                          y
                                       
                                       
                                          1
                                       
                                    
                                    |
                                    X
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       Y
                                       ∖
                                       
                                          
                                             y
                                          
                                          
                                             1
                                          
                                       
                                    
                                 
                                 P
                                 
                                    (
                                    Y
                                    |
                                    X
                                    )
                                 
                                 .
                              
                           
                         Since the normalizing constant 
                           Z
                           
                              (
                              X
                              )
                           
                         does not vary with respect to 
                           Y
                        , it can be ignored and only the numerator of the conditional probability in Eq. (6) can be used for computation of marginal score. Using the marginal scores, the components can be ranked and presented to the user in the order of their ranks.

When the set of observed variables 
                           X
                         is empty, i.e. when the user has just started the assembly based modeling process and has not added any component to the modeling workspace, the component size ratio instead of latent variable marginalization is used to rank the components. In general, users tend to start the assembly process with components that are larger in size compared to other smaller components of the 3D model. For example, while generating concepts for a power drill, one would prefer to start with the body of the drill, rather than the drill bit or the screws. Hence, using size ratios for component rankings makes more sense in the beginning of the modeling process. The size ratio for a component is defined as the ratio of the component size to the model size. The component or model size denotes the volume of its bounding box. The computation of the volumes is described in Section  4.2. Using the component size ratio, the components are initially ranked and presented to the user at the start of the assembly based modeling process.

The proposed approach for generating suggestions and creating assembly models is illustrated using a flowchart in Fig. 5
                        .

@&#EXPERIMENTS AND RESULTS@&#

Our component suggestion algorithm was implemented in MATLAB. The assembly based 3D modeling interface was created using C++. The component suggestion algorithm was integrated into the modeling interface using MATLAB compiler. All the results presented in this paper were generated on a quad-core 3.4 GHz Core i7 PC. Fig. 6
                      shows a screenshot of the interface. A 3D modeling workspace is the major portion of the interface. The top 50 components in the suggestion list are presented in the bottom pane of the interface. The users can scroll through the list and drag the components into the workspace environment. Additionally, users could also upload components from any alien source. The components selected could be placed in proper position for assembly by dragging. Users can translate, orient, and scale a component as desired using sliders and mouse clicks. After a component is selected to be assembled to the model, the suggestion list is updated automatically. In our modeling interface implementation, we use the Nef-polyhedra data structure provided in CGAL  [13] to support CSG Boolean operations (union, difference, and intersection) between two parts. By implementing the union operation, the modeling interface smoothly and precisely connects different components placed together into a single composite model. However, connecting different components into a single unified model is an optional functionality. Users could also save the model as a set of disconnected components placed at appropriate locations.

For real-time application, it is necessary to keep the runtime computation moderate. We pre-computed and stored all the necessary measures from the database during the preprocessing step. The runtime computation included determining the structure of factor graph, computing the factors for different configurations of latent variables, calculating marginal probabilities, and sorting them to rank the components. The sequential implementation of the algorithm generated the suggestion list in 0.04 s with two latent variable and 0.91 s with three latent variables. These time durations were calculated by averaging the time taken by 1000 random queries with varying number of components in the workspace. The time taken is reasonable for real-time application as the delay by the user in placing the active component and selecting the next component provides a small window of time for the algorithm to generate the suggestion list. However, the computation time could very easily be significantly decreased by parallelizing the implementation of our code.

To evaluate the correctness and relevance of the generated suggestions, we conducted multiple trials of an experiment. In this experiment, components were assembled, and the relevancy of the generated suggestions for the next component was assessed. The experiment was repeated for five different component configurations in each domain. In each trial, the number of relevant components was recorded among the top 10, 20, 30, 40, and 50 suggestions. The relevancy of the component was judged based on its competency of being added to the current state of assembly model. For example, if the current state of assembly model contains only a wing of an airplane, the suggestions list should include components such as fuselage and engines, whereas components such as tail wings and landing gear are considered irrelevant. Aggregated results of the percentage of the relevant component in top suggestions are presented in Fig. 7
                     (a). It can be observed that the top suggestions mostly included relevant components with a percentage ranging between 85% and 91%.

We also conducted an Institutional Review Board (IRB) approved user study to test the effectiveness of our suggestive interface. The study involved ten users divided equally into two groups 
                        A
                      and 
                        B
                     . Each user in this study had at least basic-level prior experience in 3D modeling using one or more existing CAD software packages. The users were shown rendered figures of three 3D models and were asked to complete the following tasks: 
                        Task 1:
                        
                           Create the 3D models using our suggestive interface.

Create the 3D models using the same interface with suggestion list replaced by a randomized list of all the components in the database.

To minimize the bias towards any one of the interfaces, group 
                        A
                      users were asked to complete the task in order, i.e. task 2 followed task 1, whereas group 
                        B
                      users were asked to complete the task 2 before task 1. Additionally, a five minute practice session was conducted for each user to familiarize him/her with the interfaces before starting the experiments. The time taken by the users in completing these tasks were recorded. The mean time spent on each task for both groups are shown in Fig. 7(b). It can be observed that our suggestive interface performs much better than the interface with the randomized list of components irrespective of the order in which tasks were performed. We also asked the user for their feedback with respect to ease of use of the two interfaces. Nine out of ten users found the suggestive interface to be more useful and easy to use than the other interface. One user felt no noticeable difference in using the two interfaces.

Several 3D models were created using our interface, some of which are shown in Figs. 8 and 9
                     
                     . The database consisted of 384 components. The number of latent variables was adjusted based on the phase (start, mid-way, and end) of the modeling task. The number of latent variables was varied between 2 and 4. A video showing the complete procedure of creating models using our interface has been included as a supplementary material (see Appendix A).

We have introduced a probabilistic factor graph based approach to recommend components to the users of assembly-based conceptual design exploration interface. Our approach overcomes the limitations of existing CAD modeling tools that require the user to input exact and well-defined dimensions for creating any model. This information is rarely available to the designers during the conceptual design phase. In the presented approach, we learn factor graph model from a large database of diverse 3D models and their segmented unlabeled components. The factor graph model encodes the geometric and semantic relationship between the models and their components. The marginal probability distribution over the set of components inferred from the probabilistic factor graph is used for scoring and ranking the components to be presented to the user. We have also developed an assembly-based 3D modeling interface prototype that the user can use to create conceptual 3D models interactively.

Our developed component suggestion algorithm and interface can be used in several domains. For example, in computer graphics, our approach can be used to easily and quickly create multiple virtual models that could fit a scene or environment. The functionality of our interface can be augmented by enabling texturing and animation features. To improve the quality of 3D models generated, mesh manipulation techniques such as deformation can also be integrated into our interface. In mechanical and structural engineering domain, our approach could be used to create conceptual designs inspired by existing designs.

There are multiple directions of future work. In future, one could incorporate more factors capturing higher level semantic aspects of designs. The factor graph in this setting can then be used to capture the stylistic relations of the components, symmetries in the designs, and higher level dependencies between non-adjacent components of the 3D models. For example, while conceptual modeling of a robot, adding a human type head should increase the probabilities for suggesting human type feet. Increasing the size of the database would also help to capture more relationships and dependencies among the components of models. However, a larger database could slow the component suggestion algorithm and effect the real-time performance of the interface. Message passing inference algorithm  [29] could be used to accelerate the speed of marginal probability computation. However, with the increase in the size of the database, the computational complexity of the algorithm might grow to an intractable level, irrespective of how small the number of latent variables is. In future, we would like to explore developing more efficient algorithms. It might involve using techniques for sampling the database or subdivision of the database into smaller subsets. Furthermore, parallel computations could be used to enhance the computational performance.

In future, we would like to conduct user study on a larger scale to evaluate the benefits and applicability of our algorithm and the interface. Another promising direction of future work is to automatically assign plausible materials to the components. Developing techniques to automatically scale and deform the infeasible design to ensure functional plausibility and design requirement satisfaction is another avenue of future work. Additionally, our interface could be improved by using more robust and easy-to-use manipulation tools, such as pointer-based and gesture-based, instead of currently implemented adjustable sliders.

Supplementary material related to this article can be found online at http://dx.doi.org/10.1016/j.cad.2015.10.002.

The following is the Supplementary material related to this article. 
                        
                           Video S1
                           
                              Video abstract of the paper.
                           
                           
                        
                     
                  

@&#REFERENCES@&#

