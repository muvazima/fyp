@&#MAIN-TITLE@&#Aggregation heuristic for the open-pit block scheduling problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present innovative aggregation and disaggregation heuristics.


                        
                        
                           
                           We obtain near-optimal solutions, improving best-known results in the literature.


                        
                        
                           
                           The procedure is fully scalable, and a promising tool for large-size problems.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mine planning

Block aggregation

Open-pit block scheduling

Integer programming

Heuristics

@&#ABSTRACT@&#


               
               
                  In order to establish a production plan, an open-pit mine is partitioned into a three-dimensional array of blocks. The order in which blocks are extracted and processed has a dramatic impact on the economic value of the exploitation. Since realistic models have millions of blocks and constraints, the combinatorial optimization problem of finding the extraction sequence that maximizes the profit is computationally intractable. In this work, we present a procedure, based on innovative aggregation and disaggregation heuristics, that allows us to get feasible and nearly optimal solutions. The method was tested on the public reference library MineLib and improved the best known results in the literature in 9 of the 11 instances of the library. Moreover, the overall procedure is very scalable, which makes it a promising tool for large size problems.
               
            

@&#INTRODUCTION@&#

The mining industry is a very relevant economic sector. In Chile, where this research has been carried out, copper exports account for about 62.5 percent of the total exports and represent a 12 percent of the GDP (Cochilco, 2013).

Mines can be either open-pit or underground, the actual decision depending on different economic and technical considerations. In this paper we focus on open-pit mines, in which mineral is extracted by digging from the surface. Open-pit mines are preferred to underground mines because they can reach higher production levels, and have smaller operational costs. However, most of the time, it is necessary to remove material with poor or none ore content (waste) in order to have access to economically profitable material.

The actual value of a mine strongly depends on the order in which the material is extracted and processed. In order to define what portions of the terrain must be mined at different moments during the life-time of the mine, the planning horizon is discretized into time-periods (or time-slots). In turn, the terrain is divided into regular blocks, which are arranged in a 3-dimensional array. For each block, estimations on the ore content, density and other relevant attributes are constructed by using geostatistical methods. A block model, namely, the set of all blocks and their attributes, is the main input to the mine planning process. Using this information, it is possible to build a block scheduling, which specifies an extraction time-period for each block. The final value of a mine is therefore determined by the block model and the block scheduling.

The feasibility of a block scheduling for the open-pit method depends on accessibility and extraction constraints. First, before extracting one block, all the blocks above it must have been extracted. Moreover, stability of the walls must be ensured. This is expressed in terms of slope angles that must be satisfied at each moment. All these constraints are translated into precedences between blocks. On the other hand, there are certain capacity constraints, as well as other limitations, that are inherent to the process. The amount of material to be transported and processed at each period is subject to upper bounds given by transportation and plant capacity, respectively, which are usually expressed either in tons or hours. Further on, processed material must satisfy some blending constraints as well. The efficiency (or even feasibility) of the plant process depends on the attributes of the combination of blocks that are processed at a given period. For example, it may not be feasible to process alone a block with a high content of a certain pollutant (say arsenic), even it has a very high ore grade. Mixing it with another block (even a low ore-grade one) and processing them simultaneously may be possible because the blending provides an acceptable amount of the pollutant. Blending constraints can be either upper or lower bounds and apply to certain attributes of the blocks to be processed. Finally, the decision of how to process a block may depend on different parameters. Indeed, it is quite common for a mine to have more than one processing possibility (considering a block as waste and sending it to a waste pile is already one possibility). Depending on the final process or destination of the block, the net profit perceived by the mine is different, as are the blending constraints that apply to the process and the resource required to achieve this processing (different plant capacities, for example).

In this work, we propose and test a new numerical method to determine the block scheduling that maximizes the net present value for the exploitation of an open-pit mine. Our proposal is based on a combination of two approaches, that allow us to reduce the size of the problem and make it computationally tractable. The procedure aggregates blocks, uses integer programming techniques to solve incrementally the aggregated problem and produces solutions for the original instance in an innovative fashion. Using this methodology, we are able to provide nearly optimal solutions for some realistic-size problems that are otherwise numerically inaccessible.

The procedure was proved on the instances of the public reference library named MineLib (Espinoza, Goycoolea, Moreno, & Newman, 2013), which has three different types of open-pit mine planning problems for which good feasible solutions have been reported: the ultimate pit limit problem and two variants of open-pit production scheduling problems, for fictional cases, but also for real-life mine (for example, the instances KD, P4HD, W23 and McLaughlin correspond to actual copper and gold mines located in North America). We focus on the Constrained Pit Limit Problem (CPIT), which consists of the maximization of the net present value (NPV) of the exploitation over the time horizon, subject to precedence and operational constraints. The results obtained by our procedure improve nine out of the eleven instances available in the MineLib library. Moreover, the remaining two cases are within a gap of 0.2 percent of the optimum solution.

The paper is organized as follows: In Section 2 we provide a brief summary of the most relevant (and best-known) approaches found in the literature. Section 3 contains all the details concerning the modeling, notation and problem statement. The description of our methodological proposal, as well as the different heuristics involved, are presented in Section 4. All the implementation details, and the numerical results obtained are given and commented in Section 5. Finally, Section 6 contains some concluding remarks and perspectives.

@&#RELATED WORK@&#

A very general formulation, due to Johnson (1968), presents the block scheduling problem under slope, capacity and blending constraints (the last ones given by ranges of the processed ore grade) within a multi-destination setting, i.e., the optimization model decides what is the best process to apply to a given block. Unfortunately, at the time of its publication, the model was too complex to be solved in realistic case studies.

As an alternative to the work of Lerchs and Grossman (1965) proposed a very simplified version of the problem in which block destinations are fixed in advance, slope constraints are considered, but capacity or blending constraints are not. In this case, the problem reduces to selecting a subset of blocks such that the contained value is maximized while the precedence constraint induced by the slope angles are held. This problem is known as the ultimate or final pit problem. Lerchs and Grossman presented an efficient (polynomial) algorithm for solving the ultimate pit problem, and showed that reducing the economic value of any given block makes the optimal solution of the ultimate pit problem to shrink, in the sense that, if the values of the blocks decrease, the new solution is a subset of the original one. Therefore, it is possible to produce nested pits and, by trial and error, construct block schedules that satisfy other constraints like capacity. Present-day commercial software, like Gemcom (2011), is based on these facts.

As it turns out, while the model proposed by Johnson (and others) has always been regarded as superior in terms of the value it can add to a mining plan, it has been only recently that new developments (especially in algorithms) have allowed to solve or approximate this kind of models. Indeed, a main motivation of this work is to contribute to transform the theoretical superiority of these mathematical models into a practical one.


                     Picard (1976) showed that the ultimate pit problem is equivalent to the maximum closure problem in which, given a directed graph 
                        
                           G
                           =
                           (
                           V
                           ,
                           A
                           )
                        
                      with weight function w defined over the nodes, one looks for a subset of nodes U ⊂ V such that ∑
                        u ∈ U
                     
                     w(u) is maximal but u ∈ U, (u, v) ∈ A⇒v ∈ U. The maximum closure problem, in turn, can be reduced to the min cut problem (for more details see Nemhauser & Wolsey, 1988). Using this fact, Hochbaum and Chen (2000) proposes to attack the ultimate pit problem by means of existing efficient algorithms for the min cut problem.


                     Caccetta and Hill (2003) use a customized version of the branch-and-bound algorithm to solve problems up to a few hundreds of thousands of blocks under blending and capacity constraints. Their method can be used only for upper bounds. Bley, Boland, Fricke, and Froyland (2010) use a similar model but incorporating additional cuts based on the capacity constraints that strengthen the formulation of the problem, in the sense that the value of the linear relaxation provides a tighter bound. They test this approach on small instances (up to 500 blocks and 10 time-periods) on which they show very interesting improvements in the computational time. Unfortunately, it is not clear how to scale the technique for larger instances, as the number of cuts may explode very quickly. A closely related strategy is used by Fricke (2006), in order to find inequalities that improve various integer formulations of the same model. Gaupp (2008) reduces the size of the problem by deriving minimum and maximum extraction periods for each block, from the capacity constraints, and eliminating some of the variables. The method then applies Lagrangian relaxation to solve the problem.

The next two papers address the problem under consideration, but considering only upper bounds on resources consumption constraints: First, Amaya et al. (2009) starting from an initial feasible solution and then iteratively fix parts of the incumbent solution and re-optimize the complement. At each iteration, this defines an integer programming sub-problem that is solved exactly. They are able to solve instances of up to 4 million blocks and 15 time periods in 4 hours. In turn, Lamghari, Dimitrakopoulos, and Ferland (2014) use a hybrid method based on linear programming and variable neighborhood descent. The authors introduce a two-phase solution method: in the first one, they solve a series of linear programming problems to generate an initial solution. In the second phase, a variable neighborhood descent procedure is applied to improve the solution. The method is tested on some benchmark instances from the literature (some of MineLib), showing new best-known solutions for almost all of the instances, when compared to the solutions reported in Lamghari et al. (2014) and Espinoza et al. (2013). Indeed, only in two of these instances the solutions obtained have a larger gap, but this is still at much 0.2 percent.

Following Picard and Hochbaum ideas, Chicoisne, Espinoza, Goycoolea, Moreno, and Rubio (2012) and Bienstock and Zuckerberg (2010) address a problem which is very close to the one considered in this paper. However, they use Lagrangian relaxation on all but the precedence constraints (in this case the problem reduces to the ultimate pit problem). Using this approach, Chicoisne et al. focus on the case where there exists only one destination and one capacity constraint per period, and develop a customized algorithm (CMA) for the linear relaxation and a procedure (based upon topological sorting) to obtain an integer feasible solutions from it. They report good solutions for the problem in large instances (over one million blocks). Moreover, Espinoza et al. (2013) published a library of standardized instances, named MineLib, for which they apply the above techniques and obtain very good results as well. Respectively, Bienstock and Zuckerberg consider all types of constraints, but focus on the resolution of the linear relaxation only, and report very good improvements in resolution time with respect to the standard LP solvers.

Other work which is close to ours is due to Cullenbine, Wood, and Newman (2011). They propose a heuristic using Lagrangian relaxation on capacity constraints (lower and upper bounds) plus a sliding window strategy in which extraction variables for late periods are relaxed while variables corresponding to early periods are fixed incrementally. They work on a slightly different problem in which the bottom of the pit must contain at least two adjacent blocks, and report improvements in the execution time with respect to standard solvers. A recent work of Lambert and Newman (2014) employs a tailored Lagrangian relaxation, which uses information obtained while generating the initial solution to select a dualization scheme for the resource constraints. They report solutions for models having up to 25,000 blocks and 10 time-periods at 36,000 seconds, with an optimality gap of 6 percent in the largest case.

Another approach to tackle large-scale problems is based on aggregation procedures. Dagdelen and Johnson (1986), Dagdelen and Akaike (1999) and Ramazan, Dagdelen, and Johnson (2005) work on a model with fixed cut-off grades, upper and lower bounds for blending, but only upper bounds for the capacity. They aggregate blocks into what they call fundamental trees (subsets that have positive value, respect slope constraints and are minimal in some sense) and present a relatively small case study (less than 15,000 blocks). Boland, Dumitrescu, Froyland, and Gleixner (2009) propose a different procedure, in which they aggregate blocks into what they call bins. The extraction of individual blocks is controlled with continuous variables, but binary variables are used at the bin level to impose slope constraints. They are able to solve instances of about 100,000 blocks.

Approaches not based in linear programming include genetic algorithms and tabu search. Zhang (2006) uses Genetic algorithm combined with a block aggregation technique based on topological sort to reduce of number of variables in the model. The method simultaneously determines an ultimate pit and an optimal block extraction schedule that maximizes the net present value by specifying whether a block should be extracted and where it should be sent (waste dump or processing plant), subject to a number of constraints including maximum wall slope, as well as mining and processing capacities. By this approach, Zhang concludes that the computational time can be effectively reduced without compromising optimality. The method was implemented and tested against BHP-Billiton’s existing industrial benchmark achieved by the commercial optimizer ILOG CPLEX (CPLEX, 2013). According to Amankwah (2011), the nature of the constraints poses a major difficulty in the use of genetic algorithms to solve the mine planning problem. Newman, Rubio, Caro, Weintraub, and Eurek (2010) point out that Zhang does not assess the practical consequences of aggregation and does not provide a disaggregation procedure. In turn, Tabesh and Askari-Nasab (2011) propose an algorithm that aggregates blocks into mining units and uses tabu search to calibrate the number of final units. The resulting problem is then solved using standard integer programming algorithms. The aggregation technique is interesting, because it is based on a similarity index that considers attributes like rock type, ore grades and the distance between the blocks. The tabu search procedure is then used to further aggregate the blocks, while trying to balance the resulting loss of selectivity. The procedure is tested on 5 different instances (with up to 20,000 blocks), which show a variety of results where improvements in the objective function value (NPV) and computational time are not completely consistent. The authors indicate that further research is required.

A completely different approach, suggested by Matheron (1975), uses continuous models to describe the problem. The pits are described by profiles, which are functions that determine the current surface of the pit. Block attributes are modeled as density functions, whose integrals have to be either maximized or kept within certain ranges. This approach was followed by Alvarez, Amaya, Griewank, and Strogies (2011), showing existence of solutions under some hypotheses on the mass density function.

Additional reviews of operations research in mining can be found in Osanloo, Gholamnejad, and Karimi (2008) for models and algorithms and Newman et al. (2010) for mining in general.

We consider a set 
                        B
                      of blocks and set 
                        
                           N
                           =
                           |
                           B
                           |
                        
                     . We denote the blocks with indices 
                        
                           i
                           ,
                           j
                           ∈
                           B
                           ,
                        
                      unless otherwise stated. Similarly, we consider 
                        
                           T
                           ∈
                           N
                        
                      time-periods and denote individual time-periods with 
                        
                           s
                           ,
                           t
                           =
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           T
                        
                     . The number T is called the time horizon. The set of time-periods is denoted by 
                        
                           T
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           T
                           }
                        
                     .

Slope (precedence) constraints are encoded as a set of arcs
                     
                        
                           A
                           ⊂
                           B
                           ×
                           B
                        
                     : 
                        
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                        
                      means that block j has to be extracted before block i. We say, in this case, that block j is a predecessor of block i, which is a successor of j. Notice that arc (i, j) goes from the successor to the predecessor.

In this work we address a simplified version of the problem in which the decision of the destination of the block is done beforehand. Therefore, the net profit (which can be negative) of processing block i is already known and noted as 
                        
                           
                              v
                              i
                           
                           ∈
                           R
                        
                     . The discounted net profit of processing block i at time-period t is 
                        
                           
                              ρ
                              t
                           
                           
                              v
                              i
                           
                           ∈
                           R
                           ,
                        
                      with discount factor 
                        
                           ρ
                           =
                           
                              1
                              
                                 1
                                 +
                                 d
                                 r
                              
                           
                           ,
                        
                      where dr represents the discount rate. We define a set of resources 
                        
                           R
                           ,
                        
                      and 
                        
                           a
                           (
                           i
                           ,
                           r
                           )
                           ∈
                           R
                        
                      as the quantity of resource 
                        
                           r
                           ∈
                           R
                        
                      used when block 
                        
                           i
                           ∈
                           B
                        
                      is processed. For each time-period t, lower and upper bounds on the consumption of resource r is given by the quantities 
                        
                           
                              C
                              
                                 r
                                 t
                              
                              −
                           
                           ∈
                           
                              {
                              −
                              ∞
                              }
                           
                           ∪
                           R
                        
                      and 
                        
                           
                              C
                              
                                 r
                                 t
                              
                              +
                           
                           ∈
                           
                              {
                              +
                              ∞
                              }
                           
                           ∪
                           R
                           ,
                        
                      respectively.

Each block is processed in the same time-period in which it is extracted from the mine (that is, we do not allow to stock material for future processing). As usual in these models, we assume that extraction, handling and processing of a block is done within a time-period length. While the modeling can be easily extended to the general case, the heuristics presented in this article do not always work in the case in which blending constraints apply, therefore, we assume there are no such constraints. Table 1
                      summarizes the notation.

A block scheduling is a function 
                        
                           τ
                           :
                           B
                           →
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           T
                           ,
                           ∞
                           }
                        
                      where τ(i) is the time-period in which block i is extracted, hence, a block scheduling must satisfy the precedence constraints, that is, if 
                        
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                        
                      then τ(i) ≥ τ(j). If τ is a block scheduling then the sets 
                        
                           
                              P
                              1
                           
                           =
                           
                              τ
                              
                                 −
                                 1
                              
                           
                           
                              (
                              1
                              )
                           
                        
                      and 
                        
                           
                              P
                              t
                           
                           =
                           
                              P
                              
                                 t
                                 −
                                 1
                              
                           
                           ∪
                           
                              τ
                              
                                 −
                                 1
                              
                           
                           
                              (
                              t
                              )
                           
                        
                      for t > 1 are called pits. We observe that 
                        
                           
                              P
                              t
                           
                           ⊂
                           
                              P
                              
                                 t
                                 +
                                 1
                              
                           
                        
                      and say that the pits are nested.

The open-pit block scheduling problem is defined on the following variables. For each 
                        
                           i
                           ∈
                           B
                           ,
                           t
                           ∈
                           T
                        
                     :

                        
                           
                              
                                 
                                    x
                                    
                                       i
                                       t
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             1
                                          
                                          
                                             
                                                
                                                   if
                                                   
                                                   block
                                                
                                                
                                                i
                                                
                                                is
                                                
                                                extracted
                                                
                                                by
                                                
                                                time-period
                                                
                                                t
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

The interpretation of variable xit
                      is by time-period, that is 
                        
                           
                              x
                              
                                 i
                                 t
                              
                           
                           =
                           1
                        
                      if and only if block i has been extracted (and processed) at some period s with 1 ≤ s ≤ t. It is useful to introduce the following auxiliary variables for 
                        
                           i
                           ∈
                           B
                        
                     : 
                        
                           Δ
                           
                              x
                              
                                 i
                                 1
                              
                           
                           =
                           
                              x
                              
                                 i
                                 1
                              
                           
                           ,
                        
                      and 
                        
                           Δ
                           
                              x
                              
                                 i
                                 t
                              
                           
                           =
                           
                              x
                              
                                 i
                                 t
                              
                           
                           −
                           
                              x
                              
                                 i
                                 ,
                                 t
                                 −
                                 1
                              
                           
                        
                      for 
                        
                           t
                           =
                           2
                           ,
                           3
                           ,
                           …
                           ,
                           T
                        
                     . We have 
                        
                           
                              x
                              
                                 i
                                 t
                              
                           
                           =
                           
                              ∑
                              
                                 s
                                 =
                                 1
                              
                              t
                           
                           Δ
                           
                              x
                              
                                 i
                                 s
                              
                           
                        
                      and 
                        
                           Δ
                           
                              x
                              
                                 i
                                 t
                              
                           
                           =
                           1
                        
                      if, and only if, block i is extracted exactly at time-period t.

The mathematical program we address is the following:

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          
                                             (
                                             OPBSP
                                             )
                                          
                                          max
                                          
                                             ∑
                                             
                                                t
                                                =
                                                1
                                             
                                             T
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             N
                                          
                                          
                                             ρ
                                             t
                                          
                                          
                                             v
                                             i
                                          
                                          Δ
                                          
                                             x
                                             
                                                i
                                                t
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                    
                                    
                                       
                                          ≤
                                          
                                             x
                                             
                                                j
                                                t
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          (
                                          ∀
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          ∈
                                          A
                                          )
                                          (
                                          ∀
                                          t
                                          ∈
                                          T
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          Δ
                                          
                                             x
                                             
                                                i
                                                t
                                             
                                          
                                       
                                    
                                    
                                       
                                          ≥
                                          0
                                       
                                    
                                    
                                       
                                          
                                          (
                                          ∀
                                          i
                                          ∈
                                          B
                                          )
                                          (
                                          ∀
                                          t
                                          ∈
                                          T
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                B
                                             
                                          
                                          a
                                          
                                             (
                                             i
                                             ,
                                             r
                                             )
                                          
                                          Δ
                                          
                                             x
                                             
                                                i
                                                t
                                             
                                          
                                       
                                    
                                    
                                       
                                          ≤
                                          
                                             C
                                             
                                                r
                                                t
                                             
                                             +
                                          
                                       
                                    
                                    
                                       
                                          
                                          (
                                          ∀
                                          r
                                          ∈
                                          R
                                          )
                                          (
                                          ∀
                                          t
                                          ∈
                                          T
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                B
                                             
                                          
                                          a
                                          
                                             (
                                             i
                                             ,
                                             r
                                             )
                                          
                                          Δ
                                          
                                             x
                                             
                                                i
                                                t
                                             
                                          
                                       
                                    
                                    
                                       
                                          ≥
                                          
                                             C
                                             
                                                r
                                                t
                                             
                                             −
                                          
                                       
                                    
                                    
                                       
                                          
                                          (
                                          ∀
                                          r
                                          ∈
                                          R
                                          )
                                          (
                                          t
                                          ∈
                                          T
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                    
                                    
                                       
                                          ∈
                                          {
                                          0
                                          ,
                                          1
                                          }
                                       
                                    
                                    
                                       
                                          
                                          (
                                          ∀
                                          i
                                          ∈
                                          B
                                          )
                                          (
                                          ∀
                                          t
                                          ∈
                                          T
                                          )
                                       
                                    
                                 
                              
                           
                        
                     
                  

Expression (1) presents the objective function, which is the discounted value of extracted blocks over the time horizon T. In turn, (2) corresponds to the precedence constraints given by the slope angle and (3) means that blocks can be extracted only once. Moreover, (4) and (5) state the maximum and minimum resource consumption in each time-period, respectively. Finally, (6) states that all the variables assume binary values.

For a block model 
                        
                           B
                           ,
                        
                      precedence arcs 
                        
                           A
                           ,
                        
                      block values 
                        
                           V
                           =
                           
                              
                                 (
                                 
                                    v
                                    i
                                 
                                 )
                              
                              
                                 i
                                 ∈
                                 B
                              
                           
                        
                      and attribute matrix 
                        
                           A
                           =
                           
                              
                                 (
                                 a
                                 
                                    (
                                    i
                                    ,
                                    r
                                    )
                                 
                                 )
                              
                              
                                 i
                                 ∈
                                 B
                                 ,
                                 r
                                 ∈
                                 R
                              
                           
                           ,
                        
                      we will use the notation 
                        
                           OPBSP
                           (
                           B
                           ,
                           A
                           ,
                           V
                           ,
                           A
                           ,
                           T
                           ,
                           ρ
                           ,
                           
                              C
                              +
                           
                           ,
                           
                              C
                              −
                           
                           )
                        
                      to denote an instance of the open-pit block scheduling problem for a certain time horizon T, discount factor ρ, and resource limit matrices 
                        
                           
                              C
                              +
                           
                           =
                           
                              
                                 (
                                 
                                    C
                                    
                                       r
                                       ,
                                       t
                                    
                                    +
                                 
                                 )
                              
                              
                                 r
                                 ∈
                                 R
                                 ,
                                 t
                                 ∈
                                 T
                              
                           
                        
                      and 
                        
                           
                              C
                              −
                           
                           =
                           
                              
                                 (
                                 
                                    C
                                    
                                       r
                                       ,
                                       t
                                    
                                    −
                                 
                                 )
                              
                              
                                 r
                                 ∈
                                 R
                                 ,
                                 t
                                 ∈
                                 T
                              
                           
                        
                     . We will omit some of the parameters if they are clear from the context.

It is important to emphasize that we present the model with lower bounds on operational resource capacities (5) to keep the model consistent with CPIT. However, all of the instances published in MineLib have these bounds equal to zero.

We present now the Block Aggregation Algorithm to approximately solve the open-pit block scheduling problem, when the original instance of 
                        OPBSP
                      cannot be solved directly.

The procedure first aggregates blocks, then it solves incrementally the aggregated problem (using integer programming techniques) and finally, it produces feasible solutions for the original instance. The algorithm has two stages: a forward stage, where the procedure tries to solve the problem using a simplified block model (obtained by the reblocking procedure described in Section 4.1.2); and a backward stage, in which the solution from the forward stage is used to fix some variables in the original problem. Fig. 1
                      outlines the procedure.

Although block aggregation appears to be simple, the reverse step (the forming of a block scheduling for the original disaggregated model) is not so straightforward. In fact, it is challenging in terms of implementation.

The goal of the forward stage is to reduce the number of variables by means of block aggregation. The stage can be described as follows:

                           
                              0.
                              Set 
                                    
                                       currentInstance
                                       ←
                                       (
                                       B
                                       ,
                                       A
                                       ,
                                       V
                                       ,
                                       A
                                       ,
                                       T
                                       ,
                                       ρ
                                       ,
                                       
                                          C
                                          +
                                       
                                       ,
                                       
                                          C
                                          −
                                       
                                       )
                                    
                                 
                              


                                 SOLVE
                                 
                                    
                                       OPBSP
                                       (
                                       currentInstance
                                       )
                                    
                                 . (See Section 4.1.1)


                                 If step 1 found a feasible solution, then go to backward stage
(see Section 4.2).


                                 else REBLOCK (see Section 4.1.2) to produce a new instance

                                    
                                       
                                          
                                             currentInstance
                                             ←
                                             (
                                             
                                                B
                                                R
                                             
                                             ,
                                             
                                                A
                                                R
                                             
                                             ,
                                             V
                                             
                                                (
                                                
                                                   B
                                                   R
                                                
                                                )
                                             
                                             ,
                                             A
                                             
                                                (
                                                
                                                   B
                                                   R
                                                
                                                )
                                             
                                             ,
                                             T
                                             ,
                                             ρ
                                             ,
                                             
                                                C
                                                +
                                             
                                             ,
                                             
                                                C
                                                −
                                             
                                             )
                                             .
                                          
                                       
                                    
                                 and go to step 1.

This recursive procedure is very flexible: it can use any subroutine to SOLVE the instance of the problem in step 1, and to REBLOCK the model in step 3. In the following, we will describe the procedures used in our case studies (Section 5) which proved to be very effective.

The standard approach of solving directly the IP formulation is highly unpractical for large-scale problems. Since the number of blocks is considerably larger than the number of periods, a reduction in the number of time-periods can have a great impact in reducing the overall number of variables and constraints. We propose the following:


                           Incremental Heuristic
                           (HInc)
                           : This heuristic tries to solve the problem incrementally: it considers only fewer time-periods (which we call sliding time window or just time window). Then, the heuristic solves and removes the scheduled blocks in the current time window. The process is repeated with the remaining blocks and time-periods, adjusting the constraints accordingly and moving the time window until the horizon planning is completed. In order to fix ideas, the simplest approach is to consider the time window as only one time-period and then solve the problem period by period.

More precisely, HInc considers an instance of the open-pit block scheduling problem 
                              
                                 OPBSP
                                 (
                                 B
                                 ,
                                 A
                                 ,
                                 V
                                 ,
                                 A
                                 ,
                                 T
                                 ,
                                 ρ
                                 ,
                                 
                                    C
                                    +
                                 
                                 ,
                                 
                                    C
                                    −
                                 
                                 )
                              
                           . Given 
                              
                                 B
                                 ⊂
                                 B
                                 ,
                              
                            define:

                              
                                 •
                                 
                                    
                                       
                                          A
                                          (
                                          B
                                          )
                                          =
                                          A
                                          ∩
                                          (
                                          B
                                          ×
                                          B
                                          )
                                          ,
                                       
                                    
                                 


                                    
                                       
                                          V
                                          
                                             (
                                             B
                                             )
                                          
                                          =
                                          
                                             
                                                (
                                                
                                                   v
                                                   i
                                                
                                                )
                                             
                                             
                                                i
                                                ∈
                                                B
                                             
                                          
                                          ,
                                       
                                     and


                                    
                                       
                                          A
                                          
                                             (
                                             B
                                             )
                                          
                                          =
                                          
                                             
                                                (
                                                a
                                                
                                                   (
                                                   i
                                                   ,
                                                   r
                                                   )
                                                
                                                )
                                             
                                             
                                                i
                                                ∈
                                                B
                                                ,
                                                r
                                                ∈
                                                R
                                             
                                          
                                       
                                    
                                 

Suppose that 
                              
                                 OPBSP
                                 (
                                 T
                                 )
                              
                            cannot be solved, but 
                              
                                 OPBSP
                                 (
                                 
                                    T
                                    ′
                                 
                                 )
                              
                            can, for T′ < T. For simplicity, we describe the heuristic when 
                              
                                 T
                                 /
                                 
                                    T
                                    ′
                                 
                                 =
                                 n
                                 ∈
                                 N
                              
                           . Thus, let also 
                              
                                 C
                                 k
                                 +
                              
                            and 
                              
                                 C
                                 k
                                 −
                              
                            be the maximum and minimum resource limits for time-periods 
                              
                                 
                                    (
                                    k
                                    −
                                    1
                                    )
                                 
                                 
                                    T
                                    ′
                                 
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 k
                                 
                                    T
                                    ′
                                 
                                 ,
                              
                            with 1 ≤ k ≤ n. The heuristic then works as follows:

                              
                                 1.
                                 Set 
                                       
                                          n
                                          =
                                          T
                                          /
                                          
                                             T
                                             ′
                                          
                                          ,
                                          k
                                          =
                                          1
                                          ,
                                          
                                             P
                                             0
                                          
                                          =
                                          ∅
                                       
                                    .

While k ≤ n:
                                       
                                          (a)
                                          Set 
                                                
                                                   
                                                      B
                                                      k
                                                   
                                                   =
                                                   B
                                                   ∖
                                                   
                                                      P
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                
                                             .

Solve 
                                                
                                                   OPBSP
                                                   (
                                                   
                                                      B
                                                      k
                                                   
                                                   ,
                                                   A
                                                   
                                                      (
                                                      
                                                         B
                                                         k
                                                      
                                                      )
                                                   
                                                   ,
                                                   V
                                                   
                                                      (
                                                      
                                                         B
                                                         k
                                                      
                                                      )
                                                   
                                                   ,
                                                   A
                                                   
                                                      (
                                                      
                                                         B
                                                         k
                                                      
                                                      )
                                                   
                                                   ,
                                                   
                                                      T
                                                      ′
                                                   
                                                   ,
                                                   
                                                      ρ
                                                      ′
                                                   
                                                   ,
                                                   
                                                      C
                                                      k
                                                      +
                                                   
                                                   ,
                                                   
                                                      C
                                                      k
                                                      −
                                                   
                                                   )
                                                
                                             .

Let 
                                                
                                                   
                                                      Γ
                                                      k
                                                   
                                                   =
                                                   
                                                      ⋃
                                                      
                                                         s
                                                         =
                                                         
                                                            (
                                                            k
                                                            −
                                                            1
                                                            )
                                                         
                                                         
                                                            T
                                                            ′
                                                         
                                                         +
                                                         1
                                                      
                                                      
                                                         k
                                                         
                                                            T
                                                            ′
                                                         
                                                      
                                                   
                                                   
                                                      τ
                                                      
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      (
                                                      s
                                                      )
                                                   
                                                
                                              be the set of extracted blocks and set 
                                                
                                                   
                                                      P
                                                      k
                                                   
                                                   =
                                                   
                                                      P
                                                      
                                                         k
                                                         −
                                                         1
                                                      
                                                   
                                                   ∪
                                                   
                                                      Γ
                                                      k
                                                   
                                                
                                             .


                                             
                                                
                                                   k
                                                   ←
                                                   k
                                                   +
                                                   1
                                                
                                             .

Return the block scheduling τ given by 
                                       
                                          τ
                                          
                                             (
                                             i
                                             )
                                          
                                          =
                                          
                                             t
                                             0
                                          
                                       
                                     if 
                                       
                                          i
                                          ∈
                                          
                                             P
                                             
                                                t
                                                0
                                             
                                          
                                       
                                     for some t
                                    0, or 
                                       
                                          τ
                                          =
                                          ∞
                                       
                                     if there is no t such that i ∈ Pt
                                    .


                           Fig. 2
                            illustrates how the block scheduling is generated, with a time-horizon of 
                              
                                 T
                                 =
                                 3
                              
                            and a time window 
                              
                                 
                                    T
                                    ′
                                 
                                 =
                                 1
                              
                           : in the first time-period, the extracted blocks are the set P
                           1. Then these blocks are removed and the procedure is repeated for the second period. During the second period, the extracted blocks correspond to the set P
                           2∖P
                           1. Finally, the process is repeated for the third and last period.

Although this procedure does not necessarily produce optimal results (see Example 1), it can give a significant improvement in practice, as we describe in Section 5.

                              Example 1
                              The small 2-dimensional mine displayed in Fig. 3
                                  is to be exploited in a 5-period time horizon. Each number represents the economic value of the corresponding block. For simplicity we assume that each block has an unit tonnage, the capacity per time-period is also one unit (hence exactly one block can be extracted in each time-period), and there is no discount rate.

We index the blocks by integer coordinates as in a matrix, so the top-left block is identified with coordinates (1, 1) and the bottom-right block has coordinates (2, 4). If the slope angle is 45°, block (x, y) has predecessors 
                                    
                                       (
                                       x
                                       −
                                       1
                                       ,
                                       y
                                       −
                                       1
                                       )
                                       ,
                                       (
                                       x
                                       −
                                       1
                                       ,
                                       y
                                       )
                                    
                                  and 
                                    
                                       (
                                       x
                                       −
                                       1
                                       ,
                                       y
                                       +
                                       1
                                       )
                                    
                                  if 
                                    
                                       x
                                       =
                                       2
                                    
                                  (when such blocks exist) and no predecessors if 
                                    
                                       x
                                       =
                                       1
                                    
                                 .

The optimal scheduling is to extract blocks (1, 1), (1, 2), (1, 3), (1, 4) in any order during the first four periods, and then to extract block (2, 3) at period 5. The corresponding value is 
                                    
                                       NPV
                                       =
                                       1
                                       +
                                       (
                                       −
                                       1
                                       )
                                       +
                                       (
                                       −
                                       1
                                       )
                                       +
                                       (
                                       −
                                       1
                                       )
                                       +
                                       10
                                       =
                                       8
                                    
                                 . However, the incremental heuristic (
                                    
                                       
                                          T
                                          ′
                                       
                                       =
                                       1
                                    
                                 ) will select block (1, 1) at the first iteration, and no blocks afterwards. The value of this solution is 1, which is suboptimal.

In this step, we do not reduce the number of time-periods, but we reduce the number of blocks by aggregating (or reblocking) them into larger units. The motivation comes from the fact that while a block model consists of thousands to millions of blocks, the decision of extracting a specific block at a certain time-period may be too atomic.

We consider a procedure reblock that takes a block model 
                              B
                            and produces a new one, say 
                              
                                 
                                    B
                                    ˜
                                 
                                 ,
                              
                            so that the number of blocks in the new model is small compared to the original block model. The idea is that 
                              
                                 B
                                 ˜
                              
                            keeps certain properties of the original one, then solving OPBSP in 
                              
                                 B
                                 ˜
                              
                            can be used to produce solutions for the original model. This is done using the following:


                           Block aggregation heuristic 
                           (HReb)
                           : Let us introduce some notation first. We consider that 
                              
                                 reblock
                                 :
                                 B
                                 →
                                 
                                    2
                                    B
                                 
                              
                            thus 
                              
                                 I
                                 m
                                 (
                                 reblock
                                 )
                              
                            is a partition of 
                              B
                           . We identify 
                              
                                 I
                                 m
                                 (
                                 reblock
                                 )
                              
                            as a new block model 
                              
                                 
                                    B
                                    R
                                 
                                 ,
                              
                            so that each block in 
                              
                                 B
                                 R
                              
                            has the same set of attributes of the blocks in the original block model. We will use notation iR, jR
                            to refer to elements of 
                              
                                 B
                                 R
                              
                            in order to prevent any confusion with blocks of the original model. Finally, we will also assume that 
                              A
                            is also translated into 
                              
                                 A
                                 R
                              
                            in a “compatible” way that allows us to use a scheduling in 
                              
                                 B
                                 R
                              
                            to construct a scheduling in 
                              B
                            respecting the slope constraints.

Note that 
                              reblock
                            is defined in a very general way. It may depend on geometric arguments (distances between blocks, for example) or block characteristics (lithology and ore grades). In this work, we consider geometric aspects, defining how many blocks 
                              
                                 i
                                 ∈
                                 B
                              
                            are included in each aggregated block 
                              
                                 
                                    i
                                    R
                                 
                                 ∈
                                 
                                    B
                                    R
                                 
                              
                           . Considering that each block is identified by coordinates (x, y, z), each aggregated block 
                              
                                 
                                    i
                                    R
                                 
                                 =
                                 
                                    (
                                    
                                       x
                                       i
                                       R
                                    
                                    ,
                                    
                                       y
                                       i
                                       R
                                    
                                    ,
                                    
                                       z
                                       i
                                       R
                                    
                                    )
                                 
                              
                            will be composed by the nR
                            × nR
                            × nR
                            original blocks with coordinates 
                              
                                 (
                                 
                                    x
                                    i
                                    R
                                 
                                 
                                    n
                                    R
                                 
                                 +
                                 
                                    j
                                    x
                                 
                                 ,
                                 
                                    y
                                    i
                                    R
                                 
                                 
                                    n
                                    R
                                 
                                 +
                                 
                                    j
                                    y
                                 
                                 ,
                                 
                                    z
                                    i
                                    R
                                 
                                 
                                    n
                                    R
                                 
                                 +
                                 
                                    j
                                    z
                                 
                                 )
                                 ,
                              
                            with 
                              
                                 
                                    j
                                    x
                                 
                                 ,
                                 
                                    j
                                    y
                                 
                                 ,
                                 
                                    j
                                    z
                                 
                                 ∈
                                 
                                    {
                                    0
                                    ,
                                    ⋯
                                    ,
                                    
                                       n
                                       R
                                    
                                    −
                                    1
                                    }
                                 
                              
                           . An example (only in 2 dimensions for clarity) can be seen in Fig. 4
                           .

This is the most important part, since it allows us to obtain a scheduling for the original block model starting from the aggregated model solution. We assume that the problem was solved in the forward stage for the instance

                           
                              
                                 
                                    OPBSP
                                    (
                                    
                                       B
                                       R
                                    
                                    ,
                                    
                                       A
                                       R
                                    
                                    ,
                                    V
                                    
                                       (
                                       
                                          B
                                          R
                                       
                                       )
                                    
                                    ,
                                    A
                                    
                                       (
                                       
                                          B
                                          R
                                       
                                       )
                                    
                                    ,
                                    T
                                    ,
                                    ρ
                                    ,
                                    
                                       C
                                       +
                                    
                                    ,
                                    
                                       C
                                       −
                                    
                                    )
                                    ,
                                 
                              
                           
                        so we have a block scheduling τR
                         for the reblocked model and we want to produce a solution for the original instance. This involves the following steps:

                           
                              1.
                              Partition 
                                    
                                       B
                                       R
                                    
                                  into ∂B and 
                                    
                                       B
                                       ˚
                                    
                                  where ∂B is the set of aggregated blocks in the borders, which are those with neighboring blocks extracted at a different time period, and 
                                    
                                       B
                                       ˚
                                    
                                  is the complement.

Fix the extracting period for the original blocks that correspond to elements of 
                                    
                                       
                                          B
                                          ˚
                                       
                                       ⊂
                                       
                                          B
                                          R
                                       
                                       ,
                                    
                                  i.e. the set of blocks such that all direct predecessors and successors are extracted at the same time-period. This is, 
                                    
                                       
                                          i
                                          R
                                       
                                       ∈
                                       
                                          B
                                          ˚
                                       
                                    
                                  if and only if the set of aggregated 
                                    
                                       
                                          i
                                          R
                                       
                                       ∈
                                       
                                          B
                                          R
                                       
                                    
                                  satisfies that
                                    
                                       (a)
                                       
                                          
                                             
                                                ∀
                                                
                                                   (
                                                   
                                                      i
                                                      R
                                                   
                                                   ,
                                                   
                                                      j
                                                      R
                                                   
                                                   )
                                                
                                                ∈
                                                
                                                   A
                                                   R
                                                
                                                ,
                                                
                                                
                                                   τ
                                                   R
                                                
                                                
                                                   (
                                                   
                                                      i
                                                      R
                                                   
                                                   )
                                                
                                                =
                                                
                                                   τ
                                                   R
                                                
                                                
                                                   (
                                                   
                                                      j
                                                      R
                                                   
                                                   )
                                                
                                             
                                          
                                       


                                          
                                             
                                                ∀
                                                
                                                   (
                                                   
                                                      j
                                                      R
                                                   
                                                   ,
                                                   
                                                      i
                                                      R
                                                   
                                                   )
                                                
                                                ∈
                                                
                                                   A
                                                   R
                                                
                                                ,
                                                
                                                
                                                   τ
                                                   R
                                                
                                                
                                                   (
                                                   
                                                      i
                                                      R
                                                   
                                                   )
                                                
                                                =
                                                
                                                   τ
                                                   R
                                                
                                                
                                                   (
                                                   
                                                      j
                                                      R
                                                   
                                                   )
                                                
                                             
                                          .

Then if 
                                    
                                       
                                          i
                                          R
                                       
                                       =
                                       reblock
                                       
                                          (
                                          i
                                          )
                                       
                                       ,
                                    
                                  we will assume that block 
                                    
                                       i
                                       ∈
                                       B
                                    
                                  is extracted at time-period τR
                                 (iR
                                 ).

Add the constraints 
                                    
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                       =
                                       0
                                    
                                  for t < τR
                                 (iR
                                 ) and 
                                    
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                       =
                                       1
                                    
                                  for t ≥ τR
                                 (iR
                                 ), for any 
                                    
                                       i
                                       ∈
                                       B
                                    
                                  such that 
                                    
                                       reblock
                                       
                                          (
                                          i
                                          )
                                       
                                       ∈
                                       
                                          B
                                          ˚
                                       
                                    
                                 .

For the original blocks i that correspond to elements of ∂B, compute the following bounds, considering that 
                                    
                                       
                                          j
                                          R
                                       
                                       =
                                       reblock
                                       
                                          (
                                          j
                                          )
                                       
                                    
                                 :

                                    
                                       (a)
                                       
                                          
                                             
                                                
                                                   t
                                                   −
                                                
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                =
                                                max
                                                
                                                   {
                                                   
                                                      τ
                                                      R
                                                   
                                                   
                                                      (
                                                      
                                                         j
                                                         R
                                                      
                                                      )
                                                   
                                                   :
                                                   
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                   
                                                   ∈
                                                   A
                                                   ,
                                                   
                                                      j
                                                      R
                                                   
                                                   ∈
                                                   ∂
                                                   B
                                                   }
                                                
                                             
                                          
                                       


                                          
                                             
                                                
                                                   t
                                                   +
                                                
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                =
                                                min
                                                
                                                   {
                                                   
                                                      τ
                                                      R
                                                   
                                                   
                                                      (
                                                      
                                                         j
                                                         R
                                                      
                                                      )
                                                   
                                                   :
                                                   
                                                      (
                                                      j
                                                      ,
                                                      i
                                                      )
                                                   
                                                   ∈
                                                   A
                                                   ,
                                                   
                                                      j
                                                      R
                                                   
                                                   ∈
                                                   ∂
                                                   B
                                                   }
                                                
                                             
                                          
                                       

Add the constraints 
                                    
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                       =
                                       0
                                    
                                  for 
                                    
                                       t
                                       <
                                       
                                          t
                                          −
                                       
                                       
                                          (
                                          i
                                          )
                                       
                                    
                                  and 
                                    
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                       =
                                       1
                                    
                                  for 
                                    
                                       t
                                       >
                                       
                                          t
                                          +
                                       
                                       
                                          (
                                          i
                                          )
                                       
                                       ,
                                    
                                  for any 
                                    
                                       i
                                       ∈
                                       B
                                    
                                  such that 
                                    
                                       reblock
                                       (
                                       i
                                       )
                                       ∈
                                       ∂
                                       B
                                    
                                 .

Adjust capacities as:

                                    
                                       (a)
                                       
                                          
                                             
                                                ∂
                                                
                                                   C
                                                   
                                                      r
                                                      t
                                                   
                                                   +
                                                
                                                =
                                                
                                                   C
                                                   
                                                      r
                                                      t
                                                   
                                                   +
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      
                                                         I
                                                         t
                                                      
                                                   
                                                
                                                a
                                                
                                                   (
                                                   i
                                                   ,
                                                   r
                                                   )
                                                
                                                ,
                                             
                                          
                                          
                                             
                                                (
                                                ∀
                                                r
                                                ∈
                                                R
                                                )
                                                (
                                                ∀
                                                t
                                                ∈
                                                T
                                                )
                                                ,
                                             
                                           where 
                                             
                                                
                                                   I
                                                   t
                                                
                                                =
                                                
                                                   {
                                                   i
                                                   ∈
                                                   
                                                      B
                                                      ˚
                                                   
                                                   :
                                                   
                                                      τ
                                                      R
                                                   
                                                   
                                                      (
                                                      
                                                         i
                                                         R
                                                      
                                                      )
                                                   
                                                   =
                                                   t
                                                   }
                                                
                                             
                                          
                                       


                                          
                                             
                                                ∂
                                                
                                                   C
                                                   
                                                      r
                                                      t
                                                   
                                                   −
                                                
                                                =
                                                max
                                                
                                                   {
                                                   
                                                      C
                                                      
                                                         r
                                                         t
                                                      
                                                      −
                                                   
                                                   −
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ∈
                                                         
                                                            I
                                                            t
                                                         
                                                      
                                                   
                                                   a
                                                   
                                                      (
                                                      i
                                                      ,
                                                      r
                                                      )
                                                   
                                                   ,
                                                   0
                                                   }
                                                
                                                ,
                                             
                                          
                                          
                                             
                                                (
                                                ∀
                                                r
                                                ∈
                                                R
                                                )
                                                (
                                                ∀
                                                t
                                                ∈
                                                T
                                                )
                                                ,
                                             
                                           where 
                                             
                                                
                                                   I
                                                   t
                                                
                                                =
                                                
                                                   {
                                                   i
                                                   ∈
                                                   
                                                      B
                                                      ˚
                                                   
                                                   :
                                                   
                                                      τ
                                                      R
                                                   
                                                   
                                                      (
                                                      
                                                         i
                                                         R
                                                      
                                                      )
                                                   
                                                   =
                                                   t
                                                   }
                                                
                                             
                                          
                                       

Solve 
                                    
                                       OPBSP
                                       (
                                       B
                                       ,
                                       A
                                       ,
                                       V
                                       ,
                                       A
                                       ,
                                       T
                                       ,
                                       ρ
                                       ,
                                       ∂
                                       
                                          C
                                          +
                                       
                                       ,
                                       ∂
                                       
                                          C
                                          −
                                       
                                       )
                                    
                                  under the additional constraints.

It is important to note that the heuristic proposed is myopic. Thus, it cannot guarantee that a feasible solution will be found, if exists. If an auxiliary problem becomes infeasible in the backward stage, it will be necessary to extend T′ in order to try to find feasibility.

In this section we discuss some specific details regarding the implementation of the Block Aggregation Algorithm introduced in Section 4. We also present the best known results obtained for the reference dataset MineLib. The idea is to illustrate how the different heuristics scale when the size and number of blocks change. We will see that a relevant feature of this approach is the ability to solve large problems.

In order to implement the different algorithms, we used the MineLink library developed at Delphos Mine Planning Laboratory at Universidad de Chile (Delphos, 2013), which implements data structures to store the block model, precedence arcs and reblocking routines. The library is written in C++, but there also exists a wrapper to use it from Python, a general-purpose free available scripting language, version 2.7. Within this library, the BOS2
                        ® module implements the mathematical model and the heuristics described earlier. The module uses the GUROBI
                        ® (Gurobi Optimization Inc., 2013) version 5.6.3 for mixed integer linear optimization. Execution of the code was done on an Intel Core i5-3570 machine with 16 gigabyte running Ubuntu version 12.10. This machine has 4 processors that run at 3.40 gigahertz.

The case studies were obtained from MineLib, a library of publicly available test problem instances for open-pit mining. The dataset can be found at http://mansci-web.uai.cl/minelib/. These instances come from real-world mining projects and simulated data. For each instance, the database contains the block model, precedence relations, additional constraints and parameters needed to formulate the optimization problem. A description of the instances (time-horizon, number of blocks, precedence arcs, variables and constraints) can be found in Table 2
                        . For more details on MineLib see Espinoza et al. (2013).

We compare against pre-existing solutions for these instances that have been published in Espinoza et al. (2013) and Lamghari et al. (2014).

We briefly describe the algorithms involved in these two references.

In Espinoza et al. (2013), the results were obtained by creating a rank of blocks, constructing a block-by-block sequence and then following this sequence up to saturate the capacities per period as follows:

                           
                              1.
                              Firstly, a solution 
                                    x
                                  to the integrality relaxation of the problem is obtained.

For each (possibly partially) extracted block, one computes 
                                    
                                       Q
                                       
                                          (
                                          i
                                          )
                                       
                                       =
                                       
                                          ∑
                                          
                                             t
                                             =
                                             1
                                          
                                          T
                                       
                                       t
                                       Δ
                                       
                                          x
                                          
                                             i
                                             t
                                          
                                       
                                       +
                                       
                                          (
                                          T
                                          +
                                          1
                                          )
                                       
                                       
                                          (
                                          1
                                          −
                                          
                                             x
                                             
                                                i
                                                T
                                             
                                          
                                          )
                                       
                                    
                                 . The values Q(i) can be interpreted as expected times of extraction.

A block-by-block sequence is produced by extracting the blocks from the surface in increasing values of Q(i) while respecting the precedence constraints.

Finally, the block sequence is used to construct a block schedule by filling each time period with blocks as long as the capacity constraints allow it.

In Lamghari et al. (2014), they present two ideas. A method to produce an initial solution, and a method to improve this solution based on a type of local search algorithm called Variable Neighborhood Descent(VND) introduced in Hansen and Mladenović (2001) to approach what they call the Mine Production Scheduling Problem (MPSP), which corresponds to the CPIT, but with no lower bounds for the capacity constraints.

Using the VND method on the solutions provided in MineLib, they are able to improve 4 of the 11 cases. Additional 4 cases are improved by using their method to produce the starting solution and then applying VND.

Finally, notice that an upper bound to the value of any feasible solution of the problem can be obtained by relaxing the integrality constraints of the variables. These upper bounds are reported in Espinoza et al. (2013).

@&#RESULTS@&#

We tested the aggregation heuristic in all of the CPIT instances of MineLib. In all of them, the problem was solved using one forward stage and its corresponding backward stage. Table 3
                         shows the instances obtained in the forward and backward stages.

For all of the instances, forward stage was implemented using HInc and HReb. HInc was set to start with a sliding time window 
                           
                              
                                 T
                                 ′
                              
                              =
                              1
                           
                         period (see Section 4.1.1). If no feasible solution was found, the sliding window was increased in one period until a feasible solution was achieved. The reblocking was implemented with HReb as described in Section 4.1.2. The backward stage was implemented as explained in Section 4.2.

Finally, the complete procedure will be denoted as HInc+HReb.


                        Table 4
                         shows the results for the MineLib instances. For each case we report:

                           
                              1.
                              
                                 LP upper bound value, obtained by relaxing the integrality constraints on the variables, as reported in Espinoza et al. (2013). This is used to compute the GAPs of the feasible solutions.


                                 Source, indicating the paper in which the current best solution was reported: “LDF14” corresponds to Lamghari et al. (2014) and “EGMN13” to Espinoza et al. (2013).


                                 GAP, the integrality GAP between the currently best known solution and the LP upper bound.


                                 Value, the value of the solution obtained using our heuristic.


                                 GAP, the integrality GAP between the solution obtained by the heuristic and the LP upper bound.


                                 Time, the solution time of the heuristic. The time reported is the real time (also known as wall-clock time) and it includes all the pre-processing steps (precedence computations, Final-Pit when needed).

The MineLib instances for the CPIT problem do not have lower bounds on the operational resource constraints (they are equal to zero and the coefficients of these constraints are positive). Then, it is possible to apply a pre-processing, using a well known result such that any block schedule will be inside the final pit outline (Caccetta & Hill, 2003). Indeed, most of the instances in MineLib are already solutions for the Final Pit. For the remaining instances (Marvin, SM2, W23 and McLaughlin), the pre-processing considered first to solve the Final Pit problem. Then, only the blocks in the final pit were given as the input for the heuristics. Thus, the problem size was considerably reduced.

@&#DISCUSSION@&#

The aggregation heuristic HInc+HReb was able to find feasible solutions for all of the problems in the MineLib dataset. Even more, our heuristic obtained the best known feasible solutions in all of the instances, except for two instances (P4HD and SM2). Still, in both cases our heuristic reported solutions with GAP of at most 0.2 percent.


                        MineLib does not provide information about block size and precedence type for the instances Zuck small, Zuck medium and Zuck large. Thus, it was difficult to find out the right precedence model for the aggregated instances (However, the feasibility of the solution was verified with respect to the original precedence relationships). This explains in part why the forward stage was not as effective as expected compared to all the remaining instances: the problem size was not reduced as expected. For example, in Zuck medium, the number of blocks in the backward stage is still 99 percent with respect to the original number of blocks. This explains that the relative gap is the highest of the instances considered.

Apart from Zuck small, Zuck medium and Zuck large (block size and precedences are not clear), the forward stage considerably reduced the size of the problem. For example, in KD, the backward stage has 26 percent fewer blocks and 32 percent fewer constraints than the original problem. Even more, in 3 out of 4 of the instances pre-solved with Final-Pit (Marvin, SM2 and McLaughlin), the reduction in size was more than 80 percent (variables and constraints in the backward stage compared to the original problem). In the remaining instance, W23, the reduction was around 23 percent.

Due to the successful reduction in the size of the problem, the problem was solved in a reasonable time. Except Zuck medium, which needed less than 5 hours, all of the instances were solved in less than 30 minutes wall-clock time. (see hardware specifications in Section 5.1.)

We have presented a number of heuristics to tackle the open-pit block scheduling problem. Our approach is based mainly on the reduction of the problem to be solved, that is, the size of the binary linear formulation.

The heuristics were applied to MineLib, a library of publicly available test problem instances. For nine of the eleven instances in the library, the gap obtained between the solution reported by our heuristic and the linear relaxation was lower than the gap currently known in the literature. While other references do not provide execution times for comparison, we consider that our running times are reasonable for application purposes. Further on, these can be improved for example by trying different levels of aggregation simultaneously on several computers, therefore reducing forward stage running time.

Furthermore, we believe that the approach described is very scalable in terms of problem size. Moreover, our approach is compatible with other algorithms described in the literature, so it can be easily combined to benefit other approaches, as well as extensions of the heuristics.

Regarding the combination with other approaches, the most promising is the one presented in Chicoisne et al. (2012): an HReb+CMA (Critical Multiplier Algorithm). This approach seems interesting, because it is not difficult to implement. Another approach, more difficult to code because of solver limitations, is the Bienstock and Zuckerberg (2010) algorithm within the branching procedure.

There are also several possible extensions. One could be using more than one time-period at each iteration of the incremental heuristic. Another is to introduce information about the future when producing incremental solutions. For example using Lagrangian relaxation like in Cullenbine et al. (2011) or Lambert and Newman (2014).

@&#ACKNOWLEDGMENTS@&#

Partly supported by FONDECYT Grant 1140829, Basal Project PFB03 CMM Universidad de Chile, Basal Project FB0809 AMTC Universidad de Chile, Millenium Nucleus ICM/FIC RC130003, Anillo Project ACT-1106, ECOS Grant C13E03, STIC AmSud Project OVIMINE and MATH Amsud Project 15MATH-02. Part of this research was carried out while P. Reyes was visiting AMTC.

@&#REFERENCES@&#

