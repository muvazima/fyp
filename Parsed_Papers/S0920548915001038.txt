@&#MAIN-TITLE@&#Recursive and ad hoc routing based localization in wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Ad hoc routing is investigated in this paper.


                        
                        
                           
                           Recursion based localization is considered over wireless networks.


                        
                        
                           
                           DV-hop, DV-distance and recursive position estimation (RPE) algorithms are compared.


                        
                        
                           
                           This paper investigates density, position error and reference point numbers.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Ad hoc network

WSN

OLSR protocol

DV-hop

DV-distance

@&#ABSTRACT@&#


               
               
                  We consider wireless nodes connected in an ad hoc network where recursion based localization is available and ad hoc routing is deployed. We are interested in studying the possibility to use ad hoc routing to help a mobile (sensor) node in a dense/sparse wireless network to estimate its position by first finding the closest two or three ad hoc reference nodes that are already known their positions then use the position value of the found reference nodes and add the estimated distance using the hop counts of the ad hoc routing to find the estimated position. Our protocol will control which are the nodes that will have to calculate their position using the recursive approach in order to serve as reference points to other nodes in the network. Our proposed algorithm basically includes the improved version of the OLSR protocol mostly about the MPR decision and utilization topics by introducing supplemental selection criteria which are also significant for the localization process. Besides, the first part of the localization is performed with this modified version but at the continuation part, two schemas are used: DV-hop and DV-distance. These two schemas are used in two ways, after finding three anchors to find the position of the related node and if three of the anchors could not be collected then in case of finding anchors. Furthermore, the localized node whose position is detected also assigned as an anchor node in the network. Additionally, we compare our schemas with a recursive position estimation (RPE) algorithm about density, position error and reference point numbers. And t-test is performed in our study for the reference points–densities with p-value of 0.05.
               
            

@&#INTRODUCTION@&#

Development in wireless communication technology leads Wireless Sensor Networks (WSNs) to be more accessible for many applications. Meanwhile, localization is an important aspect in WSNs, especially in routing protocol design. For some applications, the localization of a sensor that collects data is as notable as the data itself. In this case, the data must be gathered together with its location information. For this reason, the sensor node should know its own place to be able to determine the exact place of the recovered data. Battlegrounds and catastrophic areas are the most considerable examples of localization needing environments. To be able to examine and monitor an area for different aims, initially, sensors should be positioned. In WSNs, the sensors are positioned in two ways, manually or randomly. In manual sensor node localization, the sensor positions are exactly known. But at the scarped and wild environments, it is difficult to place and measure a sensor manually. Similarly, if a sensor node incorporates global positioning system (GPS) receivers, its exact position is also known but GPS nodes cannot detect and give optimum results in some situations like indoor areas and urban places also these sensors need costly equipments. Therefore, vast networks that contain thousands of nodes, prefer a definite number of nodes to be equipped with GPS. In this case, it is preferred to place sensors as randomly scattering over the related area, thus, areas which are difficult to be reached, can be accessed and discovered easily. The localization procedure's basic steps are; firstly, finding the distance between the unknown node and other (2 or 3 discovered/anchor) nodes. Then, computing the exact coordinates of the unknown node by using these discovered distances. During this procedure, the nodes do not try to discover their location by themselves. In the network, some of the nodes already have their own location information, these nodes are known as anchor nodes and they are used by unknown nodes to discover their positions. In WSNs, information flows occur in a hop by hop manner, thus the distance computation between the unknown node and the anchor is a remarkable problem. For this reason, to accomplish these steps WSN algorithms and protocols that are suitable for multihop network structure should be used [1,2].

One-hop approach is used in WSNs for solving localization problem. In WSNs, nodes with GPS receivers, cooperate with satellites in a one-hop manner. Owing to the high cost of GPS equipments, only some of the nodes, named as anchor nodes are equipped with GPS receivers. The anchor nodes know their locations and they are used to help other ‘unknown’ nodes to find their locations. To design a low cost network, anchors are scattered as seldom in an area. By using one-hop away anchors, effective distance estimation results may not be calculated or with the seldomly scattered anchors, the unknown nodes may not find enough number of anchors between their one-hop neighbors. Therefore, localization with multi-hop attracts great attention recently. Finding distances between anchors and the unknown node that are multiple-hops away from each other is one of the most active research topics in the literature [3].

In this context, researchers focus on most popular and rapidly developing wireless technologies; Wireless Local Area Network (WLAN), Cellular networks, Radio Frequency Identification (RFID) and Wireless Sensor/Actuator Network (WSAN) and they explore potential interactions among them in order to enhance the performance of the indoor localization and mobility management tasks, because both of them will have importance in the future ubiquitous environments. Outdoor positioning systems have proven their potential in the wide range of commercial applications, but to provide successful indoor localization systems more time will be needed, because of the harsh indoor characteristics and requirement for higher accuracy. Also, mobility management in the future heterogeneous wireless networks is much more challenging than in traditional homogeneous networks [4].

In addition to environmental and military applications, mobility in WSNs and localization gain great attention in many areas as in commercial and civil areas. In commercial areas, service robots are designed for nursing at home, providing security at buildings or offices and also servicing in hotels and restaurants for helping community. The main part of the software design of these robots is the localization of their position permanently. Also there are many robot applications for housekeeping for instance, vacuum cleaner robot forms a map of the room with the help of the sensors to be able to traverse the whole room. In civil usage area, there are pothole detectors for streets which are mounted on cars. And as another example, there is a wireless E91 which is the advanced 911 emergency service, when the service is called, the position of the caller is determined with different localization techniques [5–8].

In the literature, localization algorithms are proposed with many titles like centralized/distributed, one hop/multihop and range based/range free methods. Most familiar of them are multihop, DV-hop and DV-distance methods. In DV-hop method, the number of hops are found between all of the nodes and anchors in the network because it is a hop-by-hop method for localization. The nodes share their tables' information with their neighbors. When an anchor receives information from another anchor, it can estimate the correction value which is one hop average distance. The correction value is used by the nodes to find their distances with the anchors. The other well known algorithm is DV-distance. In DV-distance algorithm, estimated ranges between neighbors are used for finding the distance between the node and an anchor. By using these estimated ranges, the node may estimate the Euclidean distance to a farther anchor in the multihop structure. DV-distance method produces better results with the increasing number of nodes in the network. Eventually, in the DV-distance method, the radio signal strength is used to discover the distances between neighbor nodes for more delicate results than DV-hop method [9]. In single hop, the nodes find their positions by directly corresponding with anchor nodes between their neighbors. RADAR, Cricket and SpotON are the examples of a single hop localization technique [10–12].

Furthermore, mobile ad-hoc protocols are examined under three categories: proactive, reactive and hybrid. In proactive routing protocols, the changing topology should cope with permanently varying already known routes and in addition to known routes, new routes are found and updated. Because of these updates, bandwidth is wasted. The well known proactive routing protocols are Optimized Link-State Routing (OLSR) and Destination Sequenced Distance Vector (DSDV). In our study we utilized the OLSR protocol. In the OLSR, in addition to the basic proactive routing protocol structure, its most remarkable diversity is about its topology construction and message flow usage. For instance, for update procedure of topology, periodic messages are sent to definite neighbors in the network instead of sending to the whole neighbors around [13–16].

The rest of the paper is organized as follows. In Section 2, the utilized localization techniques are given. In Section 3, constructed system architecture is presented together with the examined and developed protocol structure. In Section 4, we detailed our study with the proposed algorithm. Section 5, includes our performance evaluation with presented solutions. Eventually, in the last section, the conclusion with final remarks is given.

In localization with connectivity based DV-hop, initially distance is estimated then by the help of the estimated distances, location is estimated. Distance estimation of a sensor node to every anchor is performed over a multi-hop connection. Next, by the multilateration technique, the sensor node decides its location by using estimated multihop distances. The multi-hop distance estimation of anchors and the sensor node is provided by multiplication of the minimum hop count and the average hop distance [17].

To collect the minimum hop count between anchor nodes and sensor nodes, the data that includes anchor nodes' position information is broadcasted with controlled flooding to the sensor nodes. So, the sensor node gathers the coordinates of each anchor node together with a variable that implies the number of hops from the broadcasting anchor to the arriving sensor node.

The gathered hop count data is stored by the sensor node and exchanged in between the neighbors of sensor nodes as position messages. Thus, with the position message, an anchor node estimates the average distance for a single hop. The average distance is computed as follows.
                           
                              (1)
                              
                                 AvgDistanc
                                 
                                    e
                                    i
                                 
                                 
                                 =
                                 
                                 
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                             ,
                                             j
                                             ≠
                                             i
                                          
                                          M
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            x
                                                            i
                                                         
                                                         
                                                         −
                                                         
                                                         
                                                            x
                                                            j
                                                         
                                                      
                                                   
                                                   2
                                                
                                                +
                                                
                                                
                                                   
                                                      
                                                         
                                                            y
                                                            i
                                                         
                                                         
                                                         −
                                                         
                                                         
                                                            y
                                                            j
                                                         
                                                      
                                                   
                                                   2
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                             ,
                                             j
                                             ≠
                                             i
                                          
                                          M
                                       
                                       
                                          
                                             h
                                             
                                                i
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where, (x
                        
                           i
                        ,
                        y
                        
                           i
                        ) and (x
                        
                           j
                        
                        , y
                        
                           j
                        ) are the locations of anchor i and anchor j identifies the number of anchors, hij
                         is the hop count of i and j
                        .
                     

In the network, an anchor node broadcasts its average distance to sensor nodes and other anchor nodes. And the sensor node uses the broadcasted average distance data to compute its estimation distance with the anchor node by multiplying it with the total number of hops for every anchor node using Eq. (2) that is given as
                           
                              (2)
                              
                                 
                                    d
                                    j
                                 
                                 =
                                 AvgDistanc
                                 
                                    e
                                    i
                                 
                                 
                                 ×
                                 
                                 
                                    h
                                    j
                                 
                                 .
                              
                           
                        
                     

Eventually, unknown sensor node's position is computed with triangulation or multilateration equations [18,19]. DV-hop is restricted to the geometric circumstances of anchor nodes, thus it is a kind of an anchor node based localization algorithm [20].

Another well known localization algorithm is DV-distance algorithm. In DV-distance positioning algorithm, anchor nodes broadcast to the whole network their location information that includes the anchor's position, node ID and RSSI. Then with utilizing the RSSI model, the distance from the adjacent nodes is computed by the nodes, thus they count the cumulative distance. Next, a correction factor is computed with the true distance between anchor nodes, when an anchor node receives the cumulative distance to other anchor nodes.

The true distance of anchor i and anchor j is :
                           
                              (3)
                              
                                 dtru
                                 
                                    e
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   i
                                                
                                                −
                                                
                                                   x
                                                   j
                                                
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   y
                                                   i
                                                
                                                −
                                                
                                                   y
                                                   j
                                                
                                             
                                          
                                          2
                                       
                                    
                                 
                              
                           
                        where anchor i is i(x
                        
                           i
                        ,
                        y
                        
                           i
                        ) and anchor j is j(x
                        
                           j
                        ,
                        y
                        
                           j
                        ).
                           
                              (4)
                              
                                 
                                    c
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                 d
                                 c
                                 u
                                 
                                    m
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 −
                                 dtru
                                 
                                    e
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                              
                           
                        where ci,j
                         
                        is the correction factor and dcumi,j
                         is the cumulative distance.

The correction factor is broadcasted by anchor nodes to the network and the unknown node calculates the distance to the anchor nodes. Consequently, with three or more gained distances, the unknown node can compute its location with trilateration [21–23].

The recursive localization based RPE starts with a network which is composed of nodes and most of these nodes do not know their current positions. In RPE, the sensors' geographic positions will be significant. Also, signal strength estimation and timing like inter-node ranging will be probable. RPE is composed of four basic steps. Initially, reference points are stated according to their broadcasted location data, then gained range estimates of them are utilized by the node to estimate its own location. Consequently, the location of the considered node is advertised thus it will be a reference.

At the beginning, the node gathers data about reference points around itself by receiving broadcasts. The data includes reference points' residual values. The node decides its reference points which have the lowest values.
                           
                              (5)
                              
                                 r
                                 =
                                 
                                 
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          reference
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            x
                                                            i
                                                         
                                                         −
                                                         x
                                                      
                                                   
                                                   2
                                                
                                                +
                                                
                                                   
                                                      
                                                         
                                                            y
                                                            i
                                                         
                                                         −
                                                         y
                                                      
                                                   
                                                   2
                                                
                                                +
                                                
                                                   
                                                      
                                                         
                                                            z
                                                            i
                                                         
                                                         −
                                                         z
                                                      
                                                   
                                                   2
                                                
                                             
                                          
                                          −
                                          drange
                                       
                                    
                                    2
                                 
                              
                           
                        Where, r is the residual value of an estimated position (x,
                        y,
                        z) and drange is the measured range of i
                        th reference's position which is (x
                        
                           i
                        , y
                        
                           i
                        ,
                        z
                        
                           i
                        ).
                     

After deciding a definite group of reference points, the node gathers distance estimates of these reference points to be able to estimate its own distance to each of them, so it will estimate its own location. Considered reference point provides the Eq. (6).
                           
                              (6)
                              
                                 d
                                 i
                                 
                                    s
                                    i
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   i
                                                
                                                −
                                                x
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   y
                                                   i
                                                
                                                −
                                                y
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                
                                                   z
                                                   i
                                                
                                                −
                                                z
                                             
                                          
                                          2
                                       
                                    
                                 
                                 
                                 +
                                 
                                    ε
                                    i
                                 
                              
                           
                        
                     

Where 
                           ε
                         
                        is an error term. Consequently, the node becomes a reference point after estimating its own location and it broadcasts the data of its position to help other nodes about determining their own locations [24,25].

We considered a hierarchical and heterogeneous architecture with three levels: anchor nodes such as LTE base stations, or sink nodes always know their positions and also inform the nodes in the network. Reference nodes are mobile ad hoc nodes. These nodes are already calculated their positions and will serve as reference nodes to other nodes that need to calculate their own locations. Besides, the anchor node can also play a role of a reference node. In the network, the mobile (sensor) node is the node that needs to calculate its position. The network will be heterogeneous, some nodes will have at least two network interfaces, for instance LTE, RF. It means that some nodes can have two bands either to send the messages related to the localization protocol or to send the data. These technologies offer more accurate localization than others, so it will be very useful to have the heterogeneity. The nodes will run ad hoc routing, to offer the possibility to extend the network easily.

In our work, we consider 100 nodes in the network. The network is composed of one node away and many hop away reference nodes for the node that wants to find its position. When a node needs to calculate its position, at first, it will try to find reference nodes that are one hop away. But, if it cannot find enough number of reference nodes one hop away from itself then, it will look for multi-hop away reference nodes that will serve it as distant reference nodes. In the case of, where it doesn't find neighbors that have already know their position, then the sensor node use these neighbors that can relay using the OLSR by routing the information of other ad hoc nodes that are multi-hop away from the sensor node. When it finds a distant reference node that is multi-hop away, the estimated distance is studied that is deduced from the used ad hoc routing protocol up to the founded reference node, and compared the position error due to the OLSR routing.

In other words, if the direct neighbor nodes didn't calculate their positions yet, then the idea is to find the closest node that already know its position and use the ad hoc routing to estimate how far is that node from the sensor node that needs to calculate its position. Then to add this estimated distance to the known position of the found node together with using the methods DV-hop and DV-distance. The ad hoc routing is necessary to search the node that knows its position. And the OLSR routing is used to offer the position calculation of the nodes, then the localization process (recursion based) will be completed by offering to estimate distances of nodes that are multi-hop away from the first node that already calculated its position. The reference nodes use a recursion based localization technique to calculate their positions. Our protocol will control the nodes that will have to calculate their positions using the recursive approach in order to serve as reference points to other nodes in the network. We suppose that we have some characteristics of the OLSR routing protocol over our network topology. We have 100 nodes in the area, and it is not necessary that all the 100 nodes will calculate their positions all the time.

The presented architecture and the corresponding structure is a new localization technique using the OLSR [26] together with DV-hop/DV-distance is given at Fig. 1
                     .

Mobile networks have some basic challenges. Most remarkable of them are the sudden topology reconstructions and the need of higher bandwidth. Consequently, most important feature of a routing protocol is its adaptation capability to the topology changes and the ability of covering larger areas with growing diameter which is caused by the node mobility. For providing these features, we considered to use the OLSR protocol because of the protocol's link state nature.

The OLSR is a developed link state and a hop by hop routing protocol of mobile ad hoc networks. The protocol works with a subset of links of its neighbors, that are known as multipoint relay selectors (MRS) and also works with selected nodes in its 1-hop neighborhood, that are known as multipoint relays (MPRs) to retransmit its broadcast messages with minimizing the message retransmissions by preventing the same message sending many times over the network. Therefore, with the OLSR a moving node's packet transmission can be performed, as long as it is followed in its neighborhood [27].

In the basic OLSR structure, as presented in Fig. 2
                     , according to the node x1, the nodes x2, x3, x6, x8 and x10 are the 1st degree neighbors and x4, x5, x7, x9 and x11 are the 2nd degree neighbors. Here, x3 is chosen as MPR because it has more neighbors than others. In the OLSR, every node calculates its routing table and route with the shortest hop path algorithm according to the learned network [28].

In our presented structure, to become a MPR, our priority is to find the 1st degree anchor/reference node between the 1-hop neighbors, if we find a 1st degree anchor/reference node, then it is assigned as a MPR and the anchor is noted. Then we examine the 1-hop neighbors again but this time we consider their 1st degree neighbors, if they have a 1st degree anchor/reference node neighbors then the related 1-hop neighbor is assigned as a MPR and the anchor/reference node is noted which is the considered node x1's 2nd degree neighbor. But, if we can't find an anchor in this way, we assign the most neighbor owning 1-hop neighbor as a MPR as in the basic OLSR. As presented in Fig. 3
                     , according to the method, the selected MPRs are x3, x8 and x10.

We present a simple algorithm for the proposed architecture that considers localization of mobile nodes as in Algorithm 1. Here, the algorithm is triggered when a mobile node wants to find out its position. The algorithm is developed by utilizing the OLSR protocol's basic structure. The neighbor sensing is conducted by combining the recursive anchor search with the idea of a MPR. The algorithm, first tries to find three anchors/reference nodes around the considered node. When it finds the needed number of anchors/reference nodes, the node's position is discovered with DV-hop and DV-distance algorithms. And the node is assigned as a reference node whose position was determined.
                        Algorithm 1
                        
                           
                              
                                 
                              
                           
                        

@&#PERFORMANCE EVALUATION@&#

Consequently, we propose two schemes for the network structure. First scheme is based on DV-hop and second scheme utilizes DV-distance method to compute the positions of the nodes. And to be able to compare the results, RPE algorithm is chosen because of its recursive behavior. In the recursive scheme type RPE [24], to estimate a node's position, three or more reference nodes are used [25]. According to the conditions, our main aim is to utilize only some part of the network not the whole network, that is, with the proposed structure only 20 nodes need to calculate their positions, not all the 100 nodes. A sensor node that needs to calculate its position will try to find 2 or 3 reference nodes out of the 20 nodes that know their positions using the ad hoc routing, and then estimate its position easily. Our proposal is an extension of the hierarchical architecture by using the ad hoc routing up to nodes that don't know their positions yet, besides they are surrounded by nodes that don't know their positions.

The simulations are based on the changes in network density. Basically, the effect of the network density on different properties like reference nodes and position errors is a remarkable topic for improving the network performance. In Fig. 4
                     , we increased the network density till 0.03nodes/m2. By increasing the density, the neighbor number of reference nodes and the sensor nodes (the nodes that need to calculate their position) also increases. Thus, the probability of finding the shortest paths between nodes increased. Also, the probability of finding and being a reference point increased too. By the way, the scheme 1 with DV-hop has the lowest amount of reference points compared with the RPE and scheme 2, at every level of changing network density. But scheme 2 gives better results than both scheme 1 and RPE at reference point rates that have estimated their positions. Furthermore, we conducted t-test and calculated p-values to decide which algorithm's performance is better. We realized that scheme-2's performance is better with 95% confidence at reference point rates.

In Fig. 5
                     , the network density is examined till 0.09nodes/m2 together with the position error of the network. Scheme 1 produces worse results than scheme 2 and RPE in low density rates. During the increase of density rates, scheme 1 gives better results but not as good as scheme 2. According to the collected results, with scheme 2 we gained best results with respect to the RPE method. The proposed schemes give better results at dense networks than sparse networks. The main reason of this fact is about the ability of finding a shortest path. The probability of finding a shortest path decreases in sparse networks while trying to find a neighbor around the reference node.

@&#CONCLUSION@&#

Our work proposes a new localization method for providing accurate position estimation as recursively for mobile nodes that need to find their positions over an ad hoc network. We worked on recursive based localization with ad hoc routing. The OLSR protocol is based on and mostly the MPR decision and utilization owning solutions are considered with giving integrative selection criteria. Afterwards, to estimate the position of the mobile node, we utilized DV-distance and DV-hop schemas. Ultimately, the collected simulation results are compared with the recursively working RPE method. The remarkable advantage of our presented method is gaining an increase in number of reference nodes and a very fast deployment in the network, in this way most of the nodes can compute their locations rapidly and easily.

Also, gained data with simulation analysis were compared by paired t-test to decide if our presented algorithms improve the reference point rates (Table 1
                     ) and minimize position errors. According to t-test, DV-Distance algorithm outperforms the other two algorithms: RPE and DV-Hop.

As a future work, we plan to study the time and the processing resources needed for the recursive location calculation of the network, and compare with our approach where only a subset of nodes need to do the recursive location calculation, and use another ad hoc routing for distance estimation of a node that is multihop away from the first ad hoc reference node available with its location.

@&#REFERENCES@&#

