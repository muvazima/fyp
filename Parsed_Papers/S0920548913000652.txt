@&#MAIN-TITLE@&#Web Service Diagnoser Model for managing faults in web services

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Automated policy generation tool


                        
                        
                           
                           A generic run time fault diagnoser model


                        
                        
                           
                           Monitoring component in service registry


                        
                        
                           
                           Monitoring component in service provider


                        
                        
                           
                           Fault taxonomy for publishing faults, binding faults, discovery faults and execution faults


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Web service faults

Fault diagnoser

Fault diagnosis model

Web service policy

SOAP handler

@&#ABSTRACT@&#


               
               
                  Reliability is an important criterion to facilitate extensive deployment of web service technology for commercial business applications. Run-time monitoring and fault management of web services are essential to ensure uninterrupted and continuous availability of web services. This paper presents WISDOM (Web Service Diagnoser Model) a generic architecture for detecting faults during execution of web services. Policies have been proposed to describe the intended behavior of web services and faulty behavior would be detected as deviations or inconsistencies with respect to the specified behavior. The model proposes the use of monitoring components in service registries and service providers to detect run-time faults during publishing, discovery, binding and execution of web services. An independent fault diagnoser is proposed to coordinate the individual monitoring components and also act as a repository for the specified web service policies. The proposed model has been tested with a sample web service application and the results obtained are presented.
               
            

@&#INTRODUCTION@&#

Web services are self describing, self contained and loosely coupled mechanism for program to program interaction over the Internet [1]. Web service technology is being increasingly used in many commercial applications like online reservation, auction, stock trading and banking. Web services are based on eXtensible Markup Language (XML) standards and are supported by standard protocols like Simple Object Access Protocol (SOAP) for message exchange, Web Services Description Language (WSDL) for interface description and Universal Description Discovery and Integration (UDDI) for service discovery [2,3]. It facilitates the delivery of business applications as web services are accessible to anyone, anytime, at any location and using any platform.

Web Service Management System (WSMS) is a comprehensive framework for managing web service lifecycle which covers the development, deployment, publishing, discovery, composition, monitoring and optimizing access to web services [4]. As web services are being extensively deployed for business applications, the reliability of the services provided becomes an important criterion to enable the usage of such services. Continuous monitoring and fault management of web services are essential to ensure uninterrupted and continuous availability of web services. Traditional fault management tools cannot automatically monitor, analyze, and resolve faults in web services. As web services are distributed in nature, it is hard to trace the flow of transactions when a large number of services, supplier and technologies collaborate together to perform an activity [5]. Thus monitoring of web services becomes more difficult when compared to monitoring a centralized application. Tools, methodologies and techniques need to be specially developed to support and automate the fault management efforts [6].

This paper describes WISDOM (Web Service Diagnoser Model) a generic architecture for monitoring and detecting faults during run-time execution of web services. The rest of the paper is organized as follows. Section 2 discusses the related work and Section 3 presents WISDOM, the proposed architecture for web services run-time fault detection. In Section 4, the implementation and experimental results for a sample web service application are discussed. Section 5 presents the conclusion and future work.

@&#RELATED WORK@&#

Monitoring is used as a verification technique to detect run-time errors. Run-time monitoring has been extensively studied in different areas of computer science, such as distributed systems, requirement engineering, programming languages, and aspect oriented development [7,8]. Beth A. Schroeder et al. [9] have stated that monitoring can increase application dependability. They have described monitoring systems as external observers that gather information about the functioning of the applications. Such information can then be used for correctness checking, performance enhancement, security and dependability.

On-line monitoring systems not only gather information during execution of the application but also process the information to respond in a timely manner to application events to provide increased robustness, adaptability and fault tolerance. Delgado et al. [10] have presented a taxonomy of run-time software fault-monitoring approaches. Fault has been described as an incorrect state during the execution of the software that can lead to a software failure. It has been described as a deviation from the required or intended behavior of the system. The taxonomy presents the classification of elements in a monitoring system; a specification language to define the monitoring properties, an event handler to capture and communicate monitoring results and the monitoring mechanism to handle the faults and oversee the programming execution. The issues addressed have been taken into consideration while designing the proposed model for run-time monitoring of the behavior of web services during execution.

There has been considerable work related to development and deployment of web services. Management of web services and particularly fault management is not yet a well-defined area and require considerable research focus. Fault management includes fault detection, fault isolation and fault repair. Robinson [11] has proposed the integration of software requirements analysis with execution monitoring to address web service monitoring. He has proposed the use of individual monitor servers at each site to track web service traffic. A global integrative monitor is to be used to control the individual monitors and process the received information to provide real-time alerts. Requirements are expressed using Knowledge Acquisition in autOmated Specification (KAOS) which does not provide enough information on monitoring and the transformation from specification to monitoring code has not been clearly addressed.

Benharref et al. [12] have presented architecture for detecting faults in web services based on passive testing. They have proposed the use of observers at service providers, clients and third parties interested in the observation. They have proposed that observers be designed and published as web services. The observers can be invoked by the client or third parties with information like the location of the service to be observed, its specification and when and what to observe. The model was used for the detection of only input/output faults in web services.

Zheng Li et al. [13] have developed a framework for monitoring the run-time interactions of web services. The run-time behavior is monitored and validated against pre-defined interaction constraints expressed using Finite state automata. The framework involves interception of service messages and conformance checking with the service constraints.

Farzaneh Mahdian et al. [14] have presented an approach to detect faults at the architecture level of service oriented systems and have extended the formal SOA core meta-model to support fault tolerance. New components, namely, “policy”, “selector”, “monitor” and “compositor” have been introduced to monitor faults in the different parts of the architecture. The Selector component chooses a suitable service in the given service category and if the requested service is not found then the Compositor component composites two or more services to provide the required service to the user. The Monitor component was designed to detect only three types of faults namely TimeOut, NoServiceFound and BindingDenied.

Qiangxiang Wang et al. [15] have introduced an online monitoring approach for web services requirements. The proposed approach includes a pattern based specification of service constraints that correspond to service requirements, and a monitoring model that covers five kinds of system events relevant to client request, service request, service response, application and resource and management.

It can be summarized from the above discussions that the earlier work has primarily been with respect to detecting errors in input and output of web services. In the proposed approach, fault detection pertaining to publishing, discovery, binding and execution of web services have been considered. Execution fault detection covers errors in the request given to web services and also errors in the reply from the web services. In addition, different types of SOAP processing errors have also been included in the fault detection process. The proposed model uses policies to express the intended behavior of web services. Policies provide a flexible approach to enforce and communicate various types of rules and requirements of the web services.

Service-Oriented Architecture (SOA) consists of the three key components, namely, Service Consumer (SC), Service Registry (SR), and Service Provider (SP) which interact with each other to publish, discover and execute web services. Service providers create and deploy their web services. Service providers publish their web service in service registries which act as repository of web services. Service users look up these directories to obtain details of available web services. The users then bind and execute their selected web service deployed by the service provider.

Web services are loosely coupled and dynamic in nature. Web services need to connect different servers and clients systems that run on different hardware and software platforms. To ensure availability and reliability of these web services, it is necessary to ensure that these services behave correctly at run-time. Faults can occur during all or any of the interactions between the key players [16]. Monitoring the web service interactions at run-time would enable faults to be detected and handled appropriately to avoid system failures. WISDOM has been proposed as a generic architecture for run-time monitoring of web service interactions and handling fault detection. An extended version of WISDOM (Web Service Diagnoser Model) [6], the proposed monitoring architecture is given in Fig. 1
                     .

A key aspect of web service monitoring is the interception of messages exchanged between the key players, namely, service providers, service registries and service users. Different methods are available to intercept such messages, namely, wrappers, network proxies and handlers [17].

Software wrappers are used to encapsulate the monitored service and such wrappers can be used for a variety of purposes. For on-line monitoring, the wrappers are primarily used to intercept the messages sent to the actual service. The wrapper is used to process the service request–replies and monitor for errors. To be transparent to the user, the wrapper interface has to match the interface of the service being monitored and a separate wrapper has to be designed for every service being monitored. In proxy based interception, network nodes are designated as proxies to handle the message exchanges. The transport protocol has to support the interception of the messages and the proxy server is used to process and monitor the request–replies.

In the proposed monitoring architecture, handlers have been used to intercept the message exchanges. SOAP protocol is widely used as the messaging framework for web service interchanges and SOAP provides support for the use of handlers to intercept the web service message exchanges. Handlers have been implemented to capture the request and replies between the user and web services. The handlers have been designed to delegate the validation of such messages to independent Monitoring Components (MCs) located in the service registries and service providers.

Faulty behavior can be defined as deviations or inconsistencies with respect to the specified behavior of web services [18]. Policies are proposed to describe the intended behavior of web services. Policies support standard assertions and provide a simple method to express the capabilities, requirements and characteristics of web services. Web services are frequently modified to suit the changing needs of the users. Policies make it easy to make necessary changes in the specifications of web services and facilitate its dynamic update. The interaction constraints would need to be specified by the service provider for the correct execution of their web services. Policies can also be used to define interaction constraints with respect to publishing and discovery of web services. WS-Policy [19], a web service standard, is proposed for expressing the specifications of the web services. WS-Policy is a W3C recommendation that provides a general purpose model to describe and communicate the policies of web services. The capabilities and constraints are expressed as a set of specifications using XML syntax.

MCs are the individual components that monitor the local web service interactions. An MC is implemented in each service registry that provides the directory for listing the web services of service providers. MCs are also located in each service provider where the web services are deployed. Fault Diagnoser (FD) is the common independent external entity that is used to coordinate the individual monitoring components. FD acts as the repository of web service policies and provides an interface for service providers to create and maintain their web service policies. Changes in web services would require modifications in their corresponding policies. FD provides a common interface for easy update of the policy changes. Service provider may choose to list their web service with multiple service registries. However, the policy needs to be defined only once for a web service and can be accessed by multiple MCs located in these service registries.

The MCs in service registry and service providers do not maintain these policies but access FD to obtain the policy of the web services being monitored. This would enable them to always access the latest updated or current policies. MCs would use the policy information to verify if the service run-time interactions are in conformance to the constraints specified in the policies. MCs located in the service registries analyze the web service publishing requests of service providers for faulty behavior. It also manages fault handling of web service search and discovery requests of users. MC located in each service provider would obtain the policy information from FD to detect errors that occur during binding and execution of the web services.

A local cache has been proposed to maintain details of web service policies recently accessed by the MCs. MC would first check the local cache for the policy information. If the information is available then it would proceed with verification and fault detection. Otherwise, it would send a request to the FD giving the web service details. FD would retrieve the policy details from the stored policy database and return the relevant policy information. The interaction between the monitoring components and the fault diagnoser is depicted as a sequence diagram is given in Fig. 2
                     .

As seen from Fig. 2, MCs also communicate the usage and fault details of web services to FD, which maintains these statistics in separate databases. If a web service policy has changed, FD would alert the MCs which maintain the policy in their local cache, to request for the current policy information. As future work, it is proposed to develop an analyzer component which would use the fault and web service usage data to evaluate the performance and reliability of the web services.

Web services are described using WSDL files which contain the functional specifications of the services. Web services are discovered using UDDI. SOAP is used as the communication protocol for message exchanges. Faults that occur during publishing, discovery, binding and execution of web services can be detected by the proposed architecture.

Services are published to make the service description available in the service registry. The service users would be then able to search and find the services that match their requirements. Faults occur during publishing because the service description given is incorrect or is incomplete. The service description includes a description of the service business function, information about the provider and technical details for invoking and executing the web service. The web service information is stored in the form of white, yellow and green pages in the registry. To publish a service in the service registry, the provider provides details that include publisher name, service name, business name and URL of the web service WSDL. Faults that can occur include format error and content error. Format error occurs if the service description details are incomplete or in incorrect order and content faults occur due to errors in the given service details. Publishing error can also occur due to network or server error. The faults detected by the proposed architecture are given in Fig. 3
                        .

Service discovery is the process to query the registry to obtain information about available services. Faults can occur during the search process or when the service details are returned to the service client. The faults that are detected during the discovery process are given in Fig. 4
                        .

Service Not Listed fault will occur when the relevant service is not available in the registry. Incorrect Search Criteria occur when the user specifies the incorrect service name or other details. Faulty Lookup Service error occurs when the details given does not match the specifications of the web service. Timed Out error occurs due to server or network error.

Service binding is to contact and invoke the service based on the service description information obtained during the discovery process. The faults that are detected during the binding process are given in Fig. 5
                        .

To bind to a particular service, the user has to specify the port number, target namespace, discovery URL, operation name, port type, and service name. Authentication Failure error occurs when the user cannot be properly identified. Authorization Denial occurs if the user is not permitted to use the service. Error can also occur if the service details are given incorrectly. For instance, the port number could be specified wrongly or the service name could be incorrect. Timed Out error occurs due to server or network failure.

Execution fault occurs when the service does not execute correctly. Execution errors occur due to errors in input or processing error and the results sent to the user would be incorrect. The constraints in specifying the inputs and outputs to/from the web services are given as XML tags in the policy. These constraints would have to be specified by the service providers of the individual web services. Standard tags have been defined for specifying constraints in the input and output parameters used to invoke the web services as shown in Fig. 6
                        .

Some of the constraints for numeric, alphanumeric and date used in the input and output parameters are given in Table 1
                        .

Patterns can be used to check for permitted combination of values. For example, a pattern “[1][0–5][0–9]”, would indicate that the numeric value should start with 1, the next number should be in the range of 0–5, and the last number should be within 0–9. Pattern “[a–zA–Z][a–zA–Z][a–zA–Z]” would indicate that the alphanumeric value should accept three characters in the range A–Z or a–z. Pattern “[a–zA–Z0–9]{8}” indicates that the length is 8 and each of the characters can be in the range of A–Z or a–z or 0–9.

The constraints can be easily extended to include other types of parameters like Email ID, URL etc. The policy can also be extended to also cover other aspects of web service specifications and run-time errors. In addition to the above, SOAP processing errors have also been detected as explained in the next section.

Faults have been classified under major classes and individual faults are classified under each major class. The faults are classified under the four major classes of publishing, discovery, binding and execution. Under each major class, each individual fault is given a unique fault code or ID. The list of fault and their codes are given in Table 2
                        .

Additionally SOAP processing errors that relate to invalid XML document, missing tags, duplicate tags and other syntax errors have also been detected. A sample of these errors is given in Table 3
                        .

The service usage and fault details are maintained by the FD along with date and time stamp. The data can be analyzed to design suitable recovery actions. The Quality of Service (QoS) rendered; availability and reliability of web services can be determined by analyzing the usage and fault details. Other QoS parameters like security can also be determined by analyzing the data in these logs.

A sample web application from the Travel agency domain has been used for implementing and testing of the fault detection process. An airline reservation application has been implemented with web services for enquiry, reservation and cancellation of flight tickets. Web services were developed for Flight Enquiry, Ticket Availability, Ticket Reservation, Reservation Status Enquiry and Ticket Cancellation.

IBM Rational Application Developer IDE has been used to develop the web services. jUDDI (JAVA Universal Description Discovery and Integration) was used to configure the web service registry. All service communication has been implemented using SOAP protocol. SOAP handlers have been used for intercepting SOAP messages and passing the details to the MCs for fault detection.

FD is the core component that manages and provides web service information to the MCs. FD was developed using JAVA. WS-Policy standard is used for creating the policies maintained in XML format at FD. A web service of a service provider could be listed in many service registries and MCs access the FD to retrieve the policy information and check for faults as deviations from the intended behavior. FD maintains the service usage details and data about faults that have occurred during execution of the web services. Whenever a fault is detected, a fault message is sent to FD by MC giving details such as web service name, service provider name, date and time stamp and fault details like code and ID. If the web service action is successful, then usage details like service name, service provider name, service client details, action (publishing, discovery, binding, execution) etc. are sent to FD. The fault details are stored in a fault database and service usage details are stored in a separate service usage database created using MySQL.

A tool has been developed using JAVA for capturing the policy information and generating the policy in the prescribed format. The tool can be used to generate policy tags for monitoring SOA faults in publishing, discovery and binding using WSDL and service details published in the jUDDI registry. Option has been provided to accept the constraints in the execution of web services and generate the policy; such constraints would need to be specified by the web service provider. Policies are generated separately for each web service. The generated policies were stored in the FD. Some sample screen snapshots of the tool are given in Fig. 7
                        .

The tool provides the flexibility to copy and duplicate policies for web services. For example, if a service provider offers similar policies for web service offerings, then the policy can be generated once; and duplicated and modified for other services. As the service offerings generally change frequently, the tool makes it easy to carry out the modifications.

SOAP handlers have been developed using JAX-RPC. The Monitoring component is implemented using the SOAP handler methods Init(), handleRequest() and handleResponse().

The block diagram of the processing is given in Fig. 8
                           .

In the Init() method the SOAP message is parsed to obtain the service name, business name and the WSDL URL. The FD is accessed by MC with the WSDL details to obtain the policy information. The policy information is stored in the policy cache. The SOAP message input parameters are parsed in the handleRequest() method. The processing steps for comparing the input parameters with the policy information are given as a flowchart in Fig. 9
                           .

When a fault is detected in the client request(), a SOAP fault is created with the appropriate meaningful error message and sent to the client through the handleResponse() method.

The block diagram of the processing is given in Fig. 10
                           .

The output after execution of the web service is received by the handleResponse() method. The SOAP message is parsed to obtain the results of the web service. The policy information is retrieved from the policy cache and compared with the results obtained. The processing steps at the handleResponse() are given as a flowchart in Fig. 11
                           .

Publishing faults are detected when a service provider tries to publish a service giving details like publisher name, publisher ID, service name and business name. A sample policy conforming to UDDI 2.0 version for expressing constraints in publisher name is given in Fig. 12
                           .

As an example, let the service provider try to publish a service with the publisher name given as “@hariharan”. A SOAP request message would be generated and the SOAP handler would intercept this message and pass the details to the MC in the service registry. The intercepted data is compared with the publisher name pattern given as [a–zA–Z0–9]* in the policy. Fault would be detected as the given publisher name contains @, which violates the pattern. In the absence of the FD and MC, a generic error that the service cannot be published would be returned and the user would not get information on the exact error in the given input. This is an example of content fault. Similarly the other types of faults given in Table 2 can be detected.

When a service client or user wishes to search for a web service, the search criteria is sent to the service registry. To discover a service, the user has to provide the details of business name and service name in the given order. The SOAP message is intercepted by the SOAP handler and passed to MC in the service registry for fault handling. For example, the user wants to book a plane ticket and tries to check if the service exists by giving the query as “FlightReservation”. This would be reported as a fault by MC as business name has not been specified. If the query is formed correctly, the enquiry would be sent to the UDDI Registry for processing. However, if the service “FlightReservation” does not exist, then the error sent by the registry is processed by MC and the error “Invalid Service Name” would be returned to the user. In the absence of FD and MC, a generic error of Incorrect Search Criteria or service cannot be found, would have been returned to the user.

To execute a service, the user tries to bind with the web service at the service provider using the service details obtained during the discovery process from the service registry. If binding is successful, the user tries to execute the web service by providing the input data. For some of the services, authentication may be mandatory and this would be indicated by the service provider in the binding policy of the particular service. A sample policy generated for expressing the constraints of user name and password used for authentication during binding of the service “Reservation” is shown in Fig. 13
                           .

As per the sample policy, the user has to specify the details such as user name and password for authentication during the binding process. The user name and password are appended to the request headers and the binding handler invokes Web Services Security (WSS) Agent for authentication. The message returned by WSS is processed at MC. If the authentication details are not present, an error would be generated to the user indicating that such details are mandatory. The handler would send Authentication Failure message to the user to indicate that there was an error either in the given user name, password or both. In the absence of the proposed handler, error message, such as, “http response code is 403” would be returned, which may the user perplexed.

Fault detection in the input and outputs to web service is explained. A sample policy generated for expressing constraints in the input parameter “flight number” is given in Fig. 14
                           .

Flight number is to be given as input for booking tickets in a particular flight for a given date and time. For example, the user gives the flight number as “abc444” and the SOAP handler intercepts the data and passes the details to the MC in the service provider. The intercepted data is compared with the policy information of flight number. Fault is detected because as per policy, the third character has to be a number and not an alphabet.

If the execution does not happen correctly, then there could be errors in the results returned by the service. The errors in execution could be due to various reasons, such as, database connectivity error, SQL exceptions, and error in output data returned. The error is trapped by the handler and meaningful message is sent to the user. For instance, booking for a particular flight is permitted only 30days in advance of the flight date. Hence, if the user tries to book a ticket before the 30day period, there would be no corresponding entry in the database and SQL exception error would be thrown. With the handler, it is possible to trap the error and give a meaningful message to the user that advance booking is not permitted, due to the constraint of 30days with respect to the scheduled date of flight.

To give another example, if “KF4564S001” reference is returned by the Reservation service, then MC would be able to detect an error in the execution as the reference number does not match the pattern [[A–Z][A–Z][0–9][0–9][0–9][0–9] [0–9][0–9][0–9][0–9]] given in the policy. The presence of “S” in the output is an error as a digit in the range of (0–9) should have been present.

SOAPFaultException error is raised for errors in the SOAP message received at the service provider or service registry. Such faults could occur for a number of reasons such as version mismatch and error in the SOAP protocol software. MC would trap such errors and send meaningful messages to help the user to correctly identify the actual error.

@&#EXPERIMENTAL RESULTS@&#

Faults were injected in the web services to test the proposed architecture. The implementation details are given in Table 4
                        .

IBM Functional Tester tool was used to analyze the efficiency and performance of the proposed model. The response time for web services was plotted for correct web services, that are services without faults and the results are shown in Fig. 15
                        .

It can be seen from the chart that the response time rightly increases with the introduction of FD as there is an overhead associated with the processing at MCs and FD. It can also be noted that the introduction of local policy cache greatly reduces the response delay. It was assumed that 50% of the required policies were available in cache and the remaining policies were retrieved from FD.

The processing time for handling faults in the web services by the implemented fault handler is given in Fig. 16
                        .

This has been compared with the time taken for processing errors by the default fault handling mechanism of SOAP. It can be observed that the time taken for handling faults by the proposed FD compares favorably with the default fault handler. Additionally, the proposed model would send meaningful messages identifying the exact cause of errors. The user would find it easy to correct the errors and re-submit.


                        Fig. 17
                         shows the total elapsed time from query submission to user receiving the response for all web services; correct and faulty services.

It can be seen from the chart that the response time without FD shows sharp increase in processing time when errors are present. The response time curve with FD is more or less flat showing a steady processing time. It can be further observed, that there is marked improvement in performance when policy cache is introduced. It was once again assumed that 50% of the required policies were available in cache and the remaining policies were retrieved from FD.

A comparison of the proposed work with some of the key related work is presented in this section. Run-time monitoring approach has been adopted in the proposed work to detect faults in web services, as it has been conclusively established that monitoring increases the dependability and reliability of applications.

Fault management includes fault detection, fault isolation and fault repair. The proposed work is focused on fault detection. The required behavior of web services has been expressed using policies as they offer a flexible and easy method to express the intended behavior of web services. Policies enable dynamic changes in the required specifications to cater to the changing needs of web services. The well known and universally accepted WS-Policy standard has been used to express the constraints in the web services.

Benharref et al. have presented a web service based architecture using observers for detecting faults in web services. Their proposed model was tested using the FSM model. Results were presented only with respect to input and output faults. The proposed model performance was been compared with the fault detection architecture of Benharref et al. Benharref architecture was implemented by extending the standard WSDL to introduce tags giving the expected input and output data in terms of data types and formats.

The proposed work, as explained, uses policies to indicate the intended behavior of web services interactions between the three key components. The proposed system was able to effectively detect the injected faults in publishing, discovery, binding and execution of web services. The breakup of faults is shown in Fig. 18
                           .

Delgado et al. have developed taxonomy for run-time software fault-monitoring. They have analyzed run-time monitoring but have not dealt with the implementation issues. Farzaneh Mahdian et al. in their work have listed the different types of faults in SOA, but once again, have not implemented their idea.

Zheng Li et al. have presented a framework for monitoring run-time interaction of web services. Their work aims at expressing the behavior that services can provide. OWL-S has been used to specify the semantic behavior of individual services with run-time validation of behavioral properties of the web services. In the proposed approach, instead of trying to express the full behavior of the services, policies have been used to express the required behavior of services using constraints, and faults have been detected as deviations from the intended behavior.

Mahbub and Spanoudakis [20] have used BPEL and Event Calculus to develop their monitoring framework for composite web services, but have not considered individual web services.

Fault management is one of the crucial areas of web service management. This paper presents a generic architecture for run-time service monitoring and validation to detect faults as violations in the intended behavior of web services. Policies have been used to express the run-time constraints for proper execution of web services. A policy generation tool has been developed to create policies in the web service standard WS-Policy. The requirements and constraints are expressed as a set of policy assertions using XML syntax. Monitoring components are deployed on the web service entities: service registry and service provider; to monitor the message exchanges. SOAP handlers have been used to intercept the SOAP messages which are analyzed for faulty behavior using the stored policy information. The proposed model has been tested using a sample web service application with multiple service providers and service clients. The results show that the fault detection process was able to successfully detect the faults injected in publishing, discovery, binding and execution of the web services. As future work, it is planned to extend the diagnoser model to detect other types of web service faults such as composition faults.

@&#REFERENCES@&#

