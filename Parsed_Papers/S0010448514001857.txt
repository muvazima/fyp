@&#MAIN-TITLE@&#Lightweight wrinkle synthesis for 3D facial modeling and animation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a lightweight non-parametric approach to generate wrinkles for 3D facial modeling and animation.


                        
                        
                           
                           Our method represents a convenient approach for generating plausible facial wrinkles with low-cost.


                        
                        
                           
                           Our method enables the reconstruction of captured expressions with wrinkles in real-time.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

3D facial animation

Texture synthesis

Lightweight wrinkle generation

@&#ABSTRACT@&#


               
               
                  We present a lightweight non-parametric method to generate wrinkles for 3D facial modeling and animation. The key lightweight feature of the method is that it can generate plausible wrinkles using a single low-cost Kinect camera and one high quality 3D face model with details as the example. Our method works in two stages: (1) offline personalized wrinkled blendshape construction. User-specific expressions are recorded using the RGB-Depth camera, and the wrinkles are generated through example-based synthesis of geometric details. (2) Online 3D facial performance capturing. These reconstructed expressions are used as blendshapes to capture facial animations in real-time. Experiments on a variety of facial performance videos show that our method can produce plausible results, approximating the wrinkles in an accurate way. Furthermore, our technique is low-cost and convenient for common users.
               
            

@&#INTRODUCTION@&#

3D facial modeling is an important research topic in computer graphics, mainly due to its wide applications in game and film industries. Recent progress in 3D facial modeling research advocates the importance of the modeling of fine-scale wrinkles, since it can reinforce the perception of the complex emotions in the facial performance  [1,2]. For example, the frown lines are indispensable clues of unpleasant or disapproval emotions.

Laser scanning, multi-view stereo reconstruction and sophisticated deformation methods have been applied to the modeling of highly-detailed 3D facial models with fine-scale wrinkles  [3–5]. However, these systems usually run in controlled laboratory environments by professional users with high-cost devices. They are generally hard to be accessed by common users in their living environments. A recent contribution by Garrido et al.  [2] allows users to reconstruct highly-detailed 3D facial models under uncontrolled lighting. While it has significantly simplified the requirements regarding on the capturing conditions, the demand of binocular stereo reconstruction for template face acquisition might still hinder its widespread applications by common users.

In this paper, we propose a non-parametric method to synthesize detailed wrinkle geometries and create personalized blendshape models with a single low-cost Microsoft RGBD Kinect camera, which are subsequently used to track RGBD facial performance videos to create 3D facial animations with detailed wrinkles (see Fig. 1
                     ). We utilize the texture synthesis approach to synthesize wrinkles on the 3D face expression model for various people. The distinctive feature of this method is lightweight, since we only use one high-quality 3D facial model with calibrated texture as the source in the texture synthesis and a single RGB-Depth camera. The key observation is that, although the facial wrinkles look different from one person to another, the variation of their local geometry is much less. This implies that it is possible to copy the local geometric patches of one source to synthesize different wrinkles of multiple subjects. Therefore, one can expect to synthesize different kinds of wrinkles in a lightweight fashion.

Our method works in two stages: offline personalized wrinkled blendshape construction and online 3D facial performance capturing. In the offline stage, the user-specific expressions are recorded as blendshapes, and the wrinkles on them are generated through example-based geometric detail synthesis. During the online stage, given an RGB-D video captured by a Kinect camera, the 3D facial animation with detailed wrinkles is reconstructed for each frame as the linear combination of the wrinkled blendshape models.

It should be noted that the synthesized wrinkles can only approximate the real wrinkle geometry. However, experiments show that our lightweight wrinkle synthesis method effectively guarantees the visual plausibility of the reconstructed detailed 3D facial models and animations.

@&#RELATED WORK@&#


                     3D facial modeling: The highly detailed 3D facial model is usually created via state-of-the-art 3D reconstruction techniques, such as laser scanning, structured light, multi-view video based systems.

XYZRGB  [6] is a typical laser-based 3D scanning system. It takes over 10 s per scan which makes the system more suitable for capturing static expressions. Structured light systems are capable of capturing 3D dynamic faces with salient wrinkles in less than 0.1 s per scan. They are adopted in  [7,8] to scan facial mesh animation sequences with detailed wrinkles.

In contrast to the mentioned active scanning systems, multi-view video-based facial capture systems are passive. They capture in fast speed, which is important to capture the fast occurring subtleties in the facial expressions. Markers are often used to assist the feature tracking in the facial performance video. Bickel et al.  [1] explicitly tracked the wrinkles in the performance video and imposed them on the reconstructed facial model via linear shell deformation to create bulging effects.

Marker-less approaches can ease the burden of putting markers on the human face. Such approaches usually rely on multi-view stereo reconstruction with dense correspondences to recover the detailed wrinkles  [3–5]. A lightweight solution, binocular stereo reconstruction, for marker-less facial animation is proposed in [2,9]. This technique is robust to illumination change because of the albedo estimation for the captured face.


                     Real-time facial animation: Facial performance video is a major type of input for real-time facial animation algorithms, since it is easy and fast to capture. The combination of marker tracking and fast deformation algorithms has already been used to produce facial animation in real-time  [10]. Robust face tracking algorithms combined with linear blendshape models are also widely used in single camera based real-time facial animation  [11,12,9,13]. To separately parameterize the different attributes of facial animation, a multi-linear model for face animation transfer is developed in  [14]. However, the detailed wrinkles are usually missing in their reconstructed facial animations.

In  [15], Huang et al. proposed to scan wrinkled 3D face models to create blendshape models, and successfully reconstruct the detailed wrinkles in the real-time facial animation. Bickel et al. proposed to learn a mapping from the sparse measurement facial skin strain to the wrinkle formulation to synthesize wrinkle geometries  [16]. The blendshape models and training examples in these two methods are obtained through laser scanning and structured light, respectively. In contrast, our work allows users to create their own wrinkled blendshape models with a single RGBD camera, which is low cost and easy to access.


                     Example-based texture synthesis: It aims to synthesize a new texture appearing to be generated by the same process of the given exemplar. The 2D texture synthesis algorithms can be categorized into pixel-level algorithms  [17,18], i.e. synthesize textures at each pixel, and patch-level algorithms, which can synthesize textures at a connected group of pixels simultaneously  [19,20]. They are generally faster than pixel-based approaches.

We adapt the texture optimization algorithm in  [21] to synthesize height values used to displace the face mesh vertices to generate wrinkles. While the individual components of our method may resemble previous approaches, but we are not aware of the existing work to synthesize wrinkles with non-parametric texture synthesis.

To be robust to skin color and luminance change, our wrinkle synthesis runs in the gradient domain. Basically, there are three types of images used for both the input and the example face: the RGB image 
                        I
                     , the gradient image 
                        G
                      and the height image 
                        H
                     , where the gradient image 
                        G
                      stores 
                        ∂
                        I
                        /
                        ∂
                        x
                      and 
                        ∂
                        I
                        /
                        ∂
                        y
                      in its two channels and the height values are stored in 
                        H
                     . Given an input image 
                        
                           
                              I
                           
                           
                              f
                           
                        
                     , we first convert it into a gradient image 
                        
                           
                              G
                           
                           
                              f
                           
                        
                     . Afterwards, we synthesize a gradient image 
                        
                           
                              G
                           
                           
                              s
                           
                        
                      using the patches in the example gradient image 
                        
                           
                              G
                           
                           
                              e
                           
                        
                      and compute a height image 
                        
                           
                              H
                           
                           
                              s
                           
                        
                      using the correspondence between the example gradient image 
                        
                           
                              G
                           
                           
                              e
                           
                        
                      and height image 
                        
                           
                              H
                           
                           
                              e
                           
                        
                     . 
                        
                           
                              H
                           
                           
                              s
                           
                        
                      is then used to displace the vertices on the face model to form wrinkles. The algorithm pipeline is shown in Fig. 2
                     . In the following, we first describe how to generate the exemplars and then detail the wrinkle synthesis algorithm.

Our exemplars for texture synthesis are extracted from one high quality face model 
                           
                              
                                 M
                              
                              
                                 e
                              
                           
                         in the public facial performance sequence ETH man from  [4], as shown in (a) of Fig. 3
                        . The face model is accompanied with a high quality RGB texture 
                           
                              
                                 T
                              
                              
                                 e
                              
                           
                        .

While the example gradient image 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         can be computed from 
                           
                              
                                 T
                              
                              
                                 e
                              
                           
                         easily using the Sobel operator, the computation of height map 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                         to encode the wrinkle geometry is not straightforward. To this end, we deform a smooth neutral face, which is also provided in this facial sequence, to match the selected expression model 
                           
                              
                                 M
                              
                              
                                 e
                              
                           
                         and extract the height values to be stored in the 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                        . The algorithm to compute 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                         can be separated into two steps: 
                           
                              •
                              1. The non-rigid shape registration algorithm proposed in  [22] is used to register a smooth neutral face to the selected expression. To avoid overfitting the detailed features in the deformation, we cluster the vertices according to the vertex normal variation on the neutral mesh. The deformation variables are then reduced to rigid transformations for each cluster, which is similar to Huang et al.  [22]. Since the neutral face and 
                                    
                                       
                                          M
                                       
                                       
                                          e
                                       
                                    
                                  share the same mesh connectivity, we can set up per-vertex correspondence and obtain a smooth registered mesh which successfully captures the overall facial expression but lacks the fine-scale wrinkles, as shown in Fig. 3(b).

2. After the registration, the fine-scale wrinkle information of 
                                    
                                       
                                          M
                                       
                                       
                                          e
                                       
                                    
                                  is extracted as its position difference between 
                                    
                                       
                                          M
                                       
                                       
                                          e
                                       
                                    
                                  and the registered smooth face by closest point searching. We compute the height values by projecting the difference vector into the normal direction at the searched closest point on the registered face. With the associated texture 
                                    
                                       
                                          T
                                       
                                       
                                          e
                                       
                                    
                                 , we can store height values into a height image 
                                    
                                       
                                          H
                                       
                                       
                                          e
                                       
                                    
                                 . Note that the correspondence between 
                                    
                                       
                                          G
                                       
                                       
                                          e
                                       
                                    
                                  and 
                                    
                                       
                                          H
                                       
                                       
                                          e
                                       
                                    
                                  can be well established using texture coordinates of 
                                    
                                       
                                          M
                                       
                                       
                                          e
                                       
                                    
                                 .

Since there are many areas in 
                           
                              
                                 T
                              
                              
                                 e
                              
                           
                         without wrinkle information, we manually crop the wrinkle region on the forehead as the final 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         and 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                        . The reduced search area in the exemplar is also beneficial to the performance of the texture synthesis algorithm. However, the wrinkles on the forehead are mostly horizontal. We thus compute new exemplars by rotation to significantly enlarge the wrinkle geometry variations. For example, we could rotate the face by 
                           90
                           °
                         and obtain vertical wrinkle exemplars. In our experiments, we rotate the forehead wrinkles by 
                           30
                           °
                           ,
                           60
                           °
                           ,
                           90
                           °
                           ,
                           120
                           °
                         and 
                           150
                           °
                        . Combined with the original forehead wrinkles, we collect six exemplars in total to be used in the wrinkle synthesis algorithm.

Before we perform the texture synthesis algorithm, we detect wrinkle edges from the input image. The texture synthesis is thus applied in a significantly smaller region to boost the performance. It also avoids adding unnecessary height displacement on non-wrinkle regions.

The detection is based on the observation that the gradient values have different signs on different sides of a wrinkle boundary. Specifically, in the implementation, we detect edges along both 
                           x
                         and 
                           y
                         directions. In 
                           x
                         direction, for a pixel 
                           p
                           
                              (
                              x
                              ,
                              y
                              )
                           
                        , if the gradient values in 
                           
                              
                                 q
                              
                              
                                 1
                              
                           
                           
                              (
                              x
                              −
                              1
                              ,
                              y
                              )
                           
                         and 
                           
                              
                                 q
                              
                              
                                 2
                              
                           
                           
                              (
                              x
                              +
                              1
                              ,
                              y
                              )
                           
                         have different signs and their difference is larger than a user-specified threshold 
                           ϵ
                        , we mark this point as an edge point. We perform this operation along the 
                           y
                         direction as well. From our experiments, we found that this strategy is more robust for wrinkle detection since it captures the characteristics of the buckling geometry of wrinkles.

After the edge point detection, we group them into lines through tracing them based on adjacency. We remove very short lines and the lines around mouth, lips, eye brows and nose using the feature points detection in  [23], since these lines are usually formed by color or lighting changes on smooth regions. The remaining lines are further clustered to line sets according to spatial adjacency. The 2D bounding box of each line set represents a wrinkle region. For some cases, automatic detection may not work well, for instance, the small wrinkle regions around eye corners. We thus allow user interaction to extract the wrinkle region more accurately. The user interaction is only necessary for small regions around the eyes. We only ask the user to draw several rectangles to indicate the small regions, and it takes no more than 30 s.

For texture synthesis, we require the synthesized gradient image 
                           
                              
                                 G
                              
                              
                                 s
                              
                           
                         to be locally similar to the example gradient image 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         and globally almost identical to the input gradient image 
                           
                              
                                 G
                              
                              
                                 f
                              
                           
                        . That is, we hope to use the local patches from 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         to form 
                           
                              
                                 G
                              
                              
                                 s
                              
                           
                         which are similar to 
                           
                              
                                 G
                              
                              
                                 f
                              
                           
                        . The synthesized height image 
                           
                              
                                 H
                              
                              
                                 s
                              
                           
                         is calculated by copying height values from example height image 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                         to 
                           
                              
                                 H
                              
                              
                                 s
                              
                           
                         with the closest neighborhood information between 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         and 
                           
                              
                                 G
                              
                              
                                 s
                              
                           
                        . However, if we only consider the similarity of the gradient images, the resulting height map might not be smooth, since the similarity in gradient values does not directly imply the smoothness of the synthesized height values. We thus adapt the objective function in the texture optimization technique in  [21] according to: 
                           
                              (1)
                              
                                 
                                    E
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       p
                                       ∈
                                       
                                          
                                             G
                                          
                                          
                                             s
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          ‖
                                          
                                             
                                                
                                                   g
                                                
                                             
                                             
                                                p
                                             
                                          
                                          −
                                          
                                             
                                                
                                                   g
                                                
                                             
                                             
                                                p
                                             
                                             
                                                ′
                                             
                                          
                                          ‖
                                       
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 λ
                                 
                                    
                                       
                                          ‖
                                          
                                             
                                                
                                                   h
                                                
                                             
                                             
                                                p
                                             
                                          
                                          −
                                          
                                             
                                                
                                                   h
                                                
                                             
                                             
                                                q
                                             
                                          
                                          ‖
                                       
                                    
                                    
                                       2
                                    
                                 
                              
                           
                         where the first term measures the similarity between 
                           
                              
                                 G
                              
                              
                                 s
                              
                           
                         and 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                        . 
                           
                              
                                 
                                    g
                                 
                              
                              
                                 p
                              
                           
                         is a vector of stacked gradient values from a small size window centered at 
                           p
                         in 
                           
                              
                                 G
                              
                              
                                 s
                              
                           
                        , and 
                           
                              
                                 
                                    g
                                 
                              
                              
                                 p
                              
                              
                                 ′
                              
                           
                         denotes a stacked vector of gradient values at the same pixel 
                           p
                         from 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                        . The second term measures the similarity between the formed height images 
                           
                              
                                 H
                              
                              
                                 s
                              
                           
                         and 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                         locally, where 
                           
                              
                                 
                                    h
                                 
                              
                              
                                 p
                              
                           
                         is the vector of stacked height values at pixel 
                           p
                         from 
                           
                              
                                 H
                              
                              
                                 s
                              
                           
                        , and 
                           
                              
                                 
                                    h
                                 
                              
                              
                                 q
                              
                           
                         represents the vector of stacked height values at pixel 
                           q
                         from 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                        . 
                           q
                         indicates the closest pixel in 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         to the pixel 
                           p
                         found in the texture optimization procedure using their neighborhood information.

Texture optimization can be achieved iteratively with an algorithm similar to Expectation–Maximization (EM)  [21]. The key difference of our optimization algorithm is to set the initial gradient image directly as 
                           
                              
                                 G
                              
                              
                                 f
                              
                           
                        . In the 
                           E
                         step, our algorithm calculates the average gradient and the height value at each pixel 
                           p
                         according to the neighborhood information of its closest pixel 
                           q
                         in the example gradient 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         and height image 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                        .

For the 
                           M
                         step, where the closest neighborhood is searched in the example, we fix the gradient values at each input pixel same to the 
                           
                              
                                 G
                              
                              
                                 f
                              
                           
                        . This prevents the algorithm from altering the synthesized gradient image iteratively, which will lead to a severe drift from the input gradient image in the final result. Specifically, we search the nearest neighborhood in 
                           
                              
                                 G
                              
                              
                                 e
                              
                           
                         and 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                         using the combined gradient and height distance as defined in Eq. (1), but using the input gradient values and the synthesized height values. As the scale of the height values in 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                         (we use mm as unit) is different from the gradient values, we weight the channel 
                           H
                         by 
                           λ
                         (usually we set 
                           λ
                         to 10) to keep a balance between spatial coherence of the height map and visual appearance similarity with 
                           
                              
                                 G
                              
                              
                                 f
                              
                           
                        .


                        Wrinkle geometry generation: We then displace the vertices on the 3D face expression model along their normals to form wrinkle details according to the synthesized height image 
                           
                              
                                 H
                              
                              
                                 e
                              
                           
                        . Note that we only keep the height values in the neighborhood around the detected wrinkle regions (see Section  3.2) and set others to be zero. In our experiments, the neighborhood size is set to 5 pixels. After displacing the vertex, we apply Laplacian smooth operations to further improve the mesh quality. It also constructs smooth transitions between the wrinkled and non-wrinkled regions.

Our wrinkle synthesis method allows users to use a low-cost Microsoft Kinect to generate personalized blendshape models, which is also a linear model to reinforce the captured facial animation with detailed wrinkles.

In our implementation, we usually capture twenty expressions for each user, such as neutral pose, smile, brow lower, brow raiser, jaw left, jaw right, jaw forward, mouth left, mouth right, mouth open, cheek blowing, lip funnel, lip pucker, grin and chin raiser. More complex expressions are required to be captured for the user if higher quality is demanded. While the number of captured blendshape models is less than the number required in FACS system  [24], we found the captured user-specific expressions in the blendshape model are sufficient to reconstruct the facial animation with detailed wrinkles.

As the depth data from Kinect camera is noisy, we adopt a method similar to  [25] to create high-quality expression models. The user needs to rotate her/his head slightly while keeping the expression unchanged in front of the camera. The captured multiple depth images are registered into the first scan by fast ICP, and finally merged into one smooth point cloud  [25]. The first scan is required to be of front view, and we also captured its corresponding RGB image as the input of our wrinkle synthesis algorithm. We then apply the morphable face model  [26] to the point cloud data captured for the neutral pose, resulting in a smooth 3D neutral face mesh. This neutral mesh is used as template and warped to each captured expressions using the non-rigid registration approach of  [22]. These reconstructed expression meshes share the same topology.

The reconstructed blendshape models can be directly used in real-time performance-driven facial animation. The overall procedure consists of two steps: rigid motion tracking to compute the global rigid transformation of the head and non-rigid motion tracking to reconstruct the local deformations at each expression.

For rigid motion tracking, we utilize the fast projective variant of ICP  [27] based on point-to-plane constraints. However, due to the noisy Kinect data, the resulting rigid tracking is not temporally smooth. To filter out high frequency flickering, we first smooth the raw data from Kinect temporally, i.e. a weighted average on the depth map for 
                           k
                         (default 5) consecutive frames. We also filter the computed rotations (represented by quaternion) and translations to further improve the tracking quality  [25].

The purpose of non-rigid tracking is to determine the weights of the blendshape models and reconstruct the user expressions in each frame, which can be formulated into a non-negative least squares problem: 
                           
                              (2)
                              
                                 arg
                                 
                                    
                                       min
                                    
                                    
                                       
                                          
                                             α
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          ‖
                                          F
                                          
                                             
                                                
                                                   (
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         1
                                                      
                                                   
                                                   …
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         n
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                t
                                             
                                          
                                          −
                                          
                                             
                                                f
                                             
                                             
                                                i
                                             
                                          
                                          ‖
                                       
                                    
                                    
                                       2
                                    
                                 
                              
                           
                         where 
                           F
                           
                              
                                 
                                    (
                                    
                                       
                                          α
                                       
                                       
                                          1
                                       
                                    
                                    …
                                    
                                       
                                          α
                                       
                                       
                                          n
                                       
                                    
                                    )
                                 
                              
                              
                                 t
                              
                           
                         denotes the features on the shape determined by current weights 
                           
                              {
                              
                                 
                                    α
                                 
                                 
                                    i
                                 
                              
                              }
                           
                        , and 
                           
                              
                                 f
                              
                              
                                 i
                              
                           
                         are the corresponding captured features. These features could be 3D sample points or 2D sparse features detected from RGB images. Finally, the tracked wrinkled mesh could be recovered by: 
                           
                              (3)
                              
                                 
                                    E
                                 
                                 =
                                 
                                    N
                                 
                                 +
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       α
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       B
                                    
                                    
                                       i
                                    
                                 
                              
                           
                         where 
                           
                              N
                           
                         represents the 3D neutral model and 
                           
                              
                                 B
                              
                              
                                 i
                              
                           
                         the 
                           i
                        -th blendshape model.

@&#RESULTS@&#

In this section, we validate our method in the generation of 3D facial models with detailed wrinkles and real-time facial animations of various people using the Microsoft Kinect camera. The current facial performance capture system runs in real-time on a machine with Intel Core 2.66 GHz Quad CPU and GeForce GTX 580 graphics card. The average computational time of the wrinkle synthesis for each captured expression is around 10 s, and the cost of online facial performance with wrinkles is about 20 ms for one frame in average.


                     Comparison with multi-view stereo: Fig. 4
                      illustrates a comparison between our results and the passive facial capture method  [5]. Although the reconstructed wrinkle details from  [5] are smoother than our synthesized wrinkle geometry, our synthesis results are visually very similar and provide high-quality clues of the input user expressions.


                     Testing on Kinect data: We test our method on various captured RGB-D images and videos from different people to demonstrate the ability of our system to produce plausible 3D facial performances with detailed wrinkles.

In Fig. 5
                     (a) are the wrinkle synthesis results on a few expressions captured the Kinect sensor. The first row is the RGB images, the second row lists the meshes before wrinkle details were added and the last row shows the corresponding wrinkled mesh. Note the neutral pose is shown in the left column. In Fig. 5(b) are more examples of face models with synthesized wrinkles using our method. Fig. 6
                      shows some sample frames from online facial performance with well reconstructed wrinkle details. For the left part, from top to bottom are RGB images, Kinect point clouds and the reconstructed facial models with detailed wrinkles. The close-up view in the right column shows the quality of synthesized wrinkles from our system. As our wrinkle generation depends on the coefficients of blendshapes, it is robust to light changing, hair occlusion and head rotation during online tracking.


                     Limitation: Our wrinkle synthesis algorithm now is limited to front view facial images, and it might be influenced by shadows cast by hairs on the face. We plan to explore facial image normalization and shadow removal algorithms to further improve the range of facial images that can be handled by our wrinkle synthesis algorithm.

@&#CONCLUSIONS@&#

We have presented a lightweight wrinkle synthesis method to enhance the reconstructed 3D face models with detailed wrinkles. Our method is lightweight, because we only use a single Microsoft Kinect camera plus one selected, high quality wrinkled 3D face model to generate all the results in this paper.

In future, we plan to enlarge the database so as to incorporate different styles of wrinkle geometry images from people of different ages and races. In wrinkle synthesis, images similar to the capture data will be first retrieved for the wrinkle synthesis. This would lead to higher quality of synthesized results with more enriched expressions captured by our system. We would also like to explore the fast texture synthesis method to reduce the wrinkle generation time.

@&#ACKNOWLEDGMENTS@&#

We thank Thomas Vetter for kindly providing the Morphable model and Hao Li for the generic blendshape model. The research leading to these results was supported in part by the European Community’s Seventh Framework Programme (FP7/2007-2013) under grant agreement no. 323567 (Harvest4D) 2013-2016, NSFC (61322204, 61272392, 61103084, 61272334, 61202333), CPSF (2012M520392) and grants from China Scholarship Council.

Supplementary material related to this article can be found online at http://dx.doi.org/10.1016/j.cad.2014.08.016.

The following is the Supplementary material related to this article. 
                        
                           Video S1
                           
                              This video shows the pipeline of our offline wrinkle synthesis method and also the online real-time facial performance with wrinkle details.
                           
                           
                        
                     
                     
                        
                           MMC S2
                           
                              This figure shows more results of our wrinkle synthesis method
                           
                           
                        
                     
                  

@&#REFERENCES@&#

