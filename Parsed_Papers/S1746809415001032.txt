@&#MAIN-TITLE@&#Simple real-time QRS detector with the MaMeMi filter

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The MaMeMi non-linear filter can remove baseline wander with minimum resource needs.


                        
                        
                           
                           A high quality ECG detector (0.88% detection error rate) is based on the filter.


                        
                        
                           
                           Low resource needs make it ideal for portable and battery opperated devices.


                        
                        
                           
                           Resource count can still be halved while achieving a 0.95% detection error rate.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Nonlinear filters

Biomedical signal processing

QRS detection

Real-time systems

Embedded software

@&#ABSTRACT@&#


               
               
                  Detection of QRS complexes in ECG signals is required to determine heart rate, and it is an important step in the study of cardiac disorders. ECG signals are usually affected by noise of low and high frequency. To improve the accuracy of QRS detectors several methods have been proposed to filter out the noise and detect the characteristic pattern of QRS complex. Most of the existing methods are at a disadvantage from relatively high computational complexity or high resource needs making them less optimized for its implementation on portable embedded systems, wearable devices or ultra-low power chips. We present a new method to detect the QRS signal in a simple way with minimal computational cost and resource needs using a novel non-linear filter.
               
            

@&#INTRODUCTION@&#

The function of the heart can be detected by sensing the voltage variations that occur on certain parts of the human body surface. An electrocardiograph (ECG) records those voltage changes over time for later analysis. ECG is a fundamental tool used by cardiologist to diagnose cardiac diseases. Moreover, heart rate monitoring has become an extremely popular method to control the evolution of physical training in sports.

The normal sinus rhythm of the heart is characterized by a sequence of some known phases such as P, Q, R, S, T as depicted in Fig. 1
                     . Heart rate is inferred by detecting the QRS complexes and obtaining the period between consecutive R peaks. However, QRS detection is not as simple as it could seem after seeing this ideal situation. ECG signals are usually affected by several noise sources, like muscular contraction and respiration. Moreover, as a consequence of a disease or a temporal alteration, heart beats can have very different characteristic patterns [1]. Real ECG recording databases, like the MIT/BIH ECG database [2], include episodes with all these different phenomena. Such databases allow us to study and design QRS detectors that take them into account. On top of that, by providing simple metrics to compare the performance of different algorithms, they have fostered the research for better and better detection methods.

There are large number of QRS detection proposals [3], and it could seem that the QRS detection problem is already saturated. Nevertheless, with the availability of portable embedded systems, wearable devices, and body area networks there is a renewed interest on analyzing energy efficient algorithms that allow QRS detection with minimal energy consumption so that they can extend battery life of portable equipment [4,6,7] or sports equipment.

In this paper we present a novel algorithm to detect QRS complexes in ECG signals with very low computational complexity. In Section 2 we review some of the methods described in the literature that should be avoided in order to reduce the computational complexity and energy consumption of a QRS detector. Then, Section 3 describes the various processing steps we apply to the signal to detect the heart beats, including the novel MaMeMi filter used to remove the low frequency noise caused by the baseline wander, and the following steps to finally detect the QRS peaks.

Once the method is presented, Section 4 describes the performance obtained by the algorithm when tested against the MIT/BIH ECG database. Section 5 gives more details about the low resource cost of the algorithm implementation. Finally Section 6 presents the conclusions.

In this paper we analyze detectors that process digitized ECG data like those present in MIT/BIH. On such data detection is usually a two step process, first a filtering step to remove noise and enhance signal so that QRS complex become clean pulses, and then a second step that analyze the pulses to determine if they are QRS complexes.

The frequency components of the QRS complex range from 10Hz to 25Hz. So, most algorithms filter out high and low frequency noise.

Low frequency noise can be removed by different high pass filtering techniques [8–10]. High pass FIR filters for low cutoff frequencies require a large number (let be n) of taps. This kind of filters require n fixed point multipliers and adders that must compute for each sample. This means that at least 2·n operations are needed for each sample. On the other hand, IIR filters usually need floating point coefficients, hence require floating point multipliers. The downfall of this method is that it takes too much resources in a hardware design or too many clock cycles of a integer microcontroller. Another method to remove the baseline is the subtraction of the median over a window from the signal ([11]). This is an ineffective strategy since the sorting of a signal window must be done for every sample, so for a window of n samples n
                     2 operations are needed.

For high frequency removal similar problems can arise, although the number of taps is usually lower. A possible technique to remove high frequency noise is the usage of morphological operators as described in [15]. Their principle is simple, but they need to access several values of the input signal for each sample. Common designs combine up to 8 concurrent filters of this kind. So the number of needed operations per sample is not very low.

On the enhancement phase some techniques (used in [12]) include the squaring of the signal. The use of multipliers should be avoided if possible to minimize the resource and energy costs. Other methods (also used in [12]) use the integration of the signal over a window of n samples, which is again requiring n operations for each sample of the signal.

Wavelet transform based methods [13] are also computationally expensive. Hilbert transformation [14], that shows very good results, is also prohibitive since it requires computing FFT over a window for every sample.

We propose a novel algorithm to be applied in real-time over ECG signals. Like few similar proposals, it consists of a filtering procedure coupled with enhancement phase, followed by a detection phase resulted after several applied criteria. A diagram of the process is shown in Fig. 2
                     .

The differentiation factor from known methods in proposed one is the use of a new filter to reduce low frequency noise. The detection phase is similar to many other works [3]. The computational cost of most of the algorithms is devoted to the first filtering and enhancement phase. In our case the computational cost is highly reduced, making it very attractive for its application in battery operated devices.

To remove the base wander, we have designed a high pass non-linear filter. We called it MaMeMi, from maximum mean minimum. The principle is very similar to [11], i.e. subtract a low-pass filtered version of the signal from the original signal to take the higher frequency components. As stated in Section 2, [11] proposes a median filter to get the signal to subtract, which is a computationally costly operation of the order n
                        2 operations per sample, being n the width of the window used to compute the median. Other works proposed a similar approach using a standard FIR or IIR filter to get the signal subtract. Again this is a computationally costly operation of the order 2·n per sample, being n the number of taps of the filter. In our case we propose to subtract the mean between the moving maximum and minimum values of the signal. Let x(t) be the discrete time function of the digitized ECG input signal, the filter output h(t) is defined by Eq. (1).
                           
                              (1)
                              
                                 
                                    h
                                    (
                                    t
                                    )
                                    =
                                    x
                                    (
                                    t
                                    )
                                    −
                                    
                                       
                                          
                                             ma
                                          
                                          
                                             
                                                x
                                             
                                             *
                                          
                                          (
                                          t
                                          )
                                          +
                                          
                                             mi
                                          
                                          
                                             
                                                n
                                             
                                             *
                                          
                                          (
                                          t
                                          )
                                       
                                       2
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       ma
                                    
                                    
                                       
                                          x
                                       
                                       *
                                    
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      x
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      t
                                                      =
                                                      0
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         ma
                                                      
                                                      
                                                         
                                                            x
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                      +
                                                      σ
                                                      ⋅
                                                      Δ
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      x
                                                      (
                                                      t
                                                      )
                                                      >
                                                      
                                                         ma
                                                      
                                                      
                                                         
                                                            x
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         ma
                                                      
                                                      
                                                         
                                                            x
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                      −
                                                      Δ
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      x
                                                      (
                                                      t
                                                      )
                                                      ≤
                                                      
                                                         ma
                                                      
                                                      
                                                         
                                                            x
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       mi
                                    
                                    
                                       
                                          n
                                       
                                       *
                                    
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      x
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      t
                                                      =
                                                      0
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         mi
                                                      
                                                      
                                                         
                                                            n
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                      −
                                                      σ
                                                      ⋅
                                                      Δ
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      x
                                                      (
                                                      t
                                                      )
                                                      <
                                                      
                                                         mi
                                                      
                                                      
                                                         
                                                            n
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         mi
                                                      
                                                      
                                                         
                                                            n
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                      +
                                                      Δ
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      x
                                                      (
                                                      t
                                                      )
                                                      ≥
                                                      
                                                         mi
                                                      
                                                      
                                                         
                                                            n
                                                         
                                                         *
                                                      
                                                      (
                                                      t
                                                      −
                                                      1
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In order to obtain the real extrema of x(t) over a window of n samples we would need n comparisons for each sample, and this is precisely the amount of computation that we wanted to avoid. We used pseudo-extrema functions instead that need just one comparison and one operation per sample. We called them max* and min*. They are defined in Eqs. (2) and (3) respectively. The principle of operation of the max*(t) is as follows: we kept a variable with the current maximum, if the value of the input function x(t) is equal or lower than the current maximum, we decreased the current maximum by a factor Δ. If the value of the input function x(t) is higher we then increase the current maximum by a factor σ·Δ. We interpreted that max*(t) tries to follow the maximum value of x(t) with some decay over time. The higher the factor σ is, the faster max*(t) will follow the maximum of x(t). The higher the factor Δ is, the faster the decay will occur. Function min*(t) is defined similarly. The selection of the best values for σ and Δ is not straightforward since the filter response depends, besides former parameters, on the amplitude of the signals being filtered. The MIT-BIH database was sampled with 11bit resolution over a range of 10mV. Heart beats appear as pulses of approximately 1mV, which become pulses of around 200units in the digitized signal.

The filter response for sinusoidal signals ranging from 0 to 50Hz is shown in Fig. 3
                        . To illustrate the different response to different signal amplitudes we show some discrete amplitude values: 10, 19, 55, and 208. Extrema of low amplitude signals are more easily followed and the pseudo-mean is closer to the input signal, so when removing it from the input signal the signal is highly attenuated for a wide range of frequencies. Extrema of high amplitude signals is more difficult to follow. In this case the pseudo-mean changes more slowly with the input signal and by a smaller magnitude. For higher frequencies the change is small than the input signal is hardly attenuated. On the contrary for lower frequencies the pseudo-mean has enough time to follow the input signal, and the filter perfectly attenuates it. If we focus on the amplitude of the input signal, the higher the amplitude, the sharper the high-pass filter becomes, and the lower its cut-off frequency. If we increase the value of σ the cut-off frequency increases and the filter becomes smoother. Increasing the value of Δ, the filter becomes smoother without affecting much the cut-off frequency.

However, the analysis of the filter response to constant sinusoidal signals is not directly applicable in this case since ECG signals are characterized by pulsed activity. Moreover, non-linear filters have transient dynamics not captured by frequency response analysis. To find a good filter parameters we have empirically tested a set of combinations for σ and Δ and measured the performance of the whole QRS detector. The parameters that have shown best results are σ
                        =2 and Δ
                        =2.

The MaMeMi filter can effectively remove the baseline wander as shown in Fig. 4
                        . It also reduces the T wave, which is actually interesting to minimize the efforts to discriminate between R peaks and T peaks.

Some additional interesting properties of the max* and min* functions are that they do not react quickly to follow the maximum when a sharp pulse occurs, but they can be used to sense the amplitude of a high frequency signal. We can use the a(t) range function as defined in Eq. (4) to sense the amplitude of such signals.
                           
                              (4)
                              
                                 
                                    a
                                    (
                                    t
                                    )
                                    =
                                    
                                       ma
                                    
                                    
                                       
                                          x
                                       
                                       *
                                    
                                    (
                                    t
                                    )
                                    −
                                    
                                       mi
                                    
                                    
                                       
                                          n
                                       
                                       *
                                    
                                    (
                                    t
                                    )
                                 
                              
                           
                        
                     

Although this is not totally correct, we can interpret this signal as being the envelope of high frequency noise. Then, we can subtract this pseudo-noise amplitude from signal to try to reduce the effect of high frequency noise. The filtered signal n(t) after noise reduction is defined by Eq. (5).
                           
                              (5)
                              
                                 
                                    n
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      s
                                                      i
                                                      g
                                                      n
                                                      (
                                                      h
                                                      (
                                                      t
                                                      )
                                                      ⋅
                                                      (
                                                      |
                                                      h
                                                      (
                                                      t
                                                      )
                                                      |
                                                      −
                                                      a
                                                      (
                                                      t
                                                      )
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                       
                                                      a
                                                      (
                                                      t
                                                      )
                                                      ≤
                                                      |
                                                      h
                                                      (
                                                      t
                                                      )
                                                      |
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Since max* and min* do not react fast to sharp pulses like the R peak, this operation does not suppress the R peaks (Fig. 5
                        ).

The QRS complex is usually described by a step positive pulse, i.e. a high peak in a neighborhood of lower values. The duration of the pulse is determined by physical constraints, and it is commonly in the range of 0.06–0.12s. To improve the detection of the pulse we propose a method that, for each sample, compares two samples situated β samples before and β samples after the current sample. If the three compared samples form a triangular peak on the positive range or a triangular valley in the negative one, we will measure its height. This logic is expressed in Eq. (6).
                           
                              (6)
                              
                                 
                                    g
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      n
                                                      (
                                                      t
                                                      )
                                                      −
                                                      
                                                         max
                                                      
                                                      (
                                                      n
                                                      (
                                                      t
                                                      −
                                                      β
                                                      )
                                                      ,
                                                      n
                                                      (
                                                      t
                                                      +
                                                      β
                                                      )
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      (
                                                      n
                                                      (
                                                      t
                                                      )
                                                      >
                                                      0
                                                      )
                                                      ∧
                                                      (
                                                      n
                                                      (
                                                      t
                                                      −
                                                      β
                                                      )
                                                      <
                                                      n
                                                      (
                                                      t
                                                      )
                                                      >
                                                      n
                                                      (
                                                      t
                                                      +
                                                      β
                                                      )
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      n
                                                      (
                                                      t
                                                      )
                                                      +
                                                      
                                                         min
                                                      
                                                      (
                                                      n
                                                      (
                                                      t
                                                      −
                                                      β
                                                      )
                                                      ,
                                                      n
                                                      (
                                                      t
                                                      +
                                                      β
                                                      )
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                   
                                                
                                                
                                                   
                                                      (
                                                      n
                                                      (
                                                      t
                                                      )
                                                      <
                                                      0
                                                      )
                                                      ∧
                                                      (
                                                      n
                                                      (
                                                      t
                                                      −
                                                      β
                                                      )
                                                      >
                                                      n
                                                      (
                                                      t
                                                      )
                                                      <
                                                      n
                                                      (
                                                      t
                                                      +
                                                      β
                                                      )
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                    
                                                
                                                
                                                   
                                                      o
                                                      t
                                                      h
                                                      e
                                                      r
                                                      w
                                                      i
                                                      s
                                                      e
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The formerly mentioned typical duration of heart beat pulses is equivalent to 21–42 samples, when sampling at 360Hz. Since β should be close to the half of the loop, we measure empirically which value of β between 10 and 21 minimizes the detection error rate of the whole QRS detector. The obtained value is β
                        =15.

As shown in Fig. 6
                        , the triangular detector filter effectively reduces wide pulses, which are often caused by baseline drifts or big T waves.

Not all the samples in the g(t) signal are significant to detect the QRS complexes. In fact, due to the various morphologies of QRS complexes the R peaks can come as positive pulses or negative ones. We can filter out the values that are not interesting, and focus only on the potential R peaks. Potential R peaks are defined by being either local maxima (peaks) in the positive range, or local minima (valleys) in the negative range. Since the definition of local extreme for discrete functions can be ambiguous we defined exactly what points will be considered maxima and minima for the g(t) time function.

We define a new operator 
                           
                              <
                              ⌢
                           
                         in Eq. (7) to determine that f(i)<
                        f(j) and that between those two points in time there is no higher value of function f than f(j). Similarly we have defined the 
                           
                              >
                              ⌢
                           
                         operator in Eq. (8) to determine that f(i)>
                        f(j) and that between those two points in time there is no higher value of function f than f(i).
                           
                              (7)
                              
                                 
                                    f
                                    (
                                    i
                                    )
                                    
                                       <
                                       ⌢
                                    
                                    f
                                    (
                                    j
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      true
                                                   
                                                
                                                
                                                   
                                                      i
                                                      f
                                                       
                                                      i
                                                      <
                                                      j
                                                      ∧
                                                      f
                                                      (
                                                      i
                                                      )
                                                      <
                                                      f
                                                      (
                                                      j
                                                      )
                                                      ∧
                                                      f
                                                      (
                                                      k
                                                      )
                                                      ≤
                                                      f
                                                      (
                                                      j
                                                      )
                                                       
                                                      ∀
                                                      k
                                                      ∈
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      false
                                                   
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    f
                                    (
                                    i
                                    )
                                    
                                       >
                                       ⌢
                                    
                                    f
                                    (
                                    j
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      true
                                                   
                                                
                                                
                                                   
                                                      if
                                                       
                                                      i
                                                      <
                                                      j
                                                      ∧
                                                      f
                                                      (
                                                      i
                                                      )
                                                      >
                                                      f
                                                      (
                                                      j
                                                      )
                                                      ∧
                                                      f
                                                      (
                                                      k
                                                      )
                                                      ≥
                                                      f
                                                      (
                                                      j
                                                      )
                                                      ∀
                                                      k
                                                      ∈
                                                      (
                                                      i
                                                      ,
                                                      j
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      false
                                                   
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Given previous definitions local maxima and local minima are defined by Eqs. (9) and (10) respectively. In our definition, a local maximum of a discrete time function is a sample such that the next sample is lower, and that there exists a lower previous sample with no higher samples in between. The benefit from this definition is that it supports situations were the maximum value remains constant for several samples, which is a situation that can easily happen in sampled signals.
                           
                              (9)
                              
                                 
                                    r
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      g
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                       
                                                      ∃
                                                      i
                                                      >
                                                      0
                                                      |
                                                      g
                                                      (
                                                      t
                                                      −
                                                      i
                                                      )
                                                      
                                                         <
                                                         ⌢
                                                      
                                                      g
                                                      (
                                                      t
                                                      )
                                                      >
                                                      g
                                                      (
                                                      t
                                                      +
                                                      1
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   ∅
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    v
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      g
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                       
                                                      ∃
                                                      i
                                                      >
                                                      0
                                                      |
                                                      g
                                                      (
                                                      t
                                                      −
                                                      i
                                                      )
                                                      
                                                         >
                                                         ⌢
                                                      
                                                      g
                                                      (
                                                      t
                                                      )
                                                      <
                                                      g
                                                      (
                                                      t
                                                      +
                                                      1
                                                      )
                                                   
                                                
                                             
                                             
                                                
                                                   ∅
                                                
                                                
                                                   
                                                      otherwise
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     


                        Fig. 7
                         shows how detected peaks (crosses) and valleys (circles) are detected from the input signal g(t).

As we recently stated in previous subsection QRS complexes can be positive peaks or negative valleys. So we can discard peaks in the negative range and valleys from the positive range. In addition, we can unify them by changing the sign of valleys in the negative range to become positive peaks. This simplifies the following detection step as it has considered a single threshold in the positive range. In some proposed algorithms (like [12]) this is done by squaring the signal. In our prototype we want to avoid the multiplication operation as it has a higher cost than adding or subtracting. The simple unification time function is described by Eq. (11).
                           
                              (11)
                              
                                 
                                    w
                                    (
                                    t
                                    )
                                    =
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      r
                                                      (
                                                      t
                                                      )
                                                       
                                                      if
                                                       
                                                      r
                                                      (
                                                      t
                                                      )
                                                      >
                                                      0
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      −
                                                      v
                                                      (
                                                      t
                                                      )
                                                       
                                                      if
                                                       
                                                      v
                                                      (
                                                      t
                                                      )
                                                      <
                                                      0
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Heart beats can be identified by peaks of w(t) that are higher than a certain threshold. The amplitude of the beat pulses is normally constant in the range of some mV. But, this amplitude can be altered because of physiological causes or even because of the processes that have been applied and that were originally intended to enhance the input signal. Most QRS detection algorithms use an adaptive threshold that is able to detect the range of the pulses and modify the threshold accordingly. In our algorithm we use an adaptive threshold. Peaks below that threshold are considered as “noise”.

The width of the QRS complex is usually considered constant, and there is some probability factor that the heart rate does not vary very significantly from beat to beat. We have information on the maximum and minimum possible rates of the human heart. With all this information we define the following criteria:
                           
                              (1)
                              
                                 Criterion 1
                              

A peak higher than the threshold is considered as potential detectable heart beat. Lower peaks are considered noise. Threshold is adaptively updated as the mean of the last 5 detected beats.


                                 Criterion 2
                              

QRS pulses are usually from 0.06 to 0.12s wide. After a peak is detected if another higher peak is detected inside this time window, the higher one is considered as a valid heart beat, discarding the previous one.


                                 Criterion 3
                              

Highest possible heart rate is around 220 beats per minute. After a QRS pulse is detected, it assumed it is physiologically impossible for another beat to occur before 0.27s. Peaks detected after the maximum QRS width and before this refractory period expires are considered noise.


                                 Criterion 4
                              

The period between consecutive beats can vary to a certain degree, but it is usually limited to a range. We empirically observed this variability to 85% of the previous period. So peaks that happened out of this allowed variability range are considered noise.


                                 Criterion 5
                              

If noise was detected from the last pulse, then consider beat as noise if the beat is smaller than the maximum noise peak plus the threshold, or smaller than the last detected beat minus the threshold.

All the previous criteria are taking into account and described by the flow chart in Fig. 8
                        .

@&#EXPERIMENTAL RESULTS@&#

The MIT/BIH arrhythmia database [2] is used to evaluate the performance of the algorithm. It contains 48 half-hour two-channel ambulatory ECG tape recordings recorded at 360Hz sampling frequency with 11bit resolution over ±5mV range. The database also includes annotations with the occurrences of all heart beats and other interesting information.

To evaluate the detection performance, true positive (TP), false positive (FP), false negative (FN) are used. A true positive happens when an annotated beat is correctly detected for a certain instant. A false positive happens when a beat has been detected in a certain instant, but no beat has been annotated in the database for that instant. A false negative happens when the database reports a beat for a certain instant but the algorithm fails to detect it. With this values we derive the metrics of sensitivity (Se), positive prediction (+P), and detection error, which are defined by Eqs. (12), (13) and (14) respectively.
                        
                           (12)
                           
                              
                                 Se
                                  
                                 (
                                 %
                                 )
                                 =
                                 
                                    
                                       TP
                                    
                                    
                                       TP
                                       +
                                       FN
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (13)
                           
                              
                                 +
                                 P
                                  
                                 (
                                 %
                                 )
                                 =
                                 
                                    
                                       TP
                                    
                                    
                                       TP
                                       +
                                       FP
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (14)
                           
                              
                                 DER
                                 (
                                 %
                                 )
                                 =
                                 
                                    
                                       FP
                                       +
                                       FN
                                    
                                    
                                       Total QRS
                                    
                                 
                              
                           
                        
                     
                  


                     Table 1
                      reports the performance of the algorithm on all the MIT/BIH database recordings. We have considered all annotated beats in the annotation files from the MIT/BIH. They give a total number of 109,494 annotated beats.

The detector gives very good results on most records, except on records 108, 203, and 207. The detection errors on record 108 are mainly caused by high frequency noise. Record 203 is also affected by some high frequency noise bus also by some sudden changes of the amplitude of some beat pulses that do not reach threshold levels, producing false negatives. Finally we get significant false positive errors in record 207 during the flutter episodes.


                     Table 2
                      reports the sensibility, positive prediction and detection error rate for the proposed algorithm and compares it with other high quality algorithms. It must be noted that our method is above the 99% threshold for Se and +P that is used in [3] to classify good quality algorithms. We report the performance of the full algorithm but also the performance obtained when the triangular filter is not used. The reason for this is that the triangular filtering uses more resources than the rest of the algorithm, and, if we focus on a very low power implementation, the performance loss is not that much significant considering the resource savings. Moreover, without the triangular filter the algorithm is still considered a high quality one.

@&#IMPLEMENTATION@&#

All the methods are suitable for its implementation on portable embedded systems. The resource needs in terms of computational elements and storage elements of every processing step are described in Table 3
                     .

The algorithm can be effectively implemented in hardware. The MaMeMi filter basically needs two registers to store the max* and min* values and some comparators to check if the input signal is higher or lower than the registered values. The range-module actually reuse these values to compute the output. Triangular filter is costly in terms of storage because a delay line must be build to compare the samples to the right and left of the sample of interest. Nevertheless, it could be sacrificed if the lower detection performance can be tolerated. Peak and valley detection is simply implemented by using comparators and simple finite state machines. Beat unification is straightforward. Finally beat detection is implemented with a simple algorithmic machine.

Compared with state of the art portable implementations (see Table 4
                     ), our algorithm is competitive. The number of resources is similar to or lower than the alternative proposals, although detection performance is slightly lower. We include the work from [19] as a reference although it has not been tested against the MIT-BIH.

High performance detectors that are not specifically targeting portable devices use some of the techniques mentioned in Section 2, consuming much more resources. For instance, just a step of the Pam & Tompkins algorithm [12] needs to compute the square root, which need much more resources than our full implementation.

@&#CONCLUSION@&#

We have presented the MaMeMi filter, a non-linear high pass filter useful to remove ECG baseline wander. We have created a simple QRS detector based on this filter with minimal resource needs. The algorithm is easily implementable both in software and in hardware.

The algorithm is tested against the MIT/BIH database achieving a detection rate of 99.22%, a sensitivity of 99.43% and a positive prediction of 99.67%.

@&#ACKNOWLEDGMENTS@&#

This work is partially supported by the EU FP7 DocuMeet Project http://www.documeet.eu/the-project. We would like to express our thanks to Dr. Chit Cheng Yeoh for her support and fruitful discussions.

@&#REFERENCES@&#

