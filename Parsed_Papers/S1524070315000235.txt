@&#MAIN-TITLE@&#Smooth convolution-based distance functions

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Smoothing a triangle mesh by constructing an implicit convolution-based surface.


                        
                        
                           
                           Both the convolution kernel and the implicitization of the mesh are linearized.


                        
                        
                           
                           The straight skeleton is used to linearize the mesh.


                        
                        
                           
                           The resulting distance function is globally C
                              2 continuous.


                        
                        
                           
                           It can be explicitly analytically evaluated.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Implicit surface

Convolution

Signed distance function

Straight skeleton

Analytical solution

@&#ABSTRACT@&#


               
               
                  Smooth surface approximation is an important problem in many applications. We consider an implicit surface description which has many well known properties, such as being well suited to perform collision detection. We describe a method to smooth a triangle mesh by constructing an implicit convolution-based surface. Both the convolution kernel and the implicitization of the mesh are linearized. We employ the straight skeleton to linearize the latter. The resulting implicit function is globally C
                     2 continuous, even for non-surface points, and can be explicitly analytically evaluated. This allows the function to be used in simulation systems requiring C
                     2 continuity, for which we give an example from industrial simulation, in contrast to methods which only locally smooth the surface itself.
               
            

@&#INTRODUCTION@&#

In many applications smooth surface approximation of triangular networks is an important problem. Variational design [16] is a standard technique to solve these kinds of problems. Usually B-spline surfaces are targeted. Well known methods dealing with explicit surface representations, such as corner cutting, lead to B-spline patches or more generally subdivision surfaces [11]. Other methods employ fairing of the meshes while still keeping a mesh structure [13]. Another possible way to represent surfaces is as implicit functions. Implicit surfaces have proven to be a powerful tool in surface design [9,26,29]. When the surfaces represent the boundaries of solids, it is often important to efficiently determine the inside and outside of the solids. This can easily be achieved with implicit surfaces using a sign check [25].

Our goal is to get a smooth approximation of the polygonal mesh while still being able to control the original mesh interpolating surface. Therefore we introduce a feature size parameter that controls the smoothing effect. Another constraint on our implicit representation, motivated by the application presented in Section 7, is being able to compute gradients and second derivatives and to perform collision detections (inside/outside checks) for non-surface points.

We certainly could create smooth surfaces with rather good approximation quality using subdivision surfaces, but as we aim to use an implicit surface description, a global implicitization would require an expensive computation. The smoothing effect would also be local and would affect only a small neighborhood of the surface (cf. [21] Section 2.3).

The main contribution of this paper therefore is presenting a convolution-based implicit surface definition for triangle meshes, whose underlying distance function is globally smooth even on non-surface points. We employ linearizations that allow the function to be computed analytically. The linear kernel used is not novel, but to our knowledge its use in this context is. Notable prior work are Bloomenthal’s convolution surfaces [8] and Colburn’s smoothing method [12]. Differences to our approach are detailed below.

Whenever it aids visualization or discussion, figures show the equivalent 2-d representation of our method. Fully 3-d images are given where necessary, see also Section 6. We also concentrate on triangle meshes only, since polygon meshes can be converted to triangle meshes easily. Fig. 1
                     
                      shows the result of our method applied to a solid in 2-d. While the signed minimum distance function has cusps where it is not differentiable, our smoothed distance field is C
                     2 everywhere. This cannot be achieved by only smoothing out the solid’s edges and then computing the signed minimum distance, as this would still lead to cusps not lying on the surface.

This paper is structured as follows: in Section 2 we give a brief survey of implicit functions and describe a convolution-based smoothing approach. Our choice for a linearized kernel is described in detail in Section 3. In Section 4 we give a brief survey of the straight skeleton as described by Aichholzer et al. and use it to give an implicit surface definition. We discuss the approximation quality of the resulting surface in Section 5, give results of smoothed surfaces in Section 6, and present an application in Section 7.

Implicit functions are widely used tools to describe surfaces and solids in geometric modeling. In the most general form, an implicit surface is the iso-surface of a potential field F for an iso-value T:

                        
                           (1)
                           
                              
                                 F
                                 (
                                 x
                                 )
                                 −
                                 T
                                 =
                                 0
                                 .
                              
                           
                        
                     Solids can be described as the interior of an implicit surface, i.e. all points x for which 
                        
                           F
                           (
                           x
                           )
                           −
                           T
                           ≤
                           0
                        
                     . CSG operations, such as union and intersection of different solids, can then be implemented easily as min  and max  operations.

Convolution surfaces, as first described by Bloomenthal and Shoemake [8], are implicit surfaces based on skeleton primitives like lines and triangles. The resulting surfaces are a smooth blend of iso-potentials around the primitives, but do not approximate the original mesh in the way we intend. The convolution integrals for these surfaces are mostly computed by a numerical scheme. A different approach is Colburn’s method [12], who does corner smoothing by a numerical convolution of a solid’s characteristic function with a Gaussian function. Our method employs a linearization of the convolution kernel as well as an implicit description of the triangle-manifold. This allows us to exactly evaluate the implicit function without reverting to numerical methods, in contrast to the numerical integration needed for Colburn’s approach.

Bloomenthal and Shoemake describe convolution surfaces as an extension of Blinn’s blobby model [7] for implicit surface design. They employ a convolution of a filter kernel over a skeleton to create a surface. The resulting surfaces resemble the skeleton, but surround it instead of approximating it. Fig. 2 schematically illustrates the conceptual difference between convolution surfaces on the one hand and the surfaces created by Colburn’s method and ours on the other hand. Bloomenthal’s convolution surfaces integrate over skeletons only, whereas we integrate over the complete domain of the implicit function. While both methods nicely round the corners of the square, convolution surfaces create an exterior and interior surface offsetted from the original skeleton. The innermost area has the same sign as the outside area. Thus, in our scenario convolution surfaces cannot simply be applied to a solid’s boundary, because, without further computation, they do not lead to a signed distance function to discriminate inside and outside.

To apply a convolution-based smoothing, we first have to convert the explicitly given triangle mesh to an implicit representation. The straightforward way for implicitizing a given triangle mesh Δ is using the signed minimum Euclidean distance function

                        
                           (2)
                           
                              
                                 f
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    s
                                    Δ
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 
                                    min
                                    
                                       p
                                       ∈
                                       Δ
                                    
                                 
                                 
                                    ∥
                                    x
                                    −
                                    p
                                    ∥
                                 
                                 ,
                              
                           
                        
                     where the sign function 
                        
                           
                              s
                              Δ
                           
                           
                              (
                              x
                              )
                           
                        
                      corresponds to x lying either inside or outside the solid. Partitioning the space like this turns out to be very useful. Only the sign of the distance function has to be evaluated to determine if a point lies inside or outside a volume enclosed by the surface. The zero level set of this function represents the surface. A characteristic function of the solid, effectively the same as 
                        
                           
                              s
                              Δ
                           
                           
                              (
                              x
                              )
                           
                           ,
                        
                      would be even simpler but does not have gradients at all.

The function f defined in Eq. 2 is C
                     0 continuous. It can be described by the generalized Voronoi diagram of the triangle mesh. The Voronoi diagram partitions the domain of f into regions where it is linear (distance to a triangle plane) or square-root (distance to a triangle edge or corner). Thus, inside these regions, the function is smooth but not differentiable along the borders. The borders of these regions are made up of straight polygonal segments and conic surface patches.

Our goal is now to smooth out those parts of the function where it is not differentiable. This inherently implies smoothing out the edges of the mesh. One way to achieve this is using a convolution and so increasing the smoothness. Convolution with an appropriate kernel K results in a smoother surface 
                        
                           h
                           =
                           K
                           ☆
                           f
                        
                      as:

                        
                           (3)
                           
                              
                                 h
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    (
                                    K
                                    ☆
                                    f
                                    )
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    ∫
                                    
                                       
                                          R
                                       
                                       d
                                    
                                 
                                 K
                                 
                                    (
                                    x
                                    −
                                    p
                                    )
                                 
                                 
                                 f
                                 
                                    (
                                    p
                                    )
                                 
                                 
                                 
                                    d
                                 
                                 p
                                 .
                              
                           
                        
                     The smoothness of the resulting function h is determined by both the kernel used and the implicit function f. We will therefore describe how to choose these to achieve C
                     2 continuity while being able to compute the results analytically.

Common choices for kernel functions K are the Gauss function combined with the L
                     2 norm to obtain a radially symmetric kernel. The Gauss function can also be replaced by a cubic spline with compact support. An analysis of different kernel functions (in the context of convolution surfaces) is given by Sherstyuk [27]. For all kernels except for the Cauchy kernel, the resulting integrals over triangles are then numerically approximated. Recently, Jin et al. [20] gave analytical solutions for a quartic spline with compact support. They too are, however, using the skeleton approach of Bloomenthal integrating over triangles, whereas we give analytical solutions for integrals over tetrahedra.

Using the generalized Voronoi diagram, we can partition 
                        
                           R
                           3
                        
                      into regions Ri
                      such that f is partitioned into functions 
                        
                           
                              f
                              i
                           
                           
                              
                                 =
                                 f
                                 |
                              
                              
                                 R
                                 i
                              
                           
                        
                      which are linear or square-root. The convolution integral is then just the sum over the regions Ri
                     :

                        
                           (4)
                           
                              
                                 h
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    ∫
                                    
                                       R
                                       i
                                    
                                 
                                 K
                                 
                                    (
                                    x
                                    −
                                    p
                                    )
                                 
                                 
                                 
                                    f
                                    i
                                 
                                 
                                    (
                                    p
                                    )
                                 
                                 
                                 
                                    d
                                 
                                 p
                                 .
                              
                           
                        
                     This allows us to express the integration in simpler terms than the piecewise global definition, but does not suffice to analytically evaluate the integral. Therefore, we employ a linearization of both the kernel K and implicit description of the mesh f in the following.

We simplify the convolution integrals by linearizing both the filter kernel K and the underlying implicit distance function f. Using a C
                     0 function f and a C
                     0 convolution kernel K we obtain a C
                     2 implicit surface. We base our kernel on the one-dimensional hat function:

                        
                           (5)
                           
                              
                                 k
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 max
                                 
                                    (
                                    1
                                    −
                                    
                                       |
                                       x
                                       |
                                    
                                    ,
                                    0
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                1
                                                −
                                                
                                                   |
                                                   x
                                                   |
                                                
                                             
                                          
                                          
                                             
                                                for
                                                
                                                
                                                   |
                                                   x
                                                   |
                                                
                                                ≤
                                                1
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             0
                                          
                                          
                                             otherwise.
                                          
                                       
                                    
                                 
                              
                           
                        
                     We could achieve even higher continuity by using a kernel of higher degree. For example, a cubic or quartic C
                     1 kernel leads to a C
                     3 surface but also has higher computational costs.

The usual approach to create a multi-dimensional version of the kernel is to use the L
                     2 norm of the vector as input. This creates a radially symmetric kernel with a spherical (or in the 2-d case circular) support.

We want instead to use a kernel with cubic support to allow easier integration. Two possibilities to create a 3-dimensional convolution kernel are to use the maximum norm 
                        
                           K
                           
                              (
                              x
                              ,
                              y
                              ,
                              z
                              )
                           
                           =
                           k
                           
                              (
                              max
                              
                                 (
                                 
                                    |
                                    x
                                    |
                                 
                                 ,
                                 
                                    |
                                    y
                                    |
                                 
                                 ,
                                 
                                    |
                                    z
                                    |
                                 
                                 )
                              
                              )
                           
                           =
                           min
                           
                              (
                              k
                              
                                 (
                                 x
                                 )
                              
                              ,
                              k
                              
                                 (
                                 y
                                 )
                              
                              ,
                              k
                              
                                 (
                                 z
                                 )
                              
                              )
                           
                        
                      or the product 
                        
                           K
                           (
                           x
                           ,
                           y
                           ,
                           z
                           )
                           =
                           k
                           (
                           x
                           )
                           k
                           (
                           y
                           )
                           k
                           (
                           z
                           )
                        
                      of the 1-dimensional kernel values. The max-version is piecewise linear, its support can be split up into six pentahedral regions where it is linear. The tensor product version has the advantage of being separable. Its support is trilinear on cubic regions. Fig. 3
                      shows the 2-d equivalents of these kernels for easier visualization. We use the tensor product kernel, although the same approach works for the max kernel. The first and second partial derivatives can be computed as a convolution with the corresponding derivatives of the kernel, where δ is the Dirac delta function:

                        
                           (6)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             k
                                             ′
                                          
                                          
                                             (
                                             x
                                             )
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         −
                                                         sign
                                                         (
                                                         x
                                                         )
                                                      
                                                   
                                                   
                                                      
                                                         for
                                                         
                                                         
                                                            |
                                                            x
                                                            |
                                                         
                                                         ≤
                                                         1
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      0
                                                   
                                                   
                                                      otherwise,
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             k
                                             
                                                ′
                                                ′
                                             
                                          
                                          
                                             (
                                             x
                                             )
                                          
                                          =
                                          δ
                                          
                                             (
                                             x
                                             −
                                             1
                                             )
                                          
                                          −
                                          2
                                          δ
                                          
                                             (
                                             x
                                             )
                                          
                                          +
                                          δ
                                          
                                             (
                                             x
                                             +
                                             1
                                             )
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

We trade ease of integration for isotropy by not using a radially symmetric kernel. The convolution has a certain anisotropy. That means it is not rotation invariant but depends on the coordinate system. Normally this is an undesirable feature, but it does not affect the result in a significant way. We will get back to this in Section 5.

To control the approximation quality we scale the hat function given in Eq. 5 by a parameter r:

                        
                           (7)
                           
                              
                                 
                                    k
                                    r
                                 
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    1
                                    r
                                 
                                 max
                                 
                                    (
                                    1
                                    −
                                    
                                       
                                          |
                                          x
                                          |
                                       
                                       r
                                    
                                    ,
                                    0
                                    )
                                 
                                 .
                              
                           
                        
                     and its corresponding higher dimensional version Kr
                      of the kernel. It is obvious that the value h(x) for a point x is influenced only by those values of f that lie inside the kernel’s support. Thus, we can consider the parameter r as a feature size parameter which determines how large the smoothed out parts of the surface are.

Given this kernel we get the following convolution equation:

                        
                           (8)
                           
                              
                                 
                                    
                                       
                                          h
                                          (
                                          x
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             (
                                             
                                                K
                                                r
                                             
                                             ☆
                                             f
                                             )
                                          
                                          
                                             (
                                             x
                                             )
                                          
                                          =
                                          
                                             ∫
                                             
                                                R
                                                3
                                             
                                          
                                          
                                             k
                                             r
                                          
                                          
                                             (
                                             x
                                             −
                                             s
                                             )
                                          
                                          
                                             k
                                             r
                                          
                                          
                                             (
                                             y
                                             −
                                             t
                                             )
                                          
                                          
                                             k
                                             r
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          ×
                                          
                                          (
                                          z
                                          −
                                          u
                                          )
                                          f
                                          (
                                          s
                                          ,
                                          t
                                          ,
                                          u
                                          )
                                          
                                          
                                             d
                                          
                                          s
                                          
                                          
                                             d
                                          
                                          t
                                          
                                          
                                             d
                                          
                                          u
                                          .
                                       
                                    
                                 
                              
                           
                        
                     Using the separability of the kernel, this can be split up into 8 integrals at the boundaries concerning its piecewise definition, such that in each dimension the kernel arguments lie in either 
                        
                           [
                           −
                           r
                           ,
                           0
                           ]
                        
                      or [0, r]. This gives linear terms for the 1-d kernel. Computing these integrals then depends on the definition of the function f. Using f as defined in Eq. 2 gives a function that is a piecewise square-root function. Splitting up the integrals on the definition regions of f is thus not feasible because the borders of the regions are complex. Therefore, we give a linearized definition of f in the next section.

In this section we describe how to construct an implicit function f that allows us to exactly solve the convolution integrals. The Voronoi diagram of the minimum distance function as given in Eq. 2 contains conic segments. As it is difficult to find exact solutions for integrals over these regions, Eq. 2 is not very suitable for the given task. We could overcome this by linearly approximating the Voronoi diagram by a set of tetrahedra (triangles for 2 dimensions). The original mesh is still correctly represented independent of the chosen tesselation as long as we guarantee that the zero level set is identical to the original mesh. The smoothed surface, however, does depend on the chosen tesselation.

An adaptive subdivision algorithm for approximating the generalized Voronoi diagram for triangles in three dimensions is given by Teichman and Teller [28]. This inevitably leads to a subdivision into many small cells for regions with high curvature. Rasterization-based approaches for two and three dimensions are given, for example, by Hoff et al. [17] as well as others. Numerical accuracy depends on the chosen resolution of the rasterization.

We will instead construct a function not based on Eq. 2 to use as an implicit mesh description. The function should have the property that it is continuous and piecewise linear, where the linear pieces should have polygonal boundaries and correspond to the signed distances to the planes spanning the mesh triangles. We therefore need a partition of space that allows such a construction. For 2-dimensional space, this partition is provided by the straight skeleton, which we describe first before discussing the 3-dimensional generalization.

The straight skeleton 
                        
                           S
                           (
                           P
                           )
                        
                      of a simple polygon P was introduced by Aichholzer et al. [1,2]. The skeleton structure is similar to a Voronoi diagram, but consists of straight line segments only (Fig. 4
                     ). The authors mention several other previous attempts to simplify the Voronoi diagram of straight line graphs, including Canny and Donald [10], and also that the straight skeleton itself has been used before in less general settings. The skeleton is identical to the Voronoi diagram for convex polygons. The situation is different for concave polygons, where the Voronoi diagram contains conic segments. The skeleton is defined by a wavefront propagation process where each edge of the polygon emits a wavefront traveling at constant speed orthogonal to the edge. This defines a family of offsetted polygons to P. At certain time points, called events, wavefronts meet and the topology of the offset polygon changes. The straight skeleton is then defined as the locus of the polygon vertices traced out by the wavefront propagation.

The straight skeleton can be computed by the algorithm given in [2] in theoretical worst-case time O(n
                     3log n) and a better average time for typical inputs. More complex and faster algorithms have been proposed in the literature. A detailed survey is given by Huber [18], who also gives an algorithm that runs in O(n
                     2log n) worst case and O(nlog n) for most typical inputs [19].

We use the straight skeleton to partition the plane into regions. Each face 
                        
                           F
                           (
                           e
                           )
                        
                      corresponding to an edge e defines a region where our function f is linear: 
                        
                           
                              
                                 f
                                 |
                              
                              
                                 F
                                 (
                                 e
                                 )
                              
                           
                           
                              (
                              x
                              )
                           
                           =
                           d
                           
                              (
                              x
                              ,
                              e
                              )
                           
                           ,
                        
                      where d( ·, e) is the signed distance function to the line spanning edge e. This corresponds to the terrain as defined by Aichholzer and Aurenhammer [2], which maps each point to the time it is reached by the wavefront. We use a signed distance instead to distinguish the interior and exterior of the surface. The function f thus defined is continuous, piecewise linear, and has a slope of at most 1 in any direction.

In the 3-dimensional case, we do not have line segments but polyhedral meshes. We have to compute a tetrahedral partition of 
                        
                           R
                           3
                        
                      induced by these meshes. A 3-dimensional generalization of the straight skeleton is first described by Barequet et al. [5]. Further analysis of the 3-dimensional skeleton is given by Aurenhammer and Walzl [4]. The skeleton is no longer uniquely defined for certain inputs. A unique way to define the skeleton is given in [4], although for our use case any choice seems sufficient. The resulting skeleton is a polyhedral mesh. Fig. 5
                      shows the skeleton of a T-shaped polyhedron (diagonals to subdivide quadrilaterals into triangles are not shown). Each triangle T of the input mesh is associated with a polyhedral face 
                        
                           F
                           (
                           T
                           )
                        
                     . We use these faces to partition space into regions analogous to the 2-dimensional case: we define the function f to be linear for each face as 
                        
                           
                              
                                 f
                                 |
                              
                              
                                 F
                                 (
                                 T
                                 )
                              
                           
                           
                              (
                              x
                              )
                           
                           =
                           d
                           
                              (
                              x
                              ,
                              T
                              )
                           
                           ,
                        
                      where d( ·, T) is the signed distance to the plane spanning triangle T. We can then use the convolution Eq. 8 to compute implicit C
                     2 surfaces in 3 dimensions. See Section 6 for examples.

The convolution integral is computed by summing up the integrals over the linear regions as in Eq. 4. This means clipping the cubic regions of the kernel’s support with the straight skeleton faces, tetrahedralizing the resulting volumes, and summing up the integrals over these tetrahedra.

Only a small number of the regions resulting from the straight skeleton will actually intersect with our convolution kernel. Thus, it is important to employ a space partioning scheme to quickly find only relevant regions. In our implementation, a simple Octree–based approach was sufficient, although, more complex schemes like a cell tree [14] could be useful for complex scenarios. The faces of a straight skeleton may be concave (they are monotonous but not necessarily convex). We can subdivide these into convex polygons first to simplify further processing. Thus, we can use a fast and simple algorithm to clip a convex polyhedron with an axis-aligned cube.
                        1
                     
                     
                        1
                        For the 2-dimensional analog, this corresponds to the Sutherland-Hodgman algorithm.
                      This again results in a convex polyhedron which is trivial to subdivide into tetrahedra.

The computational cost of evaluating the smooth distance function can be divided into two parts. The computation of the tetrahedra has to be done only once, while integrating over tetrahedra intersecting the smoothing region has to be done for each distinct input position for which the function is evaluated. The first part is dominated by the straight skeleton computation, which Barequet et al. give as O(kn), where n is the input size and k the number of events that occur. The cost of the actual function evalution is dependent on the data and the size of the smoothing kernel. Let m be the the number of tetrahedra intersecting the kernel’s domain, then for a single tetrahedron it takes O(log n) time to find the tetrahedron in the space partitioning structure, while integrating over it is bounded by constant time, resulting in a total of O(mlog n) to integrate over all tetrahedra. Depending on the kernel size, m is usually much smaller than n.
                  

In this section, we discuss the quality of the surface approximations depending on the feature size parameter r. If we want to perform an inside/outside check of a point x for collision detection, it suffices to determine the sign of h(x). Thus, we aim to find a value vr
                      depending on r, such that for values |f(x)| > vr
                      the sign of h(x) is guaranteed to be the same as the sign of f(x).

We note that, by construction of f using the straight skeleton
                        2
                     
                     
                        2
                        The same holds true for the min distance function of Eq. 2.
                     , the slope (where defined) of f in any direction is at most 1. Thus, we know that whenever |f(x)| has a value greater than half of the kernel’s diameter, all values in the kernel’s support have the same sign and, therefore, so does h(x). This means that a simple bound vr
                      is 
                        
                           
                              v
                              r
                           
                           =
                           
                              d
                           
                           
                           r
                        
                      for a d-dimensional kernel.

This simple bound vr
                      can, however, be further improved. We consider the pointwise absolute difference 
                        
                           |
                           h
                           (
                           x
                           )
                           −
                           f
                           (
                           x
                           )
                           |
                        
                      between the original function f and the smoothed function h.

                        
                           (9)
                           
                              
                                 
                                    
                                       
                                          |
                                          h
                                          (
                                          x
                                          )
                                          −
                                          f
                                          (
                                          x
                                          )
                                          |
                                       
                                    
                                    
                                       
                                          =
                                          
                                             |
                                             
                                                ∫
                                                
                                                   R
                                                   d
                                                
                                             
                                             
                                                K
                                                r
                                             
                                             
                                                (
                                                x
                                                −
                                                p
                                                )
                                             
                                             
                                                (
                                                f
                                                
                                                   (
                                                   p
                                                   )
                                                
                                                −
                                                f
                                                
                                                   (
                                                   x
                                                   )
                                                
                                                )
                                             
                                             
                                             
                                                d
                                             
                                             p
                                             |
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     As noted above, the slope of f is at most 1, so that 
                        
                           
                              |
                              f
                              (
                              p
                              )
                              −
                              f
                              (
                              x
                              )
                              |
                           
                           ≤
                           
                              ∥
                              p
                              −
                              x
                              ∥
                           
                        
                     :

                        
                           
                              
                                 
                                    
                                       
                                          |
                                          h
                                          (
                                          x
                                          )
                                          −
                                          f
                                          (
                                          x
                                          )
                                          |
                                       
                                    
                                    
                                       ≤
                                    
                                    
                                       
                                          
                                             ∫
                                             
                                                R
                                                d
                                             
                                          
                                          
                                             |
                                             
                                                K
                                                r
                                             
                                             
                                                (
                                                x
                                                −
                                                p
                                                )
                                             
                                             |
                                          
                                          
                                             ∥
                                             x
                                             −
                                             p
                                             ∥
                                          
                                          
                                          
                                             d
                                          
                                          p
                                       
                                    
                                 
                                 
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ∫
                                             
                                                R
                                                d
                                             
                                          
                                          
                                             K
                                             r
                                          
                                          
                                             (
                                             y
                                             )
                                          
                                          
                                             ∥
                                             y
                                             ∥
                                          
                                          
                                          
                                             d
                                          
                                          y
                                          .
                                       
                                    
                                 
                              
                           
                        
                     In the 2-dimensional case, this leads us to:

                        
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             |
                                             h
                                             (
                                             x
                                             )
                                             −
                                             f
                                             (
                                             x
                                             )
                                             |
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          ≤
                                          4
                                          
                                             1
                                             
                                                r
                                                2
                                             
                                          
                                          
                                             ∫
                                             
                                                0
                                             
                                             r
                                          
                                          
                                             ∫
                                             
                                                0
                                             
                                             r
                                          
                                          
                                             (
                                             1
                                             −
                                             
                                                s
                                                r
                                             
                                             )
                                          
                                          
                                             (
                                             1
                                             −
                                             
                                                t
                                                r
                                             
                                             )
                                          
                                          
                                             
                                                
                                                   s
                                                   2
                                                
                                                +
                                                
                                                   t
                                                   2
                                                
                                             
                                          
                                          
                                          
                                             d
                                          
                                          s
                                          
                                          
                                             d
                                          
                                          t
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          =
                                          4
                                          r
                                          
                                             ∫
                                             
                                                0
                                             
                                             1
                                          
                                          
                                             ∫
                                             
                                                0
                                             
                                             1
                                          
                                          
                                             (
                                             1
                                             −
                                             u
                                             )
                                          
                                          
                                             (
                                             1
                                             −
                                             v
                                             )
                                          
                                          
                                             
                                                
                                                   u
                                                   2
                                                
                                                +
                                                
                                                   v
                                                   2
                                                
                                             
                                          
                                          
                                          
                                             d
                                          
                                          u
                                          
                                          
                                             d
                                          
                                          v
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          =
                                          4
                                          
                                             (
                                             
                                                1
                                                60
                                             
                                             
                                                (
                                                2
                                                +
                                                
                                                   2
                                                
                                                +
                                                5
                                                ln
                                                
                                                   (
                                                   1
                                                   +
                                                   
                                                      2
                                                   
                                                   )
                                                
                                                )
                                             
                                             )
                                          
                                          r
                                          <
                                          0.5215
                                          
                                          r
                                          .
                                       
                                    
                                 
                              
                           
                        
                     This bound is tight: the inequality is reached in the limit for a regular n-gon centered around x. The graph of f, then, is an n-sided pyramid, which becomes a cone in the limit. For three dimensions we can get a similar bound of 
                        
                           
                              |
                              h
                              (
                              x
                              )
                              −
                              f
                              (
                              x
                              )
                              |
                           
                           <
                           0.6618
                           
                           r
                           ,
                        
                      which is also tight.

We can now reconsider the effect of anisotropy using the same approach. We rotate the kernel to study the extent to which the anisotropy affects the result and compare the smoothed surface to the version smoothed with the unrotated kernel.

In a 2-dimensional setting, let Rα
                      be the 2 × 2 matrix rotating by α. Let 
                        
                           
                              K
                              r
                              *
                           
                           
                              (
                              x
                              )
                           
                           =
                           
                              K
                              r
                           
                           
                              (
                              
                                 R
                                 α
                              
                              x
                              )
                           
                        
                      be the rotated kernel and 
                        
                           
                              h
                              *
                           
                           =
                           
                              K
                              r
                              *
                           
                           ☆
                           f
                        
                      be the corresponding smoothed function. We consider the difference 
                        
                           |
                           h
                           
                              (
                              x
                              )
                           
                           −
                           
                              h
                              *
                           
                           
                              (
                              x
                              )
                           
                           |
                        
                      for 
                        
                           α
                           =
                           
                              π
                              4
                           
                        
                     :

                        
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             |
                                             h
                                             
                                                (
                                                x
                                                )
                                             
                                             −
                                             
                                                h
                                                *
                                             
                                             
                                                (
                                                x
                                                )
                                             
                                             |
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          =
                                          
                                             |
                                             
                                                ∫
                                                
                                                   R
                                                   2
                                                
                                             
                                             
                                                (
                                                
                                                   K
                                                   r
                                                
                                                
                                                   (
                                                   x
                                                   −
                                                   p
                                                   )
                                                
                                                −
                                                
                                                   K
                                                   r
                                                   *
                                                
                                                
                                                   (
                                                   x
                                                   −
                                                   p
                                                   )
                                                
                                                )
                                             
                                             
                                                (
                                                f
                                                
                                                   (
                                                   p
                                                   )
                                                
                                                −
                                                f
                                                
                                                   (
                                                   x
                                                   )
                                                
                                                )
                                             
                                             
                                             
                                                d
                                             
                                             p
                                             |
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          ≤
                                          
                                             ∫
                                             
                                                R
                                                2
                                             
                                          
                                          
                                             |
                                             (
                                             
                                                K
                                                r
                                             
                                             
                                                (
                                                y
                                                )
                                             
                                             −
                                             
                                                K
                                                r
                                                *
                                             
                                             
                                                (
                                                y
                                                )
                                             
                                             )
                                             |
                                          
                                          
                                             ∥
                                             y
                                             ∥
                                          
                                          
                                          
                                             d
                                          
                                          y
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          <
                                          0.1036
                                          
                                          r
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     Fig. 6 shows that this bound is maximal for 
                        
                           α
                           =
                           
                              π
                              4
                           
                        
                     . This bound can, however, probably be improved. It is unlikely in practice that the sign of f changes to match the sign of 
                        
                           K
                           −
                           
                              K
                              *
                           
                        
                      (see Fig. 6), so that some of the values cancel out instead of adding up, which leads to a smaller difference. A typical example with a much lower difference is given in the next section. Analogously for three dimensions, there is a rotation Matrix R
                     
                        ψ, θ, ϕ
                      that maximizes the difference 
                        
                           |
                           h
                           
                              (
                              x
                              )
                           
                           −
                           
                              h
                              *
                           
                           
                              (
                              x
                              )
                           
                           |
                        
                     . We can thus compute a bound of 
                        
                           
                              |
                              h
                              
                                 (
                                 x
                                 )
                              
                              −
                              
                                 h
                                 *
                              
                              
                                 (
                                 x
                                 )
                              
                              |
                           
                           <
                           0.1626
                           
                           r
                        
                     .

@&#RESULTS@&#

We have presented an algorithm to compute an implicit C
                     2 smooth approximation of triangle meshes. In this section we present results of this algorithm.

For the 3-dimensional setting, Fig. 7
                      shows a simple hook geometry and the scalar distance function f induced by the straight skeleton. The distance function is shown in a rainbow color map for two orthogonal slices through the volume. Notable features of the geometry include sharp edges, and a hole at the top. Fig. 8
                      shows the smoothed distance function h for two choices of smoothing parameter r, as well as the resulting smoothed geometry as iso-surface 
                        
                           h
                           =
                           0
                        
                     . A small parameter r results in a surface close to the original mesh, with high curvature where the original mesh has sharp edges, while a larger parameter results in a more smooth surface with a lower curvature at edges. To better illustrate the distance function, including parts such as the inside of the polyhedron, where occlusion occurs in the previous figures, Fig. 9 shows different iso-surfaces of h for 
                        
                           r
                           =
                           0.1
                        
                     . The hole is present in both the original and smoothed geometry, but smoothly vanishes for increasing distance values.


                     Fig. 10
                     
                      shows the geometry of the Suzanne mesh
                        3
                     
                     
                        3
                        Suzanne is a model from the Blender software [6]. The model was slightly modified because the original contains non-planar quadrilaterals and self-intersections.
                      as well as a smoothed geometry with a color-coded slice through the distance function.

The second set of results is given in 2-d including different iso-levels. The images in Fig. 11
                      show the interior and exterior of the surfaces in shades of red and blue, with each shade representing a different iso-level. The zero level set is at the boundary between the red and blue parts. The first image in each row shows the input polygon and the corresponding piecewise linear unsmoothed distance function induced by the straight skeleton. The other images show the smoothed functions for different smoothing values of 
                        
                           r
                           =
                           20
                           ,
                        
                     
                     
                        
                           r
                           =
                           40
                           ,
                        
                      and 
                        
                           r
                           =
                           60
                        
                     . The size of the images themselves is 350 × 350. In the last column, the smoothed surfaces no longer touch each edge because the width of the original features is smaller than the smoothing parameter r.


                     Fig. 12
                      shows a right angle edge and the smoothed out result for a value of 
                        
                           r
                           =
                           100
                        
                     . The difference between the surfaces resulting from the rotated and unrotated kernel are too small to be visible in the graph. The second graph shows this difference in y-direction as a function of x, in contrast to Fig. 6, which shows the difference 
                        
                           K
                           −
                           
                              K
                              *
                           
                        
                      between the kernels themselves. The magnitude of the difference is less than 0.00375 r, which is significantly less than the upper bound given in Section 5.

Distance fields have applications for example in motion planning and collision detection. Here, we present an application which requires the described smoothness of the distance field to simulate contact forces.

In this application an industrial fiber laydown process is simulated. Namely, our simulation tool called FIDYST computes the dynamics of fibers in airflow constrained by machine geometry. The effect of turbulent airflow on fibers is modeled as given by Marheineke and Wegener [23], based on [22]. The simulation of the airflow itself is done in a separate process by commercially available tools, and requires the machine geometry to be given as boundary representation triangle meshes. To simulate the fibers, collisions with the machine parts have to be detected and handled. Fig. 13 shows a simulated process of an endless fiber in airflow. In this case, the machine is designed such that the fibers have little contact to the machine walls, only with the conveyor belt at the bottom. To achieve this, however, the simulation must reliably handle the case of a contact as well.

In other setups, contacts with machine geometry is an intentional part of the process. Fig. 14 shows a bundle of fibers colliding with a baffle pipe before being directed to a conveyor belt (cf. [15]). Setups with geometry shapes more complex than pipes are also possible.

The fiber is modeled to be elastic and inextensible. Let 
                        
                           r
                           :
                           
                              (
                              
                                 s
                                 a
                              
                              ,
                              
                                 s
                                 b
                              
                              )
                           
                           ×
                           
                              R
                              +
                           
                           →
                           
                              R
                              3
                           
                        
                      be the curve describing the center-line of the fiber. Then for a material point s ∈ (sa, sb
                     ) and time t the dynamics equations are

                        
                           (10)
                           
                              
                                 
                                    
                                       
                                          
                                             (
                                             ρ
                                             A
                                             )
                                          
                                          
                                             ∂
                                             
                                                t
                                                t
                                             
                                          
                                          r
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ∂
                                             s
                                          
                                          
                                             (
                                             T
                                             
                                                ∂
                                                s
                                             
                                             r
                                             −
                                             
                                                ∂
                                                s
                                             
                                             
                                                (
                                                
                                                   (
                                                   E
                                                   I
                                                   )
                                                
                                                
                                                   ∂
                                                   
                                                      s
                                                      s
                                                   
                                                
                                                r
                                                )
                                             
                                             )
                                          
                                          +
                                          
                                             f
                                             ext
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    
                                       
                                          
                                             ∥
                                          
                                          
                                             ∂
                                             s
                                          
                                          
                                             r
                                             ∥
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          1
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     with the material parameters line density (ρA), tension T, and bending stiffness (EI). The external forces 
                        
                           f
                           ext
                        
                      are the air drag forces and contact forces when the fiber collides with the machine. To model the latter, we implicitly represent the machine as a signed distance field h, as described in the earlier sections (cf. [3]). The contact force introduced at a single fiber point is computed such that it is orthogonal to the machine surface and the magnitude is such that no penetration occurs:
                     
                        
                           (12)
                           
                              
                                 
                                    f
                                    contact
                                 
                                 =
                                 λ
                                 ∇
                                 h
                                 
                                    (
                                    r
                                    )
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (13)
                           
                              
                                 
                                    
                                       
                                          (
                                          λ
                                          =
                                          0
                                          ∧
                                          h
                                          (
                                          r
                                          )
                                          >
                                          0
                                          )
                                          
                                          ∨
                                       
                                    
                                    
                                       
                                          
                                          (
                                          λ
                                          >
                                          0
                                          ∧
                                          h
                                          (
                                          r
                                          )
                                          =
                                          0
                                          )
                                          .
                                       
                                    
                                 
                              
                           
                        
                     The magnitude of the contact force is given by the Lagrangian multiplier λ, which is determined by the constraint given in Eq. 13. As the direction of the contact force is given by the implicit surface’s gradient, the function h has to be differentiable. Further, we employ a non-linear solver based on Newton’s method, which then requires derivatives of the gradient even at non-surface points. Thus, the underlying solver for PDEs requires the collision surfaces to be C
                     2. A previous implementation [24] used a weighted linear combination of plane distance functions, which lead to qualitatively unsatisfying iso-surfaces with artifical bumps at the smoothed out edges. To achieve the necessary smoothness in a more appropriate way, we now have applied the distance function presented in this paper.

@&#CONCLUSION@&#

We have presented a method to smooth a solid given as a triangle mesh surface. We represent the surface implicitly as a distance field and apply a convolution-based smoothing to it, including a feature size parameter that controls the strength of the smoothing effect. The resulting field is globally C
                     2 continuous on 
                        
                           
                              R
                              3
                           
                           ,
                        
                      which is required by the physical simulation system we mentioned. If needed, a higher smoothness can easily be achieved with a different convolution kernel at the cost of higher computation time. In contrast, the same cannot be achieved by just smoothing the triangle mesh with standard methods such as B-spline surfaces and then applying a simple implicitization using a signed distance function. The resulting field would only be locally smooth in a neighborhood of the surface, as shown in [21].

We have applied a linearization to both the implicit function representing the solid as well as the convolution kernel. This allows us to compute the integrals of the smoothed function as well as its derivatives analytically. The employed linearization of the kernel causes an anisotropy, but we have given a bound on the effect and shown that in practice it is not significant. We have also given a bound to the approximation quality with regard to the feature size parameter. For points not very close to the surface, this allows us to speed up inside/outside checks for collison detection. If the absolute value of the original function has a value larger than this bound, we know that the smoothed function has the same sign without actually evaluating it.

@&#ACKNOWLEDGMENTS@&#

This research was supported by the international graduate school IRTG 1131 of DFG (German National Science Foundation) and Fraunhofer ITWM.

@&#REFERENCES@&#

