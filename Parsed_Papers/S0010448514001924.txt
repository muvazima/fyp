@&#MAIN-TITLE@&#Intrinsic computation of centroidal Voronoi tessellation (CVT) on meshes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose two intrinsic methods for computing centroidal Voronoi tessellation (CVT) on triangle meshes.


                        
                        
                           
                           Thanks to their intrinsic nature, our methods compute CVT using metric only.


                        
                        
                           
                           Our results are independent of the embedding space.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Voronoi diagram

Centroidal Voronoi tessellation (CVT)

Discrete geodesics

Exponential map

Riemannian center

The L-BFGS method

@&#ABSTRACT@&#


               
               
                  Centroidal Voronoi tessellation (CVT) is a special type of Voronoi diagram such that the generating point of each Voronoi cell is also its center of mass. The CVT has broad applications in computer graphics, such as meshing, stippling, sampling, etc. The existing methods for computing CVTs on meshes either require a global parameterization or compute it in the restricted sense (that is, intersecting a 3D CVT with the surface). Therefore, these approaches often fail on models with complicated geometry and/or topology. This paper presents two intrinsic algorithms for computing CVT on triangle meshes. The first algorithm adopts the Lloyd framework, which iteratively moves the generator of each geodesic Voronoi diagram to its mass center. Based on the discrete exponential map, our method can efficiently compute the Riemannian center and the center of mass for any geodesic Voronoi diagram. The second algorithm uses the L-BFGS method to accelerate the intrinsic CVT computation. Thanks to the intrinsic feature, our methods are independent of the embedding space, and work well for models with arbitrary topology and complicated geometry, where the existing extrinsic approaches often fail. The promising experimental results show the advantages of our method.
               
            

@&#INTRODUCTION@&#

Centroidal Voronoi tessellation (CVT) is a special type of Voronoi diagram (VD) such that the generating point of each Voronoi cell is also its center of mass  [1]. The CVT has broad applications in computer graphics, such as meshing, stippling, sampling, etc. Although the CVT in Euclidean space has been extensively studied, relatively little progress has been reported towards computing the CVT on curved surfaces. A key step in computing the CVT is to construct the Voronoi diagrams in each iteration. It is fairly simple to construct the Voronoi diagrams in Euclidean space (e.g. 
                        
                           
                              R
                           
                           
                              2
                           
                        
                      and 
                        
                           
                              R
                           
                           
                              3
                           
                        
                     ), since many efficient algorithms and software tools are readily available. However, it is technically challenging to compute VD on curved surfaces. Some researchers tackle this challenge by computing the restricted Voronoi diagrams  [2], which is the intersection between the input mesh and the Voronoi diagram in 
                        
                           
                              R
                           
                           
                              3
                           
                        
                     . These approaches are embedding space dependent and may fail on models with complicated geometry and/or topology. Others adopt the global parameterization to map the surface to the parametric domain, such as Euclidean plane 
                        
                           
                              E
                           
                           
                              2
                           
                        
                     , the sphere 
                        
                           
                              S
                           
                           
                              2
                           
                        
                     , or hyperbolic disk 
                        
                           
                              H
                           
                           
                              2
                           
                        
                     , in which the 2-dimensional CVT is computed  [3]. It is known that parameterizing models with complicated geometry and/or topology is computationally expensive and often suffers serious numerical issues. To our knowledge, there is no method for computing the CVT on arbitrary surfaces.

To tackle the above-mentioned challenge, this paper presents two intrinsic algorithms for computing the centroidal Voronoi tessellation on arbitrary triangle meshes. Our first algorithm adopts the Lloyd framework, which iteratively moves the generator of each geodesic Voronoi diagram to its mass center. Based on the discrete exponential map, our method can efficiently compute the Riemannian center and the center of mass for any geodesic VD. Our second algorithm uses the L-BFGS method (limited-memory BFGS), which uses the CVT energy function and its gradients to approximate the Hessian matrix. The L-BFGS method has better performance due to its super-linear convergence rate. Thanks to the intrinsic feature, our methods are independent of the embedding space, and work well for models with arbitrary topology and complicated geometry, where the existing extrinsic approaches often fail. Fig. 1
                      shows our result on the genus-5 Pegaso model. Moreover, our methods are insensitive to the mesh resolution and tessellation, and can be applied to surfaces embedded in arbitrary dimensional space. The promising experimental results demonstrate the efficacy of our methods.

The rest of the paper is organized as follows. Section  2 briefly reviews the existing work on CVT and the related topics. Then Sections  3 and 4 presents our intrinsic Lloyd and L-BFGS CVT algorithms in detail. Section  5 shows the experimental results, compares our method to the existing techniques and discusses its advantages and limitations. Finally, Section  6 concludes the paper.

Let 
                           
                              S
                           
                           =
                           
                              
                                 
                                    (
                                    
                                       
                                          s
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 m
                              
                           
                         be a set of distinct sites in a connected compact region 
                           Ω
                           ⊂
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        . The Voronoi region 
                           
                              
                                 Ω
                              
                              
                                 i
                              
                           
                         of 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                         is defined as: 
                           
                              
                                 
                                    
                                       Ω
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    {
                                    x
                                    ∈
                                    Ω
                                    ∣
                                    
                                       ‖
                                       x
                                       −
                                       
                                          
                                             s
                                          
                                          
                                             i
                                          
                                       
                                       ‖
                                    
                                    ≤
                                    
                                       ‖
                                       x
                                       −
                                       
                                          
                                             s
                                          
                                          
                                             j
                                          
                                       
                                       ‖
                                    
                                    ,
                                    
                                    ∀
                                    i
                                    ≠
                                    j
                                    }
                                 
                                 ,
                              
                           
                         where 
                           
                              ‖
                              ⋅
                              ‖
                           
                         denotes the Euclidean norm. The Voronoi regions, 
                           
                              
                                 Ω
                              
                              
                                 i
                              
                           
                        , of all the sites form the Voronoi diagram of 
                           
                              S
                           
                        . The VD is a fundamental geometric tool that has a wide range of applications in science, engineering and even arts. The classic algorithms for constructing Voronoi diagram in 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                         are the sweep line algorithm  [4] and the divide-and-conquer algorithm  [5], which have optimal time complexity 
                           O
                           
                              (
                              m
                              log
                              m
                              )
                           
                        .

Let the domain 
                           Ω
                         be endowed with a density function 
                           ρ
                           
                              (
                              x
                              )
                           
                           >
                           0
                        , which is assumed to be 
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                        . A typical energy function on 
                           Ω
                         with regard to the Voronoi tessellation is defined as follows  [1]: 
                           
                              
                                 F
                                 
                                    (
                                    
                                       S
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       ∫
                                    
                                    
                                       
                                          
                                             Ω
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 ρ
                                 
                                    (
                                    x
                                    )
                                 
                                 
                                    
                                       
                                          ‖
                                          x
                                          −
                                          
                                             
                                                s
                                             
                                             
                                                i
                                             
                                          
                                          ‖
                                       
                                    
                                    
                                       2
                                    
                                 
                                 d
                                 σ
                                 ≜
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       m
                                    
                                 
                                 
                                    
                                       F
                                    
                                    
                                       i
                                    
                                 
                                 ,
                              
                           
                         where the term 
                           
                              
                                 F
                              
                              
                                 i
                              
                           
                         expresses the compactness (or inertia momentum) of the Voronoi cell 
                           
                              
                                 Ω
                              
                              
                                 i
                              
                           
                         associated with the site 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        . The Voronoi tessellation 
                           
                              {
                              
                                 
                                    Ω
                                 
                                 
                                    i
                                 
                              
                              }
                           
                         is said to be a centroidal Voronoi tessellation if each site 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                         coincides with the centroid 
                           
                              
                                 c
                              
                              
                                 i
                              
                           
                         of its Voronoi cell, that is: 
                           
                              
                                 
                                    
                                       s
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                                 
                                    (
                                    =
                                    
                                       
                                          
                                             
                                                ∫
                                             
                                             
                                                
                                                   
                                                      Ω
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          ρ
                                          
                                             (
                                             x
                                             )
                                          
                                          x
                                          d
                                          σ
                                       
                                       
                                          
                                             
                                                ∫
                                             
                                             
                                                
                                                   
                                                      Ω
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          ρ
                                          
                                             (
                                             x
                                             )
                                          
                                          d
                                          σ
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                        
                     

The Lloyd algorithm  [6] iteratively moves the generator of Voronoi cell to its mass center. Although it is conceptually simple and easy to implement, the Lloyd algorithm has only linear convergence rate. Liu et al.  [7] proved that the CVT energy function is 
                           
                              
                                 C
                              
                              
                                 2
                              
                           
                         continuous. As a result, one can minimize the CVT energy by the Newton or quasi-Newton method, which converges much faster than the Lloyd algorithm.

Both the Lloyd algorithm and the Newton algorithm require computing the Voronoi diagrams in each iteration. Although it is fairly simple to construct the VD in Euclidean space (e.g. 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                         and 
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                        ), computing VD on curved surfaces is technically challenging. Alliez et al.  [8,9] conformally parameterized genus-0 open surface to a disk and evaluated the centroids over the density function expressed in parameter space rather than on the surface. Thanks to the angle-preserving and local isotropic properties of conformal parameterization, a well-shaped triangle in parameter space will not be deformed too much once lifted back into 
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                        , except for its size, which can be easily compensated by the weighted density function in 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                        . Rong et al.  [10] generalized the CVT energy function from 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                         to spherical space 
                           
                              
                                 S
                              
                              
                                 2
                              
                           
                         and hyperbolic space 
                           
                              
                                 H
                              
                              
                                 2
                              
                           
                         and then combined all of them into a unified framework—the CVT in universal covering space (UCS). They adapted Lloyd’s iteration to compute the CVT in the embedded fundamental domain of the UCS. If a centroid is outside of the fundamental domain by one side, they performed a rigid motion to move it to the opposite side of the fundamental domain. The adjusted centroids are all inside the fundamental domain and are used as the new sites in the next iteration. Rong et al.  [11] proposed a GPU-based method for computing the CVT on the plane and observed significant speedup of these GPU-based methods over their CPU counterparts. Their method also works for some 3D models that can be represented as a geometry image. However, as mentioned above, global parameterization is computationally expensive and may suffer from serious numerical issues if the surface has complicated geometry and non-trivial topology. For example, the Bunny’s ears are shrunk to very tiny regions under spherical conformal parameterization  [12], which poses a great numerical challenge to compute the CVT on 
                           
                              
                                 S
                              
                              
                                 2
                              
                           
                        .

Yan et al.  [2] proposed a different approach. Rather than constructing the CVT on the mesh directly, they repeatedly computed restricted Voronoi diagrams (RVD), defined as the intersection between the input mesh and a Voronoi diagram in 
                           
                              
                                 R
                              
                              
                                 3
                              
                           
                        . Their method uses a kd-tree to quickly identify and compute the intersection of each triangle face with its incident Voronoi cells. The time complexity for computing RVD is 
                           O
                           
                              (
                              m
                              log
                              n
                              )
                           
                        , where 
                           n
                         is the number of seed points and 
                           m
                         is the number of triangles of the input mesh. Their method also adopted the quasi-Newton method for fast convergence. They demonstrated that the restricted RVD-based method is flexible for computing the CVT with a non-constant density function. However, their method is embedding space dependent and may fail on models with complicated geometry/topology. Recently, Lévy and Bonneel  [13] proposed an elegant method for constructing curvature-adaptive anisotropic meshes. Their idea is to transform the 3D anisotropic space into a higher dimensional isotropic space, in which the mesh is optimized by computing a CVT. Lévy and Bonneel’s method overcomes the 
                           d
                        -factorial cost of computing a Voronoi diagram of dimension 
                           d
                         by directly computing the restricted Voronoi cells with an algorithm called Voronoi Parallel Linear Enumeration, which can be easily parallelized. Their method is extrinsic due to the computation of intersection between the (higher dimensional) Voronoi cells and the surface.

For any two points 
                           p
                         and 
                           q
                         on a 2-manifold surface, the geodesic path between 
                           p
                         and 
                           q
                         is a local shortest path connecting 
                           p
                         and 
                           q
                         on the surface  [14]. If the surface is smooth, the geodesic is a curve on the surface whose geodesic curvature is always zero. Since geodesic curvature is only dependent on the first fundamental form, the geodesic is intrinsic to the surface. To compute the discrete geodesic on a triangle mesh of arbitrary topological type, two broad classes of methods exist. The first class treats the mesh as the first-order approximation of a smooth surface and uses numerical methods to solve a characterizing partial differential equation on the mesh; as a typical example, the Eikonal equation is solved on a mesh in  [15]. The second class treats the mesh as a polygonal domain and uses computational geometry methods to build the shortest paths. The second class can compute the discrete geodesic exactly, and is typified by the Mitchell–Mount–Papadimitriou (MMP) algorithm  [16], the Chen–Han (CH) algorithm  [17] and their many variants  [18–22]. The time complexities of the MMP and CH algorithms are 
                           O
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              log
                              n
                              )
                           
                         and 
                           O
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              )
                           
                        , respectively, where 
                           n
                         is the number of mesh vertices. Recently, Ying et al.  [23] proposed the saddle vertex graph (SVG), which is a pre-computation technique for efficiently computing various types of discrete geodesics.

With the above-mentioned discrete geodesic algorithms, one can compute the exponential map, which defines a geodesic polar coordinate system on meshes (see Fig. 2
                        ). Let 
                           p
                           ∈
                           M
                         be an arbitrary point on a smooth surface 
                           M
                        . The exponential map 
                           
                              
                                 exp
                              
                              
                                 p
                              
                           
                           :
                           
                              
                                 T
                              
                              
                                 p
                              
                           
                           M
                           →
                           M
                         at 
                           p
                         is a map from the tangent plane at 
                           p
                         to 
                           p
                        ’s local neighborhood. Given a radial line on the tangent plane which originates at 
                           p
                         and has direction 
                           
                              v
                           
                           ∈
                           
                              
                                 T
                              
                              
                                 p
                              
                           
                           M
                        , the exponential map sends 
                           p
                           +
                           t
                           
                              v
                           
                         to a unique geodesic curve 
                           γ
                         originating at 
                           p
                         such that 
                           
                              
                                 γ
                              
                              
                                 ′
                              
                           
                           
                              (
                              0
                              )
                           
                           =
                           
                              v
                           
                         and 
                           
                              ‖
                              γ
                              
                                 (
                                 t
                                 )
                              
                              ‖
                           
                           =
                           1
                        . Conversely, given an arc-length parameterized geodesic 
                           γ
                         originating at 
                           p
                        , 
                           γ
                           
                              (
                              0
                              )
                           
                           =
                           p
                        , there is a unique tangent direction 
                           
                              
                                 γ
                              
                              
                                 ′
                              
                           
                           
                              (
                              0
                              )
                           
                         on the tangent plane 
                           
                              
                                 exp
                              
                              
                                 p
                              
                              
                                 −
                                 1
                              
                           
                           
                              (
                              γ
                              )
                           
                           =
                           
                              
                                 γ
                              
                              
                                 ′
                              
                           
                           
                              (
                              0
                              )
                           
                        . The exponential map has been used in various graphics applications, such as decal compositing  [24], texture mapping  [25], Poisson disk sampling  [26], etc.

To compute the geodesic Voronoi diagram on a 2-manifold mesh 
                           M
                        , the Euclidean norm is replaced by the geodesic metric. Such a metric change results in fundamental change in the bisector and Voronoi regions between the Euclidean plane and a curved 2-manifold. For example, a bisector in 
                           
                              
                                 R
                              
                              
                                 2
                              
                           
                         is a line segment, while a bisector on a triangle mesh may contain both line segments and hyperbola segments. Given a genus-
                           g
                         mesh 
                           M
                        , it was shown in  [27] that the bisector of two distinct points on 
                           M
                         can have at most 
                           g
                           +
                           1
                         separated components and a Voronoi region of a point in 
                           
                              S
                           
                         can be bounded by one or more closed bisectors (see Fig. 3
                        ). Liu  [28] proved that the combinatorial complexity of geodesic Voronoi diagram on 
                           M
                         is 
                           O
                           
                              (
                              
                                 (
                                 m
                                 +
                                 g
                                 )
                              
                              n
                              )
                           
                        , where 
                           m
                         is the number of points in 
                           
                              S
                           
                         and 
                           n
                         is the number of triangles in the mesh. Edelsbrunner and Shah  [29] showed that for a general topological space, if a closed ball property is satisfied, then the dual Delaunay triangulation of Voronoi diagram exists. Recently, Liu et al.  [30] showed that the intrinsic Delaunay triangulation on mesh 
                           M
                         can be obtained by the duality of a geodesic Voronoi diagram on 
                           M
                        . They proved that this duality exists under two practical assumptions and proposed an efficient algorithm for constructing the Delaunay triangulation.

We refer the readers to  [31] for in-depth discussion on the properties of Delaunay triangulation and Voronoi diagram on a 2-manifold mesh.

@&#OVERVIEW@&#

Let 
                           M
                           =
                           
                              (
                              V
                              ,
                              E
                              ,
                              F
                              )
                           
                         be a triangle mesh representing a 2-manifold surface, where 
                           V
                        , 
                           E
                         and 
                           F
                         are the set of vertices, edges and faces, respectively. Let 
                           S
                           =
                           
                              {
                              
                                 
                                    s
                                 
                                 
                                    i
                                 
                              
                              |
                              
                                 
                                    s
                                 
                                 
                                    i
                                 
                              
                              ∈
                              M
                              ,
                              
                              i
                              =
                              1
                              ,
                              …
                              ,
                              m
                              }
                           
                         denote the set of sites on 
                           M
                        .

Our algorithm adopts the Lloyd framework, which iteratively computes the geodesic CVT on meshes. For each iteration, we first compute the multiple-source-all-destination geodesic distance with the sites 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                           ,
                           
                           i
                           =
                           1
                           ,
                           …
                           ,
                           m
                        , as the sources. This geodesic distance field on 
                           M
                         induces a geodesic Voronoi diagram. Then for each geodesic Voronoi cell, say 
                           
                              
                                 Ω
                              
                              
                                 j
                              
                           
                           ∈
                           M
                        , we compute its Riemannian center 
                           
                              
                                 r
                              
                              
                                 j
                              
                           
                        , which is defined as the average of its corners. Next, we compute the exponential map 
                           exp
                           
                              (
                              
                                 
                                    r
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         at the Riemannian center 
                           
                              
                                 r
                              
                              
                                 j
                              
                           
                        , and map the Voronoi cell 
                           
                              
                                 Ω
                              
                              
                                 j
                              
                           
                         to the tangent plane 
                           
                              
                                 T
                              
                              
                                 
                                    
                                       r
                                    
                                    
                                       j
                                    
                                 
                              
                           
                        , on which we can compute the center of mass 
                           
                              
                                 c
                              
                              
                                 j
                              
                           
                        . Finally, we map the mass center from the tangent plane to the mesh using the exponential map 
                           exp
                           
                              (
                              
                                 
                                    r
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        . We update each site 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                         to the new mass center and then repeat the above-mentioned procedure until the offsets of the sites are below the user-specified threshold.


                        
                           
                              
                           
                        
                     

Taking 
                           
                              
                                 
                                    {
                                    
                                       
                                          s
                                       
                                       
                                          i
                                       
                                    
                                    }
                                 
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 m
                              
                           
                         as sources, we apply the ICH algorithm  [21]
                        
                           1
                        
                        
                           1
                           The ICH algorithm in  [21] computes the single-source geodesic distance. But it can be extended to multi-source case easily by adding a stoping criteria during the window propagation procedure: when two windows from different sources cover the same vertex, both windows stop propagation.
                         to compute the multiple-source geodesic distance field. As a result, each mesh vertex is assigned a geodesic distance to its closest source. Then we label an edge 
                           L
                           E
                         if its two endpoints have different sources. Clearly, an 
                           L
                           E
                         edge is passed by a bisector. We further collect into a list 
                           L
                           T
                         all the triangles in 
                           M
                         that are incident to any 
                           L
                           E
                         edge. As  [27] shows, if a triangle 
                           t
                           ∈
                           L
                           T
                         has all its three edges labelled 
                           L
                           E
                        , then 
                           t
                         contains a branch point in the geodesic Voronoi diagram; otherwise 
                           t
                         is passed through by a single piece of a bisector. Based on the lists of 
                           L
                           E
                         and 
                           L
                           T
                        , we run the marching algorithm  [27] for extracting the geodesic Voronoi diagram on 
                           M
                        .

Assume the sites 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                         are uniformly distributed. This assumption is reasonable, since the distribution of the sites is improved after only a few Lloyd iterations (see Fig. 4
                        ). The ICH algorithm takes worst-case 
                           O
                           
                              (
                              
                                 
                                    
                                       
                                          n
                                       
                                       
                                          2
                                       
                                    
                                 
                                 
                                    m
                                 
                              
                              log
                              
                                 (
                                 
                                    
                                       n
                                    
                                    
                                       m
                                    
                                 
                                 )
                              
                              )
                           
                         time and empirical 
                           O
                           
                              (
                              
                                 
                                    
                                       
                                          n
                                       
                                       
                                          2
                                       
                                    
                                 
                                 
                                    m
                                 
                              
                              )
                           
                         time, where 
                           n
                         is the number of mesh vertices. The geodesic Voronoi diagram is then built in 
                           O
                           
                              (
                              k
                              log
                              k
                              )
                           
                         time, where 
                           k
                         be the number of triangles in 
                           L
                           T
                        . Fig. 5
                         shows the geodesic distance field and its induced geodesic Voronoi diagram on the double-torus model.

Let 
                           
                              
                                 v
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 v
                              
                              
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 v
                              
                              
                                 k
                              
                           
                         be the corners of a Voronoi cell 
                           
                              
                                 Ω
                              
                              
                                 i
                              
                           
                           ∈
                           M
                        . The Riemannian center is defined as the local minima 
                           x
                         of the following function 
                           
                              (1)
                              
                                 U
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       k
                                    
                                 
                                 
                                    
                                       d
                                    
                                    
                                       2
                                    
                                 
                                 
                                    (
                                    x
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 ,
                              
                           
                         where 
                           d
                           
                              (
                              p
                              ,
                              q
                              )
                           
                         is the geodesic distance between 
                           p
                         and 
                           q
                        . If 
                           M
                         has zero Gaussian curvature (that is, developable), the Riemannian center exists and is unique. However, in general, the function 
                           U
                           
                              (
                              x
                              )
                           
                         is not convex, and the minimizer may not be unique. Kendall  [32] and Karcher  [33] showed the conditions to ensure the existence and uniqueness of the Riemannian center of mass. Intuitively speaking, if the points 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         are not too far from each other, there exists a unique Riemannian center of mass. Refer to  [34,35] for the rigorous results.

Let 
                           
                              
                                 x
                              
                              
                                 ∗
                              
                           
                           ∈
                           M
                         be the local minimal of Eq. (1). Then 
                           
                              
                                 x
                              
                              
                                 ∗
                              
                           
                         satisfies 
                           
                              (2)
                              
                                 
                                    
                                       0
                                    
                                    →
                                 
                                 =
                                 ∇
                                 U
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       k
                                    
                                 
                                 ∇
                                 
                                    
                                       d
                                    
                                    
                                       2
                                    
                                 
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          ∗
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 =
                                 2
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       k
                                    
                                 
                                 d
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          ∗
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 ∇
                                 d
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          ∗
                                       
                                    
                                    ,
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                         Since 
                           d
                           
                              (
                              ,
                              )
                           
                         is the geodesic distance, 
                           ∇
                           d
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           ∈
                           
                              
                                 T
                              
                              
                                 
                                    
                                       x
                                    
                                    
                                       ∗
                                    
                                 
                              
                           
                           M
                         is a unit tangent vector. Therefore, 
                           d
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                           
                           ∇
                           d
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         represents a tangent vector with length 
                           d
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , denoted by 
                           
                              
                                 
                                    
                                       t
                                    
                                    →
                                 
                              
                              
                                 i
                              
                           
                        . Eq. (2) requires 
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 k
                              
                           
                           
                              
                                 
                                    
                                       t
                                    
                                    →
                                 
                              
                              
                                 i
                              
                           
                           =
                           
                              
                                 0
                              
                              →
                           
                        , which means 
                           
                              
                                 x
                              
                              
                                 ∗
                              
                           
                         is the center of the terminal points of 
                           
                              
                                 
                                    
                                       t
                                    
                                    →
                                 
                              
                              
                                 i
                              
                           
                        .

We iteratively compute the local minimal 
                           
                              
                                 x
                              
                              
                                 ∗
                              
                           
                        . Let 
                           x
                         be the initial point, which could be either one of the corner points 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         or the site’s location 
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        . We compute the exponential map 
                           
                              
                                 exp
                              
                              
                                 x
                              
                           
                         at 
                           x
                        . The exponential map 
                           
                              
                                 exp
                              
                              
                                 x
                              
                           
                           :
                           
                              
                                 T
                              
                              
                                 x
                              
                           
                           M
                           →
                           M
                         builds a geodesic polar coordinate system at 
                           x
                        . The inverse map 
                           
                              
                                 exp
                              
                              
                                 x
                              
                              
                                 −
                                 1
                              
                           
                         maps the point 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           ∈
                           M
                         to the tangent plane 
                           
                              
                                 T
                              
                              
                                 x
                              
                           
                           M
                        . Let 
                           
                              
                                 x
                              
                              
                                 ˆ
                              
                           
                           ∈
                           
                              
                                 T
                              
                              
                                 x
                              
                           
                           M
                         be the average of the points 
                           
                              
                                 exp
                              
                              
                                 x
                              
                              
                                 −
                                 1
                              
                           
                           
                              (
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                              )
                           
                           ,
                           …
                           ,
                           
                              
                                 exp
                              
                              
                                 x
                              
                              
                                 −
                                 1
                              
                           
                           
                              (
                              
                                 
                                    v
                                 
                                 
                                    k
                                 
                              
                              )
                           
                        . If 
                           
                              
                                 x
                              
                              
                                 ˆ
                              
                           
                         does not equal 
                           x
                        , we send 
                           
                              
                                 x
                              
                              
                                 ˆ
                              
                           
                         to the mesh 
                           M
                         by the exponential map 
                           
                              
                                 exp
                              
                              
                                 x
                              
                           
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    ˆ
                                 
                              
                              )
                           
                        . Setting 
                           x
                           =
                           
                              
                                 exp
                              
                              
                                 x
                              
                           
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    ˆ
                                 
                              
                              )
                           
                        , we then repeat the above procedures until the average 
                           
                              
                                 x
                              
                              
                                 ˆ
                              
                           
                         agrees with 
                           x
                        . Note that the exponential map, in general, does not preserve the area. However, when the Voronoi cells are small with respect to the injectivity radius  [34], we observe that our algorithm can generate fairly good results. In our implementation, we set the initial point 
                           x
                           =
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        , which is the center of the Voronoi region in the previous iteration. During the CVT iterations, the sites are getting closer to the Riemannian center, making finding the Riemannian center faster. We have observed that the iterative algorithm for finding Riemannian center converges very fast, took only two or three 
                           s
                         for all test models in our paper (see Fig. 6
                        ).


                        
                           
                              
                           
                        
                     

Although the Riemannian center 
                           r
                         is not the center of mass, it is close to all corners of the Voronoi cell. Therefore, it is very natural to use 
                           r
                         to compute the center of mass. Let 
                           
                              
                                 exp
                              
                              
                                 r
                              
                           
                         be the exponential map at the Riemannian center and 
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       ˆ
                                    
                                 
                              
                              
                                 i
                              
                           
                           =
                           
                              
                                 exp
                              
                              
                                 r
                              
                              
                                 −
                                 1
                              
                           
                           
                              (
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         the pre-image of 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                        , which lies on the tangent plane 
                           
                              
                                 T
                              
                              
                                 r
                              
                           
                           M
                        . Since the points 
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       ˆ
                                    
                                 
                              
                              
                                 i
                              
                           
                           ,
                           
                           i
                           =
                           1
                           ,
                           …
                           ,
                           k
                        , form a polygon on the tangent plane, its center of mass 
                           
                              
                                 c
                              
                              
                                 ˆ
                              
                           
                           ∈
                           
                              
                                 T
                              
                              
                                 r
                              
                           
                           M
                         is given by
                           
                              
                                 
                                    x
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          6
                                          A
                                       
                                    
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       +
                                       
                                          
                                             x
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       −
                                       
                                          
                                             x
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                              
                                 
                                    y
                                    =
                                    
                                       
                                          1
                                       
                                       
                                          6
                                          A
                                       
                                    
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                    
                                       (
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       +
                                       
                                          
                                             y
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                    
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             i
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       −
                                       
                                          
                                             x
                                          
                                          
                                             i
                                             +
                                             1
                                          
                                       
                                       
                                          
                                             y
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                              
                           
                         where 
                           
                              (
                              x
                              ,
                              y
                              )
                           
                         are the coordinates of 
                           
                              
                                 c
                              
                              
                                 ˆ
                              
                           
                        , 
                           
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    y
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         are the coordinates of 
                           
                              
                                 
                                    
                                       v
                                    
                                    
                                       ˆ
                                    
                                 
                              
                              
                                 i
                              
                           
                        , and 
                           A
                         is the area of the polygon 
                           
                              
                                 A
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       1
                                    
                                    
                                       k
                                       −
                                       1
                                    
                                 
                                 
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                    
                                       
                                          y
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    −
                                    
                                       
                                          x
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    
                                       
                                          y
                                       
                                       
                                          i
                                       
                                    
                                    )
                                 
                                 .
                              
                           
                         Finally, the center of mass for Voronoi cell 
                           Ω
                         is given by 
                           c
                           =
                           
                              
                                 exp
                              
                              
                                 r
                              
                           
                           
                              (
                              
                                 
                                    c
                                 
                                 
                                    ˆ
                                 
                              
                              )
                           
                        .

Liu et al.  [7] proved that the CVT energy function 
                        F
                      has 
                        
                           
                              C
                           
                           
                              2
                           
                        
                      smoothness, thus, one can use the Newton or quasi-Newton method to optimize the energy 
                        F
                     . In this section, we adopt the L-BFGS method to accelerate the CVT computation. To compute the numerical integration on meshes, we modify the ICH algorithm  [21] for computing the geodesic distance between any point (not necessarily a vertex) to the source point. We use  [36] to compute numerical integration on each triangle. The details of the modified ICH algorithm is in Section  5.1. The L-BFGS method requires the gradient of the energy function for approximating the approximated Hessian matrix. Given the energy function 
                        F
                      in Section  2, the gradient of the CVT energy is  [37,1]:
                        
                           
                              
                                 
                                    ∂
                                    F
                                 
                                 
                                    ∂
                                    
                                       
                                          x
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              =
                              2
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                              
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 −
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                              ,
                           
                        
                      where 
                        
                           
                              m
                           
                           
                              i
                           
                        
                        =
                        
                           
                              ∫
                           
                           
                              
                                 
                                    Ω
                                 
                                 
                                    i
                                 
                              
                           
                        
                        ρ
                        
                           (
                           x
                           )
                        
                        d
                        σ
                     , 
                        
                           
                              c
                           
                           
                              i
                           
                        
                      is the center of mass of the Voronoi cell 
                        
                           
                              Ω
                           
                           
                              i
                           
                        
                     . We use the methods in Sections  3.3 and 3.4 to compute 
                        
                           
                              c
                           
                           
                              i
                           
                        
                     . Note that the seeds are restricted on the input mesh 
                        M
                     , and the gradients are also constrained on the tangent space 
                        
                           
                              T
                           
                           
                              x
                           
                        
                     . Using the exponential map 
                        
                           
                              exp
                           
                           
                              x
                           
                        
                        :
                        
                           
                              T
                           
                           
                              x
                           
                        
                        M
                        →
                        M
                     , we can compute the projection 
                        
                           
                              
                                 
                                    c
                                 
                                 
                                    ˆ
                                 
                              
                           
                           
                              i
                           
                        
                      of 
                        
                           
                              c
                           
                           
                              i
                           
                        
                      on 
                        
                           
                              T
                           
                           
                              x
                           
                        
                     . During the L-BFGS optimization process, we use 
                        2
                        
                           
                              m
                           
                           
                              i
                           
                        
                        
                           (
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           −
                           
                              
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                              
                              
                                 ˆ
                              
                           
                           )
                        
                      as the gradient, so that it is on the tangent plane at point 
                        
                           
                              x
                           
                           
                              i
                           
                        
                     . During each iteration in L-BFGS method, we get 
                        
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                                 
                                    ′
                                 
                              
                           
                           
                              ˆ
                           
                        
                      on 
                        
                           
                              T
                           
                           
                              x
                           
                        
                      for each Voronoi cell, and use the inverse map 
                        
                           
                              exp
                           
                           
                              x
                           
                           
                              −
                              1
                           
                        
                      to get 
                        
                           
                              x
                           
                           
                              i
                           
                           
                              ′
                           
                        
                        =
                        
                           
                              exp
                           
                           
                              x
                           
                           
                              −
                              1
                           
                        
                        
                           (
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                    
                                       ′
                                    
                                 
                              
                              
                                 ˆ
                              
                           
                           )
                        
                     . Fig. 7
                      shows the energy plot comparison between Lloyd method and L-BFGS method.


                     
                        
                           
                        
                     
                  

@&#EXPERIMENTAL RESULTS@&#

@&#IMPLEMENTATION@&#

The ICH algorithm  [21] has linear space complexity and can compute the exact single-source geodesic distance in an 
                           O
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              log
                              n
                              )
                           
                         time (The empirical time complexity is 
                           O
                           
                              (
                              
                                 
                                    n
                                 
                                 
                                    1.5
                                 
                              
                              log
                              n
                              )
                           
                        ), where 
                           n
                         is the number of vertices. The ICH algorithm computes the exact geodesic distances between any mesh vertex to the source vertex. However, it cannot compute the exact geodesic distance between any mesh points, i.e., non-vertex points on the mesh. We modify the ICH algorithm by sacrificing its space complexity: we store all the windows (a data structure that carries the geodesic distance from an edge interval to the source) generated in the window propagation procedure. When computing the distance from the source to a non-vertex point, say 
                           p
                           ∈
                           t
                        , which is inside a triangle 
                           t
                        , we consider all windows covering 
                           t
                        ’s sides, and find the one which can provide the shortest distance to 
                           p
                        .

The modified ICH algorithm can also compute the discrete exponential map on triangle meshes. Thanks to the parallel structure of the Lloyd iteration, our algorithm can be easily implemented in parallel. Each ICH thread takes a point (not necessarily a mesh vertex) as the source, the ICH algorithm partitions each mesh edge into a set of intervals, called windows, which encode both the geodesic distance and the direction of the geodesic path emanating from the source. The windows are maintained in a priority queue according to the distance from the source and are propagated across the mesh faces: pops a window from the queue and then computes its children windows which can add, modify, or remove existing windows, and updates the queue accordingly. When a window reaches a vertex 
                           v
                        , it updates 
                           v
                        ’s distance and direction, which are used for the polar coordinates. The ICH algorithm terminates if the wavefront has reached the user-specified radius.

The input mesh is encoded in the half-edge structure and stored in the CPU’s global memory in a read-only manner. Each CPU thread maintains its own data (i.e., the source point, the wavefront windows and the priority queue) in its own memory pool. Even though two or more ICH threads may compute on overlapped regions, they do not have any data and control conflicts, so each thread can proceed independently.

We adopted OpenMP to implement our method on an Intel 2.50 GHz CPU with four cores. Our program asks the user to specify the number of sites, then it generates the sites on the mesh randomly. We set the convergence threshold 
                           ε
                           =
                           1
                           
                              
                                 0
                              
                              
                                 −
                                 6
                              
                           
                         in our implementation. Table 1
                         lists the model complexity and the performance of our algorithm and Fig. 8
                         shows the computed CVT on some 3D models. Fig. 9
                         shows CVT on high genus models.

To evaluating the quality of our results, we compute the Delaunay triangulation, which is the dual graph of CVT. Then we adopt the following measures  [38,2]:
                           
                              •
                              Triangle quality: Let 
                                    Q
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    6
                                    
                                       
                                          S
                                       
                                       
                                          t
                                       
                                    
                                    /
                                    
                                       (
                                       
                                          
                                             3
                                          
                                       
                                       
                                          
                                             p
                                          
                                          
                                             t
                                          
                                       
                                       
                                          
                                             h
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                  be the quality of a triangle 
                                    t
                                 , where 
                                    
                                       
                                          p
                                       
                                       
                                          t
                                       
                                    
                                 , 
                                    
                                       
                                          S
                                       
                                       
                                          t
                                       
                                    
                                  and 
                                    
                                       
                                          h
                                       
                                       
                                          t
                                       
                                    
                                  are the inradius, area, and the length of the longest edge of 
                                    t
                                 , respectively. Let 
                                    
                                       
                                          Q
                                       
                                       
                                          
                                             min
                                          
                                       
                                    
                                  (resp. 
                                    
                                       
                                          Q
                                       
                                       
                                          
                                             avg
                                          
                                       
                                    
                                 ) be the minimal (resp. average) quality measure. The closer the value to 1.0, the more isotropic of the Delaunay triangulation, therefore, the higher quality of the CVT one obtains.

Minimal angle: Let 
                                    
                                       
                                          θ
                                       
                                       
                                          
                                             min
                                          
                                       
                                    
                                  be the minimal of the smallest angle of all triangles and 
                                    
                                       
                                          θ
                                       
                                       
                                          
                                             avg
                                          
                                       
                                    
                                  the average of minimal angles of all triangles. The closer the values of 
                                    
                                       
                                          θ
                                       
                                       
                                          
                                             min
                                          
                                       
                                    
                                  and 
                                    
                                       
                                          θ
                                       
                                       
                                          
                                             avg
                                          
                                       
                                    
                                  to 60°, the more isotropic of the triangulation one obtains.

Compared to the parameterization-based methods  [9–11], our method avoids the inaccuracy due to the approximation and metric distortion in parameterization. Furthermore, our method can apply to models of arbitrary geometry and topology, for which the parameterization is not easy to obtain. As Fig. 12 shows, our method outperforms the UCS method  [10] and the RVD method  [2] in terms of quality (higher angle measure 
                           
                              
                                 Q
                              
                              
                                 
                                    ave
                                 
                              
                           
                         and lower number of singularities).

The restricted Voronoi diagram methods  [2,39] approximate the CVT on surface by computing the intersection of a 3D CVT and the input mesh. Although it works fairly well for models with simple geometry, this approximation is extrinsic, that is, embedding space dependent. Fig. 11
                        
                        shows a Coil Spring model, where the coil almost touches itself and leaves very small gap. The RVD method cannot distinguish the geometrically-close-but-topologically-far pieces, and produces the wrong result. Our method is completely intrinsic in that all the computations are based on the metric only. So it can clearly distinguish these geometric “ambiguity”. To further demonstrate the efficacy of our intrinsic method, we apply it to the Lion model in various poses. As Fig. 13
                         shows, the computed CVTs are consistently among the near-isometric poses. Fig. 14
                         shows the CVTs with very few sites. Since each Voronoi cell is big, we can clearly see the difference between the extrinsic RVD and our intrinsic CVT.

@&#CONCLUSION@&#

This paper presents an intrinsic algorithm for computing centroidal Voronoi tessellation on arbitrary triangle meshes. Our algorithm adopts the Lloyd framework, which iteratively moves the generator of each geodesic Voronoi diagram to its mass center. Based on the discrete exponential map, our method can efficiently compute the Riemannian center and the center of mass for any geodesic VD. Thanks to its intrinsic feature, our method works well for models with arbitrary topology and complicated geometry, where the existing extrinsic approaches often fail. The promising experimental results show the advantages of our method.

@&#ACKNOWLEDGMENTS@&#

This research was done for Fraunhofer IDM
                     @
                  NTU, which is funded by the National Research Foundation (NRF) and managed through the multi-agency Interactive & Digital Media Programme Office (IDMPO) hosted by the Media Development Authority of Singapore (MDA). The NTU authors are supported by Singapore Ministry of Education (MOE) Grants RG40/12 and MOE2013-T2-2-011. Y.-J. Liu is partially supported by the National Natural Science Foundation of China (61322206) and the National High Technology Research and Development Program of China (2012AA011801). X. Gu acknowledges the grants AFOSR
                  FA9550-10-1-0294, NSF
                  DMS-1221339, and Nets-1016829. We thank Prof. Xiaohu Guo for sharing his results, Dr. Yang Liu for his HLBFGS codes, and the anonymous reviewers for their valuable comments.

@&#REFERENCES@&#

