@&#MAIN-TITLE@&#Recommendations of closed consensus temporal patterns by group decision making

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A new model is proposed to find closed consensus temporal patterns.


                        
                        
                           
                           The experiments were performed by synthetic and real datasets.


                        
                        
                           
                           This showed the model’s computational efficiency, scalability, and effectiveness.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Group decision making

Data mining

Recommendation systems

Consensus temporal pattern

Closed pattern

@&#ABSTRACT@&#


               
               
                  The aggregation of individuals’ preferences into a consensus ranking is a decision support problem which has been widely used in various applications, such as decision support systems, voting systems, and recommendation systems. Especially when applying recommendation systems in business, customers ask for more suggestions about purchasing products or services because the tremendous amount of information available can be overwhelming. Therefore, we have to gather more preferences from recommenders and aggregate them to gain consensuses. For an example of preference ranking, C>A⩾D⩾B indicates C is favorable to A, A is somewhat favorable but not fully favorable to D, and ultimately D is somewhat favorable but not fully favorable to B, where > and ⩾ are comparators, and A, B, C, and D are items. This shows the ranking relationship between items. However, no studies, to the best of our knowledge, have ever developed a recommendation system to suggest a temporal relationship between items. That is, “item A could occur during the duration of item B” or “item C could occur before item D”. This type of recommendation can be applied to the reading order of books, course plans in colleges, or the order of taking medicine for patients. This study proposes a novel recommendation model to discover closed consensus temporal patterns, where closed means the patterns are only the maximum consensus sequences. Experiments using synthetic and real datasets showed the model’s computational efficiency, scalability, and effectiveness.
               
            

@&#INTRODUCTION@&#

In group decision making, aggregating individual preferences and obtaining consequences has become a significant and interesting issue, called the group ranking problem 
                     [22,23,29] (or multi-person decision making [6]). Generally, this type of decision cannot be made by any optimal approaches, requiring members’ opinions to subjectively determine a compromising result, which sometimes could be neither efficient nor effective in theory. Members, however, are requested to negotiate with one another to reach a consensus and believe the decision is (1) fair and open and (2) the best result for us at this time [55]. Afterwards they could achieve the consensus of which the term is defined as: (1) general agreement and (2) group solidarity in belief and sentiment [48].

The group ranking problem has been examined for more than two centuries [15] and applied to many fields, such as recommendation systems [21,43,49,56], machine learning [28], sport tournaments [46], and decision support models [14,29]. In recommendation systems, we can consider more preference recommendations for items, such as books, CDs, and other products, through the group rating. For example, in the recommendation system of Amazon.com, five users rated four books, a, b, c, and d, based on their preferences as (1) c>a⩾d⩾b, (2) c⩾a⩾d>b, (3) a>c>d>b, (4) c>a>d>b, and (5) c>a>d⩾b, where > denotes the former is favorable to the latter, and ⩾ denotes the former is somewhat favorable but not fully favorable to the latter. As a result, we generally discern the reading order of the five books recommended by users is c first, and then is a, d, and finally b. As in the example, the goal is to aggregate each user’s ranking and ultimately produce a result. In this case, however, user (3) has a different opinion about a>c than the other users. Therefore, the task of integrating these preferences into a consensus solution is one of the major steps in this problem [58].

To extract the aggregated information from individuals’ preferences, group ranking models are classified into two types, full and partial rankings. The former requires participators to appraise whole alternatives, whereas the latter allows for cases in which they can only compare with a subset of alternatives. The former representation proposed by Kemeny and Snell [36] was developed for complete and weak orderings. Bogart [9] extended the idea to include partial orderings. Both types have their advantages and are applied to different environments. For example, if we would like to acquire the complete orderings, the preferences for all alternatives must be ranked by participators. Moreover, conflict resolution takes place to obtain the final ranking of all alternatives if the preferences for some alternatives have different rankings. In the partial ranking, participators can naturally give their preferences for a subset of alternatives if they are not required to offer the rankings for the whole alternatives.

Traditionally, the group ranking problem deals with preference among items, meaning which items are preferable to other items. However, the interest in the temporal relationships between items is of importance in real-life circumstances as well. We can give the temporal preferences of items; for example, “item a could occur during the duration of item b” or “item a could occur before item c”. The recommendation in temporal preferences can be availed in many cases. For book recommendations in Amazon, users can suggest the reading order of books. For a course plan in a college, students take suggestions about the study order of courses. The above examples can benefit users if recommenders can adequately present their opinions, and the results produced by the aggregation procedure are provided. Another example is the order of taking medicine for patients recommended by doctors. When a patient takes different kinds of medicines, their interactive influences have to be considered during treatment. Some medicines can be taken during the same period; however, some should be taken in disjointed periods. All of these examples demonstrate the issue of temporal recommendation is interesting and necessary in real-life circumstances. To the best of our knowledge, however, no studies have addressed this problem.

Inspired by the idea of frequent itemset mining (FIM), Chen and Cheng [22] proposed a discovery model of maximum consensus sequences (MCS) for rankings, generating the maximum (or closed) sequences if their supports are larger than or equal to the user-specified threshold. Since the feature of FIM is adopted from the level-wise heuristic, generating candidates from length k
                     −1 frequent itemsets and testing their supports to find length k frequent itemsets, the MCS model can arrive at the maximum agreement level-by-level and identify the conflict items. Differing from the traditional consensus approaches, i.e. distance-based and ad hoc models [15,25,57], their model is able to establish a simpler line to extend the consensus issue for application to other types of group decision making. Therefore, we follow the line of FIM to solve our research problem.

To establish the temporal recommendation model, we first have to discuss whether we should consider the complete set of items in rankings or not. For example, a complete set needs to provide the relationships between a and b, b and c, c and d, and a and d and among a, b, and c, b, c, and d, and a, b, c, and d. However, with only the relationships between a, b, c, and d, we can obtain all the above relationships. In light of the description, we follow the idea of mining frequent closed itemsets 
                     [60] to uncover closed consensus temporal orderings (or called patterns); that is, a pattern I is closed if no superset of I exists with the same support. An example to describe non-closed and closed itemsets is as follows.
                        
                           •
                           
                              Non-closed itemsets: ab, ac, ad, bc, bd, cd, abc, abd, bcd, acd, abcd, bc, bf, cf, and bcf (assume that their supports are the same);


                              Closed itemsets: abcd and bcf.

This depicts the idea of the latter not only can avoid providing a huge amount of information to us, but does not lose all of them.

Since no previous research has addressed the topic of recommendation systems for recommending temporal preferences with the closed idea, we first propose an algorithm to find this kind of pattern, closed consensus temporal patterns, in the data mining field. The algorithm is developed by extending the well-known generalized sequential pattern (GSP) algorithm, which uses a stage-by-stage process for generating frequent patterns [52]. To correspond with the consensus requirement in decision making, however, we modify some steps of the GSP algorithm and develop some special functions for our proposed patterns. Moreover, we tackle a conflict case if the temporal relationship between items suggested by users reaches a specified conflict threshold.

This paper is organized as follows. Section 2 reviews related studies. Section 3 formally defines the problem. A new algorithm, closed consensus temporal mining (CCTM), is developed in Section 4. Section 5 describes experiments that evaluate the efficiency, scalability, and effectiveness of our algorithm. Finally, conclusions are presented in Section 6.

@&#RELATED WORKS@&#

This section reviews managerial studies related to social choice and the group ranking problem in Sections 2.1 and 2.2. After that, we review technical studies of sequential patterns mining in Section 2.3.

In a democratic society, there are essentially two methods by which social choices can be made – voting, used to make political decisions and the market mechanism, used to make economic decisions [1]. In this study, the group ranking problem belongs to the former, aggregating individual preferences into a collective choice. According to the paradox of voting 
                        [1], the ranking of alternatives based on people preferences may involve the intransitivity phenomenon. Arrow [1] proposed five properties of the impossibility theorem in social choice theory necessary to avoid the intransitivity. Therefore, to achieve the work of social choice, a good voting system has to be constructed for collecting opinions simultaneously and also addressing the conflict issue to obtain the consensus results [7,8,39–41,47,50]. Our proposed model can fulfill the above requirements to gain closed consensus temporal patterns because it widely collects people opinions from the Internet and can solve conflict problems.

When dealing with the group ranking problem, we generally have to discuss three issues [22]. The first is the input format in which individual preferences are collected and expressed. The second is the input completeness of preferences given by individuals. The final issues talks about the work of combining these preferences into comprised outcomes. In general, individuals can express their thoughts by three methods. The first is to acquire them by assigning rates, e.g. 5-Likert or 7-Likert scales, or by fuzzy sets, e.g. fuzzy numbers [45], to the evaluated items. The second is to acquire them by providing a set of pare-wise comparisons for all alternatives [15]. The last is to provide ranking lists for the evaluated items [22,23]. When inputting the preferences, individuals are required to provide two types, the full ranking approach [11,25,36,26,51] and the partial ranking approach [7,9,12,13,16,30,33]. As a result, the comprised outcomes appear in two types, full and partial orders, by the full and partial ranking approaches.

There are many techniques which are proposed to solve the group ranking problem. They can be classified into four categories: (1) using scoring functions [10], (2) minimizing a distance measurement [13,15], (3) ranking ordering to gain the best outcome by considering members as criteria [37] or defining a weighted preference relation [9,57], and (4) ways to calculate votes in favors of the propositions [27].

Sequential pattern mining (SPM) was first introduced in the mid-1990s, when it was shown patterns occur frequently in sequence databases [5]. For example, suppose 65% of customers return to buy two books, Introduction to Logic and Queen Victoria: A Personal History, after buying the book Alice’s Adventures in Wonderland. The sequence of items, <Alice’s Adventures in Wonderland (Introduction to Logic, Queen Victoria: A Personal History)>, is called a sequential pattern with a support of 65%, where its support is over a user-specified minimum support threshold. In the SPM problem, these patterns are discovered from a sequence database, of which data is automatically collected by information systems. This data-collection approach is called the objective model because its data source is naturally gathered by human behaviors without intervening with them. In this research problem, however, our data source (data sequences) is manually collected by asking for human opinions; therefore, we term it the subjective model. After gaining data sequences as the input data, we proposed a GSP-like approach [52] to dig out closed consensus temporal patterns that gain support from a user given a majority of judgments. In addition, for finding the consensus results, we modified the traditional process of SPM as well. The above descriptions are the major differences between our approach and SPM.

SPM has been successfully applied to real-life circumstances, and extensions have been proposed in many topics, including: (1) other variants of patterns, including maximum patterns [5], similar patterns [3,53], cyclic patterns [31,32], traversal patterns [17,44], multidimensional patterns [61], and hybrid patterns [18], (2) constraint-based sequential pattern mining [24], (3) mining sequential patterns in web or e-commerce applications [35,54], and (4) fuzzy sequential pattern mining [19,20,34]. As mentioned in the introduction above, these studies all discussed how to discover patterns in point-based databases. Hence, Kam and Fu [38] followed the time-related idea proposed by Allen [2] to find temporal patterns in interval-based databases. The time relationships include 7 relations as well as 6 relations for inverse, i.e. before, after, during, contain, meet, met by, overlap, overlapped by, start, started by, finish, finished by, and equal. Since the patterns defined by Kam and Fu [38] are ambiguous, Wu and Chen [59] followed their idea and then defined a new type of temporal pattern, which can solve their ambiguous problem. In this study, we referred to the time-related idea from Allen [2] and the discovery model from Wu and Chen [59] to develop our research model.

Previous studies have proposed many efficient methods to improve the performance of SPM [60], including the mining of frequent subtrees, lattices, subgraphs, and structured patterns. However, when mining longer sequences or using lower support thresholds, the performance of those methods is dramatically exacerbated. Therefore, Yan et al. [60] developed a method to mine frequent closed itemsets to overcome this difficulty. Since the closed idea can provide concise patterns, we placed it in our proposed model.

Here, we formally define the problem of mining closed consensus temporal patterns from temporal data.

Let UID
                     ={u
                     1,
                     u
                     2,…,
                     um
                     } be the user identifiers and I
                     ={i
                     1,
                     i
                     2,…,
                     in
                     } be the set of distinct items. Each user identifier ui
                      (1⩽
                     i
                     ⩽
                     m) has provided a temporal list of items according to the user’s preferences. Let si
                      be a temporal sequence that denotes the time list for the user identifier ui
                      and be defined as:
                        
                           1.
                           
                              si
                              
                              ={ik1
                              
                              ⊗1
                              
                              ik2
                              
                              ⊗2
                              …
                              ikn−1
                              
                              ⊗
                                 n−1
                              
                              
                              ikn
                              }, where 1⩽
                              i
                              ⩽
                              m, ikj
                              
                              ∊
                              I, 1⩽
                              kj
                              ⩽
                              n, and ⊗∊{&,→,∼};


                              ikx
                              
                              ≠
                              iky
                              , where x
                              ≠
                              y.

The comparator (time relation) “&” means the preceding and succeeding items occurred together. The comparator (time relation) “→” indicates the succeeding item occurred after the preceding one. Finally, the comparator (time relation) “∼” means the preceding item can occur together with or before the succeeding one; i.e., the relation between the two items can hold both comparators. Specifically, this comparator is not provided by users but automatically generated by our proposed model. The details are described in the following section. Figs. 1a and 1b
                     
                      list all possible cases of the comparators “→” and “&”, which might be perceived by users when they compare a pair of items.

For example, we have I
                     ={a,b,c,d,e}, and u
                     1 has s
                     1
                     ={b∼e&d&a→c} and u
                     2 has s
                     2
                     ={b→e∼d&c→a}. The total number of items in a temporal sequence is the length of the sequence. A temporal sequence whose length is l is referred to as a l-T-sequence.
                        Definition 1
                        Given a temporal sequence s
                           ={ikx
                           
                           ⊗
                              x
                           
                           …⊗
                              y
                           
                           −1
                           
                           iky
                           
                           …} whose length is n, a function to get the time relation between two different items is defined as TR(s,
                           ikx
                           ,
                           iky
                           ), where ikx
                            and iky
                            are items in s, and its result is:

If ∀⊗
                                 j
                              
                              ∊“&”, for 1⩽
                              x
                              ⩽
                              j
                              <
                              y
                              ⩽
                              n, then TR(s,
                              ikx
                              ,
                              iky
                              ) equals “&”;

If ∃⊗
                                 j
                              
                              ∊“→”, for 1⩽
                              x
                              ⩽
                              j
                              <
                              y
                              ⩽
                              n, then TR(s,
                              ikx
                              ,
                              iky
                              ) equals “→”;

If ∃⊗
                                 j
                              
                              ∊“∼”, for 1⩽
                              x
                              =
                              j
                              <
                              y
                              =
                              x
                              +1⩽
                              n, then TR(s,
                              ikx
                              ,
                              iky
                              ) equals “∼”;

If ∃⊗
                                 j
                              
                              ∊“∼”, for 1⩽
                              x
                              <
                              j
                              <
                              y
                              ⩽
                              n, then
                                 
                                    –
                                    if ∃⊗
                                          j
                                       
                                       ∊“→”, for y′=
                                       y
                                       +1 and 1⩽
                                       x
                                       ⩽
                                       j
                                       <
                                       y′⩽
                                       n, then TR(s,
                                       ikx
                                       ,
                                       iky
                                       ) equals “→”;

otherwise, TR(s, ikx
                                       , iky
                                       ) equals “∼”.

Suppose we have a temporal sequence s
                           ={b→e&d&c∼a}. Then the time relations of s are TR(s,e,c)=“&”, TR(s,b,c)=“→”, and TR(s,b,a)=“→”.

Let sα
                           
                           ={a
                           1
                           ⊗1
                           
                           a
                           2
                           ⊗2
                           …
                           an
                           
                           −1
                           ⊗
                              n
                           
                           −1
                           
                           an
                           } be a temporal sequence and 
                              
                                 
                                    
                                       s
                                    
                                    
                                       β
                                    
                                 
                                 =
                                 {
                                 
                                    
                                       b
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       ⊗
                                    
                                    
                                       1
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ⊗
                                    
                                    
                                       2
                                    
                                    
                                       ′
                                    
                                 
                                 …
                                 
                                    
                                       b
                                    
                                    
                                       m
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       ⊗
                                    
                                    
                                       m
                                       -
                                       1
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       b
                                    
                                    
                                       m
                                    
                                 
                                 }
                              
                            be another sequence, where m
                           ⩽
                           n. sβ
                            is contained in sα
                            if there are integers 1⩽
                           j
                           1
                           <
                           j
                           2
                           <⋯<
                           jm
                           
                           ⩽
                           n in sα
                            satisfying the following:


                              b
                              1
                              =
                              aj1
                              ,
                              b
                              2
                              =
                              aj2,
                              
                              …,
                              bm
                              
                              =
                              ajm
                              ;

If 
                                 
                                    
                                       
                                          ⊗
                                       
                                       
                                          i
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              =“&” or 
                                 
                                    
                                       
                                          ⊗
                                       
                                       
                                          i
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              =“→”, then 
                                 
                                    TR
                                    (
                                    
                                       
                                          s
                                       
                                       
                                          α
                                       
                                    
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          
                                             
                                                j
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          
                                             
                                                j
                                             
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    )
                                    =
                                    TR
                                    (
                                    
                                       
                                          s
                                       
                                       
                                          β
                                       
                                    
                                    ,
                                    
                                       
                                          b
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          b
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    )
                                 
                              , for 1⩽
                              ji
                              
                              ⩽⋯⩽
                              jm
                              
                              ⩽
                              n and 1⩽
                              i
                              ⩽
                              m; otherwise, if TR(sβ
                              ,
                              bi
                              ,
                              bi+1
                              )=“∼”, then 
                                 
                                    TR
                                    (
                                    
                                       
                                          s
                                       
                                       
                                          α
                                       
                                    
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          
                                             
                                                j
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          
                                             
                                                j
                                             
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    )
                                 
                               can be equal to “&” or “→”, meaning “do not care”.

Suppose we have two sequences sα
                           
                           ={b→e&d&c→a} and sβ
                           
                           ={b→d∼a}. Then sβ
                            is contained in sα
                           , because distinct integers j
                           1
                           =1, j
                           2
                           =3, and j
                           3
                           =5 exist so that:


                              TR(α,
                              b,
                              d)=
                              TR(β,
                              b,
                              d)=“→”;

since TR(sβ
                              ,
                              d,
                              a) equals “∼”, TR(sα
                              ,
                              d,
                              a)=“→” is satisfied.

A temporal sequence 
                              
                                 
                                    
                                       s
                                    
                                    
                                       α
                                    
                                 
                                 =
                                 {
                                 
                                    
                                       a
                                    
                                    
                                       1
                                    
                                 
                                 
                                    
                                       ⊗
                                    
                                    
                                       1
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       a
                                    
                                    
                                       2
                                    
                                 
                                 
                                    
                                       ⊗
                                    
                                    
                                       2
                                    
                                    
                                       ′
                                    
                                 
                                 ⋯
                                 
                                    
                                       a
                                    
                                    
                                       n
                                       -
                                       1
                                    
                                 
                                 
                                    
                                       ⊗
                                    
                                    
                                       n
                                       -
                                       1
                                    
                                    
                                       ′
                                    
                                 
                                 
                                    
                                       a
                                    
                                    
                                       n
                                    
                                 
                                 }
                              
                            is a subsequence of temporal sequence sγ
                           
                           ={r
                           1
                           ⊗1
                           
                           r
                           2
                           ⊗2
                           ⋯
                           rm
                           
                           −1
                           ⊗
                              m
                           
                           −1
                           
                           rm
                           } if there are integers 1⩽
                           k
                           1
                           <
                           k
                           2
                           <⋯<
                           kn
                           
                           ⩽
                           m in sα
                            satisfying the following:


                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                    =
                                    
                                       
                                          r
                                       
                                       
                                          
                                             
                                                k
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    =
                                    
                                       
                                          r
                                       
                                       
                                          
                                             
                                                k
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          a
                                       
                                       
                                          n
                                       
                                    
                                    =
                                    
                                       
                                          r
                                       
                                       
                                          
                                             
                                                k
                                             
                                             
                                                n
                                             
                                          
                                       
                                    
                                 
                              ;


                              
                                 
                                    
                                       
                                          ⊗
                                       
                                       
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⊗
                                       
                                       
                                          
                                             
                                                k
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⊗
                                       
                                       
                                          
                                             
                                                k
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       
                                          ⊗
                                       
                                       
                                          n
                                          -
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    =
                                    
                                       
                                          ⊗
                                       
                                       
                                          
                                             
                                                k
                                             
                                             
                                                n
                                                -
                                                1
                                             
                                          
                                       
                                    
                                 
                              .

Suppose we have two temporal sequences sα
                           
                           ={b→e&d&c→a} and sγ
                           
                           ={b→e&d}. Then sγ
                            is called the subsequence of sα
                            because distinct integers k
                           1
                           =1, k
                           2
                           =2, and k
                           3
                           =3 exist so: (1) a
                           1
                           =
                           r
                           1
                           =b, a
                           2
                           =
                           r
                           2
                           =e, and a
                           3
                           =
                           r
                           3
                           =d and (2) 
                              
                                 
                                    
                                       ⊗
                                    
                                    
                                       1
                                    
                                    
                                       ′
                                    
                                 
                              
                           
                           =⊗1
                           =“→” and 
                              
                                 
                                    
                                       ⊗
                                    
                                    
                                       2
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 
                                    
                                       ⊗
                                    
                                    
                                       2
                                    
                                 
                              
                           
                           =“&”.

A data sequence is represented by (u,
                     s), where u is a user identifier and s is a temporal sequence. A temporal sequential database S is formed from a set of data sequences (u,
                     s).
                        Definition 4
                        For a given temporal sequence β, its support in database S is defined as follows.


                     
                        
                           
                              
                                 support
                              
                              
                                 S
                              
                           
                           (
                           β
                           )
                           =
                           
                              
                                 {
                                 (
                                 u
                                 ,
                                 s
                                 )
                                 |
                                 (
                                 u
                                 ,
                                 s
                                 )
                                 ∈
                                 S
                                 ∩
                                 β
                                 
                                 is contained in
                                 
                                 s
                                 }
                              
                              
                                 |
                                 S
                                 |
                              
                           
                        
                     , where |S| is denoted as the number of data sequences in S.

As in the definition of consensus decision making 
                     [55], consensus is a negotiation method, ensuring a group can share their understanding, and finally all members reach agreement by majority voting. Hence, we propose a minimum support threshold to filter out sequences whose supports have not reached a majority.

Given a positive value min_sup as the minimum support threshold, a temporal sequence β is called a consensus temporal pattern or a frequent consensus temporal sequence if the support of β is no less than min_sup. According to the closed idea [60], β is a closed consensus temporal pattern or frequent closed consensus temporal sequence if no superset of β exists with the same support in the database. A closed consensus temporal pattern whose length is k is referred to as a k-CCT pattern.

This section proposes the closed consensus temporal mining (CCTM) algorithm to find closed consensus temporal patterns. The CCTM algorithm is developed by modifying the well-known GSP algorithm [52]. However, there are two major differences between the CCTM and GSP algorithms.
                        
                           1.
                           In group decision making, there may be a case in which the different opinions from two groups are tied. For example, suppose the supports of sequences {b&e} and {b→e} are 0.34 and 0.33, respectively. Their supports are almost the same, and they all belong to patterns if min_sup
                              =0.3; however, they provoke a conflict, i.e. the time-relation contradiction. To report this conflict, in the algorithm, we develop a new comparator “∼”, meaning the time relations of b and e can be either “&” or “→”. The comparator is not provided by recommenders but automatically generated by the algorithm if a contradiction occurs. Accordingly, {b∼e} in place of {b&e} and {b→e} reveals half of the people support the recommendation of {b&e}, whereas the other half support that of {b→e}. In addition, the conflict identification depends on a conflict threshold, θ. If the support of {b&e} divided by that of {b→e} is equal to or larger than θ, the conflict is established. Notably, we only inform the time-relation contradiction but not the item contradiction, e.g. the circumstance of {b→e} and {e→b}.

Since the support of {b∼e} is calculated by adding the supports of {b&e} and {b→e}, we harness a coefficient ρ to multiply the support of {b∼e} to diminish the support of {b&e}. In this way, the support of {b∼e} can be decreased if ρ
                              <1 or the original value if ρ
                              =1.

In the CCTM algorithm, there are two phases which are repeatedly executed to generate patterns. The first phase generates candidate temporal sequences (candidate sequences hereafter) of length k, denoted by Ck
                     , from the frequent consensus temporal sequences (frequent sequences hereafter) of length k
                     −1, denoted by Lk
                     
                     −1. In each cycle, one more item and its time relation will be added to each candidate sequence, based on the frequent sequences in the preceding cycle. After finding all candidate sequences, the second phase scans the database once to determine the support of each candidate sequence, and the result consists of all frequent patterns of length k.

The process of finding the candidate sequences for the different lengths of k (the first phase) is described as follows.
                        
                           (1)
                           For k
                              =1: The set of candidate sequences of length 1, C
                              1, will be generated by enumerating all distinct items of the database.

For k
                              =2: Traditionally, C
                              2 is obtained by directly joining L
                              1 with L
                              1; that is, C
                              2
                              =
                              L
                              1
                              ×
                              L
                              1, where × denotes the joining operation. However, since the first and second items in C
                              2, e.g., ix
                               and iy
                              , have two time relations, the “&” and “→”, pairs for the two comparators must be generated. Let us consider an explanatory example. Suppose {ix
                              } and {iy
                              } belong to L
                              1 and ⊗={&,→}. Then C
                              2 has a total of two candidate sequences, {ix
                              
                              &
                              iy
                              } and {ix
                              
                              →
                              iy
                              }. In a word, C
                              2 can be generated by L
                              1
                              ×⊗×
                              L
                              1.

For k
                              >2: Let 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          α
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    ⋯
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                       
                                    
                                    }
                                 
                               be a k frequent sequence in Lk
                              . Based on the anti-monotonic property in Appendix A, the (k
                              −1)-subsequences of 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          α
                                       
                                    
                                    ,
                                    
                                       
                                          s
                                       
                                       
                                          
                                             
                                                α
                                             
                                             
                                                1
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    ⋯
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                    }
                                 
                               and 
                                 
                                    
                                       
                                          s
                                       
                                       
                                          
                                             
                                                α
                                             
                                             
                                                2
                                             
                                          
                                       
                                    
                                    =
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          3
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          3
                                       
                                       
                                          ′
                                       
                                    
                                    ⋯
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                       
                                    
                                    }
                                 
                              , must be frequent, because the support of sα
                               cannot be larger than the supports of sα1
                               and sα2
                              . Therefore, if sequences 
                                 
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    ⋯
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                    }
                                 
                               and 
                                 
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          3
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          3
                                       
                                       
                                          ′
                                       
                                    
                                    ⋯
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                       
                                    
                                    }
                                 
                               exist in Lk−1
                              , then 
                                 
                                    {
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          2
                                       
                                       
                                          ′
                                       
                                    
                                    ⋯
                                    
                                       
                                          a
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                    
                                    
                                       
                                          ⊗
                                       
                                       
                                          k
                                          -
                                          1
                                       
                                       
                                          ′
                                       
                                    
                                    
                                       
                                          a
                                       
                                       
                                          k
                                       
                                    
                                    }
                                 
                               must exist in Ck
                              . All the sequences in Ck
                               can be generated by joining the sequences in Lk−1
                               this way.

Next, we will discuss how to execute the second phase, i.e., to determine the supports of all sequences in Ck
                     . To this end, a tree structure, called a candidate tree, is adopted as a basis. Basically, it is similar to the prefix tree adopted in previous studies [4,42]. The major difference lies in that the traditional approach connects each tree branch with an item name, whereas, in the new approach, two components are attached – an item name and a time relation.

Suppose we are given a candidate set Ck
                     . Initially, we have an empty tree with a single root node. Then, we insert every sequence in Ck
                      into the tree, just as when building a prefix tree. After all the sequences in Ck
                      have been inserted, the tree is built. Next, we traverse the tree for every transaction. For a given transaction, after finishing the traversal we can determine the degrees at which the patterns in the tree are contained in that transaction. Finally, after the tree has been traversed by all transactions, the support value of every sequence is kept in the corresponding leaf node in the tree. Thus, we can determine which sequences are frequent and which are not.

In this phase, however, there is an exception procedure in L
                     2. If L
                     2 has two sequences, called sx
                      and sy
                     , whose two items, i
                     1 and i
                     2, are identical but whose time relations are not, we then calculate their ratio. The ratio is calculated by sx
                     .count/sy
                     .count if sx
                     .count
                     ⩽
                     sy
                     .count; otherwise sy
                     .count/sx
                     .count, where sx
                     .count and sy
                     .count are the supports of sx
                      and sy
                     . Accordingly, if the ratio is equal to or larger than a conflict threshold θ, the two sequences, {ix
                     
                     &
                     iy
                     } and {ix
                     
                     →
                     iy
                     }, are removed from L
                     2, and {ix
                     
                     ∼
                     iy
                     } is added into L
                     2. In addition, since the support of {ix
                     
                     ∼
                     iy
                     } is calculated by adding the supports of {ix
                     
                     &
                     iy
                     } and {ix
                     
                     →
                     iy
                     }, we adopt a diminishing coefficient ρ to multiply the support of {ix
                     
                     ∼
                     iy
                     } to decrease the support of {ix
                     
                     ∼
                     iy
                     }. When k
                     >2, we also adopt this approach. In the following experimental study, we will adjust the two arguments, θ and ρ, to observe the changes in the number of patterns.

As follows, the major steps of the CCTM algorithm are listed in Fig. 2
                     . For the sake of clarity, we omit the details of the functions and steps.
                        Example 4
                        Consider the temporal sequential database shown in Table 1
                            and assume we set min_sup
                           =0.45, θ
                           =0.95, and ρ
                           =0.85. Then, the supports of all items in C
                           1
                           ={a,b,c,d,e} are 1.0, and we have L
                           1
                           ={a,b,c,d,e} because their supports are larger than min_sup. After that, C
                           2 are generated by joining by L
                           1 with ⊗={&,→}. To take an example of two frequent sequences, a and b, in L
                           1, two candidate sequences, {a&b} and {a→b}, can be generated in C
                           2 by the first phase. Finally, we have the candidate sequences in C
                           2 and find the frequent patterns in L
                           2 as follows (the format is sequence: support):

{a→b}: 0.6, {a→c}: 0.7, {a→d}: 0.7, {a→e}: 0.6, {b→c}: 0.5, {b&c}: 0.5, {b→d}: 0.5, {b&d}: 0.5, {b→e}: 0.6, {c&d}: 1.0, {c&e}: 0.6, and {d&e}: 0.6.

Further, there are two pairs of time-relation contradictions, {b→c} and {b&c} and {b→d} and {b&d}, because their ratios are both larger than θ. They are then replaced by two new frequent sequences, {b∼c} and {b∼d}. Ultimately, we have a new set of L
                     2
                     ={{a→b}, {a→c}, {a→d}, {a→e}, {b∼c}, {b∼d}, {b→e}, {c&d}, {c&e}, {d&e}}.

After the generation of L
                     2, the algorithm begins to produce Ck
                      and Lk
                      for k
                     >2. Since there are 10 frequent sequences in L
                     2, the candidate sequences and their supports multiplied by ρ in C
                     3 are enumerated as follows.
                        
                           •
                           {a→b∼c}: 0.51, {a→b∼d}: 0.51, {a→b→e}: 0.3, {a→c&d}: 0.7, {a→c&e}: 0.3, {a→d&e}: 0.3, {b∼c&d}: 0.85, {b∼c&e}: 0.51, {b∼d&e}: 0.51, and {c&d&e}: 0.6.

After filtering C
                     3 by the support mechanism, we have L
                     3 as {{a→b∼c}, {a→b∼d}, {a→c&d}, {b∼c&d}, {b∼c&e}, {b∼d&e}, {c&d&e}}.

Because C
                     4 can still be generated from L
                     3, we gain C
                     4 and its sequences’ supports as: {a→b∼c&d}: 0.51, {a→b∼d&e}: 0.17, {b∼c&d&e}: 0.51, and {a→c&d&e}: 0.51, and L
                     4 is {a→b∼c&d} and {b∼c&d&e}. Since there are no candidate patterns in C
                     5, the procedure is terminated. Based on the above computations, we eventually obtain all closed consensus temporal patterns as {a→e}, {a→b∼d}, {a→c&d}, {b∼c&e}, {b∼d&e}, {a→b∼c&d}, and {b∼c&d&e}.

In this section, we use several synthetic datasets and one real dataset to evaluate the performance of the CCTM algorithm. The proposed algorithm was implemented using Sun Java™ language (J2SDK 1.4.2_16) and tested on a PC with an Intel Core 2 Duo 2.4GHz processor and 2GB main memory using the Microsoft™ Windows Server 2003 operating system. Neither multithreading technology nor parallel computing skills were used in implementing our programs. As follows, we present the results of the experiments using the synthetic datasets in Section 5.1 and the results of those using the real dataset in Section 5.2.

Synthetic datasets are generated by applying the well-known synthetic data generation algorithm in the study of Agrawal and Srikant [5]. In the traditional method, the sequence generation begins by having the itemset, meaning items in the itemset occur together like in our proposed relation, &. After that, a sequence is generated by itemsets; therefore, the relation of items between different itemsets is like →. Based on the description above, we modified their algorithm to develop the data generator. Table 2
                         shows the parameters in this generator and their definitions.

Here, we specify each synthetic dataset contains |U| users, each of which has |S| itemsets and |I| items in each itemset. The parameter |NI| is set to describe the number of recommended items. Therefore, if |NI| equals |S|×|I|, the mined results are presented as the full ranking case. In general, we can set them as |NI|⩾|S|×|I|. Moreover, we used the parameter acr to generate the conflict between the two relations, & and →, in proportion, which can turn into the relation ∼. If |U|=1000 and acr
                        =10%, the generator will randomly generate 100 pairs of items, picked from all recommended items (50 pairs have the relations & and → respectively) and also insert them into any 100 of 1000 sequences randomly. In the simulation, the parameter |NI| is fixed as 100.

The first comparison analyzes the run times of the CCTM algorithm observed in six diminishing coefficients, ρ
                        =100%, ρ
                        =90%, ρ
                        =80%, ρ
                        =70%, ρ
                        =60%, and ρ
                        =50%, with different minimum supports and a fixed conflict threshold, θ
                        =0.9. A comparison is made on the basis of the four datasets shown in Table 3
                        , in which the minimum support threshold varies from 5% to 25%. Figs. 3–6
                        
                        
                        
                         summarize the results. From these four datasets, we can observe how the performance of the CCTM algorithm using six diminishing coefficients changes as we vary the value of acr. Table 3 lists the parameter settings of different synthetic data generations.

The results all indicate the CCTM algorithm in ρ
                        =50% is the fastest, followed by that in ρ
                        =60%, ρ
                        =70%, ρ
                        =80%, ρ
                        =90%, and finally ρ
                        =100%. The result matches our expectation, because the lower diminishing coefficient can greatly reduce the support values of patterns so most of the patterns cannot be larger than the minimum support threshold and are filtered out in further passes. When the number of patterns is reduced, the run times to process the combination of candidate patterns and to calculate supports are also decreased. Moreover, the observation in the variation of the minimum support threshold has the same reason as above. When the minimum support is gradually increased, the number of candidate patterns is decreased so the run time of the CCTM algorithm can also be reduced. In addition, we find the performance of the CCTM algorithm in U1000-I25-S10-acr10 is superior to that in U1000-I25-S10-acr20, U1000-I25-S10-acr30, and U1000-I25-S10-acr40. This is because when the acr value is lower, the number of conflicts between & and → is decreased; therefore, the run time to deal with the conflict task is also reduced.

Second, the scalabilities of the CCTM algorithm using the six diminishing coefficients are compared. In this part, four tests are designed to vary four parameters, |U|, |I|, |S|, and θ. The first test varies the number of users (sequences), |U|, from 500 to 10,000 and fixes min_sup
                        =10%, |I|=25, |S|=10, acr
                        =10%, and θ
                        =0.9 (as shown in Fig. 7
                        ). The second varies the average number of items per user (sequence), |I|, from 25 to 100 and fixes min_sup
                        =10%, |U|=1000, |S|=10, acr
                        =10%, and θ
                        =0.9 (as shown in Fig. 8
                        ). The third varies the average number of itemsets per user (sequence), |S|, from 10 to 22 and fixes min_sup
                        =10%, |U|=1000, |I|=25, acr
                        =10%, and θ
                        =0.9 (as shown in Fig. 9
                        ). The final one varies the conflict threshold, θ, from 1 to 0.8 and fixes min_sup
                        =10%, |U|=1000, |I|=25, |S|=10, and acr
                        =10% (as shown in Fig. 10
                        ).

The results indicate the run times of the CCTM algorithm in the first two tests grow somewhat exponentially. The CCTM algorithm, however, scales up linearly with respect to the last two tests. To understand why, note increasing values of |U| and |I| both degrade the performance of the CCTM algorithm in mining patterns. The greater the number of users or items we test, the more candidate patterns this algorithm will generate. Therefore, the CCTM algorithm has to spend more time dealing with those candidate patterns, leading it to scale up somewhat exponentially.

In this section, we observe how the closed consensus temporal patterns work in practice. Therefore, we are determined to recommend the reading temporal preference for business and management books as this empirical research topic. All of the experimental procedures are described as follows.
                           
                              1.
                              First of all, we used a Web-based survey method to collect the data. We collected these data from May 1st, 2011 to May 31st, 2011. Eight books were recommended by respondents. To save space, we use codes to represent titles in Table 4
                                 . Further, the related information was attached with the Web-based questionnaire to confirm the respondents understood our research purpose and how to execute the recommendation process.

Second, 208 respondents answered the questionnaire, and 8 of those had to be dropped because they provided invalid data which could not be analyzed. In the end, there were 200 useful samples selected in this research.

Finally, we performed the CCTM algorithm in the collected dataset and found the sets of consensus temporal patterns, closed consensus temporal patterns, and conflict patterns. The CCTM algorithm was executed in the following settings to test the real dataset: (1) the minimum support threshold was specified as 8%, 10%, and 12%, (2) ρ was 100%, 75%, and 50%, and (3) θ was 0.5, 0.55, and 0.6.


                        Table 5
                         shows the demographic distributions. 38% of the subjects are male and 62% are female. More than half are female. The age range is mostly between 21 and 30 and under 20 years old. The largest age range group falls between 21 and 30 years old (59.5%). College, master’s, and Ph.D. degrees are the major educational backgrounds of the subjects. Respondents with college degrees make up the majority (68%). Student is the most common occupation (79%). There is larger proportion of seniority in Internet usage of over 10 years (53%).

Most of the subjects are basically familiar with the eight recommended books (31% of the samples are average and 18% are familiar), and they are confident of their recommendations in this survey (55% of the samples are average and 20% are confident). Consequently, we believe the patterns discovered by the CCTM algorithm are valuable and reliable. Moreover, 43% of the subjects have had experience with recommendation systems and 57% have not. Although the subjects who have used recommendation systems are less than those who have not, the experienced subjects are mostly satisfied with the recommendations (71.5% of the samples are average and 20% are satisfied).

Next, we study the number of patterns with respect to consensus temporal patterns (CTP), closed consensus temporal patterns (CCTP), and conflict patterns (Conflict). The results in Figs. 11–13
                        
                        
                         show the number of patterns (CTP, CCTP, and Conflict) is reduced when the minimum support threshold is varied from 8% to 12%. The reason is when the minimum support threshold is increased, there are many candidate patterns which cannot be over the threshold and, as a result, the number of patterns (CTP, CCTP, and Conflict) is reduced. Moreover, when the conflict threshold θ is increased, the number of conflict patterns is reduced contrarily. This is because as θ is increased it is difficult for conflict cases to occur, and the number of conflict patterns is correspondingly decreased.

We also compare the number of CTP, CCTP, and Conflict in the three tests, as shown in Figs. 11–13. The results all indicate the number of CCTP is significantly less than that of CTP. Accordingly, we show CTP cannot only provide more concise information for users, but also reduce information overload. In addition, the result in the number of Conflict shows the conflict case is presented in the recommendation of temporal preferences in our real dataset.

Ultimately, we observe as the diminishing coefficient ρ varying from 100% to 50%, the number of patterns (CTP, CCTP, and Conflict) is reduced. The reason is obvious: the lower diminishing coefficient can decrease the support values of candidate patterns, so the candidate patterns cannot easily surpass the minimum support threshold and the number of frequent patterns is decreased accordingly.

As follows, we discuss some patterns in the empirical study of the real dataset. We list the set of patterns in L
                        5, where the minimum support threshold is 8%, ρ
                        =100%, and θ
                        =0.5. The types of these patterns are CCTP as well as Conflict.

As shown in Table 6
                        , there are some interesting implications which can be discussed as follows.
                           
                              1.
                              The first three items of the three patterns, A→B→C∼D∼G, A→B→C∼D→H, and A→B→C∼D&H indicate Principles of Accounting should be read first, Intermediate Accounting second, and Advanced Accounting third. Their subsequent items can be D and then G or D and then H. This recommendation makes sense to us. However, the temporal relationship of the third and fourth is conflict; that is, the reading sequence of Advanced Accounting and Cost Accounting recommended by our subjects holds two time relations.

In regard to the five patterns, E∼A→B→C∼D, E∼A→B→C→H, F∼A→B→C∼D, F∼A→B→C→H, and G→A→B→C∼D, we know if we want to read books A, B, C, and H or D, books E, F, or G should be read primarily but the relationship between E or F and A can involve two time relations.

To compare the above-mentioned patterns with the four patterns, E→B→C∼D→H, F→B→C∼D→H, F∼E→B→C∼D, and F∼E→B→C→H, we find B can be read instead of A directly if E, F, or F and E has been read.

Other findings: (1) Based on the eight patterns, F∼E→B→C∼D, F∼E→B→C→H, E∼F∼A→B→C, E∼F∼A→B→D, E∼F∼A→B→H, F∼E∼A→B→C, F∼E∼A→B→D, and F∼E∼A→B→H, we realize the first two items, E and F, also exist in the conflict case. (2) Referring to the pattern A→B→C∼D&H, we find D and H can be read simultaneously. The result is reasonable because they are all about cost management and can be studied at the same time.

@&#CONCLUSIONS@&#

Most existing approaches focus on giving recommendations of ranking items based on group decisions. Unfortunately, no studies have ever addressed the topic of recommendation systems in temporal preferences between items with a closed idea. This work presents a novel mining approach to find closed consensus temporal patterns to broaden the spectrum for the application of recommendation systems.

The CCTM algorithm is presented for discovering closed consensus temporal patterns. In addition, we tackle a conflict case in which the proportion of two time relations between items reaches a specified conflict threshold. An analysis of its performance by the three arguments, the diminishing coefficient, the minimum support threshold, and the average conflict ratio, is shown using synthetics datasets. In a scalability test, the run times of the CCTM algorithm grow somewhat exponentially with the number of users (sequences) and the average number of items per user (sequence). The algorithm, however, scales up linearly with increases in the average number of itemsets per user (sequence) and decreases in the conflict threshold. As a result, the performance of the CCTM algorithm is still serviceable and can be applied to discover patterns. A test involving a real dataset collected in this study showed the novel model can find interesting patterns, provide more concise information for users, and reduce the information overload problem. The result in the number of conflict patterns shows the conflict case is presented in the recommendation of temporal preferences. This reflects the paradox of voting in social choice.

Closed consensus temporal pattern mining represents a new and promising research area in recommendation systems and data mining. The model can be extended by considering more temporal relationships, such as meet, during, and overlap, fuzzy temporal patterns, and other kinds of time-related knowledge. Finally, more real-life collected datasets in other types of recommended items can be used to test the proposed model’s effectiveness.

@&#ACKNOWLEDGEMENTS@&#

The author would like to thank the Editor in Chief, Dr. Jie Lu, Associate Editor, and two anonymous referees for their helps and valuable comments to improve this paper. He also appreciates Krannert School of Management, Purdue University, providing the research resources to support the revision of this paper during his visiting period. The assistance in the real-dataset collection and the discovery of its patterns by Mr. Cheng-Qi Chang is thankful as well. This research was supported by the National Science Council of the Republic of China under the Grant NSC 101-2918-I-194-008.

To demonstrate the convergency of the CCTM algorithm, we only make certain the infrequent sequences in Ck
                      cannot be passed to Lk
                     
                     −1 but frequent ones can be. Accordingly, the most preferences will be narrowed down to a smaller set with the filtering mechanism, the minimum support threshold. This set is also joining the different opinions during the two phases of the CCTM algorithm. We describe the concept in Fig. 14
                      and have the following theorem.
                        Theorem 1
                        Anti-monotonic property


                        
                           If a sequence is frequent, so are all of its subsequences. In other words, if a sequence is not frequent, neither is its super sequence.

To demonstrate the theorem, we only have to show support(sα
                           )⩽
                           support(sβ
                           ) if sα
                           
                           ⊇
                           sβ
                           . Given a temporal sequential database S. Let sα
                            and sβ
                            be two sequences so that sα
                           
                           ⊇
                           sβ
                           . For each data sequence s containing sequence sα
                           , s also contains sβ
                           , which is a subset of sα
                           . Therefore, we have support(sα
                           )⩽
                           support(sβ
                           ).□

@&#REFERENCES@&#

