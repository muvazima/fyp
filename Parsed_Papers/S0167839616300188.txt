@&#MAIN-TITLE@&#Revisiting the problem of zeros of univariate scalar Béziers

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A fast algorithm for computing roots of univariate scalar Béziers is proposed.


                        
                        
                           
                           A speed-up of about an order-of-magnitude is gained compared to previous methods.


                        
                        
                           
                           The proposed algorithm has the ability to count multiplicities of roots.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Polynomial roots

Bézier polynomials

Subdivision

Numerical method

Newton–Raphson, polynomial division

@&#ABSTRACT@&#


               
               
                  This paper proposes a fast algorithm for computing the real roots of univariate polynomials given in the Bernstein basis. Traditionally, the polynomial is subdivided until a root can be isolated. In contrast, herein we aim to find a root only to subdivide the polynomial at the root. This subdivision based algorithm exploits the property that the Bézier curves interpolate the end-points of their control polygons. Upon subdivision at the root, both resulting curves contain the root at one of their end-points, and hence contain a vanishing coefficient that is factored out. The algorithm then recurses on the new sub-curves, now of lower degree, yielding a computational efficiency. In addition, the proposed algorithm has the ability to efficiently count the multiplicities of the roots. Comparison of running times against the state-of-the-art on thousands of polynomials shows an improvement of about an order-of-magnitude.
               
            

The problem of numerically finding zeros of univariate polynomials is ubiquitous in computer aided design (Cohen et al., 2001) and engineering. Many geometric problems can be cast into that of finding zeros of polynomials, for instance, computing intersections of curves and surfaces (Sederberg and Meyers, 1988; Sederberg and Parry, 1986), contact analysis of shapes (Kim et al., 2014), kinematic analysis (Bartoň et al., 2009), etc. There have been many approaches to the problem of computing zeros of univariate polynomials in the past (Isaacson and Keller, 1966; McNamee, 1990), such as, based on Newton's method (Grandine, 1989), using Descartes' rule of signs (Eigenwillig et al., 2006; Krandick and Mehlhorn, 2006; Rouillier and Zimmermann, 2004), based on subdivision (Gopalsamy et al., 1991; Mourrain and Pavone, 2009), to name a few.

In this work, we use the Bernstein representation for polynomials. Bernstein polynomials have several useful properties such as the variation diminishing property, the convex hull property and numerical stability with respect to perturbation of coefficients (Farouki and Rajan, 1987), which makes such a representation especially amenable for numerical applications.

One of the earliest methods to exploit the variation diminishing property of Bézier curves in order to isolate the roots of polynomials was given by Lane and Riesenfeld (1981). In 1990, Sederberg and Nishita (1990) proposed the technique of Bézier clipping for identifying regions of the domain which contain roots. This was done by intersecting the convex hull of the control polygon with the zero axis. In 2007, Bartoň and Jüttler (2007) improved the technique of Bézier clipping using degree reduction to generate a strip bounded by two quadratic polynomials, which encloses the graph of the input polynomial. This strip, when intersected with the zero axis, gives the new interval potentially containing the roots. This approach, that is also known as quadratic clipping, was shown to have quadratic convergence by Schulz (2009). In 2009, Liu et al. (2009) improved quadratic clipping by using cubic polynomials, yielding faster rates of convergence. In 2007, Mørken and Reimers (2007) utilized the close relationship between the spline and its control polygon for computing zeros of polynomials. They use the zeros of the control polygon as an initial guess for tracing the zeros of the polynomial. The control polygon is iteratively refined until the roots are found. In 2013, Ko and Kim (2013) used bounding polygons to reduce the intervals containing roots of Bézier polynomials. A hybrid of the convex hull, sharp bounds (Nairn et al., 2006) and quasi-interpolating bounds (Zhang and Wang, 2006) was used to refine the intervals. Recently, in 2015, Chen et al. (2015) improved the convergence rates achieved by Liu et al. (2009) by bounding the polynomial of interest by a pair of rational cubic polynomials.

Our approach, as explained in Section 1.1 uses the fact that polynomials represented in the Bernstein–Bézier form admit efficient algorithms for polynomial multiplication and division (Buse and Goldman, 2007; Goldman, 2002). These are employed to factor out the roots already computed, thus reducing the degree of the polynomial, as part of the solution process.

We now give an overview of our method, which exploits several properties of the Bézier curves, for computing zeros of scalar polynomials. The Bernstein basis for an n-degree univariate polynomial is given by the set of functions 
                           
                              
                                 θ
                              
                              
                                 i
                                 ,
                                 n
                              
                           
                           (
                           t
                           )
                           =
                           
                              (
                              
                                 
                                    
                                       n
                                    
                                 
                                 
                                    
                                       i
                                    
                                 
                              
                              )
                           
                           
                              
                                 t
                              
                              
                                 i
                              
                           
                           
                              
                                 (
                                 1
                                 −
                                 t
                                 )
                              
                              
                                 n
                                 −
                                 i
                              
                           
                        , 
                           t
                           ∈
                           [
                           0
                           ,
                           1
                           ]
                        , for 
                           i
                           =
                           0
                           ,
                           …
                           ,
                           n
                        . A degree n scalar polynomial in the Bernstein basis is expressed as 
                           c
                           (
                           t
                           )
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 0
                              
                              
                                 n
                              
                           
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                           
                              
                                 θ
                              
                              
                                 i
                                 ,
                                 n
                              
                           
                           (
                           t
                           )
                         where, 
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                           ∈
                           R
                         are the real coefficients of the polynomial. While 
                           c
                           (
                           t
                           )
                         may have roots outside the domain 
                           [
                           0
                           ,
                           1
                           ]
                        , in this paper we focus on finding the real roots of 
                           c
                           (
                           t
                           )
                         in 
                           [
                           0
                           ,
                           1
                           ]
                        . Throughout this paper, we will consider 
                           [
                           0
                           ,
                           1
                           ]
                         to be the domain of definition of all Bézier curves, unless stated otherwise.

We will exploit the fact that the Bézier curves interpolate the end-points of their control polygon. Upon finding a root, 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                        , our algorithm subdivides 
                           c
                           (
                           t
                           )
                         at 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                        . Let 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         and 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                         denote the resulting polynomials corresponding to the sub-intervals 
                           [
                           0
                           ,
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           ]
                         and 
                           [
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           ,
                           1
                           ]
                        , respectively, with their domains again mapped to 
                           [
                           0
                           ,
                           1
                           ]
                        . Clearly, 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         and 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                         vanish at 1 and 0, respectively. Since the Bézier curves interpolate the end-points of their control polygon, it follows that the last coefficient of 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         and the first coefficient of 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                         are zero. 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         may be expressed as 
                           (
                           1
                           −
                           t
                           )
                           
                              
                                 c
                              
                              
                                 L
                              
                           
                           (
                           t
                           )
                         for some Bernstein polynomial 
                           
                              
                                 c
                              
                              
                                 L
                              
                           
                           (
                           t
                           )
                         having one degree less than 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                        . Similarly, 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                         may be written as 
                           t
                           
                              
                                 c
                              
                              
                                 R
                              
                           
                           (
                           t
                           )
                         for some Bernstein polynomial 
                           
                              
                                 c
                              
                              
                                 R
                              
                           
                           (
                           t
                           )
                         with one degree less than 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                        . Factoring out the terms 
                           (
                           1
                           −
                           t
                           )
                         and t from 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         and 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                        , respectively (Buse and Goldman, 2007), eliminates the root 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                         from these two polynomials, yielding polynomials with smaller degrees to recurse upon that preserves all roots but 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                        , thus giving a computational boost to the algorithm. This is explained schematically in Fig. 1
                        . The graph of polynomial 
                           c
                           (
                           t
                           )
                         is shown in red, in Fig. 1(a), along with its control polygon that is shown in green. 
                           c
                           (
                           t
                           )
                         has two real roots, at 
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                        . Assume we found the root at 
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                        . Fig. 1(b) shows the subdivided polynomials 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         and 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                         respectively, both containing the root, 
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                        , at the respective end-point of their domains, and hence have a vanishing coefficient there. Fig. 1(c) shows the lower degree polynomials obtained after factoring out 
                           (
                           1
                           −
                           t
                           )
                         and t from 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           t
                           )
                         and 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                        , respectively.

The rest of this paper is organized as follows. Our basic algorithm is explained in Section 2. An interesting efficient feature of our approach to count the multiplicities of roots, along with two more extensions of the algorithm are given in Section 3. One extension lets the search for roots go outside the domain of interest, and another initializes the Newton–Raphson method with better calculated seeds compared to the basic algorithm. We compare the running times of our implementation of the algorithm with those of the state-of-the-art alternatives, on thousands of polynomials. The results of the comparison, as given in Section 4, show an improvement of about an order-of-magnitude. Finally, we conclude the paper, in Section 5, with remarks on future work.

In this section, we explain our algorithm for finding the real roots of univariate scalar polynomials, given in Bernstein form. The proposed algorithm is based on subdivisions at detected roots.

As explained in Section 1.1, the proposed algorithm achieves a reduction in the complexity of the problem by factoring out all the roots that are already found. A scalar Bernstein polynomial 
                        c
                        (
                        t
                        )
                      of degree n with 
                        c
                        (
                        0
                        )
                        =
                        0
                      may be expressed as 
                        c
                        (
                        t
                        )
                        =
                        t
                        r
                        (
                        t
                        )
                     , for some Bernstein polynomial 
                        r
                        (
                        t
                        )
                      with degree 
                        n
                        −
                        1
                      (Buse and Goldman, 2007). The coefficients of 
                        r
                        (
                        t
                        )
                      are obtained from those of 
                        c
                        (
                        t
                        )
                      as 
                        
                           
                              q
                           
                           
                              i
                           
                        
                        =
                        
                           
                              p
                           
                           
                              i
                              +
                              1
                           
                        
                        
                           n
                           
                              i
                              +
                              1
                           
                        
                     , for 
                        i
                        =
                        0
                        ,
                        …
                        ,
                        n
                        −
                        1
                     . The proof appears in Lemma 1, for completeness:


                     
                        Lemma 1
                        
                           A degree n scalar Bernstein polynomial 
                           
                              c
                              (
                              t
                              )
                              =
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    n
                                 
                              
                            
                           such that 
                           
                              c
                              (
                              0
                              )
                              =
                              0
                            
                           can be written as 
                           
                              c
                              (
                              t
                              )
                              =
                              t
                              
                                 
                                    ∑
                                 
                                 
                                    i
                                    =
                                    0
                                 
                                 
                                    n
                                    −
                                    1
                                 
                              
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              
                                 
                                    θ
                                 
                                 
                                    i
                                    ,
                                    n
                                    −
                                    1
                                 
                              
                            
                           
                              =
                              t
                              r
                              (
                              t
                              )
                           
                           , where, 
                           
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    p
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 n
                                 
                                    i
                                    +
                                    1
                                 
                              
                            
                           for 
                           
                              i
                              =
                              0
                              ,
                              …
                              ,
                              n
                              −
                              1
                           
                           .
                        


                     
                        Proof
                        Since 
                              c
                              (
                              0
                              )
                              =
                              0
                           , the first coefficient, 
                              
                                 
                                    p
                                 
                                 
                                    0
                                 
                              
                           , is zero, and we have,
                              
                                 
                                    
                                       
                                          
                                             c
                                             (
                                             t
                                             )
                                          
                                          
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   0
                                                
                                                n
                                             
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                   
                                                   
                                                      
                                                         i
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   1
                                                   −
                                                   t
                                                   )
                                                
                                                
                                                   n
                                                   −
                                                   i
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                   
                                                   
                                                      
                                                         i
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   1
                                                   −
                                                   t
                                                   )
                                                
                                                
                                                   n
                                                   −
                                                   i
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             =
                                             t
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                   
                                                   
                                                      
                                                         i
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                   −
                                                   1
                                                
                                             
                                             
                                                
                                                   (
                                                   1
                                                   −
                                                   t
                                                   )
                                                
                                                
                                                   n
                                                   −
                                                   i
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             =
                                             t
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   0
                                                
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      
                                                         n
                                                      
                                                   
                                                   
                                                      
                                                         i
                                                         +
                                                         1
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   1
                                                   −
                                                   t
                                                   )
                                                
                                                
                                                   n
                                                   −
                                                   i
                                                   −
                                                   1
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             =
                                             t
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   0
                                                
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             
                                                n
                                                
                                                   i
                                                   +
                                                   1
                                                
                                             
                                             
                                                (
                                                
                                                   
                                                      
                                                         n
                                                         −
                                                         1
                                                      
                                                   
                                                   
                                                      
                                                         i
                                                      
                                                   
                                                
                                                )
                                             
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   (
                                                   1
                                                   −
                                                   t
                                                   )
                                                
                                                
                                                   n
                                                   −
                                                   i
                                                   −
                                                   1
                                                
                                             
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             =
                                             t
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   0
                                                
                                                
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             
                                                
                                                   q
                                                
                                                
                                                   i
                                                
                                             
                                             
                                                
                                                   θ
                                                
                                                
                                                   i
                                                   ,
                                                   n
                                                   −
                                                   1
                                                
                                             
                                             (
                                             t
                                             )
                                             ,
                                          
                                       
                                       
                                          
                                          
                                             =
                                             t
                                             r
                                             (
                                             t
                                             )
                                             ,
                                          
                                       
                                    
                                 
                              
                            where 
                              
                                 
                                    q
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    p
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              
                                 n
                                 
                                    i
                                    +
                                    1
                                 
                              
                           , for 
                              i
                              =
                              0
                              ,
                              …
                              ,
                              n
                              −
                              1
                           , are the coefficients of the scalar Bernstein polynomial 
                              r
                              (
                              t
                              )
                            having degree 
                              n
                              −
                              1
                           . □

Clearly, the term t can be factored out from 
                        c
                        (
                        t
                        )
                      in linear time with respect to the number of coefficients in 
                        c
                        (
                        t
                        )
                     . In a similar way, a degree n scalar Bernstein polynomial 
                        c
                        (
                        t
                        )
                      with 
                        c
                        (
                        1
                        )
                        =
                        0
                      may be expressed as 
                        (
                        1
                        −
                        t
                        )
                        s
                        (
                        t
                        )
                     , for some scalar Bernstein polynomial 
                        s
                        (
                        t
                        )
                      with degree 
                        n
                        −
                        1
                     , whose coefficients are obtained from those of 
                        c
                        (
                        t
                        )
                      as 
                        
                           
                              p
                           
                           
                              i
                           
                        
                        
                           n
                           
                              n
                              −
                              i
                           
                        
                      for 
                        i
                        =
                        0
                        ,
                        …
                        ,
                        n
                        −
                        1
                     . The proof is similar to that given in Lemma 1. More importantly, the following holds:


                     
                        Remark 2
                        Let the set of real roots of 
                              c
                              (
                              t
                              )
                            be 
                              
                                 
                                    R
                                 
                                 
                                    c
                                 
                              
                            and 
                              c
                              (
                              0
                              )
                              =
                              0
                           . Then,
                              
                                 
                                    
                                       
                                          
                                             R
                                          
                                          
                                             c
                                          
                                       
                                       =
                                       
                                          
                                             R
                                          
                                          
                                             r
                                          
                                       
                                       ∪
                                       {
                                       0
                                       }
                                       ,
                                    
                                 
                              
                            where, 
                              c
                              (
                              t
                              )
                              =
                              t
                              r
                              (
                              t
                              )
                            and 
                              
                                 
                                    R
                                 
                                 
                                    r
                                 
                              
                            is the set of real roots of 
                              r
                              (
                              t
                              )
                           .

In other words, the set of real roots of 
                        r
                        (
                        t
                        )
                      identifies with the roots of 
                        c
                        (
                        t
                        )
                      up to the root at zero and hence, we can continue working with 
                        r
                        (
                        t
                        )
                      instead of 
                        c
                        (
                        t
                        )
                     , without missing any root, but in a reduced complexity. A similar remark holds for a polynomial 
                        c
                        (
                        t
                        )
                      with 
                        c
                        (
                        1
                        )
                        =
                        0
                     .

As a first step, our algorithm employs a sufficient condition for discarding sub-domains which do not contain roots, by inspecting the signs of the coefficients of 
                        c
                        (
                        t
                        )
                     . If they are either all positive or all negative, the sub-domain does not contain roots and is purged. This follows from the convex-hull property of the Bézier curves.

If the domain is not discarded, an attempt is made to find a root in the current domain, numerically. We employ the Newton–Raphson method, which is known to have a quadratic rate of convergence (Isaacson and Keller, 1966), for this purpose and use an initial guess of 0.5 as an initial seed value. Upon successful finding of a root, 
                        
                           
                              t
                           
                           
                              0
                           
                        
                     , the polynomial 
                        c
                        (
                        t
                        )
                      is subdivided at 
                        
                           
                              t
                           
                           
                              0
                           
                        
                     . As explained previously, both curves resulting from the subdivision of 
                        c
                        (
                        t
                        )
                      contain the root, 
                        
                           
                              t
                           
                           
                              0
                           
                        
                     , at the respective end-points of their domains. The root at 
                        
                           
                              t
                           
                           
                              0
                           
                        
                      is factored out from these two new curves and the resulting lower degree polynomials are recursed upon. Alternatively, if no root is found by the numeric step, 
                        c
                        (
                        t
                        )
                      is subdivided in the middle of the domain and the resulting polynomials are recursed upon. The stopping criteria for the Newton–Raphson method is either a divergent step, or the search going outside the domain, or the number of iterations exceeding a limit, 100 in our case (a case that never occurred in all our tests).

Our method is summarized in Algorithm 1
                     . The test for absence of roots (all coefficients positive or all negative) is performed by the routine PurgeProblem in Line 1 of Algorithm 1. The Newton–Raphson method is invoked in Line 4 by the routine NumericStep, with the mid-point (0.5) of the domain as the starting seed. The case when a root is found by NumericStep is handled in Lines 6 to 9 while the case when no root is found is executed in Lines 14 to 16. Note that we assume the curves are always within domain 
                        [
                        0
                        ,
                        1
                        ]
                     . Yet, we keep track of the real domain by propagating the 
                        [
                        
                           
                              t
                           
                           
                              min
                           
                        
                        ,
                        
                           
                              t
                           
                           
                              max
                           
                        
                        ]
                      values.


                     Algorithm 1 uses two tolerances, the numeric tolerance, ϵ, and the subdivision tolerance, δ. The roots are searched up to ϵ, i.e., for each root, 
                        
                           
                              t
                           
                           
                              0
                           
                        
                     , returned, 
                        −
                        ϵ
                        <
                        c
                        (
                        
                           
                              t
                           
                           
                              0
                           
                        
                        )
                        <
                        ϵ
                     , while the minimal width of the domain of any subdivided curve, to be considered by our algorithm, is set by δ. The termination of Algorithm 1 stems from looking at its two sub-cases. If a root is found by the numeric step, the algorithm recurses upon two sub-polynomials of one degree less. If no root is found by the numeric step, the algorithm recurses on two polynomials, each with domain width half that of the original polynomial. Hence, the algorithm terminates when either one of the following conditions holds: (i) the width of the problem domain 
                        [
                        
                           
                              t
                           
                           
                              min
                           
                        
                        ,
                        
                           
                              t
                           
                           
                              max
                           
                        
                        ]
                      falls below the subdivision tolerance, or (ii) the control polygon of 
                        c
                        (
                        t
                        )
                      does not cross the t-axis, or (iii) the degree of 
                        c
                        (
                        t
                        )
                      is one.

We now consider several extensions of the basic algorithm from Section 2. In Section 3.1, we present an extension for counting the multiplicities of roots. In Section 3.2, we consider an alternative method of initializing the Newton–Raphson method and in Section 3.3, we portray an extended framework which lets the search for roots go outside the domain of interest.

The extended ability to count the multiplicities of roots is naturally supported by our computational framework. Each time a root is factored out, the terminal coefficient of the resulting polynomial is inspected again. A vanishing coefficient, again after an elimination of t or 
                           (
                           1
                           −
                           t
                           )
                        , implies that the root is repeated. Hence, counting multiplicities is reduced to the examination of a single (terminal) scalar coefficient of 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                           (
                           t
                           )
                         to be zero, and hence, is highly efficient. This is demonstrated schematically in Fig. 2
                         for a double root. The pseudo-code for counting multiplicities of roots is given in Algorithm 2
                         which replaces Lines 7 and 8 in Algorithm 1. Herein, 
                           
                              
                                 m
                              
                              
                                 0
                              
                           
                         is the desired root multiplicity. For clarity, both input and output curves are designated as 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                         and 
                           
                              
                                 c
                              
                              
                                 r
                              
                           
                         in Algorithm 2 (against 
                           
                              
                                 c
                              
                              
                                 L
                              
                           
                         and 
                           
                              
                                 c
                              
                              
                                 R
                              
                           
                         in Algorithm 1) due to the recursive computation. This extended ability is examined in Section 4. Note that, the Newton–Raphson method converges linearly to a root with multiplicity greater than one (Isaacson and Keller, 1966).

It is known that the control polygon of a Bézier curve is an approximation of the curve itself. One can compute the intersection of the control polygon of 
                           c
                           (
                           t
                           )
                         with the t-axis, in order to supply a better initial value for the Newton–Raphson method, following Mørken and Reimers (2007). Due to the variation diminishing property, the number of intersections of the control polygon with the t-axis is greater than or equal to the number of real roots of 
                           c
                           (
                           t
                           )
                        . In this extension option, we examined both the first intersection point as well as the intersection point closest to the mid-point of the domain, between the control polygon and the t-axis. The potential computational benefits of both alternative initializations of the Newton–Raphson method are examined in Section 4.

Consider letting the Newton–Raphson search for roots go outside the domain, 
                           [
                           0
                           ,
                           1
                           ]
                        , of interest. If such a root is found, it can still be factored out, thus, reducing the degree of the problem. If a root, 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           >
                           1
                        , is found, the input polynomial 
                           c
                           (
                           t
                           )
                         is subdivided at 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                         to obtain a polynomial, 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                        , corresponding to the domain 
                           [
                           0
                           ,
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           ]
                         and a polynomial, 
                           
                              
                                 c
                              
                              
                                 d
                              
                           
                         corresponding to the domain 
                           [
                           1
                           ,
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           ]
                        . The polynomial 
                           
                              
                                 c
                              
                              
                                 d
                              
                           
                         is immediately discarded, being outside the domain 
                           [
                           0
                           ,
                           1
                           ]
                        . Clearly, 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           (
                           1
                           )
                           =
                           c
                           (
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           )
                           =
                           0
                        , and as before, the factor 
                           (
                           1
                           −
                           t
                           )
                         is removed from 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                        . However, herein 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                         is again subdivided at 
                           
                              1
                              
                                 
                                    t
                                 
                                 
                                    0
                                 
                              
                           
                         to bring 
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                         back to the original 
                           [
                           0
                           ,
                           1
                           ]
                         domain. A similar sequence of steps are followed when the root is found below zero, 
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           <
                           0
                        . The potential benefits of this possible extension are also discussed in Section 4.

@&#RESULTS@&#

The algorithm described in the previous sections was implemented in the IRIT (Elber, 2015) solid modeling environment. This section first compares the running times of the presented approach, on thousands of polynomials, with the running times of three other algorithms, also implemented in IRIT, all on a PC with a 3.4 GHz CPU (single thread) and 4 GB (32-bit executable) memory. Further, the presented algorithm is compared with Quadratic clipping (Bartoň and Jüttler, 2007) and Cubic clipping (Liu et al., 2009) on the polynomials used in Bartoň and Jüttler (2007), Liu et al. (2009). We also compared the running times of the presented algorithm with those of the roots finding algorithm of Matlab (MathWorks, 2015). Finally, we compared our algorithm with that proposed in Ko and Kim (2013).

A numeric tolerance of 
                        
                           
                              10
                           
                           
                              −
                              10
                           
                        
                      (ϵ in Algorithm 1) and a subdivision tolerance of 
                        
                           
                              10
                           
                           
                              −
                              3
                           
                        
                      (δ in Algorithm 1) were used for all the runs, wherever applicable, unless stated otherwise. The subdivision tolerance is used to terminate the algorithm when the width of the sub-domain becomes small, i.e., when 
                        
                           
                              t
                           
                           
                              max
                           
                        
                        −
                        
                           
                              t
                           
                           
                              min
                           
                        
                        <
                        δ
                     . In essence, the separation of adjacent nearby roots is limited by this subdivision tolerance. Hence, roots which are apart by less than δ are deemed identical. The roots returned from all the different methods were compared against each other to ensure the completeness and correctness of the solutions. Running times for the basic approach presented in Section 2 appear under the column BZF (Bézier-Zero-Factored) in Tables 1–5
                     
                     
                     
                     
                     . The running times for the extension given in Section 3.2 for alternative initialization of the Newton–Raphson method, using the first intersection and the one close to the middle of the domain, found between the control polygon of 
                        c
                        (
                        t
                        )
                      and the t-axis, appear under the columns BZF-NRI1 and BZF-NRI2 respectively, in Tables 1–4.

The first method that we compare our approach with, computes the roots of 
                        c
                        (
                        t
                        )
                      by computing the points of intersection between two curves in 
                        
                           
                              R
                           
                           
                              2
                           
                        
                      (Sederberg and Parry, 1986), viz., the graph of 
                        c
                        (
                        t
                        )
                      and the t-axis. This method inspects the intersection of the double wedge of 
                        c
                        (
                        t
                        )
                      with the t-axis to discard sub-intervals not containing roots (Sederberg and Meyers, 1988). The running times for this method appear under the column CCI (Curve–Curve-Intersection) in Tables 1–4.

The second method that we use for comparison, is a subdivision-based approach which uses cones bounding the tangent field of polynomial 
                        c
                        (
                        t
                        )
                      in order to identify the intervals of domain which are guaranteed to contain at most one root (Sederberg and Meyers, 1988). Once such an interval is identified, a root is searched using the Newton–Raphson method. Further, this method inspects if the coefficients of 
                        c
                        (
                        t
                        )
                      are either all positive, or all negative, in order to check for absence of roots, in which case, the sub-domain is discarded. This method, in our implementation, is geared towards solutions of multi-variate polynomials and hence has some computational overhead. The running times for this method of numerically computing zeros appear under the column NCZ in Tables 1–4.

Finally, we compare our method against an analytic algorithm for finding the roots (Nickalls, 2009). This can be used only on polynomials with degree less than 6, though our implementation only supported polynomials with degree less than 5 and uses Euler's approach which first eliminates the coefficient of the cubic term in the input polynomial. The running times for the same appear under the column Analytic in Tables 1–4.

In order to ensure the correctness of the time measurements, for each measurement, an aggregate time for 104 runs on each polynomial was noted and divided by 104. We used four sets of polynomials for comparison, as described below:
                        
                           1.
                           Scalar univariate Bernstein polynomials with degrees between 3 and 100 were created by randomly sampling the coefficients of the polynomials. In this case, the number of real roots was typically quite small compared to the degree of the polynomial. For each degree, 100 different polynomials were created, some of which are shown in Fig. 3
                              . The running times and the number of roots reported in Table 1 are the average of these.

Scalar univariate Bernstein polynomials with degrees ranging from 3 to 14, with the number of real roots equal to the degree, were created. This was done by generating monomials with randomly generated roots and multiplying these together. The resulting polynomial in the power basis was converted into the Bernstein basis. A few of these polynomials are shown in Fig. 4
                              . The comparison of running times for these polynomials for all the six methods appears in Table 2.

Polynomials having roots with multiplicity of two, with degrees between 8 and 21, were created in a manner similar to that for degree n polynomials with n roots described above, albeit, by repeating one of the monomials. The running times for the same are tabulated in Table 3. In this case, our algorithm with the extension given in Section 3.1 correctly counted the multiplicities. A few of these polynomials are plotted in Fig. 5
                              .

A Wilkinson's polynomial with degree n is defined as 
                                 c
                                 (
                                 t
                                 )
                                 =
                                 
                                    
                                       ∏
                                    
                                    
                                       i
                                       =
                                       0
                                    
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 (
                                 t
                                 −
                                 
                                    i
                                    
                                       n
                                       −
                                       1
                                    
                                 
                                 )
                              . Wilkinson's polynomials are known for their numerical instability, in particular, the sensitivity of the roots to perturbation of coefficients (Wilkinson, 1959). The comparison of running times on Wilkinson's polynomials with degrees 13 and 20 are given in Table 4. The polynomials are shown in Fig. 6
                              . For polynomials of degree 13 and 20, the mean deviation of the roots returned by our method from the actual roots is 
                                 1.8
                                 ×
                                 
                                    
                                       10
                                    
                                    
                                       −
                                       15
                                    
                                 
                               and 
                                 1.5
                                 ×
                                 
                                    
                                       10
                                    
                                    
                                       −
                                       9
                                    
                                 
                              , and the maximum deviation is 
                                 5.5
                                 ×
                                 
                                    
                                       10
                                    
                                    
                                       −
                                       15
                                    
                                 
                               and 
                                 7.3
                                 ×
                                 
                                    
                                       10
                                    
                                    
                                       −
                                       9
                                    
                                 
                              , respectively, using the double precision for representation of the coefficients.

As can be observed from Tables 1–4, Algorithm BZF is faster than the other methods by almost an order-of-magnitude. Further, BZF-NRI1 and BZF-NRI2 show computational benefit over simple BZF, as seen in Tables 1–5, with some exceptions as can be seen in Table 3 for polynomial with 21 control points. While initializing the Newton–Raphson method with a location near the middle of the domain is expected to more likely succeed compared to an initialization at the end of the domain, it requires the computation of all the intersections between the control polygon of 
                        c
                        (
                        t
                        )
                      and the t-axis. Hence, in some cases BZF-NRI1 performs better than BZF-NRI2, for instance, in Table 1, while in some cases it is vice versa, for instance, on the polynomials with high degree in Table 3.

It turns out that the out-of-domain root searching extension discussed in Section 3.3, allowing the domain to expand beyond 
                        [
                        0
                        ,
                        1
                        ]
                     , does not show a significant improvement in running times over the simple BZF. This is probably because even if a polynomial has a root outside 
                        [
                        0
                        ,
                        1
                        ]
                     , in most cases, that portion of polynomial gets discarded by the routine PurgeProblem (Line 1 of Algorithm 1), as the control polygon is for domain 
                        [
                        0
                        ,
                        1
                        ]
                      that contains no roots.

We further noted the running times of algorithms BZF, BZF-NRI1 and BZF-NRI2 on the 12 polynomials used in Bartoň and Jüttler (2007) and Liu et al. (2009), with single, double, triple and near double roots, identifying all roots (and ignoring their multiplicities), as is done in Bartoň and Jüttler (2007), Liu et al. (2009). Each of these four classes has three polynomials in it, labeled as 
                        
                           
                              f
                           
                           
                              4
                           
                        
                        (
                        t
                        )
                        ,
                        
                           
                              f
                           
                           
                              8
                           
                        
                        (
                        t
                        )
                      and 
                        
                           
                              f
                           
                           
                              16
                           
                        
                        (
                        t
                        )
                     , with degrees 4, 8 and 16 respectively. We did not run tests on polynomials with near triple roots used in Liu et al. (2009) for the lack of precision while converting these polynomials from the power basis to the Bernstein basis, when using the double precision representation. The running times for Quadratic clipping and Cubic clipping are noted from Liu et al. (2009) for accuracy of 
                        
                           
                              10
                           
                           
                              −
                              8
                           
                        
                     , in which, a computer with Intel(R) 1.7 GHz processor and 512 MB RAM was reported. The comparison of the running times, given in Table 5, shows that BZF is much faster than both Quadratic clipping as well as Cubic clipping, even after accounting for the difference in the processor speed used in Liu et al. (2009) and that used in our tests. The CPU used in our tests was twice as fast as that used in Liu et al. (2009), while the speed-up achieved by BZF is far more than twice, as can be seen from Table 5. Note that, the running times for BZF for double root polynomials are smaller than those for single root polynomials. This is explained by the fact that the double root polynomials in this case have the root at 0.5, which is also the seed used for initializing the Newton–Raphson method in BZF.

The function roots in Matlab (MathWorks, 2015) computes the complex roots of polynomials given in power basis. This is done by computing the eigen-values of the companion matrix (Hoffman and Kunze, 1971) of the input polynomial. This approach does not require numeric tolerance as an input parameter. However, the gained precision of roots thus computed is less compared to our method. The roots returned by this Matlab function for the four classes of polynomials used for our tests, as described previously, had an average precision of 
                        
                           
                              10
                           
                           
                              −
                              8
                           
                        
                     . Further, since this method works with the power basis, it has issues with numerical stability. For instance, on the Wilkinson's polynomial of degree 20, the achieved precision was 
                        
                           
                              10
                           
                           
                              −
                              4
                           
                        
                     , while our method gains a precision of 
                        
                           
                              10
                           
                           
                              −
                              10
                           
                        
                     . In order to compare our algorithm with the roots function of Matlab, we exported the C code of this function from Matlab and noted the running times of the same. It was observed that on polynomials with sparse real roots, e.g., polynomials obtained by randomly sampling the coefficients of the polynomials, as explained before, our algorithm was over 10 times faster than the Matlab function. On polynomials with dense real roots, e.g., degree-n polynomials with n real roots, our algorithm was about three times faster than the Matlab function.

Finally, we compared our method with that proposed in Ko and Kim (2013) on polynomials used in Ko and Kim (2013) and found our method to be two orders-of-magnitude faster. For instance, the time reported in Ko and Kim (2013) for computing roots of Wilkinson's polynomial of degree 20 is 20 ms for a precision of 
                        
                           
                              10
                           
                           
                              −
                              7
                           
                        
                     , on a PC with 2.2 GHz processor and 2 GB RAM, while BZF takes only 40.72 μs for the same, with a precision of 
                        
                           
                              10
                           
                           
                              −
                              10
                           
                        
                     , as shown in Table 4.

One main factor that contributed to the almost order-of-magnitude improvement in the performance over the state-of-the-art is the success rate in the numeric search step for roots (Line 4 in Algorithm 1). Newton–Raphson is very efficient in converging (quadratically for simple roots, Isaacson and Keller, 1966) to the roots and our experiments (see Table 6
                     ) show that over 
                        50
                        %
                      (and sometimes even over 
                        90
                        %
                     ) of the recursive invocations of BZF terminated with a successful finding of a new root in the domain in hand. This means that, amortized, Algorithm 1 was recursively invoked less than two calls per root! Further, it was observed that Algorithm 1 almost never terminated due to the condition that 
                        
                           
                              t
                           
                           
                              max
                           
                        
                        −
                        
                           
                              t
                           
                           
                              min
                           
                        
                        <
                        δ
                      (Line 11 in Algorithm 1), except once, when a root was present at a distance less than subdivision tolerance from the domain boundary, which is extremely rare. As noted at the beginning of this section, the subdivision tolerance δ governs the minimal distance between two different adjacent roots and might affect the computation time only for almost-singular cases, viz., when roots are very close.

@&#CONCLUSION@&#

This paper presented a fast algorithm for finding zeros of scalar univariate polynomials given in the Bernstein form. A speed-up in running times compared to the previous state-of-the-art alternative approaches of almost an order-of-magnitude is reported. Unlike the traditional approach, wherein, the polynomial is subdivided until a root is isolated, the proposed algorithm derives its computational advantage from factoring out the roots already computed, hence, reducing the complexity of the sub-problems to recurse upon. Further, the Newton–Raphson method, which is known to be highly efficient, is very effectively exploited, wherever possible. Finally, a salient feature of this method is the ability to efficiently compute the multiplicities of the roots, and is discussed in Section 3.1.

Like any numeric algorithm, the robustness of the presented approach must be further examined. Specifically, roots with high orders of multiplicities are prone to numerical instabilities. Our test shows that using double precision, the detection of multiplicities of triple roots up to tolerances of 
                        
                           
                              10
                           
                           
                              −
                              10
                           
                        
                      can be unstable for degrees larger than 4. This can be partially explained by the fact that each factoring operation scales the coefficients by 
                        O
                        (
                        n
                        )
                     , the degree of the polynomial. One possible way to alleviate this difficulty would be to inspect the k terminal coefficients in order to detect a multiplicity of order k, and if found to be zero within some tolerance, factor them out once by dividing by 
                        
                           
                              t
                           
                           
                              k
                           
                        
                      or 
                        
                           
                              (
                              1
                              −
                              t
                              )
                           
                           
                              k
                           
                        
                      (see also Buse and Goldman, 2007), as the case may be. Further, one could consider replacing the all-positive or all-negative coefficients test used in our method for identifying sub-domains with no solution, by other, more sophisticated bounds such as quadratic clipping (Bartoň and Jüttler, 2007). Finally, an extension of the proposed method to finding zeros of multi-variates would be very useful, for instance, in computing curve-curve or curve-surface intersections.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to thank the anonymous reviewers for their invaluable comments. This work was supported in part by the People Programme (Marie Curie Actions) of the European Union's Seventh Framework Programme FP7/2007-2013/ under REA grant agreement PIAP-GA-2011-286426, and was supported in part by the Israel Science Foundation (grant No. 278/13).

@&#REFERENCES@&#

