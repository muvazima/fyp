@&#MAIN-TITLE@&#A hybrid and dynamic reliable transport protocol for wireless sensor networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A hybrid and dynamic reliable transport protocol for wireless sensor networks is proposed.


                        
                        
                           
                           It provides hybrid Acknowledgement/Negative Acknowledgement scheme.


                        
                        
                           
                           It controls the booting sensor nodes problem and the all-packets-lost problem.


                        
                        
                           
                           The performance of proposed protocol is tested under TinyOS Simulator.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless sensor networks

Transport layer protocols

Error tolerance

Success rate

Average latency

Average delivery ratio

@&#ABSTRACT@&#


               
               
                  Wireless sensor networks are formed by a large number of sensor nodes which are commonly known as motes. In the past few years, several reliable, congestion controlled and energy efficient transport layer protocols in wireless sensor networks have been developed and proposed in the literature. In this paper, we have presented a hybrid and dynamic reliable transport protocol which provides the mechanism to dynamically assign the timing parameters to the nodes as well as enhance the protocol performance by using a hybrid Acknowledgement/Negative Acknowledgement scheme. The performance of proposed protocol is tested under TinyOS Simulator varying different parameters and protocol settings and found that proposed protocol is able to program all the nodes when given proper pump/fetch ratios, is able to solve the booting sensor nodes problem by being able to wait till all the nodes finished booting and solves the all-packets-lost problem by acknowledging the receipt of its first packet delivered that is the inform message.
               
            

@&#INTRODUCTION@&#

Wireless sensor networks (WSNs) are formed by a collection of hundreds or thousands of sensor nodes working together and are used to monitor events in a region to obtain data about the environment. Sensor nodes are composed of processor, memory, transceiver, one or more sensors and a battery [1]. In wireless sensor networks, transport protocols are used to decrease congestion and reduce packet loss to provide fairness in bandwidth allocation and to guarantee end-to-end reliability [2]. However, the Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) are popular transport protocols and deployed widely in the Internet, neither may be a good choice for wireless sensor networks due to many constraints in terms of throughput and energy efficiency [3]. One of the major drawback of TCP is that it uses end-to-end retransmission-based error control and the window-based Additive-Increase Multiplicative-Decrease (AIMD) congestion control mechanisms that may not be feasible for the wireless sensor networks domain and hence, may lead to waste of scarce resources [4]. In contrast, UDP is connectionless transport control protocol and is not suitable for wireless sensor networks due to lack of flow and congestion control mechanisms [5].

The main focus in this paper is on the design of reliable transport protocol for wireless sensor networks. Reliable data transport is an important research area in the field of wireless sensor networks. Many wireless sensor network applications require the reliable transport of data. For example, consider a wireless sensor network deployed in a chemical plant to detect harmful gas. It is essential for sensor nodes to reliably transport every sensor reading back to the base station. Due to many unique characteristics and constraints of sensor nodes, providing reliable transport of data in wireless sensor networks can be a challenging task. Another challenging task in designing a reliable transport protocol in wireless sensor networks is frequent node failure. Node failure in the sensor network can be the result of system crashes, harsh environment or energy depletion [6].

The rest of this paper is organized as follows. An outline of related transport layer protocols is presented in Section 2. In Section 3, hybrid and dynamic reliable transport protocol (HDRTP) is presented. The performance analysis of both Pump Slowly Fetch Quickly (PSFQ) and HDRTP protocols has been presented in Section 4. Finally, Section 5 concludes the paper.

@&#RELATED WORK@&#

For wireless sensor networks, several transport layer protocols have been designed to address various issues such as reliability, congestion control or both. A brief summary of the related protocols is provided in this section.

PSFQ [7] is designed to be downstream, scalable and energy efficient transport layer protocol. It distributes data from sink to sensors by pacing data at a relatively slow speed but allowing sensor nodes that experience data loss to recover any missing segments from immediate neighbours. It provides a hop-by-hop error recovery technique in which intermediate nodes also cache fragments and share accountability for loss detection and recovery. NCMPT [8] (nodes cooperation based multi-path transmission protocol) is based on ReInForM algorithm. In this algorithm sensor node designs the set which comprise of before hop (H−), this hop (H0) and next hop (H+) based on the hop distance between itself and sink node. To achieve better transmission reliability, data from source node are transmitted not to one sensor node, but to multiple sensor nodes in the inner cluster, when source nodes have data packets to be transmitted. ARTP [9] (Adaptive Reliable Transport protocol) is designed as receiver controlled based on a new protocol stack and uses slightly different semantics of acknowledgement messages. In order to reduce the energy consumption it uses three different types of acknowledgements, i.e. Acknowledgement (ACK), Negative Acknowledgement (NACK) and Forward Looking Negative Acknowledgement (FNACK). FNACK with a sequence number is sent by the receiver to the sender, to inform that no more data packets have been received and an interval of time has passed during which remaining unoccupied receiver cache would have got filled up if the data packets were continued to be collected at the present average packet receiving rate.

QERP [10] (Quality-based Event Reliability Protocol) is designed to optimize event reliability by incrementing the number of data packets successfully transmitted by regulating transport process. In QERP, reporting data from sensor nodes are distinct in the contribution degree (CD) for event detection according to their environmental conditions. It consists of two different processes, a collection process for collecting sensor nodes to send their reporting data to the sink node according to CD and a transport process for differentially transporting them by CD based buffer management and CD based load balancing in data congestion. RP2PT [11] (Reliable Point-to-Point Transport Protocol) uses virtual circuit between the source nodes and the sink node and provides assured reliability by local caching and local retransmission. In RP2PT, data packets at the intermediate node can be cached with a given probability such that retransmission can be implemented between this intermediate sensor node and the sink node.

A new reliable data delivery protocol [12] is designed as hop-by-hop reliable transport layer protocol for wireless sensor networks. It detects loss by using NACK and recovery pattern by end-to-end sequence numbers. It provides a new queue management pattern that gives priority to new data. It is also based on dequeue policy in which if a new packet is received and the transmission queue is full, then the node discards the packet at the head of the queue and makes space for the newer packet. MPLOT [13] (Multi-Path LOss-Tolerant) is designed around the basis of separability of reliability and congestion control functions in an end-to-end transport protocol. It performed congestion control separately on individual paths, and the reliability method works over the collective set of paths available for an end-to-end session. It uses combination of Forward Error Correction (FEC) coding and adaptive Hybrid Automatic Repeat Request (HARQ) to decrease the number of data packet retransmissions, and exploits Explicit Congestion Notification (ECN) to separate between congestion and link losses.

GLRD [14] (Geographic Location based Reliable Data transmission over multipath) provides reliable data transmission over multipath in the wireless sensor networks and accomplish improved performance on transmission time delay and energy utilization. The achievement of GLRD protocol is based on the success of the forwarding node election at each hop. If higher than two candidate nodes locate at the first transmitting slot, and further crash at the first transmitting time slice, this data packet fails to continue to be forwarded to next hop. RETP [15] (Reliable Event Transmission Protocol) is designed as real time event detection and reliable packet forwarding in wireless sensor networks. It consists of two procedures, Accurate Event Detection and Real-time and Reliable Transmission. In Accurate Event Detection, each sensor collects the event information and makes the decision cooperatively in order to ensure whether a particular event happened or not. In RETP, to perform real-time event transmission a timer is set for each sensor and the event packet reliability is achieved with the technique called multi-transmission.

Reliable and Efficient Caching-Based WSN Transport Protocol [16] is designed to improve Distributed Transport for Sensor Network (DTSN) protocol (denoted as DTSN+) and compared its performance with TCP and Datagram Transport Protocol for Ad Hoc Networks (DTPA). This protocol comprises of enhanced O(1)-time complexity NACK recovery technique, experimental verification of the optimal DTSN acknowledgement window (AW) and performance evaluation of DTSN with transport protocol TCP and a newly proposed protocol DTPA. HRDG-MS [17] (High-Reliability Data Gathering Protocol Based on Mobile Sinks) is designed on the basis of two mechanism i.e. No-Route-Buffer mechanism and adaptive BEACON interval strategy respectively. The two different parameters are used for performance evaluation of HRDG-MS protocol. Forwarding overhead represents the efficiency of a protocol. Furthermore, packet loss ratio is defined as the ratio of the number of data packets unsuccessfully delivered to mobile sinks to the number of data packets sent by the sensor nodes.

In this section, we first analyze the working of an existing protocol (PSFQ), we then present the weaknesses of an existing protocol and after that we provide solution to those weaknesses in our proposed HDRTP protocol for wireless sensor networks.

PSFQ is a hop-by-hop downstream transport protocol which is reliable, scalable and robust. It uses NACK-based loss detection and notification and local retransmission for loss recovery. It consists of three operations: pump, fetch and report. The pump operation controls the rate at which data packets are passed into the network. The fetch operation requests a retransmission of the lost packet from the neighbouring nodes. Lastly, the report operation provides a feedback status to the users [18]. It has four types of message formats: INJMSG, NAKMSG, REPMSG and REPAIR. INJMSG is the message used to inject the program image into the nodes. NAKMSG is NACK message; it is used to inform other nodes about a negative acknowledgement. REPMSG is report message; it is used to inform the user node about data delivery information. REPAIR is repair message; it is used for initiating repair requests from other nodes. It consists of few timers which are responsible for keeping timings of different operations performed by the protocol. There are two pump timers known as T
                        min (in milliseconds) and T
                        max (in milliseconds) which are used to control the pump operation. A user node broadcasts a message every T
                        min ms until it sends out all its file fragments. If this is a new message, PSFQ will buffer the packet and decrease the Time to Live (TTL) by 1. If the TTL value is not zero and there is no gap in the sequence number, then PSFQ sets a schedule to forward the message. A node that receives a message, buffers it in its internal cache and waits for a random time between T
                        min and T
                        max to forward this message to the next node. A random delay before forwarding a message is required because the timings of the broadcasting nodes may be highly correlated, which may cause collisions.

Also T
                        max can give an estimation of the delay bound D(n) as given in Eq. (1)
                        
                           
                              (1)
                              
                                 D
                                 (
                                 n
                                 )
                                 =
                                 
                                    
                                       T
                                    
                                    
                                       max
                                    
                                 
                                 *
                                 n
                                 *
                                 (
                                 number of hops
                                 )
                              
                           
                        where n is the number of file fragments.

Fetch timer is used when a node goes into fetch mode where it aggressively sends out NACKs to its neighbours to request the missing segments. If no reply is heard or only a partial set of segments are recovered within a period of Tr
                         (in milliseconds) time, then the node will resend NACK every Tr
                         ms (with slight randomization). Tr
                        
                        <
                        T
                        max defines the pump fetch relationship. Proactive fetch timer is used in the proactive fetch mechanism and it is designed to autonomously trigger the fetch mode at the proper time. Report timer is used when the node enters the report mode where it receives an inject data message with the “report bit” set in the TTL field. Each node along the path towards the source node will piggyback its report message by adding its own node ID and sequence number pair into the report, and then propagate the aggregated report towards the user node. Each node will ignore the report if it found its own ID in the report to avoid looping [7].

We have already discussed the functionality of an existing protocol in previous subsection. In this subsection, we discuss some weaknesses of an existing protocol which are improved in the proposed protocol.

NACK based approaches suffer from last-segment-lost and all-packet-lost problems because the receiving node has no way to know that some segments are lost unless some segment arrives at the node which has a sequence number higher than expected.

Since PSFQ protocol is based on NACKs, there can be problems of last-segment-lost and all-packet-lost. Last-segment-loss problem is solved by the proactive fetch feature of PSFQ. Proactive fetch comes into action given by the timer which acts after time T
                           pro (in milliseconds), which is given by Eq. (2).
                              
                                 (2)
                                 
                                    
                                       
                                          T
                                       
                                       
                                          pro
                                       
                                    
                                    =
                                    α
                                    ∗
                                    (
                                    
                                       
                                          S
                                       
                                       
                                          max
                                       
                                    
                                    -
                                    
                                       
                                          S
                                       
                                       
                                          last
                                       
                                    
                                    )
                                    ∗
                                    
                                       
                                          T
                                       
                                       
                                          max
                                       
                                    
                                    
                                    where
                                    
                                    (
                                    α
                                    ⩾
                                    1
                                    )
                                 
                              
                           
                           T
                           pro should be proportional to the difference between last highest sequence number (S
                           last) packet received and the largest sequence number (S
                           max) of the file. α (alpha) is a scaling factor to adjust the delay in triggering the proactive fetch and should be set to 1 for most operational cases [7]. But the PSFQ does not consider the all-packet-lost problem. The case in which a node fails to hear the transmission due to some reasons such as noise or temporary node failure (or when the node is booting). This problem is common especially when the file size is small or may consist of a single transmission. Also noisy environments may cause such problems. Systems which use NACK exclusively have no way to guarantee delivery of a single packet.

PSFQ employs a slow pump operation. It is another drawback because it slows down the operation of transfer of file segments in the nodes. This protocol does not provide a way to dynamically adjust the PSFQ timers. It uses static and slow pump operation that results in large delay. A faster pump operation would provide much faster transfer of file fragments. Faster pump operations could be used when possible, such as when working in a low error rate environment. Since the timing of pump operation is controlled by T
                           max and T
                           min which are programmed at compile time; they cannot be changed during actual programming. Hence they are static in nature.

The PSFQ protocol may fail if the sensors are still booting or temporarily switched-off since the protocol achieves reliability by NACKs. A node which is still booting/temporarily switched off will not be able to perceive any ongoing transmission and shall send no NACKs. In other words, a sending node has no way to judge whether the destination node has correctly received all segments or it is switched off. When the node gets into the booted state or gets switched on, it will have no idea of the transmission that took place in the recent past.

In this subsection, we present the enhancement of an existing protocol by removing its weaknesses given in the previous subsection. We have added two new types of messages and supplemented the NACK based protocol with ACKs. In the next section, we have done performance analysis of both an existing protocol and HDRTP protocol.

We have added two message types to an existing protocol which originally had four message types. The new message types are INFORM MESSAGE (INFMSG) and ACKNOWLEDGEMENT MESSAGE (ACKMSG). The nesC code of the new packets are shown in Fig. 1
                           .

INFMSG is used to inform the nodes with the new parameter values. This contains five fields (which can be easily increased) in the header. The header contains the values which will be used for initialization of different variables in each node. These values can be used for initialization of timer values and other node parameters. Fig. 2
                               shows an INFMSG received in TinyOS Simulator (TOSSIM).

ACKMSG is used for acknowledgement purposes. Originally PSFQ does not have any acknowledgement message. The benefits of these two new message types will be elaborated in the coming subsections.

PSFQ does not have any mechanism for dynamically assigning parameters such as T
                           max, T
                           min, and alpha which are used for the timing purposes. In PSFQ, these parameters are assigned to nodes at compile time and cannot be changed before doing the actual reprogramming of node. We introduce a new mechanism in HDRTP to assign these parameters dynamically. Benefits of dynamically assigned parameters will be that we will be able to alter T
                           max/T
                           min (responsible to control the pump/fetch ratio) and constant such as alpha (which are responsible for timing in proactive fetch). Hence we will be able to control pump/fetch ratio and control the delay time bounds of PSFQ upload according to delay bound as given in Eq. (1).

To achieve this, we use INFMSG which we introduced briefly in the previous subsection. INFMSG is responsible for uploading the parameters to each node by unicast. Node 0, which is the user node (or sink), sends unicast INFMSG message to each node that contains the parameters as shown in Fig. 3
                           . Every other node on receiving this message updates its parameters with the new ones in the INFMSG. To solve the problem of a lost INFMSG, an acknowledgement mechanism is used which is explained in the next subsection.

The lost-full-message problem is caused when a sensor node fails to hear a full message. It can be due to two reasons either the node is temporarily switched-off (or booting), or a node can miss a whole transmission due to noise in radio transmission. Lost-full-messages can be quite common when messages are short. NACK systems also fail in single message transmissions.

To solve this problem, we use the newly introduced ACKMSG instead of NACK because ACKs provide assurance that the packets has arrived at the destination without causing too much traffic and interference in the network. If we acknowledge each received packet with ACK, we will quickly detect when a packet has been lost, so we will not loose time to wait for a timeout. If we use NACK instead, we will become dependent on the traffic pattern because if we send a single request packet and expect an answer, and that request is lost, we will have to have a timeout that expires if we do not get an answer.

The ACKMSG is used to acknowledge the receipt of INFMSG. Apart from updating the parameters at each node, INFMSG also informs each node of the incoming file transmission. After successfully receiving the INFMSG, each node starts to wait for the incoming file transmission (INJECT messages). If a node does not get the transmission after a predefined time, the node will itself go into proactive fetch mode requesting the file segments itself.

Addition of the ACKMSG turns the new protocol into hybrid ACK/NACK protocol.

PSFQ could fail when the user node (sink) starts to inject packets into the network when the nodes are still booting or temporarily switched-off. Since the receiving nodes reply by a NACK in case of an error, there is no way for a sending node to know whether a node has correctly received all segments or it is switched off.

Again this problem is solved with help of the newly introduced INFMSG and ACKMSG. We have changed the protocol as such, before starting the PSFQ pump operation the user node (sink) has to update all nodes with INFMSG and wait for the acknowledgement with ACKMSG. In case of a still booting/switched-off node, a node will not be able to reply with ACKMSG. Only a booted/switched-on node will be able to reply with the ACKMSG. Hence the user node will be able to know which node is booted/switched-on.

In an existing protocol, the duty of informing the nodes of the new file size, file ID was with the inject message. We have given this responsibility to ACKMSG. The inject message still retains these fields.

In this section, we have presented the performance analysis of proposed HDRTP protocol and an existing protocol. We have used packet level simulation. Our approach works by changing the way an existing algorithm works at the user node (sink) and sensor nodes. We have added some functionality at both the user and sensor nodes to improve the algorithm.

An existing algorithm starts injecting packets into the network as soon as the user node boots. Our algorithm on the other hand works in two phases. In first phase, it sends INFMSGs to all the nodes participating in the network informing them about the impending file transfer and waits for their acknowledgement through ACKMSGs. After the user node successfully receives acknowledgement from all nodes it moves to the second phase. In the second phase, it sends INJECT packets to all the nodes in the conventional manner.

The user node maintains an array containing the status of receipt of ACKMSGs from all the nodes and sends INFMSGs to all the nodes from which it has still not received an ACKMSGs. The user node sends the INFMSGs in a round-robin manner such that it does not need to wait for a node which is still booting/switched-off and moves to a further node in case a node does not reply with an ACKMSG. The sensor nodes are provided with a mechanism to use the data provided in the INFMSGs and then to reply to the user node with an ACKMSG.

We have compared the proposed HDRTP protocol with an existing protocol on the basis of three parameters. We have studied these parameters as a function of channel error rate as well as the network size. The parameters are explained as follows.

We have observed that in some cases, an existing protocol fails to transmit data to the node, in case the node is currently in the state of booting or temporarily switched off. We compare both the protocols in a simulation where the nodes including the user node boot at a random time within a given time interval. The success rate is based on how many nodes the protocol is able to successfully program in the network.

Average latency is the time a protocol takes to program a sensor node, from the beginning of the simulation to successfully transmit all file fragments. In the simulation, the nodes boot at a random time within a given time interval and start injecting packets into the network. The time it takes for a node to receive the full program image is its latency. We have calculated the average of the latency of few simulations to obtain the average latency.

Average delivery ratio measures the ability of the protocol to successfully transfer the data packets to final destination within certain time limit. Average delivery ratio is the ratio of number of messages a target node received to the number of messages a user node injects into the network. We have calculated the average of the delivery ratio of few simulations to obtain the average delivery ratio.

We have tested proposed HDRTP protocol and an existing protocol on TinyOS [19]. We simulate the network in which all the nodes are running TinyOS over the TOSSIM simulator. We simulate a total of 19 nodes, which contains 18 sensor nodes and 1 user node used for injecting the file image. The simulation setup is shown in Fig. 3. In this setup, round dots are sensor motes and link between them shows transfer of data packets. A user node at location 0 attempts to inject a program image file of size equal to 0.8kB into every node. Protocol header size is 11bytes while data size is 16bytes. So there are 50 data packets. Packets are generated from the node at location 0 and transmitted at a rate of one packet every 10ms towards user node 1. User node 1 first receives all the data packets. When it completes receiving all the data packets it starts forwarding those packets towards node 2. Node 2 does not wait for all the data packets; it runs in normal fashion. So node 2 routes data packets towards node 3, then node 3 towards node 4 and so on. Network size decides the last node. If network size is 10 then our target node is 10. The communication takes place as shown by the arrows while transmitting the file segments. ACKMSGs and INFMSGs are sent using unicast method directly from the user node to the sensor node.

We have simulated the protocols using TOSSIM running on system based on XUBUNTU. The network has been visualized using TinyViz, a java based application which helps in visualizing TOSSIM simulations.

We have simulated the network such that the nodes should boot randomly at different times. This would help us to know how the protocols deal with booting nodes. We have used four scenarios as shown below, each with 0% error rate, T
                           max
                           =96ms and T
                           min
                           =48ms.
                              
                                 •
                                 Boot time interval=10s.

Boot time interval=20s.

Boot time interval=40s.

Boot time interval=60s.

In each scenario, we have simulated the protocol 10 times and reached to the following conclusion.

In Fig. 4
                           (a), we had a 10s boot time interval for sensor nodes, which means all the nodes are booted uniformly within a time frame of 10s. We see that in 8 out of the total 10 simulations, the protocol has been able to program all of the nodes successfully. In Fig. 4(b), we had a 20s boot time interval which shows that in only 4 out of the total 10 simulations, the protocol has been able to program all of the nodes successfully. In two simulations, only few nodes were programmed successfully. In Fig. 4(c), we had 40s boot time interval which shows that in only 2 out of the total 10 simulations, the protocol has been able to program all of the nodes successfully. In one simulation, only a single node has been programmed successfully. In Fig. 4(d), we had a 60s boot time interval in which we see that in only 2 out of the total 10 simulations, the protocol has been able to program all of the nodes successfully. In four other simulations, only a few nodes have been programmed successfully.


                           Fig. 5
                            shows the success rates of the protocols as a function of nodes programmed vs. boot interval. The graph shows how the probability of a node being programmed decreases with the increase in the boot time of the node.

Since PSFQ is a NACK based protocol, it fails to program the nodes because it does not receive any NACKs from the booting nodes and hence assumes that they have received the file segments that results in increasing the overhead and collisions in the low-bandwidth wireless sensor networks. Our protocol first confirms that all nodes are booted and only after that starts sending them the file segments. So our protocol is able to program all the nodes with any boot time and provides 100% success rate of data.

Latency is the time that the protocol takes to transfer the whole file from the user node to the sensor node. We have done a couple of simulation experiments and averaged the results to calculate the average latency. Since PSFQ fails to transmit a file fragment in case the nodes are still booting, we delay the transmission of file till the time all the nodes are booted. Our protocol automatically finds when all the sensor nodes have been booted and injects the file fragments. For the original PSFQ, we need a fixed amount of time after the booting of the user node to start injecting messages. This time is needed to be sure that all the sensor nodes have booted otherwise the PSFQ protocol fails as shown earlier.

Sensor nodes may have different boot times and it may not be possible to boot every node at the same time. Hence we will be basing some of our simulations on different boot times. Details of the average latency observed in our simulations, by changing the boot time interval and error rate, are given in Tables 1–6
                           
                           
                           
                           
                           
                           .


                           Tables 1, 3 and 5 shows result of PSFQ and HDRTP in terms of average delivery ratio and average latency for different network size for 30%, 50% and 70% packet error rate with 60s of boot time interval. Tables 2, 4 and 6 shows result of PSFQ and HDRTP in terms of average delivery ratio and average latency for different network size for 30%, 50% and 70% packet error rate with 30s of boot time interval. So these tables give us comparison of performance of PSFQ and HDRTP under different channel error conditions.

We simulated the protocols with T
                           max
                           =96ms, T
                           min
                           =48ms, Error Rate=30%, 50% and 70% packet loss, Sensor boot time=60s as shown in Fig. 6
                            and the file has been injected into all the 18 nodes. The graph in Fig. 6 shows that our protocol works much better than an existing protocol, because it starts injecting file segments as soon as all nodes boot.

We simulated the protocols with T
                           max
                           =96ms, T
                           min
                           =48ms, Error=30%, 50% and 70% packet loss, Sensor boot time=30s as shown in Fig. 7
                            and the file has been injected into all the 18 nodes.

As we observe in Figs. 6 and 7, our algorithm apart from solving the problems with PSFQ requires less delay to transfer the whole file from the user node to the sensor node. From the graph, we can conclude that as the network size increases, the average latency also increases. Also we can say that HDRTP has less delay as compared to original PSFQ.

It is measured by the ratio of the number of packets a target node receives to the number of packets a user node injects into the network. Tables 1–6 shows result of PSFQ and HDRTP in terms of average delivery ratio for different network size, boot interval and packet error rate. So these tables give us comparison of performance of PSFQ and HDRTP under different channel error conditions. Each experiment is run ten times and the results shown are an average of these runs.

We simulated the protocols with T
                           max
                           =96ms, T
                           min
                           =48ms, Error=30%, 50% and 70% packet loss, Sensor boot time=60s as shown in Fig. 8
                            and the file has been injected into all the 18 nodes.

We simulated the protocols with T
                           max
                           =96ms, T
                           min
                           =48ms, Error=30%, 50% and 70% packet loss, Sensor boot time=30s as shown in Fig. 9
                            and the file has been injected into all the 18 nodes.

As we observe in Figs. 8 and 9, our algorithm apart from solving the problems with PSFQ performs much better than an existing protocol. We can see that as the network size increases, the number of packets received at the target node varies. More number of data packets is received by target node in case of HDRTP protocol. For 30%, 50% and 70% error rate, it is 1 for more number of nodes in case of HDRTP while in case of PSFQ it is less than 1 for most of the nodes. Also as the error rate changes from 30% to 50% or 70%, there is much decrease in delivery ratio.

Our protocol also provides the facility of dynamically adjusting the parameters responsible for pump/fetch ratio and proactive fetch. In Fig. 10
                           , we demonstrate how changing the parameters affect the file transfer latency.

In the simulation shown in Fig. 10, we kept an error rate of 50% packet loss; boot interval was set to 30s. T
                           max and T
                           min have been varied. As we observe from the graph, the latency decreases as we decrease the pump/fetch parameters. This is what is expected by faster pump operations, but to the down side is that during the simulation time T
                           max
                           =24ms and T
                           min
                           =12ms, the protocol failed on few occasions during simulation. Simulation with higher pump ratios was perfect; all simulations worked and transmitted the file fragments till the last node. Details of the average latency observed in simulations, by changing pump/fetch ratios are given in Tables 7–9
                           
                           
                           .


                           Tables 7–9 shows result of HDRTP in terms of average latency for different network size for 50% packet error rate and 30s of boot time interval with dynamically assigned parameters.

@&#CONCLUSION@&#

A hybrid and dynamic reliable transport protocol (HDRTP) is presented for wireless sensor networks. We have shown performance analysis of HDRTP protocol and an existing protocol (PSFQ). We have simulated the protocol and found that the HDRTP protocol performed better than an existing protocol. The HDRTP protocol program all the nodes with different boot time interval and solves booting sensor nodes problem and all-packets-lost problem. Apart from these improvements, we added the dynamic assignment of parameters to the protocol, which helps to improve the static and slow pump operation of an existing protocol. It has been shown that HDRTP protocol works better than an existing protocol in terms of success rate, average latency and average delivery ratio.

@&#ACKNOWLEDGEMENTS@&#

This work has been carried out in wireless sensor network research facility in Computer Science and Engineering department of PEC University of Technology, Chandigarh, India. This research facility has been funded from the inhouse grant of PEC University of Technology. We thank the Director Prof. Manoj K. Arora and the head of the department Prof. Rajesh Bhatia for his co-operation in setting up of this research facility and giving us an opportunity to work there.

@&#REFERENCES@&#

