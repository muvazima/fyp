@&#MAIN-TITLE@&#The modular tool switching problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper introduces the modular tool switching problem.


                        
                        
                           
                           The problem is an extension of the traditional tool switching problem.


                        
                        
                           
                           The property that tools can be swapped individually or in group makes the problem difficult to solve.


                        
                        
                           
                           We show that the MTS problem is NP-hard in the general case.


                        
                        
                           
                           We also show that with a fixed number of online modules and a fixed capacity, the problem can be solved in polynomial time.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Complexity theory

Flexible Manufacturing Systems

Tool loading

Set-up optimization

Printed circuit board

@&#ABSTRACT@&#


               
               
                  This article analyzes the complexity of the modular tool switching problem arising in flexible manufacturing environments. A single, numerically controlled placement machine is equipped with an online tool magazine consisting of several changeable tool feeder modules. The modules can hold a number of tools necessary for the jobs. In addition to the online modules, there is a set of offline modules which can be changed to the machine during a job change. A number of jobs are processed by the machine, each job requiring a certain set of tools. Tools between jobs can be switched individually, or by replacing a whole module containing multiple tools. or a whole module, containing multiple tools can be replaced. We consider the complexity of the problem of arranging tools into the modules, so that the work for module and tool loading is minimized. Tools are of uniform size and have unit loading costs. We show that the general problem is NP-hard, and in the case of fixed number of modules and fixed module capacity the problem is solvable in polynomial time.
               
            

@&#INTRODUCTION@&#

In the assembly of printed circuit boards (PCB), flexible component placement machines are used to mount components onto a bare PCB. The placement machines are highly automatized, configurable and suitable for the assembly of a wide range of PCB product types. The flexibility and configurability of these machines results in various efficiency problems. The planning and control of PCB assembly machines is a task that consist of multiple interconnected problems (see Ayob and Kendall, 2008; Crama, 1997; Crama et al., 2002).

One of these problems arises when several different PCB product types are manufactured on a single machine, with each product type requiring a specific set of component types to be placed on the boards. The component placement machines are equipped with a feeder unit that can hold a sufficient number of component input reels to manufacture a single product type. Due to the capacity constraints of the feeder unit, it is not possible to load at once all the component reels required for all the PCB jobs.

In the case of multiple PCB types, as one PCB type batch ends, the content of the feeder unit must be reconfigured, by loading the component reels required for the next PCB type. This replacement can occur only between processing jobs, because the machine must be stopped. Replacing one component reel causes extra delay in production, and the total delay between two jobs is determined by the number of component reel swaps.

The above discussion deals with the organization of job switching in the context of PCB assembly manufacturing. The same situation occurs in many other Flexible Manufacturing Systems (FMS), where tools (above component reels) are stored in tool magazines (feeder units). Minimizing the setup delay is known in literature as the Tool Switching Problem (TS) (see Tang and Denardo, 1988), in this more general context.

Many variants of the tool switching problem have been extensively studied in literature. The order in which the jobs are processed may be fixed or arbitrary. If the job order is arbitrary, the tool switching cost can be further reduced by finding a better job sequence (this is also known as the job sequencing problem). The cost of switching tools may be uniform or tool specific. Further, the size of the tools may be uniform, or tool specific, causing fragmentation of the feeder unit in the latter case. The job sequencing problem is NP-hard even in the case of uniform tool sizes and equal switching costs (Crama et al., 1994).

When the job sequence is fixed, the tool switching problem with uniform tool sizes and equal change costs can be solved optimally in polynomial time by the means of the KTNS procedure of Tang and Denardo (1988). When tool sizes are non-uniform, the problem is NP-hard even for the fixed job sequence (as shown in Crama et al., 2007, where the problem is called the tool loading problem).

Over the past decade, component placement machines have increasingly employed modular feeder units to improve versatility, flexibility and efficiency of these equipments. Such examples are Fuzion from Universal, iFlex from Assemblon, and BM/NPM from Panasonic. These machines employ several feeder module units that are online at the same time. The modules contain component reels, and can be swapped with readily available offline modules, that have been prepared in parallel to the processing of the current assembly job.

The present work focuses on the practical problem of switching component reels (tools) in a single placement machine containing multiple removable feeder modules of equal capacity. Each feeder module contains a number of component reels (typically 40), and one or more online modules can be replaced by another module which has been prepared to contain a different set of component reels. Swapping a feeder module with another one incurs a much smaller delay (cost) than swapping some individual component reels. Therefore, switching components in groups can reduce the overall setup time required when transitioning between PCB job types. Component reels can also be swapped individually in the online modules if that is preferred (in case of small setup changes), making the problem more difficult than the basic tool switching problem.

The problem of switching tools in groups to improve production efficiency is not considered by the tool switching literature to our knowledge. Let us call this problem the modular tool switching (MTS) problem, where in the present context, tools are component reels required to manufacture PCB jobs (see Fig. 1
                     ). In the present work, the tools have uniform sizes and the delay caused by switching tools to online modules is also uniform across tool types. The delay of switching a feeder module is a constant, different from the tool switching delay. We show that by introducing online and offline modules into the tool switching problem, the problem becomes NP-hard even in the case of a fixed job sequence, uniform tool sizes and equal tool switching delays.


@&#LITERATURE REVIEW@&#

The tool switching literature focuses mainly on solving two problems. The first one deals with a fixed job sequence (see Matzliach and Tzur, 2000). The second problem also includes the task of finding an order of the jobs that minimizes the tool switching costs. The general tool switching problem was introduced by Tang and Denardo (1988). They proposed a polynomial time, optimal algorithm called Keep Tool Needed Soonest (KTNS), for the case of a fixed job sequence, uniform tool sizes and tool switching costs.

The case of fixed job sequence, uniform tool size, and tool specific changeover cost was discussed by Privault and Finke (1995). They show that if the changeover costs are of the form dik
                        , where tool i is inserted after removing tool k, then the problem can be solved optimally by formulating it as a min-cost flow problem.

For non-uniform tool sizes and arbitrary magazine capacity C 
                        Stecke (1983), the problem becomes NP-hard even for a fixed job sequence, as shown by Crama et al. (2002). Heuristic methods for solving the problem were given in Hirvikorpi et al. (2006) and in Tzur and Altman (2004). However, when the magazine capacity C is fixed, Crama et al. (2002) show that the problem admits a polynomial-time optimal algorithm, albeit with a very large exponent, making it unpractical for industrial application.

For the case of job sequencing with uniform tool sizes, Crama et al. (1994) show that the problem is NP-hard, even for C = 2. Heuristics to solve the problem have been proposed in Bard (1988),Hertz et al. (1998),Djellab et al. (2000),Salonen et al. (2003),Song and Hwang (2002) and Zhou et al. (2005). The approximability of the problem was discussed by Crama and van de Klundert (1999). Al-Fawzan and Al-Sultan (2003) use a tabu search approach to find better job sequences, that minimize the number of tool switches.

For the case of job sequencing with non-uniform tool sizes, two NP-hard problems (tool switching and job sequencing) are combined into a single optimization objective. Heuristics to solve the combined problem have been discussed in Matzliach and Tzur (2000) and Raduly-Baka et al. (2005).

While the case of modular tool magazine and extra offline modules is an important practical application, previous research on it seems to be missing.

Next, the definition and assumptions of the modular tool switching problem (MTS) are given, in the context of loading component reels into feeder modules of a PCB assembly machine. Suppose, that a list J of n PCB assembly jobs is given. The jobs are processed by a single component placement machine. The order in which these jobs are processed is fixed by the list J. Each job j (j ∈ [1…n]) requires the insertion of a set Tj
                         of different component types (these are considered tools) and the components of a job are supplied by the means of a modular feeder unit (tool magazine).

The feeder unit has sufficient capacity to hold all the component reels required for a job. The feeder unit contains a number of F changeable modules (typically from 2 to 6). Each module has the same fixed capacity C to hold the component reels. A number of E offline modules are available in the vicinity of the machine. The capacity of each offline module is the same C, and their content can be manually rearranged, in parallel to the processing of the current job, having no impact on the production time.

The available capacity in all the online modules is F · C, and it is not sufficient to hold all the component reels for all the PCB types: |∪
                           j ∈ [1…n]
                        Tj
                        | > F · C. Therefore, component reel changes are possibly required between jobs. Reels can be changed individually, incurring a delay of tc
                         for each change, or in group by changing a whole module, incurring a delay of tm
                         for each module change. By changing a module, one can change a total of C component reels in one step (C is typically 20–40) and incur a single tm
                         delay that is much smaller than a C · tc
                         delay of changing all reels of a module while changing jobs. (In practice the tm
                        /tc
                         ratio tends to be between 2 and 4, and it is 2.5 for the machine types studied here.) Therefore, arranging component reels into offline modules, so that they can be swapped in a group when transitioning to the next job, is advantageous in terms of the incurred delay.

Next, the parameters and assumptions of the MTS problem are listed:

                           
                              
                                 C
                              
                              the capacity of a feeder module. All feeder modules have equal capacity.

the number of online feeder modules.

the number of offline modules. It is assumed that at least one offline module is available. Otherwise the problem simplifies to the well known tool switching problem which can be solved optimally by the means of the KTNS procedure.

the number of PCB assembly jobs. The order in which jobs are processed is given and fixed by list J.

the set of component types required for job j. It is assumed that a single job will always fit into the available online capacity (|Tj
                                 | ≤ F · C), and that there is no sufficient online capacity for all the jobs: (|∪
                                    j ∈ [1…n]
                                 Tj
                                 | > F · C). All components are of uniform size, i.e. demand a unit space (single slot) in the feeder module.

the delay incurred when swapping one component reel in an online module.

the delay incurred when swapping one online module with an offline module.

It is assumed that the completion time of each job is sufficiently large that offline modules can be prepared before the job completes. This simplifying assumption is valid mainly because jobs are typically batches of identical PCB units.

Extra copies of component reels may or may not be available. If extra copies are available, these make it easier to setup offline modules, while the current job is being processed. The number of extra copies may be limited per component reel type, or it may be that no extra copies are available due to budgetary constraints. There are F online modules and there is no need to place more than one reel of a type into a module. Therefore, it is sufficient to have F + 1 copies available of each component type reel, so that at least one reel is available offline, and there is no need to wait for a job to complete when building offline modules. Otherwise, some component reel types may be locked into online modules, so an offline module can be completed only after the previous job completes, and at that moment all the component reel switchings will be counted in the total delay.

The problem of switching component reels (tools) having equal sizes, equal switching costs, and no offline modules, can be solved by the means of the KTNS procedure. In the case of modular feeder units, with at least one offline module, the problem becomes more complicated by the fact that switching modules incurs a smaller cost than switching individually several component reels of a module.

Next, we show that if the capacity constraints F and C are arbitrary, the MTS problem is NP-hard. In fact there are four cases of the MTS problem in terms of the capacity constraints. Either F or C can be fixed, or can be arbitrary parameters. In the case of either F or C are arbitrary, the problem is NP-hard. Only when both F and C are fixed, the problem becomes polynomially solvable.

The four cases of the MTS problem are:

                        
                           •
                           The General MTS or simply MTS is the problem of minimizing the delay incurred by component reel and module switches, when both the number of online modules F and their capacity C are arbitrary.

The MTS-F problem is the special case of MTS, when the number of online modules F is fixed, but the capacity C of these modules is arbitrary.

The MTS-C problem is the special case of MTS, when capacity of the modules C is fixed, but the number of online modules F is arbitrary.

The MTS-FC problem is the special case of MTS, when both the number of online modules and their capacity are fixed.

Next, we show that MTS, MTS-C and MTS-F are NP-hard, while MTS-FC can be solved in polynomial time, albeit with very large exponent.

In the General MTS (or just MTS) problem, F and C are arbitrary. We show that this problem is NP-hard, by showing that its decision version (Decision-MTS) is NP-complete. The proof is inspired by the complexity proof for the traditional tool switching problem with non-uniform tool sizes by Crama et al. (2007).

In Decision-MTS, a fixed integer L is given and it is asked whether there is a module and component reel switching policy so that the total delay is less or equal than L. We use a reduction from 3-Partition which is known to be strongly NP-complete (Garey and Johnson, 1979). The 3-Partition problem is defined as follows:

Given a multi-set S of 3n positive integers wk
                           , and a positive integer B, where B/4 < wk
                            < B/2 for each wk
                           , and ∑
                              k ∈ S
                           
                           wk
                            = nB. The problem asks to partition S into n disjoint triples S
                           1, S
                           2, …, Sn
                           , so that for each 1 ≤ i ≤ n, the sum of integers in Si
                            is B: 
                              
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       
                                          S
                                          i
                                       
                                    
                                 
                                 
                                    w
                                    k
                                 
                                 =
                                 B
                              
                           .


                           
                              Lemma 1
                              Decision-MTS is NP-Complete, with at least one offline module and with or without extra component reels.

Clearly, Decision-MTS is in NP: given a module setup and component reel switching policy, it is easy to sum up the setup delay incurred between jobs. Next, we show that the 3-Partition problem can be reduced into a Decision-MTS problem.

In the Decision-MTS, one or more offline modules can help to reduce the cost of component reel switches. First, we consider the case where at least one extra copy is available for each component reel type. Then, with a small change, we show that the reduction works even if no extra copies of component reels are available.



                                 One extra copy for each component type. Given an arbitrary instance I of the 3-Partition problem, a Decision-MTS instance will be constructed in the following way:

                                    
                                       •
                                       Set the component reel switching cost tc
                                           = 6n + 1 and the module switching cost tm
                                           = 1. The component reel switching cost can be any number equal or greater than 6n + 1, the goal is to force Decision-MTS to avoid switching component reels.

For each value wk
                                           (k = 1, 2, …, 3n) of I, define a set of basic component types 
                                             
                                                
                                                   T
                                                   k
                                                
                                                =
                                                
                                                   {
                                                   
                                                      t
                                                      
                                                         k
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      t
                                                      
                                                         k
                                                         2
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      t
                                                      
                                                         k
                                                         
                                                            w
                                                            k
                                                         
                                                      
                                                   
                                                   }
                                                
                                                ,
                                             
                                           |Tk
                                          | = wk
                                          . There are a total of n · B different component types.

Define an extra set of component types X, |X| = B. These component types are different from the ones in the basic sets Tk
                                          .

Let Ja
                                           be a basic job requiring all the basic component types from 
                                             
                                                
                                                   ∪
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   
                                                      3
                                                      n
                                                   
                                                
                                                
                                                   T
                                                   k
                                                
                                             
                                          . There are a total of nB component reels required by job Ja
                                          .

Let Jk
                                           be an extra job containing the component types 
                                             
                                                
                                                   (
                                                   
                                                      ∪
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      
                                                         3
                                                         n
                                                      
                                                   
                                                   
                                                      T
                                                      i
                                                   
                                                   )
                                                
                                                
                                                   ∖
                                                
                                                
                                                   T
                                                   k
                                                
                                                ,
                                             
                                           and wk
                                           component types from X. Job Jk
                                           also requires exactly n · B component reels. Component types from X are reused between various jobs Jk
                                          , by selecting a wk
                                           number of component types from X.

Each of the 3n component type set Tk
                                           induces a different job Jk
                                          .

Create a job sequence of 6n + 1 jobs: Ja, J
                                          1, Ja, J
                                          2, Ja
                                          , …, Ja, J
                                          3n
                                          , Ja
                                          .

Each of the 6n + 1 jobs requires exactly nB reel types.

Let the number of online modules be F = n, the capacity of a module C = B, and use at least one offline module of capacity C. The total available online capacity is thus n · B.

Clearly, each job fully uses the available online capacity.

Each pair of consecutive jobs (Ja, Jk
                                           or Jk, Ja
                                          ) s by a number of wk
                                           component types, and these reels must be switched between each job (see Fig. 2
                                          ).

There are 6n transitions between the 6n + 1 jobs. It is assumed that the machine starts with all the component reels available online for job Ja
                                          .

Since each transition must change at least wk
                                           component reels, the optimal solution must have at least one module change incurring a cost of tm
                                           = 1 per transition.

Set L = 6n, the Decision-MTS will ask if there is a module and component reel swapping policy with a delay no more than L.

All component reels have an extra copy available, so that offline modules can be prepared before the current job completes. One extra copy is sufficient, since there will be no need to duplicate copies in online modules. Each component type will have at most one reel online and at least one reel offline.

The above transformation creates a Decision-MTS problem instance that has a size exponential in the size of the 3-Partition problem, in case of binary representation. This is because for each value wk
                                  we create wk
                                  different components. If wk
                                  is binary encoded, the number of components will be exponential in the size of wk
                                 . Since 3-Partition is a strongly NP-complete problem, it is still NP-complete if unary coding of wk
                                  is used. Therefore, the unary coded representation of the 3-Partition is considered, and it is transformed into a Decision-MTS of similar size.

                                    
                                       1.
                                       To show NP-Completeness (with one extra copy for each component type), we show that a YES-instance of Decision-MTS translates into a YES-instance of 3-Partition and vice versa.

Consider that there is a YES-instance for Decision-MTS with L = 6n. A consecutive pair of jobs is either of the form (Ja, Jk
                                          ) or (Jk, Ja
                                          ). The difference between jobs Jk
                                           and Ja
                                           is exactly wk
                                           components, as the set of Tk
                                           components required by job Jk
                                           are replaced by wk
                                           components from the set X. Therefore, there must be some reel changes between two consecutive jobs.

There are 6n job transitions, and for L = 6n the answer of the Decision-MTS was a YES. Clearly, this can happen if and only if there is exactly one module swap between each consecutive jobs (the delay of the module swap being tm
                                           = 1). But this implies that all the wk
                                           component reels (basic or extra) are located in one module. That is, the (2k)th and (2k + 1)th job transition cannot be done with a delay of 1 if the replaced wk
                                           components of Tk
                                           or X are spread over multiple modules.

A transition from job Ja
                                           to job Jk
                                           can be done by a single module in the following way. Let Mi
                                           be the module containing reels from the set Tk
                                           while Ja
                                           is processed. Prepare a new module 
                                             
                                                M
                                                i
                                                ′
                                             
                                           offline, that has the same content as Mi
                                           except the reels of Tk
                                           are replaced with wk
                                           reels from X. 
                                             
                                                M
                                                i
                                                ′
                                             
                                           can be prepared offline because there is at least one extra offline copy for each reel (the other B − wk
                                           reels of module Mi
                                           are also required for module 
                                             
                                                M
                                                i
                                                ′
                                             
                                          ).

Each job requires exactly n · B reels. Each module holds at most B reels. Each set of Tk
                                           reels is fully contained in a module. A module cannot contain 4 or more Tk
                                           sets of reels (because B/4 < wk
                                          ). There are 3n sets of reels loaded into the n online modules, then each module contains exactly three sets of reels. Since the total online capacity n · B is fully used by each job, each module contains exactly B reels. Thus, when a job Ja
                                           is being processed, for each online module Mi
                                           we have 
                                             
                                                
                                                   ∑
                                                   
                                                      
                                                         T
                                                         k
                                                      
                                                      ∈
                                                      
                                                         M
                                                         i
                                                      
                                                   
                                                
                                                
                                                   |
                                                   
                                                      T
                                                      k
                                                   
                                                   |
                                                
                                                =
                                                B
                                             
                                          . This directly translates into a YES-instance of the 3-Partition problem, where Si
                                           corresponds to module Mi
                                           and 
                                             
                                                
                                                   ∑
                                                   
                                                      k
                                                      ∈
                                                      
                                                         S
                                                         i
                                                      
                                                   
                                                
                                                
                                                   w
                                                   k
                                                
                                                =
                                                B
                                             
                                          .

Now we show that a YES-instance of 3-Partition corresponds to a YES-instance of Decision-MTS with L = 6n. Given a solution Si
                                           to 3-Partition, assign modules Mi
                                           (i = 1, 2, …, n) with reels from Tk
                                           for all k ∈ Si
                                          . The capacity of a module is B, and from 3-Partition we will have 
                                             
                                                
                                                   ∑
                                                   
                                                      k
                                                      ∈
                                                      
                                                         S
                                                         i
                                                      
                                                   
                                                
                                                
                                                   |
                                                   
                                                      T
                                                      k
                                                   
                                                   |
                                                
                                                =
                                                B
                                             
                                          . Thus, all modules are completely filled with reels, and all 3n reel sets are made available online for job Ja
                                          .

At the transition from Ja
                                           to Jk
                                           there is exactly one module Mi
                                           that contains the set of reels Tk
                                          . Prepare an offline module 
                                             
                                                M
                                                i
                                                ′
                                             
                                           containing the other B − wk
                                           reels of Mi
                                           and wk
                                           reels from X. Swap Mi
                                           with 
                                             
                                                M
                                                i
                                                ′
                                             
                                           at cost tm
                                           = 1. A similar transition can be made from Jk
                                           to Ja
                                          . Thus, the given job list can be processed with no more than 6n module transitions, with each transition at a cost of tm
                                           = 1. This results in a YES-instance for the Decision-MTS with L = 6n.


                                 No extra copies of component reels. Consider the case where no extra reels are available to build offline modules. We show that a reduction exists from 3-Partition even in this case.

If there are sufficient extra copies of each component reel, a complete offline module can be prepared without using reels from online modules. This is a relaxed assumption of the problem. If there are no such extra copies, the offline module cannot be prepared completely and the above reduction will not hold. With a small change to the job list, the reduction can be modified so that it holds for no extra copies as well.

Define a new set Y containing B different component types, these are also different from component types in Tk
                                  and X. Define a new job Jy
                                 , that contains exactly B component types from Y. Now define a job sequence of the following form:

                                    
                                       
                                          
                                             
                                                J
                                                a
                                             
                                             ,
                                             
                                                J
                                                y
                                             
                                             ,
                                             
                                                J
                                                1
                                             
                                             ,
                                             
                                                J
                                                y
                                             
                                             ,
                                             
                                                J
                                                a
                                             
                                             ,
                                             
                                                J
                                                y
                                             
                                             ,
                                             
                                                J
                                                2
                                             
                                             ,
                                             
                                                J
                                                y
                                             
                                             ,
                                             
                                                J
                                                a
                                             
                                             ,
                                             …
                                             ,
                                             
                                                J
                                                a
                                             
                                             ,
                                             
                                                J
                                                y
                                             
                                             ,
                                             
                                                J
                                                
                                                   3
                                                   n
                                                
                                             
                                             ,
                                             
                                                J
                                                y
                                             
                                             ,
                                             
                                                J
                                                a
                                             
                                             .
                                          
                                       
                                    
                                 There are a total of 12n + 1 jobs, with 12n transitions. The Ja, Jy
                                  transition will unload all reels from a module Mi
                                 , and load one module containing only reels from Y. The reels of module Mi
                                  then are available offline, so that a new module can be constructed for job Jk
                                  (while job Jy
                                  is being processed) (see Fig. 3
                                 ). The transition back to job Ja
                                  is similar, a job Jy
                                  is inserted in-between in order to unload all reels that are required to construct an offline module for Ja
                                 .

In this instance of the Decision-MTS, the limit is set to L = 12n, and the reel switching cost is tc
                                  = 12n + 1. Similarly to the earlier reduction, it is clear that a 12n delay can be achieved if and only if there is a 3-Partition of the instance.□

The above reduction for the General MTS assumed that both the number of online modules and their capacity are arbitrary. In the MTS-F problem the number of online modules is fixed and the capacity of each module is arbitrary. Showing the complexity of MTS-F requires a different reduction, since in the earlier case the variable n of 3-Partition was mapped to the number of online carriages F.

In the case of MTS-F, a reduction from the Bin-Packing problem is used. Then the Bin-Packing problem is also known to be strongly NP-complete (Garey and Johnson, 1979). As before, the following reduction considers the unary representation of the values in Bin-Packing. Since the Bin-Packing problem is strongly NP-complete, it remains NP-Complete even in the case of unary representation of the problem.

Given a multi-set of numbers A = {a
                           1, a
                           2, …, an
                           } and a bin capacity V, find a minimum number of bins m and a partition of the numbers of A into the bins B
                           1, B
                           2, …, Bm
                            such that 
                              
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       
                                          B
                                          i
                                       
                                    
                                 
                                 ≤
                                 V
                              
                            for all 1 ≤ i ≤ m. The decision version of Bin-Packing (b-Bin-Packing) asks if it is possible to pack the given input A into b bins each of the capacity V.


                           
                              Lemma 2
                              Decision-MTS-F is NP-Complete, with at least one offline module and with or without extra component reels.

Clearly, the Decision-MTS-F is in NP. We will show that an arbitrary instance of the b-Bin-Packing problem can be reduced to the Decision-MTS-F problem. Given an instance of the b-Bin-Packing problem, construct the following Decision-MTS-F instance:

                                    
                                       •
                                       Set the reel switching cost to tc
                                           = 2n + 1 and the module switching cost tm
                                           = 1.

For each value ak
                                           of A, define a set of basic component types 
                                             
                                                
                                                   T
                                                   k
                                                
                                                =
                                                
                                                   {
                                                   
                                                      t
                                                      
                                                         k
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      t
                                                      
                                                         k
                                                         2
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      t
                                                      
                                                         k
                                                         
                                                            a
                                                            k
                                                         
                                                      
                                                   
                                                   }
                                                
                                                ,
                                             
                                           with |Tk
                                          | = ak
                                          .

Define an extra set of component types X, |X| = V (i.e. the capacity of a bin). These component types are different from the ones in the basic sets Tk
                                          .

Let the number of online modules F = b, and the capacity of a module C = V.

Let 
                                             
                                                S
                                                =
                                                
                                                   ∑
                                                   
                                                      k
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   a
                                                   k
                                                
                                             
                                          . Clearly S ≤ b · V, otherwise the b-Bin-Packing problem is not feasible.

Define another set of component types Z containing b · V − S different component types.

Component types of Z are used to complete the jobs so that they fully use the available online capacity.

Let Ja
                                           be a basic job requiring all the basic component types from all Tk
                                           sets and the component types from Z. Then, Ja
                                           requires exactly b · V capacity (see Fig. 4
                                          ).

Let Jk
                                           be an extra job containing the components 
                                             
                                                
                                                   (
                                                   
                                                      ∪
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      n
                                                   
                                                   
                                                      T
                                                      i
                                                   
                                                   )
                                                
                                                
                                                   ∖
                                                
                                                
                                                   T
                                                   k
                                                
                                                ,
                                             
                                           all components from Z, and wk
                                           component types from X. Job Jk
                                           also requires exactly b · V capacity.

There are a total of n basic component type sets Tk
                                           and each of them induces a different job Jk
                                          .

Create a job sequence of 2n + 1 jobs: Ja, J
                                          1, Ja, J
                                          2, Ja
                                          , …, Ja, Jn, Ja
                                          .

There are a total of 2n + 1 jobs in the sequence, each requiring exactly b · V component reel types.

Each consecutive pair of jobs differs by a number of wk
                                           component types, these reels must be switched between each job.

There are 2n transitions between the 2n + 1 jobs.

Since each transition must incur at least wk
                                           component reel changes, the optimal solution must have a minimum of one module switch incurring a cost of tm
                                           = 1 per transition.

Set L = 2n, that is the Decision-MTS-F will ask whether there is a module and component reel swapping policy with a delay no more than 2n.

All component reels have an extra copy available, so that offline modules can be prepared before the current job completes.

To show NP-Completeness, we show that a YES-instance of Decision-MTS-F translates into a YES-instance of b-Bin-Packing, and vice versa. The reduction is similar to that of the General MTS.

Clearly, in a YES-instance for Decision-MTS-F with L = 2n, there is exactly one module swapped between two consecutive jobs. This means that each reel set Tk
                                  was fully contained by one module.

A module Mi
                                  will contain the reel sets Tk
                                  that correspond to a bin assignment Bi
                                 . The extra reels of Z are used to fill the empty capacity of each module. If b online modules, each of capacity V, are sufficient to achieve one module swap per job transition (i.e. a reel sets Tk
                                  is fully contained in a module Mi
                                 ), then b bins are sufficient to pack all ak
                                  numbers of the Bin-Packing instance. Thus, for a YES-instance of Decision-MTS-F we have a YES-instance of Bin-Packing.

Suppose, that the answer to the b-Bin-Packing problem is YES. For each bin Bi
                                  containing numbers ak
                                 , assign the corresponding reel sets Tk
                                  to module Mi
                                 . Since the Bin-Packing instance fits into b bins, each reel set Tk
                                  can be placed into exactly one of the b online modules. Because a reel set is fully contained in one module, a single module swap is sufficient between each job Ja
                                  and Jk
                                 . This results in a total delay of 2n, implying a YES-instance for the Decision-MTS-F problem.

The reduction in the case of no extra component reel copies is handled in a similar way as in the case of General MTS. Let Y be an additional set of V component types, and Jy
                                  a job containing the V component types from Y. Job Jy
                                  is inserted after each Ja
                                  and Jk
                                  to allow the unloading of reels required to construct a module offline. Transitions between Jy
                                  and other jobs can be handled by exactly one module swap. In order to avoid extra cost, the swapped module must contain the changing reel set Tk
                                 .□

In the MTS-C problem, the capacity of a module C is fixed and the number of online modules F is arbitrary. For MTS-C we use a reduction from the Minimum Makespan Scheduling Problem, that is also known to be strongly NP-hard (Garey and Johnson, 1979).

In the Minimum Makespan Scheduling Problem (MMS) n jobs are given, each with an integer processing time pk
                           , and m identical machines. Find the assignment of the n jobs to the m machines so that the maximum completion time (also called makespan) is minimized.

The MMS problem is strongly NP-hard for arbitrary m. The decision version of the MMS problem (Decision-MMS) asks if there is a job/machine assignment so that the makespan is not larger than some fixed integer C. Decision-MMS is NP-complete for an arbitrary value of m.


                           
                              Lemma 3
                              Decision-MTS-C is NP-Complete, with at least one offline module and with or without extra component reels.

The proof of NP-Completeness of the Decision-MTS-C follows similar steps as the earlier reductions, the details are given in Appendix A.

In MTS-FC both the number of online modules F and their capacity C are fixed. We show that the problem can be solved optimally in polynomial time, albeit with a very large exponent. The polynomial-time algorithm follows similar ideas to those given by Crama et al. (2007), for the case of non-uniform tool sizes and single linear tool magazine, except that here we solve the problem by dynamic programming.

Consider all the possible component reel assignments to the online modules. A given assignment to F online modules may or may not be feasible. The assignments that are not feasible are not considered (incur ∞ cost). The transition between two module assignments can be calculated easily and efficiently by either swapping components or replacing modules if such modules can be constructed offline.

Let m = |∪
                           j ∈ [1…n]
                        Tj
                        | be the total number of different components used in the manufacturing of n jobs. Consider one extra dummy component type, which is used to fill unused slots in a module. Suppose that there is an arbitrary number of copies available of the dummy component. Thus, a module can be filled with m + 1 components in at most O((m + 1)
                           C
                        ) different ways (depending how many extra copies of each reel are available). With F online modules there are at most O((m + 1)
                           C · F
                        ) configurations for online components. An online configuration is feasible for a job j if all the required component types are present, and the number of component reel duplications do not exceed the available component reel copies.

Let D be the set of all the O((m + 1)
                           C · F
                        ) possible online configurations, and d, d′ ∈ D be two such configurations. Then, the transition function R(d, d′) calculates the delay incurred by changing from configuration d to d′. The function R can be efficiently calculated for a fixed online capacity F and C.

Given a number of n jobs, the delay for the minimum module/component reels swapping can be calculated by dynamic programming using the following recurrence relation:

The initial online magazine setup consists of loading no more than C · F component reels into the feeder unit:

                           
                              
                                 
                                    OPT
                                    
                                       (
                                       1
                                       ,
                                       
                                          d
                                          ′
                                       
                                       )
                                    
                                    ≤
                                    C
                                    ·
                                    F
                                    ·
                                    
                                       t
                                       c
                                    
                                 
                              
                           
                        For each d′ ∈ D that contains all the components for job j
                        
                           
                              
                                 
                                    OPT
                                    
                                       (
                                       j
                                       ,
                                       
                                          d
                                          ′
                                       
                                       )
                                    
                                    =
                                    m
                                    i
                                    
                                       n
                                       d
                                    
                                    
                                       {
                                       OPT
                                       
                                          (
                                          j
                                          −
                                          1
                                          ,
                                          d
                                          )
                                       
                                       +
                                       R
                                       
                                          (
                                          d
                                          ,
                                          
                                             d
                                             ′
                                          
                                          )
                                       
                                       }
                                    
                                 
                              
                           
                        and let

                           
                              
                                 
                                    OPT
                                    (
                                    j
                                    ,
                                    
                                       d
                                       ′
                                    
                                    )
                                    =
                                    ∞
                                 
                              
                           
                        if d′ ∈ D is not feasible for job j.

That is, the minimum delay of reaching job j with state d′ is the minimum of the sum of reaching job j − 1 with a state d and transitioning from state d to d′.

                           Lemma 4
                           The dynamic programming recurrence defined by 
                                 
                                    OPT
                                    (
                                    n
                                    ,
                                    d
                                    )
                                 
                               results in an optimal solution to the MTS-FC problem.

By induction, assume that 
                                 
                                    OPT
                                    (
                                    n
                                    −
                                    1
                                    ,
                                    d
                                    )
                                 
                               is the optimal value to reach job n − 1 with a feasible state d. Let d′ ∈ D be a feasible state for job n. Let us assume that this state can be reached by a delay Q, where 
                                 
                                    Q
                                    <
                                    OPT
                                    (
                                    n
                                    ,
                                    
                                       d
                                       ′
                                    
                                    )
                                 
                              .

Let d′′ ∈ D be the state used by job n − 1, in the solution that obtains delay Q. Then we have

                                 
                                    
                                       
                                          Q
                                          =
                                          OPT
                                          
                                             (
                                             n
                                             −
                                             1
                                             ,
                                             
                                                d
                                                
                                                   ′
                                                   ′
                                                
                                             
                                             )
                                          
                                          +
                                          R
                                          
                                             (
                                             
                                                d
                                                
                                                   ′
                                                   ′
                                                
                                             
                                             ,
                                             
                                                d
                                                ′
                                             
                                             )
                                          
                                          
                                             }
                                             <
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    
                                       
                                          
                                          m
                                          i
                                          
                                             n
                                             d
                                          
                                          
                                             {
                                             OPT
                                             
                                                (
                                                n
                                                −
                                                1
                                                ,
                                                d
                                                )
                                             
                                             +
                                             R
                                             
                                                (
                                                d
                                                ,
                                                
                                                   d
                                                   ′
                                                
                                                )
                                             
                                             }
                                          
                                       
                                    
                                 
                              since Q is optimal and R(d′′, d′) can be calculated efficiently. But this is a contradiction, since mind
                               minimizes over all possible configurations, thus 
                                 
                                    Q
                                    =
                                    OPT
                                    (
                                    n
                                    ,
                                    
                                       d
                                       ′
                                    
                                    )
                                 
                              .

That is, there is no solution that results in a smaller delay than the one given by the recurrence relation 
                                 
                                    OPT
                                    (
                                    n
                                    ,
                                    
                                       d
                                       ′
                                    
                                    )
                                 
                              .□

The above dynamic program calculates the minimum setup delay when manufacturing n jobs. The actual module configurations can be recovered, by recording at each step the choice made for d that achieves the minimum. The dynamic program will involve a table of size O(n · (m + 1)
                           F · C
                        ).

Although this is polynomial for a fixed F and C, in practice the values of m, F and C are large enough to make this approach prohibitive. It is typical in industrial cases that m ≥ 100, while F = 4 and C = 40. Making the DP table as large as 100160 per job.

@&#CONCLUSION@&#

This study considered the complexity of the modular tool switching problem. The problem arises in flexible manufacturing environment, especially in the case of component placement machines in PCB manufacturing, where multiple online and offline feeder modules are available for a single machine. It was shown that the modular tool switching problem is NP-hard in the general case, even for a fixed job sequence, unit loading cost and uniform tool sizes. The problem can be solved optimally in polynomial time if both the number of online feeder modules and the capacity of these modules are fixed.

In practical applications of the MTS problem, both the number of feeder modules and their capacity are constants. These are characteristics of the component placement machines. Nevertheless, the number of different component types and the total capacity of the online feeder modules make an exact solution prohibitive. Thus, heuristic approaches are necessary to find good feeder module arrangements and reel/module swapping decisions. Such heuristics are subject of active research in our group, and will be considered in future for publication.


                     
                        Proof
                        The reduction of Decision-MMS to Decision-MTS-C follows a similar logic to the earlier reductions. Here we must check that, for some fixed C, processing times pk
                            can be assigned to the machines so that each machine completes in no more that C time. Observe that this reduction relies on the fact that Minimum Makespan Scheduling is strongly NP-hard, and therefore its unary representation is still NP-complete.

Given an arbitrary instance I of the Decision-MMS problem, construct a Decision-MTS-C problem instance in the following way:

                              
                                 •
                                 Set the reel switching cost to tc
                                     = 2n + 1 and the module switching cost tm
                                     = 1.

For each processing time pk
                                     of I, define a set of basic component types 
                                       
                                          
                                             T
                                             k
                                          
                                          =
                                          
                                             {
                                             
                                                t
                                                
                                                   k
                                                   1
                                                
                                             
                                             ,
                                             
                                                t
                                                
                                                   k
                                                   2
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                t
                                                
                                                   k
                                                   
                                                      p
                                                      k
                                                   
                                                
                                             
                                             }
                                          
                                          ,
                                       
                                     |Tk
                                    | = pk
                                    . This transformation is linear when unary representation of the MMS problem is used (per the definition of strongly NP-complete).

Define an extra set of component types X, |X| = C. These component types are different from the ones in the basic sets Tk
                                    .

Let the number of online modules be the number of machines F = m, and the capacity of a module be C (the makespan of the Decision-MMS).

A machine of MMS corresponds to a module of MTS. Assigning jobs k in MMS to a machine corresponds assigning reels of the set Tk
                                     to a module.

Let 
                                       
                                          S
                                          =
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             n
                                          
                                          
                                             p
                                             k
                                          
                                       
                                    . Clearly, S ≤ m · C otherwise the problem is not feasible.

Define another set of component types Z containing n · C − S different component types.

If a machine (module) is not fully used to its capacity C, components of Z are used to fill the capacity requirement up to nC for each job of MTS.

The rest of the Decision-MTS-C instance is constructed in the same way as in the Bin-Packing reduction.

Clearly, as in the Bin-Packing reduction, a YES-instance of Decision-MTS-C can be achieved if and only if, each reel set Tk
                            is entirely contained in a single module. This is because only in such assignment it is possible to have a single module switched between two consecutive jobs. Each module may contain some extra components of Z, and the capacity of a module may not exceed C.

The reduction follows the same logic as earlier reductions. From a YES-instance of Decision-MTS-C we get an assignment of reel sets Tk
                            to modules Mi
                           , where each reel set is feasibly assigned to a single module. This corresponds to an assignment of job k in MMS to a single machine, where the machine capacity C is not exceeded.

Conversely, a YES-instance in MMS can easily be converted into a YES-instance of MTS-C, requiring only one module swap between two consecutive jobs, by assigning a reel set Tk
                            to a module Mi
                            following the job/machine assignments obtained in MMS.

As in the previous cases, the proof can also be extended to the case where no extra component reel copies are available. A job Jy
                            taking up only one module is inserted between each job Ja, Jk
                            and Jk, Ja
                           , forcing the content of the corresponding module offline, and making the necessary components available offline to construct a new module at no delay.□

@&#REFERENCES@&#

