@&#MAIN-TITLE@&#A region-growing algorithm using parallel computing for surface reconstruction from unorganized points

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We develop a region-growing algorithm based on parallel computation architecture.


                        
                        
                           
                           The old algorithm needs to be redesigned to fit the requirement of GPU architecture.


                        
                        
                           
                           Our algorithm can speed up the mesh reconstruction over 10 times.


                        
                        
                           
                           The proposed algorithm also have the same quality compared to original algorithm.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

GPU-based computation

Surface reconstruction

Region-growing algorithm

Candidate triangle table

Overlapping triangle removal

Filling small hole

@&#ABSTRACT@&#


               
               
                  A parallel computing region-growing algorithm for surface reconstruction from unorganized point clouds is proposed in this research. The traditional region-growing algorithm belongs to sequential process and needs to update the topology information continuously to maintain the boundaries of the growing region. This constraint becomes a bottleneck for efficiency improvement. The proposed GPU-based region-growing algorithm is to decompose the traditional sequence and re-plan specific framework for the purpose of utilizing parallel computation. Then, a graphics card with multi-processing units will be used to build triangles in the parallel computing mode. In our GPU-based reconstruction process, each sampling point is regarded as an independent seed and expands simultaneously until all surrounding patches overlap each other. Following this, the overlapping patches are removed and holes are filled by the GPU-based calculation. Finally, a complete model is created. In order to validate the algorithm proposed, the unorganized point cloud was obtained by a 3D scanner and then reconstructed using the parallel computing region-growing algorithm. According to the results obtained, the algorithm proposed here shows 10 times better performance when compared to the traditional region-growing method.
               
            

@&#INTRODUCTION@&#

Reverse engineering (RE) technology has become an important part of today’s industrial design process. The initial step is to first acquire the profile data using a 3D scanner. Following this, the surface can be constructed for the purpose of editing and design. Finally, the product can be manufactured using a CNC machine or a rapid prototyping machine.

Creating a geometric surface constructed from scanned point clouds is an integral part of the reverse engineering procedure, and can be classified into surface-based modeling and polygon-based modeling. The surface-based model has the advantages of high precision and continuity, but needs more complex calculation and cannot represent a free-form object with complex profiles. In contrast to surface-based model, polygon-based modeling can represent all kinds of objects due to its versatility. Mesh modeling is widely used in a number of fields, including: computer animation, virtual reality, digital heritage collections and medical applications.

After data acquisition, the point clouds must be transferred into a mesh object using a specific algorithm. For larger object sizes, greater amounts of scanned data can decrease the efficiency of model reconstruction. However, with the wide use of non-contacting 3D scanners by which dense point clouds are commonly acquired, the process often results in development bottlenecks due to long construction times.

Recently, the computing speed of Central Processing Units (CPUs) has not continued to improve significantly. Thus, the efficiency of the sequential mesh reconstruction algorithm has been difficult to improve. Fortunately, thanks to rapid development of Graphics Processing Units and programming language which supports parallel computing. The integration of parallel computing devices and algorithm architecture re-planning will be the key factors in improving efficiency when applying the algorithm.

This paper aims to develop a region-growing algorithm using parallel computing applied to mesh reconstruction. The efficiency of the conventional region-growing algorithm cannot be improved significantly due to the use of a single core CPU for sequential calculation. Here, the efficiency of traditional region-growing algorithm will be improved significantly by employing a parallel computing architecture.

@&#RELATED WORK@&#

Various algorithms for surface reconstruction had been proposed in related literature during recent decades. These algorithms are generally divided into three classes: Delaunay triangulation algorithms, implicit-function algorithms and region-growing algorithms.

Delaunay triangulation algorithms usually consist of two steps. The first is to compute Delaunay triangulation or Voronoi diagrams. Then, appropriate triangles are extracted as surface features [1,2]. Gopi et al. [3] proposed a Localized Delaunay triangulation (LDT) algorithm for application in surface reconstruction. Buchart et al. [4] and Kil and Amenta [5] proposed their GPU-based surface reconstruction algorithm based on the concept of LDT. In general, while the Delaunay triangulation algorithm can obtain better mesh quality, it involves more computing time and is sensitive to disturbance.

The process of implicit function algorithms is to construct a model surface with function approximation. Kazhdan et al. [6] proposed a method for constructing a 3D indicator function based on sampling data. They referenced the normal information and divided the space into internal and external spaces. Finally, the polygon could be extracted from the model surface. Zhou et al. [7] accelerated the performance of [6] by GPU-based calculations and used a marching cube algorithm to extract the polygon surface based on parallel computing architecture. The implicit function algorithm has the advantage of being robust against noise, but it is time-consuming while performing function calculations.

The region-growing algorithms first select a triangle as a seed and define a growing rule for triangle expansion. The front edges present the outermost boundary of the growth triangles. In the region growing process, the front edge continues to search for the appropriate point to form a triangular mesh until the model is complete. Kuo and Yau [8] proposed a surface reconstruction algorithm by integrating Delaunay triangulation and the region-growing process. Li et al. [9] presented a priority-driven approach which grows polygons based on curvature changes. Their region-growing algorithm can enhance reconstruction quality by considering the edge condition, and has the advantage of high efficiency performance. However, the surface quality in this case will be easily influenced by noise and by missing data.

The purpose of this research is to develop a surface reconstruction algorithm based on unorganized points. We propose a highly efficient GPU-based mesh reconstruction algorithm through the re-planning of algorithm architecture and application of a graphics card device. Fig. 1
                      shows the GPU-based region growing process proposed in this paper. First, k-dimensional tree is established on CPU. Then, the tree and points will be copied into the GPU memory. With the GPU parallel computation, the adjacent point table and the candidate triangle table can be established and stored on the GPU memory. Then, the GPU-based region growing algorithm proposed in this paper can be used to reconstruct the mesh quickly. Different from traditional methods, this algorithm expands the region of each sampling point according to the table of candidate triangle simultaneously. After the region growing process, a GPU-based sorting algorithm can be used to remove overlapping triangles. Finally, this algorithm will fill small holes to complete the model. All the triangle information will be copied back to the CPU memory for other geometric applications. In this paper, all the computations are executed on GPU except the k-d tree calculation. More detail description about this algorithm will be discussed in Section 4.

This section will clearly state the process of the GPU-based region growing algorithm. All of the processes are completed within the GPU device with the exception of k-d tree construction. The following section describes all the steps in detail.

To begin with, all neighbors of each sampling point have to be searched using the k-NN search algorithm proposed by [10]. His method first constructs a k-d tree structure based on CPU architecture. Next, the k-d tree can be transferred to the GPU memory. The GPU kernel can search the nearest k points of each sampling point with parallel computation simultaneously. Finally, searching results will be sequentially stored in the GPU memory as a candidate table.

The concept of the candidate table is to regard the connection of each sampling point and its nearest point as a front edge. The purpose is to calculate the candidate polygon of each front edge in advance. In this way, all sampling points can quickly access their candidate triangle with parallel computation. For each sampling point vM
                        , there are four parameters N, α
                        max, β
                        max and d need to be defined before the calculation of a candidate triangle. N is number of the nearest neighbor points around vM
                        ; α
                        max is the threshold angle of the candidate triangle. β
                        max is the upper bound value of the normal; and d is the distance from the middle point of the front edge to the reference point. These parameters are used to calculate the priority of each candidate triangle. The steps of priority calculation are described as follows:
                           
                              
                                 Step 1: Find the front edge of the sampling point vM
                                  from the candidate table. The connection between vM
                                  and its nearest point can be regarded as another front edge, as shown in Fig. 2
                                 a.


                                 Step 2: List all the referencing points around vM
                                 , as shown in Fig. 2b.


                                 Step 3: Select possible referencing points, as shown in Fig. 3
                                 , where t is the referencing point and 
                                    
                                       
                                          
                                             vr
                                          
                                          
                                             ¯
                                          
                                       
                                    
                                  is the front edge. The following two conditions must be satisfied:


                                 
                                    
                                       ∠
                                       trv
                                       <
                                       
                                          
                                             α
                                          
                                          
                                             max
                                          
                                       
                                    
                                  and 
                                    
                                       ∠
                                       tvr
                                       <
                                       
                                          
                                             α
                                          
                                          
                                             max
                                          
                                       
                                    
                                 .

The angle between the normal of sample point vM
                                  and the normal of Δvtr must be less than β
                                 max.


                                 Step 4: Use Eq. (1) to calculate priority Q for candidate triangle [9] when the reference point has been selected. The detail of Eq. (1) is shown in Fig. 4
                                 , where m is the middle point of the front edge 
                                    
                                       
                                          
                                             vr
                                          
                                          
                                             ¯
                                          
                                       
                                    
                                 , R is the search range, and π is the plane through point m and orthogonal to 
                                    
                                       
                                          
                                             vr
                                          
                                          
                                             ¯
                                          
                                       
                                    
                                 .


                        
                           
                              
                                 Step 5: The candidate triangles will be sorted according to the priority Q and saved in the GPU memory, as shown in Fig. 5
                                 .

In our GPU-based region-growing algorithm, each sampling point is treated as an individual seed in order to expand its region independently. The purpose is to facilitate the data distribution for GPU-based computation, and to effectively manage the memory. An umbrella structure is one of the important features of triangular mesh topology. Many related algorithms, such as mesh deformation or smoothness, are based on the umbrella characteristics. This study aims to construct a topological structure based upon unorganized points. Hence, the umbrella structure may be a good choice for constructing a complete model based on GPU parallel computing architecture.

The first step is to calculate the initial triangle of each sampling point. The method is described as follows: find the point nearest vc
                         of each sampling point from the table of k-NN, and connect them to form a front edge 
                           
                              
                                 
                                    
                                       
                                          v
                                       
                                       
                                          M
                                       
                                    
                                    
                                       
                                          v
                                       
                                       
                                          c
                                       
                                    
                                 
                                 
                                    ¯
                                 
                              
                           
                         as shown in Fig. 6
                        b. Then, vr
                         which has the highest priority will be selected from the candidate table and form an initial triangle, as shown in Fig. 6c. This triangle will be regarded as the initial triangle and is saved into the GPU memory.

For the umbrella expansion, the edge 
                           
                              
                                 
                                    
                                       
                                          v
                                       
                                       
                                          M
                                       
                                    
                                    
                                       
                                          v
                                       
                                       
                                          r
                                       
                                    
                                 
                                 
                                    ¯
                                 
                              
                           
                         of the initial triangle will be set as the next front edge, as shown in Fig. 7
                        a. The process described above is then repeated to get the second triangle from the candidate table, as shown in Fig. 7b. The most appropriate triangle is a new triangle which is also saved in the GPU memory. Next, the front edge and the new vertex vr
                         will be updated, as shown in Fig. 7c. Fig. 7d expresses that the umbrella structure will continue to expand around vM
                        . Finally, the umbrella structure can be built, as shown in Fig. 7e.

The umbrella structure for each sampling point will be saved into the GPU memory. Fig. 8
                         shows the condition of the triangle index list.

Since our GPU-based region-growing algorithm will expand from every sampling point. A large number of overlapping triangles will be produced as expected, as shown in Fig. 9
                        . This section will demonstrate how to efficiently remove the overlapping triangles based on parallel computing architecture.

The end indexes of the triangles are listed in Fig. 10
                        a. The steps of removing overlapping triangles can be described as follows:
                           
                              
                                 Step 1: Sort the id 0 of each triangle Fig. 10b based on [11]; the results are shown in Fig. 10c.


                                 Step 2: For each id 0, sort id1 for each triangle, as shown in Fig. 10c.


                                 Step 3: Check if the index of the triangle is consistent or not. Remove duplicated indexes, as shown in Fig. 10d.

Filling small holes is the last step of the GPU-based surface reconstruction algorithm. The reason for the appearance of holes is that the growth of sampling points cannot be guaranteed to cover the model surface completely. Thus, holes will appear on those places which are not covered by an umbrella mask. Fortunately, since our GPU-based region-growing algorithm is based on the synchronous growth of each sampling point, most of the holes will belong to a single triangle, as shown in Fig. 11
                        . These holes will still be filled efficiently based on our parallel computing architecture.

In this study, we prefer to identify the location of the holes’ boundary with the interactive use of a candidate table and mesh information, instead of using conventional topology operation. This not only reduces the topology operation but also takes advantage of parallel computing to speed up computational efficiency. Our GPU-based hole filling operation is described as follows:
                           
                              
                                 Step 1: Define all the edges of existing polygons by referencing the candidate table and mesh information, as shown in Fig. 12
                                 a.


                                 Step 2: Re-check all the edges of the mesh if holes exist by referencing opposite edge conditions, as shown in Fig. 12b. If the opposite edge is empty and can be found on the candidate triangle table, the small hole will be formed by searching the candidate table shown in Fig. 12c. Finally, small holes can be filled by adding a single triangle, as shown in Fig. 12d.

This section presents the results of surface reconstruction achieved by applying our GPU-based region-growing algorithm. Since our models are digitized using a 3D scanner machine, an uneven distribution of points may result in a failed attempt at achieving surface reconstruction. In order to overcome this shortcoming, data re-sampling will be necessary before GPU-based surface reconstruction. The algorithm is implemented by C++ and the CUDA Toolkit 3.2, running in Windows XP environment. All tests are run on a PC with an Intel Core2 1.86GHz CPU, 2GB RAM, and an NVIDIA GeForce GTX460 GPU. The resulting models are shown in Fig. 13
                     .

A comparison of running times is shown in Table 1
                     . Compared with the conventional region-growing algorithm [9], the highest speedup is 13.2 times faster. The average speedup is 10 times, or an order faster the original algorithm.

The pie charts in Figs. 14 and 15
                     
                      depict the running time at differing stages during application of our GPU-based region-growing algorithm.

In conclusion, the time of building the k-NN table accounts for nearly half the total time; k neighbor points must be found around each sampling point and then sorted according to distance. The relationship between point number and efficiency is shown in Fig. 16
                     . As the point number increases, efficiency grows almost linearly in our GPU-based surface reconstruction. This comparison fully demonstrates the advantage of using parallel computing architecture as compared to the conventional region-growing algorithm.

For surface reconstruction, polygon quality is one of the important indicators for estimating algorithm performance. Table 2
                      presents a performance comparison of GPU-based and conventional region-growing algorithms. The results show that our algorithm has a small number of mesh interferences and holes. But, with respect to the triangle number and efficiency improvement, we think the disadvantage can be accepted.

Traditional region growing algorithm not only is a sequential process but also needs to update the topology information to maintain the boundaries of the growing region. In order to ensure the expansion is correct, the topology calculation of mesh is very important. However, the calculation process increases the difficulty of GPU memory operation and not suitable to the calculation of parallelization. In this paper, the region growing process of each sampling point is regarded as independent computing task and does not affect the calculation results of surrounding sampling points. Each thread will be responsible for one sampling point calculation until the computation is completed. Therefore, there is no core synchronization problem in our GPU-based region growing algorithm.

This paper redesigns the region-growing algorithm flowchart to fit the architecture requirement of GPU. With our algorithm structure, data can be simultaneously processed by a large number of parallel cores and avoid the issue of synchronization. Also, our algorithm can reduce the excessive memory operations to enhance the efficiency of parallel computing.

@&#CONCLUSION@&#

In this study we develop a parallel computing architecture for the region-growing algorithm applied to surface mesh reconstruction from unorganized point clouds. The GPU-based region-growing algorithm first applies a region-growing operation to each sampling point, removes the overlapping patches using a rapid-sorting method, and finally fills small holes in order to complete the model. Before reconstruction, the establishment of a candidate table is an important part of the GPU-based region-growing process. It is necessary for both region-growing and hole-filling operations to access the candidate table information in order to reconstruct an appropriate surface mesh. In other words, the candidate table mechanism simplifies the topological operation of the original region-growing method, and makes the parallel computing architecture of the region-growing algorithm possible.

The results have proven that efficiency can be significantly improved through a combination of algorithm re-planning and use of parallel computing architecture devices. However, the region-growing algorithm has the shortcomings of polygon interferences and incomplete mesh. In the future, we will focus on the development of stricter judgment mechanisms in order to avoid polygon collision and incomplete mesh, and also to enhance time performance. Furthermore, the uniform distribution of point clouds has an impact on the reconstruction quality of the region-growing algorithm. Data re-sampling is still necessary for the region-growing algorithm to be able to reconstruct smooth surfaces. Future work will focus on how to parallelize the re-sampling algorithm and how to integrate this with our GPU-based region-growing algorithm.

@&#REFERENCES@&#

