@&#MAIN-TITLE@&#Resource loading with time windows

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Resource loading decides the resource usage and timing of a portfolio of orders.


                        
                        
                           
                           Resource loading is relevant to tactical multi-project capacity planning.


                        
                        
                           
                           We define three fundamental variants of resource loading.


                        
                        
                           
                           We provide a detailed complexity analysis.


                        
                        
                           
                           We investigate the inclusion of a non-preemption constraint.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Resource loading

Complexity theory

Manpower planning

Preemption

@&#ABSTRACT@&#


               
               
                  Resource loading appears in many variants in tactical (mid-term) capacity planning in multi-project environments. It develops a rough sketch of the resource usage and timing of the work packages of a portfolio of orders. The orders need to be executed within a time horizon organized into periods, each of which has a known number of workers available. Each order has a time window during which it must be executed, as well as an upper and lower bound on the number of workers that can work on this order in a period. The duration of the order is not fixed beforehand, but depends on the number of workers (intensity) with which it is executed. In this article we define three fundamental variants of resource loading and study six special cases that are common to the three variants. We present algorithms for those cases that can be solved either in polynomial time or in pseudo-polynomial time. The remaining cases are proven to be np-complete in the strong sense, and we discuss the existence of approximation algorithms for some of these cases. Finally, we comment on the validity of our results when orders must be executed without preemption. Although inspired by a number of practical applications, this work focuses on the properties of the underlying generic combinatorial problems. Our findings contribute to a better understanding of these problems and may also serve as a reference work for authors looking to design efficient algorithms for similar problems.
               
            

@&#INTRODUCTION@&#

Many organizations adopt a project structure to cope with large and highly complex tasks. These tasks usually involve expertise from many different departments or teams, such as engineering, service providers, process and production planning, and various production departments (De Boer, 1998). Traditionally, research in the area of project planning has focused on planning isolated projects. Many companies, however, employ an organizational structure in which multiple projects are run in parallel, sharing the same limited resources. This corresponds with a so-called ‘matrix structure’: resources are associated with functional departments, but are assigned to different ongoing projects over time (Larson and Gobeli, 1989). Adler, Mandelbaum, Nguyen, and Schwerer (1995) point out that frequent conflicts of interest arise when more than one project requires the same resource at the same time. The global coordination of such multi-project organizations is the essence of multi-project management. An aggregate, combined project plan facilitates cross-project analysis and reporting (Kerzner, 1998), and offers a useful tool for management to ensure that the organization does not take on more projects than it can complete (cf. Wheelright and Clark, 1992). Speranza and Vercellis (1993) observe that, because of the multi-objective and dynamic nature of multi-project planning, a monolithic approach is inadequate for most practical applications. Instead, they suggest a decomposition into an operational and tactical planning phase. In the latter phase, which we refer to as resource loading, the distinct production operations are often aggregated into jobs representing whole production phases, and planning and scheduling decisions typically pertain to these so-called work packages 
                     (Alfieri, Tolio, and Urgo, 2011). While detailed production planning (scheduling) at the operational level has already been the subject of extensive research efforts for various industrial sectors, the work on mid-term capacity planning is rather limited. This paper contributes to a better understanding of the latter through a careful analysis of the underlying combinatorial optimization problem.

We are given a set of potential orders (henceforth, ‘jobs’) and a work roster for the planning horizon. The workforce capacity may change over time in function of the individual workers’ calendars and earlier capacity-allocation decisions. Each job has a release time and a deadline, which together make up the job’s time window, as well as a work content (equivalently referred to as workload), expressed in worker-periods. The essential difference between ‘classic’ planning and scheduling, on the one hand, and resource loading, on the other hand, is that the latter allows flexible resource utilization for the jobs to be performed, i.e. the workload can, to a certain extent, be spread over several periods in the planning horizon, and this in varying proportions. The duration of a job is therefore not fixed beforehand, but depends on the number of workers (intensity) with which the job is executed. Additionally, this intensity can change over time. A job can, for example, be started with two workers and completed with one, or vice versa. This model is of particular interest for tactical planning in equipment maintenance and in project-based make-to-order (MTO) and engineer-to-order (ETO) environments, where capacity utilization may strongly fluctuate over time and orders may vary significantly with respect to routings, material and tool requirements. Moreover, these attributes may not be fully known at the stage of order acceptance. In the classic product-process matrix of Hayes and Wheelright (1979), these environments belong to the same cell because they all deal with low-volume, low-standardization, one-of-a-kind products or assignments, with high variety. The available capacity is therefore flexibly planned in an aggregate fashion, relegating detailed scheduling decisions to the operational level. Throughout this text, we mainly refer to workers as the resource type being planned, but obviously the results obtained can also be directly applied to other renewable (i.e., non-consumable) resource types such as machines and other equipment.

As mentioned supra, resource loading is part of tactical capacity management, which seeks to develop a rough overview of the resource usage and timing of the work packages involved in a given portfolio of orders. Dependent on the application, this may entail due-date setting and accept/reject decisions for individual orders, as well as choices regarding overtime and subcontracting. One specific application pertains to the planning of aircraft line maintenance, the routine maintenance performed at airports between flight arrival and departure. Line maintenance takes place on the tarmac (not in a hangar); typical tasks include troubleshooting, minor repairs, systems servicing, and the removal or replacement of components such as batteries, filters and reflectors. For each flight, the maintenance must be performed between the scheduled time of arrival and the scheduled time of departure of the aircraft, and the expected maintenance workload is known (see Beliën, Demeulemeester, and Cardoen, 2012). A similar application has been described for maintenance procedures of civil helicopters by Masmoudi (2011), more precisely for the so-called Heavy Maintenance Visit (HMV). For individual helicopters, HMVs are of a very low frequency: on average they occur only once every 12 years. De Boer (1998) describes similar problems encountered at the Royal Netherlands Navy (RNN) Dockyard, in the context of maintenance and repair of national-defence marine equipment. As an application in MTO environments rather than service operations, we can mention a tactical production-planning problem in sheet-metal production. Each order here consists of one or more jobs that are related via chain-like precedence constraints, and each job visits one specific machine group (a preliminary study was done in a Master’s thesis by Smeulders, 2011). Other practical illustrations of resource loading are presented by Naber and Kolisch (2014).

We define three fundamental problem variants. We first consider the decision problem that verifies the existence of a feasible schedule that executes all orders with the workers available. Second, we study the scheduling problem of finding a feasible schedule that minimizes the number of additional worker-periods needed to execute all orders within the planning horizon. Finally, we look into the combined selection and scheduling problem of choosing a subset of orders that can be executed with the workers available while maximizing the total revenue. We identify six special cases that apply to each of these three related problems, and present algorithms for those cases that can be solved either in polynomial time or in pseudo-polynomial time. The remaining cases are shown to be np-complete in the strong sense, and we also discuss the existence of approximation algorithms for some of these cases. Finally, we comment on the validity of our results when orders must be executed without preemption: in practice, management often prefers a schedule in which jobs are not interrupted and resumed at a later time.

Although inspired by a number of practical applications, this work focuses on the properties of the underlying generic combinatorial problems. Our findings contribute to a better understanding of the structural properties of resource loading. In addition, they can serve as a reference work for authors looking to design efficient algorithms for similar problems: the proposed algorithms can be implemented as a subroutine within any framework for solving practical problems. Beliën et al. (2012), for instance, propose a two-level solution approach for the line maintenance problem at Sabena Technics, where at the higher level an enumeration of a number of shift planning options is performed, and at the lower level a resource loading instance (as defined in Section 2.1) is encountered for each of the enumerated options. If the instances to be solved at the lower level display some of the specific characteristics outlined in Section 2.4, or can without too much loss of practical validity be modified to match those characteristics, then substantial runtime savings can be achieved by solving the instances with a dedicated algorithm (such as those proposed in this text) rather than by means of a commercial mixed-integer programming (MIP) solver (which is used by Beliën et al.). More generally, for any practical application, the work in this article allows to assess which of the modeling assumptions will tilt the problem from easily solvable to intractable.

The remainder of this article is organized as follows. In Section 2.1, we give a formal definition of the three problem variants and review the relevant literature. In Section 3 the decision-problem variant is discussed, while the scheduling variant is analyzed in Section 4, and Section 5 focuses on resource loading with job selection. Finally, Section 6 presents conclusions and suggestions for future research.

We provide a formal problem statement in Section 2.1, followed by an illustrative example (Section 2.2). Section 2.3 briefly reviews the relevant literature, while in Section 2.4 the results obtained in the following sections are summarized.

We consider H consecutive time periods that constitute the planning horizon, where period t (t = 1, …, H) runs from time (instant) t − 1 to t (period 1, for instance, is the interval [0, 1]). For aircraft line maintenance, for instance, the planning horizon is typically 1 week: the same flights are to be serviced every week. In period t, ct
                         workers are available (this number can be derived from the work roster). We denote by N = {1, 2, …, n} the set of available jobs (orders), which can be executed by a single resource type (representing the workers) within the planning horizon. Each job j has a release time rj
                        , before which it cannot be started, and a deadline 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              ,
                           
                         which represents the ultimate completion time of the job. In other words, each job j is associated with a time window 
                           
                              [
                              
                                 r
                                 j
                              
                              ,
                              
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              ]
                           
                        . The work content (workload) of job j is denoted by pj
                        , and is expressed in worker-periods. Furthermore, each job j has a pre-specified minimum number of workers lb
                        
                           j
                         that must, and a maximum number ub
                        
                           j
                         that can be assigned, during each period in which it is scheduled 
                           
                              (
                              1
                              ≤
                              lb
                              
                                 
                                 j
                              
                              ≤
                              ub
                              
                                 
                                 j
                              
                              ≤
                              
                                 p
                                 j
                              
                              )
                           
                        . In aircraft maintenance, for example, the size of the aircraft and the specific nature of each task impose an upper bound on the number of workers that can work simultaneously, while (for safety reasons and effective coordination) there is also a minimum number of workers that should be present around the aircraft when maintenance is performed.

For each job j, we assume that 
                           
                              lb
                              
                                 
                                 j
                              
                              ≤
                              
                                 c
                                 t
                              
                           
                         for each period t during which j can be executed, and 
                           
                              ub
                              
                                 
                                 j
                              
                              ≤
                              max
                              {
                              
                                 c
                                 t
                              
                              :
                              
                              t
                              =
                              
                                 r
                                 j
                              
                              +
                              1
                              ,
                              …
                              ,
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              }
                           
                        . The decision problem rlp-decision answers the question whether it is possible to devise a schedule that executes all jobs within the time horizon while respecting the time windows as well as the bound and capacity constraints. By rlp-scheduling we refer to the problem of finding a schedule that executes all the jobs using a minimum number of extra worker-periods. In practice, this implies that, if needed, external workers will be hired on a per-period basis or part of the work is subcontracted. Note that by solving rlp-scheduling we can also infer the answer to rlp-decision. Finally, we consider that each job j also has a revenue Qj
                        , which is gained only when the job is completed, and depends on the nature of the job and the fee the client is willing to pay. The objective of the third problem, rlp-selection, is (1) to evaluate which jobs should be accepted in order to maximize total revenue and (2) to derive a feasible schedule that executes all the selected jobs within the time horizon using the workers available. Clearly, rlp-selection is also at least as hard as the problem rlp-decision, but no such obvious relationship exists between rlp-scheduling and rlp-selection.

A MIP formulation of these three problem variants uses the binary decision variables xjt
                         defined for j ∈ N and 
                           
                              t
                              ∈
                              {
                              
                                 r
                                 j
                              
                              +
                              1
                              ,
                              …
                              ,
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              }
                              ,
                           
                         with the interpretation that xjt
                         = 1 if and only if job j is executed in period t, and the integer variables 
                           
                              
                                 y
                                 
                                    j
                                    t
                                 
                              
                              ∈
                              
                                 {
                                 0
                                 ,
                                 lb
                                 
                                    
                                    j
                                 
                                 ,
                                 lb
                                 
                                    
                                    j
                                 
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 ub
                                 
                                    
                                    j
                                 
                                 }
                              
                           
                         (j ∈ N and 
                           
                              t
                              ∈
                              {
                              
                                 r
                                 j
                              
                              +
                              1
                              ,
                              …
                              ,
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              }
                           
                        ) representing the number of workers assigned to job j in period t. For rlp-scheduling we also use integer variables zt
                         (t = 1, …, H) to indicate the number of external workers hired in period t. Finally, problem rlp-selection also gives rise to binary variables sj
                         for j ∈ N, with sj
                         = 1 if and only if job j is selected. A formulation contains the following set of constraints, which says that each job (each selected job, for rlp-selection) should be executed completely between its release time and deadline.

                           
                              (1)
                              
                                 
                                    
                                       ∑
                                       
                                          t
                                          =
                                          
                                             r
                                             j
                                          
                                          +
                                          1
                                       
                                       
                                          
                                             d
                                             ¯
                                          
                                          j
                                       
                                    
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    =
                                    
                                       p
                                       j
                                    
                                    
                                       s
                                       j
                                    
                                    ,
                                    
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    .
                                 
                              
                           
                        For rlp-decision and rlp-scheduling, all the variables sj
                         in Eq. (1) take the value 1. The workload assigned to each period cannot exceed the number of workers available (including external workers), which translates into:

                           
                              (2)
                              
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    ≤
                                    
                                       c
                                       t
                                    
                                    +
                                    
                                       z
                                       t
                                    
                                    ,
                                    
                                    t
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    H
                                    .
                                 
                              
                           
                        For rlp-decision and rlp-selection, all the variables zt
                         in Eq. (2) are set at 0. Eq. (3) ensures that the number of workers assigned to each job in each period is either 0 or within the specified lower and upper bounds.

                           
                              (3)
                              
                                 
                                    lb
                                    
                                       
                                       j
                                    
                                    
                                    
                                    
                                       x
                                       
                                          j
                                          t
                                       
                                    
                                    ≤
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    ≤
                                    ub
                                    
                                       
                                       j
                                    
                                    
                                    
                                    
                                       x
                                       
                                          j
                                          t
                                       
                                    
                                    ,
                                    
                                    j
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    n
                                    ,
                                    
                                    t
                                    =
                                    
                                       r
                                       j
                                    
                                    +
                                    1
                                    ,
                                    …
                                    ,
                                    
                                       
                                          d
                                          ¯
                                       
                                       j
                                    
                                    .
                                 
                              
                           
                        The problem rlp-decision corresponds with deciding whether the domain defined by constraints (1)–(3), with all sj
                         = 1 and zt
                         = 0, is non-empty. Problem rlp-scheduling consists in optimizing the objective function (4) subject to constraints (1)–(3), with all sj
                         = 1.

                           
                              (4)
                              
                                 
                                    min
                                    
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       H
                                    
                                    
                                       z
                                       t
                                    
                                 
                              
                           
                        Finally, rlp-selection amounts to solving

                           
                              (5)
                              
                                 
                                    max
                                    
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       Q
                                       j
                                    
                                    
                                       s
                                       j
                                    
                                 
                              
                           
                        subject to constraints (1)–(3), with all zt
                         = 0.

A solution to rlp-decision, rlp-scheduling or rlp-selection is entirely determined by the matrix Y = (yjt
                        )
                           j, t
                         for j = 1, …, n and t = 1, …, H. We can deduce the value of the remaining variables as follows: xjt
                         = 1 if and only if yjt
                         > 0, sj
                         = 1 if and only if 
                           
                              
                                 ∑
                                 
                                    t
                                    =
                                    
                                       r
                                       j
                                    
                                    +
                                    1
                                 
                                 
                                    
                                       d
                                       ¯
                                    
                                    j
                                 
                              
                              
                                 y
                                 
                                    j
                                    t
                                 
                              
                              >
                              0
                              ,
                           
                         and 
                           
                              
                                 z
                                 t
                              
                              =
                              max
                              
                                 {
                                 0
                                 ,
                                 
                                 
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    y
                                    
                                       j
                                       t
                                    
                                 
                                 −
                                 
                                    c
                                    t
                                 
                                 }
                              
                           
                        . Throughout this paper, we denote a solution to rlp-decision, rlp-scheduling and rlp-selection by Y, and we resort to the variables X = (xjt
                        )
                           j, t
                        , S = (sj
                        )
                           j
                         and Z = (zt
                        )
                           t
                         only when necessary.

Next, we present our first result, which states that the integrality constraint on the variables yjt
                         in the MIP formulations can be relaxed if all the parameters are integers.

                           Proposition 1
                           If all parameters are integers, then any optimal solution to rlp-decision, rlp-scheduling or rlp-selection obtained using the MIP formulations without integrality constraint on yjt
                               can be transformed in polynomial time into an equivalent solution satisfying the restriction 
                                 
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       
                                          lb
                                          j
                                       
                                       ,
                                       
                                          lb
                                          j
                                       
                                       +
                                       1
                                       ,
                                       …
                                       ,
                                       
                                          ub
                                          j
                                       
                                       }
                                    
                                 
                               for all j ∈ N and t = 1, …, H.

We prove this result for the problem rlp-selection, the reasoning for rlp-decision and rlp-scheduling is analogous. Assume that all parameters are integers and let Y′ be an optimal solution to the MIP formulation for rlp-selection without integrality constraint (so yjt
                               ≥ 0 for j ∈ N and t = 1, …, H). Suppose that some components of Y′ are not integer. If there is a unique job j
                              0 ∈ {1, …, n} for which some 
                                 
                                    y
                                    
                                       
                                          j
                                          0
                                       
                                       t
                                    
                                    ′
                                 
                               are fractional, then we define an integral solution Y as follows. Let t
                              1 be the first period (smallest index) with 
                                 
                                    y
                                    
                                       
                                          j
                                          0
                                       
                                       
                                          t
                                          1
                                       
                                    
                                    ′
                                 
                               fractional; we build a new solution Y with integer yjt
                               for t ≤ t
                              1 and for all j by defining 
                                 
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    =
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                       ′
                                    
                                 
                               for j ∈ N∖{j
                              0} and t = 1, …, H; and 
                                 
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          t
                                       
                                    
                                    =
                                    
                                       ⌈
                                       
                                          y
                                          
                                             
                                                j
                                                0
                                             
                                             t
                                          
                                          ′
                                       
                                       ⌉
                                    
                                 
                               for t ≤ t
                              1 (here ⌈ · ⌉ is the symbol for the ceiling); the remaining 
                                 
                                    y
                                    
                                       
                                          j
                                          0
                                       
                                       t
                                    
                                 
                               with t > t
                              1 are adapted accordingly. More concretely, let t
                              2 > t
                              1 be the first period so that 
                                 
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          
                                             t
                                             1
                                          
                                       
                                    
                                    −
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          
                                             t
                                             1
                                          
                                       
                                       ′
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          t
                                          =
                                          
                                             t
                                             1
                                          
                                          +
                                          1
                                       
                                       
                                          t
                                          2
                                       
                                    
                                    
                                       (
                                       
                                          y
                                          
                                             
                                                j
                                                0
                                             
                                             t
                                          
                                          ′
                                       
                                       −
                                       
                                          ⌊
                                          
                                             y
                                             
                                                
                                                   j
                                                   0
                                                
                                                t
                                             
                                             ′
                                          
                                          ⌋
                                       
                                       )
                                    
                                 
                               (where ⌊ · ⌋ is the symbol for the floor), then 
                                 
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          t
                                       
                                    
                                    =
                                    
                                       ⌊
                                       
                                          y
                                          
                                             
                                                j
                                                0
                                             
                                             t
                                          
                                          ′
                                       
                                       ⌋
                                    
                                 
                               for t
                              1 < t < t
                              2; 
                                 
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          
                                             t
                                             2
                                          
                                       
                                    
                                    =
                                    
                                       ⌊
                                       
                                          y
                                          
                                             
                                                j
                                                0
                                             
                                             
                                                t
                                                2
                                             
                                          
                                          ′
                                       
                                       ⌋
                                    
                                    +
                                    
                                       [
                                       
                                          ∑
                                          
                                             t
                                             =
                                             
                                                t
                                                1
                                             
                                             +
                                             1
                                          
                                          
                                             t
                                             2
                                          
                                       
                                       
                                          (
                                          
                                             y
                                             
                                                
                                                   j
                                                   0
                                                
                                                t
                                             
                                             ′
                                          
                                          −
                                          
                                             ⌊
                                             
                                                y
                                                
                                                   
                                                      j
                                                      0
                                                   
                                                   t
                                                
                                                ′
                                             
                                             ⌋
                                          
                                          )
                                       
                                       −
                                       
                                          y
                                          
                                             
                                                j
                                                0
                                             
                                             
                                                t
                                                1
                                             
                                          
                                       
                                       +
                                       
                                          y
                                          
                                             
                                                j
                                                0
                                             
                                             
                                                t
                                                1
                                             
                                          
                                          ′
                                       
                                       ]
                                    
                                 
                               and 
                                 
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          t
                                       
                                    
                                    =
                                    
                                       y
                                       
                                          
                                             j
                                             0
                                          
                                          t
                                       
                                       ′
                                    
                                 
                               for t > t
                              2. By repeating this procedure at most H times, we arrive at a solution Y whose components are all integer. Furthermore, Y is a solution to rlp-selection that executes the same jobs as Y′, and hence Y and Y′ have the same objective value.

Now suppose that more than one job has fractional components. Without loss of generality, we assume that for each t = 1, …, H, either 
                                 
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                       ′
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       
                                          lb
                                          j
                                       
                                       ,
                                       
                                          lb
                                          j
                                       
                                       +
                                       1
                                       ,
                                       …
                                       ,
                                       
                                          ub
                                          j
                                       
                                       }
                                    
                                 
                               for all j ∈ N, or there are at least two jobs j
                              1 and j
                              2 that are executed with a fractional number of workers in that period. If this is not the case, we simply consider the equivalent solution where for that unique job, say j
                              1, we have replaced 
                                 
                                    y
                                    
                                       
                                          j
                                          1
                                       
                                       t
                                    
                                    ′
                                 
                               by 
                                 
                                    ⌈
                                    
                                       y
                                       
                                          
                                             j
                                             1
                                          
                                          t
                                       
                                       ′
                                    
                                    ⌉
                                    ,
                                 
                               and the execution of job j
                              1 in the subsequent periods is adapted as described above. Using a similar argument, we can assume that for each period t the quantity 
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                       ′
                                    
                                 
                               is integer.

Let Y′ be an optimal solution to the relaxation of the MIP formulation for rlp-selection satisfying the above restrictions. We build the following weighted complete bipartite graph G = (V
                              1∪V
                              2, E), where each node in V
                              1 corresponds with a job j having at least one period t where 
                                 
                                    y
                                    
                                       j
                                       t
                                    
                                    ′
                                 
                               is fractional and each node in V
                              2 corresponds with a period t with at least one job j with 
                                 
                                    y
                                    
                                       j
                                       t
                                    
                                    ′
                                 
                               fractional; we write V
                              1 = {j
                              1, j
                              2, …, jα
                              } and V
                              2 = {t
                              1, t
                              2, …, tβ
                              }, where α ≤ n and β ≤ H. Each node i ∈ V
                              1 is a source node with supply 
                                 
                                    
                                       ∑
                                       
                                          t
                                          =
                                          
                                             r
                                             i
                                          
                                          +
                                          1
                                       
                                       
                                          
                                             d
                                             ¯
                                          
                                          i
                                       
                                    
                                    
                                       {
                                       
                                          y
                                          
                                             i
                                             t
                                          
                                          ′
                                       
                                       −
                                       
                                          ⌊
                                          
                                             y
                                             
                                                i
                                                t
                                             
                                             ′
                                          
                                          ⌋
                                       
                                       }
                                    
                                    ,
                                 
                               and each node t ∈ V
                              2 is a sink node with demand 
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       {
                                       
                                          y
                                          
                                             j
                                             t
                                          
                                          ′
                                       
                                       −
                                       
                                          ⌊
                                          
                                             y
                                             
                                                j
                                                t
                                             
                                             ′
                                          
                                          ⌋
                                       
                                       }
                                    
                                 
                              . Finally, each arc (i, t) ∈ V
                              1 × V
                              2 has unit capacity, and zero cost if 
                                 
                                    
                                       y
                                       
                                          i
                                          t
                                       
                                       ′
                                    
                                    ≠
                                    
                                       ⌊
                                       
                                          y
                                          
                                             i
                                             t
                                          
                                          ′
                                       
                                       ⌋
                                    
                                 
                               and cost = M otherwise, where M is a large positive number. All the arc capacities are integer, so the Integrality Theorem (Ahuja, Magnanti, and Orlin, 1993) implies that there exists an optimal integer solution to the resulting capacitated network flow instance. Furthermore, since there is a fractional solution with cost 0, we infer that any optimal integer solution also has objective value 0. Let 
                                 
                                    A
                                    =
                                    
                                       
                                          (
                                          
                                             a
                                             
                                                
                                                   j
                                                   k
                                                
                                                
                                                   t
                                                   ℓ
                                                
                                             
                                          
                                          )
                                       
                                       
                                          k
                                          ,
                                          ℓ
                                       
                                    
                                    ,
                                 
                               for k = 1, …, α and ℓ = 1, …, β, be such an optimal integer solution, which can obtained in polynomial time (Ahuja et al., 1993). We consider the matrix Y defined as follows: for (j, t)∉V
                              1 × V
                              2 we have 
                                 
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    =
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                       ′
                                    
                                 
                               and for (j, t) ∈ V
                              1 × V
                              2 we set 
                                 
                                    
                                       y
                                       
                                          j
                                          t
                                       
                                    
                                    =
                                    
                                       ⌊
                                       
                                          y
                                          
                                             j
                                             t
                                          
                                          ′
                                       
                                       ⌋
                                    
                                    +
                                    
                                       a
                                       
                                          j
                                          t
                                       
                                    
                                 
                              . Matrix Y is an integer solution to rlp-selection that executes the same jobs as Y′; therefore Y and Y′ have the same objective value.


                              □

We close this section with additional definitions. We say that a job j ∈ N is splittable if and only if 
                           
                              2
                              
                              
                                 lb
                                 j
                              
                              ≤
                              
                                 p
                                 j
                              
                           
                         and 
                           
                              
                                 r
                                 j
                              
                              +
                              1
                              <
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              ,
                           
                         which are two necessary conditions for a job to be executable over more than one period. Note that in an optimal schedule a splittable job need not be executed in multiple periods. A job j ∈ N is said to be executed without preemption if and only if it is executed in consecutive periods, meaning that all periods with yjt
                         ≥ 1 are consecutive, for all j ∈ N. When 
                           
                              
                                 lb
                                 j
                              
                              ≥
                              1
                           
                         for j = 1, …, n, Proposition 1 remains valid even if each job must be executed without preemption. In Section 2.4 we will conclude that cases where 
                           
                              
                                 lb
                                 j
                              
                              =
                              0
                           
                         can be replaced by 
                           
                              
                                 lb
                                 j
                              
                              =
                              1
                              ,
                           
                         so the result holds regardless of the values of the lower bounds.

We now present a small example to illustrate the foregoing definitions. We consider a planning horizon with H = 10 weeks, with capacities (c
                        1, c
                        2, …, cH
                        ) = (2, 3, 3, 5, 7, 9, 8, 8, 10, 9). Observe that the available capacity is lower especially in the first weeks of the planning horizon. As noted by Hans (2001), this typically occurs in practice when capacity is reserved for (scheduled) orders that are already on the shop floor, and that may not be shifted in time. The remaining data are gathered in Table 1
                        .

An optimal solution to the corresponding instance of rlp-scheduling is graphically depicted in Fig. 1
                        (a). The thick black curve represents the available regular capacity; the minimum required number of external workers is 13. The answer to the associated rlp-decision instance is therefore No. Fig. 1(b) represents an optimal solution to the rlp-selection instance with the same parameters; the maximum total revenue is 61, which is achieved by selecting all jobs except job 8.

@&#LITERATURE REVIEW@&#

This paper models tactical capacity planning in equipment maintenance, MTO and ETO. To date, few studies have dealt with similar problems. The articles most related to our work focus on tactical planning and use a “bucketized” time horizon (each period is a “bucket”). This includes Hans (2001) and Mestry, Damodaran, and Chen (2011), which both develop a branch-and-price algorithm. Variants of our problem are studied by Wullink, Gademann, Hans, and van Harten (2004), whose main contribution is the incorporation of uncertainty, Gademann and Schutten (2005), who propose linear-programming-based heuristics, and Alfieri et al. (2011), who study the inclusion of “feeding” precedence constraints, which allow some overlap in the execution of precedence-related activities. The use of a discrete time horizon is quite common in medium-term production planning for make-to-stock environments, but the underlying models are quite different in other respects (they generally formalize lot-sizing decisions; see, for instance, Pochet and Wolsey, 2006). In lot-sizing terminology, we work with “big buckets” rather than “small buckets,” because more than one job can be scheduled in the same bucket (see Suerie and Stadtler, 2003). In our model, we will decide which proportion of the workload of each job should be performed during each time period.

In the operational planning literature, models quite similar to our planning of work packages have been studied under the title of project scheduling with “variable-intensity” or “continuously divisible” activities or “flexible resource profiles”; examples are Fündeling and Trautmann (2010); Kogan and Shtub (1999); Leachman (1983); Leachman, Dincerler, and Kim (1990); Naber and Kolisch (2014). The first three papers only describe heuristic algorithms, while Kogan and Shtub (1999) provide a characterization of optimal solutions and preliminary computational results, and Naber and Kolisch (2014) compare a number of MIP formulations by means of a commercial solver. Another recent contribution to this field of literature is Kis (2005), who reports computational results for benchmark data sets based on a branch-and-cut algorithm. An early study, which considers a continuous time horizon, is Weglarz (1981).

A different line of literature adheres more closely to operational machine scheduling, such as Kim, Shim, Kim, Choi, and Yoon (2004); Sadykov (2012); Serafini (1996); Xing and Zhang (2000). The references Günther, König, and Megow (2014); Hendel, Kubiak, and Trystram (2014); Jansen (2004); Jansen and Porkolab (2002); Mounié, Rapine, and Trystram (2007) investigate the problem of scheduling “malleable jobs,” whereas Baptiste, Le Pape, and Nuijten (1999) focus on the “fully elastic cumulative scheduling problem,” with an equivalent solution space. The models studied in the above references differ from the resource loading variants examined in this paper in the sense that, to the best of our knowledge, none of the theoretical work cited has considered time windows, lower and upper bounds, or job selection, apart from Baptiste et al. (1999), which does consider time windows and contains a result that corresponds to our Lemma 2. Finally, in Section 5.5 of his recent handbook, Drozdowski (2009) provides a very thorough summary of parallel-machine scheduling with malleable jobs, with some isolated results in multiprocessor scheduling where upper bounds or ready times are also considered. The problem statement, however, never fully coincides with ours.

In today’s competitive manufacturing environment, organizations commit to meeting the order deadlines agreed with customers. However, order acceptance often takes place without considering the effect on the planning of other jobs in the order portfolio. As pointed out by Herbots, Herroelen, and Leus (2007) and Guerrero and Kern (1998), an integration of job selection and planning within a firm is essential to avoid conflicts of interest between the sales department, which tends to accept as many jobs as possible, and the production department, which attempts to meet the delivery dates promised to clients.

This integration of order acceptance decisions has already been investigated within the domain of tactical job-shop planning; for some recent work, see Ebben, Hans, and Olde Weghuis (2005); Slotnick and Morton (2007). Extensive literature surveys on the topic of order acceptance and scheduling are provided by  (Keskinocak and Tayur, 2004, Chap. 12); Roundy et al. (2005); Slotnick (2011) and Talla Nobibon and Leus (2011). In a more classic scheduling context, the goal of “maximum-throughput scheduling” is to find a non-preemptive schedule that maximizes the weight of the jobs for which the deadline can be met (see, for instance, Bar-Noy, Guha, Naor, and Schieber, 2001; Engels et al., 2003). In the standard notation for scheduling problems, this boils down to variants of P|ri
                           |∑(1 − Ui
                           ), a topic which goes back as early as Moore (1968).

Each of the problems rlp-decision, rlp-scheduling and rlp-selection are considered separately in Sections 3, 4 and 5, respectively. In each section, we focus on the following specific cases: (1) no time windows and no bound constraints, (2) no bound constraints, (3) no lower bounds, (4) no upper bounds, (5) only one job, and finally (6) exactly two jobs. In this context, the ‘no time windows’ case corresponds with having the same time window [0, H] for each job; ‘no upper bound’ equates with 
                           
                              
                                 ub
                                 j
                              
                              =
                              
                                 p
                                 j
                              
                              ,
                           
                         and ‘no lower bound’ means that 
                           
                              
                                 lb
                                 j
                              
                              =
                              0
                              ,
                           
                         which is equivalent with 
                           
                              
                                 lb
                                 j
                              
                              =
                              1
                           
                         because the yjt
                        -values are integers and the lower bound only applies to periods t where yjt
                         > 0. The cases with one and two jobs are interesting because they may be encountered as subproblems when solving problems with higher n. Our algorithm for the decision problem with one job, for instance, is also called as a subroutine to decide the case with two jobs (see Appendices Appendix B and Appendix C). The results of our analysis are summarized in Table 2
                        . Unless otherwise mentioned, in cases (1)–(4) the parameter H is considered to be constant, since typically n > H, whereas for cases (5) and (6) we have either one or two jobs, so H is then regarded as input.

We address the problem rlp-decision and study the six special cases presented in the previous section. For ease of exposition, we alternatively consider each job j ∈ N as consisting of pj joblets, where a joblet corresponds with the work performed by one worker in one period. Similarly, the available capacity in period t can be divided into ct
                      units, where each unit equates with one worker.

All jobs have the same time window [0, H] and any number of available workers can be assigned to any job. We observe the following:

                           Lemma 1
                           A given instance of rlp-decision with the above restrictions is a yes instance if and only if 
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       p
                                       j
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       H
                                    
                                    
                                       c
                                       t
                                    
                                 
                              .

The proofs of all the lemmas are included in Appendix A. Lemma 1 remains valid even if each job must be executed without preemption.

We now assume that jobs can have different time windows but there are no bound constraints. Therefore, the resulting problem is a generalization of the problem defined in Section 3.1. We propose Algorithm 1
                         to solve rlp-decision when there are no bound constraints.


                        Algorithm 1 is a modification of the earliest due-date rule (Pinedo, 2008), allowing a fraction of a job to be scheduled in one period, if necessary.

                           Lemma 2
                           
                              Algorithm 1 solves rlp-decision without bound constraints in time O(nlog n).


                        Baptiste et al. (1999) obtain a comparable result based on a different reasoning. Algorithm 1 does not guarantee the execution of jobs without preemption, as illustrated by the following example. Consider an instance of rlp-decision without bound constraints consisting of two jobs that must be executed in five periods (H = 5), each with capacity ct
                         = 5 workers (for t = 1, …, 5). Job 1 has r
                        1 = 0, 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 1
                              
                              =
                              5
                           
                         and p
                        1 = 17, and job 2 is characterized by r
                        2 = 1, 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 2
                              
                              =
                              3
                           
                         and p
                        2 = 8. Algorithm 1 schedules job 2 in periods 2–3, with five and three workers respectively, and executes job 1 in periods 1,  3,  4 and  5, with five, two, five and five workers, respectively. Job 1 is preempted because it is executed in periods 1 and 3 but not in period 2. A schedule that executes both jobs without preemption, however, does exist: it executes job 2 in periods 2–3 with four workers in each period.

The next result shows that it is unlikely that there exists a polynomial-time algorithm to solve rlp-decision without bound constraints when each job must be executed without preemption. In fact, we show that if preemption is not allowed, then the problem is np-complete in the strong sense. We prove this result using a reduction from sequencing with release times and deadlines, which is np-complete in the strong sense (Garey and Johnson, 1979, p. 236). The latter problem is defined as follows:


                        sequencing with release times and deadlines
                        
                           
                              
                                 Instance: Set T of tasks and for each task t ∈ T, a length 
                                    
                                       ℓ
                                       
                                          (
                                          t
                                          )
                                       
                                       ∈
                                       
                                          Z
                                          +
                                       
                                       ,
                                    
                                  a release time 
                                    
                                       r
                                       
                                          (
                                          t
                                          )
                                       
                                       ∈
                                       
                                          Z
                                          0
                                          +
                                       
                                       ,
                                    
                                  and a deadline 
                                    
                                       d
                                       
                                          (
                                          t
                                          )
                                       
                                       ∈
                                       
                                          Z
                                          +
                                       
                                    
                                 .


                                 Question: Is there a one-processor schedule for T that satisfies the release-time constraints and meets all deadlines, i.e. a one-to-one function 
                                    
                                       σ
                                       :
                                       T
                                       →
                                       
                                          Z
                                          0
                                          +
                                       
                                       ,
                                    
                                  with σ(t) > σ(t′) implying σ(t) ≥ σ(t′) + ℓ(t′), such that, for all tasks t ∈ T, σ(t) ≥ r(t) and σ(t) + ℓ(t) ≤ d(t)?

We obtain the following complexity result.

                           Lemma 3
                           The problem rlp-decision without bound constraints where each job must be executed without preemption is np-complete in the strong sense.

The execution of each job is constrained only by its time window and the upper bound. Algorithm 1 can be modified to address this situation as well, if in line 3 the capacity of each period t is filled with 
                           
                              min
                              {
                              
                                 ub
                                 
                                    π
                                    [
                                    j
                                    ]
                                 
                              
                              ,
                              
                                 p
                                 
                                    π
                                    [
                                    j
                                    ]
                                 
                              
                              ,
                              
                                 c
                                 t
                              
                              }
                           
                         before moving to the next period.

Again, the resulting solution does not necessarily schedule jobs without preemption. When the latter restriction is imposed, the proof of Lemma 3 remains valid in order to show that rlp-decision without lower bounds and without preemption is np-complete. We formalize this result in the next lemma.

                           Lemma 4
                           The problem rlp-decision without lower bounds where each job must be executed without preemption is np-complete in the strong sense.

This is the case when there are no upper-bound restrictions (only the available number of workers in each period). The problem rlp-decision with no upper bounds is a special case of the maximum flow problem with minimum quantities (Haugland, Eleyat, and Hetland, 2011; Thielen and Westphal, 2013) because the associated network is bipartite. As a consequence, any positive result for the latter problem remains valid, but the negative results do not necessarily apply to rlp-decision without upper bounds.


                        rlp-decision without upper bounds can be solved using Lemma 1 if it consists of a single period. The next result states that the problem becomes np-complete as soon as there are at least two periods. The proof uses a reduction from the following variant of partition, which easily reduces from the variant shown to be np-complete by Garey and Johnson (1979).


                        partition
                        
                           
                              
                                 Instance: A set A with 2m elements, and a size 
                                    
                                       s
                                       
                                          (
                                          a
                                          )
                                       
                                       ∈
                                       
                                          Z
                                          +
                                       
                                    
                                  with s(a) > 2 for each a ∈ A such that ∑
                                    a ∈ A
                                 
                                 s(a) = 2B.


                                 Question: Can A be partitioned into two disjoint sets A
                                 1 and A
                                 2 such that |A
                                 1| = |A
                                 2| = m, and 
                                    
                                       
                                          ∑
                                          
                                             a
                                             ∈
                                             
                                                A
                                                1
                                             
                                          
                                       
                                       s
                                       
                                          (
                                          a
                                          )
                                       
                                       =
                                       B
                                    
                                 ?

The problem rlp-decision with no upper bounds is np-complete, even if there are two periods and all jobs are splittable.


                        Lemma 5 indicates that rlp-decision with no upper bounds is at least np-complete in the ordinary sense, leaving open the possibility that the problem is even harder, for example np-complete in the strong sense. Below, we present a pseudo-polynomial-time algorithm to solve the problem when there are exactly two periods, and we show that the problem effectively becomes np-complete in the strong sense when the number of periods is free.

Consider rlp-decision with two periods and no upper bounds. If ∑
                           j ∈ N
                        
                        pj
                         > c
                        1 + c
                        2, then the answer is no; otherwise we can call the following dynamic programming (DP) algorithm to obtain a decision. Without loss of generality, we assume that rj
                         = 0 and 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              =
                              2
                           
                         for each job j ∈ N. For ease of exposition, we add a dummy job 0 with r
                        0 = 0, 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 0
                              
                              =
                              2
                           
                         and p
                        0 = 0. We use the following (Boolean) DP function:

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                k
                                             
                                             
                                                (
                                                
                                                   α
                                                   1
                                                
                                                ,
                                                
                                                   α
                                                   2
                                                
                                                )
                                             
                                             ≡
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            1
                                                            ,
                                                         
                                                      
                                                      
                                                         
                                                            
                                                            if
                                                            
                                                            jobs
                                                            
                                                            0
                                                            ,
                                                            1
                                                            ,
                                                            …
                                                            ,
                                                            k
                                                            ,
                                                            
                                                            can
                                                            
                                                            be
                                                            
                                                            executed
                                                            
                                                            with
                                                            
                                                            
                                                               α
                                                               t
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      
                                                      
                                                         
                                                            
                                                            
                                                            workers
                                                            
                                                            in
                                                            
                                                            period
                                                            
                                                            t
                                                            
                                                            (
                                                            t
                                                            =
                                                            1
                                                            ,
                                                            2
                                                            )
                                                            ,
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            0
                                                            ,
                                                         
                                                      
                                                      
                                                         
                                                            
                                                            otherwise
                                                            .
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The initial condition of the recursion is given by F
                        0(α
                        1, α
                        2) = 1 for all α
                        1 ∈ {0, 1, …, c
                        1} and α
                        2 ∈ {0, 1, …, c
                        2}, and by Fk
                        (α
                        1, α
                        2) = 0 whenever α
                        1 < 0 or α
                        2 < 0, for k = 0, 1, 2, …, n. The recursive relation is

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                k
                                             
                                             
                                                (
                                                
                                                   α
                                                   1
                                                
                                                ,
                                                
                                                   α
                                                   2
                                                
                                                )
                                             
                                             =
                                             max
                                             
                                                {
                                                
                                                   F
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   (
                                                   
                                                      α
                                                      1
                                                   
                                                   −
                                                   ℓ
                                                   ,
                                                   
                                                      α
                                                      2
                                                   
                                                   +
                                                   ℓ
                                                   −
                                                   
                                                      p
                                                      k
                                                   
                                                   )
                                                
                                                :
                                                ℓ
                                                ∈
                                                
                                                   Δ
                                                   k
                                                
                                                }
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 Δ
                                 k
                              
                              =
                              
                                 {
                                 0
                                 ,
                                 
                                    p
                                    k
                                 
                                 }
                              
                              ∪
                              
                                 (
                                 N
                                 ∩
                                 
                                    [
                                    
                                       lb
                                       k
                                    
                                    ,
                                    
                                       p
                                       k
                                    
                                    −
                                    
                                       lb
                                       k
                                    
                                    ]
                                 
                                 )
                              
                           
                        . If job k is not splittable, then the second part of the union is empty, and the job will be executed either exclusively in period 1 or exclusively in period 2. Splittable jobs may also be executed in both periods, dependent on the remaining capacity. The solution to rlp-decision with two periods and without upper bounds is obtained by verifying the value of Fn
                        (c
                        1, c
                        2): if Fn
                        (c
                        1, c
                        2) = 1, then we have a yes instance; otherwise we have a no instance.

The time complexity of the foregoing DP algorithm is O(nC
                        2
                        P), where C = max {c
                        1, c
                        2} and P = max {p
                        1, …, pn
                        }. This can be seen as follows. We need to compute O(n · C · C) values, namely one for each combination of k, α
                        1 and α
                        2. For each of these O(nC
                        2) values, the maximum operator pertains to |Δk
                        | possibilities, with |Δk
                        | = O(P) (because all values in Δk
                         are in [0, pk
                        ]). Therefore, rlp-decision with two periods can be solved in pseudo-polynomial time. This DP recursion can be generalized for any constant H: the total number of partitions (ℓ1, ℓ2, …, ℓ
                           H
                        ) of pk
                        , with 
                           
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 H
                              
                              
                                 ℓ
                                 i
                              
                              =
                              
                                 p
                                 k
                              
                              ,
                           
                         is then constant in the number of jobs (it is upper-bounded by O(PH
                        )), hence the resulting algorithm will still run in pseudo-polynomial time.

When the number of periods is free (H is part of the input), we show that rlp-decision without upper bounds is np-complete in the strong sense. The proof uses a reduction from 3-partition, which is defined as follows (Garey and Johnson, 1979):

3-partition
                        
                           
                              
                                 Instance: A set A of 3m elements, a bound 
                                    
                                       B
                                       ∈
                                       
                                          Z
                                          +
                                       
                                       ,
                                    
                                  and a size 
                                    
                                       s
                                       
                                          (
                                          a
                                          )
                                       
                                       ∈
                                       
                                          Z
                                          +
                                       
                                    
                                  for each a ∈ A such that 
                                    
                                       
                                          B
                                          4
                                       
                                       <
                                       s
                                       
                                          (
                                          a
                                          )
                                       
                                       <
                                       
                                          B
                                          2
                                       
                                    
                                  and ∑
                                    a ∈ A
                                 
                                 s(a) = mB.


                                 Question: Can A be partitioned into m disjoint sets A
                                 1, A
                                 2, ..., Am
                                  in such a way that, for 1 ≤ i ≤ m, 
                                    
                                       
                                          ∑
                                          
                                             a
                                             ∈
                                             
                                                A
                                                i
                                             
                                          
                                       
                                       s
                                       
                                          (
                                          a
                                          )
                                       
                                       =
                                       B
                                    
                                 .

The problem rlp-decision with no upper bounds is np-complete in the strong sense, even if all jobs are splittable.

We close this section by making the following two observations. First, all the results presented in this section remain valid when all jobs have the same time window. Second, the DP algorithm developed for instances with two (or more, but a constant number of) periods, as well as Lemma 5, remain valid even if each job must be executed without preemption. The negative result in Lemma 3 also directly transfers, which leads us to the conclusion that rlp-decision without upper bounds is np-complete in the strong sense even if each job must be executed without preemption.

We present Algorithm 2
                         to solve rlp-decision with a single job. In the description we omit the subscript referring to the job. Without loss of generality, we assume that the release date is r = 0 and the deadline 
                           
                              
                                 d
                                 ¯
                              
                              =
                              H
                           
                        .

                           Lemma 7
                           
                              Algorithm 2 solves rlp-decision with a single job in time O(Hlog H).

In Appendix B, we present a modified version of Algorithm 2 that solves rlp-decision with a single job to be executed without preemption in time O(H).

We establish the following complexity result for instances of rlp-decision that consist of two jobs.

                           Lemma 8
                           
                              rlp-decision with two jobs is np-complete, even if the two jobs are identical.

The result of Lemma 8 also leaves open the possibility that the problem is np-complete in the strong sense. We discard this option by presenting a pseudo-polynomial-time DP algorithm to solve instances of rlp-decision that consist of two jobs. Note that Algorithm 2 can be used for each job individually to identify possible no instances. For ease of exposition, we present a DP algorithm for cases where the two jobs have the same time window. We define the Boolean value function

                           
                              
                                 
                                    
                                       F
                                       t
                                    
                                    
                                       (
                                       
                                          β
                                          1
                                       
                                       ,
                                       
                                          β
                                          2
                                       
                                       )
                                    
                                    ≡
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   1
                                                   ,
                                                   
                                                   if
                                                   
                                                   a
                                                   
                                                   schedule
                                                   
                                                   exists
                                                   
                                                   that
                                                   
                                                   assigns
                                                   
                                                   an
                                                   
                                                   exact
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                   
                                                   total
                                                   
                                                   of
                                                   
                                                   
                                                      β
                                                      i
                                                   
                                                   
                                                   workers
                                                   
                                                   to
                                                   
                                                   job
                                                   
                                                   i
                                                   
                                                   (
                                                   
                                                      i
                                                      =
                                                      1
                                                      ,
                                                      2
                                                   
                                                   )
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                   
                                                   during
                                                   
                                                   periods
                                                   
                                                   
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      t
                                                   
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   
                                                   otherwise
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The initial condition is F
                        1(β
                        1, β
                        2) = 1 if β
                        1 + β
                        2 ≤ c
                        1 and 
                           
                              
                                 β
                                 j
                              
                              ∈
                              
                                 {
                                 0
                                 ,
                                 lb
                                 
                                    
                                    j
                                 
                                 ,
                                 lb
                                 
                                    
                                    j
                                 
                                 +
                                 1
                                 ,
                                 …
                                 ,
                                 ub
                                 
                                    
                                    j
                                 
                                 }
                              
                           
                         for j = 1, 2; otherwise F
                        1(β
                        1, β
                        2) = 0. The recursive relation is

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                t
                                             
                                             
                                                (
                                                
                                                   β
                                                   1
                                                
                                                ,
                                                
                                                   β
                                                   2
                                                
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             max
                                             {
                                             
                                                F
                                                
                                                   t
                                                   −
                                                   1
                                                
                                             
                                             
                                                (
                                                
                                                   β
                                                   1
                                                
                                                −
                                                
                                                   ℓ
                                                   1
                                                
                                                ,
                                                
                                                   β
                                                   2
                                                
                                                −
                                                
                                                   ℓ
                                                   2
                                                
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             :
                                             
                                                ℓ
                                                j
                                             
                                             
                                                ∈
                                                
                                                   {
                                                   0
                                                   ,
                                                   lb
                                                   
                                                      
                                                      j
                                                   
                                                   ,
                                                   lb
                                                   
                                                      
                                                      j
                                                   
                                                   +
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   ub
                                                   
                                                      
                                                      j
                                                   
                                                   }
                                                
                                                ,
                                                
                                                for
                                                
                                                
                                                   j
                                                   =
                                                   1
                                                   ,
                                                   2
                                                
                                                }
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        An optimal solution to an instance of rlp with two jobs is yes if FH
                        (p
                        1, p
                        2) = 1 and otherwise it is no. The time complexity of this DP algorithm is O(P
                        4 
                        H), where P = max {p
                        1, p
                        2}. This algorithm can easily be generalized to instances with a fixed number k of jobs; the running time will then be O(P
                        2k
                         
                        H).

We close this section by observing that rlp-decision with two jobs becomes polynomially solvable when the two jobs must be executed without preemption; in Appendix C we present an algorithm that runs in time O(H
                        4) for solving this problem.

We now turn our attention to the problem rlp-scheduling. As mentioned earlier, by solving rlp-scheduling we can infer the solution to rlp-decision, which implies that all negative results established in Section 3 are also valid for rlp-scheduling under the same conditions.

We obtain the following result, which is an adaptation of Lemma 1.

                           Lemma 9
                           For a given instance of rlp-scheduling with the above restrictions, the quantity 
                                 
                                    max
                                    {
                                    0
                                    ,
                                    
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       p
                                       j
                                    
                                    −
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       H
                                    
                                    
                                       c
                                       t
                                    
                                    }
                                 
                               represents the optimal objective value.

A schedule that achieves the objective value of 
                           
                              max
                              {
                              0
                              ,
                              
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 p
                                 j
                              
                              −
                              
                                 ∑
                                 
                                    t
                                    =
                                    1
                                 
                                 H
                              
                              
                                 c
                                 t
                              
                              }
                           
                         is obtained by executing jobs (in any order) from the first period to the last-but-one period without external workers; in the last period all the remaining jobs are scheduled, which requires 
                           
                              max
                              {
                              0
                              ,
                              
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 p
                                 j
                              
                              −
                              
                                 ∑
                                 
                                    t
                                    =
                                    1
                                 
                                 H
                              
                              
                                 c
                                 t
                              
                              }
                           
                         external workers. The lemma remains valid even with a non-preemption constraint.

We present Algorithm 3
                        , which is an adaptation of Algorithm 1, to solve rlp-scheduling when there are no bound constraints.

A proof of the following result can follow similar reasoning as the proof of Lemma 2.

                           Lemma 10
                           
                              Algorithm 3 solves the problem rlp-scheduling without bound constraints in time O(nlog n).

In the same way as Algorithm 1, Algorithm 3 does not guarantee the execution of jobs without preemption. When this restriction is imposed, the problem rlp-scheduling without bound constraints becomes np-hard in the strong sense, as a consequence of Lemma 3. Furthermore, we establish the following non-approximability result.

                           Lemma 11
                           Unless 
                                 
                                    p
                                    =
                                    np
                                    ,
                                 
                               problem rlp-scheduling does not admit an approximation algorithm when there are no bound constraints in combination with a non-preemption constraint.

In line with Section 3.3, we observe that Algorithm 3 can be modified to incorporate non-trivial upper bounds. We conclude here that both for the decision variant and for the scheduling problem, the complexity status without lower bounds is essentially the same as without bound constraints, which leads to the conclusion that upper bounds are easier to deal with than lower bounds (see below), at least without preemption.

We can also borrow the following two results from Section 4.2: the problem rlp-scheduling without lower bounds and with non-preemption constraint is np-hard in the strong sense and does not admit an approximation algorithm unless 
                           
                              p
                              =
                              np
                           
                        .


                        Lemma 5 implies that the problem rlp-scheduling without upper bounds is np-hard, even if there are only two periods and all jobs are splittable. We now present a DP algorithm to solve instances of rlp-scheduling with no upper bounds when there are exactly two periods (H = 2). We assume that rj
                         = 0 and 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 j
                              
                              =
                              2
                           
                         for each job j ∈ N and we add a dummy job 0 with r
                        0 = 0, 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 0
                              
                              =
                              2
                           
                         and p
                        0 = 0. We use the value function Fk
                        (α
                        1, α
                        2), which represents the minimum number of additional worker-periods necessary to execute jobs 0, 1, …, k with αt
                         workers in period t~(t = 1, 2). The initial condition of the recursion is given by F
                        0(α
                        1, α
                        2) = 0 for all α
                        1 ∈ {0, 1, …, c
                        1} and α
                        2 ∈ {0, 1, …, c
                        2}, and by F
                        0(α
                        1, α
                        2) = −(min {α
                        1, 0} + min {α
                        2, 0}) if α
                        1 ∈ { − P
                        sum, …, −1} or α
                        2 ∈ { − P
                        sum, …, −1}, where 
                           
                              
                                 P
                                 sum
                              
                              =
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 p
                                 j
                              
                           
                        . The recursive relation is

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                k
                                             
                                             
                                                (
                                                
                                                   α
                                                   1
                                                
                                                ,
                                                
                                                   α
                                                   2
                                                
                                                )
                                             
                                             =
                                             min
                                             
                                                {
                                                
                                                   F
                                                   
                                                      k
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   (
                                                   
                                                      α
                                                      1
                                                   
                                                   −
                                                   ℓ
                                                   ,
                                                   
                                                      α
                                                      2
                                                   
                                                   +
                                                   ℓ
                                                   −
                                                   
                                                      p
                                                      k
                                                   
                                                   )
                                                
                                                :
                                                ℓ
                                                ∈
                                                
                                                   Δ
                                                   k
                                                
                                                }
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 Δ
                                 k
                              
                              =
                              
                                 {
                                 0
                                 ,
                                 
                                    p
                                    k
                                 
                                 }
                              
                              ∪
                              
                                 (
                                 N
                                 ∩
                                 
                                    [
                                    
                                       lb
                                       k
                                    
                                    ,
                                    
                                       p
                                       k
                                    
                                    −
                                    
                                       lb
                                       k
                                    
                                    ]
                                 
                                 )
                              
                              ,
                           
                         as in Section 3.4. The optimal objective value for an instance of rlp-scheduling without upper bounds and with two periods is then Fn
                        (c
                        1, c
                        2). The time complexity of this algorithm is O(n
                        3
                        P
                        3), with (as before) P = max {p
                        1, …, pn
                        }.

We also establish the following result for this problem.

                           Lemma 12
                           Problem rlp-scheduling without upper bounds and with two periods admits an approximation algorithm only if 
                                 
                                    p
                                    =
                                    np
                                 
                              .

With a free number of periods, it follows from Lemma 6 that rlp-scheduling without upper bounds is np-hard in the strong sense. Furthermore, unless 
                           
                              p
                              =
                              np
                              ,
                           
                         the problem does not admit an approximation algorithm. We close this section by observing that the DP algorithm and the complexity results established above remain valid even if each job must be executed without preemption.

We present Algorithm 4
                        , which is adapted from Algorithm 2, to solve the problem rlp-scheduling with a single job. In the description we omit the subscript referring to the job, and without loss of generality we assume that the release date is r = 0 and the deadline 
                           
                              
                                 d
                                 ¯
                              
                              =
                              H
                           
                        .

                           Lemma 13
                           
                              Algorithm 4 solves the problem rlp-scheduling with a single job in time O(Hlog H).

In Appendix D, we present a modified version of Algorithm 4 that runs in time O(H) to solve the problem rlp-scheduling with a single job to be executed without preemption.

A consequence of Lemma 8 is that the problem rlp-scheduling with two jobs is np-hard, even if the two jobs are identical. We now present a DP algorithm to solve instances of rlp-scheduling with two jobs. Without loss of generality, we assume that the two jobs have the same time window. We define the value function Ft
                        (β
                        1, β
                        2) as the number of additional worker-periods needed when a total of βi
                         workers are assigned to job i (i = 1, 2) during periods 1, …, t. The initial condition is

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                1
                                             
                                             
                                                (
                                                
                                                   β
                                                   1
                                                
                                                ,
                                                
                                                   β
                                                   2
                                                
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             max
                                             {
                                             0
                                             ,
                                             
                                             
                                                β
                                                1
                                             
                                             +
                                             
                                                β
                                                2
                                             
                                             −
                                             
                                                c
                                                1
                                             
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             for
                                             
                                             
                                                
                                                   β
                                                   j
                                                
                                                ∈
                                                
                                                   {
                                                   0
                                                   ,
                                                   
                                                      lb
                                                      j
                                                   
                                                   ,
                                                   
                                                      lb
                                                      j
                                                   
                                                   +
                                                   1
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      ub
                                                      j
                                                   
                                                   }
                                                
                                             
                                             
                                             (
                                             
                                                j
                                                =
                                                1
                                                ,
                                                2
                                             
                                             ),
                                          
                                       
                                    
                                 
                              
                           
                        and F
                        1(β
                        1, β
                        2) = +∞ otherwise. The recursive relation is

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                t
                                             
                                             
                                                (
                                                
                                                   β
                                                   1
                                                
                                                ,
                                                
                                                   β
                                                   2
                                                
                                                )
                                             
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                min
                                                {
                                                max
                                                
                                                   {
                                                   0
                                                   ,
                                                   
                                                   
                                                      ℓ
                                                      1
                                                   
                                                   +
                                                   
                                                      ℓ
                                                      2
                                                   
                                                   −
                                                   
                                                      c
                                                      t
                                                   
                                                   }
                                                
                                                +
                                                
                                                   F
                                                   
                                                      t
                                                      −
                                                      1
                                                   
                                                
                                                
                                                   (
                                                   
                                                      β
                                                      1
                                                   
                                                   −
                                                   
                                                      ℓ
                                                      1
                                                   
                                                   ,
                                                   
                                                      β
                                                      2
                                                   
                                                   −
                                                   
                                                      ℓ
                                                      2
                                                   
                                                   )
                                                
                                                :
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                ℓ
                                                j
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                
                                                   lb
                                                   j
                                                
                                                ,
                                                
                                                   lb
                                                   j
                                                
                                                +
                                                1
                                                ,
                                                …
                                                ,
                                                
                                                   ub
                                                   j
                                                
                                                }
                                             
                                             
                                             and
                                             
                                             
                                                ℓ
                                                j
                                             
                                             ≤
                                             
                                                β
                                                j
                                             
                                             
                                                ,
                                                
                                                j
                                                =
                                                1
                                                ,
                                                2
                                                }
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The optimal objective value for an instance of rlp-scheduling with two jobs is FH
                        (p
                        1, p
                        2); if FH
                        (p
                        1, p
                        2) = +∞, then the instance is infeasible. The time complexity of this algorithm is O(P
                        4 
                        H), where P = max {p
                        1, p
                        2}. As in Section 3.6, this algorithm can be extended to run in O(P
                        2k
                         
                        H) time for any fixed number of jobs k.

We also establish the following non-approximation result for this problem.

                           Lemma 14
                           Unless 
                                 
                                    p
                                    =
                                    np
                                    ,
                                 
                               the problem rlp-scheduling with two jobs does not admit an approximation algorithm.

When the two jobs must be executed without preemption, Algorithm 7 can be modified to solve the problem in time O(H
                        4).

As in Section 4, we observe that by solving rlp-selection, we can infer the solution to rlp-decision. As a consequence, all negative results established in Section 3 remain valid for the problem rlp-selection under the same conditions.

Unlike the problems rlp-decision and rlp-scheduling, which under this condition are solved in linear time, the next result shows that rlp-selection is equivalent to the classic 0/1 knapsack problem.

                           Lemma 15
                           The problem rlp-selection is equivalent to the 0/1 knapsack problem when there are no time windows and no bound constraints, even if there is only one period.

The problem rlp-selection without time windows and without bound constraints is therefore np-hard in the ordinary sense. Furthermore, all known exact and approximation algorithms for knapsack problems are also valid for this special case of rlp-selection (we refer the reader to the comprehensive handbook by Kellerer, Pferschy, and Pisinger (2004) for an overview of such algorithms). All these results remain valid even if each job must be executed without preemption.

As this case is a generalization of the one in Section 5.1, we infer that the problem rlp-selection without bound constraints is at least np-hard in the ordinary sense, even if there is only one period. If H = 1, then the problem rlp-selection without bound constraints is equivalent to the knapsack problem, but when H > 1 this no longer holds, nor is the problem then equivalent to the classic multiple knapsack problem, since this variant of rlp-selection has time windows and jobs can be scheduled in more than one time period. We propose a standard DP algorithm for this case. We assume that jobs are already sorted in non-increasing order of their deadlines; this can be done in time O(nlog n).

For ease of exposition, we add a dummy job 0 with 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 0
                              
                              ≥
                              
                                 
                                    d
                                    ¯
                                 
                                 1
                              
                           
                         and r
                        0 = p
                        0 = Q
                        0 = 0. In this way, there is always an optimal solution that contains job 0. We use the following value function:

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                k
                                             
                                             
                                                (
                                                
                                                   α
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   α
                                                   H
                                                
                                                )
                                             
                                          
                                       
                                       
                                          ≡
                                       
                                       
                                          
                                             the
                                             
                                             maximum
                                             
                                             revenue
                                             
                                             obtained
                                             
                                             by
                                             
                                             considering
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             jobs
                                             
                                             {
                                             0
                                             ,
                                             1
                                             ,
                                             …
                                             ,
                                             k
                                             }
                                             
                                             and
                                             
                                             using
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             
                                                α
                                                t
                                             
                                             ≥
                                             0
                                             
                                             workers
                                             
                                             in
                                             
                                             period
                                             
                                             t
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        The initial condition is F
                        0(α
                        1, …, αH
                        ) = 0 for αt
                         = 0, 1, …, ct
                        , and the recursive relation is formulated as follows, where the values 
                           
                              
                                 α
                                 ¯
                              
                              t
                           
                         are the output of Algorithm 5
                        :

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                k
                                             
                                             
                                                (
                                                
                                                   α
                                                   1
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   α
                                                   H
                                                
                                                )
                                             
                                             =
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  α
                                                                  1
                                                               
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  α
                                                                  H
                                                               
                                                               )
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            if
                                                            
                                                            
                                                               ∑
                                                               
                                                                  t
                                                                  =
                                                                  
                                                                     r
                                                                     k
                                                                  
                                                                  +
                                                                  1
                                                               
                                                               
                                                                  
                                                                     d
                                                                     ¯
                                                                  
                                                                  k
                                                               
                                                            
                                                            
                                                               α
                                                               t
                                                            
                                                            
                                                            <
                                                            
                                                            
                                                               p
                                                               k
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            max
                                                            {
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  α
                                                                  1
                                                               
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  α
                                                                  H
                                                               
                                                               )
                                                            
                                                            ,
                                                         
                                                      
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                            
                                                               Q
                                                               k
                                                            
                                                            +
                                                            
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  
                                                                     α
                                                                     ¯
                                                                  
                                                                  1
                                                               
                                                               ,
                                                               …
                                                               ,
                                                               
                                                                  
                                                                     α
                                                                     ¯
                                                                  
                                                                  H
                                                               
                                                               )
                                                            
                                                            
                                                               }
                                                               ,
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            otherwise
                                                            .
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        The optimal objective value is Fn
                        (c
                        1, …, cH
                        ). Note that the jobs are indexed in non-increasing order of deadline, and that the DP algorithm actually schedules the jobs in reverse order. Algorithm 5 avoids having to evaluate all possible assignments of the pk
                         joblets within the time window of job k, and is based on the result obtained in Section 3.2 that Algorithm 1 produces a feasible schedule for the decision version of this problem: the workload of input job k is scheduled as early as possible within its time window conditional on (ct
                         − αt
                        ) resource units already being allocated to jobs k + 1, …, n (t = 1, …, H) when computing Fk
                        (α
                        1, …, αH
                        ).

The time complexity of this DP procedure is O(C 
                        n + nlog n), where 
                           
                              C
                              =
                              
                                 ∏
                                 
                                    t
                                    =
                                    1
                                 
                                 H
                              
                              
                                 c
                                 t
                              
                              ,
                           
                         and is thus pseudo-polynomial.

When jobs must be executed without preemption, we establish the following non-approximability result.

                           Lemma 16
                           Unless 
                                 
                                    p
                                    =
                                    np
                                    ,
                                 
                               the problem rlp-selection without bound constraints and without preemption does not admit an fptas.

The problem rlp-selection without lower bounds is also a generalization of the problem studied in Section 5.1, and so it is at least np-hard in the ordinary sense, even if there is only one period. When there is exactly one period, the problem is equivalent to the knapsack problem (by eliminating the jobs that do not satisfy the upper bounds). When the number of periods H > 1, the DP algorithm proposed in Section 5.2 can be modified to solve this problem, with the necessary changes described in Section 3.2 for Algorithm 1 applied to Algorithm 5. Again, we observe that without preemption, the inclusion of non-trivial upper bounds does not essentially make the problem more difficult, in contrast to lower bounds (see Section 5.4).

We close this section by noting that with a non-preemption constraint, rlp-selection becomes np-hard in the strong sense; hence it does not admit an fptas unless 
                           
                              p
                              =
                              np
                           
                        .


                        Lemma 5 implies that rlp-selection without upper bounds is np-hard, even if there are only two periods and all jobs are splittable. Note that with only one period, this problem is equivalent to the knapsack problem, and can therefore be solved by any known knapsack algorithm.

We now consider the case when there is more than one period. The DP algorithm proposed in Section 5.2 can be modified to solve this problem by examining all possible 
                           
                              
                                 α
                                 ¯
                              
                              t
                           
                         at each recursion. For simplicity, we present the DP algorithm for two periods. We also add a dummy job 0 with 
                           
                              
                                 
                                    d
                                    ¯
                                 
                                 0
                              
                              <
                              
                                 
                                    d
                                    ¯
                                 
                                 1
                              
                              ,
                           
                        
                        
                           
                              
                                 r
                                 0
                              
                              =
                              
                                 
                                    d
                                    ¯
                                 
                                 0
                              
                              ,
                           
                         
                        p
                        0 = 0 and Q
                        0 = 0. We use the DP value function Fk
                        (α
                        1, α
                        2), which represents the maximum revenue that can be generated by considering jobs {0, 1, …, k} and αt
                         workers in period t (t = 1, 2). The initial condition of the DP recursion is F
                        0(α
                        1, α
                        2) = 0 for α
                        1 = 0, 1, …, c
                        1 and α
                        2 = 0, 1, …, c
                        2, and F
                        0(α
                        1, α
                        2) = −∞ if α
                        1 < 0 or α
                        2 < 0. The recursive relation is as follows: if α
                        1 + α
                        2 < pk
                        , then Fk
                        (α
                        1, α
                        2) = F
                        
                           k − 1(α
                        1, α
                        2); otherwise,

                           
                              
                                 
                                    
                                       
                                          
                                             
                                                F
                                                k
                                             
                                             
                                                (
                                                
                                                   α
                                                   1
                                                
                                                ,
                                                
                                                   α
                                                   2
                                                
                                                )
                                             
                                             =
                                             max
                                             
                                                {
                                                
                                                   
                                                      
                                                         
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  α
                                                                  1
                                                               
                                                               ,
                                                               
                                                                  α
                                                                  2
                                                               
                                                               )
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               Q
                                                               k
                                                            
                                                            +
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  α
                                                                  1
                                                               
                                                               −
                                                               
                                                                  p
                                                                  k
                                                               
                                                               ,
                                                               
                                                                  α
                                                                  2
                                                               
                                                               )
                                                            
                                                            
                                                            if
                                                            
                                                            
                                                               [
                                                               
                                                                  r
                                                                  k
                                                               
                                                               ,
                                                               
                                                                  
                                                                     d
                                                                     ¯
                                                                  
                                                                  k
                                                               
                                                               ]
                                                            
                                                            =
                                                            
                                                               [
                                                               0
                                                               ,
                                                               1
                                                               ]
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               Q
                                                               k
                                                            
                                                            +
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  α
                                                                  1
                                                               
                                                               ,
                                                               
                                                                  α
                                                                  2
                                                               
                                                               −
                                                               
                                                                  p
                                                                  k
                                                               
                                                               )
                                                            
                                                            
                                                            if
                                                            
                                                            
                                                               [
                                                               
                                                                  r
                                                                  k
                                                               
                                                               ,
                                                               
                                                                  
                                                                     d
                                                                     ¯
                                                                  
                                                                  k
                                                               
                                                               ]
                                                            
                                                            =
                                                            
                                                               [
                                                               1
                                                               ,
                                                               2
                                                               ]
                                                            
                                                            ,
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               Q
                                                               k
                                                            
                                                            +
                                                            
                                                               F
                                                               
                                                                  k
                                                                  −
                                                                  1
                                                               
                                                            
                                                            
                                                               (
                                                               
                                                                  α
                                                                  1
                                                               
                                                               −
                                                               ℓ
                                                               ,
                                                               
                                                                  α
                                                                  2
                                                               
                                                               +
                                                               ℓ
                                                               −
                                                               
                                                                  p
                                                                  k
                                                               
                                                               )
                                                            
                                                            :
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            
                                                            
                                                            ℓ
                                                            ∈
                                                            
                                                               Δ
                                                               k
                                                            
                                                            
                                                            if
                                                            
                                                            
                                                               r
                                                               k
                                                            
                                                            =
                                                            0
                                                            
                                                            and
                                                            
                                                            
                                                               
                                                                  d
                                                                  ¯
                                                               
                                                               k
                                                            
                                                            =
                                                            2
                                                         
                                                      
                                                   
                                                
                                                }
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 Δ
                                 k
                              
                              =
                              
                                 {
                                 0
                                 ,
                                 
                                    p
                                    k
                                 
                                 }
                              
                              ∪
                              
                                 (
                                 N
                                 ∩
                                 
                                    [
                                    
                                       lb
                                       k
                                    
                                    ,
                                    
                                       p
                                       k
                                    
                                    −
                                    
                                       lb
                                       k
                                    
                                    ]
                                 
                                 )
                              
                           
                        . The optimal objective value is given by Fn
                        (c
                        1, c
                        2). The time complexity of this DP algorithm is O(nC
                        2
                        P), where C = max {c
                        1, c
                        2} and P is the largest work content. By the same reasoning as in Section 3.4, this DP recursion can be generalized for any constant H, still leading to a pseudo-polynomial-time algorithm.

Since the knapsack problem admits an fptas, we can conclude that rlp-selection without upper bounds also admits an fptas when H = 1. Conversely, we can establish the following non-approximation result when H > 1.

                           Lemma 17
                           Unless 
                                 
                                    p
                                    =
                                    np
                                    ,
                                 
                               the problem rlp-selection with two periods and no upper bounds does not admit an fptas.

When the non-preemption constraint is included into the problem statement, both the positive and the negative results of this section can be carried over.

There are two options in this case: the selection (and execution) of the job or no selection. The problem can be solved by an adapted version of Algorithm 2, where in lines 3 and 6 we return Q (the revenue of the unique job), and in lines 2 and 7 we return 0 (meaning that the job is not selected). By applying similar modifications to Algorithm 6
                        , we can solve rlp-selection with only one job and without preemption.


                        Lemma 8 implies that rlp-selection with two jobs is np-hard, even if the two jobs are identical. We now describe an algorithm to solve this problem. We refer to the two jobs as job 1 and job 2. Four options are possible: (1) none of the two jobs is selected; (2) job 1 is selected and not job 2; (3) job 2 is selected and not job 1; and (4) both job 1 and job 2 are executed. The first option results in an objective value of zero. The second option yields an objective value of either zero or Q
                        1, and the third one a value of either zero or Q
                        2, which can be determined via the procedure described in Section 5.5. The last option, which is considered only if option (2) leads to Q
                        1 and option (3) to Q
                        2, generates a value of either zero or Q
                        1 + Q
                        2 and can be evaluated with the DP algorithm described for rlp-decision with two jobs. Since we have four possibilities, and since each case requires an algorithm that is at most pseudo-polynomial, we conclude that rlp-selection with two jobs can be solved in pseudo-polynomial time. This result can be generalized for any fixed number k of jobs. The described procedure also remains valid even if each job must be executed without preemption.

@&#CONCLUSIONS@&#

In this paper, we have defined a generic resource scheduling problem inspired by tactical capacity planning in project-based environments. The direct contributions of this study are mainly theoretical: we contribute to a better understanding of the problem by presenting a structured complexity analysis of the underlying combinatorial optimization problem. In the process, we have observed a number of links with existing work in equipment maintenance and MTO and ETO planning, as well as operational and multiprocessor scheduling. Our results are useful to further the understanding of the structural properties of resource loading, and the proposed algorithms can be implemented as a subroutine within any framework for solving practical resource loading problems.

Further work in this area should focus on incorporating practical aspects of specific planning cases. In one particular aircraft line maintenance problem, for instance, we learned that the intensities were required to be monotone, meaning that a job is executed with either non-decreasing or non-increasing intensities. This would mean, for instance, that one cannot start a job with one person, then continue with two persons, and finish again with one person. This monotonicity constraint also implies that the jobs are executed without preemption. Related studies have identified similar monotonicity constraints as dominant properties (see Hendel et al., 2014; Sadykov, 2012), hence this aspect certainly deserves further research. Resource loading as described in this paper can also be seen as a variant of the multiple knapsack problem in which items can be spread across different knapsacks. The bin packing problem is closely related to the multiple knapsack problem, and the possibility of splitting jobs across multiple bins has also been the subject of recent research (see Casazza and Ceselli, 2014). This area might also present a number of interesting synergies to be further explored.

@&#ACKNOWLEDGMENTS@&#

We thank two anonymous reviewers for their constructive comments; in particular we are grateful to Reviewer #1 for pointing out an omission in the determination of the time complexity of some of the algorithms.

The project leading to these results has been partially supported by the bilateral scientific cooperation project BIL10/10 between KU Leuven (Belgium) and Tsinghua University (China). Fabrice Talla Nobibon gratefully acknowledges the Fund for Scientific Research - Flanders (FWO-Vlaanderen) for his postdoctoral fellowship. Zhenbo Wang also received support from project NSFC no. 11371216.

Each joblet (of any job) can be assigned to any worker in any period; such assignment is feasible if and only if there is enough capacity. This condition is exactly the inequality 
                                 
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       p
                                       j
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       H
                                    
                                    
                                       c
                                       t
                                    
                                 
                              .

For ease of exposition, we assume that jobs are already indexed in non-decreasing order of their deadline; this can be done in O(nlog n), where n is the number of jobs (Cormen, Leiserson, Rivest, and Stein, 2005).

On the one hand, if Algorithm 1 outputs yes, then the computed schedule is such that each job is executed within its time window and the capacity of each period is respected; in other words, all the constraints of rlp-decision are satisfied. On the other hand, suppose that we have a yes instance of rlp-decision without bound constraints and that we are given a feasible schedule. Consider the first job (with the smallest deadline) and its release time r
                              1. Move all the joblets of job 1 to period r
                              1 + 1, and if that period is not enough to completely schedule job 1, then use the next period. Repeat this until job 1 is completely executed. Note that the obtained schedule is feasible because all the jobs (or joblets) that are moved backward have a deadline greater than or equal to that of job 1. This procedure is successively repeated for jobs 2, …, n, without moving jobs (or joblets of jobs) with smaller indices that are already re-scheduled. The final schedule is feasible because we started with a feasible schedule. Furthermore, the latter is exactly the same schedule that is output by Algorithm 1. As a consequence, Algorithm 1 returns yes for this instance.

The time complexity of Algorithm 1 is dominated by the sorting in line 1; therefore its complexity is O(nlog n).

Clearly, the problem rlp-decision without bound constraints belongs to the class np. Given an arbitrary instance of sequencing with release times and deadlines, we construct an instance of rlp-decision with H = max 
                                 t ∈ T
                              
                              d(t) periods, each period with exactly one worker. There are |T| jobs and each job corresponds with a task in T so that job j has processing time pj
                               = ℓ(j) and time window 
                                 
                                    
                                       [
                                       
                                          r
                                          j
                                       
                                       ,
                                       
                                          
                                             d
                                             ¯
                                          
                                          j
                                       
                                       ]
                                    
                                    =
                                    
                                       [
                                       r
                                       
                                          (
                                          j
                                          )
                                       
                                       ,
                                       d
                                       
                                          (
                                          j
                                          )
                                       
                                       ]
                                    
                                 
                              . Note that this construction can be done in polynomial time. Because each job must be executed without preemption and each period has exactly one worker, it follows that there exists a feasible schedule for the instance of sequencing with release times and deadlines if and only if the constructed instance of rlp-decision without bound constraints is a yes instance.

The problem rlp-decision with no upper bounds clearly belongs to the class np. Given an arbitrary instance of partition, we build an instance of rlp-decision with two periods (H = 2). There are c
                              1 = mB
                              3 + B
                              2 − m workers available in the first period and c
                              2 = 3mB
                              3 + 3B
                              2 − m workers in the second one. There are 2m jobs, and each job corresponds with an element in A so that job j has the processing time pj
                               = 2B
                              3 + 2s(j)B − 1 and lb
                              
                                 j
                                = B
                              3 + s(j)B − 1. Furthermore, all the jobs have the same time window [0, 2]. This construction can be done in polynomial time. Note that all the jobs are splittable, and that there is only one way to split job j, i.e. into a smaller part requiring 
                                 
                                    
                                       p
                                       
                                          j
                                          s
                                       
                                    
                                    =
                                    
                                       B
                                       3
                                    
                                    +
                                    s
                                    
                                       (
                                       j
                                       )
                                    
                                    B
                                    −
                                    1
                                 
                               workers, which we refer to as js
                              , and a larger part j
                              ℓ with 
                                 
                                    
                                       p
                                       
                                          j
                                          ℓ
                                       
                                    
                                    =
                                    
                                       B
                                       3
                                    
                                    +
                                    s
                                    
                                       (
                                       j
                                       )
                                    
                                    B
                                 
                               workers. We now argue that we have a yes instance of partition if and only if the instance of rlp-decision is also a yes instance.

On the one hand, if we have a yes instance of partition, then we construct a feasible schedule as follows: all the jobs corresponding with elements in A
                              1 are split into two parts. The smaller parts are scheduled in the first period, whereas the larger parts of these jobs and the jobs corresponding with elements in A
                              2 are all scheduled in the second period. It can be verified that this schedule is feasible for the instance of rlp-decision. On the other hand, suppose that we have a yes instance of rlp-decision. The number of workers required to execute all jobs is equal to the sum of the capacities of the two periods, so the capacity of each period is fully used. Let us consider a feasible schedule and denote by F the set of jobs fully executed in the first period and by S (respectively L) the set of split jobs whose smaller (respectively larger) part is executed in the first period. The capacity usage (and availability) in period 1 is then:

                                 
                                    (A.1)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   
                                                      2
                                                      |
                                                      F
                                                      |
                                                   
                                                   
                                                      B
                                                      3
                                                   
                                                   +
                                                   2
                                                   B
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         F
                                                      
                                                   
                                                   s
                                                   
                                                      (
                                                      j
                                                      )
                                                   
                                                   −
                                                   
                                                      |
                                                      F
                                                      |
                                                   
                                                   +
                                                   
                                                      |
                                                      S
                                                      |
                                                   
                                                   
                                                      B
                                                      3
                                                   
                                                   +
                                                   B
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         S
                                                      
                                                   
                                                   s
                                                   
                                                      (
                                                      j
                                                      )
                                                   
                                                   −
                                                   
                                                      |
                                                      S
                                                      |
                                                   
                                                   +
                                                   
                                                      |
                                                      L
                                                      |
                                                   
                                                   
                                                      B
                                                      3
                                                   
                                                
                                             
                                          
                                          
                                             
                                             
                                             
                                                
                                                   
                                                   +
                                                   
                                                   B
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         L
                                                      
                                                   
                                                   s
                                                   
                                                      (
                                                      j
                                                      )
                                                   
                                                   =
                                                   m
                                                   
                                                      B
                                                      3
                                                   
                                                   +
                                                   
                                                      B
                                                      2
                                                   
                                                   −
                                                   m
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              Without loss generality, we assume that B is sufficiently larger than m so that the coefficients of B
                              3 and the constant terms in both sides of Eq. (A.1) coincide. It follows that

                                 
                                    (A.2a)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   2
                                                   |
                                                   F
                                                   |
                                                   +
                                                   |
                                                   S
                                                   |
                                                   +
                                                   |
                                                   L
                                                   |
                                                   =
                                                   m
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (A.2b)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   and
                                                
                                             
                                          
                                          
                                             
                                             
                                             
                                                
                                                   |
                                                   F
                                                   |
                                                   +
                                                   |
                                                   S
                                                   |
                                                   =
                                                   m
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

By substituting (A.2b) into (A.2a), we obtain that |F| + |L| = 0, which implies that |F| = |L| = 0 and |S| = m. This means that exactly m smaller parts of split jobs are executed in the first period. By comparing the coefficients of B
                              2 in Eq. (A.1) we obtain that ∑
                                 j ∈ S
                              
                              s(j) = B. We then define A
                              1 as follows: an element a ∈ A
                              1 if and only if the smaller part of the corresponding job is scheduled in the first period. The remaining m jobs (that are not split) belong to A
                              2. Clearly, we have |A
                              1| = |A
                              2| = m. Furthermore, since 
                                 
                                    
                                       ∑
                                       
                                          a
                                          ∈
                                          
                                             A
                                             1
                                          
                                       
                                    
                                    s
                                    
                                       (
                                       a
                                       )
                                    
                                    =
                                    B
                                 
                               we conclude that A
                              1 and A
                              2 constitute a feasible partition of A. This completes the proof of Lemma 5.

Given an arbitrary instance of 3-partition, we construct an instance of rlp-decision with H = m + 1 periods. The first m periods have 3B
                              3 + B
                              2 − 3 workers available and the last period (m + 1) has 3mB
                              3 + mB
                              2 workers. There are 3m jobs, each job corresponding with an element of A so that job j has the processing time of pj
                               = 2B
                              3 + 2s(j)B − 1 and the lower bound of lb
                              
                                 j
                                = B
                              3 + s(j)B − 1. All jobs have the same time window [0, H]. As in the proof of Lemma 5, these jobs are all splittable and there is only one way to split each job j, with a smaller part js
                               requiring 
                                 
                                    
                                       p
                                       
                                          j
                                          s
                                       
                                    
                                    =
                                    
                                       B
                                       3
                                    
                                    +
                                    s
                                    
                                       (
                                       j
                                       )
                                    
                                    B
                                    −
                                    1
                                 
                               workers and a larger part j
                              ℓ with 
                                 
                                    
                                       p
                                       
                                          j
                                          ℓ
                                       
                                    
                                    =
                                    
                                       B
                                       3
                                    
                                    +
                                    s
                                    
                                       (
                                       j
                                       )
                                    
                                    B
                                 
                               workers. This construction can be completed in polynomial time. We now argue that the instance of 3-partition is a yes instance if and only if the constructed instance of rlp-decision is also a yes instance.

On the one hand, if we have a yes instance of 3-partition, then there exists a feasible schedule for the instance rlp-decision. Indeed, it suffices to execute in period t the smaller part of the three jobs corresponding with elements in At
                              , for t = 1, …, m; and then execute the larger parts of all the jobs in the last period.

On the other hand, let us suppose that we have a feasible schedule for the constructed instance of rlp-decision. The number of workers required to execute all jobs is equal to the sum of the capacities of all periods, so we infer that the capacity of each period is fully used. We denote by F the set of jobs completely executed in the last period (m + 1), and by S (respectively L) the set of jobs for which only the smaller (respectively larger) part is executed in period (m + 1). The capacity usage in period (m + 1) is then:

                                 
                                    (A.3)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   
                                                      2
                                                      |
                                                      F
                                                      |
                                                   
                                                   
                                                      B
                                                      3
                                                   
                                                   +
                                                   2
                                                   B
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         F
                                                      
                                                   
                                                   s
                                                   
                                                      (
                                                      j
                                                      )
                                                   
                                                   −
                                                   
                                                      |
                                                      F
                                                      |
                                                   
                                                   +
                                                   
                                                      |
                                                      S
                                                      |
                                                   
                                                   
                                                      B
                                                      3
                                                   
                                                   +
                                                   B
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         S
                                                      
                                                   
                                                   s
                                                   
                                                      (
                                                      j
                                                      )
                                                   
                                                   −
                                                   
                                                      |
                                                      S
                                                      |
                                                   
                                                   +
                                                   
                                                      |
                                                      L
                                                      |
                                                   
                                                   
                                                      B
                                                      3
                                                   
                                                
                                             
                                          
                                          
                                             
                                             
                                             
                                                
                                                   
                                                   +
                                                   
                                                   B
                                                   
                                                      ∑
                                                      
                                                         j
                                                         ∈
                                                         L
                                                      
                                                   
                                                   s
                                                   
                                                      (
                                                      j
                                                      )
                                                   
                                                   =
                                                   3
                                                   m
                                                   
                                                      B
                                                      3
                                                   
                                                   +
                                                   m
                                                   
                                                      B
                                                      2
                                                   
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              It follows that

                                 
                                    (A.4a)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   2
                                                   |
                                                   F
                                                   |
                                                   +
                                                   |
                                                   S
                                                   |
                                                   +
                                                   |
                                                   L
                                                   |
                                                   =
                                                   3
                                                   m
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              
                                 
                                    (A.4b)
                                    
                                       
                                          
                                             
                                             
                                             
                                                
                                                   and
                                                
                                             
                                          
                                          
                                             
                                             
                                             
                                                
                                                   |
                                                   F
                                                   |
                                                   +
                                                   |
                                                   S
                                                   |
                                                   =
                                                   0
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

which implies that |F| = |S| = 0 and |L| = 3m. This observation indicates that all jobs are split (into two parts), and that the larger parts are all scheduled in period m + 1, whereas the smaller parts are all executed in the first m periods. Each of these first m periods is then assigned exactly three smaller parts, which fully occupy the available workers. We now construct a partition of A by defining A
                              ℓ (ℓ = 1, …, m) to contain the three elements for which the smaller parts of their corresponding jobs are scheduled in period ℓ. This completes the proof of Lemma 6.

We prove this result using a reduction from the problem partition defined earlier. Given an arbitrary instance of partition, we build an instance of rlp-decision with two identical jobs (n = 2) as follows. Each job j (j = 1, 2) has the workload pj
                               = (2m + 1)B, 
                                 
                                    lb
                                    
                                       
                                       j
                                    
                                    =
                                    2
                                    B
                                    +
                                    
                                       min
                                       
                                          a
                                          ∈
                                          A
                                       
                                    
                                    s
                                    
                                       (
                                       a
                                       )
                                    
                                 
                               and 
                                 
                                    ub
                                    
                                       
                                       j
                                    
                                    =
                                    2
                                    B
                                    +
                                    
                                       max
                                       
                                          a
                                          ∈
                                          A
                                       
                                    
                                    s
                                    
                                       (
                                       a
                                       )
                                    
                                 
                              . There are 2m periods with ct
                               = 2B + s(t) workers available in period t, for t = 1, …, 2m. The lower bound implies that in each period we can execute only one job. Finally, the time window of each job is [0, 2m]. This construction can be completed in polynomial time. We now argue that the instance of partition is a yes instance if and only if the instance of rlp-decision is also a yes instance.

On the one hand, if we have a yes instance of partition, then the set A can be partitioned into two subsets A
                              1 and A
                              2 such that 
                                 
                                    
                                       ∑
                                       
                                          a
                                          ∈
                                          
                                             A
                                             1
                                          
                                       
                                    
                                    s
                                    
                                       (
                                       a
                                       )
                                    
                                    =
                                    B
                                 
                              . For each period t, if t ∈ A
                              1 then we assign 2B + s(t) workers to job 1 and 0 workers to job 2 in that period; otherwise, we assign 2B + s(t) workers to job 2 and 0 workers to job 1 in that period. The schedule achieves a feasible execution of both jobs and we conclude that the instance of rlp-decision is a yes instance. On the other hand, if we have a yes instance of rlp-decision, then by defining Ai
                               = {t: job~i is executed in period~t}, we conclude that the instance of partition is a yes instance.

Let us consider the reduction from sequencing with release times and deadlines constructed in the proof of Lemma 3. We have a yes instance of sequencing with release times and deadlines if and only if the constructed instance of rlp-scheduling has an optimal objective value of 0. As a consequence, if there exists an approximation algorithm for the latter problem, then it can be used to solve the former. In combination with the fact that sequencing with release times and deadlines is np-complete, the lemma can then be seen to hold.

Consider the reduction from partition constructed in the proof of Lemma 5. We have a yes instance of partition if and only if the constructed instance of rlp-scheduling has an optimal objective value of 0. Therefore, an approximation algorithm for rlp-scheduling would correctly decide each instance of partition.

The proof of this result is similar to that of Lemma 12, but then with reference to Lemma 8 instead of Lemma 5.

Given an instance of rlp-selection with the above restrictions, we build an instance of the knapsack problem as follows: the capacity of the knapsack is 
                                 
                                    B
                                    =
                                    
                                       ∑
                                       
                                          t
                                          =
                                          1
                                       
                                       H
                                    
                                    
                                       c
                                       t
                                    
                                    ,
                                 
                               and there are n items. Item j has profit Qj
                               and weight pj
                              . Clearly, an optimal solution to this instance of the knapsack problem corresponds with an optimal solution to the instance of rlp-selection and vice versa. Moreover, an instance of the knapsack problem can be seen as an instance of rlp-selection with a single period. This completes the proof.

We still consider the reduction from sequencing with release times and deadlines constructed in the proof of Lemma 3, and in addition each job j ∈ N has revenue Qj
                               = 1. If we have a yes instance of sequencing with release times and deadlines, then the constructed instance of rlp-selection has an optimal objective value of n; otherwise, it is at most n − 1. Therefore, by taking 
                                 
                                    ϵ
                                    =
                                    
                                       1
                                       
                                          n
                                          +
                                          1
                                       
                                    
                                 
                               any fptas can be used to distinguish between these two situations in polynomial time.

We consider the reduction from partition set up in the proof of Lemma 5, where in addition each job j has revenue Qj
                               = 1. If we have a yes instance of partition, then the optimal objective value is 2m; otherwise, it is at most 2m − 1. Therefore, an fptas for rlp-selection with two periods and no upper bounds can be used to distinguish between these two situations in polynomial time.

We present Algorithm 6 for solving rlp-decision with a single job that must be executed without preemption. Without loss of generality, we assume 
                        
                           
                              c
                              t
                           
                           ≥
                           lb
                           ,
                        
                      ∀t ∈ H.

By observing that Ht
                      in line 5 can be obtained as 
                        
                           min
                           {
                           H
                           ,
                           
                              ⌊
                              
                                 p
                                 lb
                              
                              ⌋
                           
                           +
                           t
                           −
                           1
                           }
                        
                      (assuming 
                        
                           p
                           ≥
                           lb
                        
                     ), and with a careful monitoring of the sums in line 6, the following result can be seen to hold.

                        Lemma 18
                        
                           Algorithm 6 solves the problem rlp-decision with a single job that must be executed without preemption in time O(H).

We use 
                        
                           t
                           1
                           s
                        
                      and 
                        
                           t
                           1
                           e
                        
                      (respectively 
                        
                           t
                           2
                           s
                        
                      and 
                        
                           t
                           2
                           e
                        
                     ) to refer to the first and the last period in which job 1 (respectively job 2) is executed. Note that for a feasible schedule, we have 
                        
                           
                              r
                              1
                           
                           ≤
                           
                              t
                              1
                              s
                           
                           ≤
                           
                              t
                              1
                              e
                           
                           ≤
                           
                              
                                 d
                                 ¯
                              
                              1
                           
                        
                      and 
                        
                           
                              r
                              2
                           
                           ≤
                           
                              t
                              2
                              s
                           
                           ≤
                           
                              t
                              2
                              e
                           
                           ≤
                           
                              
                                 d
                                 ¯
                              
                              2
                           
                        
                     . Without loss of generality, we assume that r
                     1 ≤ r
                     2. We present Algorithm 7
                      for solving rlp-decision with two jobs that must be executed without preemption, and we formulate the following result.

                        Lemma 19
                        
                           Algorithm 7 solves the problem rlp-decision with two non-preemptible jobs in time O(H4).

The correctness of Algorithm 7 is guaranteed by the complete enumeration of all possible cases and its time complexity results from the nested loops.□


                     Algorithm 8
                      runs in time O(H) and solves the problem rlp-scheduling with a single job that must be executed without preemption.

@&#REFERENCES@&#

