@&#MAIN-TITLE@&#A multilevel ant colony optimization algorithm for classical and isothermic DNA sequencing by hybridization with multiplicity information available

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           Partial information about substring repetitions has been taken into account.


                        
                        
                           
                           An ACO algorithm for SBH with multiplicity information has been proposed.


                        
                        
                           
                           The proposed algorithm outperformes other algorithms known from the literature.


                        
                        
                           
                           The usefulness of the multiplicity information has been positively verified.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Sequencing by hybridization

Substring repetitions

Multiplicity information

Isothermic oligonucleotide libraries

Ant colony optimization

@&#ABSTRACT@&#


               
               
                  The classical sequencing by hybridization takes into account a binary information about sequence composition. A given element from an oligonucleotide library is or is not a part of the target sequence. However, the DNA chip technology has been developed and it enables to receive a partial information about multiplicity of each oligonucleotide the analyzed sequence consist of. Currently, it is not possible to assess the exact data of such type but even partial information should be very useful.
                  Two realistic multiplicity information models are taken into consideration in this paper. The first one, called “one and many” assumes that it is possible to obtain information if a given oligonucleotide occurs in a reconstructed sequence once or more than once. According to the second model, called “one, two and many”, one is able to receive from biochemical experiment information if a given oligonucleotide is present in an analyzed sequence once, twice or at least three times.
                  An ant colony optimization algorithm has been implemented to verify the above models and to compare with existing algorithms for sequencing by hybridization which utilize the additional information. The proposed algorithm solves the problem with any kind of hybridization errors. Computational experiment results confirm that using even the partial information about multiplicity leads to increased quality of reconstructed sequences. Moreover, they also show that the more precise model enables to obtain better solutions and the ant colony optimization algorithm outperforms the existing ones.
                  Test data sets and the proposed ant colony optimization algorithm are available on: http://bioserver.cs.put.poznan.pl/download/ACO4mSBH.zip.
               
            

@&#INTRODUCTION@&#

Reading DNA sequences remains one of the necessary procedures in many areas of biological research. The obvious reason is the fact that the goal of scientific investigations in those areas is to discover a meaning of some pieces of genetic information. But before understanding this information must be read. This is also the reason of the importance of sequencing methods. Nowadays, Next Generation Sequencing (NGS) approaches evolve very rapidly and became more and more efficient. However, they are especially suitable for sequencing large fragments of genomes. It justifies development of some alternative sequencing strategies. They can be better suited for some specific sequencing tasks than NGS methods, e.g. for sequencing some relatively short fragments of DNA or for re-sequencing.

One of such methods is Sequencing by Hybridization (SBH) (Drmanac et al., 1989; Khrapko et al., 1989; Southern et al., 1992). The method is known for quite a long time. It is composed of two stages, the biochemical one and the computational one. In the biochemical stage of the classical variant of the method a hybridization experiment is performed. Here, a DNA chip containing a full library of oligonucleotides of some given length l is hybridized with the target DNA sequence. As a result a set, called a spectrum, of substrings of length l, called l-mers, of the target DNA is obtained. However, the information about the order of the fragments is lost. It must be recovered in the computational stage. In an ideal case, i.e. where there are no hybridization errors or repetitions of length l or longer in the target DNA, the problem is computationally easy (Pevzner, 1989). However, in almost every case some errors occur. The errors can be divided into two types, i.e. negative ones and positive ones.

The negative error is a lack of some substring of length l in a spectrum. The source of errors of this type is the imperfectness of the hybridization process. Such errors can appear also because of repetitions in the target sequence. It is due to the fact that a spectrum is a set but not a multiset what means that there are no repetitions. The positive error is an occurrence in a spectrum of a substring which is not a part of the target DNA molecule. The source of these errors is the imperfectness of the hybridization process. It should be noted that the negative errors resulting from repetitions cannot be eliminated by improving the quality of hybridization procedure because they follow from the structure of the target DNA sequence.

The assumption that in a spectrum there are no repetitions is one of the fundamental features of the classical variant of SBH. It was fully justified by the sequencing chips technology at times when the method was developed. This technology allowed only for detection of the presence of some substring in the target DNA but it was impossible to determine how many copies of such a substring occur there. However, today the technology of DNA chips is much more advanced and allows for estimation of the number of substring repetitions, at least to some extent. It is exploited in the case of microarrays for gene expression analysis, where the levels of signals on the chip are measured (cf. Schena, 2003). These levels correspond to the amount of mRNAs present in the analyzed tissue. Also in the case of DNA sequencing chips the signal levels can be measured. In this case they correspond to the number of copies of a given substring in the target molecule. However, the exact relationship between the signal level and the number of copies of substrings present in the target DNA sequence is difficult to determine. So, on the basis of the signal level only an approximate number of substring repetitions can be obtained. It is possible to distinguish between one and two occurrences because the difference in the corresponding signal levels is significant. But distinguishing between six and seven occurrences, for example, would be much more difficult since in this case the difference between signal levels is small. So, in practice in SBH method at the current stage of the DNA chip technology development it should be possible to apply only some simple models of the information about substring repetitions. In one of such models it is assumed that it is possible to distinguish between one and more than one occurrences of a substring. This model is called “one and many”. According to the second model it is possible to distinguish between one occurrence, two occurrences and more than two occurrences. This model is called “one, two and many” (Formanowicz, 2005, 2005; Kwarciak and Formanowicz, 2014).

There are some other attempts to improve the performance of SBH. Some of them are based on non-classical DNA sequencing chips, i.e. these ones which do not contain a full library of oligonucleotides of a fixed length l. One of such SBH variants is called isothermic SBH (Błażewicz et al., 2000; Błażewicz et al., 2004). In this method a full library of oligonucleotides of a given melting temperature is used.

When a hybridization experiment is considered, the process of DNA denaturation must be taken into account. The process takes place in the sufficiently high temperature, and in general, the longer the double helix, the more energy is necessary to achieve the denaturation.

One of the simplest ways to determine the melting temperature for a given double-stranded DNA is to calculate a sum of weights for every pair of nucleotides which build it. The weight of A-T pair is assumed to be equal to 2, while for the pair C-G it is set to 4. For example, for sequence ATTCAGA the melting temperature according to this model is equal to 18. Obviously, the value calculated in this way is only an approximation of the real melting temperature.

In the classical SBH libraries of oligonucleotides of a given length are used, so their melting temperatures are different. Therefore it is difficult or even impossible to set the conditions of the biochemical experiment such that all the oligonucleotides will create stable duplexes. This issue influences the number of hybridization errors. The idea for solving the problem lies behind the so-called isothermic libraries, which contain oligonucleotides having the same melting temperature (Błażewicz et al., 2004). Obviously, the elements of such libraries are of various lengths.

Such a library L contains oligonucleotides with a melting temperature 
                        
                           T
                           L
                        
                        =
                        
                           w
                           A
                        
                        
                           x
                           A
                        
                        +
                        
                           w
                           C
                        
                        
                           x
                           C
                        
                        +
                        
                           w
                           G
                        
                        
                           x
                           G
                        
                        +
                        
                           w
                           T
                        
                        
                           x
                           T
                        
                     , where weight 
                        
                           w
                           A
                        
                        =
                        
                           w
                           T
                        
                        =
                        2
                     , weight 
                        
                           w
                           C
                        
                        =
                        
                           w
                           G
                        
                        =
                        4
                      while x
                     
                        A
                     , x
                     
                        C
                     , x
                     
                        G
                      and x
                     
                        T
                      denote the numbers of nucleotides A, C, G and T, respectively. In (Błażewicz et al., 2004) it has been proven that for successful sequencing of a given DNA two libraries of temperatures 
                        
                           T
                           L
                        
                      and 
                        
                           T
                           L
                        
                        +
                        2
                      must be used.

In this paper we present a heuristic algorithm based on ant colony metaheuristic for SBH problem with errors of arbitrary types and with additional information of repetitions. The algorithm can use spectra from the classical SBH experiment as well as ones that come from the use of the isothermic oligonucleotide libraries.

It should be emphasized that even such partial information about spectrum elements repetitions may cause reduction of the number of negative errors resulting from substring repetitions in the target sequence and improve the quality of sequencing results (cf. Kwarciak and Formanowicz, 2014). It is important since, as has been mentioned, errors of this type cannot be reduced by the improvement of the hybridization procedure. On the other hand, repetitions occur quite often in many DNA molecules.

The organization of the paper is as follows. In Section 2 formal definitions of the considered sequencing problems are provided. In Section 3 the proposed algorithm is described while in Section 4 the results of a computational experiment are presented. The paper ends with conclusions given in Section 5.

Formal definitions of the problems of DNA sequencing by hybridization with multiplicity information available have been formulated in (Formanowicz, 2005, 2005). This section contains only their brief overview.

In the classical variant of SBH a spectrum is a part of an input to the computational phase of the method. When the information about repetitions is available still a spectrum is a part of this input but from the formal point of view various types of spectra should be considered. Let S(Q) denote the spectrum of DNA sequence Q. As mentioned in Section 1 it is a set of all l-mers obtained as a result of the hybridization experiment. The spectrum may contain some errors, i.e. there may be some l-mers distinguishable in sequence Q which are not elements of S(Q) (negative errors). Moreover, S(Q) may contain some l-mers which are not present in Q (positive errors). A variant of the spectrum which contains all and only those types of l-mers which are distinguishable in target sequence Q is called an ideal spectrum and is denoted by S
                     (is)(Q). It should be noted that S
                     (is)(Q) is a set, so it contains all types of l-mers being parts of Q but each of them only once. A multiset containing all l-mers distinguishable in sequence Q (not only all types of l-mers), denoted as S
                     (im)(Q), is called an ideal multispectrum of Q. A set denoted by S
                     (m)(Q) is called a multispectrum of sequence Q. The multispectrum corresponds to the results of the real hybridization experiment, where some information about repetitions is available. Hence, it may contain errors following from the imperfectness of the hybridization process and from the limited precision of the information about repetitions.

For every s
                     
                        i
                     
                     ∈
                     S(Q) let m
                     
                        i
                      be a parameter whose value corresponds to the number of occurrences of s
                     
                        i
                      in S
                     (m)(Q). To be more precise, in the case, where the information about repetitions is not available, for each s
                     
                        i
                     
                     ∈
                     S(Q), m
                     
                        i
                     
                     =1. When there is available the information of the type “one and many”, if s
                     
                        i
                      appears in S
                     (m)(Q) once, then m
                     
                        i
                     
                     =1 and if s
                     
                        i
                      appears in S
                     (m)(Q) more than once, then m
                     
                        i
                     
                     =2. In the case where the multiplicity information is of the type “one, two and many”, m
                     
                        i
                     
                     =1 if s
                     
                        i
                      appears in S
                     (m)(Q) once, m
                     
                        i
                     
                     =2 if s
                     
                        i
                      appears in S
                     (m)(Q) two times and m
                     
                        i
                     
                     =3 if s
                     
                        i
                      appears in S
                     (m)(Q) more than two times. Let us also define function 
                        u
                        :
                        
                           Σ
                           DNA
                           *
                        
                        ×
                        
                           Σ
                           DNA
                           *
                        
                        →
                        
                           
                              ℕ
                           
                        
                     , u(Q′, s
                     
                        i
                     ) is a number of occurrences of s
                     
                        i
                      in Q′, where Σ
                        DNA
                     
                     ={A, C, G, T} is an alphabet of DNA sequences. Moreover, let 
                        U
                        (
                        
                           Q
                           ′
                        
                        )
                        =
                        
                           ∑
                           
                              
                                 s
                                 i
                              
                              ∈
                              S
                              (
                              Q
                              )
                           
                        
                        u
                        (
                        
                           Q
                           ′
                        
                        ,
                        
                           s
                           i
                        
                        )
                     .

Let us consider three variants of the sequencing problem differing by the available information about repetitions. In all of these variants there may be errors of arbitrary types and the following relations hold: S(Q)⊆
                     S
                     (m)(Q) and S
                     (is)(Q)⊆
                     S
                     (im)(Q).

In the first problem the information about repetitions is not available. This problem can be formulated in the following way.


                     
                        Problem 1
                        (SBH without information about repetitions and with errors of arbitrary types – search version)


                           Instance: set S(Q), length n of sequence Q.


                           Answer: sequence Q′ of length n with the maximum value of U(Q′).

In the second problem the information about repetitions is of the type “one and many”. This problem can be formulated as follows.


                     
                        Problem 2
                        (SBH with information about repetitions of the type “one and many” and with errors of arbitrary types – search version)


                           Instance: set S(Q), length n of sequence Q, parameter m
                           
                              i
                           
                           ∈{1, 2} for each s
                           
                              i
                           
                           ∈
                           S(Q).


                           Answer: sequence Q′ of length n with the maximum value of U(Q′) and such that for every s
                           
                              i
                           
                           ∈
                           S(Q) 
                              
                                 min
                                 i
                              
                              ≤
                              u
                              (
                              
                                 Q
                                 ′
                              
                              ,
                              
                                 s
                                 i
                              
                              )
                              ≤
                              
                                 max
                                 i
                              
                           , where 
                              
                                 min
                                 i
                              
                              =
                              0
                            and 
                              
                                 max
                                 i
                              
                              =
                              1
                            if m
                           
                              i
                           
                           =1 and 
                              
                                 min
                                 i
                              
                              =
                              1
                            and 
                              
                                 max
                                 i
                              
                              =
                              n
                              −
                              l
                              +
                              1
                            if m
                           
                              i
                           
                           =2.

In the third problem the information about repetitions is of the type “one, two and many”. The formulation of the problem is as follows.


                     
                        Problem 3
                        (SBH with information about repetitions of the type “one, two and many” and with errors of arbitrary types – search version)


                           Instance: set S(Q), length n of sequence Q, parameter m
                           
                              i
                           
                           ∈{1, 2, 3} for each s
                           
                              i
                           
                           ∈
                           S(Q).


                           Answer: sequence Q′ of length n with the maximum value of U(Q′) and such that for every s
                           
                              i
                           
                           ∈
                           S(Q) 
                              
                                 min
                                 i
                              
                              ≤
                              u
                              (
                              
                                 Q
                                 ′
                              
                              ,
                              
                                 s
                                 i
                              
                              )
                              ≤
                              
                                 max
                                 i
                              
                           , where 
                              
                                 min
                                 i
                              
                              =
                              0
                            and 
                              
                                 max
                                 i
                              
                              =
                              1
                            if m
                           
                              i
                           
                           =1, and 
                              
                                 min
                                 i
                              
                              =
                              1
                            and 
                              
                                 max
                                 i
                              
                              =
                              2
                            if m
                           
                              i
                           
                           =2, and 
                              
                                 min
                                 i
                              
                              =
                              2
                            and 
                              
                                 max
                                 i
                              
                              =
                              n
                              −
                              l
                              +
                              1
                            if m
                           
                              i
                           
                           =3.

Since all of these problems are NP-hard in the strong sense (Błażewicz and Kasprzak, 2003; Formanowicz, 2005, 2005) heuristic approaches for solving them are well justified. In the next section one of the methods of this type will be proposed to solve the problems. It should be noted that in many cases the starting oligonucleotide is known, so this information can be exploited by an algorithm. This, however, does not change the complexity of the problems since in the case when this oligonucleotide is not known the algorithm can be run polynomial number of times – each time with a different starting oligonucleotide.

The ant colony optimization algorithm (ACO) presented in this paper is based on the heuristics developed in (Blum et al., 2008). It has been extended to take into account the multiplicity information (cf. Kwarciak and Formanowicz, 2012; Kwarciak, 2014).

ACO is a probabilistic, iterative approach to solve a problem whose goal is to find a path in a graph. There are two types of solutions constructed in each iteration: forward and backward. The forward solution is developed from the first node in a path and it is extended by appending next nodes at the end of the current solution. Initially, the backward solution contains the last path node and it is developed by inserting next nodes at the beginning of the current solution.

The foundation of the probabilistic solution construction is a pheromone model F. It is a set of values which codes the knowledge collected during a computation performed up to now. It contains pheromone value τ
                        
                           ij
                         for each pair of oligonucleotides i, j
                        ∈
                        S(Q). The higher the pheromone value τ
                        
                           ij
                        , the more desirable occurrence of j directly after i in the constructed solutions. Additionally, F contains values τ
                        0i
                         and τ
                        
                           i0 for each i
                        ∈
                        S(Q). They represent the desirability that i is the first l-mer or the last l-mer in the target sequence, respectively.

The pheromone model is updated after each iteration using the best solutions found so far. Subsequently, it is checked if the algorithm reached convergence, i.e. if the constructed solutions are too similar to each other. If yes then the pheromone values are reset to the initial ones and the algorithm is restarted. The pheromone values are in interval [τ
                        
                           min
                        , τ
                        
                           max
                        ]. Thus, the implemented approach is Max-Min Ant System (MMAS).

The algorithm uses the following data structures (cf. (Blum et al., 2008)):
                           
                              •
                              the iteration-best solution p
                                 
                                    ib
                                 : the best solution constructed in the current iteration,

the restart-best solution p
                                 
                                    rb
                                 : the best solution constructed since the last restart of the algorithm,

the best-so-far solution p
                                 
                                    bs
                                 : the best solution constructed during the whole computation,

the convergence factor λ, 0≤
                                 λ
                                 ≤1: the measure of the algorithm convergence,

the binary variable convergent: it is set to true when the algorithm reaches convergence.

All variables are initialized at first. λ
                        =0 and all pheromone values are equal to 0.5. There are n
                        
                           f
                         forward solutions and n
                        
                           b
                         backward solutions generated in each iteration (see Section 3.2). The best of them is set as p
                        
                           ib
                        . Additionally, if solutions p
                        
                           rb
                         and p
                        
                           bs
                         are empty or are worsen than solution p
                        
                           ib
                         then they are updated using p
                        
                           ib
                        .

Two criteria are used to compare solutions. Firstly, the more preferable is the solution containing more l-mers (the path consisting of greater number of nodes). In other words, despite positive and negative errors in the spectrum, we assume that the more elements from it will be used, the better the result will be. Secondly, if two solutions contain the same number of oligonucleotides then the more desirable is the solution representing shorter DNA sequence (the path with lower cost). The shorter the DNA sequence related to the current solution, the higher the chance to extend it by including some additional oligonucleotides and to improve the score according to the first criterion. This is based on a simple observation: when one wants to construct a sequence of a given length, choosing a shorter one containing the same number of elements from spectrum as some other sequence gives the algorithms a chance to extend it later if necessary (e.g., by using oligonucleotides from the set, which is described in Section 3.2).

The next step of each iteration is to update the pheromone model F and the convergence factor λ. Subsequently, if λ
                        >0.9999 and the variable convergent is false then the variable convergent is set to true and the next iteration is executed. If λ
                        >0.9999 and the variable convergent is true then the algorithm is restarted. All values of pheromone model F are set to the initial one equal to 0.5. The restart-best solution p
                        
                           rb
                         is cleared and the variable convergent is set to false.

The algorithm stops after a given number of iterations without improvement of p
                        
                           bs
                        . Then, the best-so-far solution p
                        
                           bs
                         is returned by the algorithm.

Forward and backward solutions are generated by a greedy heuristic which uses the pheromone model F. The greedy algorithm is a combination of two algorithms presented in (Blum et al., 2008; Kwarciak and Formanowicz, 2011). However, an additional information about multiplicity is available and must be processed.

Solution construction starts from the first l-mer of an analyzed sequence and next oligonucleotides are appended at the end of the current solution. The number of occurrences in the current solution is maintained for each oligonucleotide. If it reaches the maximum value defined by the parameter m
                        
                           i
                         then the oligonucleotide i is not taken into account during selection of the next solution element. Let 
                           
                              
                                 S
                                 ˆ
                              
                           
                           ⊆
                           S
                           (
                           Q
                           )
                         denote the set of all l-mers for which the maximum number of occurrences has not been reached yet and they may be included into the current solution.

The parameter m
                        
                           i
                         and a given multiplicity information model determine the minimum number of occurrences of each oligonucleotide in the final solution. There is a reserve R maintained to fulfill this requirement. It is the cost of appending at the end of the current solution all l-mers for which the minimum utilization has not been reached yet. They are elements of set. The reserve is calculated assuming the following appending order of these oligonucleotides. The first one is chosen randomly. The next l-mers are selected using a greedy approach, i.e. the best overlapped oligonucleotide is chosen. Note that only multiple l-mers for which the current usage is less than the minimum are taken into account in this subroutine. The whole process is represented in a graphical form in Fig. 1
                        .

The process of adding next l-mers to the current solution stops when appending the next element would lead to a solution corresponding to a sequence longer than the expected length n decreased by the current reserve value. Finally, if there are any oligonucleotides which should be included to satisfy the minimum utilization constraint then they are appended. They are included at the end of the current solution in the same order which has been used to calculate the reserve. Pheromone model updates and the convergence factor are calculated in the same way as in (Blum et al., 2008).

The multilevel paradigm has been presented in (Walshaw, 2004). It has been used to develop a multilevel version of an ant colony optimization algorithm for the classical SBH (Blum et al., 2008). The algorithm presented in this section is its extended version which is able to take into account the multiplicity information according to models “one and many” and “one, two and many”. Other differences are discussed in the last paragraph of this section.

The multilevel approach is a simple one. The original instance is recursively coarsened until some stopping conditions are satisfied. A hierarchy of reduced instances is constructed as a result. The next level instance is always smaller than the previous level one. The solution is then computed on the smallest level instance and transformed to a previous (larger) level. This procedure is continued until a solution for the original problem instance is obtained.

The above idea has been applied as follows. Firstly, the hierarchy of reduced instances is obtained by concatenating overlapped oligonucleotides into longer sequences. The higher the coarsening level, the shorter overlapping required to combine them (see Section 3.3.1). Next, the ACO algorithm presented in Section 3.1 is used to obtain an initial solution. It is constructed for the smallest instance. Afterward, the iterative refinement process is performed. The current ith level solution p
                        
                           i
                         is transformed to the previous (i
                        −1)th level solution p
                        
                           i−1 (see Section 3.3.2) and the same ACO algorithm is used to refine p
                        
                           i−1. It works exactly as described in Section 3.1 but, initially, the best solution found so far p
                        
                           bs
                         is not empty and it is set to p
                        
                           i−1. The iterative routine stops after the refinement of solution p
                        0 which represents the original instance solution. The multilevel ACO returns the refined p
                        0 as a result.

The multilevel ACO algorithm described in (Blum et al., 2008) uses a predefined maximum CPU time limit as one of stopping conditions. However, the variant of the algorithm presented in this paper solves the problem for the longest tested sequences (i.e. 509 bp) without any time constraint in about 2–3s. Thus, the algorithm has been simplified and the maximum time limit is not used. Additionally, the instance contraction subroutine presented in (Blum et al., 2008) does not store any tracking information about combined elements which could be used to transform a reduced instance solution to a previous level solution. It has not been stated precisely how to perform this transformation, therefore comparing both algorithms is more difficult.

The foundation of the multilevel approach is an instance coarsening. The goal is to generate a sequence of smaller and smaller problem instances. An instance representation is progressively contracted by combining oligonucleotides into growing subsequences which most probably are the subsequences of a target DNA sequence. A spectrum size is limited and a corresponding graph is reduced as a result too because nodes representing combined l-mers are replaced by new combined nodes (cf. Blum et al., 2008).

Let 
                              
                                 S
                                 ¯
                              
                              (
                              Q
                              )
                            denote the spectrum containing combined l-mers, 
                              
                                 x
                                 ¯
                              
                              ∈
                              
                                 S
                                 ¯
                              
                              (
                              Q
                              )
                            and 
                              
                                 y
                                 ¯
                              
                              ∈
                              
                                 S
                                 ¯
                              
                              (
                              Q
                              )
                            denote combined oligonucleotides representing subsequences and s
                           
                              i
                           
                           ∈
                           S(Q) be the last l-mer in the subsequence of 
                              
                                 x
                                 ¯
                              
                            and s
                           
                              j
                           
                           ∈
                           S(Q) be the first l-mer in the subsequence of 
                              
                                 y
                                 ¯
                              
                           . The cost 
                              
                                 
                                    c
                                    ¯
                                 
                                 mn
                              
                            of the arc from node representing 
                              
                                 x
                                 ¯
                              
                            to node representing 
                              
                                 y
                                 ¯
                              
                            in the reduced graph is equal to c
                           
                              ij
                           , i.e. the cost of the arc from node representing s
                           
                              i
                            to node representing s
                           
                              j
                            in the original graph. Let 
                              
                                 x
                                 ¯
                              
                              =
                              {
                              
                                 s
                                 
                                    
                                       i
                                       1
                                    
                                 
                              
                              ,
                              
                                 s
                                 
                                    
                                       i
                                       2
                                    
                                 
                              
                              ,
                              …
                              ,
                              
                                 s
                                 
                                    
                                       i
                                       t
                                    
                                 
                              
                              }
                            and 
                              len
                              (
                              
                                 x
                                 ¯
                              
                              )
                            represent the length of the combined oligonucleotide 
                              
                                 x
                                 ¯
                              
                           .
                              
                                 (1)
                                 
                                    len
                                    (
                                    
                                       x
                                       ¯
                                    
                                    )
                                    =
                                    l
                                    +
                                    
                                       ∑
                                       
                                          k
                                          =
                                          2
                                       
                                       
                                          k
                                          =
                                          t
                                       
                                    
                                    
                                       c
                                       
                                          
                                             
                                                i
                                                
                                                   k
                                                   −
                                                   1
                                                
                                             
                                          
                                          
                                             i
                                             k
                                          
                                       
                                    
                                 
                              
                           Note that the combined oligonucleotide length depends on how well its l-mers are overlapped. It is also required to redefine the best successor and the best predecessor of 
                              
                                 x
                                 ¯
                              
                           :
                              
                                 (2)
                                 
                                    pre
                                    (
                                    
                                       x
                                       ¯
                                    
                                    )
                                    =
                                    argmin
                                    {
                                    
                                       
                                          c
                                          ¯
                                       
                                       nm
                                    
                                    |
                                    
                                       x
                                       ¯
                                    
                                    ,
                                    
                                       y
                                       ¯
                                    
                                    ∈
                                    
                                       S
                                       ¯
                                    
                                    (
                                    Q
                                    )
                                    ,
                                    
                                       x
                                       ¯
                                    
                                    ≠
                                    
                                       y
                                       ¯
                                    
                                    }
                                    ,
                                 
                              
                           
                           
                              
                                 (3)
                                 
                                    suc
                                    (
                                    
                                       x
                                       ¯
                                    
                                    )
                                    =
                                    argmin
                                    {
                                    
                                       
                                          c
                                          ¯
                                       
                                       mn
                                    
                                    |
                                    
                                       x
                                       ¯
                                    
                                    ,
                                    
                                       y
                                       ¯
                                    
                                    ∈
                                    
                                       S
                                       ¯
                                    
                                    (
                                    Q
                                    )
                                    ,
                                    
                                       x
                                       ¯
                                    
                                    ≠
                                    
                                       y
                                       ¯
                                    
                                    }
                                    .
                                 
                              
                           Let define the set of best predecessors 
                              
                                 
                                    S
                                    ¯
                                 
                                 
                                    pre
                                    (
                                    
                                       x
                                       ¯
                                    
                                    )
                                 
                              
                            of 
                              
                                 x
                                 ¯
                              
                            and the set of best successors 
                              
                                 
                                    S
                                    ¯
                                 
                                 
                                    suc
                                    (
                                    
                                       x
                                       ¯
                                    
                                    )
                                 
                              
                            of 
                              
                                 x
                                 ¯
                              
                            as:
                              
                                 (4)
                                 
                                    
                                       
                                          S
                                          ¯
                                       
                                       
                                          pre
                                          (
                                          
                                             x
                                             ¯
                                          
                                          )
                                       
                                    
                                    =
                                    {
                                    
                                       y
                                       ¯
                                    
                                    ∈
                                    
                                       S
                                       ¯
                                    
                                    (
                                    Q
                                    )
                                    |
                                    
                                       
                                          c
                                          ¯
                                       
                                       nm
                                    
                                    =
                                    
                                       
                                          c
                                          ¯
                                       
                                       
                                          pre
                                          (
                                          
                                             x
                                             ¯
                                          
                                          )
                                          
                                          m
                                       
                                    
                                    }
                                    ,
                                 
                              
                           
                           
                              
                                 (5)
                                 
                                    
                                       
                                          S
                                          ¯
                                       
                                       
                                          suc
                                          (
                                          
                                             x
                                             ¯
                                          
                                          )
                                       
                                    
                                    =
                                    {
                                    
                                       y
                                       ¯
                                    
                                    ∈
                                    
                                       S
                                       ¯
                                    
                                    (
                                    Q
                                    )
                                    |
                                    
                                       
                                          c
                                          ¯
                                       
                                       mn
                                    
                                    =
                                    
                                       
                                          c
                                          ¯
                                       
                                       
                                          m
                                          
                                          suc
                                          (
                                          
                                             x
                                             ¯
                                          
                                          )
                                       
                                    
                                    }
                                    .
                                 
                              
                           
                        

Initially, each combined oligonucleotide is a sequence of one l-mer from S(Q). The following criteria have to be satisfied to join two oligonucleotides (sequences of l-mers) 
                              
                                 x
                                 ¯
                              
                            and 
                              
                                 y
                                 ¯
                              
                            (cf. Blum et al., 2008):
                              
                                 •
                                 
                                    
                                       
                                          x
                                          ¯
                                       
                                     is the unique best predecessor of 
                                       
                                          y
                                          ¯
                                       
                                    , i.e. 
                                       pre
                                       (
                                       
                                          y
                                          ¯
                                       
                                       )
                                       =
                                       
                                          x
                                          ¯
                                       
                                     and 
                                       |
                                       
                                          
                                             S
                                             ¯
                                          
                                          
                                             pre
                                             (
                                             
                                                y
                                                ¯
                                             
                                             )
                                          
                                       
                                       |
                                       =
                                       1
                                    ,


                                    
                                       
                                          y
                                          ¯
                                       
                                     is the unique best successor of 
                                       
                                          x
                                          ¯
                                       
                                    , i.e. 
                                       suc
                                       (
                                       
                                          x
                                          ¯
                                       
                                       )
                                       =
                                       
                                          y
                                          ¯
                                       
                                     and 
                                       |
                                       
                                          
                                             S
                                             ¯
                                          
                                          
                                             suc
                                             (
                                             
                                                x
                                                ¯
                                             
                                             )
                                          
                                       
                                       |
                                       =
                                       1
                                    ,


                                    
                                       
                                          x
                                          ¯
                                       
                                     and 
                                       
                                          y
                                          ¯
                                       
                                     occur in a target sequence once, i.e. 
                                       
                                          m
                                          
                                             
                                                x
                                                ¯
                                             
                                          
                                       
                                       =
                                       1
                                     and 
                                       
                                          m
                                          
                                             
                                                y
                                                ¯
                                             
                                          
                                       
                                       =
                                       1
                                    ,


                                    
                                       
                                          x
                                          ¯
                                       
                                     and 
                                       
                                          y
                                          ¯
                                       
                                     do not represent the sequence containing the first l-mer of Q (if given).

If 
                              
                                 x
                                 ¯
                              
                            and 
                              
                                 y
                                 ¯
                              
                            may be joined then two crucial actions are performed. Firstly, the sequence of l-mers represented by 
                              
                                 y
                                 ¯
                              
                            is appended at the end of the sequence of 
                              
                                 x
                                 ¯
                              
                           . Secondly, the information about joined oligonucleotides is stored in variable 
                              
                                 composition
                                 
                                    
                                       x
                                       ¯
                                    
                                 
                                 level
                              
                           . It will be used to transform a solution for a reduced instance to a solution for the previous level (see Section 3.3.2). Note that variables composition are maintained for each level independently.

If for a given cost any two oligonucleotides have been joined then the next level instance is created. If a combined oligonucleotide is longer than the expected sequence length n then joining oligonucleotides is not performed any more and the subroutine stops. The process is also finished after combining oligonucleotides for cost=
                           l
                           −1 (Blum et al., 2008).

Algorithm 1 presents the transformation of a solution. The output of the instance coarsening procedure contains a set of reduced instances and variables named composition. These variables store information which elements have been joined on a given reduction level. They are used to perform transformation of ith level solution p
                           
                              i
                            to a previous level solution p
                           
                              i−1. Combined oligonucleotides from p
                           
                              i
                            are replaced by a sequence of combined oligonucleotides included in variables composition defined for level i.


                           
                              
                                 
                                    
                                    
                                       
                                          Algorithm 1. Solution transformationRequire: 
                                             i-th level solution 
                                                
                                                   p
                                                   i
                                                
                                                =
                                                {
                                                
                                                   
                                                      x
                                                      ¯
                                                   
                                                   1
                                                
                                                ,
                                                
                                                   
                                                      x
                                                      ¯
                                                   
                                                   2
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   
                                                      x
                                                      ¯
                                                   
                                                   
                                                      
                                                         t
                                                         i
                                                      
                                                   
                                                
                                                }
                                             , i-th level 
                                                
                                                   composition
                                                   
                                                      
                                                         x
                                                         ¯
                                                      
                                                   
                                                   i
                                                
                                              for each i-th level combined oligonucleotide 
                                                
                                                   x
                                                   ¯
                                                
                                             
                                          
                                       
                                       
                                          
                                              1: p
                                             
                                                i−1
                                             :=∅
                                       
                                       
                                          
                                              2: for 
                                             j
                                             =1to
                                             t
                                             
                                                i
                                              
                                             do
                                          
                                       
                                       
                                          
                                              3:   
                                                
                                                   p
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                :
                                                =
                                                
                                                   p
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                
                                                |
                                                
                                                   composition
                                                   
                                                      
                                                         
                                                            x
                                                            ¯
                                                         
                                                         j
                                                      
                                                   
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          
                                              4: end for
                                          
                                       
                                       
                                          
                                             Ensure: (i
                                             −1)th level solution p
                                             
                                                i−1
                                          
                                       
                                    
                                 
                              
                           
                        

The general idea of the multilevel ACO approach to a sequence reconstruction is given in a graphical form in Fig. 2
                           .

All experiments described in this section have been performed on a PC with Intel Core 2 Duo processor (T8100, 2.1 GHz), 3GB RAM and Windows XP operating system. The algorithm has been implemented using C#, so Microsoft.NET 3.5 framework is required to execute it.

The ant colony optimization algorithm has been configured as follows: the number of forward generated solutions (forward ant count) n
                     
                        f
                     
                     =3, the number of backward generated solutions (backward ant count) n
                     
                        b
                     
                     =3, the restricted candidate list size k
                     =10, the determinism rate q
                     =0.9, the learning rate ρ
                     =0.1, the maximum number of iterations without improvement of p
                     
                        bs
                     
                     =100, the minimum pheromone value τ
                     
                        min
                     
                     =0.01, the maximum pheromone value τ
                     
                        max
                     
                     =0.99. The values of the parameters are the same as those used in (Blum et al., 2008). Assuming the same values allows comparing both approaches, i.e., the algorithms for the problem without information about repetitions and the ones proposed in this paper for the problems with such information, at least to some extent. The details concerning methodology of tuning those parameters are given in (Blum and Vallès, 2006).

The presented ACO algorithms are compared with the tabu and scatter search algorithm for the SBH with the multiplicity information available (Kwarciak and Formanowicz, 2014). The following parameters have been used by the tabu and scatter search algorithm: the restart count=15, the number of cycles of condensing and extending moves=300, the reference set size=8, the minimum number of moves before reference set update=10, the tabu list size=10, the number of condensing moves without any improvement of the global criterion function=2 and the number of extending moves=4.

The biochemical stage of SBH utilizes a large number of copies of an analyzed DNA sequence. Usually, they are prepared using the polymerase chain reaction (PCR) which requires the knowledge of the first l-mer of the sequence. Thus, as stated earlier, the algorithms have been tested mostly using the first l-mer as a part of an input. If not then it is mentioned in an experiment description.

Reconstructed sequences have been compared with real sequences using the global alignment Needleman–Wunsch algorithm (Waterman, 1995). Its parameters have been set as follows: match (the same nucleotides) +1, mismatch (different nucleotides) −1, insertion/deletion (a nucleotide in one sequence and a gap in the second sequence) −1. A solution the same as the target gains the highest similarity score equal to the number of nucleotides in the sequence.

Several experiments have been performed. Each of them uses a different data set. The first test set, called A, has been proposed in (Błażewicz et al., 2004). It contains 40 DNA sequences coding human proteins of length from 109 to 509 nucleotides. The sequences are free of repetitions and their spectra have been generated for oligonucleotides of length l equal to 10. Moreover, the spectra contain 20% negative errors and 20% positive errors and the first l-mer is unknown. The experiment has been performed to compare both ant colony optimization algorithms presented in this paper with: the tabu and scatter search for the classical SBH (Błażewicz et al., 2004), the tabu and scatter search taking into account the multiplicity information (Kwarciak and Formanowicz, 2014), the basic ACO for the classical SBH (Blum et al., 2008) and the multilevel ACO for the classical SBH (Blum et al., 2008). The algorithms incorporate some randomness so computations have been repeated 10 times for each sequence in the test set and average values are shown. However, it does not apply to the tabu and scatter search for the classical SBH. In this case, the values from (Błażewicz et al., 2004) are presented. One should also note that the results described in (Blum et al., 2008) have been obtained in a different way. The computation have been also repeated 10 times for each sequence. However, the values have been not averaged but the best result has been chosen. Consequently, most of the results are comparable only to some extent. Only the time complexity of the algorithms (i.e. a normalized computation time) is suitable for comparison.

The results of the first experiment (set A) are presented in Tables 1
                      and 2
                     . The following values are shown in the first table. The quality of a solution describes how many l-mers from a spectrum have been utilized. The test set consist of 40 sequences of each length so the maximum number of optimal solutions for each length is 40. The perfect reconstruction count indicates how many of the obtained sequences were the same as a target one (the maximum is 40). The two above numbers are fractional because computations for each sequence from the test set have been repeated 10 times and all results have been averaged. The similarity is the score returned by the alignment algorithm (with maximum values from 109 to 509). The similarity has been computed in percentages too (with maximal value equal to 100% if both sequences are the same). Finally, the computation time is shown.


                     Table 2 contains a normalized computation time for all tested algorithms. Each row presents values for one algorithm. They have been normalized by dividing the computation time for a given spectrum size by the computation time for the smallest spectrum size. One can see the growth of the computation time when the spectrum size becomes bigger.

The new multilevel ACO algorithm outperforms both tabu and scatter search algorithms and the basic ACO algorithm presented in this paper. The number of optimal solutions has been significantly increased. The average quality and the average similarity is higher too. However, the results for the basic ACO algorithm are not so spectacular as described in (Blum et al., 2008). The number of optimal solutions is the lowest one. The average similarity and the number of perfectly reconstructed sequences are close to the results for the tabu and scatter search using the multiplicity information.

The execution of the new ACO algorithms requires one order of magnitude less time than in the case of the tabu and scatter search using the multiplicity information. Moreover, the application of the multilevel paradigm enables to reduce the computation time of the basic ACO algorithm by about 42% (the average for all spectrum sizes). The results presented in Tables 1 and 2 and in (Błażewicz et al., 2004; Blum et al., 2008) have been obtained using different machines. They have been normalized to enable comparison. The multilevel ACO algorithm is the best one according to this criterion too. One should note the huge difference between computation times for ACO algorithms presented in (Blum et al., 2008) and the ACO algorithms presented in this paper. Although the general ideas are the same the difference is outstanding.

One more remark should be made about the results presented in Table 1. The tabu and scatter with multiplicity algorithm provides better results than the simple tabu and scatter method, while in fact the sequences from set A contain no repetitions. The tabu and scatter with multiplicity used in our tests is a significant modification of the algorithm described in (Błażewicz et al., 2004). There are many new additions in our version of the algorithm, apart from using multiplicity information (if it is available). This explains the difference in results between both tabu algorithms. The full description of improvements of the new tabu and scatter search algorithm is provided in (Kwarciak and Formanowicz, 2014).

The second test set, called B, contains 59 real DNA sequences of length 509 nucleotides. They contain from 1 to 32 natural repetitions. Their spectra have been generated for oligonucleotides of length l equal to 10 and they are affected only by repetitions (no hybridization errors). This data set has been used for the first time in (Błażewicz et al., 2005) to examine two algorithms developed for the classical SBH: the hybrid genetic algorithm (Błażewicz et al., 2002) and the tabu and scatter search algorithm (Błażewicz et al., 2004). Originally, the spectra did not contain any information about repetitions. They have been updated and the multiplicity information according to the model “one, two and many” has been introduced to evaluate the tabu and scatter search algorithm using the multiplicity information (Kwarciak and Formanowicz, 2014).

The results for this set have been shown in Table 3
                     . The only source of spectra errors are repetitions so the optimal value for the classical sequencing by hybridization is equal to the ideal spectrum size (see definition in Section 2). The sequences contain various numbers of repetitions so each sequence has its own optimal quality value. Thus, the average optimal quality has been computed. The algorithms taking into account the multiplicity information may use some oligonucleotides more than once so the quality of a reconstructed sequence may be greater than the size of ideal spectrum. Therefore, the optimal quality for these algorithms has been set equal to the ideal multispectrum size (see definition in Section 2). The number of reconstructed sequences which quality is equal to the optimal quality is shown in a row called Optimal Solutions. It has been also verified if an obtained sequence is the same as a target one and the number of perfectly reconstructed sequences is presented in the fourth row. Afterward, the average similarity is presented. The last row contains information about computation time.

The computations of algorithms using the multiplicity information have been performed 10 times for each sequence in the set and average values are presented. The values for the algorithms for the classical SBH comes from (Błażewicz et al., 2005), where each sequence has been reconstructed only once. Their computation time is not presented because a different machine has been used to obtain them.

The multilevel ant colony optimization algorithm generates greater number of optimal solutions than the hybrid genetic algorithm (Błażewicz et al., 2002) but the number is worsen than in the case of both tabu and scatter search algorithms (Błażewicz et al., 2004; Kwarciak and Formanowicz, 2014). The average similarity and the number of perfectly reconstructed sequences of multilevel ACO are also lower in comparison with the tabu and scatter search using the multiplicity information (Kwarciak and Formanowicz, 2014). The advantage of the new multilevel ACO is the computation time, i.e. the tabu and scatter search taking into account the information about repetitions requires about 50% more time.

The third data set, called C, has been used in (Błażewicz et al., 2006) to evaluate a revised hybrid genetic algorithm. It consists of 40 DNA sequences coding human proteins. The sequence length is 600 nucleotides and each sequence contains from 1 to 17 natural repetitions (the average is 4). The set is divided into four parts: C.1, C.2 for the classical libraries, and C.3 and C.4 for the isothermic libraries. Details concerning creation of spectra containing oligonucleotides from the isothermic libraries will be given before the results for the subsets C.3 and C.4. The first part, called C.1, contains spectra affected only by repetitions. The second part, called C.2, consist of spectra with additional 5% of random positive errors and additional random negative errors up to 5% (i.e. the total amount of negative errors coming from repetitions and imperfect hybridization is 5%). The oligonucleotide length l is equal to 10. The spectra have been updated and the multiplicity information according to the model “one, two and many” has been introduced in (Kwarciak and Formanowicz, 2014). The extended spectra with the partial information about repetitions have been used in this experiment. The results have been shown in Table 4
                      (set C.1) and Table 5
                      (set C.2). They contain the same information as Table 3 described above. The computations for the algorithms using the multiplicity information have been also repeated 10 times and average values are presented. The results for the algorithms developed for the classical SBH approach come from (Błażewicz et al., 2006), where each sequence has been reconstructed only once.

In the case of set C.1, the tabu and scatter search algorithm using the multiplicity information (Kwarciak and Formanowicz, 2014) generates the best solutions. Its number of optimal solutions, number of perfectly reconstructed sequences and average similarity score are the highest ones. The new multilevel ACO algorithm performs slightly better than the revised hybrid genetic algorithm (Błażewicz et al., 2006), i.e. the average similarity score is higher by 0.47% and the averaged number of perfectly reconstructed solutions is greater by 0.5. In the case of set C.2, the new multilevel ant colony optimization algorithm gains the highest score almost on all criteria. Only the average similarity score of the revised hybrid genetic algorithm is better (i.e. higher by 0.5%). One should note that the new ACO algorithm performance does not depend on the introduced errors simulating imperfect hybridization. Indicators like perfect reconstruction or average similarity for set C.2 are similar to the values for set C.1, while the average quality is a few percent worse for the C.1. The revised hybrid genetic algorithm works similarly. However, the hybridization errors lead to worsen performance of the tabu and scatter search. The number of optimal solutions and the number of perfectly reconstructed sequences have been decreased and the computation time has been doubled.

In (Błażewicz et al., 2006) apart from the results for the algorithms prepared for the classical SBH, the results for the hybrid genetic algorithm using spectra obtained on the basis of the isothermic libraries have also been given.

For sequence in set C spectra containing oligonucleotides from the isothermic libraries have been generated. These two isothermic libraries had temperatures 26∘
                     C and 28∘
                     C - such two libraries have a similar cardinality as one classical library composed of oligonucleotides with length equal to 10 (Błażewicz et al., 2004; Błażewicz et al., 2006). In set C.3 only negative errors following from repetitions have been considered, while for set C
                     .4 5% of positive errors and 5% of negative errors of both types (in total) have been generated. Tables 6
                      (set C.3) and 7
                      (set C.4) present the results in the same manner as Tables 4 and 5.

As one can see, for C.3 test set the best results have been provided by tabu and scatter search algorithm taking into account the multiplicity information. Both multilevel ACO and tabu have better results than Hybrid GA. Tabu and scatter search algorithm has a slightly better results in terms of average quality and similarity. In C.4 test set the multilevel ACO algorithm outperforms tabu and scatter search. The results concerning the average similarity score for the Hybrid GA are better than the ones for the tabu and scatter search and slightly better than those obtained by the multilevel ACO.

The most important conclusion however, is that using isothermic libraries for the same sequences leads to much worse results than in a case when classical libraries of oligonucleotides (of equal length) have been used. For the compared algorithms the average similarity dropped by a dozen or so percent, the number of perfect reconstructed sequences for the multilevel ACO dropped from 18.90 to 3.10 (Tables 5 and 7). On the other hand, when isothermic libraries have been used in the discussed tests, the time of computations for the algorithms increased several times. Two explanations can be given here. Firstly, when using isothermic libraries the average number of repetitions increases significantly. For the classical library (having oligonucleotides of size l
                     =10) the average number of repetitions has been equal to 4 while for the isothermic libraries (with temperatures 26°C and 28°C) the average has been equal to 16. The explanation for this fact is given e.g. in (Błażewicz et al., 2006) – isothermic libraries cause fewer experimental errors but they give more repetition errors than standard libraries. This results from the fact that used isothermic libraries (26°C and 28°C, being counterpart for one classical library with oligonucleotides having length of 10) consist of many oligonucleotides shorter than 10 nucleotides (the ones having many GC nucleotides). The second important reason is that ideal multispectrum is greater for the isothermic libraries, resulting in a higher difficulty for the algorithm solving the problem. One can see the difference e.g. in the average quality results (i.e. how many l-mers from a spectrum have been used). For the classical libraries the average quality has been equal to 558–591 oligonucleotides (Tables 4 and 5) while for the isothermic libraries the average quality values have been equal to 732–770 nucleotides (Tables 6 and 7).

One more important explanation for the isothermic libraries results can be given. In general, the main reason for the creation of the isothermic libraries has been the reduction of the number of hybridization errors. For this reason a melting temperature is considered when the probes are created, therefore in the hybridization experiment the DNA can make stronger binding with the probes. It results in stronger and thus easier to interpret hybridization signal. This reduces the hybridization errors, for a price of already mentioned repetitions. In our tests the numbers of hybridization errors are arbitrarily set in order to compare the results with the ones obtained for the classical libraries.

The final test set, called D, has been developed in (Kwarciak and Formanowicz, 2014) to evaluate the tabu and scatter search algorithm which takes into consideration the partial information about repetitions. It consist of real human DNA sequences from GenBank of length 109, 209, 309, 409 and 509 nucleotides. Spectra have been prepared for l-mers of length equal to 10 and they contain 10% random positive errors and 10% random negative errors. Additionally, each sequence contains repetitions leading to additional 5% of negative errors. The data set consist of 40 different sequences of each length and for each sequence 10 spectra have been generated. Thus, the data set contains 400 instances of each length. Computations have been repeated 5 times for each instance and the results have been averaged. Consequently, the outcomes represent 2000 algorithm runs. The first five tables for set D (i.e. Tables 8–12
                     
                     
                     
                     
                     ) present the results for the classical oligonucleotide libraries. Subsequent tables in this section will present the results for the case where isothermic libraries have been used (Tables 13–17
                     
                     
                     
                     
                     ).


                     Tables 8–12 contain the following values. The quality of a solution presents how many l-mers from a multispectrum have been included in a reconstructed sequence. The expected quality is the expected number of utilized multispectrum elements. It is equal to the ideal multispectrum size minus the number of negative errors caused by the imperfect hybridization. Note that algorithms solving any version of SBH problem try to include in a solution as many l-mers as possible. If the information about repetition is available then some of them may be used multiple times and each occurrence is an additional score. In some cases an obtained solution quality may be greater than the expected quality as a result. There are presented both the number of solutions with expected quality and the number of solutions with quality greater than the expected one (rows 2 and 3). The fourth row contains the perfect reconstruction values, while next two rows describe average similarity score given in points and in percentages. For the latter the maximum is 100% if both sequences are the same. The average computation time is shown in the last row.

Two experiments have been performed using set D. The first one verifies an impact of the partial information about repetitions on the quality of sequences reconstructed by the new multilevel ant colony optimization algorithm. The results are shown in Table 8 (no multiplicity information available), Table 9 (the multiplicity model “one and many”) and Table 10 (the multiplicity model “one, two and many”). The additional information about repetitions is very useful. Even using the simplest model “one and many” improves the sequence reconstruction. All measured indicators have been significantly increased and the computation time is the same. The application of the more precise model “one, two and many” leads to a further enhancement but the difference between both multiplicity information models is significantly lower than the difference between the model “one and many” and the case when the partial multiplicity information is not available. One should also note that using the more precise model requires a little bit more time.

The second experiment using set D compares the following algorithms which take into account the partial information about repetitions: the tabu and scatter search (Kwarciak and Formanowicz, 2014), the basic ACO algorithm and the multilevel ACO algorithm. Their results for the multiplicity model “one, two and many” are presented in Table 12, Table 11 and Table 10, respectively. The tabu and scatter search generates solutions with the best quality, i.e. its solutions uses the greatest number of spectrum elements. The total number of solutions with the expected quality and the quality greater than the expected one is also the highest in the case of the tabu and scatter search algorithm. However, the main goal is to solve the biological problem. Using the tabu and scatter search leads to a greater number of perfectly reconstructed sequences than using the basic ant colony optimization but the average similarity score returned by the alignment algorithm is a little bit better in the case of the basic ACO. Moreover, the computation time of the basic ACO is less about 65% (average for all sequence lengths). The application of the multilevel paradigm leads to significant improvement of the basic ACO algorithm. The average solution quality is greater and the number of perfectly reconstructed sequences is closer to the number obtained using the tabu and scatter search algorithm. Most importantly, using the multilevel ACO leads to a significantly better similarity score and to further reduction of computation time, i.e. averagely about 39% less in comparison with the basic ACO and averagely about 80% less in comparison with the tabu and scatter search algorithm. To summarize, the multilevel ACO algorithm is the fastest one. The number of perfectly reconstructed sequences is a little bit lower than in the case of the tabu and scatter search algorithm but the multilevel ACO generates solutions with the highest similarity score.

The next five tables (Tables (13–17) show the results for the same cases, but when the isothermic libraries have been used instead of the classical ones. Tables 13–15 contain the results for the isothermic libraries and multilevel ant colony optimization algorithm with different precision of information about multiplicity. They are the counterparts of Tables 8–10 which have been already discussed. The additional information about repetitions (Tables 14–17) also in this case has a significant positive impact on the results compared with a case without such data (Table 13). When the information about repetitions is available, the average similarity is better and the biggest improvement concerns the perfect reconstruction score. Time needed for computations increased by 15% to 20% if multiplicity information is used, while time difference between two multiplicity models is on the other hand rather insignificant.

However, comparing the results for the classical and isothermic libraries brings a conclusion that using the latter has a negative impact on the results. Average similarity score is always worse while the algorithm requires three to five times more time for computations. When comparing the impact of the multiplicity information separately for both types of libraries, Tables 13–15 show similar improvement of the results as shown in Tables 8–10.


                     Tables 15–17 present the results for two ACO algorithms and tabu search, respectively, where information about multiplicity of the type “one, two and many” is available. In the case when the isothermic libraries are used, tabu and scatter search algorithm is again better in terms of generating better quality solutions. Its average similarity score is however slightly worse, and it requires about two times more time for computations when compared to the ACO algorithms. When these results are compared with the ones given in Tables 10–12 one can see that for a fixed number of hybridization errors the isothermic libraries, especially for the longer sequences, had worse results. Required computation time is also significantly greater for the isothermic approach. As it has been already explained, spectra obtained on the basis of such libraries contain more repetitions and in general – more elements, resulting in an increased difficulty for each of the tested algorithms.

As a final note, an issue of the so-called tandem repetitions should be discussed. Without this type of repetitions the initial solutions generated by the greedy algorithm (which are later send to the metaheuristic algorithm) contain minimal number of repeats of the same oligonucleotides (in accordance to the used multiplicity model, e.g., one, two and many).

Tandem repeats are repetitions of different type. For example, lets consider sequence ACTACTACTACTACT. Depending on the size of the oligonucleotides, ACTACTACT, CTACTACTA and TACTACTAC will be present in the spectrum, and the algorithm will assign them the multiplicity signature ‘many’. In such an example the spectrum will contain three oligonucleotides, and each of them can be used multiple times in a reconstruction.

The process of creation of the solution by our algorithms can be susceptible to the multiple repeating fragments. In order to secure the reconstruction process from a domination of a few elements from spectrum there is an upper bound for the maximal usage of the same oligonucleotide. In the performed experiments this parameter has been set to 10. In some cases however, such a limitation can make the creation of the optimal solution impossible. If the substring consisting of tandem repeats will be long enough, such a part of the reconstructed sequence will never be ideally reconstructed. It should be noted, however, that the issue concerning tandem repeats in sequences is not specific only to our approaches, e.g. ACO or tabu search, but in general it is a common problem for many algorithms trying to reconstruct a DNA sequence from smaller fragments.

@&#CONCLUSION@&#

In this paper a variant of the sequencing by hybridization method, where partial information about substring repetitions is available has been considered. In the classical version of the method this information is not taken into account but the development of DNA chip technology allows for it. However, according to technological constraints only approximate information of this type is available. Hence, in the paper two realistic models of the multiplicity information have been considered. Since sequencing problems with errors and information of repetitions are strongly NP-hard heuristic methods are reasonable approaches for solving them. Hence, an ant colony optimization algorithm has been proposed and tested in an extensive computational experiment for both the classical and the isothermic libraries. Time required by the proposed algorithms is shorter than the computation time of the tabu and scatter search approach. When isothermic libraries have been used, the new ACO algorithm also proved to be better than its tabu counterpart, although the isothermic libraries in a given comparative tests could not show their true potential for the reasons explained in the paper. The results of these tests indicate that the new ACO algorithm outperforms the tabu search method known from the literature, especially for a case when errors other than the ones resulting from repetitions are present in the spectrum.

@&#ACKNOWLEDGEMENTS@&#

This publication has been partially supported by the Polish Ministry of Science and Higher Education under the KNOW program.

@&#REFERENCES@&#

