@&#MAIN-TITLE@&#A case-based design with 3D mesh models of architecture

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Manipulate 3D mesh models of architecture.


                        
                        
                           
                           Recognition of floors, stairs, walls from the mesh models.


                        
                        
                           
                           Representation of the topologies of multi-story buildings.


                        
                        
                           
                           Construct new composition satisfying user-defined topology.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Case-based design

Topology

Segmentation

Synthesis

Mesh

@&#ABSTRACT@&#


               
               
                  This paper presents a case-based design (CBD) focusing on the segmentation of building models and the synthesis of new compositions. Our TRAMMA (Topology Recognition and Aggregation of Mesh Models of Architecture) program is developed as an application of the method. The segmentation includes the recognition of floors, stairs, and walls out of the mesh models. The aggregation process recombines the building segments according to the user-defined topology. The topology representation of multi-story buildings and the spatial synthesis of 3D building models are integrated in the program.
               
            

Case-based reasoning (CBR) has been characterized as a formal methodology for reasoning from experience  [1]. The theory of CBR sheds light on the cycle of retrieving cases, evaluating/adapting the cases in new situations, and storing/retaining the cases  [2,3]. Its significance increases when reasoning from first principles is not adequate in the domain  [4]. Thus this methodology should benefit the field of architectural design as well. However, the subject of CBR in architecture is usually limited to the floor plans rather than the 3D models of buildings. With few exceptions, they only deal with the floor plan layouts with orthogonal walls. These limitations are attributed to the difficulties in indexing various information in buildings. Case indexing is regarded as a key issue in CBR, since it encodes our knowledge of the cases and substantially shapes the way we reuse the cases. People have to decide how to represent and organize the knowledge of the cases (as solutions) and the knowledge of the corresponding problems. As Maher and de Silva Garza  [5] state, “The most important issue when defining a case representation is what information in the design facilitates its reuse”.

It is not easy to establish a general and versatile representation of architecture. There are several reasons. First, the design problems have been regarded as ill-defined problems or “wicked problems”  [6]. More precisely, both the design criteria and the solution space are difficult to be formally defined. Second, there is no general model of architecture that has been widely accepted. Building Information Modeling (BIM)  [7,8] aims to establish a standard modeling platform through integrating various models in the Architecture, engineering and construction (AEC) industry. Nevertheless, various difficulties arise when the distinct designers replace their domain models with the standard BIM model. Thus, some researchers (e.g.  [9]) chose to develop additional software to adopt the BIM standard. Third, architectural design seldom leads to the “query-retrieval” procedure—a list of specifications leads to solutions  [3]. Rather, the process of query, retrieval, evaluation, and adaptation are diffused in the design process.

Case-based design (CBD) has been treated as an application of CBR in design  [5]. Heylighen and Neuckermans  [10] and Richter et al.  [11] reviewed a set of CBD programs for architecture, casting light on the structure and organization of knowledge as well as on the reasoning process (retrieval and manipulation). This section compares a series of CBD programs from two aspects: topology representation and synthesis. Topology representation is essential for formulating the relationship between the rooms in buildings, and subsequently spatial synthesis could use the topology information to adapt and manipulate the cases.

Archie-II  [12] is one of the earliest CBD applications in architecture. It represents each case by floor plan and verbal descriptions. Most CBD approaches caught the geometric information of floor plans; however, they usually assumed that the floor plan is made of rectangles  [13,14] or right-angle polygons  [15]. Alternatively, the recent work by Dillenburger  [16] employed a pixel-based representation of buildings and its environment. Besides, a number of works  [13–15] succeeded in representing the topological configurations of floor plans. For instance, Langenhan  [9] and Weber [17] extracted the topological configurations from BIM models as graphs, benefiting from the semantic information embedded in the model components. Moreover, Grabska et al.  [18] extended the topology of 2D floor plans to the topology of multi-story buildings. Merrell  [19] employs Bayesian networks to learn topological/geometric information from cases (multi-story buildings) and synthesizes 3D buildings according to the learned topology. However, the original topological/geometric information (the training data for the network) is manually encoded from cases. It is important to emphasize that most CBD approaches deal with floor plans instead of 3D models (Table 1
                     ). There have been diverse strategies for manipulating the case for new designs. CADRE  [15] supports both the dimensional adaptation and the topological adaptation. IDIOM  [13] and SEED-Layout  [14] can make new compositions by re-combining the parts of previous floor plans. Intelligent synthesis was a big challenge to the early CBD programs. More sophisticated synthesis usually involves advanced search methods such as evolutionary algorithms, e.g., Rosenman  [20] and de Silva Garza  [21]. The evolutionary process in both programs can manipulate the cases and generate new designs satisfying user-defined objectives. Nevertheless, the synthesis of these programs is conventionally limited to floor plans (Table 1).

The CBD approaches listed above indicate a need for representing and synthesizing multi-story buildings. Thus our TRAMMA program commences with the 3D models of building. The major challenges of the work include: (1) recognition: extracting the topological information from the 3D mesh models, in other words, breaking the model into meaningful parts such as floors, walls, and stairs. (2) synthesis: combining the parts of cases into multi-story buildings that satisfy specified topology. In opposite to the programs in Table 1, our research emphasizes the analysis and manipulation of 3D models of multi-story buildings rather than that of floor plans.

@&#OVERVIEW@&#

The input data of our TRAMMA program (written in Java) is a repository of 3D mesh models of buildings (Fig. 1
                        ). In the stage of recognition, the program extracts the essential structure—floors out of the mesh models. After that the walls and the vertical connections (stairs/slopes) are extracted and indexed according to the floors that they belong to. As a result, the building is represented by a network of nodes (floors) and links (stairs/slopes). The topology between the rooms within a single floor is ignored. Such unconventional representation is not in conflict with the CBD programs in Table 1, because those programs could manipulate each single floor after the TRAMMA program builds the floor structure of the whole buildings.

Every element extracted during the recognition stage consists of three parts: floor–vertical connections–floor, namely two floors connected with stairs or slopes (Fig. 2
                        (a)–(d)). Combining such elements vertically or horizontally results in a network of floors and connections, i.e., a skeleton of the building (Fig. 2(e)). The TRAMMA program can produce a desired network according to the user-defined topology. In the final stage, the walls are attached to the floors that they originally belong to (Fig. 2(f)).

Although the CBD method we propose has not been tested in extensive building libraries, we worked with a limited repository of building models created in SketchUp (3D Warehouse  [22]) for demonstration purposes. The repository includes 26 models of modern architecture, a few samples are shown in Fig. 1. A typical building in the repository consists of 2–4 floors; the rooftops are flat or irregular. In order to process the models in Java, they are transformed from the original SketchUp models to triangular mesh representations. In our application the triangulated mesh serves as the input for recognition and aggregation described below.

The goal of recognition is to group the triangles of the mesh into meaningful categories such as walls and floors. The definition of the categories depends on the desired design operations rather than on a general expertise. In other words, the segmentation provides necessary information for the synthesis (aggregation). The segmentation includes three tasks: recognizing floors, stairs/slopes, and walls.

The recognition of floors is a multi-level clustering process. The goal is to construct set 
                           H
                           
                              {
                              h
                              }
                           
                        , each element 
                           h
                         represents one floor. In order to find these floors out of the mesh, the algorithm (1) puts flat triangles into set 
                           D
                        ; (2) groups the triangles in 
                           D
                         into set 
                           E
                           
                              {
                              e
                              }
                           
                        ; (3) selects the elements of 
                           E
                         as set 
                           F
                           
                              {
                              f
                              }
                           
                        ; (4) groups 
                           
                              {
                              f
                              }
                           
                         into higher-level clusters 
                           G
                           
                              {
                              g
                              }
                           
                        ; (5) selects the elements of 
                           G
                         as set H. The details are as follows (also illustrated in Fig. 3
                        ): 
                           
                              1.
                              Preprocessing the triangles. Grouping all the triangles into four sets according to their normal vectors: 
                                    A
                                    
                                       {
                                       t
                                       :
                                       n
                                       
                                          (
                                          t
                                          )
                                       
                                       <
                                       0.1
                                       }
                                    
                                    
                                    B
                                    
                                       {
                                       t
                                       :
                                       0.1
                                       ≤
                                       n
                                       
                                          (
                                          t
                                          )
                                       
                                       <
                                       0.95
                                       }
                                    
                                    ,
                                    
                                    C
                                    
                                       {
                                       t
                                       :
                                       0.95
                                       ≤
                                       n
                                       
                                          (
                                          t
                                          )
                                       
                                       <
                                       0.995
                                       }
                                    
                                    ,
                                    
                                    D
                                    
                                       {
                                       t
                                       :
                                       0.995
                                       ≤
                                       n
                                       
                                          (
                                          t
                                          )
                                       
                                       }
                                    
                                  (horizontal pieces).


                                 
                                    t
                                 : triangle made of three Euclidean vectors (vertices).


                                 
                                    n
                                    
                                       (
                                       t
                                       )
                                    
                                 : the absolute value of the 
                                    z
                                  component of the normal vector (normalized) of triangle 
                                    t
                                 .

Making set 
                                    E
                                    =
                                    
                                       {
                                       e
                                       }
                                    
                                    ,
                                    
                                    
                                       
                                          ⋂
                                       
                                       
                                          e
                                          ∈
                                          E
                                       
                                    
                                    e
                                    =
                                    ∅
                                    ,
                                    
                                    
                                       
                                          ⋃
                                       
                                       
                                          e
                                          ∈
                                          E
                                       
                                    
                                    e
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          t
                                          ∈
                                          D
                                       
                                    
                                    t
                                 . If share 
                                    
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                       
                                          
                                             t
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                  is true they must fall into the same set 
                                    e
                                 
                              


                                 
                                    e
                                 : a set of triangles, actually a continuous face made of triangles.


                                 
                                    
                                       share
                                    
                                    
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                       
                                          
                                             t
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                 : test if two triangles share two vertices.

Constructing set 
                                    F
                                    =
                                    
                                       {
                                       f
                                       :
                                       f
                                       ∈
                                       E
                                       ,
                                       
                                       
                                          area
                                       
                                       
                                          (
                                          f
                                          )
                                       
                                       >
                                       
                                          
                                             a
                                          
                                          
                                             1
                                          
                                       
                                       }
                                    
                                 .


                                 
                                    f
                                 : a set of triangles, actually a continuous face made of triangles.


                                 
                                    
                                       
                                          a
                                       
                                       
                                          1
                                       
                                    
                                 : a threshold, constant.


                                 
                                    
                                       area
                                    
                                    
                                       (
                                       f
                                       )
                                    
                                 : the sum of the areas of the triangles in set 
                                    f
                                 .

Calculating set 
                                    G
                                    =
                                    
                                       {
                                       g
                                       }
                                    
                                    ,
                                    
                                    
                                       
                                          ⋂
                                       
                                       
                                          g
                                          ∈
                                          G
                                       
                                    
                                    g
                                    =
                                    ∅
                                    ,
                                    
                                    
                                       
                                          ⋃
                                       
                                       
                                          g
                                          ∈
                                          G
                                       
                                    
                                    g
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          f
                                          ∈
                                          F
                                       
                                    
                                    f
                                 . If 
                                    
                                       close
                                    
                                    
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             f
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                  is true, all the triangles in 
                                    
                                       
                                          f
                                       
                                       
                                          i
                                       
                                    
                                  and in 
                                    
                                       
                                          f
                                       
                                       
                                          j
                                       
                                    
                                  must fall into the same set 
                                    g
                                 . 
                                    
                                       (1)
                                       
                                          
                                             close
                                          
                                          
                                             (
                                             
                                                
                                                   f
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   f
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                          =
                                          ∃
                                          
                                             
                                                t
                                             
                                             
                                                p
                                             
                                          
                                          ,
                                          
                                             
                                                t
                                             
                                             
                                                q
                                             
                                          
                                          :
                                          
                                             close
                                          
                                          Z
                                          
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   p
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   q
                                                
                                             
                                             )
                                          
                                          ∧
                                          
                                             close
                                          
                                          X
                                          Y
                                          
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   p
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   q
                                                
                                             
                                             )
                                          
                                          ,
                                          
                                          
                                             
                                                t
                                             
                                             
                                                p
                                             
                                          
                                          ∈
                                          
                                             
                                                f
                                             
                                             
                                                i
                                             
                                          
                                          ,
                                          
                                          
                                             
                                                t
                                             
                                             
                                                q
                                             
                                          
                                          ∈
                                          
                                             
                                                f
                                             
                                             
                                                j
                                             
                                          
                                          .
                                       
                                    
                                 
                                 
                                    g
                                 : a set of triangles.


                                 
                                    
                                       close
                                    
                                    Z
                                    
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             p
                                          
                                       
                                       ,
                                       
                                          
                                             t
                                          
                                          
                                             q
                                          
                                       
                                       )
                                    
                                 : true if the minimum difference between the 
                                    z
                                  components of the vertices of the two triangles are below a threshold; otherwise false.


                                 
                                    
                                       close
                                    
                                    X
                                    Y
                                    
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             p
                                          
                                       
                                       ,
                                       
                                          
                                             t
                                          
                                          
                                             q
                                          
                                       
                                       )
                                    
                                 : true if the minimum distance between the vertices of the two triangles are below a threshold, or the two triangles overlap in the 
                                    X
                                    Y
                                  plane; otherwise false.

Making set 
                                    H
                                    =
                                    
                                       {
                                       h
                                       :
                                       h
                                       ∈
                                       G
                                       ,
                                       
                                       
                                          area
                                       
                                       
                                          (
                                          h
                                          )
                                       
                                       >
                                       
                                          
                                             a
                                          
                                          
                                             2
                                          
                                       
                                       }
                                    
                                 .


                                 
                                    h
                                 : a set of triangles, actually a floor.


                                 
                                    
                                       
                                          a
                                       
                                       
                                          2
                                       
                                    
                                 : a threshold, constant.

The stairs/slopes are the vertical components connecting a pair of floors (Fig. 4 middle). Therefore, the stairs/slopes are searched between any pair of two floors in each model. Similarly to the recognition of the floor, the recognition of stairs/slopes is also a multi-level clustering process. The detailed procedure for floor 
                           
                              
                                 h
                              
                              
                                 i
                              
                           
                         and 
                           
                              
                                 h
                              
                              
                                 j
                              
                           
                         is as follows: 
                           
                              1.
                              Constructing set 
                                    K
                                    =
                                    
                                       {
                                       t
                                       :
                                       t
                                       ∉
                                       
                                          
                                             ⋃
                                          
                                          
                                             h
                                             ∈
                                             H
                                          
                                       
                                       h
                                       ,
                                       
                                       t
                                       ∈
                                       C
                                       ∪
                                       D
                                       ,
                                       min
                                       z
                                       
                                          (
                                          t
                                          )
                                       
                                       >
                                       
                                          
                                             h
                                          
                                          
                                             j
                                          
                                       
                                       ,
                                       max
                                       z
                                       
                                          (
                                          t
                                          )
                                       
                                       <
                                       
                                          
                                             h
                                          
                                          
                                             i
                                          
                                       
                                       }
                                    
                                 .


                                 
                                    min
                                    z
                                    
                                       (
                                       t
                                       )
                                    
                                 : the minimum 
                                    z
                                  coordinate of the triangle 
                                    t
                                 .


                                 
                                    max
                                    z
                                    
                                       (
                                       t
                                       )
                                    
                                 : the maximum 
                                    z
                                  coordinate of the triangle 
                                    t
                                 .


                                 
                                    
                                       
                                          h
                                       
                                       
                                          i
                                       
                                    
                                 : the upper floor.


                                 
                                    
                                       
                                          h
                                       
                                       
                                          j
                                       
                                    
                                 : the lower floor.

Calculating set 
                                    M
                                    =
                                    
                                       {
                                       m
                                       }
                                    
                                    ,
                                    
                                    
                                       
                                          ⋂
                                       
                                       
                                          m
                                          ∈
                                          M
                                       
                                    
                                    m
                                    =
                                    ∅
                                    ,
                                    
                                    
                                       
                                          ⋃
                                       
                                       
                                          m
                                          ∈
                                          M
                                       
                                    
                                    m
                                    =
                                    
                                       
                                          ⋃
                                       
                                       
                                          t
                                          ∈
                                          K
                                       
                                    
                                    t
                                 . If 
                                    
                                       close
                                    
                                    
                                       (
                                       
                                          
                                             t
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             t
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                  is true, they must fall into the same set 
                                    m
                                 . 
                                    
                                       (2)
                                       
                                          
                                             close
                                          
                                          
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                          =
                                          
                                             share
                                          
                                          
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                          ∨
                                          
                                             close
                                          
                                          Z
                                          
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                          ∨
                                          
                                             close
                                          
                                          X
                                          Y
                                          
                                             (
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   j
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    m
                                 : a set of triangles.

Making set 
                                    N
                                    =
                                    
                                       {
                                       n
                                       :
                                       n
                                       ∈
                                       M
                                       ,
                                       
                                          area
                                       
                                       
                                          (
                                          n
                                          )
                                       
                                       >
                                       
                                          
                                             a
                                          
                                          
                                             3
                                          
                                       
                                       }
                                    
                                 
                              


                                 
                                    n
                                 : a set of triangles.


                                 
                                    
                                       
                                          a
                                       
                                       
                                          3
                                       
                                    
                                 : a threshold, constant.

Making set 
                                    S
                                    =
                                    
                                       {
                                       s
                                       :
                                       s
                                       ∈
                                       N
                                       ,
                                       
                                       ∃
                                       t
                                       :
                                       c
                                       
                                          (
                                          t
                                          ,
                                          
                                             
                                                h
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                       ∧
                                       c
                                       
                                          (
                                          t
                                          ,
                                          
                                          
                                             
                                                h
                                             
                                             
                                                j
                                             
                                          
                                          )
                                       
                                       ,
                                       
                                       t
                                       ∈
                                       s
                                       }
                                    
                                 . 
                                    
                                       (3)
                                       
                                          c
                                          
                                             (
                                             t
                                             ,
                                             h
                                             )
                                          
                                          =
                                          ∃
                                          
                                             
                                                t
                                             
                                             
                                                i
                                             
                                          
                                          :
                                          
                                             close
                                          
                                          Z
                                          
                                             (
                                             t
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          ∧
                                          
                                             close
                                          
                                          X
                                          Y
                                          
                                             (
                                             t
                                             ,
                                             
                                                
                                                   t
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                          ,
                                          
                                          
                                             
                                                t
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          h
                                       
                                    
                                 
                                 
                                    c
                                    
                                       (
                                       t
                                       ,
                                       h
                                       )
                                    
                                 : test if triangle 
                                    t
                                  is close to floor 
                                    h
                                 .


                                 
                                    s
                                 : a set of triangles.

The aggregation procedure combines the extracted elements 
                           
                              {
                              p
                              }
                           
                         into new compositions, as illustrated in Fig. 2. The desired topology is manually defined by the user; the TRAMMA program stacks the elements according to the defined topology automatically. The elements could be combined vertically (Figs. 2 and 7) or horizontally (Fig. 9). The topology of multi-story buildings is represented by graphs. Graphs have been widely employed to represent the topology in 2D floor plans, both in analysis  [23] and in synthesis  [19,24]. In this program each floor is modeled as a node, the vertical connections (stairs or slopes) between a pair of floors as a link/edge (Fig. 5
                        ). In the graph, a topological element 
                           p
                         is represented by two nodes with one link. Two jointed nodes (e.g. the node 
                           B
                           ,
                           C
                         in Fig. 5 left) denote that the two floors connect horizontally. To some degree the user-defined topology is arbitrary; three topologies are tested in the application: LINEAR, CIRCLE, and BRANCH (Fig. 5).

After the topology is specified, the program randomly retrieves elements from the library (set 
                           P
                        ) and combines them to satisfy the topology. For example, if we are going to implement the LINEAR topology, the procedures are:


                        
                           
                              
                                 
                                 
                                    
                                       retrieve one element from the library as component AB in LINEAR topology
                                    
                                    
                                       
                                          FOR each connection in LINEAR topology //1st: AB to CD; 2nd: CD to EF.
                                    
                                    
                                       
                                          
                                          WHILE (error function 
                                             f
                                             
                                                (
                                                v
                                                )
                                             
                                           is TRUE) //1st-level trial
                                    
                                    
                                       
                                           retrieve a new element 
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                           from the library
                                    
                                    
                                       
                                          
                                          WHILE (error function 
                                             f
                                             
                                                (
                                                v
                                                )
                                             
                                           is TRUE) //2st-level trial
                                    
                                    
                                       
                                           move and rotate element 
                                             
                                                
                                                   p
                                                
                                                
                                                   i
                                                
                                             
                                           by vector 
                                             v
                                          
                                       
                                    
                                    
                                       
                                          
                                          END
                                       
                                    
                                    
                                       
                                          
                                          END
                                       
                                    
                                    
                                       
                                          END
                                       
                                    
                                 
                              
                           
                        
                     

The error function: 
                           
                              (4)
                              
                                 f
                                 
                                    (
                                    v
                                    )
                                 
                                 =
                                 
                                    overlap
                                 
                                 
                                    (
                                    v
                                    ,
                                    l
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    ,
                                    
                                    h
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    )
                                 
                                 ⋁
                                 
                                    as
                                 
                                 
                                    (
                                    v
                                    ,
                                    s
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    ,
                                    l
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    )
                                 
                                 ⋁
                                 
                                    as
                                 
                                 
                                    (
                                    v
                                    ,
                                    s
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             j
                                          
                                       
                                       )
                                    
                                    ,
                                    h
                                    
                                       (
                                       
                                          
                                             p
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                    )
                                 
                              
                           
                        
                     


                        
                           
                              
                                 
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                 :
                              the upper element, 
                                    
                                       
                                          p
                                       
                                       
                                          j
                                       
                                    
                                 : the lower element (illustrated in Fig. 6
                                 ).
                              

the lower floor of element 
                                    p
                                 
                              

the upper floor of element 
                                    p
                                 
                              

the set of stairs/slops of element 
                                    p
                                 
                              

the 2D transformation vector of three components: angle (rotation), 
                                    x
                                  and 
                                    y
                                  (translation).

The major task of aggregation is error elimination. The errors occur in the vertical/horizontal connection between the floors (Fig. 6(a) illustrates a valid connection between floors), and in the collisions between stairs/slopes and floors (Fig. 6(b) illustrates an invalid connection with collision). The error functions for different topologies (Fig. 5) are slightly different. The pseudocode of the aggregation process indicates that the process is a two-level “trial and error” algorithm. Therefore, the performance of the algorithm can be partially evaluated by how many trials it must take to eliminate the errors (Table 3
                        ).

The three topologies in Section  3.3 can be quickly achieved by the TRAMMA program (usually after dozens of iterations). The information acquired in the recognition phase enables the aggregation process to make valid compositions. It implements the general task of CBD: “creating a new design solution by combining and/or adapting previous design solution(s)”  [25]. Figs. 7–9
                     
                      show two results for each topology (Fig. 5) respectively. The results imply that a small collection of samples (26 cases) can lead to a wide range of forms. Some results surprise us because they present the 3D geometric features of different cases within a novel composition. For architects, some generated buildings appear as manually designed. Thus, the program could help the architects to explore new designs with a few cases.

The complexity of the recognition algorithm is between 
                        O
                        
                           (
                           n
                           )
                        
                      and 
                        O
                        
                           (
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           )
                        
                     . For instance, the complexity of steps 1, 3, 5 of floor recognition is 
                        O
                        
                           (
                           n
                           )
                        
                     ; that of steps 2, 4 is 
                        O
                        
                           (
                           
                              
                                 n
                              
                              
                                 2
                              
                           
                           )
                        
                     . The synthesis algorithm has a linear complexity. The program could be inefficient with large repository or with complex models. Besides, there are some drawbacks in the generated designs from a point of view of architect. For instance, some generated buildings lack structural feasibility. Moreover, some interior spaces could be chaotic because the program focuses on the topology between floors instead of the topology within a single floor. This problem could be solved by manual manipulation or by other synthesis programs for single floor.

The future work can be developed in several directions. First, the category of semantic structures such as floors, walls, and stairs could be extended so that the method we propose could be more widely applicable to architectural design. Second, the recognition–aggregation process could be integrated with the optimization algorithm to consider more criteria. Third, it is interesting to integrate this program into urban design. An experimental scenario has been tested: first, creating a virtual construction site (360 m × 360 m), with several roads dividing the site into irregular parcels; and second, employing a 2D packing algorithm in order to place the generated buildings (according to their convex hulls) in the parcels compactly (Fig. 10
                     ). It is possible to add more constraints to the packing algorithm to have more sophisticated controls on the planning in the future work.

@&#CONCLUSIONS@&#

Briefly, it is rewarding to regard CBD not only as the formalization of previous knowledge but also as an opportunity to create new designs and to stimulate new reflections. In TRAMMA program, some synthesized designs have surprised us by unexpected combination of previous cases, e.g., by an unprecedented mixture of different kinds of rooftops. The results suggest that CBD could be a middle ground between traditional use of CAD software and automatic spatial synthesis  [19,24,26,27]. Commercial modeling software provides a convenient platform for modeling and storing cases; spatial synthesis emphasizes the early stages of design, especially the automatic production of spatial compositions via formal operations. Our TRAMMA program functions independently, however, it is possible to integrate the program with CAD tools in the future. Such kind of CBD programs can directly take the models in CAD software as samples and then employ a generative process to construct new compositions. In this scenario, CBD can lead to new designs without the extensive manual interventions in traditional modeling, but still benefit from the increasing number of models based on common modeling software.

@&#ACKNOWLEDGMENTS@&#

Prof. Dr. Ludger Hovestadt at the chair of Computer-Aided Architectural Design ETH Zürich has given valuable advices on this work. The SketchUp models are downloaded from Trimble 3D Warehouse (2013).

@&#REFERENCES@&#

