@&#MAIN-TITLE@&#Optimized polygonal approximations through vertex relocations in contour neighborhoods

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Polygonal approximations using relaxed approximations allowing the vertices of an approximation to lie outside the contour.


                        
                        
                           
                           Adaptive estimation of contour neighborhoods where the vertices of an approximation are located.


                        
                        
                           
                           A general approach to reduce error measure of any polygonal approximations through vertex relocation.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Polygonal approximation

Dominant points

Point neighborhood

Vertex relocation

@&#ABSTRACT@&#


               
               
                  This paper presents yet another algorithm for finding polygonal approximations of digital planar curves; however, with a significant distinction: the vertices of an approximating polygon need not lie on the contour itself. This approach gives us more flexibility to reduce the approximation error of the polygon compared to the conventional way, where the vertices of the polygon are restricted to lie on the contour. To compute the approximation efficiently, we adaptively define a local neighborhood of each point on the contour. The vertices of the polygonal approximation are allowed to ‘move around’ in the neighborhoods. In addition, we demonstrate a general approach where the error measure of an already computed polygonal approximation can possibly be reduced further by vertex relocation, without increasing the number of dominant points. Moreover, the proposed method is non-parametric, requiring no parameter to set for any particular application. Suitability of the proposed algorithm is validated by testing on several databases and comparing with existing methods.
               
            

@&#INTRODUCTION@&#

Polygonal approximation is an effective way for capturing the outline of digital planar shapes [2,24], where the outline of an image is approximated by a sequence of line segments. Such approximations can be utilized for shape modeling [16] and recognition [17]. The main motivation for such an approximation based modeling lies in the ability of the approximation to cope with the noise on the shape contour [6,16]. At the same time, a polygonal approximation is a more compact representation of the shape contour [2]. For this reason, a lot of research has been carried out (for decades) in search of effective polygonal approximation algorithms [4,6,7,10–16,19,21–23].

Most of these polygonal approximation algorithms attempt to find a set of points, called dominant points, on the shape contour that serve as the vertices of the approximating polygon [6,12]. Such an approximation generally minimizes some error criteria, like (weighted) mean squared error [10,19,20]. Most of the polygonal approximation algorithms share a common idea where a significant measure is defined for each point on the contour. Then a subset of points on the contour is selected based on this measure. This is done by either selecting most significant points [7,23] or removing redundant non-significant points from the contour as much as possible [6,12,16]. This selection process requires some definition of relative significance of points on the contour. This relative significance can be defined using some threshold [12] or can be determined by finding a set of points that optimizes some error measures. Several researchers have demonstrated the superiority of optimization over thresholding [6,16].

In addition, most of the polygonal approximation algorithms (if not all) share another common feature: vertices of the polygonal approximation are a subset of the contour points. This can be a limiting factor; since a better approximation can possibly be obtained if we allow the vertices to lie outside the contour points. We call such an approximation as relaxed approximation. Fig. 1
                      demonstrates one such example. The main motivation behind a relaxed approximation is that such an approximation allows us more flexibility in reducing the error of the approximation. In this paper, we statistically substantiate this claim through experimentations on various image databases.

However, finding an optimum relaxed approximation can be computationally prohibitive, as the vertices may not lie on the contour. This is especially true for contours with large number of points. This paper proposes a novel method that is somewhat a ‘middle way’: take the benefit of relaxed approximations, while try to reduce the computational overhead. This approach is described more formally below.

In this work, we consider a curve C as an ordered set of points {p
                     
                        i
                     
                     =(x
                     
                        i
                     ,
                     y
                     
                        i
                     ),
                     i
                     =1,2,…,
                     n}, where p
                     
                        i
                        +1 is a neighbor of p
                     
                        i
                     . For a closed curve, p
                     
                        n
                      and p
                     1 are neighbors also. Since we are dealing with digital images, the points p
                     
                        i
                      on C are treated as pixels in the digital images. Therefore, for our purpose, points on a curve are taken from a discrete two dimensional space. If a curve is formed from the boundary pixels of a digital image, then this curve is called a contour.

For a point p
                     
                        i
                      (either in real or discrete space), a neighborhood can be defined as a set of points Ν(p
                     
                        i
                     ), where for each point q
                     ∈
                     Ν(p
                     
                        i
                     ), dis(q,
                     p
                     
                        i
                     )≤
                     r, and r
                     >0. Here, dis(q,
                     p
                     
                        i
                     ) refers to the distance between the points q
                     =(q
                     
                        x
                     ,
                     q
                     
                        y
                     ) and p
                     
                        i
                     
                     =(p
                     
                        ix
                     ,
                     p
                     
                        iy
                     ). In real space, dis(q,
                     p
                     
                        i
                     ) can be defined as the Euclidean distance between q and p
                     
                        i
                      (Fig. 2(a)). However, in pixel space (the case in this work), the points on the curve C have integer co-ordinates and the calculation of dis(q,
                     p
                     
                        i
                     ) can be simplified by computing City-block or Manhattan distance between q and p
                     
                        i
                     . Fig. 2(b) shows one such example, where the curve points are treated as pixels.

In this paper, we propose a non-parametric algorithm that selects a sequence of m points d
                     1,
                     d
                     2,…,
                     d
                     
                        m
                      as the vertices of a polygon that approximates a contour C, where d
                     
                        j
                     
                     ∈
                     Ν(p
                     
                        i
                     ), j
                     =1,2,…,
                     m, for some i
                     ∈{1,2,…,
                     n}. We also present a simplified version of the proposed method that can work as a general framework to reduce the approximation error of any ‘in-hand’ approximations (approximations computed from possibly other algorithms). In this general framework, a subset C
                     
                        R
                      of C is found initially by an existing polygonal approximation algorithm. Then, the neighborhoods of points in C
                     
                        R
                      are searched for the best set of vertices for a polygonal approximation of C. In addition, the proposed method is non-parametric: neighborhoods of the points in C and the best set of vertices of the polygon approximating C are found adaptively.

This paper thus improves the state of the art in finding polygonal approximations of digital planar curves through the following contributions.
                        
                           •
                           Improved polygonal approximations through relaxed approximations, allowing the vertices of the approximations to lie outside the contour.

Efficient computation of relaxed approximations by searching the vertices of the approximations in adaptively estimated local neighborhoods.

A general approach to reduce error measure of any polygonal approximations through vertex relocation.

Regarding the third point above, the following comments can be made. For any digital curve, an approximation with zero mean squared error (called ISE) can be obtained by following the curve exactly (just remove the collinear points from the curve!). Such an approximation generally results in a large number of vertices in the polygon. Reducing the number of vertices of the polygon will increase the resulting ISE. Thus, algorithms for finding polygonal approximations generally attempt to minimize the number of vertices and ISE at the same time. Getting the optimal combination of these two parameters can be computationally prohibitive for large contours. Therefore, researchers have utilized heuristics to reduce the approximation error [5,6,11,12,16]. The following scenario occasionally arises while reducing the error of the polygonal approximations. Suppose, two equal-size sets of vertices V
                     1 and V
                     2 define two approximations of a curve C. Now, the associated errors E(V
                     1) and E(V
                     2) of the two approximating polygons of C can be different; that is, E(V
                     1)≠
                     E(V
                     2), |V
                     1|=|V
                     2|. This indicates the possibility of obtaining an approximation of C with less error by relocating the vertices of the already existing approximation. For example, vertices are shifted along the curve to reduce the approximation error in [20]. In this paper, we present a general approach that can possibly reduce the error of an in-hand approximation by relocating the vertices of the polygon in their neighborhoods. Experimental results indicate that a statistically significant amount of improvement is possible through this approach.

The rest of the paper is organized as follows. Section 2 describes some related works on polygonal approximations. Mathematical formulations of polygonal approximations are presented in Section 3. The proposed algorithm is described in Section 4. Section 5 details the experimental results. Finally, Section 6 presents our conclusions.

@&#RELATED WORK@&#

Many algorithms have been proposed for dominant point detection of digital planar curves. These algorithms can be categorized into two main classes: (1) algorithms that try to fit the curve with minimum number edges/vertices that satisfy some error criteria [8,18,25] and (2) algorithms that find a subset of the curve points as dominant points [5–7,12–16,19,22,23].

Algorithms in the first category try to find optimal approximations of digital curves. However, these algorithms are generally parametric and one needs to specify the starting point or the maximum allowable error before an approximation is found. For example, the method in [8] approximates a contour by a polygon with the minimum number of vertices for a given allowable approximation error and initial vertex. The algorithm progressively determines the minimal set of vertices of the polygonal approximation starting from a pre-selected initial vertex.

The algorithms in the second category are generally more robust for various shapes. Since there are quite a number of dominant point detection algorithms in the literature, here we discuss only the more recent and relevant ones. More rigorous evaluations of different dominant point detection algorithms are given in [3].

Many dominant point detection algorithms first screen the points on the contour using various criteria, like pre-defined mask for various orientation [7] and break-point detection [12,13,16]. Then, a significance measure is estimated for each point on the contour C and less significant points are removed. Researchers have calculated this measure in different ways. Chau and Siu [7] used cosine angle to define significance measure for each point in the set of possible dominant points. Based on this significance measure, unimportant dominant points were suppressed. In [13], Masood defined associated error value (AEV) for each dominant point (DP). Then the algorithm iteratively deleted the DP with least AEV. An optimization procedure was then used to optimize the ISE of the resulting polygonal approximation. The drawback of this scheme is that no clear stopping criterion is mentioned.

Some researchers have defined a region of support for each point p
                     
                        i
                      on contour C 
                     [5,12,15,16]. Region of support of p
                     
                        i
                      consists of the points 
                        
                           
                              p
                              
                                 i
                                 −
                                 k
                              
                           
                           …
                           
                              p
                              i
                           
                           …
                           
                              p
                              
                                 i
                                 +
                                 
                                    k
                                    ′
                                 
                              
                           
                        
                      on C for some k and k′. The, the significance measure is calculated for p
                     
                        i
                      using some mathematical operations which involve the support region of p
                     
                        i
                     . Then less significant points can be suppressed by collinear-points suppression [5,12,16].

Marji and Siy [12] first introduced this idea of point suppression. However, their method is limited by a fixed threshold for suppression. Carmona-Poyato et al. [5] improved the method in [12] by using an optimization procedure to obtain the threshold value for collinear-points suppression. In [6], Carmona-Poyato et al. further improved their method by iteratively suppressing dominant points, until a final condition is satisfied. However, the performance of the algorithm can significantly vary based on the choice of the final condition.

Both of the algorithms in [5,6] are global optimization algorithms and used a single suppression parameter for the entire contour. Parvez and Mahmoud [16] demonstrated that a local optimization method can perform better. Their approach used different suppression thresholds (estimated adaptively) for various parts of the contour, taking into account the various levels of details present in the contour.

The proposed algorithm in this paper has improvements over existing methods in two major ways: (i) it allows the dominant points to lie outside the contour itself to reduce the error of the approximation; and (ii) the error of an approximation is further reduced without increasing the number of dominant points. These advantages are demonstrated through experimentations of the proposed method on various image databases.

Let P
                     ={pi
                      (xi
                     , yi
                     ), i
                     =1, 2, …, n} be a sequence of n points in the Euclidean space, where p
                     
                        i
                        +1 is a neighbor of p
                     
                        i
                     . In case of digital images, the co-ordinates of these n points are integers. If these n points are taken from the boundary of a planar digital image, then the points p
                     
                        i
                      and p
                     
                        i
                        +1 are neighboring pixels, with p
                     
                        n
                      being the neighbor of p
                     1. In this case, the set P is called a contour.

We first define a polygonal approximation of P for the case where the vertices of the approximation form a sub-set of P. Let D
                     ={d
                     
                        j
                     (x
                     
                        j
                     ,
                     y
                     
                        j
                     ),
                     j
                     =1,2,…,
                     m} be a sub-set of P. Here d
                     
                        j
                     
                     =
                     p
                     
                        i
                      for some j and i, where j
                     ≤
                     m and i
                     ≤
                     n. Suppose P
                     
                        j
                        →
                        j
                        +1 denote the set of k points {p
                     
                        i
                     ,
                     p
                     
                        i
                        +1,
                     p
                     
                        i
                        +2,…,
                     p
                     
                        i
                        +
                        k
                        −1,
                     p
                     
                        i
                        +
                        k
                     } where p
                     
                        i
                     
                     =
                     d
                     
                        j
                      and p
                     
                        i
                        +
                        k
                     
                     =
                     d
                     
                        j
                        +1. Let L
                     
                        j
                        ↔
                        j
                        +1 be the line-segment connecting d
                     
                        j
                      and d
                     
                        j
                        +1. We call L
                     
                        j
                        ↔
                        j
                        +1 a straight-line approximation of P
                     
                        j
                        →
                        j
                        +1 (see Fig. 3
                     ). The sequence of all L
                     
                        j
                        ↔
                        j
                        +1, j
                     =1,2,…,
                     m, forms a polygonal approximation of P. Note that L
                     
                        m
                        ↔
                        m
                        +1 is the same as L
                     
                        m
                        ↔1. The points in D are called dominant points. Thus, dominant points are the vertices of the polygonal approximation of P.

Suppose the approximation error of L
                     
                        j
                        ↔
                        j
                        +1 is denoted by E
                     
                        j
                        ↔
                        j
                        +1. The error E
                     
                        j
                        ↔
                        j
                        +1 can be measured in a number of ways (discussed later) and can be used as a fitness function for L
                     
                        j
                        ↔
                        j
                        +1. For example, E
                     
                        j
                        ↔
                        j
                        +1 can be measured as 
                        
                           E
                           
                              j
                              ↔
                              j
                              +
                              1
                           
                        
                        =
                        
                           
                              ∑
                              
                                 t
                                 =
                                 i
                              
                              
                                 i
                                 +
                                 k
                              
                           
                           
                              per
                              
                                 
                                    p
                                    t
                                 
                                 
                                    L
                                    
                                       j
                                       ↔
                                       j
                                       +
                                       1
                                    
                                 
                              
                           
                        
                     , where per(p
                     
                        t
                     ,
                     L
                     
                        j
                        ↔
                        j
                        +1) is the perpendicular distance from the point p
                     
                        t
                      to the line-segment L
                     
                        j
                        ↔
                        j
                        +1. Then, the approximation error of the polygonal approximation of P can be found as: 
                        E
                        =
                        
                           
                              ∑
                              
                                 j
                                 =
                                 1
                              
                              m
                           
                           
                              
                                 E
                                 
                                    j
                                    ↔
                                    j
                                    +
                                    1
                                 
                              
                           
                        
                     . The goal of a polygonal approximation algorithm is to find the set D (the set of dominant points) such that the error measure E is optimized. In general, we need to put some restrictions on this formulation to keep the computational complexity of finding the set D as tractable [18]. For example, the size of D can be pre-set or a threshold on the error E can be set up [18,25].

In this paper, we allow D
                     ⊄
                     P, with the hope that the resulting polygonal approximation of P will have a lower error compared to the case where D
                     ⊂
                     P. However, in this case, finding an optimal polygonal approximation may become computationally prohibitive. Once again, we can put some restrictions on the set D to reduce the complexity. In this paper, we put the following restrictions on D. For each point d
                     
                        j
                     
                     ∈
                     D,
                     j
                     =1,2,…,
                     m, there exists a point p
                     
                        i
                     
                     ∈
                     P for some i
                     ∈{1,2,…,
                     n} such that dis(d
                     
                        j
                     ,
                     p
                     
                        i
                     )≤
                     τ. Here, τ is a pre-defined threshold and dis(d
                     
                        j
                     ,
                     p
                     
                        i
                     ) is the distance between d
                     
                        j
                      and p
                     
                        i
                     . The distance dis(d
                     
                        j
                     ,
                     p
                     
                        i
                     ) can simply be the Euclidean distance between d
                     
                        j
                      and p
                     
                        i
                     .

With this formulation of the polygonal approximation of P in hand, we devise an algorithm that can effectively estimate the threshold τ for any sequence of points P. This is done through an estimation of a point neighborhood Ν(p
                     
                        i
                     ) for each point p
                     
                        i
                     
                     ∈
                     P. Then, the set D is found with the restriction that d
                     
                        j
                     
                     ∈
                     N(p
                     
                        i
                     ) for some i, i
                     =1,2,…,
                     n. The details of the algorithm are given in the next section.

Based on the formulation of the polygonal approximation for a sequence of points P described above, we present our algorithm for finding the polygonal approximation of P. In the discussion below, the sequence P forms the contour C of a digital image.

The image is assumed to be a binary image and the contour C is extracted using a suitable contour-extraction algorithm. The major steps of the proposed algorithm are listed below.
                        
                           •
                           Adaptively estimate the point neighborhood Ν(p
                              
                                 i
                              ) for each point p
                              
                                 i
                               on a contour C.

Obtain a set C′⊂
                              C by suppressing collinear and near-collinear points on C. C′ defines an initial approximation of C.

For each vertex in C′, relocate the vertex in its neighborhood or remove it to reduce the error measure of the resulting approximation.

We now describe each of these phases in details.

We first describe the method to find the point neighborhoods adaptively. Suppose, V is the vertex set of a polygon that approximates a contour C. Let p
                        
                           i
                         be a point on C which is included in V: p
                        
                           i
                        
                        ∈
                        V. A point neighborhood Ν(p
                        
                           i
                        ) for a point p
                        
                           i
                         on C is defined as the set of points, such that for each point q
                        ∈
                        Ν(p
                        
                           i
                        ), the distance between p
                        
                           i
                         and q is less than some pre-computed threshold.

The purpose behind finding Ν(p
                        
                           i
                        ) is that there might be a point q
                        ∈
                        Ν(p
                        
                           i
                        ), such that the set V′=
                        V
                        −
                        p
                        
                           i
                        
                        ∪
                        q approximates the contour C with less approximation error. We call this process of finding the vertex q as the relocation of p
                        
                           i
                        . A simple example to illustrate the relocation process is shown earlier in Fig. 1, where the vertex at point P is moved to the location at P′ to reduce the error of the resulting approximation.

A key point here is how the size of a point neighborhood can be estimated. We answer this question intuitively and then more formally as follows. For this purpose, consider Fig. 4
                        .

In Fig. 4(a), a contour segment is shown to be approximated by a polyline (a polygon with open ends) with three edges. If the two vertices pi
                         and pj
                         in Fig. 4(a) can be relocated as shown in Fig. 4(b), then the same segment can be approximated by a single edge. The approximation in Fig. 4(b) has less approximation error and less number of edges compared to the polyline in Fig. 4(a). Note that, relocation of the two vertices pi
                         and pj
                         in Fig. 4(b) do not mean that the actual contour points have been moved. Rather, the locations of the two vertices of approximating polyline are moved beyond the contour points.

Interestingly, this relocation of pi
                         and pj
                         in Fig. 4(b) can be thought of as a suppression of the two points, as used in several previous works [6,12,16]. The key difference between suppression (as used by other researchers) and relocation (as defined here) is that, in relocation a vertex will not necessarily be removed from the approximating polygon. However, the extent to which a point can survive the suppression process can be thought of its neighborhood in which the vertex can ‘move around’. Therefore, the following heuristic is used to estimate the point neighborhood Ν(p
                        
                           i
                        ) of a point p
                        
                           i
                         on the contour C. To reduce the computational overhead, all the points on C will have neighborhoods of the same size.

The points on the contour C
                        ={pi
                        
                        =(xi
                        , yi
                        ), i
                        =1, 2, …, n}, are iteratively suppressed to remove redundant points, which are defined as follows. Suppose p
                        
                           i
                        ,
                        p
                        
                           j
                         and p
                        
                           k
                         are three points (possibly consecutive) on C. Point p
                        
                           j
                         is a redundant point if the perpendicular distance from p
                        
                           j
                         to the line-segment joining p
                        
                           i
                         and p
                        
                           k
                         is less than some threshold δ 
                        [16]. Let this distance be denoted as dis
                        
                           j
                        (p
                        
                           i
                        
                        ↔
                        p
                        
                           k
                        ). For any contour C, δ can be made large enough to mark all the points on C as redundant! To avoid this extreme situation, we define the following constraint called preservation constraint. In this constraint, a point p
                        
                           j
                         on C cannot be marked redundant if there exists another point on C having perpendicular distance to the line-segment joining p
                        
                           i
                         and p
                        
                           k
                         less than δ.

We now use the following iterative suppression process to estimate the point neighborhoods. We start with an initial small value of δ (called δ
                        
                           ini
                        ). At each iteration j
                        ≥1, a new set of points C
                        
                           j
                         is found from C
                        
                           j
                           −1, where C
                        0
                        =
                        C, by removing the redundant points in C
                        
                           j
                           −1. To find C
                        
                           j
                           +1, the value of δ is increased with a small increment τ. This process continues until at some iteration k, C
                        
                           k
                        
                        =
                        C
                        
                           k
                           −1. Let the maximum value of δ in the last iteration be δ
                        max. The value of δ
                        max is taken as the neighborhood width η. This process for estimating the neighborhood width is given in more formal way in estimateNeighborhood procedure below.
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                Procedure: estimateNeighborhood
                                                
                                                   
                                                      
                                                         Input: C
                                                         =
                                                         pi
                                                          (xi
                                                         , yi
                                                         ), i
                                                         =1, 2, …, n: n contour points


                                                         Output: η: neighborhood width for each point on C
                                                      


                                                         Begin
                                                         
                                                            
                                                               
                                                                  δ
                                                                  0
                                                                  ←
                                                                  δ
                                                                  
                                                                     ini
                                                                  
                                                               


                                                                  C
                                                                  
                                                                     k
                                                                  
                                                                  ←
                                                                  C,
                                                                  k
                                                                  =0


                                                                  Repeat
                                                                  
                                                                     
                                                                        For each three consecutive points p
                                                                           
                                                                              i
                                                                           ,
                                                                           p
                                                                           
                                                                              j
                                                                            and p
                                                                           
                                                                              k
                                                                            in C
                                                                           
                                                                              k
                                                                           
                                                                           
                                                                              
                                                                                 
                                                                                    d
                                                                                    
                                                                                       per
                                                                                    
                                                                                    ←
                                                                                    dis
                                                                                    
                                                                                       j
                                                                                    (p
                                                                                    
                                                                                       i
                                                                                    
                                                                                    ↔
                                                                                    p
                                                                                    
                                                                                       k
                                                                                    )


                                                                                    C
                                                                                    
                                                                                       k
                                                                                    
                                                                                    ←
                                                                                    C
                                                                                    
                                                                                       k
                                                                                    
                                                                                    −
                                                                                    p
                                                                                    
                                                                                       j
                                                                                    , if d
                                                                                    
                                                                                       per
                                                                                    
                                                                                    <
                                                                                    δ and ∀
                                                                                    p
                                                                                    
                                                                                       l
                                                                                    
                                                                                    ∈
                                                                                    C
                                                                                    
                                                                                       k
                                                                                    ,
                                                                                    d
                                                                                    
                                                                                       l
                                                                                    (p
                                                                                    
                                                                                       i
                                                                                    
                                                                                    ↔
                                                                                    p
                                                                                    
                                                                                       k
                                                                                    )>
                                                                                    δ,
                                                                                    p
                                                                                    
                                                                                       l
                                                                                    
                                                                                    ∉{p
                                                                                    
                                                                                       i
                                                                                    ,
                                                                                    p
                                                                                    
                                                                                       j
                                                                                    ,
                                                                                    p
                                                                                    
                                                                                       k
                                                                                    }


                                                                           C
                                                                           
                                                                              k
                                                                              +1
                                                                           ←
                                                                           C
                                                                           
                                                                              k
                                                                           ,
                                                                           k
                                                                           ←
                                                                           k
                                                                           +1


                                                                           δ
                                                                           
                                                                              k
                                                                           
                                                                           ←
                                                                           δ
                                                                           
                                                                              k
                                                                              −1
                                                                           +
                                                                           τ
                                                                        


                                                                  Until C
                                                                  
                                                                     k
                                                                     −1
                                                                  =
                                                                  C
                                                                  
                                                                     k
                                                                  
                                                               


                                                                  η
                                                                  ←
                                                                  δ
                                                                  
                                                                     k
                                                                  
                                                               


                                                End.

In estimateNeighborhood procedure, the value of δ
                        
                           ini
                         is taken as 0.5, since the minimum possible value for δ is 1/√5=0.447 [6]. The value of the increment τ is also taken as 0.5. An illustrative example showing the results of the various iterations of estimateNeighborhood procedure is given in Fig. 5
                        . For the example contour C of Fig. 5(a), the procedure stops with δ
                        max
                        =1.5. For δ
                        >1.5, points on C cannot be marked as redundant due to the preservation constraint discussed above.

The running time for the estimateNeighborhood procedure can be estimated as follows. Calculation of the distance d
                        
                           per
                         can be done in O(1) time. Therefore, it takes Θ(n) time to find whether a point on the contour C should be suppressed or not. Thus, an iteration of the estimateNeighborhood procedure takes O(n
                        2) time.

In our method, we first remove collinear and near-collinear points of C to obtain an initial set of dominant points. Let Q
                        ={q
                        1,
                        q
                        1,…,
                        q
                        
                           m
                        } be the m points on contour C after the removal of collinear and near-collinear points of C. The set Q can be found by applying the process of suppression defined above on C with a small threshold δ. The reasons behind working with this set Q are two-fold: collinear and near collinear points of C will possibly not be in the vertex set of the optimal approximating polygon of C and thus removing them at an early age can reduce the overall computational overhead.

Now, for each point q
                        
                           i
                        
                        ={q
                        
                           i
                        (x),
                        q
                        
                           i
                        (y)}, i
                        =1,2,…,
                        m, points in the neighborhood Ν(q
                        
                           i
                        ) are found as follows. A point (or a pixel in digital plane) T
                        =(T
                        
                           x
                        ,
                        T
                        
                           y
                        ) is included in Ν(q
                        
                           i
                        ) if the following conditions are satisfied: |T
                        
                           x
                        
                        −
                        q
                        
                           i
                        (x)|≤
                        η/2 and |T
                        
                           y
                        
                        −
                        q
                        
                           i
                        (y)|≤
                        η/2. Note that, q
                        
                           i
                        
                        ∈
                        Ν(q
                        
                           i
                        ). Fig. 6
                         illustrates this definition of a point neighborhood. In Fig. 6, the neighborhood of q
                        
                           i
                         contains nine pixels (inside the box with thick boundary) when η
                        =2. Note that, pixels marked with lighter shades are not part of the original contour.

Once the collinear and near collinear points on the contour C are suppressed and a neighborhood is found for each remaining point in C, the vertex relocation/removal process is used to find an approximating polygon for C. Pseudo-code of the overall process for finding the polygonal approximation of C is shown in findPolygonalApproximation algorithm below, with an illustrative example in Fig. 7
                        .

Suppose Q
                        ={q
                        1,
                        q
                        1,…,
                        q
                        
                           m
                        } is the set of m points obtained after removing (near) collinear points on the contour C. For a closed contour C, these m points define m line segments L
                        1,
                        L
                        2,…,
                        L
                        
                           m
                        , where L
                        
                           i
                         is constructed from joining q
                        
                           i
                         and q
                        
                           i
                           +1. Note that, for a closed contour, q
                        
                           m
                           +1
                        =
                        q
                        1 and L
                        −1
                        =
                        L
                        
                           m
                        . These m line segments define a polygonal approximation of C. As discussed earlier, points in Q (which are the vertices of the approximating polygon) may need to be relocated or removed in order to obtain an approximation of C that optimizes some error measure. For this purpose, we do the following for each point q
                        
                           i
                         in Q:
                           
                              •
                              Select a point q
                                 
                                    i
                                 
                                 
                                    R
                                 
                                 ∈
                                 Ν(q
                                 
                                    i
                                 ) such that the approximation defined by Q
                                 
                                    R
                                 
                                 =
                                 Q
                                 −
                                 q
                                 
                                    i
                                 
                                 ∪
                                 q
                                 
                                    i
                                 
                                 
                                    R
                                  has a minimum approximation error among all the points in Ν(q
                                 
                                    i
                                 ). Denote this minimum error (called relocation error) by E
                                 
                                    i
                                 
                                 
                                    R
                                 , which refers to the improvement due to the relocation of q
                                 
                                    i
                                 . The point q
                                 
                                    i
                                 
                                 
                                    R
                                  is called the relocated point of q
                                 
                                    i
                                 .

Estimate the approximation error E
                                 
                                    i
                                 
                                 
                                    D
                                 , which is the error measure for the approximation defined by Q
                                 
                                    D
                                 
                                 =
                                 Q
                                 −
                                 q
                                 
                                    i
                                 . The term E
                                 
                                    i
                                 
                                 
                                    D
                                  refers to the approximation error due to the deletion of the point q
                                 
                                    i
                                  and is called the removal error of q
                                 
                                    i
                                 .

If E
                                 
                                    i
                                 
                                 
                                    D
                                  is lower than E
                                 
                                    i
                                 
                                 
                                    R
                                 , then remove q
                                 
                                    i
                                  from Q; otherwise replace q
                                 
                                    i
                                  with the point q
                                 
                                    i
                                 
                                 
                                    R
                                  in Q.


                                       
                                          
                                             
                                                Algorithm: findPolygonalApproximation
                                                
                                                   
                                                      
                                                         Input: C
                                                         =
                                                         pi
                                                          (xi
                                                         , yi
                                                         ), i
                                                         =1, 2, …, n: n contour points.


                                                         Output: V
                                                         =
                                                         q
                                                         
                                                            j
                                                         (x
                                                         
                                                            j
                                                         ,
                                                         y
                                                         
                                                            j
                                                         ),
                                                         j
                                                         =1,2,…,
                                                         n
                                                         
                                                            d
                                                         : vertices defining the polygonal approximation of C.


                                                         Begin
                                                         
                                                            
                                                               Calculate neighborhood width η using estimateNeighborhood procedure.


                                                                  Q
                                                                  ←
                                                                  C′, where C′ is obtained from C by removing (near) collinear points in C.

Estimate the strength of each point in Q and sort them based on the strength.

For each point q
                                                                  
                                                                     i
                                                                   in Q (weakest point first):
                                                                     
                                                                        Estimate the relocation error E
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              R
                                                                            and removal error E
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              D
                                                                           .

If E
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              D
                                                                           
                                                                           <
                                                                           E
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              R
                                                                           , then Q
                                                                           ←
                                                                           Q
                                                                           −
                                                                           q
                                                                           
                                                                              i
                                                                           .

Otherwise Q
                                                                           ←
                                                                           Q
                                                                           −
                                                                           q
                                                                           
                                                                              i
                                                                           
                                                                           ∪
                                                                           q
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              R
                                                                            and Ν(q
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              R
                                                                           )←
                                                                           Ν(q
                                                                           
                                                                              i
                                                                           ), where q
                                                                           
                                                                              i
                                                                           
                                                                           
                                                                              R
                                                                            is the relocated point of q
                                                                           
                                                                              i
                                                                           .

Update the strengths of the points in Q.


                                                                  V
                                                                  ←
                                                                  Q
                                                               


                                                End.

There are a number of error measures for the approximating polygon that can be minimized while estimating the relocation and removal errors. The choice of such measures will be discussed later. The final set of points in the set Q defines the polygonal approximation of the contour C, where the vertices of the polygon may not lie on the contour itself.

Generally, the approximation will vary based on the order in which the points in Q are selected for relocation/removal. To reduce the effect of the ordering of points, a significance measure can be defined for each point in Q. Then the points in Q are ordered by this measure and then are relocated/removed following the ordering. For our case, we define this measure as follows.

For each point q
                        
                           j
                        
                        ∈
                        Q,
                        j
                        =1,2,…,
                        m, we define a corresponding point ℂ(q
                        
                           j
                        ) as follows: 
                           ℂ
                           
                              
                                 q
                                 j
                              
                           
                           =
                           
                              p
                              k
                           
                           ,
                           k
                           =
                           
                              
                                 arg
                                 min
                              
                              
                                 i
                                 =
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 n
                              
                           
                           
                              
                                 d
                                 
                                    
                                       q
                                       j
                                    
                                    
                                       p
                                       i
                                    
                                 
                              
                           
                        . Here, d(q
                        
                           j
                        ,
                        p
                        
                           i
                        ) refers to the Euclidian distance between points q
                        
                           j
                         and p
                        
                           i
                        . In other words, ℂ(q
                        
                           j
                        ) is the point in C closest to q
                        
                           j
                        . Note that, initially ℂ(q
                        
                           j
                        )=
                        q
                        
                           j
                        . However, after the relocation of q
                        
                           j
                         beyond the contour, ℂ(q
                        
                           j
                        )≠
                        q
                        
                           j
                        . Suppose {q
                        
                           j1,
                        q
                        
                           j2,
                        q
                        
                           j3} are three points in Q, where {ℂ(q
                        
                           j1),ℂ(q
                        
                           j2),ℂ(q
                        
                           j3)} are three ordered points on the contour C. Let these three corresponding points be denoted by {p
                        
                           s
                        ,
                        p
                        
                           m
                        ,
                        p
                        
                           e
                        }. Then the left-support region of q
                        
                           j2 consists of the points {ps
                        , p
                        
                           s
                           +1, …, p
                        
                           m
                           −1}. Similarly, the right-support region of q
                        
                           j2 consists of the points {p
                        
                           m
                           +1, p
                        
                           m
                           +2, …, pe
                        }. The total number of points in the left and right-support regions of q
                        
                           j2 is called the strength of q
                        
                           j2 and is used as the significance measure of q
                        
                           j2. The point in Q with the minimum strength will be relocated first, then the next one and so on. Fig. 8
                         illustrates the estimation of strengths for two different scenarios.

The running time of the findPolygonalApproximation procedure can be estimated as follows. Calculation of the neighborhood width takes Θ(ηn
                        2) time. The initial set of Q can be found in O(n). Computing the strengths of the points in initial set Q can be done in Θ(n) time, as the points in initial set Q lie on the contour. This is because, in the initial set Q, the corresponding point of each point p in Q can be easily found from the previous step of the procedure: when collinear points of C are suppressed. If a point p on C survives suppression, then p is included in Q and p becomes the corresponding point of itself.

An initial sorting of the points in Q takes Θ(nlgn) time. Estimations of relocation and removal errors of a point can be done in O(η) time, if the new error of the entire approximation (after removal or relocation of a point) is calculated incrementally. Once a point p in Q is relocated, the corresponding point of p can be found in O(η) time, since p will be relocated within the neighborhood only. Thus, after relocation/removal of a point, the strengths of the remaining points in Q take Θ(nlgn) to be sorted. Therefore, the complexity of the findPolygonalApproximation procedure is O(ηn
                        2
                        +
                        n
                        +
                        n
                        +
                        n
                        lg
                        n
                        +
                        n(η
                        +
                        n
                        lg
                        n))=
                        O(n
                        2(η
                        +lg
                        n)).

In this section, we report the experimental results obtained by applying our method on different databases of images, including MPEG7 CE Shape-1 database and a database of handwritten Arabic characters. These databases cover shapes with large number of contour points and noisy outlines. We also present the comparative evaluations of the proposed method. Experimental results show significant improvement in performance for different databases.

It is extremely important how we measure the quality of an approximation to evaluate the performance. Researchers have proposed different measures to evaluate the quality of polygonal approximations [5,6,12,13]. We briefly describe these measures below.

Compression ratio CR
                        =
                        n/n
                        
                           d
                        , where n is the number of points in the contour and nd
                         is the number of dominant points, measures the normalized compression rate of the approximation. However, it does not take into account the error of the approximation. A natural alternative is to use integral sum of squared error, 
                           I
                           S
                           E
                           =
                           
                              
                                 ∑
                                 
                                    i
                                    =
                                    1
                                 
                                 n
                              
                              
                                 
                                    e
                                    i
                                    2
                                 
                              
                           
                        , where e
                        
                           i
                         is the distance from a point p
                        
                           i
                         on the contour to the approximated line segment. The problem in using ISE is that it can always be reduced by using more dominant points! For this reason, weighted sum of square error, WE
                        =
                        ISE/CR, is used by many researchers that combines the compression ratio and the sum of square error.

Rosin [20] showed that the two terms in WE are not balanced causing the measure to be biased towards approximations with lower ISE (which can be easily attained by increasing the number of detected dominant points) and hence is not the best measure for comparing contours with different numbers of dominant points. He used two components: fidelity and efficiency. Fidelity is how well the polygonal approximation fits the contour relative to the optimal polygon in terms of the approximation error [18]: Fidelity
                        =(E
                        
                           opt
                        /E
                        
                           approx
                        )×100. Here, Eapprox
                         is the error of the polygonal approximation, Eopt
                         is the error incurred by the optimal algorithm; both algorithms are set to produce the same number of lines. The optimal polygon obtains the lowest possible error for a given number of dominant points.


                        Efficiency measures how compact the polygonal approximation is relative to the optimal polygon, which incurs the same error: Efficiency
                        =(M
                        
                           opt
                        /M
                        
                           approx
                        )×100. Here, Mapprox
                         is the number of lines in the polygonal approximation; Mopt
                         is the number of lines for the optimal polygon, with the same error.

To further balance the measure of WE, several researchers have used a modified WE defined as 
                           W
                           
                              E
                              x
                           
                           =
                           
                              
                                 I
                                 S
                                 E
                              
                              
                                 C
                                 
                                    R
                                    x
                                 
                              
                           
                         
                        [6,12,15,16]. Here, the parameter x is used to control the contribution of the denominator to the overall result in order to reduce the imbalance between the two terms. They used x
                        =1, 2 and 3. Carmona et al. [5] demonstrated that WE
                        2 performs better than WE. Based on the discussion above, we have optimized the WEx
                         measures while implementing the findPolygonalApproximation algorithm.

The proposed algorithm is first applied to the four popular shapes: chromosome, leaf, semicircles and infinity. These shapes have been used by many researchers to test their dominant point detection algorithms [5–7,12–16,22,23]. The results obtained by our algorithm for these four shapes are shown in Fig. 9
                        . A comparative evaluation for the proposed method with other existing algorithms is presented in Table 1
                        .

The effect of vertex relocations can be seen in Fig. 9. For example, for the chromosome shape, Fig. 9(b) is the final approximation obtained by optimizing WE
                        3 measure in vertex relocation/removal process. In the approximation of Fig. 9(b), several vertices have been located outside the contour (marked with arrows). Similar relocations of dominant point outside the original contour points can be noted in other approximations of Fig. 9.

As for the comparative evaluations in Table 1, the proposed algorithm performs favorably in all the basic shapes. Specially, the WEx
                         measures are very competitive for all the shapes. In fact, our algorithm achieves the lowest WE
                        3 measures for all four shapes. However, these basic shapes are not suitable for measuring the performance of the algorithm for noisy and large contours [16]. Hence, the proposed method is applied on several large datasets and the performance is evaluated statistically. The results are discussed next.

In this paper, we demonstrate the effectiveness of the proposed algorithm by testing it on two large databases: MPEG7 CE Shape-1 database [9] and a database of handwritten Arabic characters [1]. These databases are selected keeping two criteria in mind: contours with large number of points (covered by MPEG7 database) and contours with noisy outlines (covered by handwritten shapes). Figs. 10 and 11
                        
                         illustrate the results of our method on different shapes from MPEG7 CE Shape-1 database and Arabic character database respectively. These figures provide some visual evaluations of the proposed algorithm. Statistical evaluations of our method are presented next.

Performance of the proposed algorithm is statistically evaluated and compared with two other methods for the two databases mentioned earlier. The results are shown in Tables 2 and 3
                        
                        . Note that, the average number of dominant points for Arabic handwriting database is comparable for all three methods. For MPEG7_CE-Shape-1_Part_B database, the method in [16] uses less number of dominant points. However, the method in [16] results in much higher average ISE (almost nine folds as compared to the proposed method), as shown in Table 3.


                        Table 3 shows the key performance measures for all three methods for two datasets. The following comments can be made based on the values in Table 3. For both of the databases, our method obtained the least WE
                        3 measures on average. Statistically, the proposed method results in at least 18%–25% improvements in performance in terms of WE
                        3 measures. Note that, for MPEG7_CE-Shape-1_Part_B database, our approach has resulted in better WE
                        3 measure with average ISE similar to the method in [12]. This improvement is due to a larger CR in our case, which indicates that relocating and/or removing vertices do have impact on the performance measures. Similar comments are applicable for the results obtained for Arabic handwritten character database also. Improvement in WE
                        3 measures, as shown in Table 3, indicates that the proposed algorithm can find better approximations without going to the extreme in terms of CR and ISE measures.

It would be interesting to estimate the number of vertices in the approximations which are located outside the original contours by our method. On average, 20.5% and 15% vertices of the final approximating polygons lie outside the contour points for MPEG7_CE-Shape-1_Part_B and handwritten Arabic characters database respectively. Based on the discussion above and with these large numbers of relocated points in hand, our earlier expectations regarding relaxed approximations having better error measure get more substantiated.

As discussed above, the proposed method obtains better approximations with significant number of vertices located outside the contour. To further substantiate the flexibility of vertex relocation in reducing the approximation error, we conduct the following experimentations. In these experimentations, the vertex relocation process is added as a post-processing phase to any other suitable polygonal approximation algorithm. The reason behind this approach is to demonstrate the effect of vertex relocation in reducing the approximation errors. Therefore, the following steps are followed in these experimentations. Note that, no vertices will be removed in these steps.
                           
                              Step 1:
                              Estimate the point neighborhoods for any contour C.

Obtain a set of dominant points CR
                                  of C using any suitable algorithm.

For each point p in CR
                                 , estimate the relocation error of p and relocate it (if needed). [The vertex relocation process].

Iterate Step 3 until no points in CR
                                  can be relocated.

Again, we utilize the two databases described earlier. For each sample from these two databases, the neighborhoods are estimated and two preliminary approximations are obtained using the algorithms described in [12] and [16]. Then the vertex relocation process is carried out (without deleting any point) to reduce ISE for both approximations. Statistics on the samples from the two databases are shown in Table 2. Note that, the algorithm in [12] generally uses larger number of dominant points compared to the algorithm in [16]. This is due to the fixed suppression parameter used in [12], which was estimated adaptively in [16].

Performance improvements due to the vertex relocation process for these two databases are shown in Table 4
                        . The average reduction in error is calculated for each database. In addition, the standard deviation of the reductions in error is also calculated for each database. As can be seen in Table 4, vertex relocation can significantly reduce the errors in both of the test databases, without further increasing the number of dominant points of the ‘in-hand’ approximations. Note that, a much higher reduction of errors is obtained in MPEG7_CE-Shape-1_Part_B database for the augmented method in [12]. However, the standard deviations of the error-reductions are comparable across all databases and methods. Another point to note from Table 4 is the higher reduction of error by vertex relocation for the method in [12], compared to the one in [16]. As mentioned earlier, the algorithm in [12] generally results in higher number of dominant points, which gives the vertex relocation process more opportunity to relocate the points and reduce error further.


                        Fig. 12
                         illustrates the effects of vertex relocation on a sample image of Arabic character Hamza (ء). Note that, vertex relocation process doesn't increase or decrease the number of vertices in the original approximations. However, the WE
                        3 measures are significantly decreased with the relocation of vertices. In addition, several vertices are located outside the original contour; like the right-top vertex in Fig. 12(c) and the left-bottom vertex in Fig. 12(e).


                        Fig. 13
                         illustrates the number of samples from Arabic handwriting database [1] for which specific ranges of error reductions are obtained. Error reductions between 10% and 30% are obtained for around 66% samples for both of the algorithms in [12] and [16], when both algorithms are augmented with vertex relocation. Note that, this reduction in error is achieved without increasing the number of vertices of the polygons generated by the original algorithms.

Another important aspect to consider in our context is the number vertices of the approximations that are really relocated to reduce the error. As can be seen in Table 4, a significant amount of vertices is moved beyond their original positions, while reducing the error by vertex relocation. Also, more vertices are relocated for MPEG7_CE-Shape-1_Part_B database compared to the other database, which is expected as the MPEG database contains larger contours. Interestingly, these large numbers of relocated vertices indicate a very important conclusion: the reduction of errors have been distributed over a large portion of the original approximations. Based on the figures in Table 4, we may conclude that for almost one-third to half of the vertices of the original approximations, there might be better choices for the locations of the vertices to reduce approximation errors! Thanks to the vertex relocation process in the neighborhoods, that allows us to find these better locations.

To better understand the effect of neighborhood width on the reduction of approximation error, we construct Fig. 14
                        . Again, we augment the two methods in [12] and [16] with vertex relocation process. For each of the two methods, we group the images from MPEG7_CE-Shape-1_Part_B database by their estimated neighborhood widths and then calculate the average reductions of error in each group. The results of such calculations are shown in Fig. 14. The general downward trend in the reductions of error for larger neighborhood widths can be understood as follows. A higher neighborhood width estimated from the estimateNeighborhood procedure indicates that a large number of points on the contour can be suppressed. This means that the contour might possibly be approximated by relatively few number of dominant points. This in turn reduces the room for vertex relocation process to further reduce the approximation error for contours with higher neighborhood widths.

In the experimentations above, the vertex relocation process is carried out once for each sample. This is primary done to reduce the computational overhead, as the relocation process may take long time for contours with large number of points. However, the question remains whether iterating the relocation process can further reduce the error of the approximation. To answer this question, we carry out experimentations on the handwritten Arabic character database, while varying the maximum number iterations in the relocation process. The number of maximum iterations of the relocation process is varied between one and 10. For each case, the average ISE of the final approximations is calculated. The result is shown in Fig. 15
                        .

It can be seen from Fig. 15 that the average errors in approximations remain almost constant beyond three iterations of the relocation process. Even a single iteration of the relocation process will work fine, since the difference in error is not too much (around 4% reductions in ISE if two iterations are used). Therefore, for faster results, a single iteration of the relocation process can be used.

@&#CONCLUSIONS@&#

In this paper, we demonstrate that a relaxed approximation can be a better choice in approximating digital planar shape due to its flexibility in reducing approximation error. In addition, we conclude from our experimentations that a significant amount of vertices in the approximations obtained by existing algorithms is in need of relocations to get better approximations. Our vertex relocation process can be utilized by other researchers to improve the existing methods.

The proposed algorithm can be made faster in specific applications. If the shapes are normalized in a particular application, then a fixed neighborhood width can be used. This fixed neighborhood width can be calculated by running the estimateNeighborhood procedure on a number of samples and then by averaging the estimated neighborhood widths.

@&#ACKNOWLEDGMENTS@&#

We thank Qassim University, Saudi Arabia, for partially supporting this research work. The author is grateful to Prof. Sabri A. Mahmoud for critical comments at the early stage of this work. The author also thanks the anonymous reviewers for their comments that greatly improved the clarity of the paper.

@&#REFERENCES@&#

