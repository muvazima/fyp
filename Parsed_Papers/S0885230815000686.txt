@&#MAIN-TITLE@&#Articulatory feature-based pronunciation modeling

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We review our research developing articulatory feature-based pronunciation models.


                        
                        
                           
                           We argue for sub-phonetic features inspired by articulatory phonology.


                        
                        
                           
                           We review evaluations via frame-level perplexity and lexical access performance.


                        
                        
                           
                           Our models typically outperform phone-based models.


                        
                        
                           
                           Context-dependent surface feature models outperform context-independent models.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Speech recognition

Articulatory features

Pronunciation modeling

Dynamic Bayesian networks

@&#ABSTRACT@&#


               
               
                  Spoken language, especially conversational speech, is characterized by great variability in word pronunciation, including many variants that differ grossly from dictionary prototypes. This is one factor in the poor performance of automatic speech recognizers on conversational speech, and it has been very difficult to mitigate in traditional phone-based approaches to speech recognition. An alternative approach, which has been studied by ourselves and others, is one based on sub-phonetic features rather than phones. In such an approach, a word's pronunciation is represented as multiple streams of phonological features rather than a single stream of phones. Features may correspond to the positions of the speech articulators, such as the lips and tongue, or may be more abstract categories such as manner and place.
                  This article reviews our work on a particular type of articulatory feature-based pronunciation model. The model allows for asynchrony between features, as well as per-feature substitutions, making it more natural to account for many pronunciation changes that are difficult to handle with phone-based models. Such models can be efficiently represented as dynamic Bayesian networks. The feature-based models improve significantly over phone-based counterparts in terms of frame perplexity and lexical access accuracy. The remainder of the article discusses related work and future directions.
               
            

automatic speech recognition

International Phonetic Alphabet

lip constriction location

lip opening degree

tongue tip constriction location

tongue tip opening degree

tongue body constriction location

tongue body opening degree

velum opening degree

glottis opening degree

conditional probability table

@&#INTRODUCTION@&#

Human speech is characterized by enormous variability in pronunciation. Two speakers may use different variants of the same word, such as EE-ther vs. EYE-ther, or they may have different dialectal or non-native accents. There are also speaker-independent causes, such as speaking style – the same words may be pronounced carefully and clearly when reading but more sloppily in conversational or fast speech (Johnson, 2004) (e.g. “probably” may be pronounced “probly” or even “prawly”). In this article we are concerned with building a pronunciation model that is a distribution over the possible sub-word sequences that may be produced in uttering a given word; and we focus on building a model that is as accurate as possible for conversational speech. Here we address speaker-independent pronunciation variability, i.e. variability due to speaking style or context, although the methods we describe are applicable to studying dialectal or idiolectal variation as well. There are many possible applications for this work, including in automatic speech recognition (ASR), linguistics, and psycholinguistics. In this work, we are mainly motivated by the ASR application, where pronunciation variation in conversational speech is a significant problem.

Pronunciation variation has long been considered a major factor in the poor performance of ASR systems on conversational speech (Ostendorf, 1999; McAllaster et al., 1998; Weintraub et al., 1996a; Fosler-Lussier, 1999; Strik and Cucchiarini, 1999; Livescu et al., 2012). Early work on this topic analyzed this effect in various ways. For example, Weintraub et al. (1996a) compared the error rates of a recognizer on identical word sequences recorded in identical conditions but with different styles of speech, and found the error rate to be almost twice higher for spontaneous conversational sentences than for the same sentences read by the same speakers in a dictation style. Fosler-Lussier (1999) found that words pronounced non-canonically are more likely than canonical productions to be deleted or substituted by an automatic speech recognizer. McAllaster et al. (1998) generated synthetic speech with pronunciations matching canonical dictionary forms, and found that it can be recognized with error rates about eight times lower than for synthetic speech with the pronunciations observed in actual conversational data.

Considering recent advances in speech recognition, one may wonder whether this is still a challenge. Indeed it is: Although error rates in general have gone down dramatically, they are still 50% higher for non-canonically pronounced words in a recent discriminatively trained recognizer (Livescu et al., 2012). Most speech recognition systems use context-dependent (such as triphone) acoustic models to implicitly capture some of the pronunciation variations. However, this approach may be insufficient for modeling pronunciation effects that involve more than a single phone and its immediate neighbors, such as the rounding of [s] in strawberry. The work of Jurafsky et al. (2001) suggests that triphones are in general mostly adequate for modeling phone substitutions, but inadequate for handling insertions and deletions.

There have been a number of approaches proposed for handling this variability in the context of phone-based speech recognition. One approach, which was studied heavily especially in the 1990s but also more recently, is to start with a dictionary containing canonical pronunciations and add to it those alternative pronunciations that occur often in some database, or that are generated by deterministic or probabilistic phonetic substitution, insertion, and deletion rules (e.g., Sloboda and Waibel, 1996; Riley et al., 1999; Weintraub et al., 1996b; Strik and Cucchiarini, 1999; Fosler-Lussier, 1999; Saraçlar and Khudanpur, 2004; Hazen et al., 2005). Other approaches are based on alternative models of transformations between the canonical and observed pronunciations, such as phonetic edit distance models (Hutchinson and Droppo, 2011) and log-linear models with features based on canonical-observed phone string combinations (Zweig and Nguyen, 2009). Efforts to use such ideas in ASR systems have produced performance gains, but not of sufficient magnitude to solve the pronunciation variation problem.

One often-cited problem is that with the introduction of additional pronunciations, confusability between words is also introduced (Finke and Waibel, 1997; Riley et al., 1999). This may be due to the large granularity of phone-level descriptions: An actual pronunciation may contain a sound that is neither a dictionary phone nor an entirely different phone, but rather something intermediate (Saraçlar and Khudanpur, 2004), suggesting that a finer-grained level of representation may be needed. One way of introducing a finer-grained representation is to represent words in terms of multiple streams of sub-phonetic features, rather than a single stream of phones. This idea is supported by modern phonological theories such as autosegmental phonology (Goldsmith, 1990) and articulatory phonology (Browman and Goldstein, 1992). Many authors have pursued such approaches in one form or another (Deng and Sun, 1994; Erler and Freeman, 1994; Kirchhoff, 1996; Richardson et al., 2003; Mitra et al., 2012; Livescu and Glass, 2004a; Hu et al., 2010). Early approaches used hidden Markov models (HMMs) in which each state corresponds to a combination of articulatory feature values (Deng and Sun, 1994; Erler and Freeman, 1994; Richardson et al., 2003). The HMM state space is constructed by allowing features to evolve asynchronously between phonetic targets, resulting in a very large state space. To control the size of the space, this work involved constraining the models, for example by requiring that the features re-synchronize often (e.g. at phonetic targets).

In the work we review here, we have proposed explicit models of multiple streams of articulatory features, which factor the large state space of articulatory configurations into models of inter-articulator asynchrony and articulatory substitution (e.g., reduction). The factorization of the joint articulatory feature distribution can be represented via graphical models (in particular dynamic Bayesian networks) and requires fewer model parameters than if we “compiled” the model into an HMM. Incorporating such models into complete recognizers is an important research question that we do not address in this paper; instead, here we focus on evaluation of pronunciation models independently of any particular recognizer. In prior work on new phone-based pronunciation models, the models were evaluated through experiments with manual phonetic transcriptions. Similarly, here we describe experiments using manual phonetic transcriptions converted to articulatory features. Section 4 provides more details on the evaluation methods.

In the next section, we provide detailed motivating background and examples. The remainder of the paper presents the proposed model (Section 3), along with a feature set based on articulatory phonology and the model representation in terms of dynamic Bayesian networks; summarizes a series of evaluations using perplexity and lexical access accuracy as performance measures (Section 4), and gives a brief description of model variants and extensions of the basic model that have been explored by ourselves and others (Section 5).

@&#MOTIVATION@&#

We motivate our approach by considering in greater detail some prior work and relevant examples. We define a pronunciation of a word as a representation of the way the word can be produced by a speaker, in terms of some set of linguistically meaningful sub-word units. We distinguish between a word's (i) underlying (or target or canonical) pronunciations, the ones typically found in a dictionary and represented as strings of phonemes, and its (ii) surface pronunciations, the ways in which a speaker may actually produce the word. While a given word usually has one or a few underlying phonetic pronunciations, the same word may have dozens of surface phonetic pronunciations. Table 1
                      shows canonical pronunciations for four words, along with all of their surface pronunciations that appear in the portion of the Switchboard conversational database that has been manually transcribed phonetically (Greenberg et al., 1996). The data set is described further in Section 4.3. The surface pronunciations given here are somewhat simplified from the original transcriptions for ease of reading; e.g., [dx] has been transcribed as [d] and [nx] as [n], and vowel nasalization is not shown. The exact transcriptions are to some extent subjective.
                        1
                     
                     
                        1
                        As noted by Johnson, “Linguists have tended to assume that transcription disagreements indicate ideolectal differences among speakers, or the moral degeneracy of the other linguist.” (Johnson, 2002)
                      However, there are a few points about the data in Table 1 that are clear:
                        
                           •
                           There is a large number of surface pronunciations per word, with most occurring only once in the data.

The canonical pronunciation rarely appears in the transcriptions: It was not used at all in the two instances of sense, eleven of probably, and five of everybody, and used four times out of 89 instances of don’t.

Many observed pronunciations differ grossly from the canonical one, with entire phones or syllables deleted (as in probably → [p r ay] and everybody → [eh b ah iy]) or inserted (as in sense → [s eh n t s]).

Many observed pronunciations are the same as those of other English words. For example, according to this table, sense can sound like cents and sits; probably like pry; and don’t like doe, own, oh, done, a, new, tow, and dote. In other words, it would seem that all of these word sets should be confusable.

These four words are not outliers: For words spoken at least five times in this database, the mean number of distinct pronunciations is 8.8.
                        2
                     
                     
                        2
                        This is after dropping some diacritics and collapsing similar phone labels, reducing the phonetic label set from 396 to 179 distinct labels. Before collapsing the labels, the mean number of distinct pronunciations for words spoken at least five times is 11.0.
                     
                  

One approach used in ASR research for handling this variability is to start with a dictionary containing only canonical pronunciations and add to it those alternate pronunciations that occur often in some database (Strik and Cucchiarini, 1999). The alternate pronunciations can be weighted according to the frequencies with which they occur in the data. By limiting the number of pronunciations per word, we can ensure that we have sufficient data to estimate the probabilities, and we can (to some extent) control the degree of confusability between words. However, this does not address the problem of the many remaining pronunciations that do not occur with sufficient frequency to be counted. Perhaps more importantly, for any reasonable-sized vocabulary and database, most words in the vocabulary will only occur a handful of times, and many will not occur at all. For example, of the 29,695-word vocabulary of the Switchboard database, 18,504 words occur fewer than five times. It is therefore infeasible to robustly estimate the probabilities of most words’ pronunciations.

However, many pronunciation variants are predictable. For example, we have seen that sense can be pronounced [s eh n t s]. In fact, there are many words that show a similar pattern of epenthetic stop insertion: defense → [d ih f eh n t s], prince → [p r ih n t s], insight → [ih n t s ay t], and so on. These can be generated by a phonetic rewrite rule, ɛ → t / n _ s, read “The empty string (ɛ) can become t in the context of an n on the left and s on the right.” Many pronunciation phenomena are described well by rules of the form p
                        1 → p
                        2 / c
                        
                           l
                         _ c
                        
                           r
                        , where p
                        1, p
                        2, c
                        
                           l
                        , and c
                        
                           r
                         are phonetic labels or strings. Such rules have been documented in the linguistics, speech science, and speech technology literature (e.g., Heffner, 1950; Schane, 1973; Ladefoged, 2001; Kaisse, 1985; Oshika et al., 1975) and are the basis for another phone-based pronunciation modeling approach: One or a few main pronunciations are listed for each word, and a bank of rewrite rules is used to generate additional pronunciations. The rules can be pre-specified (Hazen et al., 2005) or learned from data (Finke and Waibel, 1997), and their firing probabilities can also be learned (Shu and Hetherington, 2002). A related approach is to learn, for each phoneme, a decision tree representing a detailed set of rules for predicting the phoneme's surface pronunciation depending on context (Riley and Ljolje, 1996; Fosler-Lussier, 1999). This approach alleviates the data sparseness issue mentioned above: Instead of observing many instances of each word, we need only observe many instances of words susceptible to the same rules. But data sparseness still remains an issue: There are many possible phonetic contexts to consider, and many of them occur very rarely.

There is also the additional challenge of confusability, as mentioned before and studied by others previously (Finke and Waibel, 1997; Riley et al., 1999; Fosler-Lussier and Morgan, 1999). While word confusions may be disambiguated by a language model, previous work has shown that it is not always enough to alleviate the problem (Goldwater et al., 2010). The issue of confusability could be alleviated by using a finer-grained phonetic labeling of the observed pronunciations. For example, a more detailed transcription of the two instances of sense above is [s eh
                           n
                         n t s] and [s ih
                           n
                         t s], indicating that the two vowels were nasalized, a common phenomenon for vowels occurring before nasal consonants. Similarly, don’t → [d ow t] is more finely transcribed [d ow
                           n
                         t]. This labeling makes it clear that that what seems like a nasal consonant deletion in don’t is not a deletion at all; rather, the nasalization feature surfaces on the vowel preceeding the nasal consonant. With this labeling, the second instance of sense is no longer confusable with sits, and don’t is no longer confusable with dote. (The first sense token, however, is still confusable with cents.)
                           3
                        
                        
                           3
                           In this discussion we are not directly addressing the issue of which confusability is important to eliminate, and which is already handled by the language model. We are considering all potential confusability between words. A study of the detailed interaction between the language model and confusability is outside the scope of this paper.
                         Next we consider an alternative fine-grained representation provided by sub-phonetic features.

Returning to the two examples of sense above, it is useful to consider the process by which the [t] in these productions comes about. In order to produce an [n], the speaker must make an alveolar closure with the tongue tip, as well as lower the velum to allow airflow to the nasal cavity. To produce the following [s], the tongue closure is slightly released, and voicing and nasality are turned off. If the voicing and nasality are turned off before the tongue closure is released, this results in a segment of the speech signal with no voicing or nasality but with complete tongue tip closure; this configuration of articulators happens to be the same one used in producing a [t]. The second example of sense is characterized by more extreme asynchrony: Nasality and voicing are turned off even before the complete tongue closure is made, leaving no [n] and only a [t].

Such observations motivate a representation of pronunciations using, rather than a single stream of phonetic labels, multiple streams of sub-phonetic features such as nasality, voicing, and closure degrees. Tables 2–4
                        
                        
                         show such a representation of the canonical pronunciation of sense and of the observed pronunciations [s eh
                           n
                         n t s] and [s ih
                           n
                         t s]. Deviations from the canonical values are marked (*). In Table 3, all of the feature values are produced faithfully, but with some asynchrony in the timing of feature changes. In Table 4, most feature values are produced canonically, except for slightly different amounts of tongue opening accounting for the observed [ih
                           n
                        ]. This contrasts with the phonetic representation, in which half of the phones are different from the canonical pronunciation.

This representation allows us to account for the three phenomena seen in these examples – vowel nasalization, [t] insertion, and [n] deletion – with the single mechanism of asynchrony, between voicing and nasality on the one hand and the tongue features on the other. don’t → [d ow
                           n
                         t] is similarly accounted for, as is the common related phenomenon of epenthetic [p] insertion in words like warmth → [w ao r m p th].

The feature-based representation may also allow us to better handle the sense/cents confusability. By ascribing the [t] to part of the [n] closure gesture, this analysis predicts that a [t] inserted in this environment will be shorter than a “true” [t]. This, in fact, appears to be the case in at least some contexts (Yoo and Blankenship, 2003). This implies that we may be able to distinguish sense → [s eh
                           n
                         n t s] from cents based on the duration of the [t], without an explicit model of epenthetic [t] duration.

This is an example of the more general idea that we should be able to avoid confusability by using a finer-grained representation of observed pronunciations. The feature-based approach makes it possible to have a fine-grained representation, without the explosion in model size that would result if we used a finer-grained phone set. The epenthetic stop examples also suggest that pronunciation models should be sensitive to timing information. In experiments with manual annotation, it has been found that inter-annotator agreement is higher when labeling features than when labeling phones (Livescu et al., 2007a); presumably this is because, whenever a speech sound is intermediate to two phones, a phone-based representation forces labelers to choose between multiple labels that are equally poor descriptions of the actual sound.

This reasoning is in line with modern ideas in linguistics. The paradigm of a string of phonemes (plus possibly rewrite rules) is characteristic of the generative phonology of the 1960s and 1970s (e.g., Chomsky and Halle, 1968). More recent linguistic theories, under the general heading of non-linear or autosegmental phonology (Goldsmith, 1990), have done away with the single-string representation, opting instead for multiple tiers of features. An example of this is articulatory phonology (Browman and Goldstein, 1992), which posits that most or all surface variation results from the relative timings of articulatory gestures, using a representation similar to that of Tables 2–4. Articulatory phonology is a work in progress, but one that motivates ideas in our and others’ work (Mitra et al., 2012; Ghosh and Narayanan, 2011).

The remaining sections review a line of research using this approach: an initial model with context-independent substitutions (Livescu and Glass, 2004a,b; Livescu, 2005), a more complex model with context sensitivity (Bowman and Livescu, 2010; Jyothi et al., 2011; Jyothi, 2013), evaluation via perplexity and lexical access, and related work that has used our models for other tasks (Tang et al., 2012; Prabhavalkar et al., 2011, 2013; Hasegawa-Johnson et al., 2007; Livescu et al., 2007b; Jyothi and Livescu, 2014).

Motivated by the observations of the previous section, this section describes the proposed approach of modeling pronunciation variation in terms of the time course of multiple sub-phonetic features. The main components of the model are (1) a baseform dictionary, defining the sequence of target values for each feature, from which the surface realization can stray via the processes of (2) inter-feature asynchrony, in which different features proceed through their trajectories at different rates, and (3) substitutions of individual feature values, which subsumes both reductions and assimilations. Unlike in many phone-based models, we do not allow deletions or insertions of features, instead accounting for apparent phone insertions or deletions as resulting from feature asynchrony or substitution. We formalize the models as dynamic Bayesian networks (DBNs), a generalization of HMMs that allows for natural and parsimonious representations of multi-stream models. Fig. 1
                      shows DBN representations for our models; they are described in detail in the sections below.

We define an underlying pronunciation of a word in the usual way as a string of phonemes, or more generally a string of phonetic units found in a baseform pronuncing dictionary.
                        4
                     
                     
                        4
                        Building a useful baseform dictionary is itself an interesting problem (Lamel and Adda, 1996), and some recent work dispenses with the pre-built baseform dictionary and instead learns all possible pronunciations from acoustic data (McGraw et al., 2013). For our purposes here we assume the baseforms are given.
                      We define surface pronunciations in a somewhat unconventional way. In Section 2.2, we proposed a representation consisting of multiple streams of feature values, as in Tables 2–4. We also mentioned, but did not formalize, the idea that the representation should be sensitive to timing information, so as to take advantage of knowledge such as the tendency of epenthetic stops to be shorter than non-epenthetic stops. To formalize this, we define a surface pronunciation as a time-aligned listing of all of the surface feature values produced by a speaker. Such a representation might look like Table 4 with the addition of time stamps. In practice, we assume that time is discretized into short frames, say of 10ms each as is typical in ASR.

There is no standard feature set used in feature-based ASR research. One commonly used type of feature set is based on the categories used in the International Phonetic Alphabet (IPA) (Albright, 1958) to distinguish phones, such as manner, place, voicing, nasalization, rounding, and height and frontness for vowels. However, for some types of pronunciation variation, this feature set does not seem well-suited. One example is the reduction of consonants to glides or vowel-like sounds. For example, a /b/ with an incomplete closure may surface as an apparent [w]. Intuitively, there is only one dimension of change, the reduction of the constriction at the lips. In terms of IPA-based features, however, this would involve a large number of substitutions: The manner would change from stop to approximant, and the vowel front/back and height features would change from nil to the appropriate values.

Motivated by such examples, we have used a feature set based on the vocal tract variables of Browman and Goldstein's articulatory phonology (AP) (Browman and Goldstein, 1992), shown in Table 5
                        . We have informally assumed this type of features in examples in previous sections. These features refer to the locations and degrees of constriction of the major articulators in the vocal tract. The state space of this feature set consists of 41,472 combinations of feature values. However, in practice we do not allow all of these combinations, due to constraints that we impose on the asynchrony and substitutions in the model.

This feature set was developed with articulatory phonology as a starting point. However, since neither the entire feature space nor a complete mapping from a phone set to feature values was available in the literature, we have filled in gaps as necessary, using the guideline that the number of feature values should be kept as low as possible, while differentiating between as many phones as possible. In constructing phone-to-feature mappings, we have consulted the articulatory phonology literature (Browman and Goldstein, 1986, 1989, 1990a,b, 1992), phonetics literature (Ladefoged, 2001; Stevens, 1998), and X-ray tracings of speech articulation (Perkell, 1969). Additional details about the features and a phone-to-feature mapping are given in (Livescu, 2005).

In preliminary experiments comparing different feature sets in our pronunciation models, these articulatory features outperformed IPA-style features (Livescu, 2005).

In this section, we describe a procedure for generating all of the possible surface pronunciations of a given word, along with their probabilities. We denote the N features F
                        
                           j
                        , 1≤
                        j
                        ≤
                        N. A T-frame surface pronunciation in terms of these features is denoted 
                           
                              Surf
                              i
                              j
                           
                        , 1≤
                        j
                        ≤
                        N, 1≤
                        i
                        ≤
                        T, where 
                           
                              Surf
                              i
                              j
                           
                         is the surface value of feature F
                        
                           j
                         in time frame i.

Each word has one or more phonetic baseforms, each of which is converted to a table of underlying feature values using a phone-to-feature mapping table.
                           5
                        
                        
                           5
                           A table used in our work can be obtained from Livescu (2005).
                         Dynamic phones consisting of more than one feature configuration are divided into multiple segments: Stops are divided into closure+release, affricates into closure+frication, and diphthongs into the beginning and ending configurations. The mapping from phones to feature values may be non-deterministic in some cases. Table 6
                         shows a possible baseform for sense.

The top row of Table 6 is simply an index into the underlying phone sequence; it will be needed later in the discussion of asynchrony. Note that it is assumed that all features have the same number of targets in a given word. For example, lips is assumed to have four targets, although they are all identical. This means that, for each phone in the baseform, and for each feature, there must be a span of time in the production of the word during which the feature is “producing” that phone. This is a basic assumption that, in practice, amounts to a duration constraint and makes it particularly easy to talk about feature asynchrony by referring to index differences.

We assume that in the first frame of a word, all of the features begin in index 1. Denoting the index, or position, of feature j at time i 
                           
                              
                                 Pos
                                 i
                                 j
                              
                           , this means 
                              
                                 Pos
                                 1
                                 j
                              
                            =1∀
                           j.
                              6
                           
                           
                              6
                              This corresponds to the (strong) assumption that there is no cross-word asynchrony. Relaxing this assumption is in principle straightforward but is a topic for future work.
                            In subsequent frames, each feature can either stay in the same state or transition to the next one with some (possibly phone-dependent) transition probability. Features may transition at different times, and this is what we refer to as feature asynchrony. We define the degree of asynchrony between two features F
                           
                              j
                            and F
                           
                              k
                            in a given time frame i as the absolute difference between their indices in that frame:


                           
                              
                                 (1)
                                 
                                    
                                       aSync
                                       i
                                       
                                          j
                                          :
                                          k
                                       
                                    
                                    =
                                    |
                                    
                                       Pos
                                       i
                                       j
                                    
                                    −
                                    
                                       Pos
                                       i
                                       k
                                    
                                    |
                                    .
                                 
                              
                           
                        

Similarly, we define the degree of asynchrony between two sets of features F
                           
                              A
                            and F
                           
                              B
                            as the difference between the means of their indices, rounded to the nearest integer:


                           
                              
                                 (2)
                                 
                                    
                                       aSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                    =
                                    round
                                    (
                                    |
                                    mean
                                    (
                                    
                                       Pos
                                       i
                                       A
                                    
                                    )
                                    −
                                    mean
                                    (
                                    
                                       Pos
                                       i
                                       B
                                    
                                    )
                                    |
                                    )
                                    ,
                                 
                              
                           where A and B are subsets of {1, …, N} and F
                           {j
                              1,j
                              2,…}
                           ={F
                           
                              j
                              1
                           , F
                           
                              j
                              2
                           , …}. More “synchronous” configurations may be preferred, and there may be an upper bound on the degree of asynchrony. We express this via a distribution over the degree of asynchrony between features in each frame, 
                              p
                              (
                              
                                 aSync
                                 i
                                 
                                    j
                                    :
                                    k
                                 
                              
                              )
                           , or feature sets, 
                              p
                              (
                              
                                 aSync
                                 i
                                 
                                    A
                                    :
                                    B
                                 
                              
                              )
                           . Given the index sequence for each feature, the corresponding frame-by-frame sequence of target feature values, 
                              
                                 Tar
                                 i
                                 j
                              
                           , 1≤
                           i
                           ≤
                           T, is drawn according to the baseform table (Table 6).

A feature may fail to reach its target value, instead substituting another value. This may happen, for example, if a constriction is reduced, or if a given feature value assimilates to neighboring values. One example of substitution is sense → [s ih
                              n
                            t s]; a frame-by-frame representation is shown in Table 7
                           . We model substitutions with a conditional distribution over each surface feature value in a given frame, given its corresponding underlying value and other context variables, 
                              p
                              (
                              
                                 Surf
                                 i
                                 j
                              
                              |
                              
                                 Tar
                                 i
                                 j
                              
                              ,
                              
                                 c
                                 i
                                 j
                              
                              )
                           , where 
                              
                                 c
                                 i
                                 j
                              
                            is a vector of context variables such as neighboring feature values. In initial experiments looking at the separate effects of asynchrony and substitutions, we have found that substitutions alone account for more conversational pronunciations than asynchrony alone, but both make a significant contribution (Livescu, 2005).

@&#SUMMARY@&#

To summarize the generative recipe, in this model a surface pronunciation of a given word is produced in the following way:
                              
                                 1.
                                 Choose a baseform from the baseform dictionary.

For the chosen baseform, generate state sequences for all features, with probabilities given by the transition and asynchrony probabilities.

Given the generated index sequence, generate underlying feature values by drawing from the baseform feature distributions at each index. (This is a deterministic lookup in the case of a single baseform.)

For each underlying feature value, generate a surface feature value by drawing from the substitution distribution.

The model we have described can be naturally represented as a DBN. Fig. 1(a) shows a DBN representing our model with two feature streams and with context-independent feature substitutions. In this article, we model each word independently, although ultimately we should include context from the previous and following words as well. In the model with context-independent substitutions, the variables at time frame i are as follows:
                           
                              
                                 
                                    
                                       Word
                                       i
                                       
                                    
                                  – The current word at time i.


                                 
                                    
                                       Trans
                                       i
                                       j
                                    
                                  – binary transition variable. 
                                    
                                       Trans
                                       i
                                       j
                                    
                                    =
                                    1
                                  indicates that frame i is the last frame of the current state for feature j.


                                 
                                    
                                       Pos
                                       i
                                       j
                                    
                                  – index of feature j at time i. 
                                    
                                       Pos
                                       1
                                       j
                                    
                                    =
                                    1
                                    ∀
                                    j
                                 ; in subsequent frames 
                                    
                                       Pos
                                       
                                          i
                                          +
                                          1
                                       
                                       j
                                    
                                    =
                                    
                                       Pos
                                       i
                                       j
                                    
                                  if 
                                    
                                       Trans
                                       i
                                       j
                                    
                                  = 0, and 
                                    
                                       Pos
                                       i
                                       j
                                    
                                 +1 otherwise.


                                 
                                    
                                       Tar
                                       i
                                       j
                                    
                                  – underlying (target) value of feature j.


                                 
                                    
                                       Surf
                                       i
                                       j
                                    
                                  – surface value of feature j. p(
                                    
                                       Surf
                                       i
                                       j
                                    
                                    |
                                    
                                       Tar
                                       i
                                       j
                                    
                                 ) encodes allowed feature substitutions.


                                 
                                    
                                       aSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                  and 
                                    
                                       checkSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                  represent the asynchrony model. 
                                    
                                       aSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                  is drawn from an (unconditional) distribution over the integers, while 
                                    
                                       checkSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                  checks that the degree of asynchrony between A and B is in fact equal to 
                                    
                                       aSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                 . To enforce this constraint, 
                                    
                                       checkSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                  is always observed with value 1 and is given deterministically by its parents’ values: 
                                    
                                       checkSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                    =
                                    1
                                    ⇔
                                    round
                                    
                                       
                                          
                                             |
                                             mean
                                             
                                                
                                                   
                                                      
                                                         Pos
                                                         i
                                                         A
                                                      
                                                   
                                                
                                             
                                             −
                                             mean
                                             
                                                
                                                   
                                                      
                                                         Pos
                                                         i
                                                         B
                                                      
                                                   
                                                
                                             
                                             |
                                          
                                       
                                    
                                    =
                                    
                                       aSync
                                       i
                                       
                                          A
                                          :
                                          B
                                       
                                    
                                 
                              

If we assume that the features always synchronize at the end of a word, then in the final frame we must enforce that all features are exiting their final state. Cross-word asynchrony (as in “green beans” → [g r iy m b iy n z]) and cross-word coarticulation are also important, and can be incorporated into such a model, but as mentioned previously, we limit the presentation to the case where asynchrony and conditioning contexts are restricted to be within word boundaries.

We can use standard DBN inference algorithms to answer such questions as:
                           
                              •
                              Decoding: Given a surface pronunciation (set of surface feature value sequences 
                                    
                                       Surf
                                       
                                          1
                                          :
                                          T
                                       
                                       
                                          1
                                          :
                                          N
                                       
                                    
                                 ), what is the most likely word that generated them?

Parameter learning: Given a training set of words and corresponding surface pronunciations, what are the best settings of the conditional probability tables in the DBN?
                                    7
                                 
                                 
                                    7
                                    This assumes training data in the form of labeled surface feature values. If these are not available, but only acoustics are, training can be done by combining the model with an acoustic observation model; this is outside the scope of this article.
                                 
                              

Alignment: Given a word and a corresponding surface pronunciation, what are the most likely values of the hidden variables 
                                    
                                       Pos
                                       i
                                       j
                                    
                                  and 
                                    
                                       Tar
                                       i
                                       j
                                    
                                 ? This is useful for analysis or qualitative evaluation.

Parameter learning can be done with a maximum-likelihood criterion via the Expectation-Maximization algorithm (Dempster et al., 1977), or with discriminative criteria (e.g., Pernkopf and Bilmes, 2005).


                        Fig. 1(b) shows a version of the model where the surface features depend on additional context variables besides the target feature values. In this case the context variables are the previous and next target values of the feature and the previous surface value (denoted 
                           
                              Prev
                              i
                              j
                           
                        , 
                           
                              Next
                              i
                              j
                           
                         and 
                           
                              PrvSurf
                              i
                              j
                           
                         respectively), but many other context variables are possible (refer to Section 4.2 for some examples). Dependencies between surface feature values can encode smoothness constraints in the motion of articulators; and conditioning surface feature values on past or future target values can model assimilation effects that are not accounted for by asynchrony. Analogously to previous work on phone-based pronunciation models (Riley et al., 1999; Fosler-Lussier, 1999), we can use decision trees to represent the context-dependent surface feature distributions. In such a setup, we have a decision tree for every target feature value, with questions about the context variables determining splits in the decision trees.

In addition to standard decision trees, we have also considered maximum-entropy models (Berger et al., 1996) of the surface feature distributions (Jyothi, 2013). These may be more robust since, unlike decision trees, their training is a convex optimization problem and involves fewer tuning parameters. In this approach, we learn maximum-entropy predictors of the surface feature values given the target and context variables, using target/context variable values as feature functions in the predictors:
                           
                              (3)
                              
                                 p
                                 (
                                 Surf
                                 |
                                 Tar
                                 ,
                                 c
                                 ;
                                 λ
                                 )
                                 =
                                 
                                    1
                                    
                                       Z
                                       (
                                       Tar
                                       ,
                                       c
                                       )
                                    
                                 
                                 exp
                                 
                                    
                                       
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             λ
                                             k
                                          
                                          
                                             f
                                             k
                                          
                                          (
                                          Tar
                                          ,
                                          c
                                          ,
                                          Surf
                                          )
                                       
                                    
                                 
                                 ,
                              
                           
                        where c refers to all of the context variables, f
                        
                           k
                        (·) are feature functions (in our case they are properties of the context variables), λ
                        
                           k
                         are weights learned to maximize the conditional likelihood of the training data, and Z(Tar, c) is the partition function.

In order to train either the decision trees or the maximum-entropy predictors, we need training data with all context variables observed. For this purpose we have used alignments generated using a trained context-independent model, similarly to the training of phone-based models such as those of Riley et al. (1999).

@&#RELATED WORK@&#

Besides the earlier motivating work mentioned in Section 1 (Deng and Sun, 1994; Erler and Freeman, 1994; Kirchhoff, 1996; Richardson et al., 2003), the most closely related work to ours is the recent work of Mitra et al. (2012) on noise robustness with articulatory models. In their work, Mitra et al. define a DBN with multiple streams of articulatory variables based on articulatory phonology. In their models, however, there is no explicit modeling of inter-feature asynchrony or substitutions.
                           8
                        
                        
                           8
                           For this reason we have not compared directly against this model in experiments. Since our experiments are based on manual transcriptions, while their model accounts for a large amount of variation at the acoustic level, that model would perform unfairly poorly in our experiments.
                         
                        Markov et al. (2006) also use DBNs with articulatory variables, but with no modeling of inter-frame dependencies. Some authors have explored DBN models for the task of recognition of asynchronous articulatory features (Wester et al., 2004a). Other work has explored the use of multiple asynchronous streams of variables other than sub-phonetic features, such as different streams of acoustic observations or acoustic observations with the addition of an auxiliary variable (Nock and Ostendorf, 2003; Stephenson et al., 2004; Zweig, 1998; Zhang et al., 2003). Finally, in linguistics and speech science there have been several efforts to formalize models of multiple asynchronous tiers (Huckvale, 1994; Wiebe, 1992) and a simulation of articulatory phonology itself has now been implemented in a toolkit (Nam et al., 2004).

There has also been a great deal of work in speech recognition on acoustic observation models based on sub-phonetic features and on feature classification (Kirchhoff et al., 2002; Metze and Waibel, 2002; Eide, 2001; Frankel and King, 2001; Wester et al., 2004b; King et al., 2007; Cetin et al., 2007; Morris and Fosler-Lussier, 2008; Siniscalchi et al., 2013). Such methods can be combined with articulatory feature-based pronunciation models to build complete speech recognizers. The outputs of feature classifiers can be used as observations for surface feature variables, or alternatively the feature variables can be kept hidden and inferred (or marginalized out) in recognition. In this article we focus on pronunciation modeling alone, although the two topics are linked.

There are multiple ways of evaluating the proposed approach. For purposes of ASR, we could of course embed the model in a complete recognizer. Sub-phonetic feature-based pronunciation models have indeed been evaluated in complete ASR systems (Deng et al., 1997; Richardson et al., 2003; Mitra et al., 2012; Livescu et al., 2007b), but always using a simplified pronunciation model for computational or other reasons. It is also difficult to discern in such ASR experiments how much of the performance differences are attributable to the new pronunciation model versus the corresponding new observation models. In the work reviewed in this article, therefore, we have chosen to use “intrinsic” evaluation, external to any ASR system.

In the past, the value of new pronunciation models has been evaluated in a few “intrinsic” ways. For example, an extensive study by Riley et al. (1999) used the perplexity of the surface phone strings in a test set as a performance criterion. Bates et al. (2007) also used phone perplexity, as well as phonetic error rate and distance. We cannot use the same phone perplexity measure, since our models do not produce a probability per surface phone label. Our models do produce a per-frame probability of the surface form, so we use frame perplexity as one measure of performance.

A second type of evaluation we use is via a lexical access task, that is classification of a word's identity given its surface phonetic transcription. We compared our feature-based models to a phonetic baseline model based on the one of Riley et al. (1999), described below.

In the experiments described in this section, we used data from the Switchboard Transcription Project (STP) (Greenberg et al., 1996), a subset of the Switchboard conversational speech database (Godfrey et al., 1992) that has been manually labeled at a fine phonetic level, including various diacritics, and phonetically time-aligned. This dataset provides a set of examples of conversational surface pronunciations, which we convert to frame-by-frame articulatory feature transcriptions via a mapping from the STP phone set to our feature set. All of our experiments have been done on the “train-ws96-i” subset of the STP transcriptions, excluding partial words, words whose transcriptions contain non-speech noise, and words whose baseforms are four phones or shorter (where stops, affricates, and diphthongs are considered two phones each). The length restriction is intended to exclude words that are so short that most of their pronunciation variation is caused by neighboring words. The resulting data set contains 3343 single-word tokens excised from continuous conversational utterances.

Since the surface pronunciations are transcribed phonetically in this data, we may not be able to exploit the full power of the feature-based model in this evaluation. For example, partially nasalized vowels, incomplete stop closures, and anticipatory rounding are handled by the model but are missing from the phonetic transcriptions. This may be addressed in the future by either manual articulatory transcription efforts (Livescu et al., 2007a) or automatic forced articulatory transcription (Prabhavalkar et al., 2011).

Since the feature-based model is inherently frame-based, we measure the frame-level perplexity. We therefore also trained frame-level phonetic decision trees as a baseline for this evaluation. In these experiments, the STP excised word data described above is split into a 2942-word (∼90,000-frame) train set, 165-word development set, and 236-word test set (see (Livescu, 2005; Bowman and Livescu, 2010) for more details). The goal is to measure how well a model predicts a test set of surface pronunciations. Let the surface phone label at time frame i be P
                        
                           i
                         and the corresponding N-feature vector be 
                           {
                           
                              Surf
                              i
                              1
                           
                           ,
                           …
                           ,
                           
                              Surf
                              i
                              N
                           
                           }
                           =
                           
                              Surf
                              i
                              
                                 1
                                 :
                                 N
                              
                           
                        .

To evaluate our models, we align the test data (using the context-independent model), i.e. we find the most probable values of all hidden variables given the word and the surface labels, and then compute the frame-level perplexity of the test set:


                        
                           
                              (4)
                              
                                 perp
                                 (
                                 
                                    P
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    P
                                    T
                                 
                                 )
                                 =
                                 
                                    2
                                    
                                       −
                                       (
                                       1
                                       /
                                       T
                                       )
                                       
                                          ∑
                                          t
                                       
                                          
                                       
                                          log
                                          2
                                       
                                          
                                       p
                                       (
                                       
                                          P
                                          i
                                       
                                       |
                                       
                                          c
                                          i
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where there are T frames in the test data and 
                           
                              c
                              i
                              
                           
                         refers to the context variables. In this expression, 
                           p
                           (
                           
                              P
                              i
                           
                           |
                           
                              c
                              i
                              
                           
                           )
                         is computed from either phonetic or feature-based decision trees, via 
                           p
                           (
                           
                              P
                              i
                           
                           |
                           
                              c
                              i
                              
                           
                           )
                           =
                           
                              ∏
                              
                                 j
                                 =
                                 1
                              
                              N
                           
                           p
                           (
                           
                              Surf
                              i
                              j
                           
                           |
                           
                              c
                              i
                              j
                           
                           )
                        .

Building a separate decision tree for each articulatory feature produces poor results, presumably because the assumption of independence between the features is too strong. Instead, we “bundle” the features into three streams that should be more independent, which yields much better results: all tongue features (19 possible underlying values, and therefore 19 trees); glottis and velum (3 trees); and lip opening (4 trees). These bundles were chosen because there is typically very little asynchrony among the features within each bundle, but more so in between bundles. Fig. 2
                         shows a (highly pruned) example decision tree for the Glottis-Velum feature tier, corresponding to the case where the target value is voiced (VD) and non-nasal (N-N). This tree shows that the current sound is more likely to be nasalized if the following target is a nasal than if it is a non-nasal, and even more likely to be nasalized if the previous surface sound was also nasal.


                        Table 8
                         shows the frame perplexities for various models. For most sets of context variables, the feature-based models outperform the phone-based ones. The best perplexities are obtained by including cross-feature context. It can be difficult to interpret the importance of perplexity differences, so next we consider evaluation through lexical access performance.

In the lexical access task we address the question: If we knew the true sequences of surface feature values 
                           
                              Surf
                              i
                              j
                           
                           ∀
                           i
                           ,
                           j
                         for a word, how well could we guess the identity of the word? In this case, the “true” surface feature values are derived from the STP phonetic transcriptions, by assuming a deterministic mapping from surface phones to surface feature values. The task then consists of introducing these surface feature values as observations of 
                           S
                           =
                           
                              Surf
                              i
                              j
                           
                           ∀
                           i
                           ,
                           j
                         in the DBN for each word, and finding the word with maximum posterior probability, 
                           p
                           (
                           
                              w
                              k
                           
                           |
                           S
                           )
                           ,
                           1
                           ≤
                           k
                           ≤
                           V
                        , where V is the vocabulary size. Given a test set of words with their observed surface feature values, we measure the lexical access error rate of the model as the percentage of the test words that are predicted incorrectly.

In these experiments the parameter learning is done via maximum likelihood using the EM algorithm, given the training set of observed word/surface feature pairs. All DBN inference and parameter learning is done using the Graphical Models Toolkit (GMTK) (Bilmes and Zweig, 2002; Bilmes, 2002). The maximum-entropy models are trained using the Maximum Entropy Modeling Toolkit (Zhang, 2004). We enforce two hard constraints on asynchrony:
                           
                              1.
                              The lips can desynchronize from the tongue by up to one state: 
                                    p
                                    (
                                    
                                       aSync
                                       i
                                       
                                          L
                                          :
                                          T
                                       
                                    
                                    >
                                    1
                                    )
                                    =
                                    0
                                 . Lip-tongue asynchrony can account for effects such as vowel rounding in the context of a labial consonant. We ignore for now longer-distance lip-tongue asynchrony effects, such as the rounding of [s] in strawberry.

The glottis/velum must be within 2 states of the tongue and lips: 
                                    p
                                    (
                                    
                                       aSync
                                       i
                                       
                                          L
                                          ,
                                          T
                                          ;
                                          GV
                                       
                                    
                                    >
                                    2
                                    )
                                    =
                                    0
                                 . This accounts for longer-distance effects, such as long-range nasalization as in trying → [t r ay
                                    n
                                  n] (where the nasalized [ay] is two phones away from the nasal in the underlying pronunciation).

We compare our models to a baseline phonetic pronunciation model built according to the specification in (Riley et al., 1999). The phonemic transcriptions were aligned with the hand-labeled phonetic transcriptions from STP to give phoneme-to-phone correspondences which were then used to build phonetic decision tree models. The phonemes were each represented as a six-element feature vector: (type of phoneme (vowel, consonant, silence), consonant-manner, consonant-place, vowel-manner, vowel-place, nasalized or not nasalized). The decision tree questions were based on these features. As in (Riley et al., 1999), we also allowed for deletion of phonemes in context. The context for the decision trees includes three neighboring phonemes on either side and the distance of the phoneme from the word boundary on either side, as in (Riley et al., 1999).

The pronunciation models in these experiments used a 3328-word vocabulary, consisting of the 3500 most likely words in the “Switchboard I” training set (Godfrey et al., 1992), excluding partial words, non-speech, and words for which we did not have baseform pronunciations.


                        Fig. 3
                         shows the lexical access error rates of the context-dependent phonetic baseline and of several feature-based models, in a 5-fold experimental setup with 2000 words in each fold's training set and about 670 words in the development and test sets.

The main result here is that the context-dependent feature-based models outperform the context-dependent phonetic baseline, despite the fact that the phonetic baseline uses a longer context window (three previous/following phones) and additional context variables, and despite the fact that the phonetic labeling of the data favors a phonetic model. These improvements in performance are statistically significant according to McNemar's test (Dietterich, 1998) at p
                        <0.01. A context-independent feature-based model, however, is insufficient to beat the phonetic baseline. Finally, there is less variability in error rates across folds for the context-dependent feature-based models than for the phone-based model. Context-dependent models based on decision trees and maximum-entropy models perform comparably – the decision tree models slightly outperform the maximum-entropy models, but not significantly so – but the maximum-entropy models require much less tuning to obtain good performance so they may be preferable overall.

For a more detailed look, it is also informative to consider not only the error rate but also the rank of the correct word. The correct word may not be top-ranked because of true confusability with other words; it is then instructive to compare different systems as to their relative rankings of the correct word. In a real-world connected speech recognition scenario, confusable words may be disambiguated based on the linguistic and phonetic context. The role of the pronunciation model is to give as good an estimate as possible of the goodness of fit of each word to the observed signal. Fig. 5 shows the cumulative distribution function of the correct word's rank for the same feature-based and phone-based models as in Fig. 3, for one of the five folds. This plot is equivalent to the r-best oracle accuracy for varying r; the previously reported error rate is given by the first point on the plot for each model. This figure demonstrates that, not only are the context-dependent feature-based models better than the phonetic baseline in terms of 1-best accuracy, they are also markedly better in terms of r-best accuracy for r
                        >1. In fact, the phone-based model tapers off at <85% r-best accuracy even for very high r, while the best feature-based models quickly reach about 95% r-best accuracies. Note that, due to zero probabilities in each model, there are some words that fall outside the r-best list for any r, no matter how large. For example, the articulatory models have limits on asynchrony and allowed substitutions, and the phone-based models do not allow all substitutions. However, this does not detract from the overall trend in relative performance of the models, which is visible even for very low r where this “ceiling effect” is not reached.

In order to get a qualitative sense of whether a model is behaving reasonably, we can look at the most likely settings for the hidden variables given a word and its surface realization, which we refer to as an alignment. This is the multi-stream analogue of a phonetic alignment, and is the model's best guess for how the surface pronunciation was generated. Fig. 4(a) and (b) shows spectrograms and the most likely sequences of some of the model variables for two example words, everybody → [eh r uw ay] and instruments → [ih
                           n
                         s tcl ch em ih
                           n
                         n s]. Multiple frames with identical variable values have been merged for visual clarity.
                     

Considering first the analysis of everybody, it suggests that (i) the deletion of the [v] is caused by the substitution critical → wide in the LIP-OPEN feature, and (ii) the [uw] comes about through a combination of asynchrony and substitution: The lips begin to form the closure for the [b] while the tongue is still in position for the [iy], and the lips do not fully close but reach only a narrow constriction. Turning to the example of instruments, the apparent deletion of the first [n] and nasalization of both [ih]s is explained by asynchrony between the velum and other features. The replacement of /t r/ with [ch] is described as a substitution of a palato-alveolar TT-LOC for the underlying alveolar and retroflex values. We cannot be certain of the correct analyses, but these analyses seem reasonable given the phonetic transcriptions.

It is also instructive to consider examples that different models recognize correctly/incorrectly. For example, the context-independent feature-based model fails to recognize the examples favorite → [f ey v er t] and twenty → [t w eh n iy]. In the case of twenty, the canonical pronunciation is /t w eh n t iy/. In this surface realization, the stop is nasalized, and in this case there is insufficient oral pressure built up to cause a burst when the stop is released. This is captured by the context-dependent distribution of the tongue tip feature, which goes directly from a closure to the following vowel in the context of a nasal.

The models described in this article, or variations on these models, have been extended in various ways and applied to other tasks. First, the experimental results in this article were obtained with generative models trained via maximum likelihood. In related work, we have developed an approach for discriminative training of the models, by converting the DBNs to finite-state transducers and learning their arc weights discriminatively, for improved lexical access performance (Jyothi et al., 2012). Another discriminative approach is to use the models to define feature functions in a log-linear classifier. This approach has been applied in a discriminative whole-word model for lexical access, leading to large improvements over the lexical access results reviewed here (Tang et al., 2012); however, such whole-word models are less straightforward to extend to end-to-end recognition since they cannot be incorporated into frame-based recognition models. A related model has also been used to define feature functions in a discriminative keyword spotter, showing improvement over a phone-based model in conversational speech in a low-data setting (Prabhavalkar et al., 2013).

As mentioned previously, this type of model has been used in end-to-end speech recognition experiments, although with highly constrained versions of the models (with greatly restricted or eliminated substitution models). Extension to full speech recognition could be done by first predicting articulatory feature values and then using them as observations in the pronunciation model. Such hard decisions are likely to introduce additional errors. Instead, the articulatory features can be kept as hidden variables, and the distribution of the acoustic observations can be modeled as a Gaussian mixture (Livescu et al., 2007b) or indirectly in a hybrid approach (Hasegawa-Johnson et al., 2005). With the dramatic recent improvements in hybrid models using deep neural networks (Hinton et al., 2012), this approach should be revisited.

The same kind of model has been used in visual and audio-visual speech recognition (Hasegawa-Johnson et al., 2007; Saenko et al., 2009), with improvements found in lipreading performance. In the case of audio-visual speech, the model provides an account of the well-known phenomenon of audio-video asynchrony (Nefian et al., 2002; Gravier et al., 2002; Gowdy et al., 2004; Hazen, 2006) as the result of asynchrony between visible (e.g., lip opening) and non-visible (e.g., nasality, back articulations of the tongue) articulatory gestures. For example, anticipatory lip rounding can make it appear that the visual signal is “ahead” of the acoustic signal, whereas in fact it is the lips that are ahead of the other articulators.

Finally, pronunciation models can be used for a variety of other applications. One example is the development of “word neighborhood density” measures, which are used in psycholinguistics work to predict human word recognition performance (Bailey and Hahn, 2001) and to analyze speech recognition performance (Goldwater et al., 2010). In recent work we have used the articulatory feature-based models presented here, converted to finite-state transducers, to define word neighborhoods by finding the nearest neighbors of a given word in terms of transducer edit distance. Word neighborhoods defined in this way outperform phone-based neighborhood measures as predictors of ASR errors (Jyothi and Livescu, 2014).

@&#CONCLUSION@&#

This article has reviewed our work on a flexible model class that explicitly accounts for articulatory asynchrony and substitution effects in pronunciation variation. We have argued, and have found in initial experiments, that the proposed articulatory feature set (as opposed to, for example, IPA-based features) is not an arbitrary choice but an important one for modeling pronunciation variation. The graphical model formulation – as opposed to “compiling” the model into an HMM – allows us to implement such models with minimal assumptions and to take advantage of the parsimony of the factored state space. Our main findings from frame perplexity and lexical access experiments are that
                        
                           •
                           Feature-based pronunciation models of the type we have developed outperform comparable phone-based models in most cases, in terms of both frame perplexity and lexical access performance.

Context-dependent surface feature models outperform context-independent ones. Maximum-entropy and decision tree-based models perform comparably, but maximum-entropy models are easier to train and tune.

In context-dependent models, it is helpful to combine the feature tiers into “bundles” of highly interdependent feature subsets; without this we do not obtain improved perplexities over the phonetic baselines.

We have also reviewed extensions of our models to allow for discriminative training and for application to speech recognition, lipreading and audio-visual speech recognition, spoken term detection, and speech recognition error prediction. There are still many opportunities for future work on properly integrating such a pronunciation model into a speech recognizer or other downstream tasks. For example, the relationship between the pronunciation model and acoustic model requires further study: Should the acoustic model be factored into multiple terms for the different articulators? Should there be a separate factor for each bundle? How much of the variation should be accounted for by the acoustic model versus the pronunciation model? Discriminative training is likely to be a big part of such integration, considering that we do not know what the “perfect” feature set and model structure are.

The models presented in this paper can be improved in a number of ways. Studies of pronunciation variation in the ASR literature suggest some useful contextual factors that we have not yet used in our models, such as prosodic and position-dependent factors. For example, Greenberg et al. have studied pronunciation variation as a function of the position of a phone within a syllable, and found that the codas of syllables are far more likely to be realized non-canonically (Greenberg, 1999). Other prior work (Ostendorf et al., 1996) has suggested that there is a “hidden mode” or speaking style that may vary during the course of an utterance, which may be useful to model as well. Finally, a number of authors have shown that pronunciation variants depend on contextual factors such as nearby disfluencies (e.g., hesitations), word predictability, utterance position, and speaking rate (Bell et al., 2003; Fosler-Lussier and Morgan, 1999; Fosler-Lussier, 1999). In addition, incorporating cross-word context is important and in principle straightforward in our models, but we have thus far ignored cross-word effects on both asynchrony and substitutions.

We have also assumed that the distribution of asynchrony is symmetrical: The probability of feature i being ahead of feature j by a certain amount is the same as that of j being ahead of i. There are common examples of variation that cause us to doubt this assumption. For example, pre-nasalization of vowels appears to be more common than post-nasalization (Browman and Goldstein, 1992). The existence of attested phenomena such as football → [f uh b ao l] (Greenberg et al., 1996) but not, as far as we know, of haptic → [h ae p ih k] implies that tongue-lip asynchrony may also be asymmetric. Asymmetric asynchrony can be added to the model by allowing the aSync variables to take on both positive and negative values. This has begun to be explored in some related work (Prabhavalkar, 2013; Terry et al., 2010) but deserves more attention in future work.


                     Browman and Goldstein (1992) use evidence from linguistic and articulatory data to devise specific ordering constraints among their vocal tract variables. We have thus far also used such considerations in deciding on the constraints used in our experiments. However, in the absence of conclusive data on all variables of interest, it would be useful to investigate automatically learning certain aspects of the model, such as the feature bundles and asynchrony constraints. For example, the feature bundles could be automatically discovered from forced alignments with an “unbundled” model. The optimal structure of the model for ASR purposes may differ from a linguistically faithful model. For this purpose discriminative training approaches (Bilmes et al., 2002; Jyothi et al., 2012), or using our models to define features in discriminative log-linear models (Prabhavalkar et al., 2013; Tang et al., 2012), may be fruitful.

The type of model we have proposed may also have applications in speech analysis, for both scientific exploration and more immediate applications. One possible use of the model would be to make automatic articulatory transcriptions of large amounts of recorded speech, to allow the study of articulation phenomena on a larger scale than is possible with existing corpora (Prabhavalkar et al., 2011). For example, we could learn the relative timing of articulatory gestures, therefore contributing to the theory of articulatory phonology.

@&#ACKNOWLEDGMENTS@&#

A number of colleagues have contributed in various ways to the work reviewed in this paper, including Sam Bowman, Jim Glass, Joseph Keshet, Rohit Prabhavalkar, and Hao Tang. This paper was improved by comments from the anonymous reviewers. This research was supported by NSF grants IIS-0905633 and IIS-0905420. The opinions expressed in this work are those of the authors and do not necessarily reflect the views of the funding agency.

@&#REFERENCES@&#

