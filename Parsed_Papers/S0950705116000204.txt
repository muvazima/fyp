@&#MAIN-TITLE@&#Two-stage approach for reliable dynamic Web service composition

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           This paper proposes a two-stage method for reliable dynamic Web service composition and improves the reliability of dynamic Web service composition.


                        
                        
                           
                           In the first stage, the scale of candidate services is reduced and the service composition problem is transformed to local service selection problem.


                        
                        
                           
                           In the second stage, QoS of candidate services are predicted and used to select the optimal services for tasks in the service composition workflow.


                        
                        
                           
                           Culture Genetic Algorithm (CGA) is proposed to reduce candidate services and decompose the global QoS constraints into local QoS constraints.


                        
                        
                           
                           It proposes a Web service QoS dynamic prediction method based on improvedÂ case-based reasoning (CBR).


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Web service

Web service composition

Quality of service

QoS prediction

@&#ABSTRACT@&#


               
               
                  Web service composition is a key technology for creating value-added services by integrating available services. With the rapid development of Service Computing, Cloud Computing, Big Data, and the Internet of Things, mass services with the same functionalities and different quality of service (QoS) values are available on the Internet. Moreover, due to the uncertainties of services’ application environment, a service’s QoS is highly dynamic; these two factors cause reliable dynamic Web service composition to be a challenge. To address this issue, this paper proposes a two-stage approach for reliable dynamic Web service composition. In the first stage, the top K Web service composition schemes based on each service’s historical QoS values are selected with the proposed algorithm named Culture Genetic Algorithm (CGA). Then, component services in the top K schemes are filtered out and employed as the candidate services for dynamic service composition. This operation can greatly reduce the number of available services and filter out better candidate services for dynamic service composition. Next, the global QoS constraints are decomposed into local QoS constraints with the CGA algorithm, and the global optimal problem of service composition is transformed into a local optimal service selection problem; this conversion increases the flexibility of dynamic service composition and provides a chance to predict QoS values of services before service selection. In the second stage, before selecting the best service for each task during the running of the service composition workflow, QoS values of each candidate service are predicted based on the improved case-based reasoning, and the best service is selected according to the predicted QoS values. Through QoS prediction, the reliability of the composite Web service can be greatly enhanced. Finally, experimental results show that the proposed method is feasible and effective.
               
            

@&#INTRODUCTION@&#

Web service is a type of distributed computing model that is self-contained, modular, loosely coupled, standards-based, and high capacity. Web services can provide a type of distributed information sharing computing technology that can be used on the Internet or an intranet with standard XML protocols and message formats to eliminate the discrepancies of different application systems [1–3]. Industry standards such as WSDL, UDDI, and WS-BPEL have been provided for describing, locating, and combining Web services. The service-oriented computing paradigm and its realization through standardized Web service technologies provide an encouraging solution for the seamless integration of business applications. Currently, composite Web services (CWSs) [4–6] have been used in many areas, such as virtual enterprise, supply chain, accounting, finances, and eScience. Following the service-oriented architecture paradigm, dynamic Web service composition is described as a process consisting of several tasks. Then, based on running time, concrete optimal Web services are selected and bound for each task.

Using the business strategy making process in supermarkets as a use case (UC), in brutal commercial competition, to provide better services and obtain greater benefits, large supermarkets always making business strategies (such as developing a reasonable order plan, determining scientific placement of articles, and predicting the inventory) through data mining. This business process involves data collection, data transmission, data storage, data mining, decision making, and decision-execution monitoring, as illustrated in Fig. 1
                     .

To realize this process, supermarkets must develop their own software and hardware facilities and have sufficient computing power and storage capacity. They also need to employ hardware, network, and software maintenance workers; moreover, they should have a data analysis technician and a decision support expert. therefore, the cost will be large for supermarkets to build their own business information platform. However, with the emergence of Cloud Computing [7], Web services [8], Big Data [9], and the Internet of Things [10], many services are provided by different companies. The aim of business strategy creation can be realized by combining different services through a third party service system; supermarkets only need to pay some fee for the whole service. Obviously, service composition can create value-added services and can provide great convenience to users.

It is expected that with the proliferation of Cloud Computing, Software as a Service [11], Big Data, and the Internet of Things, more and more Web services will be available on the internet. For example, there are mass services that can complete the data mining task in the UC, but each of these services has a different quality of service (QoS, such as price, response time, availability, and reliability). Mass candidate services for each task will increase the complexity of service composition, and cause the problem of Web service composition to be an NP-hard problem [12].

Moreover, the QoS of a Web service is dynamic in an open network environment, take the data transmission service in the UC, for example, when the service is idle, its transmission speed will be fast, its reliability will be high, and its response time will be short. Alternatively, when the service is very busy, its transmission speed will be slow, its reliability will be low, and its response time will be long. Moreover, other factors such as task type and task volume greatly influences service QoS. Take data transmission service in the UC as an example, when the data volumes to be transferred are large, the response time will be long; otherwise, the response time will be short. Research [13,14] also demonstrates that service QoS is highly dynamic; thus, the QoS of the CWSs may satisfy users QoS constraints in the design phase, but it may be not able to satisfy users QoS constraints at the running time. However, most studies on QoS-aware Web service composition define the QoS of component services as deterministic quantities [15–18]. These studies utilize a pre-specified model of the process environment in which composition solutions are based on point estimates such as average values.

In recent years, intensive studies have been performed on QoS-aware Web service composition [4,5,19,20]. Several Web service composition methods (such as service composition based on nonlinear programming and swarm intelligent algorithms) have been proposed [21–39]. However, issues remain to be solved:

First, most existing Web service composition methods [21–39] try to create an optimal Web service composition scheme in the design phase, but due to the large number of candidate Web services, the time complexity of these methods is much higher. Thus, such Web service composition methods cannot be used to solve the problem of dynamic Web service composition. Therefore, improving the efficiency and flexibility of dynamic Web service composition remains an open issue.

Second, most existing service composition methods take the QoS values of component services as static, wherein an optimal CWS is constructed based on determined QoS values. These methods neglect the dynamic QoS features, and always violate the QoS constraints when the CWS is executed. Therefore, creating a reliable CWS is also an open issue.

Recently, new techniques have been developed to predict the future QoS values of services. Such a predictive ability will facilitate the selection of single services. Nonetheless, limited effort has been devoted to QoS prediction for a CWS. In fact, because the environment of Web services is very complex and there are many available candidate services, predicting the QoS of a CWS is very difficult. It is obvious that reliable dynamic Web service composition cannot be realized in one step. Therefore, this paper provides a two-stage approach for reliable dynamic Web service composition.

The main idea of this approach is described as follows. In the first stage, the top K Web service composition schemes are initially identified based on historical QoS values, and the component services involved in the K Web service composition schemes are selected as candidate services. This operation can not only filter out better candidate services but also can reduce the number of candidate services to improve the efficiency of service dynamic composition. Then, transform the global optimization problem of QoS-aware service composition problem to a local optimal service selection problem by decomposing the global QoS constraints into local QoS constraints. This operation can increase the flexibility of Web service dynamic composition and provide a chance to predict services’ QoS before service selection. The problems of identifying the top K Web service composition schemes and decomposing the global QoS constraints into local QoS constraints are solved by the proposed swarm intelligence algorithm, the Culture Genetic Algorithm (CGA), which will be presented in detail in Section 4.

In the second stage, during the execution of the service composition workflow, the QoS values of the candidate services are predicted before selecting a concrete service for each task. Then, the optimal services are selected according to the predicted QoS values. consider UC as an example, before concrete services are selected for each task (such as data collection, data transmission, and data storage), the QoS values of the candidate services are predicted, and then the best service is selected based on the predicted QoS. In this stage, the QoS accuracy of the component services is improved through QoS prediction; thus, the reliability of the CWS is enhanced. The QoS dynamic prediction method based on improved case-based reasoning (CBR) will be introduced in Section 6.1. The process of two-stage dynamic Web service composition is illustrated as Fig. 2
                     .

The contributions of this paper are summarized as follows.

                        
                           (1)
                           This paper proposes a new idea for reliable dynamic Web service composition through two stages. This idea can not only improve the flexibility of dynamic Web service composition but also can enhance the reliability of the composite service.

This paper proposes an optimization algorithm named CGA by integrating Genetic Algorithm (GA) into the framework of the Culture Algorithm (CA); moreover, a learning operator based on collaborative learning is introduced into the CGA. the CGA is applied to solve the problems of finding the top K Web service composition schemes and global QoS constraints optimal decomposition. Moreover, CGA can be used to solve other combinatorial optimization problems.

This paper presents a global QoS constraints optimization decomposition method, a new quality level combination evaluation model is provided to find the optimal local QoS constraints for each service class.

This paper proposes a dynamic QoS prediction method based on improved CBR. This method considers key environmental factors, such as service load, task type, task volume, cooperation service, and timeliness, which greatly influence QoS.

The rest of this paper is organized as follows. Section 2 introduces related work; Section 3 presents Web services dynamic composition problem; Section 4 introduces the CGA. Section 5 presents the first stage of service dynamic composition; Section 6 describes the second stage of service dynamic composition. Section 7 gives the local optimal Web service selection method. Section 8 verifies the effectiveness of our approaches through simulating experiments. Finally, summary and future work are presented.

@&#RELATED WORK@&#

To place our work in a state-of-the-art context, we briefly describe the related work on Web service composition and QoS prediction.

Recently, QoS-aware Web service composition is an active research issue in Service Computing and Cloud Computing, which attracting a lot of researchers from both academia and industry. Many studies have been carried out on this issue. Liu et al. [21] proposed an extensible QoS computation model that supports an open and fair management of QoS data by incorporating user feedback. However, the problem of QoS based composition is not addressed by this work. In paper [22], multidimensional multi-choice knapsack problem has been used to model this problem. In works [23,24], linear and nonlinear programming methods are used to find the optimal solution for this problem. Ardagna and Pernici [25] propose an approach for service selection with QoS constraints in global view. Huang et al. [26] adopted integer programming approach to solve service selection problem. These methods were very effective when the size of the problem is small. However, these methods suffer from poor scalability due to the exponential time complexity.

To achieve higher scalability, GA and Ant Colony Optimization algorithm are used to solve the problem of Web service composition. Liang et al. [27] provide a hybrid approach for the multi-constraint Web service composition problem. Gao et al. [28] used simulated annealing-based GA to solve the problem of QoE/QoS-aware Web services composition. Simulations showed that SGA was better than GA and SA in efficiency. Jiang et al. [29] proposed a variable length chromosome GA for handling QoS-aware service composition among multiple paths problem. Liang et al. [30] proposed an approach for service selection based on improved genetic algorithm (HPGA) where the hamming similarity degree is used to avoid inbreeding and the pheromone strategy is designed with considering not only the individual fitness but also the global information of best chromosomes.

Li and He [31] solved the problem of QoS-aware service composition with Multi-objective Chaos ACO, experiment results in [31] showed that Chaos ACO demonstrates better performance than the ACO and GA algorithms. An improved discrete immune optimization algorithm based on particle swarm optimization (IDIPSO) is proposed for QoS-driven Web service composition with global QoS constraints in work [32], empirical comparisons with recently proposed algorithms on various scales of composite Web service instances with global QoS constraints indicate that IDIPSO has better searching capability and stability. In Wang et al. [33], C-MMAS algorithm was devised and used to solve the problem of Web service composition with multi-paths, and verified the performance of C-MMAS surpasses the performance of ACO and MMAS algorithm. Rostami et al. [34] propose a novel architecture for semantic Web service composition using clustering and Ant colony algorithm.

In order to improve the flexibility of Web service composition, Alrifai et al. [35] proposed a dynamic Web service composition method based on global QoS decomposition, their research work open a new research direction of Web service dynamic composition. Mardukhi et al. [36] propose a top-down structure (named quality constraints decomposition) to decompose the global constraints into the local constraints, using the GA, then the best Web service for each task is selected through a simple linear search. Liu et al. [37] propose an approach for Web service dynamic composition based on global QoS constraints decomposition with new evaluation model and hybrid swarm intelligent algorithm. However, for these work, the reliability of the CWS are still need to be improved.

Most of the current Web service composition methods are designed to find the optimal Web service composition scheme prior to the execution of CWS. Although these methods can solve the problem of QoS-aware Web service composition to certain degree, they still have some flaws, such as higher complexity, poor reliability, lower user satisfaction, and so on.

Recently, in order to improve the reliability of CWS, researchers began to focus on QoS prediction method for composite service. Hwang et al. [38] take QoS as a random variable, and estimate the QoS of a Web service workflow probabilistically. In this paper, they identify a set of QoS metrics in the context of Web service workflows, and propose a unified probabilistic model for describing QoS values of a broader spectrum of atomic and CWSs. However, the prediction method only can compute the probability that the QoS of composite service can satisfy service-level agreement, cannot predict concrete QoS values, moreover, when there are mass candidate Web services, the complexity of this approach is higher. Wang et al. [39] propose a Web service composition method integrating QoS prediction with service composition, however, the factors that influence the QoS are considered incomplete.

In order to improve the accuracy of services’ QoS, researchers have carried out work on Web service QoS prediction. The authors [40–42] propose QoS prediction approaches based on collaborative filtering method, the main idea of this approach is to make similarity mining among consumers and QoS data, and then predict QoS of the unused Web services based on other consumers experiences. Zhang et al. [43] propose a prediction method based on other users QoS experiences, this method uses similarity mining and prediction from users experience by selecting a set of Web services that have the highest degree of similarity with the target service, then, predict QoS data for the target user. Shi et al. [44] provide a Web service QoS prediction method based on historical using information, this method firstly cluster the users based on location and network condition, then according to the QoS historical statistics of users in the same cluster, use the linear regression algorithm to predict the QoS value based on invocation time and workload. Zheng et al. [45] propose a collaborative QoS prediction approach for Web services by taking advantages of the past Web service usage experiences of service users.

As above QoS predicting methods are all focused on predicting individual QoS, without considering the relationship between services. In Liang et al. [46], for the problem of Multi-QoS Effective Prediction, a Multi-QoS Effective Prediction approach is proposed. For cloud service composition, Ngoko et al. [47] propose to use a probabilistic modelling in which the QoS of an operation is drawn from a finite set of discrete values, according to a probability mass function, and an existing graph reduction algorithm is adapted for such representations. In order to improve the quality of CWS, Geebelen et al. [48] propose a technique for predicting whether the execution of a service composition will be compliant with service level objectives, they use a kernel based quantile estimator with online adaptation of the constant offset to predict future QoS values.

Existing QoS prediction approaches above have promoted the research work of Web service QoS prediction and improved the accuracy of QoS values, however, most of the existing prediction approaches forecast Web services QoS only based on historic QoS data, do not consider critical factors that influence Web service QoS greatly. Hwang et al. [12] pointed out that Web service QoS change dynamically under the open internet environment, there are several primary factors cause the dynamic nature of Web service QoS.

In fact, the load of Web service has great influence on Web service performance. Obviously, QoS of Web service will be different if the service load is distinct when it deals with the same tasks, the performance of Web service will be better when the service is idle, the performance of the service will be poor when the service is very busy. Secondly, task type and task amount are also key factors that can influence Web service QoS. QoS of Web service will be different when it processes tasks of different types. In addition, QoS of Web service will be different when it deals with tasks of the same type but with different amount. Moreover, QoS of Web service will be distinct when it cooperating with different services.

Thus, it is necessary to consider these main factors that influence service performance when to predict Web service QoS. However, existing prediction approaches forecast Web services QoS only based on historic QoS, do not take above factors into consideration, this may lead to inaccurate QoS prediction. To predict Web service QoS accurately, this work proposes a new QoS dynamic prediction method based on improved CBR considering above key factors.

Based on the time when CWSs are created, Web service composition could be categorized into static or dynamic[n1sheng], static Web service composition is also known as workflow-based (model-based)service composition, and the dynamic service composition is known as direct service composition without any model guidance. In static service composition, the aggregation of services takes place at design time. Component service required for composition are selected, bound together and then deployed. Static Web services composition always works well when there exist fixed business flow that can satisfy users demand, and service functionalities or composition requirements do not, or rarely, change. Static composition is not flexible and adaptable in cases when there are frequent runtime changes of requirements or services that cannot be predicted at design time. Once an early binding service becomes unavailable, or if there is a better alternative service, static composition will not be able to provide better support for the execution of composite service in real-time. This kind of composition is a time-consuming procedure with no guarantee that the QoS of the composite service will indeed satisfy the users QoS requirements [20].

In contrast, a dynamic Web services composition allows selecting and bounding services during runtime. Dynamic Web services composition requires the execution system to support automatic discovery, selection, and binding of service components. Undoubtedly, dynamic composition is ideal as the Web services environment is highly dynamic in nature. However, dynamic services composition is a very challenging task and a number of important issues need to be considered such as composition correctness, time limits, transactional support, and so on [20]. This kind of services composition is a sort of “service semantic integration system”. Automated services composition approaches typically exploit the semantic Web and artificial intelligence planning techniques. By giving a set of component services and a specified requirement (e.g., users request), a composite service specification can be generated automatically [49]. However, realizing a fully automated services composition is still very difficult and presents several open issues. Moreover, in dynamic service composition, it is also difficult to guarantee that the QoS of the composite service will satisfy users QoS requirements due to the volatility of QoS.

The work studied in this paper is categorized as model-based service composition but not static service composition; this work includes the idea of service dynamic composition, that is, optimal services are selected for tasks comprising the service composition workflow at run time. In this work, CWSs are not determined in the design phase, and optimal services are dynamically selected at run time. This mechanism can improve the flexibility of model-based service composition and can address the runtime changes in services that cannot be predicted at design time, better alternative services can also be used. Moreover, in our work, the QoS prediction method is adopted to improve the accuracy of QoS values of services. This improvement can address the problem of unreliable QoS in static and dynamic service composition.

Model-based dynamic Web service composition with global QoS constraints is illustrated as Fig. 3
                        , in which Ti
                        (1 ≤ i ≤ m) denotes the tasks of the service composition process. Each task Ti
                         has a service class SCi
                         that includes many candidate Web services with identical functionalities and different QoS. The problem of dynamic Web service composition is to find the optimal Web service for each task at run time, so that the composite service constructed by the selected services can satisfy the global QoS constraints and deliver the global optimal QoS.

Some preliminary concepts about dynamic Web service composition are introduced as follows:

                           
                              
                                 
                                    
                                       T
                                       =
                                       {
                                       
                                          
                                             T
                                             1
                                          
                                          ,
                                          …
                                          ,
                                          
                                             T
                                             i
                                          
                                          ,
                                          …
                                          ,
                                          
                                             T
                                             m
                                          
                                       
                                       }
                                    
                                  indicates tasks comprising the service composition workflow; m is the number of tasks.


                                 
                                    
                                       S
                                       
                                          C
                                          i
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                s
                                                
                                                   i
                                                   1
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                s
                                                
                                                   i
                                                   j
                                                
                                             
                                             ,
                                             …
                                             ,
                                             
                                                s
                                                
                                                   i
                                                   
                                                      N
                                                      i
                                                   
                                                
                                             
                                          
                                          }
                                       
                                    
                                  (
                                    
                                       i
                                       =
                                       1
                                       ,
                                       2
                                       ,
                                       …
                                       ,
                                       m
                                    
                                 ) denotes the service class for task Ti. Ni
                                  indicates the number of candidate services in SCi
                                 . Web services in SCi
                                  have the same functionality and different QoS.


                                 
                                    
                                       Q
                                       o
                                       S
                                       =
                                       {
                                       
                                          
                                             q
                                             1
                                          
                                          ,
                                          …
                                          ,
                                          
                                             q
                                             i
                                          
                                          ,
                                          …
                                          ,
                                          
                                             q
                                             k
                                          
                                       
                                       }
                                    
                                  indicates QoS attributes of Web services; k is the number of QoS attributes.


                                 
                                    
                                       W
                                       =
                                       {
                                       
                                          
                                             w
                                             1
                                          
                                          ,
                                          …
                                          ,
                                          
                                             w
                                             j
                                          
                                          ,
                                          …
                                          ,
                                          
                                             w
                                             k
                                          
                                       
                                       }
                                    
                                  indicates user QoS preferences for each QoS attributes; wj
                                 (1 ≤ j ≤ k) indicates user preference for the jth QoS attribute.


                                 
                                    
                                       C
                                       =
                                       {
                                       
                                          
                                             C
                                             1
                                          
                                          ,
                                          …
                                          ,
                                          
                                             C
                                             j
                                          
                                          ,
                                          …
                                          ,
                                          
                                             C
                                             k
                                          
                                       
                                       }
                                    
                                  indicates global QoS constraints; Cj
                                 (1 ≤ j ≤ k) is a global constraint on QoS attribute qj
                                  of a CWS.

In practice, various composition styles, e.g., sequential, parallel, alternative, and loops can be engaged in a composition plan. In this paper, we focus on investigating the sequential composition model as other research works do [50–52]; other styles can be reduced or transformed into the sequential model with present mature techniques as mentioned in [53].

QoS values of CWSs can be calculated according to the QoS values of the component Web services and composite models. Currently, there are several studies on Web service composition models and QoS aggregation formulas. Cardoso et al. [54] devised a stochastic workflow reduction algorithm to compute overall QoS values of service processes. Based on different workflow patterns, they defined QoS aggregation formulas for QoS attributes. QoS attributes usually considered in a service composition include Response Time, Throughput, Reputation, Reliability, Availability, and Cost. For the definitions of these properties can refer to the literature [48]. Because the focus of QoS prediction is on the attributes having a volatile nature, we do not consider static attributes such as fixed costs and membership fees. Reputation is also an attribute that offers a general impression about users’ opinions of a service, and is not meant to change frequently over time. The throughput of services often largely depends on the hardware of the underlying infrastructure; throughput is not considered in our work. In this work, we concentrate on non-static QoS attributes. Interesting attributes for our approach are response time, reliability, and availability [48]. The aggregation formulas for the four key QoS attributes ( Cost, ResponseTime, Availability, and Reliability) are presented in Table 1
                        .

Global QoS constraints indicate users’ end-to-end QoS requirements. Such constraints can be expressed in terms of upper and/or lower bounds for the aggregated values of different QoS attributes. Let CWSR be a given composition request and 
                           
                              C
                              =
                              {
                              
                                 
                                    C
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    C
                                    j
                                 
                                 ,
                                 …
                                 ,
                                 
                                    C
                                    k
                                 
                              
                              }
                           
                         be a vector of global QoS constraints on CWSR. Let CWS be an instantiation of a CWSR in which a concrete Web service is selected for each task. A CWS is considered as a feasible solution if its QoS values can satisfy all of the global QoS constraints, that is, 
                           
                              
                                 Q
                                 i
                              
                              S
                              a
                              t
                              i
                              s
                              f
                              y
                              
                                 C
                                 i
                              
                              
                                 
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    ,
                                    …
                                    ,
                                    k
                                    )
                                 
                                 )
                                 ,
                              
                           
                         where Qi
                         is the ith aggregate value of the CWS.

A utility function is usually used to evaluate the multi-dimensional quality of a CWS [50,55,56]. This function can map the quality vector into a single real value. The evaluation value is used to sort and rank candidate CWSs. Similar to previous research [50,53,55,56], this work uses the simple additive weighting approach as the utility function. Before computing the utility value of a CWS, each QoS attribute value should be transformed into a value between 0 and 1 by comparing it with the minimum and maximum possible values [53]. Examining composite Web service 
                           
                              C
                              W
                              S
                              =
                              {
                              
                                 
                                    S
                                    1
                                 
                                 ,
                                 
                                    S
                                    2
                                 
                                 ,
                                 …
                                 ,
                                 
                                    S
                                    n
                                 
                              
                              }
                              ,
                           
                         the aggregated QoS values are compared with the minimum and maximum aggregated values. The minimum or maximum aggregated values can be easily estimated by aggregating the minimum or maximum value of each service class. Formally, the minimum and maximum aggregated values of the kth QoS attribute of the CWS are computed as (1) and (2):

                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                
                                                   min
                                                
                                                
                                                   
                                                   ′
                                                
                                             
                                             
                                                (
                                                k
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                Q
                                                min
                                             
                                             
                                                (
                                                j
                                                ,
                                                k
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                
                                                   max
                                                
                                                
                                                   
                                                   ′
                                                
                                             
                                             
                                                (
                                                k
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                Q
                                                max
                                             
                                             
                                                (
                                                j
                                                ,
                                                k
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where

                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                min
                                             
                                             
                                                (
                                                j
                                                ,
                                                k
                                                )
                                             
                                             =
                                             
                                                min
                                                
                                                   ∀
                                                   
                                                      s
                                                      
                                                         j
                                                         i
                                                      
                                                   
                                                   ∈
                                                   
                                                      S
                                                      j
                                                   
                                                
                                             
                                             
                                                q
                                                k
                                             
                                             
                                                (
                                                
                                                   s
                                                   
                                                      j
                                                      i
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                max
                                             
                                             
                                                (
                                                j
                                                ,
                                                k
                                                )
                                             
                                             =
                                             
                                                max
                                                
                                                   ∀
                                                   
                                                      s
                                                      
                                                         j
                                                         i
                                                      
                                                   
                                                   ∈
                                                   
                                                      S
                                                      j
                                                   
                                                
                                             
                                             
                                                q
                                                k
                                             
                                             
                                                (
                                                
                                                   s
                                                   
                                                      j
                                                      i
                                                   
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Here, Q
                        min (j, k) is the minimum value and Q
                        max (j, k) is the maximum value that can be expected for service class Sj
                        . The utility function of component Web service s ∈ Sj
                         is defined as (5), and the whole utility of a CWS is defined as (6).

                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             U
                                             
                                                (
                                                s
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                r
                                             
                                             
                                                
                                                   
                                                      Q
                                                      max
                                                   
                                                   
                                                      (
                                                      j
                                                      ,
                                                      k
                                                      )
                                                   
                                                   −
                                                   
                                                      q
                                                      k
                                                   
                                                   
                                                      (
                                                      s
                                                      )
                                                   
                                                
                                                
                                                   
                                                      Q
                                                      max
                                                   
                                                   
                                                      (
                                                      j
                                                      ,
                                                      k
                                                      )
                                                   
                                                   −
                                                   
                                                      Q
                                                      min
                                                   
                                                   
                                                      (
                                                      j
                                                      ,
                                                      k
                                                      )
                                                   
                                                
                                             
                                             ·
                                             
                                                w
                                                k
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             U
                                             
                                                (
                                                C
                                                W
                                                S
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                r
                                             
                                             
                                                
                                                   
                                                      Q
                                                      
                                                         max
                                                      
                                                      
                                                         
                                                         ′
                                                      
                                                   
                                                   
                                                      (
                                                      j
                                                      ,
                                                      k
                                                      )
                                                   
                                                   −
                                                   
                                                      q
                                                      k
                                                   
                                                   
                                                      (
                                                      s
                                                      )
                                                   
                                                
                                                
                                                   
                                                      Q
                                                      
                                                         max
                                                      
                                                      
                                                         
                                                         ′
                                                      
                                                   
                                                   
                                                      (
                                                      j
                                                      ,
                                                      k
                                                      )
                                                   
                                                   −
                                                   
                                                      Q
                                                      
                                                         min
                                                      
                                                      
                                                         
                                                         ′
                                                      
                                                   
                                                   
                                                      (
                                                      j
                                                      ,
                                                      k
                                                      )
                                                   
                                                
                                             
                                             ·
                                             
                                                w
                                                k
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        here wk
                         ∈ (0, 1) and 
                           
                              
                                 ∑
                                 
                                    k
                                    =
                                    1
                                 
                                 r
                              
                              
                                 w
                                 k
                              
                              =
                              1
                           
                        . wk
                         represents users preference for the kth QoS attribute qk
                        .

The first stage of the reliable dynamic Web service composition aims to reduce the scale of candidate services by finding the top K service composition schemes and transform the global optimal service composition problem to a local optimal service selection problem by decomposing global QoS constraints into local QoS constraints. In fact, finding the top K service composition schemes and decomposing global QoS constraints are two typical combinatorial optimization problems; the solutions of these two problems influence the performance of the proposed method. The GA [57–59] is a global optimization algorithm based on selection and natural genetics that was developed from evolution theory and genetic theory. The main characteristic of the GA that it does not depend on gradient information. Thus, it is especially suited to address complex and nonlinear problems that are difficult to solve by traditional search methods. Many research results prove that GA is a powerful tool for solving continuous optimization and combinatorial optimization problems [60–62]. Therefore, the GA is also suitable for solving these two combinatorial optimization problems. However, the prematurity phenomenon of the GA is the largest obstacle to obtaining a better solution. Therefore, some measures must be implemented to ensure that the global optimal solution can be obtained.

CA is derived from the culture evolution and is based on the knowledge of an evolutionary system. This algorithm was introduced by Reynolds as a means of simulating culture evolution [63]. The CA is composed of a population space and a belief space. The population space is the main space of the algorithm, with evolution operation and outcome assessment for the self-iteration solving, and thus generates knowledge constantly. Then, through the accept operation, it saves the knowledge in the belief space. Moreover, the belief space update operates through the self-evolution, and through the “influence” operating guidelines for further evolution of the main population space. This mechanism communicates between the main population space and belief space information called dual evolution and promotion. the CA has been successfully used in many fields [64–66]. Moreover, Bin proved that evolution under the influence of culture was far better than evolution solely relying on biological genetic evolution [67].

To solve the two combinatorial optimization problems efficiently, this paper integrates the GA into the framework of the CA and constructs a new evolution algorithm named the CGA. Additionally, a learning mechanism inspired by correlation learning is introduced into the CGA. The framework of the CGA is illustrated in Fig. 4
                     . The computing process of the CGA is described as Algorithm 1
                     .

All of the functions involved in the CGA are defined as follows.

                        
                           (1)
                           
                              Evaluate(): Calculate the fitness of each individual; in this paper, the fitness function is designed according to the specific optimization problem.


                              Accept(): Absorb δ excellent individuals to the belief space.


                              Update(): Replace individuals absorbed from the population space with poor individuals in the belief space.


                              BEvolve(): Perform the evolution based on learning operation. Learning operations can be designed for specific optimization problems.


                              PEvolve(): Carry out the selection, crossover, and mutation operation designed for optimization problems.


                              Influence(): Take solutions in the belief space to replace poor solutions in the population space.

Too many candidate services will increase the complexity of service dynamic composition. It is time-consuming to predict every candidate service’s QoS. To improve the efficiency of service composition and QoS prediction, in the first stage, we aim to reduce the scale of candidate services and filter out better candidate services for each task by identifying the top K service composition schemes based on historical QoS, and select services involved in these schemes as candidate services. Then, to increase the flexibility of service dynamic composition, we propose to decompose the global QoS constraints into local QoS constraints, and transform the global optimization problem of QoS-aware Web service composition to the local optimal service selection problem. In the following sections, the processes of finding the top K service composition schemes and decomposing global QoS constraints into local QoS constraints will be presented in detail

Finding the top K service composition schemes is actually a combinatorial optimization problem; this paper proposes the CGA designed in Section 4 to solve this problem. The algorithm for solving the problem of finding the top K service composition schemes based on the CGA is named as CGA-SCS. Evolution operators and the process of the CGA-SCS are presented as follows.

The goal of finding the top K service composition schemes is to find K service composition schemes with excellent fitness. For the QoS-aware service composition problem, each task has many candidate services. Here, we number the candidate services in each service class with an integer. Therefore, an integer-encoding model is adopted for the CGA-SCS. The chromosome model for this problem is illustrated in Fig. 5
                           , in which T
                           1, T
                           2, ...,Tn
                            are tasks involved in the service composition workflow, and numbers in boxes indicate the serial number of services selected from candidate service sets. A chromosome indicates a service composition scheme; a case of the chromosome can be illustrated in Fig. 5.

The initial population of the CGA-SCS is generated randomly; that is, for each gene in the chromosome, randomly select a service from the candidate service set, and take the number of the selected service as a gene of the chromosome. Then, calculate the aggregated QoS values of the chromosome according to the formulas presented in Table 1, and check whether the aggregated QoS values can satisfy the global QoS constraints. If not, discard this chromosome and construct a chromosome again; repeat this process until n valid chromosomes are obtained.

For the problem of finding the top K service composition schemes, the fitness function is defined as (6). As a chromosome represents a service composition scheme, so, when evaluating a chromosome, firstly obtain aggregated QoS values of the chromosome according to formulas presented in Table 1, then calculate fitness of the chromosome according to formula (6).

The GA has three important operators: selection operator, crossover operator, and mutation operator. The selection operator selects the most suitable individuals, causing their chromosomes to be preserved for the next generation. The crossover operator consists of generating children from suitable parents, somehow merging their chromosomes. The mutation operator consists of changing one or more genes of the individuals in the next generation, hoping that such changes at the chromosome level may work in favor of the population.

In the CGA-SCS, the roulette wheel is adopted to perform the selection of individuals. Specific operation is that once the selection probabilities are determined for each individual, the wheel is spun; when it stops, the corresponding individual is selected. This procedure is repeated until a percentage of the generation is selected and their chromosomes are cloned onto the next one.

For the CGA-SCS, the gene segment crossing over method is proposed. The cross over process is illustrated in Fig. 6
                           , in which A
                           1 and A
                           2 are two chromosomes. Suppose that the randomly selected gene segments of A
                           1 are marked with red, the randomly selected gene segments of A
                           2 are marked with yellow, and the crossover operator is to exchange the red gene segment of A
                           1 with the yellow gene segment of A
                           2. After completing the crossover operation, two new individuals 
                              
                                 A
                                 
                                    1
                                 
                                 
                                    
                                    ′
                                 
                              
                            and 
                              
                                 A
                                 
                                    2
                                 
                                 
                                    
                                    ′
                                 
                              
                            are generated.

In the CGA-SCS, a one-point mutation model is adopted, that is, randomly select one gene of the chromosome, then randomly select a new service from the candidate service set that corresponds to the selected gene, and replace the new selected service with the service in the selected gene.

Individuals in the swarm intelligence algorithms do not learn from one another; if individuals can learn from one another, the performance of swarm intelligent algorithms could be effectively improved. In human society, collaborative learning is a situation in which two or more people attempt to learn something together [68]. Unlike individual learning, people engaged in collaborative learning capitalize on one another resources and skills [69]. More specifically, collaborative learning is based on the model that new knowledge can be created within a population in which members actively interact by sharing experiences and take on asymmetric roles. To improve the performance of the CGA-SCS, based on the idea of collaborative learning, a learning operator for finding the top K service composition schemes is proposed.

The learning process is described as follows. First, randomly select several individuals from the population to form a collaborative learning group. Second, divide each individual into several segments. A segment is a part of a solution (chromosome), and segments are produced by dividing the solution averagely. Third, compare the same segments of individuals in the group and select the best segments. Finally, combine the selected segments to form a new individual. The learning operator in the CGA-SCS is illustrated in Fig. 7
                           ; here, I
                           1, I
                           2, ...,Ik
                            are k different individuals that form a learning group. Segments marked with color are the best segments among the same segments of individuals. The best segments are extracted through learning, and form a new individual INew.

The process of the CGA-SCS is described with Algorithm 2
                           .

For the CGA-SCS algorithm, let n be the scale of the initial individuals, m be the number of tasks in the service composition workflow, N be the number of the available services for each task, P be the number of individuals that form a learning group, and L be the number of segments of the learning individuals. The complexities of the CGA-SCS in each generation are shown in Table 2. In the CGA-SCS, typical roulette wheel selection needs n roulette operations to generate the new population. Each roulette operation contains at least 1 and at most n times comparisons according to the relative fitness values of individuals. Thus, the average complexity of the selection operator is O(n
                           2). Moreover, the crossover and mutation operations in the CGA-SCS are only just executed once for each individual, the complexities are both at least O(nm) and at most O(nm), and the complexity of the learning operation is O(nLP). Therefore, the time complexity of the CGA-SCS is O(n
                           2).
                        

Assume that the top K service composition schemes found by CGA-SCS are 
                           
                              S
                              C
                              
                                 S
                                 K
                              
                              =
                              
                                 {
                                 
                                    S
                                    C
                                    
                                       S
                                       1
                                    
                                    ,
                                    S
                                    C
                                    
                                       S
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    S
                                    C
                                    
                                       S
                                       K
                                    
                                 
                                 }
                              
                              ,
                           
                         assume that 
                           
                              S
                              C
                              
                                 S
                                 1
                              
                              =
                              
                                 〈
                                 
                                    s
                                    
                                       1
                                       i
                                    
                                 
                                 ,
                                 
                                    s
                                    
                                       2
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    s
                                    
                                       m
                                       u
                                    
                                 
                                 〉
                              
                              ,
                           
                        
                        
                           
                              S
                              C
                              
                                 S
                                 2
                              
                              =
                              
                                 〈
                                 
                                    s
                                    
                                       1
                                       j
                                    
                                 
                                 ,
                                 
                                    s
                                    
                                       2
                                       t
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    s
                                    
                                       m
                                       p
                                    
                                 
                                 〉
                              
                              ,
                              …
                              ,
                           
                         and 
                           
                              S
                              C
                              
                                 S
                                 K
                              
                              =
                              
                                 〈
                                 
                                    s
                                    
                                       1
                                       r
                                    
                                 
                                 ,
                                 
                                    s
                                    
                                       2
                                       q
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    s
                                    
                                       m
                                       f
                                    
                                 
                                 〉
                              
                              ,
                           
                         where 
                           
                              s
                              
                                 x
                                 y
                              
                           
                         indicates services in service composition schemes. Then, collect services at the same position of the K service composition schemes to form a candidate service set for the corresponding task, that is, 
                           
                              S
                              
                                 C
                                 1
                              
                              =
                              
                                 〈
                                 
                                    s
                                    
                                       1
                                       i
                                    
                                 
                                 ,
                                 
                                    s
                                    
                                       1
                                       j
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    s
                                    
                                       1
                                       r
                                    
                                 
                                 〉
                              
                              ,
                           
                        
                        
                           
                              S
                              
                                 C
                                 2
                              
                              =
                              
                                 〈
                                 
                                    s
                                    
                                       2
                                       j
                                    
                                 
                                 ,
                                 
                                    s
                                    
                                       2
                                       t
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    s
                                    
                                       2
                                       q
                                    
                                 
                                 〉
                              
                              ,
                              …
                              ,
                           
                         and 
                           
                              S
                              
                                 C
                                 m
                              
                              =
                              
                                 〈
                                 
                                    s
                                    
                                       m
                                       u
                                    
                                 
                                 ,
                                 
                                    s
                                    
                                       m
                                       p
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    s
                                    
                                       m
                                       f
                                    
                                 
                                 〉
                              
                              >
                           
                        . Take service classes SC
                        1, SC
                        2, …, and SCm
                         as the candidate service sets for the m tasks T
                        1, T
                        2, …, and Tm
                        . The process of filtering out candidate services can be illustrated as Fig. 8
                        .

By filtering out services from the K service composition schemes, the number of candidate services will be significantly reduced. This reduction can enhance the efficiency of QoS prediction in the second stage to improve the effectiveness of Web service dynamic composition.

To improve the flexibility of dynamic Web service composition and provide opportunities for QoS prediction, the global optimization problem of QoS-aware Web service composition is transformed to a local optimal Web service selection problem by decomposing global QoS constraints into local QoS constraints, the main idea is that, first, each global QoS constraint Ci
                         is decomposed into a set of m local constraints 
                           
                              {
                              
                                 
                                    c
                                    1
                                 
                                 ,
                                 
                                    c
                                    2
                                 
                                 ,
                                 …
                                 ,
                                 
                                    c
                                    m
                                 
                              
                              }
                           
                         (m is the number of tasks in the service composition workflow). Then, set these local QoS constraints as conservative upper or lower bounds for the local optimal service selection for each task. Global QoS constraint decomposition should ensure the following two points:

                           
                              (1)
                              If a candidate service for a task can meet the local QoS constraints, then the aggregated QoS values of the candidate services for all of the tasks should satisfy the global QoS constraints.

The local QoS constraints should be relaxed as much as possible to avoid missing any candidate service that might be part of a feasible CWS.

To decompose global QoS constraints optimally, the value range of each QoS attribute of all of the service classes is divided into a set of discrete quality values that are called quality levels. Then, each global QoS constraint is mapped onto a set of quality levels that will be used as local QoS constraints.

Usually, a user always proposes several global QoS constraints; thus, each service class should satisfy the same number of local QoS constraints simultaneously. The aim of global QoS constraints optimal decomposition is to find an optimal quality level combination for each service class. To solve this problem, an evaluation function for quality level combination must be constructed.

Quality levels for each service class Sj
                            are initialized by dividing the value range of each QoS attribute qk
                            into a set of discrete quality values as depicted in Fig. 9
                           . 
                              
                                 q
                                 
                                    
                                       j
                                       k
                                    
                                    t
                                 
                              
                            indicates the value of the kth QoS attribute of the tth candidate service in service class Sj
                           , 
                              
                                 L
                                 
                                    j
                                    k
                                 
                                 d
                              
                           represents the dth quality level of the kth QoS attribute in the service class Sj
                           , and

                              
                                 
                                    
                                       
                                          Q
                                          min
                                       
                                       
                                          (
                                          j
                                          ,
                                          k
                                          )
                                       
                                       ≤
                                       
                                          L
                                          
                                             j
                                             k
                                          
                                          1
                                       
                                       ≤
                                       
                                          L
                                          
                                             j
                                             k
                                          
                                          2
                                       
                                       ≤
                                       ⋯
                                       ≤
                                       
                                          L
                                          
                                             j
                                             k
                                          
                                          d
                                       
                                       ≤
                                       
                                          Q
                                          max
                                       
                                       
                                          (
                                          j
                                          ,
                                          k
                                          )
                                       
                                       .
                                    
                                 
                              
                           
                        

Because each service class has several QoS attributes and each QoS attribute has a set of quality levels, these quality levels can constitute many quality level combinations. To evaluate these quality level combinations, an evaluation function F(EQLCij
                           ) is constructed to compute the fitness of quality level combinations. The function estimates the benefit of using a quality level combination for service class Sj
                           . The motivation for constructing the evaluation function is that a greater number of candidate Web services under a quality level combination is better, and larger utility values of candidate Web services under a quality level combination are better. The evaluation function for evaluating quality level combinations is defined as (7).

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                F
                                                
                                                   (
                                                   Q
                                                   l
                                                   
                                                      C
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   )
                                                
                                                =
                                                
                                                   
                                                      n
                                                      (
                                                      Q
                                                      l
                                                      
                                                         C
                                                         j
                                                      
                                                      )
                                                   
                                                   q
                                                
                                                ·
                                                
                                                   U
                                                   
                                                      Q
                                                      L
                                                      
                                                         C
                                                         j
                                                      
                                                   
                                                   
                                                      m
                                                      a
                                                      x
                                                   
                                                
                                                
                                                   (
                                                   
                                                      S
                                                      j
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where QLCij
                            indicates the ith quality level combination for service class Sj, n(QLCi
                           ) represents the number of candidate services under the ith quality level combination, and q is the total number of all of the candidate services in service class Sj
                           . 
                              
                                 
                                    U
                                    
                                       Q
                                       L
                                       
                                          C
                                          j
                                       
                                    
                                    
                                       m
                                       a
                                       x
                                    
                                 
                                 
                                    (
                                    
                                       S
                                       j
                                    
                                    )
                                 
                              
                            is the maximum utility value of candidate services under the ith quality level combination. The objective of the global QoS decomposition is to find the best quality level combinations for each service class; therefore, the objective function for global QoS constraints optimal decomposition problem is defined as (8).

                              
                                 (8)
                                 
                                    
                                       
                                          
                                             
                                                Maximize
                                                
                                                   (
                                                   
                                                      ∑
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      n
                                                   
                                                   F
                                                   
                                                      (
                                                      Q
                                                      L
                                                      
                                                         C
                                                         
                                                            i
                                                            j
                                                         
                                                      
                                                      )
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Global QoS optimal decomposition is a combinatorial optimization problem for which the intelligent algorithm CGA is designed and to solve this problem. Here we name the global QoS optimal decomposition based on CGA as CGA-QD. The chromosome encoding model, selection operator, crossover operator, mutation operator and learning operation of CGA-QD will be presented in the following sections.

The aim of global QoS constraints decomposition is to determine the optimal quality level combination for each service class. Because each service class corresponds to a quality level combination, and a service composition workflow always has several service classes, the solution for the problem of global QoS constraint decomposition is constructed by quality level combinations of each service class; therefore, a two-dimensional encoding model is suitable for the CGA-QD. A chromosome for the problem of global QoS constraints decomposition is illustrated in Fig. 10
                           , in which 
                              
                                 {
                                 
                                    
                                       S
                                       1
                                    
                                    ,
                                    
                                       S
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       S
                                       m
                                    
                                 
                                 }
                              
                            presents service classes, and 
                              
                                 {
                                 
                                    
                                       Q
                                       1
                                    
                                    ,
                                    
                                       Q
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       Q
                                       k
                                    
                                 
                                 }
                              
                            indicates QoS attributes included in global QoS constraints. QmkLe
                            represents the eth quality level of the kth QoS attribute of service class Sm
                           . The rows of the chromosome represent quality level combinations for different service classes.

The process of generating an initial population for the CGA-SCS is described as follows: first, randomly select a quality level of each QoS attribute of a service class to construct a quality level combination for the current service class. Then, assemble the quality level combinations of all of the service classes together to form a chromosome. After that, check whether the chromosome is valid; if not, construct a chromosome again, and repeat this process until n valid chromosomes are obtained. A valid chromosome should satisfy two points: (a) for each row of the chromosome, there exist Web services that can satisfy the local constraints in the quality level combination, and (b) for each column of the chromosome, the aggregated value of the column can satisfy the corresponding global QoS constraint.

An evaluation function of the global QoS decomposition problem is used to calculate the sum of evaluations of the quality level combinations in the chromosome. The fitness function is defined as (8). This function is used to find the optimal quality level combination for all of the service classes.

In this paper, a roulette wheel model is adopted to complete the selection operation in the CGA-QD. A gene block crossover operator is designed and illustrated in Fig. 11
                           , in which A
                           1 and A
                           2 are two chromosomes. Suppose that the randomly selected gene blocks of A
                           1 are marked with red and the randomly selected gene blocks of A
                           2 are marked with yellow. Then, exchange the red gene blocks of A
                           1 with the yellow gene block of A
                           2. After completing the crossover operator, two new individuals 
                              
                                 A
                                 
                                    1
                                 
                                 
                                    
                                    ′
                                 
                              
                            and 
                              
                                 A
                                 
                                    2
                                 
                                 
                                    
                                    ′
                                 
                              
                            are generated.

In the CGA-QD, a one-row mutation operation is adopted to randomly select a row of a chromosome, then, new quality levels are randomly selected from the corresponding quality level collections to replace the selected quality levels in the chromosome.

The process of the learning operation in the CGA-QD is described as follows: first, randomly select several individuals from the population to form a learning group. Second, divide each individual into several segments. Third, for the identical segments of the individuals in the group, identify the best segments through comparison among the same segments. Finally, combine the selected segments to form a new individual. The learning operation in the CGA-QD is illustrated in Fig. 12
                           , in which 
                              
                                 〈
                                 
                                    I
                                    1
                                 
                                 ,
                                 
                                    I
                                    2
                                 
                                 ,
                                 …
                                 ,
                                 
                                    I
                                    k
                                 
                                 〉
                              
                            are k different individuals in the learning group and segments marked with color are the best segments among the identical segments. Through learning, the best segments can be selected, and all of the selected segments composed together can form a new individual INew
                           .

The process of global QoS constraints optimal decomposition based on CGA is described as Algorithm 3
                           . After obtaining local QoS constraints for all of the service classes, define these local QoS constraints as upper/lower bounds for selecting the best Web service for each task.

For the CGA-QD, let n be the scale of the population, m be the number of tasks in the service composition workflow, and k be the number of QoS attributes. P is the number of individuals that form a learning group, and L is the number of segments of the learning individuals. The complexities of the CGA-QD in each generation are shown in Table 3
                           . In the CGA-QD, a typical roulette wheel selection needs n roulette operations to generate a new population. Each roulette operation contains at least 1 and at most n times comparisons according to the relative fitness values of individuals. Thus, the average complexity of a selection operator is O(n
                           2). Moreover, crossover and mutation operations in the CGA-QD are only executed once for each individual; thus, the complexities are both at least O(nmk) and at most O(nmk). The complexity of the learning operation is 
                              
                                 O
                                 (
                                 n
                                 P
                                 L
                                 k
                                 )
                              
                           . Therefore, the complexity of CGA-SCS is O(n
                           2).

In the second stage of reliable dynamic Web service composition, QoS prediction is adopted to enhance the accuracy of each service’s QoS; that is, the QoS of each candidate service is predicted before selecting the best service for each task. To obtain an accurate QoS, this paper proposes a QoS prediction method based on improved CBR. This method considers several key factors that influence a service’s QoS. The QoS prediction method based on improved CBR is introduced in detail in the following sections.

In the dynamic Internet environment, there are several factors that greatly influence Web service QoS, such as serviceload, tasktype, taskvolume, and cooperationservice. There exist relationships between these factors and Web service QoS. To predict Web service QoS accurately, this study considers these factors and proposes a dynamic QoS prediction method based on improved CBR. The main idea of this QoS prediction method is that when a service operates in an identical or similar environment, and the cooperation service and the task to be processed are identical or similar, then, the QoS of the service will be identical or similar.

CBR is a popular problem-solving methodology that solves a new problem by remembering previous similar problems and reusing the solutions of these problems [70,71]. CBR has been successfully applied in many domains such as dynamic scheduling [72], intelligent stock selection [73], and petroleum engineering [74]. In CBR, a case model consists of two parts: the first part describes the problem and the second part presents a solution of the problem to be solved. A case model of CBR can be illustrated as (9).

                           
                              (9)
                              
                                 
                                    
                                       
                                          
                                             C
                                             a
                                             s
                                             e
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             〈
                                             P
                                             r
                                             o
                                             b
                                             l
                                             e
                                             m
                                             d
                                             e
                                             s
                                             c
                                             r
                                             i
                                             p
                                             t
                                             i
                                             o
                                             n
                                             
                                                (
                                                
                                                   p
                                                   1
                                                
                                                ,
                                                
                                                   p
                                                   2
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   p
                                                   r
                                                
                                                )
                                             
                                             ∥
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             S
                                             o
                                             l
                                             u
                                             t
                                             i
                                             o
                                             n
                                             (
                                             s
                                             o
                                             
                                                l
                                                1
                                             
                                             ,
                                             s
                                             o
                                             
                                                l
                                                2
                                             
                                             ,
                                             …
                                             ,
                                             s
                                             o
                                             
                                                l
                                                u
                                             
                                             )
                                             〉
                                             ;
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              P
                              r
                              o
                              b
                              l
                              e
                              m
                              d
                              e
                              s
                              c
                              r
                              i
                              p
                              t
                              i
                              o
                              n
                              (
                              
                                 p
                                 1
                              
                              ,
                              
                                 p
                                 2
                              
                              ,
                              …
                              ,
                              
                                 p
                                 r
                              
                              )
                           
                         indicates important elements of the problem to be solved, and r is the number of the problem elements. 
                           
                              S
                              o
                              l
                              u
                              t
                              i
                              o
                              n
                              (
                              s
                              o
                              
                                 l
                                 1
                              
                              ,
                              s
                              o
                              
                                 l
                                 2
                              
                              ,
                              …
                              ,
                              s
                              o
                              
                                 l
                                 u
                              
                              )
                           
                         presents the solution of the problem, and u is the number of elements of the solution. The meaning of the case model is that the current situation of the problem is 
                           
                              P
                              r
                              o
                              b
                              l
                              e
                              m
                              d
                              e
                              c
                              r
                              i
                              p
                              t
                              i
                              o
                              n
                              (
                              
                                 p
                                 1
                              
                              ,
                              
                                 p
                                 2
                              
                              ,
                              …
                              ,
                              
                                 p
                                 r
                              
                              )
                           
                        ; thus, the solution of the problem is 
                           
                              S
                              o
                              l
                              u
                              t
                              i
                              o
                              n
                              (
                              s
                              o
                              
                                 l
                                 1
                              
                              ,
                              s
                              o
                              
                                 l
                                 2
                              
                              ,
                              …
                              ,
                              s
                              o
                              
                                 l
                                 u
                              
                              )
                           
                        . CBR is very appropriate for QoS prediction because the case model of CBR is very suitable for describing the QoS prediction problem. That is, the first part can describe the current situation of service, such as serviceload, tasktype, taskvolume, and cooperationservice; the second part is suitable to describe service QoS values, such as Cost, Responsetime, Availability, and Reliability. A QoS case indicates that when a service is under the situation described in the first part, then QoS of the service will be the second parts of the QoS case.

The process of CBR consists of four processes: 
                           
                              (
                              a
                              )
                           
                         Retrieve similar historic cases from the case-base. 
                           
                              (
                              b
                              )
                           
                         Reuse solutions of similar historic cases to generate a proper solution to the current problem. 
                           
                              (
                              c
                              )
                           
                         Revise the proposed solution if necessary. 
                           
                              (
                              d
                              )
                           
                         Retain the new case by incorporating it into the existing case-base for future problem-solving. In the following sections, key elements (such as QoS case model, QoS case organization, QoS cases retrieval, and QoS prediction) of the QoS prediction method are presented in detail in the following sections.

The QoS case model is defined as 〈currentsituationofservice∥QoSvalues〉. The first part of the model describes factors that have great influence on service QoS, and the second part of the model indicates QoS values when the service is dealing with the task under the situation described in the first part. Under the open network environment, factors that influence service QoS primarily include service load, task type, task volume, and cooperation service. Moreover, because newer QoS cases have better reference values, the timeliness of a QoS case is also important; therefore, a time stamp is added to QoS cases. The QoS case model is defined in (10).

                              
                                 (10)
                                 
                                    
                                       
                                          
                                             
                                                Q
                                                o
                                                S
                                                C
                                                =
                                                
                                                   〈
                                                   S
                                                   L
                                                   ,
                                                   T
                                                   T
                                                   ,
                                                   T
                                                   A
                                                   ,
                                                   C
                                                   o
                                                   S
                                                   ∥
                                                   
                                                      q
                                                      1
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      q
                                                      k
                                                   
                                                   〉
                                                
                                                
                                                   
                                                   
                                                      T
                                                      i
                                                      m
                                                      e
                                                      T
                                                      a
                                                      g
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

In the QoS case model, SL indicates service load during processing a task, TT and TV indicate the task type and task volume, CoS presents the cooperation service, TimeTag presents the time when this QoS case was created. 
                              
                                 〈
                                 
                                    q
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    q
                                    k
                                 
                                 〉
                              
                            indicate QoS values of the service when it address the task under the situation described in the first part. This QoS case model is extensible; other factors that influence service QoS and other QoS attributes can be flexibly added into the model.

The basic principle of CBR is to find one or more similar historical cases of the target case, and then generate a solution for the target case based on solutions of the selected similar historic cases. When the number of historic QoS cases is large, the retrieving process will be time consuming. To improve the efficiency of retrieving similar cases, historical QoS cases should be organized reasonably. For QoS cases, cooperation service, service load, task type, and task volume are key problem features; using these features as indexes to organize QoS cases could improve the speed of case retrieval. The QoS of the service will be different when it cooperates with different services; therefore, we first classify QoS cases according to the cooperation services. Because Web service QoS is not comparable when addressing tasks of different types, QoS cases are classified with the same cooperation service according to task type. Then, QoS cases are classified according to the service load range. Here the load range is divided into five intervals, such as:

                              
                                 
                                    
                                       
                                          
                                             0
                                          
                                          
                                             ≤
                                          
                                          
                                             
                                                S
                                                L
                                                <
                                                20
                                                %
                                                ,
                                                20
                                                ≤
                                                S
                                                L
                                                <
                                                40
                                                %
                                                ,
                                                40
                                                ≤
                                                S
                                                L
                                                <
                                                60
                                                %
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             60
                                          
                                          
                                             ≤
                                          
                                          
                                             
                                                S
                                                L
                                                <
                                                80
                                                %
                                                ,
                                                80
                                                ≤
                                                S
                                                L
                                                <
                                                100
                                                %
                                             
                                          
                                       
                                    
                                 
                              
                           Finally, QoS cases are stored sequentially according to task volume. The organization of QoS cases can be illustrated as Fig. 13
                           .

When receiving a QoS prediction demand, the QoS prediction system constructs a target QoS case based on the current situation of service. The target QoS case model is defined as (11).

                              
                                 (11)
                                 
                                    
                                       
                                          
                                             
                                                T
                                                C
                                                =
                                                
                                                   〈
                                                   S
                                                   
                                                      L
                                                      0
                                                   
                                                   ,
                                                   T
                                                   
                                                      T
                                                      0
                                                   
                                                   ,
                                                   T
                                                   
                                                      A
                                                      0
                                                   
                                                   ,
                                                   C
                                                   o
                                                   S
                                                   ∥
                                                   ?
                                                   
                                                      q
                                                      1
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   ?
                                                   
                                                      q
                                                      k
                                                   
                                                   〉
                                                
                                                
                                                   
                                                   
                                                      T
                                                      i
                                                      m
                                                      e
                                                      T
                                                      a
                                                      g
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where SL
                           0 is the current service load, and TT
                           0 and TV
                           0 are task type and task volume of the task to be processed, CoS means the cooperation service, 
                              
                                 ?
                                 
                                    q
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 ?
                                 
                                    q
                                    k
                                 
                              
                            indicate QoS values to be predicted. TT
                           0 and TV
                           0 can be determined form the description of the task. SL
                           0 can be calculated according to (12).

                              
                                 (12)
                                 
                                    
                                       
                                          
                                             
                                                S
                                                L
                                                =
                                                
                                                   w
                                                   
                                                      1
                                                   
                                                   
                                                      
                                                      ′
                                                   
                                                
                                                ·
                                                U
                                                
                                                   R
                                                   
                                                      C
                                                      P
                                                      U
                                                   
                                                
                                                +
                                                
                                                   w
                                                   
                                                      2
                                                   
                                                   
                                                      
                                                      ′
                                                   
                                                
                                                ·
                                                U
                                                
                                                   R
                                                   
                                                      I
                                                      /
                                                      O
                                                   
                                                
                                                +
                                                
                                                   w
                                                   
                                                      3
                                                   
                                                   
                                                      
                                                      ′
                                                   
                                                
                                                ·
                                                U
                                                
                                                   R
                                                   M
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where URCPU, UR
                           
                              I/O
                            and URM
                            denote the utilization rate of CPU, I/O and the Memory of the Server in which the Web service is deployed, 
                              
                                 
                                    w
                                    
                                       1
                                    
                                    
                                       
                                       ′
                                    
                                 
                                 ,
                              
                           
                           
                              
                                 w
                                 
                                    2
                                 
                                 
                                    
                                    ′
                                 
                              
                           , and 
                              
                                 w
                                 
                                    3
                                 
                                 
                                    
                                    ′
                                 
                              
                            indicate the importance of URCPU, UR
                           
                              I/O
                           , and URM
                           , and 
                              
                                 w
                                 
                                    1
                                 
                                 
                                    
                                    ′
                                 
                              
                            + 
                              
                                 w
                                 
                                    2
                                 
                                 
                                    
                                    ′
                                 
                              
                            + 
                              
                                 w
                                 
                                    3
                                 
                                 
                                    
                                    ′
                                 
                              
                            =1. The value of 
                              
                                 
                                    w
                                    
                                       1
                                    
                                    
                                       
                                       ′
                                    
                                 
                                 ,
                              
                           
                           
                              
                                 w
                                 
                                    2
                                 
                                 
                                    
                                    ′
                                 
                              
                           , and 
                              
                                 w
                                 
                                    3
                                 
                                 
                                    
                                    ′
                                 
                              
                            could be determined through a trial and error method, here we assume they are known.

To predict the QoS values of the target QoS case, retrieve the top d similar historical QoS cases from the QoS case base that are similar to the target case from. In this paper, a historical QoS case QoSCi
                            is similar to the target case TC if and only if the similarity between QoSCi
                            and TC is greater than a similarity value ν defined in advance. The process of retrieving similar QoS cases is presented as follows:

                              
                                 (1)
                                 Identify historical QoS cases that have the same cooperation service as the target QoS case.

Retrieve historic QoS cases that have the same task type as the target case.

Filter out historical QoS cases in the same time window.

Compute the similarity between the target service and the retrieved historical QoS cases, and select the top d historical QoS cases based on the computed similarity.

The similarity between historic QoS cases and the target case includes local similarity and global similarity. Local similarity indicates a similarity of factors between historic QoS cases and the target case, whereas the global similarity is the weighted average of local similarities. Pal and Shiu verified that Manhattan distance is the best method of calculating local similarity [75]; therefore, similarity-calculating formula between historic QoS cases and a target QoS case based on Manhattan distance is defined as (13):

                              
                                 (13)
                                 
                                    
                                       
                                          
                                             
                                                S
                                                i
                                                m
                                                
                                                   (
                                                   T
                                                   C
                                                   ,
                                                   S
                                                   
                                                      C
                                                      i
                                                   
                                                   )
                                                
                                                =
                                                s
                                                i
                                                
                                                   m
                                                   1
                                                
                                                ·
                                                
                                                   w
                                                   
                                                      s
                                                      1
                                                   
                                                
                                                +
                                                s
                                                i
                                                
                                                   m
                                                   2
                                                
                                                ·
                                                
                                                   w
                                                   
                                                      s
                                                      2
                                                   
                                                
                                                ;
                                             
                                          
                                       
                                    
                                 
                              
                           where 
                              
                                 
                                    w
                                    
                                       s
                                       1
                                    
                                 
                                 +
                                 
                                    w
                                    
                                       s
                                       2
                                    
                                 
                                 =
                                 1
                                 ,
                              
                            
                           w
                           
                              s1 and w
                           
                              s2 indicate the weight of the two local similarities. Formulas for calculating local similarities are defined as follows:


                           
                              
                                 
                                    (
                                    1
                                    )
                                 
                                 
                                 s
                                 i
                                 
                                    m
                                    1
                                 
                                 =
                                 1
                                 −
                                 
                                    |
                                    S
                                    
                                       L
                                       0
                                    
                                    −
                                    S
                                    
                                       L
                                       j
                                    
                                    |
                                 
                              
                           : computes the similarity of load between historic QoS cases and a target case.


                           
                              
                                 
                                    (
                                    2
                                    )
                                 
                                 
                                 s
                                 i
                                 
                                    m
                                    2
                                 
                                 =
                                 1
                                 −
                                 
                                    
                                       
                                          |
                                          T
                                       
                                       
                                          V
                                          0
                                       
                                       −
                                       T
                                       
                                          V
                                          j
                                       
                                       
                                          |
                                       
                                    
                                    
                                       T
                                       
                                          V
                                          
                                             m
                                             a
                                             x
                                          
                                       
                                    
                                 
                              
                           : computes the similarity of task volume between historic QoS cases and a target case, where TAmax
                            is the maximum of task quantity the service could process.


                           w
                           
                              s1 and w
                           
                              s2 indicate weights of similarities of service load and task volume. Suppose 
                              
                                 {
                                 Q
                                 
                                    C
                                    1
                                 
                                 ,
                                 Q
                                 
                                    C
                                    2
                                 
                                 ,
                                 …
                                 ,
                                 Q
                                 
                                    C
                                    d
                                 
                                 }
                              
                            are the top d historically similar QoS cases; the next step is to generate a solution for the target QoS case based on these similar QoS cases.

After obtaining d similar historic QoS cases, the QoS values of the target case can be generated based on the QoS values of the d similar QoS cases. Currently, there are several approaches for generating solutions based on similar historic cases. In this paper, time stamp has been added to the QoS cases; a newer QoS case has a higher reference value. Before computing the solution of the target case, we first sort the d similar QoS cases according to time tag and assume the arrangement is 
                           
                              Q
                              
                                 C
                                 1
                              
                              ≻
                              Q
                              
                                 C
                                 2
                              
                              ≻
                              …
                              ≻
                              Q
                              
                                 C
                                 d
                              
                           
                        . In this paper, we propose a new solution-generating formula, which is defined as (14).

                           
                              (14)
                              
                                 
                                    
                                       
                                          
                                             T
                                             
                                                C
                                                
                                                   Q
                                                   o
                                                   S
                                                
                                             
                                             =
                                             
                                                w
                                                
                                                   1
                                                
                                                
                                                   
                                                   
                                                      ′
                                                      ′
                                                   
                                                
                                             
                                             Q
                                             
                                                C
                                                
                                                   1
                                                
                                                
                                                   Q
                                                   o
                                                   S
                                                
                                             
                                             +
                                             ⋯
                                             +
                                             
                                                w
                                                
                                                   d
                                                
                                                
                                                   
                                                   
                                                      ′
                                                      ′
                                                   
                                                
                                             
                                             Q
                                             
                                                C
                                                
                                                   d
                                                
                                                
                                                   Q
                                                   o
                                                   S
                                                
                                             
                                             ;
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 w
                                 
                                    1
                                 
                                 
                                    
                                    
                                       ′
                                       ′
                                    
                                 
                              
                              >
                              
                                 w
                                 
                                    2
                                 
                                 
                                    
                                    
                                       ′
                                       ′
                                    
                                 
                              
                              >
                              ⋯
                              >
                              
                                 w
                                 
                                    d
                                 
                                 
                                    
                                    
                                       ′
                                       ′
                                    
                                 
                              
                              ,
                           
                        
                        
                           
                              
                                 w
                                 
                                    1
                                 
                                 
                                    
                                    
                                       ′
                                       ′
                                    
                                 
                              
                              +
                              
                                 w
                                 
                                    2
                                 
                                 
                                    
                                    
                                       ′
                                       ′
                                    
                                 
                              
                              +
                              ⋯
                              +
                              
                                 w
                                 
                                    d
                                 
                                 
                                    
                                    
                                       ′
                                       ′
                                    
                                 
                              
                              =
                              1
                              ,
                           
                         
                        TCQoS
                         denotes the QoS vector of the target case, and 
                           
                              〈
                              Q
                              
                                 C
                                 
                                    1
                                 
                                 
                                    Q
                                    o
                                    S
                                 
                              
                              ,
                              Q
                              
                                 C
                                 
                                    2
                                 
                                 
                                    Q
                                    o
                                    S
                                 
                              
                              ,
                              …
                              ,
                              Q
                              
                                 C
                                 
                                    d
                                 
                                 
                                    Q
                                    o
                                    S
                                 
                              
                              〉
                           
                         indicate the QoS vector of similar historic QoS cases. In this formula, the weight of the newer QoS case is set higher to ensure that the newer QoS case will impose a stronger influence on generating the solution for the target case. By incorporating the solution parts of the d similar historic QoS cases into (13), the QoS values of the target case can be produced. Web service QoS prediction based on improved CBR is described as Algorithm 4
                        .

For the QoS prediction method, let n be the scale of the QoS cases that have the same cooperation service and task type as the target QoS case and d be the number of similar QoS cases. The complexities of the QoS prediction method are shown in Table 4
                        . The complexity of computing the similarity between a target QoS case and historical QoS cases is O(n), the complexity of selecting the top d historical QoS cases lies in the sorting operation, and its complexity is O(dn
                        2). The complexity of generating QoS values of the d historical QoS cases is O(dk
                        2). Therefore, the complexity of the QoS prediction method is O(n
                        2).

During the running of the service composition workflow, before selecting the best service for the current task, predict candidate services’ QoS based on the QoS prediction method. Then, according to the predicted QoS values, select the optimal Web service that can satisfy corresponding local QoS constraints and has the best fitness value. the local optimal Web service selection algorithm is described as Algorithm 5. Through this service selection method, during the execution of the Web service composition process, best services can be selected for all of the tasks.
                  

For the local optimal service selection method, let K be the number of the candidate services for the current task and r be the number of QoS attributes. The complexity of computing the fitnesses of candidate services is O(rK). The complexity of selecting the optimal service lies in the sorting operation, and its complexity is O(K
                        2). Therefore, the complexity of the local optimal service selection method is O(n
                        2).

@&#EXPERIMENTAL RESULTS@&#

The experiment work contains two major parts. The first part is to verify the effectiveness of dynamic Web service composition based on global QoS constraints optimal decomposition; the second part is to verify the validity of the QoS prediction method.

To verify the feasibility and effectiveness of the dynamic Web service composition method proposed in this paper, we perform three simulation experiments. The first and second experiments are used to verify the feasibility and scalability of the approach; the third experiment is designed to verify the superiority of the approach. The experimental background is designed as follows. Suppose that there is a Web service composition process consisting of nine abstract services. Each abstract service has m candidate services. m varies from 50 to 400, and there are four global QoS constraints:

                              
                                 (1)
                                 
                                    Cost < 140Dollar; (2) ResponseTime < 130Sec; (3) Reliability > 0.40; (4) Availability > 0.40;

The number of quality levels is d; d varies from 10 to 40. User QoS preferences including Cost, ResponseTime, Reliability, and Availability and are set as 0.35, 0.3, 0.25, and 0.1, respectively. QoS values of candidate Web services of the nine service classes are randomly generated within certain ranges. The value ranges of Reliability and Availability of all of the service classes are set as follows: 
                              
                                 R
                                 e
                                 l
                                 i
                                 a
                                 b
                                 i
                                 l
                                 i
                                 t
                                 y
                                 >
                                 =
                                 0.85
                                 ;
                                 A
                                 v
                                 a
                                 i
                                 l
                                 a
                                 b
                                 i
                                 l
                                 i
                                 t
                                 y
                                 >
                                 =
                                 0.85
                              
                           .

To be consistent with the actual situation, the value ranges of Cost and ResponseTime of the services in the nine service classes are different.Value ranges of Cost and ResponseTime of all of the service classes are set as follows.

                              
                                 (1)
                                 For service class S
                                    1: 
                                       
                                          8
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          25
                                          ;
                                          1
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          20
                                       
                                    ;

For service class S
                                    2: 
                                       
                                          20
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          50
                                          ;
                                          15
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          30
                                       
                                    ;

For service class S
                                    3: 
                                       
                                          1
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          15
                                          ;
                                          5
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          15
                                       
                                    ;

For service class S
                                    4: 
                                       
                                          10
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          25
                                          ;
                                          2
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          8
                                       
                                    ;

For service class S
                                    5s: 
                                       
                                          1
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          10
                                          ;
                                          10
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          20
                                       
                                    ;

For service class S
                                    6: 
                                       
                                          20
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          40
                                          ;
                                          20
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          32
                                       
                                    ;

For service class S
                                    7: 
                                       
                                          12
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          24
                                          ;
                                          3
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          9
                                       
                                    ;

For service class S
                                    8: 
                                       
                                          1
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          5
                                          ;
                                          12
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          25
                                       
                                    ;

For service class S
                                    9: 
                                       
                                          5
                                          =
                                          <
                                          C
                                          o
                                          s
                                          t
                                          <
                                          =
                                          15
                                          ;
                                          14
                                          =
                                          <
                                          R
                                          s
                                          p
                                          o
                                          n
                                          s
                                          e
                                          T
                                          i
                                          m
                                          e
                                          <
                                          =
                                          25
                                       
                                    ;

The GA configuration in this experiment is as follows.

                              
                                 (1)
                                 Parameter setting of the GA

Currently, the parameters of the GA are set based on the experience. The existing research result proves that the better experience value for population size is [20, 160], the experience-based value of the crossover probability is [0.25, 1.0], and the experience-based value of the mutation probability is [0.005, 0.1]. Here, we set the size of the population in the GA as 100, the crossover probability is set to 0.85, and the parameter of mutation is set to 0.05.

Generating initial population of the GA

First, the quality levels for each QoS attribute of each service class are computed. The process is described as follows. Find the maximum and minimum value of the kth QoS attribute by statistical methods. Here assume that the maximum and minimum values of the kth QoS attribute are 
                                       
                                          m
                                          a
                                          
                                             x
                                             
                                                q
                                                k
                                             
                                          
                                       
                                     and 
                                       
                                          m
                                          i
                                          
                                             n
                                             
                                                q
                                                k
                                             
                                          
                                          ,
                                       
                                     respectively. Then, generate the quality level of each QoS attributes by formula (15).

                                       
                                          (15)
                                          
                                             
                                                
                                                   
                                                      
                                                         L
                                                         =
                                                         
                                                            
                                                               (
                                                               m
                                                               a
                                                               
                                                                  x
                                                                  
                                                                     q
                                                                     k
                                                                  
                                                               
                                                               −
                                                               m
                                                               i
                                                               
                                                                  n
                                                                  
                                                                     q
                                                                     k
                                                                  
                                                               
                                                               )
                                                            
                                                            d
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    Finally, constructing the quality level set of each QoS attribute, which is presented as (16):

                                       
                                          (16)
                                          
                                             
                                                
                                                   
                                                      
                                                         L
                                                         e
                                                         v
                                                         e
                                                         l
                                                         S
                                                         e
                                                         
                                                            t
                                                            
                                                               q
                                                               k
                                                            
                                                         
                                                      
                                                   
                                                   
                                                      =
                                                   
                                                   
                                                      
                                                         {
                                                         m
                                                         i
                                                         
                                                            n
                                                            
                                                               q
                                                               k
                                                            
                                                         
                                                         ,
                                                         m
                                                         i
                                                         
                                                            n
                                                            
                                                               q
                                                               k
                                                            
                                                         
                                                         +
                                                         L
                                                         ,
                                                         …
                                                         ,
                                                         m
                                                         i
                                                         
                                                            n
                                                            
                                                               q
                                                               k
                                                            
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                   
                                                   
                                                      
                                                         +
                                                         
                                                         
                                                            (
                                                            d
                                                            −
                                                            1
                                                            )
                                                         
                                                         ·
                                                         L
                                                         ,
                                                         m
                                                         a
                                                         
                                                            x
                                                            
                                                               q
                                                               k
                                                            
                                                         
                                                         
                                                            }
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    After obtaining the quality level set of each QoS attribute of each service class, we can produce chromosomes for the GA. A two-dimensional array is used to store a chromosome. The combination of quality levels of the four QoS attributes of a service class is stored in a row of the two-dimensional array. Chromosomes are produced randomly, that is, for each service class, randomly select a quality level of a QoS attribute and assemble these quality levels together to form a quality levels combination(a row of the two-dimensional array). Assemble all of the quality level combinations together to form a chromosomes (a two-dimensional array), as illustrated in Fig. 6. Repeat the chromosomes generating method until 100 individuals are obtained.

Selection operation in the GA

In the GA, the roulette wheel is adopted as the selection operation. The selection operation is performed as follows. First, calculate the fitness of each chromosome according to the fitness function defined as Eq. (3). Here, assume the fitness of the 100 chromosomes are

                                       
                                          
                                             
                                                {
                                                f
                                                i
                                                
                                                   t
                                                   1
                                                
                                                ,
                                                f
                                                i
                                                
                                                   t
                                                   2
                                                
                                                ,
                                                …
                                                ,
                                                f
                                                i
                                                
                                                   t
                                                   100
                                                
                                                }
                                             
                                          
                                       
                                    then, compute the selection probability of the each chromosome according to (17).

                                       
                                          (17)
                                          
                                             
                                                
                                                   p
                                                   i
                                                
                                                =
                                                
                                                   
                                                      f
                                                      i
                                                      
                                                         t
                                                         i
                                                      
                                                   
                                                   
                                                      
                                                         ∑
                                                         
                                                            j
                                                            =
                                                            1
                                                         
                                                         100
                                                      
                                                      
                                                         f
                                                         i
                                                         
                                                            t
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    Each probability value consists of an area, and the sum of all of the probability values equals 1. When performing the selection operation, first generate a random number r in the interval of (0,1); then, select an individual according to the area in which the random number r appears. Repeat this selection method until the size of the new population is 100.

Crossover operation in the GA

Crossover operation is a major operator in the GA to generate a new individual by exchanging parts of two specific chromosomes with a certain probability. In this paper, the gene-segment crossover method is adopted. The crossover process is described as follows. First, randomly pair the chromosomes. Then, randomly determine two locations of the row vector of each chromosomes pair. Finally, exchange the two gene segments determined by the two locations. The process of the crossover operation is illustrated in Fig. 11.

Mutation operation in the GA

Mutation operation in the GA is also a method for generating new individuals by changing one or some genes in a chromosome according to a small probability. In this paper, a single point mutation method is adopted. The process of the mutation operation is described as follows. First, randomly determine a gene location of each chromosome, that is, randomly select a column of the two-dimensional array that indicates a chromosome. Then, according to a certain probability, exchange the quality levels in the determined column with quality levels that are randomly selected from quality level sets to which the determined quality levels belong.

The parameter setting and the setup of operations of the GA have some reference value for solving a similar problem with the global QoS decomposition problem. In this experiment, the number of excellent individuals extracted to the belief space is set to 20, and the generations of knowledge accumulation in the belief space is set to 5. The number of individuals that form a learning group is 5. The experimental environment is a PC configured with the following configures, CPU: Intel(R) Core(TM) Duo, 2.93 GHz; Memory: 1.00 GB; and OS: Windows 7. The time unit of the following experiments is one second. The algorithm of global QoS constraint optimal decomposition based on the CGA is realized with C++ programming language.

In this experiment, set m ∈ {50, 100, 200, 300, 400}, and set 
                              
                                 d
                                 =
                                 20
                              
                           . Then, execute the dynamic Web service composition algorithm, and record the running time of the algorithm with different numbers of candidate Web services. Experimental results are depicted in Fig. 14
                           , in which the vertical axis represents the running time of the algorithm, and the horizontal axis denotes the number of iterations.

As Fig. 14 indicates, with an increase in the number of candidate Web services, the running time of the dynamic Web service composition algorithm does not significantly increase. By comparing we can found that there is linear growth between the running time of the algorithm and the increase of the number of candidate services. Therefore, we can say that the service composition algorithm proposed in this paper has better feasibility and scalability.

Experiment 2 is used to verify the influence of the quality level number on the performance of the service composition method, here named 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                           . In this experiment, set 
                              
                                 m
                                 =
                                 100
                                 ,
                              
                            and the quality level number d varies from 10 to 40. We iterate the service composition method with different quality level numbers for 100, 200, 300, 400, 500, and 600 times, recording the running time and evaluation values of the CWS found by the service composition method. The experimental results are illustrated as Figs. 15
                            and 16
                           .


                           Fig. 15 describes the running time of the 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            with a different quality level number, in which the vertical axis represents the running time of the algorithm and the horizontal axis denotes the number of iterations of the algorithm. As Fig. 15 indicates, the running time increases rapidly when the number of the quality level number is large. From this result, we can say that the quality level number is the main factor that influences the speed of 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                           .


                           Fig. 16 describes best solutions found by 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            with a different quality level number, in which the vertical axis represents the evaluation of CWSs founded by 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                                 ,
                              
                            and the horizontal axis denotes the quality level numbers. As Fig. 16 indicates when the quality level number is set to 10, the solution founded by 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            is the best. Considering the experimental results, we can find that when set the quality level number as 10, 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            not only can run fast but also identify a better solution. So, the quality level number in this paper is set to 10.

Experiment 3 is to verify the superiority of 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                           . In this experiment, we use 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            and the 
                              
                                 C
                                 -
                                 M
                                 M
                                 A
                                 S
                              
                            algorithm provided in works [33] to solve the service composition problem designed is Section 3.1. The number of tasks in the service composition workflow is 9, the number of Web services in each service class is 50, and the quality level number is 10. Other parameters of 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            are set as in Section 8.1.1. The parameters of 
                              
                                 C
                                 −
                                 M
                                 M
                                 A
                                 S
                              
                            are set as proposed in works [33].

The two methods are executed under in identical environments. The running time and the solution found by each method are recorded. Experimental results are presented in Fig. 17
                           . The vertical axis represents the evaluation of solutions, and the horizontal axis denotes running times of the two algorithms. Solutions founded by the two algorithms and the corresponding running times are also presented in Fig. 18
                           . From Figs. 17 and 18, we can determine that 
                              
                                 W
                                 S
                                 
                                    C
                                    −
                                 
                                 C
                                 G
                                 A
                              
                            has better searching capability and a fast convergence rate.

To verify the validity of the QoS dynamic prediction method, simulation experiments are conducted on the Web service application platform. A Web service with two computing functions is developed; one function is to calculate the rank of a large matrix, and another function is to calculate the eigenvalues of the large matrix. Here, use the calculation of matrices rank as the first task type, recorded as type I; use the calculation of the matrices eigenvalues as the second task type, recorded as type II. The order of the matrix is used to indicate the task volume.

The simulation experiment platform consists of two components. The first component of the platform is the client simulated by a PC. The configuration of the PC is, CPU2vCPU 1674 MHz, Memory2048 MB, OSWindows XP. The second component is a Web Server on which the service is deployed. The configuration of the Web Server is CPU2vCPU 1674 MHz; Memory1024 MB; and OSWindows XP. In this experiment, some tasks are randomly generated, task type is randomly produced between I and II, and task volumes are randomly generated in the interval [500, 2000]. Then, these tasks are randomly submitted to the Web service. When a task is submitted, the client records the task type, task volume and the submission time 
                              
                                 T
                                 sub
                              
                           ; when the result is received, the client records the completion time 
                              
                                 T
                                 comp
                              
                           ; then, the response time T is computed by formula: 
                              
                                 T
                                 =
                                 
                                    T
                                    comp
                                 
                                 −
                                 
                                    T
                                    sub
                                 
                              
                           . The experiment platform is illustrated in Fig. 19
                           .

In this experiment, CPU utilization is used to indicate the load of the service; during the process of handling tasks, CPU utilization is recorded every 50 ms. After the task is completed, the average value of CPU utilization is interpreted as the load of the service. Because there is no cooperation between services in this simulation experiment, the factor of cooperation service is not considered. After a task is completed, create a QoS case according to the load, task type, task volume, and processing time. In this experiment, 1750 QoS cases with task type I and 1500 QoS cases with task type II are produced. Only the ResponseTime attribute is considered.

This experiment is to verify that Web service QoS is subject to the influence of several key factors, such as service load, task type, and task volume. In this experiment, keep the load of the service at 30%; then, produce some tasks with different task volumes and different task types, and submit these tasks to the service. Record the response time of these tasks. Experiment results are described in Fig. 20
                           .


                           Fig. 20 show the following: (1) although the task amount and service load are the same, if the task type is different, the response times of these tasks are different; (2) although service load and task type are the same, if the volumes of the tasks are different, the response times of these tasks are different. As seen in Fig. 20, response time increases with the increase of the volume of task. Therefore, it can be concluded that when service load, or task type, or task volume changes, the QoS will also change. Thus, to predict Web service QoS, it is necessary to consider the factors that cause the fluctuation of the Web service QoS.

When using the CBR method to solve a new problem, the quality of similar historical cases is very important; therefore, it is necessary to find the most suitable value of parameter k. This experiment aims to find a suitable value for parameter k. In this experiment, a QoS prediction method based on improved CBR is realized with the C++ programming language. The experiment environment is a PC configured with CPU: Intel(R) 4 2.40 GHz, Memory: 512MB; OS: Microsoft Windows 2000. Here, the 10-fold cross-validation method is adopted. Each data fold includes 30 QoS cases; then, for each data fold, we set values for parameter k as 1,2,...,10 and predict the QoS of the test cases. The experimental results are presented as Fig. 21
                           .

From Fig. 21, it can be seen that when the value of k is small, the average prediction error rate is high, and as the number of similar QoS cases increases, the average prediction error rate gradually decreases. This result is because that when the number of similar QoS cases is small, the number of similar QoS cases with high quality is also small; thus, it cannot give fully apply similar historical cases to the solving of new problems, leading to a high average relative prediction error rate. With an increase in the number of similar cases, more high-quality similar cases are reused, thereby improving precision of prediction is improved; As seen in Fig. 20, when the number of similar cases is 6, the prediction accuracy is the highest. Subsequently, when the number of similar cases gradually becomes grater, the prediction accuracies begin to decrease, this decrease occurs because that with the increase in the similar cases, some similar cases with poor quality will be reused, thus affecting prediction accuracy.

To obtain the best prediction effect, the number of similar cases is set to 6. That is, when predicting the QoS values of a new QoS case, select the top six historical QoS cases according to their similarity, and compute QoS values of the new QoS case based on the five similar QoS cases.

This experiment is to verify the effectiveness of our QoS prediction method. In this experiment, a QoS prediction method based on CBR and a QoS prediction method based on an optimized vector machine [76](O-SVM) are adopted to predict the response time of QoS cases, O-SVM is produced through optimizing the parameters of SVM by an artificial colony bee algorithm [77]. In this experiment, the scale of the QoS data is 896, the first 800 data points are used as training data, and the last 96 are used as a testing data set. For each experiment, randomly select 20 data values from the testing data set and use them as testing data. For the O-SVM method, set the loss function parameter 
                              
                                 
                                    ɛ
                                 
                                 =
                                 0.01
                                 ,
                              
                            the value range of penalty parameter c and kernel function parameter σ is [0.1, 1000], and the value of c and σ are dynamically determined by the ABC algorithm. In order to verify the performance of the O-SVM method, the QoS data are increased 50 by 50 during the experiment, and the parameters of SVM is optimized for each group of data, and is used to train SVM in the next group of data and complete the prediction of testing QoS data. For the QoS prediction method based on improved CBR, set 
                              
                                 
                                    w
                                    
                                       s
                                       1
                                    
                                 
                                 =
                                 0.6
                                 ,
                              
                           
                           
                              
                                 
                                    w
                                    
                                       s
                                       2
                                    
                                 
                                 =
                                 0.4
                              
                           ;
                              
                                 
                                    w
                                    1
                                 
                                 =
                                 0.3
                                 ,
                              
                           
                           
                              
                                 
                                    w
                                    2
                                 
                                 =
                                 0.25
                                 ,
                              
                           
                           
                              
                                 
                                    w
                                    3
                                 
                                 =
                                 0.2
                                 ,
                              
                           
                           
                              
                                 
                                    w
                                    4
                                 
                                 =
                                 0.15
                                 ,
                              
                           
                           
                              
                                 
                                    w
                                    6
                                 
                                 =
                                 0.1
                                 ,
                              
                            QoS prediction is to be performed when the scale of train QoS data reaches 10, 20, 30, ..., 380, 390 and 400. For each experiment, the accuracy rate of the prediction is the average value of the 20 iterations. The experimental results are shown in Fig. 22
                           .


                           Fig. 22 shows that the prediction accuracy of the improved CBR and O-SVM is gradually improved as the scale of the training QoS data increased. When the scale of the training QoS data is in [10, 140], the prediction accuracy of the improved CBR is higher than that of the O-SVM. This is results occurs because when the scale of the training QoS data is small, the O-SVM cannot obtain sufficient training. Therefore, the prediction accuracy of the O-SVM is lower. When the scale of the training QoS data is in [140, 240], the prediction accuracy of the O-SVM is greater than that of the improved CBR. This difference occurs because that when the scale of the training QoS data is large, the O-SVM can obtain sufficient information and can be trained fully. So it can exert its nonlinear simulation advantage, making the prediction accuracy greater than that of the improved CBR. When the scale of the training QoS data is larger than 300, the prediction accuracy of the O-SVM and the improved CBR are approximately the same; and when the scale of the training QoS data is greater than 300, the variation between the prediction accuracies of the two QoS prediction methods is small.

The running times of the two QoS prediction methods are presented in Fig. 23
                           . Fig. 23 shows that the prediction speed of the improved CBR was faster than that of the O-SVM, particularly when the scale of the training QoS data increased.

Therefore, from the above experimental results, we conclude that when the scale of the training QoS data is in [10, 140], the performance of the improved CBR is better than that of the O-SVM. When the scale of the training QoS data is in [140, 240], the prediction accuracy of the O-SVM is better than that of the improved CBR, but the prediction speed of O-SVM is slower than that of the improved CBR. When the scale of the training QoS data is greater than 300, the prediction accuracy of the two methods are approximately the same, but the prediction speed of the improved CBR is faster than that of the O-SVM.

From these experimental results, we can conclude that each QoS prediction method has its own advantages and disadvantages. Moreover, there are many dynamic environmental factors; it is difficult to find a single QoS prediction method that can work well in different QoS prediction situations. Therefore, in our future work, we will conduct further study of QoS adaptive prediction and provide a QoS adaptive prediction model that can schedule the most appropriate QoS methods for the current QoS prediction situation.

QoS-aware Web service composition is an active research issue in Service Computing and Cloud Computing fields, and attracting many researchers from industry and academia. Many studies have been performed on this problem, but dynamically constructing reliable composite services remains an open issue. For this problem, unlike existing solutions that model the QoS-aware service composition problem as a conventional combinatorial optimization problem, this paper provides a new two-stage approach for reliable dynamic Web service composition. In the first stage, in order to reduce the number of candidate services and improve the effectiveness of service composition, the top K service composition schemes are found, and component services of these schemes are filtered out and selected as the candidate services for service dynamic composition. Then, to increase the flexibility of service dynamic composition and to integrate QoS prediction into the service dynamic composition process, this paper transforms the problem of QoS-aware service composition to a local optimization problem by decomposing global QoS constraints into a set of local constraints. In the second stage, during the execution of the service composition workflow, the QoS of each candidate service is predicted, and the best services that can satisfy local constraints are selected for each task. Finally, experimental results show that our approach is the feasible and effective for reliable dynamic Web service composition.

In the future work, we will continue to do the following deep research: (1) study the performance of CGA, and try to propose a new swarm intelligent algorithm which simulate the learning process of human society; (2) study how to decompose the global QoS constraints adaptively; and (3) study how to predict Web service QoS adaptively and propose a QoS adaptive prediction model that can schedule the most appropriate QoS prediction method according to the real-time situation. Moreover, we are planning to verify this two-stage service dynamic composition method in a real cloud-computing platform and continue to improve it.

@&#ACKNOWLEDGMENTS@&#

This work is supported byThe National Natural Science Foundation Fund China (nos. 61300124, 61472106, and 61403128), Major projects of science and technology in Shandong Province(2015ZDXX0201B02), Basis and frontier of Henan Province (152300410212), Soft science research project of Henan Province(152400410513), Zhengzhou leading talent project(131PLJRC645), and Henan Polytechnic University Youth Fund Project(Q2014-09). The authors would like to thank the anonymous reviewers for their valuable feedback on this work.

@&#REFERENCES@&#

