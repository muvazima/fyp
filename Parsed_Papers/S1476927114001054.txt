@&#MAIN-TITLE@&#newDNA-Prot: Prediction of DNA-binding proteins by employing support vector machine and a comprehensive sequence representation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Give a comprehensive sequence representation.


                        
                        
                           
                           Establish our prediction model basing on support vector machine classifier.


                        
                        
                           
                           Compared with the relevant prediction methods in two independent test datasets.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

DNA-binding proteins

Features

Feature selection methods

SVM

ROC

@&#ABSTRACT@&#


               
               
                  Identification of DNA-binding proteins is essential in studying cellular activities as the DNA-binding proteins play a pivotal role in gene regulation. In this study, we propose newDNA-Prot, a DNA-binding protein predictor that employs support vector machine classifier and a comprehensive feature representation. The sequence representation are categorized into 6 groups: primary sequence based, evolutionary profile based, predicted secondary structure based, predicted relative solvent accessibility based, physicochemical property based and biological function based features. The mRMR, wrapper and two-stage feature selection methods are employed for removing irrelevant features and reducing redundant features. Experiments demonstrate that the two-stage method performs better than the mRMR and wrapper methods. We also perform a statistical analysis on the selected features and results show that more than 95% of the selected features are statistically significant and they cover all 6 feature groups. The newDNA-Prot method is compared with several state of the art algorithms, including iDNA-Prot, DNAbinder and DNA-Prot. The results demonstrate that newDNA-Prot method outperforms the iDNA-Prot, DNAbinder and DNA-Prot methods. More specific, newDNA-Prot improves the runner-up method, DNA-Prot for around 10% on several evaluation measures. The proposed newDNA-Prot method is available at http://sourceforge.net/projects/newdnaprot/
                  
               
            

@&#INTRODUCTION@&#

DNA-binding proteins are functional molecules in a cell and play an important role in a variety of biological processes, i.e., transcription regulation, DNA replication, DNA packaging, DNA repair and DNA rearrangement (Gao and Skolnick, 2009). Moreover, proteins that interact with specific DNA sequences may be a potential therapeutics for genetic diseases. At present, both experimental and computational techniques have been developed for identification of the DNA-protein interactions. Although, the experimental techniques, including filter binding assays (Cajone et al., 1989), ChIP-chip (Buck and Lieb, 2004), genetic analysis (Freeman et al., 1995) and X-ray crystallography (Chou et al., 2003) provide atomic-level perspective on DNA-protein interaction, they are time-consuming and expensive. Therefore, there is an urgent need to develop computational methods that identify DNA-binding proteins with high success rates (Gromiha and Nagarajan, 2013). Presently, the in silico methods are mainly categorized into two class: methods based on protein structures (Ahmad and Sarai, 2004; Zhao et al., 2010; Tjiong and Zhao, 2007; Stawiski et al., 2003; Szilagyi and Skolnick, 2006) and methods based on primary sequence (Cai and Lin, 2003; Robert and Hui, 2010; Huang et al., 2011; Kumar et al., 2007; Shao et al., 2009; Lin et al., 2011). Although, the structure-based methods achieve higher accuracy when compared with the sequence-based techniques, they are not applicable for high-throughput annotation of DNA-binding proteins as structures are only determined for a small fraction of known proteins. Since it is widely recognized that primary sequence determines the tertiary structure which further determines the function of a protein (Cai and Doig, 2004), majority of the computational methods took primary sequence as the only input. The sequence-based methods mainly include two steps: firstly, transforms the primary sequence into a fixed number of numerical features, i.e., the composition of the amino acids; second, choose a machine learning algorithm and build a computation model for prediction. Previously, dozens of machine-learning algorithms such as support vector machine (SVM) (Zhao et al., 2010; Tjiong and Zhao, 2007; Brown and Akutsu, 2009; Wang et al., 2010; Xiong et al., 2011; Zou et al., 2013), artificial neural network (ANN) (Ahmad et al., 2004; Keil et al., 2004; Ahmad et al., 2009), random forest (Cai and Lin, 2003; Nimrod et al., 2010; Wang et al., 2009), naive Bayes (Yan et al., 2006) and nearest neighbor (Qian et al., 2006) have been proposed which performs prediction of DNA-binding proteins. Among these algorithms, the SVM is especially widely implemented.

The performance of SVM is largely dependent on the quality of the features (Liu et al., 2008). Although, plenty of feature representation and selection methods were proposed for protein sequence (Fang et al., 2008; Chou, 2011; Yuan et al., 2010; Song et al., 2008) and these methods were systematically surveyed (Nanni et al., 2010; Zhang et al., 2005), the underlying principle of protein-DNA interaction is still largely unknown. To this end, we propose a comprehensive feature representation, including the sequence information, evolutionary profiles, predicted secondary structural, predict relative solvent accessibility (RSA) information, physicochemical properties, and biological function information. Moreover, we employ three feature selection methods, mRMR, wrapper and two-stage (mRMR and wrapper), to remove the irrelevant features and reduce redundancy among the features. The proposed method outperforms existing sequence-based methods including the DNAbinder (Kumar et al., 2007), iDNA-Prot (Lin et al., 2011), DNA-Prot (Kumar et al., 2009) which either have a web server or provide standalone program. The framework of the proposed DNA-binding predictor is given in Fig. 1
                     .

The training set, namely DNAdset, contains 231 DNA-binding and 231 non-binding protein chains or domains which were obtained from a union of datasets used in previously related studies (Zou et al., 2013; Gao et al., 2012; Fang et al., 2008). By employing the CD-HIT program (Huang et al., 2010), any pair of the protein chains have a sequence similarity less than 40%.

Additionally, we build an independent test set, namely DNAiset, to perform an independent evaluation of the predictive model. The test set includes 97 DNA-binding proteins and 192 non-DNA binding proteins. The DNA-binding proteins are culled from PDB by keyword searching (released on 2014-06–01 and later) while the non-binding proteins were culled by Lin et al. (2011). We employ the CD-HIT (Wang and Dunbrack, 2003 
                        Huang et al., 2010) program to remove the sequence similarity between DNAiset and DNAdset. Any sequence from DNAiset has a sequence similarity less than 30% to a sequence from DNAdset.

Many machine learning algorithms perform better when the number of positive samples is comparable to the number of negative samples. To this end, the numbers of DNA-binding proteins and non-binding proteins are equivalent in DNAdset and comparable in DNAiset. However, in real situation, the fraction of DNA-binding proteins is small when compared with the fraction of non-binding proteins. To this end, DNArset, which simulates the ratio between DNA-binding proteins and non-binding proteins in cellular environment, is created. DNArset contains 97 DNA-binding proteins taken from DNAiset and 1500 non-binding proteins culled by Kumar et al. (2007).

The performance of a computational model is largely dependent on the quality of the feature representation (Chou, 2011; Brameier et al., 2006). In this study, we generate six groups of features that are derived from primary sequence, evolutionary information, predicted secondary structure, predicted RSA values (Faraggi et al., 2012), physicochemical properties and functional information.

This group of features is directly calculated from primary sequence.
                              
                                 •
                                 SeqLen is the length of a sequence (1 feature).

Composition vector: CV
                                       i
                                    
                                    =AA
                                       i
                                    /SeqLen represents the percentage of the ith type of AA in the sequence (20 features).

The first and second order composition moment vector:
                                       
                                          
                                             
                                                CMV
                                             
                                             
                                                i
                                             
                                             
                                                k
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      ,
                                                      j
                                                      =
                                                      1
                                                   
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      n
                                                   
                                                   
                                                      i
                                                      j
                                                   
                                                   
                                                      k
                                                   
                                                
                                             
                                          
                                          /
                                          
                                             
                                                Π
                                             
                                             
                                                d
                                                =
                                                1
                                             
                                             
                                                k
                                             
                                          
                                          
                                             (
                                             N
                                             −
                                             k
                                             )
                                          
                                       
                                     , where nij
                                     represents the jth position of the ith type of AA, ni
                                     is the frequency of ith type of AA in the sequence, and k
                                    =1, 2 is the order of the CMV.

For an input protein sequence, its position-specific scoring matrix (PSSM) profile can be calculated from alignment profile generated by PSI-BLAST (Altschul et al., 1997). PSSM score indicates the conservation of a given AA position in the query sequence among its homologues (Wu and Zhang, 2008). Since functional sites, including DNA and RNA-binding residues, are more conserved than other residues, it was proved that PSSM profile are valuable in prediction of DNA-protein interactions (Kumar et al., 2007; Ahmad and Sarai, 2005).

The PSI-BLAST program generates two position specific scoring matrices, which are conservation scores and probability of occurrence of a given AA respectively. The two matrices are denoted as PSSMcons
                              lm
                            and PSSMprob
                              lm
                            respectively, where l
                           =1,2,…,SeqLen represents the position in the sequence and m
                           =1,2,…,20 denotes the 20 substitution positions that correspond to the 20 AA types.
                              
                                 •
                                 Ach_CS_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    if AA(l)=AA
                                       i
                                    , then PSSMcons
                                       li
                                     else 0/SeqLen, sum of all normalized PSSMcons
                                       lm
                                     values (“Ach_CS” stands for achieved conservation scores), where l includes only positions of AA
                                       i
                                     and m
                                    =AA
                                       i
                                     (20 features). The other 2 features are the sum of Ach_CS_{AA
                                       i
                                    } and the sum of Ach_CS_{AA
                                       i
                                    } if AA locates on the solvent surface.

Max_CS_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    if AA(l)=AA
                                       i
                                    , then 
                                       
                                          
                                             
                                                max
                                                ⁡
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                20
                                             
                                          
                                       
                                    (PSSMcons
                                       li
                                    ) else 0/SeqLen sum of maximal, over m, PSSMcons
                                       lm
                                     values, where l includes only positions of AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of Max_CS_{AA
                                       i
                                    } and the sum of Max_CS_{AA
                                       i
                                    } if AA locates on the solvent surface.

Max–Ach_CS_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    if AA(l)=AA
                                       i
                                    , then [
                                       
                                          
                                             
                                                max
                                                ⁡
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                20
                                             
                                          
                                       
                                    (PSSMcons
                                       li
                                    )−PSSMcons
                                       li
                                    ] else 0/SeqLen, sum of differences between maximal PSSMcons
                                       lm
                                     and PSSMcons
                                       li
                                     values where l includes only positions of AA
                                       i
                                     and i
                                    =AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of Max−Ach_CS_{AA
                                       i
                                    } and the sum of Max–Ach_CS_{AA
                                       i
                                    } if AA locates on the solvent surface.

Ach_Prob_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    if AA(l)=AA
                                       i
                                     then PSSMBprob
                                       li
                                     else 0/SeqLen, sum of all normalized PSSMprob
                                       lm
                                     values, where l includes only positions of AA
                                       i
                                     and i
                                    =AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of Ach_Prob_{AA
                                       i
                                    } and the sum of Ach_Prob_{AA
                                       i
                                    } if AA locates on the solvent surface.

Max_Prob_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    if AA(l)=AA
                                       i
                                     then 
                                       
                                          
                                             
                                                max
                                                ⁡
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                20
                                             
                                          
                                       
                                     (PSSMprob
                                       li
                                    ) else 0/SeqLen, sum of maximal, over m, PSSMprob
                                       lm
                                     values, where l includes only positions of AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of Max_Prob_{AA
                                       i
                                    } and the sum of Max_Prob_{AA
                                       i
                                    } if AA locates on the solvent surface.

Max–Ach_prob_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    if AA(l)=then [
                                       
                                          
                                             
                                                max
                                                ⁡
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                20
                                             
                                          
                                       
                                    (PSSMcons
                                       li
                                    )−PSSMcons
                                       li
                                    ] else 0/SeqLen, sum of differences between maximal PSSMprob
                                       lm
                                     and PSSMprob
                                       li
                                     values where l includes only positions of AA
                                       i
                                     and i
                                    =AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of Max–Ach_{AA
                                       i
                                    }and the sum of Max−Ach_{AA
                                       i
                                    } if AA locates on the solvent surface.

CSSeq_{AA
                                       i
                                    }=SeqLen, sum of normalized PSSMcons
                                       lm
                                     values where l
                                    =1,2,…,SeqLen and m
                                    =AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of CSSeq_{AA
                                       i
                                    } and the sum of CSSeq_{AA
                                       i
                                    } if AA locates on the solvent surface.

Seq_Prob_{AA
                                       i
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    PSSMprob
                                       li
                                    /SeqLen, sum of normalized PSSMcons
                                       lm
                                     values where l
                                    =1,2,…,SeqLen and m
                                    =AA
                                       i
                                    , divided by the sequence length (20 features). The other 2 features are the sum of Seq_Prob_{AA
                                       i
                                    } and the sum of Seq_Prob_{AA
                                       i
                                    } if AA locates on the solvent surface.

Ent_{AA
                                       i
                                    }=
                                       
                                          −
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                       
                                    [PSSMprob
                                       li
                                    
                                    ﻿
                                    ×log2﻿(PSSMprob
                                       li
                                    )], entropy of PSSMprob
                                       lm
                                     values, for l
                                    =1,2,…,SeqLen and m
                                    =AA
                                       i
                                     (20 features). The other 22 features contain the average entropy per position in sequence (which is equivalent to conservation) (1 feature), the average entropy per position in sequence if all AA locates on the solvent surface and average entropy per position in sequence for each AA type (20 features).

Secondary structure is generated by the PSIPred program (McGuffin et al., 2000). PSIPred were successfully integrated into a number of computational methods that predict structural properties of proteins, i.e., structural class (Kurgan et al., 2008), beta-turns (Zheng and Kurgan, 2008), residue depth (Zhang et al., 2008), prediction fold (Reinhardt and Eisenberg, 2004) and contact orders (Song and Burrage, 2006).
                              
                                 •
                                 Ach_Prob_{SS
                                       n
                                    }=
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                l
                                                =
                                                1
                                             
                                             
                                                SeqLen
                                             
                                          
                                          ⁡
                                       
                                    if AA(l)=SS
                                       n
                                     then PM
                                       li
                                     else 0/SeqLen, sum of normalized PM
                                       lm
                                     values (which represents the probability matrix (PM) by predict secondary structure), where l includes only positions of SS
                                       n
                                    , which SS
                                       n
                                    
                                    ={C,H,E}, divided by the sequence length and m
                                    =SS
                                       n
                                     (3 features).

Content_{SS
                                       n
                                    }=count (AA1:AA1 predicted as SS
                                       n
                                    )/SeqLen, the number of residues predicted as SS
                                       n
                                     where l
                                    =1,2,…,SeqLen, divided by the sequence length (3 features). The other 3 features are generated by AAs on the surface using this formula, which represent content of AAs related to binding.

SegCount_{E,H}_L{L
                                    
                                       i
                                    }=count (SEG:SEG(SS
                                       n
                                    ) AND length(SEG≥
                                    Li
                                    )/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      E
                                                      ,
                                                      H
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count (SEG:SEG(SS)), the number of helix or strand segments which contain at least Li
                                    
                                    =2,3,…,20 AAs divided by the total number of helix and strand segments in the input protein chain (38 features)

SegCount_C_L{L
                                    
                                       i
                                    }=count (SEG:SEG(SS
                                       n
                                    ) AND length(SEG≥
                                    Li
                                    )/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count (SEG:SEG(SS)), the number of coils which contain at least Li
                                    
                                    =2,3,…,20 AAs divided by the number of all segments in a protein (19 features).

SegCount_{E,H}_P{P
                                    
                                       i
                                    }=count (SEG:SEG(SS
                                       n
                                    ) AND length(SEG≥P
                                       i
                                    
                                    ﻿
                                    ×SegLen)/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      E
                                                      ,
                                                      H
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of helix or strand segments which contain at least P
                                       i
                                    AAs where Pi
                                    
                                    =2,4,…,10% of the sequence length, divided by the total number of helix and strand segments in the input protein chain (10 features).

SegCount_C_P{P
                                    
                                       i
                                    }=count (SEG:SEG(SS
                                       n
                                    ) AND length(SEG≥P
                                       i
                                    
                                    ﻿
                                    ×SegLen)/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of coil segments which contain at least P
                                       i
                                    AAs where Pi
                                    
                                    =2,4,…,10% of the sequence length, divided by the number of all segments (5 features).

NormSegCount_{SS
                                       n
                                    }=count (SEG:SEG(SS
                                       n
                                    ))/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the total number of SS
                                       n
                                     segments divided by the total number of all secondary structure segments in the input protein chains (3 features).

MaxSegCount_{SS
                                       n
                                    }=maxLen(SEG(SS
                                       n
                                    )), the maximal SS
                                       n
                                     segment length (3 features).

NormMaxSegCount_{SS
                                       n
                                    }=maxLen(SEG:SEG(SS
                                       n
                                    ))/SeqLen, the maximal SS
                                       n
                                    , the maximal SS
                                       n
                                     segment length divided by the sequence length (3 features).

AvgSegCount_{SS
                                       n
                                    }=avgLen(SEG(SS
                                       n
                                    )), the average SS
                                       n
                                     segment length (3 features).

NormAvgSegLength_{SS
                                       n
                                    }=avgLen(SEG:SEG(SS
                                       n
                                    ))/SeqLen, the average SS
                                       n
                                     segment length divided by the sequence length (3 features).

HH=count(HH), the number of helix–coil–helix motifs divided by the total number of the secondary structure segments in a protein (1 feature).

EE=count(EE), the number of strand–coil–strand motifs divided by the total number of the secondary structure segments in a protein (1 feature).

HE=count(HE)+count(EH), the number of strand–coil–helix or helix–coil–strand motifs by the total number of the secondary structure segments in a protein (1 feature).

{HH,HE,EE}−L{L
                                       i
                                    }=count({HH,HE,EE}:LEN(Coil)≥L
                                       i
                                    )/
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                SS
                                                ∈
                                                
                                                   {
                                                   H
                                                   ,
                                                   E
                                                   ,
                                                   C
                                                   }
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of helix–coil–helix, helix–coil–strand/strand–coil–helix, or strand–coil–strand motifs which include at least Li
                                    
                                    =2,3,…,20 AAs residues in the middle coil, divided by the total number of the secondary structure segments in a protein (57 features).

{HH,HE,EE}−L{P
                                    
                                       i
                                    }=count({HH,HE,EE}:LEN(Coil)≥
                                    P
                                    
                                       i
                                    
                                    ﻿
                                    ×SeqLen)/
                                       
                                          
                                             
                                                ∑
                                             
                                             
                                                SS
                                                ∈
                                                
                                                   {
                                                   H
                                                   ,
                                                   E
                                                   ,
                                                   C
                                                   }
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of helix–coil–helix, helix–coil–strand/strand–coil–helix, or strand–coil–strand motifs which include at least Pi
                                    
                                    =2,3,…,10% of a sequence length residues in the middle coil, divided by the total number of the secondary structure segments in a protein (15 features).

MaxHCH=max(HC..H:count(H)), the maximal number of helices among all helix–coil–helix–coil…coil–helix motifs, i.e., the maximal number of helix segments separated only by coils (1 feature).

MaxECE=max(EC..E:count(E)), the maximal number of helices among all strand–coil–strand–coil…coil–strand motifs, i.e., the maximal number of strand segments separated only by coils (1 feature).

AvgHCH=avg(HC..(H))/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      
                                                         
                                                            SS
                                                         
                                                      
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the average number of helices in all helix–coil–helix–coil…coil–helix motifs, divided by the total number of the secondary structure segments in a protein (1 feature).

AvgECE=avg(EC..(E:count:(E))/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      
                                                         
                                                            SS
                                                         
                                                      
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the average number of helices in all strand–coil–strand–coil…coil–strand motifs, divided by the total number of the secondary structure segments in a protein (1 feature).

HCH_L{L
                                    
                                       i
                                    }=count(HC..H:count(H)≥
                                    L
                                    
                                       i
                                    )/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of helix–coil–helix–coil…coil–helix motifs with more than Li
                                    
                                    =1,2,…,20 helices, divided by the total number of the secondary structure segments (19 features).

HCH_P{P
                                    
                                       i
                                    }=count(HC..H:count(H)≥
                                    P
                                    
                                       i
                                    
                                    ﻿
                                    ×SeqLen)/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of helix–coil–helix–coil…coil–helix motifs with more than Pi
                                    
                                    =2,4,…,10 of all helics in a protein, divided by the total number of the secondary structure segments (5 features).

ECE_L{L
                                    
                                       i
                                    }
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of strand–coil–strand–coil…coil-strand motifs with more than Li
                                    
                                    =1,2,…,20 strands, divided by the total number of the secondary structure segments (19 features).

ECE_P{P
                                    
                                       i
                                    }=count(EC..E:count(E)≥P
                                    
                                       i
                                    
                                    ×SeqLen)/
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      SS
                                                      ∈
                                                      {
                                                      H
                                                      ,
                                                      E
                                                      ,
                                                      C
                                                      }
                                                   
                                                
                                             
                                          
                                       
                                    count(SEG:SEG(SS)), the number of strand–coil–strand–coil…coil–strand motifs with more than Pi
                                    
                                    =2,4,…,10 of all helics in a protein, divided by the total number of the secondary structure segments (5 features).


                           
                              
                                 •
                                 Average RSA of the residues with AA type (20 features).

Average RSA of the residues with secondary structure type {C,H,E} (3 features).

It is widely recognized that physicochemical properties of AAs play an important role in protein folding and protein-DNA interaction. Experimental and theoretical studies have proposed a wide variety of properties for AAs. Even for the same property, it might be assigned to different values by different studies. Based on the analysis of Huang et al. (2010), we include nine physicochemical indices, see in Table 1
                           . Several physicochemical properties in Table 1 have been employed in prediction of protein-DNA interaction (Shao et al., 2009; Fang et al., 2008) while several other properties, i.e., the flexibility property, are utilized for prediction of DNA-binding proteins for the first time. The correlation between protein flexibility and biological function of proteins has demonstrated a linkage between protein-DNA interaction and flexibility of the corresponding domain (Gryk et al., 1996).
                              
                                 •
                                 
                                    
                                       
                                          
                                             
                                                K
                                             
                                             
                                                α
                                             
                                          
                                          =
                                          
                                             
                                                1
                                             
                                             
                                                N
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      N
                                                   
                                                
                                                
                                                   
                                                      α
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                       
                                     where α represents the corresponding physicochemical AA index; charge, pK-C, pK-(COOH), polarity (2), pK-N, pK-a (RCOOH) and normalized index were used, and these indexes values listed in the Table 1 (8 features).


                                    
                                       
                                          
                                             
                                                A
                                             
                                             
                                                n
                                             
                                             
                                                α
                                             
                                          
                                          =
                                          
                                             
                                                1
                                             
                                             
                                                N
                                                −
                                                n
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      N
                                                      −
                                                      n
                                                   
                                                
                                                
                                                   
                                                      α
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          
                                             
                                                α
                                             
                                             
                                                i
                                                +
                                                n
                                             
                                          
                                       
                                    , where α defines the corresponding physicochemical AA index; hydrophobicity index (4) n
                                    =1, 2,...,6, flexibility (2) n
                                    =1, 2,...,6, Secondary structure (4) n
                                    =1, 2,...,6, and solvent accessibility (5) n
                                    =1, 2,...,6 were used (90 features).


                                    
                                       
                                          
                                             
                                                Acum
                                             
                                             
                                                n
                                             
                                             
                                                α
                                             
                                          
                                          =
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   
                                                      N
                                                      −
                                                      n
                                                   
                                                
                                                
                                                   (
                                                   
                                                      
                                                         ∑
                                                      
                                                      
                                                         j
                                                         =
                                                         1
                                                      
                                                      
                                                         i
                                                      
                                                   
                                                   
                                                      
                                                         α
                                                      
                                                      
                                                         j
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                          ×
                                          (
                                          
                                             
                                                ∑
                                             
                                             
                                                j
                                                =
                                                1
                                             
                                             
                                                i
                                                +
                                                n
                                             
                                          
                                          
                                             
                                                α
                                             
                                             
                                                j
                                             
                                          
                                          )
                                          /
                                          N
                                          −
                                          n
                                       
                                    , where α is the hydrophobicity index (4) with n
                                    =1, 2,...,6, flexibility (2) with n
                                    =1, 2,...,6, secondary structure (4) with n
                                    =1, 2,...,6, and solvent accessibility (5) with n
                                    =1, 2,...,6 (90 features).


                                    
                                       
                                          
                                             
                                                H
                                             
                                             
                                                sum
                                             
                                             
                                                a
                                             
                                          
                                          =
                                          
                                             
                                                ∑
                                             
                                             
                                                i
                                                =
                                                1
                                             
                                             
                                                N
                                             
                                          
                                          
                                             
                                                α
                                             
                                             
                                                i
                                             
                                          
                                       
                                    , where α is the hydrophobicity index (4), flexibility (2), secondary structure (4), and solvent accessibility (5) (15 features).

The last decade had witnessed a growing recognition that a large fraction of proteins are intrinsically or natively disorder proteins (Vuzman and Levy, 2012). Plenty of intrinsically (or natively) disordered proteins (IDRs) are associated with DNA-protein interactions and play a crucial role in the interactions by increasing the affinity and specificity of DNA binding (Vuzman and Levy, 2012; Zheng and Kurgan, 2008). The ability of IDRs to interact with DNA is due to the high content of charged residues in IDRs. In general, IDRs that interact with DNA are rich in positively charged residues and these residues are spatially clustered. The IUPred (Dosztanyi et al., 2005) method is employed to calculate the pairwise energy profile along the input AA sequence. The IUPred method generates a series of scores, which stands for energy values, ranging from 0 (completely ordered) to 1 (completely disordered). In order to produce the same number of features for protein sequences with varied length, we employ the CTD method, which was firstly proposed by Dubchak et al. (1995). The CTD method is widely used in prediction of protein folding class and protein function (Cai et al., 2003; Zou et al., 2013). The letter C, which is the abbreviation of composition, stands for the percentage of AAs with a certain property (such as disorder). The letter T, which is the abbreviation of transition, stands for the percentage of AAs followed by an AA with different property, i.e., an ordered residue followed by a disordered residue. The letter D, which is the abbreviation of distribution, measures the range of the first, 25, 50, 75 and 100% of the AAs with a certain property respectively. The CTD method generates 13 features for each protein sequence.

@&#PERFORMANCE EVALUATION@&#

Several quality measures, including accuracy (ACC), sensitivity, precision, specificity, F-measure, and Matthews correlation coefficient (MCC) (Baldi et al., 2000), are employed for evaluation of the proposed method. These measures are defined as follows:
                        
                           (1)
                           
                              
                                 ACC
                                 =
                                 
                                    
                                       TP+TN
                                    
                                    
                                       TP+TN+FP+FN
                                    
                                 
                                 ×
                                 100
                                 %
                                 ⁡
                              
                           
                        
                     
                     
                        
                           (2)
                           
                              
                                 Sensitivity
                                 =
                                 
                                    
                                       TP
                                    
                                    
                                       TP+FN
                                    
                                 
                                 ×
                                 100
                                 %
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 Pr
                                 ecision
                                 =
                                 
                                    
                                       TP
                                    
                                    
                                       TP+FP
                                    
                                 
                                 ×
                                 100
                                 %
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 Specificity
                                 =
                                 
                                    
                                       TN
                                    
                                    
                                       TN+FP
                                    
                                 
                                 ×
                                 100
                                 %
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 Specificity
                                 =
                                 
                                    
                                       TN
                                    
                                    
                                       TN+FP
                                    
                                 
                                 ×
                                 100
                                 %
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 MCC
                                 =
                                 
                                    
                                       TP
                                       ×
                                       TN-FP
                                       ×
                                       FN
                                    
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   TN+FN
                                                
                                                )
                                             
                                             
                                                (
                                                
                                                   TN+FP
                                                
                                                )
                                             
                                             
                                                (
                                                
                                                   TP+FN
                                                
                                                )
                                             
                                             
                                                (
                                                
                                                   TP+FP
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                                 ⁡
                              
                           
                        
                     where TP and TN are the number of correctly predicted DNA-binding and non-binding proteins, respectively, FP denotes the non-binding proteins predicted as the DNA-binding proteins, and the FN denotes DNA-binding proteins predicted as non-binding proteins. The F-measure is used to balance the sensitivity and precision (Gromiha and Yabuki, 2008). Higher values of these measures indicate better quality of predictions. The MCC value ranges between −1 and 1 and other indices range between 0 and 1. Higher value of these measures imply better predictions.

We also employ the area under the ROC curve (AUC) to evaluate the predicted probabilities. The above mentioned measures are dependent on a threshold that discretizes the predicted probabilities into positives and negatives, while the AUC takes all thresholds into consideration. Therefore, the AUC index provides more comprehensive perspective on the predictions than other measures. The AUC value ranges between 0 and 1 and higher values imply better predictions.

The generated features may be irrelevant to the prediction of DNA-binding domains and redundant with each other. To this end, we employ mRMR, wrapper and the two-stage (mRMR and wrapper) feature selection algorithms to remove the irrelevant features and reduce redundancy among the features.

The maximum relevance, minimum redundancy (mRMR) method was proposed by Peng for processing microarray data (Peng et al., 2005). The approach selects the features having maximum dependency, minimum redundancy, and maximum relevance. The redundancy and relevance are measured by mutual information defined as following:
                           
                              (7)
                              
                                 
                                    I
                                    (
                                    x
                                    ,
                                    y
                                    )
                                    =
                                    ∬
                                    
                                       p
                                       (
                                       x
                                       ,
                                       y
                                       )
                                       
                                          
                                             p
                                             (
                                             x
                                             ,
                                             y
                                             )
                                          
                                          
                                             p
                                             (
                                             x
                                             )
                                             p
                                             (
                                             y
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        where p(x), p(y) and p(x,y) are the probabilistic density functions of two variables x and y. Detailed description of the algorithm is given in (Peng et al., 2005).

The mRMR algorithm generates a feature set S in which features are arranged in certain order:
                           
                              (8)
                              
                                 
                                    S
                                    =
                                    
                                       {
                                       
                                          
                                             f
                                          
                                          
                                             1
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       
                                          
                                             f
                                          
                                          
                                             2
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       L
                                       ,
                                       
                                          
                                             f
                                          
                                          
                                             h
                                          
                                          
                                             ′
                                          
                                       
                                       ,
                                       K
                                       ,
                                       
                                          
                                             f
                                          
                                          
                                             N
                                          
                                          
                                             ′
                                          
                                       
                                       }
                                    
                                 
                              
                           
                        
                     

The wrapper-based method convolves with a classifier (Kohavi and John, 1997). The features are first sorted by the absolute value of biserial correlation coefficient (BCC), which is defined as:
                           
                              (9)
                              
                                 
                                    BCC
                                    =
                                    (
                                    
                                       
                                          M
                                       
                                       
                                          b
                                       
                                    
                                    −
                                    
                                       
                                          M
                                       
                                       
                                          
                                             
                                                nb
                                             
                                          
                                       
                                    
                                    )
                                    ×
                                    sqrt
                                    (
                                    nb
                                    ×
                                    
                                       
                                          n
                                       
                                       
                                          
                                             
                                                nb
                                             
                                          
                                       
                                    
                                    /
                                    n
                                    )
                                    /
                                    (
                                    stdev
                                    )
                                 
                              
                           
                        where Mb
                         and M
                        nb are the mean values of the feature values of DNA-binding and non DNA-binding chains, respectively, stdev is the standard deviation of the feature, nb and n
                        nb are the numbers of DNA-binding and non DNA-binding chains, respectively, and n is the total number of chains.

Next, we start with a single feature that provides the highest MCC based on the 5-fold cross validation on training set. The remaining features are added in the order determined by BCC. A feature is retained if the addition of the feature improves MCC and discarded otherwise. After the completion of feature selection, we optimize the parameters of the classification model. The wrapper-based feature selection method was employed in a number of related studies (Chen et al., 2011; Mizianty et al., 2010; Mizianty and Kurgan, 2011; Gao et al., 2012).

mRMR method is also called filter method (Langley, 1994) as it identifies a subset of the features and ignore the remaining features. In the two-stage method, we first use mRMR-based feature selection method, which identifies a small set of candidate features. In this study, the mRMR-based method select 300 candidate features out of 781 features, which constitute the complete feature representation.

In the second stage, the wrapper-based method is employed to identify a compact feature subset from the candidate feature set. By adding the first stage, the computational complexity of wrapper-based method is reduced and predictive performance is improved. After completion of feature selection, we optimize the parameters of the classification model.

@&#RESULTS AND DISCUSSION@&#

The mRMR program can be downloaded from http://penglab.janelia.org/proj/mRMR/#c ++. The mRMR program ranks all features and generates the top 200, 300, 400 and 500 candidate features from the initial 781 features for DNAdset (462 samples). Features with higher mRMR score implies better predictive performance. The performance by employing different number of features is compared in Table 2
                        . We note that employing top 300 features results in better predictions. This model provides high values for all evaluation indices, i.e., 0.9536 for AUC, 0.9091 for ACC, 0.8185 for MCC, 0.8961 for sensitivity, 0.9221 for specificity, 0.92 for precision and 0.9011 for F-measure.

We also assess the performance of the prediction models by employing different feature selection methods, including the mRMR-based, wrapper-based and the two-stage method. Table 3 
                         demonstrates that the model that integrates two-stage method generates better predictions. The model with the two-stage method achieves higher values for all indices, i.e., 0.9654 for AUC, 0.9221 for ACC, 0.8441 for MCC, 0.9091 for sensitivity, 0.9351 for specificity, 0.9333 for precision and 0.9211 for F-measure. The results demonstrate that the combination of the mRMR-based and wrapper-based methods enhance the performance of individual feature selection method.

We first investigate statistical significance of the differences between the feature values of DNA-binding and feature values of non-binding proteins on DNAdset. The two-sided t test is employed and the P value is the probability that the difference between feature values of DNA-binding and non-binding groups occurs by a random chance. We note that at a significance level of 0.05, 118 out of 128 (118/128=92.2%) features have P values less than 0.05. Therefore, the difference between feature values of DNA-binding and non-binding groups are statistically significant for 118 features. The results prove that majority of the selected features have statistically significant differences between the DNA-binding and non-binding proteins.

We also perform an analysis on the selected features, see Table 4
                        . It should be emphasized that the selected features cover all 6 feature groups, which indicates that all considered feature groups contribute to prediction of DNA-protein interactions. The largest group of the selected 128 features is PM+RA, of which 48 features are selected by the two-stage feature selection method. It demonstrates that the evolutionary information generated by PSI-BLAST plays a pivotal role in prediction of DNA-binding proteins. The second largest group, AA sequence length and AA composition group, consists of 28 selected features. The remaining selected features includes 24 features calculated from predicted secondary structure, 18 features calculated from the physiochemical properties, 7 features are calculated from predicted RSA values and 3 features are calculated from predicted disordered information. The results demonstrate that the selected 128 features are valuable in prediction of DNA-binding proteins.

We also assess the performance of predictive models by employing individual feature groups. The ROC curves by utilizing individual feature groups are given in Fig. 2
                        . The corresponding AUC values are given in Table 5
                        . The AUC values for each of the 6 groups are above 0.5. We note that the PM+RA group provides higher AUC values than other groups which is likely because the two-stage method selects more features for the PM+RA group than other groups.

The proposed method is also compared with several existing methods (DNAbinder (Kumar et al., 2007), iDNA-Prot (Lin et al., 2011), and DNA-Prot (Kumar et al., 2009)). All methods are evaluated on an independent test set, namely DNAiset, which contains 97 DNA-binding proteins and 192 non-binding proteins. Table 6
                         demonstrates the predictive performance of our method and the competing methods.

As shown in Table 6, our method provides higher accuracy, AUC value, MCC and F-measure than the DNAbinder and DNA-Prot methods. However, the iDNA-Prot (Lin et al., 2011) generates higher accuracy of 0.889, MCC of 0.752, specificity of 1.000, and F-measure of 0.795 than our method. The better performance of iDNA-Prot is due to the fact that a number of sequences in the test DNAiset have more than 35% sequence similarity to the sequences of the training set of S
                        Bench, which was used to build the classification model of iDNA-Prot. Therefore, the performance of the iDNA-Prot method should be overestimated. The DNAbinder method is developed by Kumar et al. (2007) and can be accessed at www.imtech.res.in/raghava/dnabinder/. The method was introduced by Kumar et al. (2007). DNAbinder employs SVM classifier and evolutionary information in the form of PSSM profiles. DNAbinder identifies DNA-binding proteins at a success rate of 70.9% in the DNAiset. The DNA-Prot method was also introduced by Kumar et al. (2009). This method integrates random forest classifier and features calculated from primary sequence. The DNA-Prot method achieves a success rate of 82.4% in prediction of DNA-binding proteins in DNAiset.

We also compare our newDNA-Prot method with iDNA-Prot, DNAbinder and DNA-Prot in DNArset, see Table 7
                        . As discussed in Section 2, DNArset simulates the ration between DNA-binding and non-binding proteins in cellular environment and contains more non-binding proteins than DNAiset. Table 7 demonstrates that our method achieves higher ACC, MCC, F-measure and specificity than the iDNA-Prot, DNAbinder and DNA-Prot methods. Specifically, newDNA-Prot improves on the runner-up method DNA-Prot for (0.84−0.735)/0.735=14.3% for ACC, (0.166−0.152)/0.152=9.2% for MCC, (0.222−0.197)/0.197=12.7% for F-measure and (0.871−0.747)/0.747=16.6% for specificity.

These results demonstrate, that using our comprehensive protein sequence information and two-stage feature selection method can better predict the DNA-binding proteins with SVM model than some previous studies.

@&#CONCLUSIONS@&#

DNA-binding proteins play an important role in a variety of biological processes. Therefore, development of computational method that identifies DNA-binding proteins at high success rate is valuable. This study proposes a novel DNA-binding protein predictor that integrates a comprehensive set of feature descriptors, including primary sequence based, evolutionary profile based, predicted secondary structure based, predicted relative solvent accessibility based, physicochemical property based and biological function based features. To the best of our knowledge, the predicted secondary structure based, predicted relative solvent accessibility based and biological function based features are first employed in prediction of DNA-binding proteins. We have also assessed the performance of three feature selection methods, i.e., the mRMR, wrapper and two-stage methods in prediction of DNA-binding proteins. Results demonstrate that the two-stage method performs better than the other two methods. Statistical analysis shows that more than 95% of the selected features are statistically significant and the selected features cover all 6 feature groups. This implies all 6 feature groups contribute to the prediction of DNA-binding proteins. The proposed newDNA-Prot method is compared with three state of the art algorithms, DNAbinder, DNA-Prot and iDNA-Prot on two independent datasets. The results show that the newDNA-Prot method outperforms existing methods.

@&#ACKNOWLEDGEMENTS@&#

This work is supported by the National Natural Science Foundation of China (Grant no. 11201334), Science and Technology Commission of Tianjin Municipality (Grant no. 12JCYBJC31900) to KC. JRuan group is supported by Natural Science Fund of China (NSFC) (10671100, 68075049 and 31050110432) and the aid of a grant (No. 104519-010) from the International Development Research Center, Ottawa, Canada.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.compbiolchem.2014.09.002.

The following are Supplementary data to this article:
                        
                           
                        
                     
                  

@&#REFERENCES@&#

