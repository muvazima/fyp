@&#MAIN-TITLE@&#3D anatomical shape atlas construction using mesh quality preserved deformable models

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Propose a robust framework to model shape and create shape atlas.


                        
                        
                           
                           It improves AFDM by incorporating an energy term to preserve shape quality.


                        
                        
                           
                           The results are generally smooth without significantly sacrificing shape details.


                        
                        
                           
                           Using this approach, we solve several diverse and challenging tasks.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Shape atlas

Shape modeling

Adaptive focus deformable models

Detail preserved smoothing

Shape registration

Shape statistics

@&#ABSTRACT@&#


               
               
                  3D anatomical shape atlas construction has been extensively studied in medical image analysis research, owing to its importance in model-based image segmentation, longitudinal studies and populational statistical analysis, etc. Among multiple steps of 3D shape atlas construction, establishing anatomical correspondences across subjects, i.e., surface registration, is probably the most critical but challenging one. Adaptive focus deformable model (AFDM) [1] was proposed to tackle this problem by exploiting cross-scale geometry characteristics of 3D anatomy surfaces. Although the effectiveness of AFDM has been proved in various studies, its performance is highly dependent on the quality of 3D surface meshes, which often degrades along with the iterations of deformable surface registration (the process of correspondence matching). In this paper, we propose a new framework for 3D anatomical shape atlas construction. Our method aims to robustly establish correspondences across different subjects and simultaneously generate high-quality surface meshes without removing shape details. Mathematically, a new energy term is embedded into the original energy function of AFDM to preserve surface mesh qualities during deformable surface matching. More specifically, we employ the Laplacian representation to encode shape details and smoothness constraints. An expectation–maximization style algorithm is designed to optimize multiple energy terms alternatively until convergence. We demonstrate the performance of our method via a set of diverse applications, including a population of sparse cardiac MRI slices with 2D labels, 3D high resolution CT cardiac images and rodent brain MRIs with multiple structures. The constructed shape atlases exhibit good mesh qualities and preserve fine shape details. The constructed shape atlases can further benefit other research topics such as segmentation and statistical analysis.
               
            

@&#INTRODUCTION@&#

3D anatomical shape atlas is an important component in various biomedical studies, e.g., the neuroanatomical shape complex atlas [2] and the cardiac atlas [3]. In short, a 3D shape atlas provides reference of a population of shapes (usually of the same organ/anatomical structure) in a statistical way. These shape statistics can be exploited in numerous applications such as, but not limited to, statistical analysis of the populations [4], the segmentation of the structures of interest [5], the detection of the disease regions [6] and tracking for MRI-guided robotic intervention [7–9].

A 3D shape atlas is usually constructed from a set of volumetric images with organs of interest labeled. In general, as shown in Fig. 1
                     , the construction of a shape atlas consists of three major steps, surface reconstruction, surface registration and statistical analysis. Surface reconstruction aims to convert a labeled volume to a surface. Although different surface representations have been proposed in [10–12,2], triangle mesh is the most widely used one, which can be reconstructed by the marching cube algorithm [13]. In this way, a surface is described by a set of vertices and triangle patches. After a population of surfaces are reconstructed, surface registration is performed to build correspondences across different surface instances. More specifically, vertices of the same local anatomy should be labeled as correspondences across population. Only after correct correspondences are established, can statistical analysis (e.g., Principal Component Analysis [4]) be performed to extract meaningful shape statistics. In fact, since the quality of a shape atlas is highly dependent on the accuracy of surface registration, surface registration becomes the most critical yet challenging step of the construction of 3D shape atlas. We will mainly focus on surface registration in the remainder of this paper.

Surface registration
                        1
                        In literatures, it is sometimes named as “correspondence matching” or “surface matching”.
                     
                     
                        1
                      has been extensively studied in recent decades (detailed in Section 2). Adaptive focus deformable model (AFDM) [1,14] is one of the most representative ones. In AFDM, a set of geometric attributes are designed to characterize a surface. By matching these geometric attributes, a surface can deform to another, which essentially establishes correspondences between them. Apart from the success of AFDM in various applications, the registration accuracy of AFDM is sensitive to the mesh qualities, which might degrade during the surface deformation. As shown in Fig. 2
                     , if irregular topology and skinny triangle patches appear, geometric attributes will unexpectedly change, hence, the registration accuracy decreases.

In this paper, we propose a new framework for 3D anatomical shape atlas construction. Our method aims to robustly establish correspondences across different surfaces and simultaneously generate high-quality surface meshes without losing shape details. Mathematically, a new energy term is incorporated into the original energy function of AFDM to preserve surface mesh qualities during deformable surface matching [15]. More specifically, we employ the Laplacian representation to encode shape details and smoothness constraints. An expectation–maximization style algorithm is designed to optimize multiple energy terms alternatively until convergence. In addition, a hierarchical strategy is employed to effectively extract shape statistics of complex anatomical structures, which often include multiple parts. In this way, only a limited number of training samples are required to obtain statistics of complex anatomical shapes.

Our method is evaluated in three very diverse applications: (1) left ventricle atlas construction from sparse cardiac MRI slices, (2) high resolution cardiac atlas construction from CT images, and (3) atlas construction rodent brains (with multiple structures) from dense brain MRI. For these two cardiac applications, our method is able to find the anatomical point correspondence both among multiple instances of the same phase of a cardiac cycle or sequential phases of one cycle. The ability to fit the atlas to all temporal phases of a dynamic study can benefit the automatic functional analysis. For the brain application, our approach is able to discover the spatial relationship among multiple structures and construct a shape atlas for all structures.

The major contributions are as follows:
                        
                           1.
                           Propose a novel approach to improve the traditional AFDM by incorporating an energy term to preserve shape quality during surface deformation. Besides establishing surface correspondences, registered surfaces have high mesh qualities and are generally smooth without significantly sacrificing shape details. Furthermore, a hierarchical strategy is employed to extract shape statistics of complex shapes (with multiple structures) using a limited number of training samples.

Using this approach, we solve several diverse and challenging tasks. Specifically, we create a high resolution cardiac shape atlas with many complex shape features such as papillary muscles and the trabeculae. We also effectively construct the atlas of multiple rodent brain structures (i.e., the cerebellum, the left and right striatum, and the left and right hippocampus) using a small set of samples.

The rest of the paper is organized as follows. Section 2 reviews related work of surface registration. Section 3 details our approach, including the whole framework (Section 3.1), different energy terms (Sections 3.2–3.4) and the extraction of shape statistics (Section 3.5). Section 4 shows the experimental results of three applications. Section 5 concludes this paper.

@&#RELATED WORK@&#

In this section we review relevant work of surface registration [16]. When two surfaces have the same number of vertices, Procrustes analysis [17] can be employed to find an optimal global transformation (e.g., rigid or similarity transformation) to align them. However, established surface correspondence is a prerequisite of Procrustes analysis. One can use the Iterative Closest Point (ICP) algorithm [18] or the Soft-assign Procrustes [19] to establish correspondences. These two methods also find the optimal similarity transformation from one surface to the other as a result. This constraint adversely affects the registration performance when dealing with shapes having complex local details. In fact, non-rigid registration of training meshes is a better choice in these scenarios. Representative work of deformable registration includes B-Splines [20] and multi-resolution Octree splines [21]. Another type of methods use pattern recognition techniques to determine correspondences. For example, unsupervised clustering has been employed to detect the corresponding parts on other shapes [22]. Dynamic programming and pattern matching has also been used to find corresponding points according to features learned from a set of sparsely annotated training examples [23]. Both methods have only been validated on 2D cases. One can also assume the alignment of two point sets as a probability density estimation problem. Following this assumption, Coherent Point Drift (CPD) [24] and Robust Point-set Registration [25] have been proposed. Some other algorithms, [26,27], have used auxiliary information, such as a set of landmarks, which can be used to guide a Thin-Plate-Spline deformation in deformable shape registration.

Different from the aforementioned algorithms, AFDM [1] aims to register surfaces by exploiting comprehensive geometric characteristics. As shown in Fig. 3
                     , each vertex has multiple geometric attributes that are defined by the volumes of tetrahedrons (color dashed lines in Fig. 3) consisting with its neighbors. In this way, the geometric characteristics of a surface are described in a local-to-global fashion. Surface registration is then formulated as an optimization problem, which aims to maximize the geometric similarities between two surfaces. In practice, the optimization is realized via iteratively deforming one surface to the other. Although AFDM achieved tremendous success in various applications [5,28–30], its performance is dependent on the quality of the surface mesh. It is not difficult to see that a low quality mesh, i.e., a mesh with highly non-equilateral triangle patches, will contain abnormal geometric attributes, which will adversely affect the registration accuracy. In fact, AFDM often requires the pre-process of both surfaces, which ensures good mesh qualities. However, since traditional AFDM does not preserve mesh qualities during surface deformation, the inaccurate registration resulting from degraded mesh qualities cannot be avoided.

To validate the proposed shape registration method, we measure the registrations errors and shape quality [31]. In addition, we also measure the goodness of correspondence established by our method. We follow the measurements that have been widely used [32–34], including the model compactness and model generalization.

@&#METHODOLOGY@&#

As discussed before, the performance of AFDM relies on the mesh quality, which might degrade during the deformable registration. In fact, the deformed surface with bad mesh qualities affects not only the registration accuracy but also the statistical analysis. Though pre-processing techniques using mesh smoothing methods such as [35–37] can alleviate the problem to some degree, it is still highly possible that the mesh is degenerate during shape deformation. Thus it is desirable to design a unified framework to consider shape deformation and mesh quality simultaneously, which will be detailed next.

Denote M
                        
                           o
                         and M
                        
                           t
                         as the source and target surface, respectively. Surface registration aims to deform M
                        
                           o
                         to M
                        
                           d
                        , such that M
                        
                           d
                         and M
                        
                           t
                         have maximum geometric similarity. This process is formulated as an energy minimization procedure. Three energy functions are introduced to control the model deformation and preserve the mesh quality, i.e., model energy, external energy and shape energy. The energy function is defined as:
                           
                              (1)
                              
                                 E
                                 =
                                 [
                                 
                                    
                                       E
                                    
                                    
                                       model
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       o
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       E
                                    
                                    
                                       ext
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 ]
                                 +
                                 
                                    
                                       E
                                    
                                    
                                       shape
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       o
                                    
                                 
                                 )
                                 .
                              
                           
                        Here, External energy E
                        
                           ext
                        (M
                        
                           d
                        , M
                        
                           t
                        ) is the distance between M
                        
                           d
                         and M
                        
                           t
                        . It is designed to drive the model deforming towards the boundaries of the target model M
                        
                           t
                        . Model energy E
                        
                           model
                        (M
                        
                           d
                        , M
                        
                           o
                        ) reflects the geometric differences between M
                        
                           o
                         and M
                        
                           d
                        . It preserves the geometric characteristics during the deformation. By jointly minimizing these two terms, the model will deform to the boundaries of the target and still preserving its geometric characteristics. In our study, an additional term Shape energy M
                        
                           shape
                        (M
                        
                           d
                        , M
                        
                           o
                        ) is designed to ensure that vertices are evenly distributed and shape details are roughly preserved. Using only E
                        
                           model
                         and E
                        
                           ext
                         produces similar results as AFDM, which makes the surface registration sensitive to mesh quality. The quality energy M
                        
                           shape
                         induced here ensures that the mesh quality is improved during deformation procedure, making the whole model more robust to handle diverse input.

To optimize this energy function, we use an expectation–maximization (EM) type of algorithm. During the “E” step, the model energy and external energy are minimized using similar approach as AFDM. Thus the source surface is deformed to fit the target one, although this deformation may degrade mesh quality and not be accurate. In the “M” step, the mesh quality is improved by minimizing the shape energy. As we show in Section 3.4, this step is formulated as a least square problem and solved efficiently. Two procedures are alternately performed to robustly register the source surface to the target surface. In the following sections, we will introduce the details of different energies as well as the optimization algorithms.

External energy measures the distance between the deformed surface and the target one. The minimization of external energy E
                        
                           ext
                         is fairly standard. First, distance transform is applied to M
                        
                           t
                         to obtain a binary distance 3D image I
                        
                           t
                        , which is the implicit embedding space of the target mesh. Then the deformed mesh M
                        
                           d
                         is placed in the embedding space I
                        
                           t
                        . Standard gradient on M
                        
                           d
                         vertices is computed from I
                        
                           t
                        . The gradient force drives M
                        
                           d
                         to be close to M
                        
                           t
                         on the boundaries. The details of E
                        
                           model
                         and E
                        
                           quality
                         are introduced in the next two subsections.
                           
                              (2)
                              
                                 
                                    
                                       E
                                    
                                    
                                       ext
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       E
                                    
                                    
                                       ext
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       I
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 =
                                 -
                                 |
                                 ∇
                                 I
                                 
                                    
                                       |
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                        where ∇ is the gradient operator.

Model energy measures the geometric differences between the original model and its deformed version. It is designed to maintain the geometric characteristics of the source surface while it is deforming to the target one. Model energy is defined by the differences of geometric attribute vectors. An attribute vector is attached to each vertex of the model, which reflects the geometric structure of the model from a local to global level. For a particular vertex V
                        
                           i
                         in 3D, each attribute is defined as the volume of a tetrahedron on that vertex. The other three vertices form the tetrahedron are randomly chosen from the lth level neighborhood of V
                        
                           i
                        . Smaller tetrahedrons reflect the local structure near a vertex while larger tetrahedrons reflect a more global information around a vertex. The attribute vector, if sufficient enough, uniquely characterizes the different anatomical structures along a surface. Denote the volume of a tetrahedron as f
                        
                           l
                        (V
                        
                           i
                        ), the attribute vector of a vertex is defined as:
                           
                              (3)
                              
                                 F
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 [
                                 
                                    
                                       f
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ,
                                 
                                    
                                       f
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ,
                                 …
                                 ,
                                 
                                    
                                       f
                                    
                                    
                                       R
                                       (
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                       )
                                    
                                 
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 ]
                                 ,
                              
                           
                        where R(V
                        
                           i
                        ) is the neighborhood layers we want to use around V
                        
                           i
                        .

The model energy term reflects the differences of attribute vectors between the original and the deformed surface. Mathematically, it is represented as:
                           
                              (4)
                              
                                 
                                    
                                       E
                                    
                                    
                                       model
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       o
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          l
                                          =
                                          1
                                       
                                       
                                          R
                                          (
                                          
                                             
                                                V
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                    
                                 
                                 
                                    
                                       δ
                                    
                                    
                                       l
                                    
                                 
                                 
                                    
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             d
                                             ,
                                             l
                                          
                                       
                                       (
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       -
                                       
                                          
                                             f
                                          
                                          
                                             o
                                             ,
                                             l
                                          
                                       
                                       (
                                       
                                          
                                             V
                                          
                                          
                                             i
                                          
                                       
                                       )
                                       )
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                        where f
                        
                           d, l
                        (V
                        
                           i
                        ) and f
                        
                           o, l
                        (V
                        
                           i
                        ) are components of attribute vectors of the deformed surface and surface at vertex V
                        
                           i
                        , respectively. δ
                        
                           l
                         here denotes the importance of the lth neighborhood layers. R(V
                        
                           i
                        ) is the number of neighborhood layers around vertex V
                        
                           i
                        .

The proposed algorithm is optimized iteratively. In each iteration, a neighborhood of a vertex has been examined and the point in the neighborhood with the minimum model energy would be chosen as the new location of the vertex. The iterations continue until the energy converges. During the deformation, we suggest moving a surface segment as a whole, rather than a single vertex. This would avoid the risk of getting trapped in a local minimum, and also speed up the convergence. Let V
                        
                           i
                         be the vertex to be deformed during a particular iteration. The first to R(V
                        
                           i
                        )th neighborhood layers are about to move together as a surface segment. Suppose V
                        
                           i
                         is to move to V
                        
                           i
                        
                        +
                        Δ as a tentative position. Then the new position of each vertex nbr
                        
                           l, m
                        (V
                        
                           i
                        ), the mth vertex on lth neighborhood layer, is set to move to:
                           
                              (5)
                              
                                 
                                    
                                       nbr
                                    
                                    
                                       l
                                       ,
                                       m
                                    
                                 
                                 (
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 Δ
                                 ·
                                 exp
                                 
                                    
                                       
                                          -
                                          
                                             
                                                
                                                   
                                                      l
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                             
                                                2
                                                
                                                   
                                                      δ
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        where δ is a parameter determining the locality of the transformation. We make the deformation unchanged on the boundary of the surface segment, such that the continuity has been maintained.

The parameter R(V
                        
                           i
                        ) that determines the locality if the deformation is chosen to be large in the initial iteration, and is then gradually reduced to 1. Therefore, initially there are more vertices involved in the deformation. More global features are used in deformation. In later stages, more local deformations are performed.

Shape energy is used to smooth the shape without losing the important details. Usually there is a tradeoff between the smoothness and keeping shape details. We extend the Laplacian coordinate to achieve this. Let the mesh 
                           
                              M
                           
                         of the shape be described by a pair 
                           
                              (
                              V
                              ,
                              E
                              )
                           
                        , where 
                           
                              V
                              =
                              {
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    v
                                 
                                 
                                    n
                                 
                              
                              }
                           
                         describes the geometric positions of the vertices in 
                           
                              
                                 
                                    R
                                 
                                 
                                    3
                                 
                              
                           
                         and 
                           
                              E
                           
                         describes the connectivity. The neighborhood ring of a vertex i is the set of adjacent vertices 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              =
                              {
                              j
                              |
                              (
                              i
                              ,
                              j
                              )
                              ∈
                              E
                              }
                           
                         and the degree d
                        
                           i
                         of this vertex is the number of elements in 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                           
                        . Instead of using absolute coordinates 
                           
                              V
                           
                        , the mesh geometry is described as a set of differentials Δ
                        ={δ
                        
                           i
                        }. Specifically, coordinate i will be represented by the difference between v
                        
                           i
                         and the weighted average of its neighbors:
                           
                              (6)
                              
                                 
                                    
                                       δ
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          
                                             
                                                N
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       w
                                    
                                    
                                       ij
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 ,
                              
                           
                        where w
                        
                           ij
                         is computed from cotangent weights [38] (Fig. 4
                        ). Assume V is the matrix representation of 
                           
                              V
                           
                        . Using a small subset 
                           
                              A
                              ⊂
                              V
                           
                         of m anchor points, a mesh can be reconstructed from connectivity information alone. The x, y and z positions of the reconstructed object 
                           
                              
                                 
                                    
                                       
                                          
                                             V
                                          
                                          
                                             p
                                          
                                          
                                             ′
                                          
                                       
                                       =
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         1
                                                         p
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      
                                                         v
                                                      
                                                      
                                                         np
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             T
                                          
                                       
                                       ,
                                       p
                                       ∈
                                       {
                                       x
                                       ,
                                       y
                                       ,
                                       z
                                       }
                                    
                                 
                              
                           
                         can be solved for separately by minimizing the quadratic energy:
                           
                              (7)
                              
                                 
                                    
                                       E
                                    
                                    
                                       shape
                                    
                                 
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 ,
                                 
                                    
                                       L
                                    
                                    
                                       o
                                    
                                 
                                 )
                                 =
                                 ‖
                                 
                                    
                                       M
                                    
                                    
                                       d
                                    
                                 
                                 -
                                 
                                    
                                       L
                                    
                                    
                                       o
                                    
                                 
                                 ‖
                                 =
                                 ‖
                                 
                                    
                                       L
                                    
                                    
                                       u
                                    
                                 
                                 
                                    
                                       V
                                    
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 -
                                 Δ
                                 
                                    
                                       ‖
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          a
                                          ∈
                                          A
                                       
                                    
                                 
                                 ‖
                                 
                                    
                                       v
                                    
                                    
                                       ap
                                    
                                    
                                       ′
                                    
                                 
                                 -
                                 
                                    
                                       v
                                    
                                    
                                       ap
                                    
                                 
                                 
                                    
                                       ‖
                                    
                                    
                                       2
                                    
                                 
                                 ,
                              
                           
                        where L
                        
                           u
                         is the Laplacian matrix from uniform weights, and the v
                        
                           ap
                         are anchor (landmark) points. 
                           
                              ‖
                              
                                 
                                    LV
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              -
                              Δ
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                         tries to smooth the mesh when keeping it similar to the original shape, and 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    a
                                    ∈
                                    A
                                 
                              
                              ‖
                              
                                 
                                    v
                                 
                                 
                                    ap
                                 
                                 
                                    ′
                                 
                              
                              -
                              
                                 
                                    v
                                 
                                 
                                    ap
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                         keeps the anchor points unchanged. The cotangent weights approximate the normal direction, and the uniform weights point to the centroid. By minimizing the difference of these two (i.e., L
                        
                           u
                        
                        V′ and Δ), the vertex is actually moved along the tangential direction. Thus the shape is smoothed without significantly losing the detail. With m anchors, (7) can be rewritten as a (n
                        +
                        m)×
                        n overdetermined linear system 
                           
                              
                                 
                                    AV
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              =
                              b
                           
                        :
                           
                              (8)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   L
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         I
                                                      
                                                      
                                                         ap
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       V
                                    
                                    
                                       p
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Δ
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         V
                                                      
                                                      
                                                         ap
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        This is solved in the least squares sense using the method of normal equations 
                           
                              
                                 
                                    V
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              =
                              
                                 
                                    (
                                    
                                       
                                          A
                                       
                                       
                                          T
                                       
                                    
                                    A
                                    )
                                 
                                 
                                    -
                                    1
                                 
                              
                              
                                 
                                    A
                                 
                                 
                                    T
                                 
                              
                              b
                           
                        . The conjugate gradient method is used in our system to efficiently solve it. The first n rows of 
                           
                              
                                 
                                    AV
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              =
                              b
                           
                         are the Laplacian constraints, corresponding to 
                           
                              ‖
                              
                                 
                                    LV
                                 
                                 
                                    p
                                 
                                 
                                    ′
                                 
                              
                              -
                              Δ
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                        , while the last m rows are the positional constraints, corresponding to 
                           
                              
                                 
                                    ∑
                                 
                                 
                                    a
                                    ∈
                                    A
                                 
                              
                              ‖
                              
                                 
                                    v
                                 
                                 
                                    ap
                                 
                                 
                                    ′
                                 
                              
                              -
                              
                                 
                                    v
                                 
                                 
                                    ap
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                        . I
                        
                           ap
                         is the index matrix of V
                        
                           ap
                        , which maps each 
                           
                              
                                 
                                    V
                                 
                                 
                                    ap
                                 
                                 
                                    ′
                                 
                              
                           
                         to V
                        
                           ap
                        . The reconstructed shape is generally smooth, with the possible exception of small areas around anchor vertices. Different from [39], we use cotangent weights instead of uniform weights. Thus the movement along the normal direction is prevented, and shape details can be better preserved.

Although this method is able to improve mesh quality during runtime, it may still have difficulty to handle very dense and degenerated initial meshes. Furthermore, the computational efficiency can also be adversely affected by such dense meshes. Thus, we can also improve the mesh quality in the pre-process step, as shown in Fig. 5
                        . Usually mesh decimation can be employed to decrease the number of vertices, and this shape energy can be used to smooth the mesh.

The one-to-one correspondence is obtained for each vertex among all shapes after shape registration. Then the shape statistics can be computed straightforwardly using generalized Procrustes analysis and hierarchical PCA. Given any two shapes, they can be fitted to each other using a similarity or rigid transformation. Procrustes analysis is used to find the translation, rotation and scaling components. Since there is no mean shape in the beginning, generalized Procrustes analysis arbitrarily chooses a shape to use as the reference and transforms all the rest to fit it. After that, a mean shape is computed by averaging all transformed shapes. Then, this mean shape is used as a reference shape in the next round. We repeat this procedure until the mean shape converges to a stable state. Note that normalization is necessary, as otherwise the mean shape will degenerate to a single point. After the alignment, each resulting shape is filled into a matrix as a column vector. PCA is applied to get the Point Distribution Model (PDM).

To effectively extract shape statistics from complex shapes, which often have multiple structures, we employ PCA hierarchically. First, RPCA is applied on each structure separately. Thus, shape variation of individual structure can be well discovered even with limited number of samples. Second, their relative locations with respect to the mass centroid are also modeled using PCA. This global statistics is used to place structures. Then local statistics of shapes is employed to select the important “modes” (i.e., eigenvectors corresponding to the largest eigenvalues) to cover more than 80% of the variance. Combining the mean shape and the modes, the PDM is able to summarize and describe the sample shapes concisely and accurately.

@&#EXPERIMENTS@&#

In this section, we validate our method using three applications: construction shape atlas of (1) left ventricle from sparse MRI; (2) cardiac anatomies form high resolution CT images; and (3) multiple structures of rodent brains from MR Microscopy.

MRI has been proven to be a noninvasive tool that can be used to measure the myocardial mass and functional deformation of the heart [40]. Quantification of ventricular mass and function are important for early diagnosis of cardiac disorders and quantitative analysis of cardiac diseases. Recent developments in Cine MRI further help the diagnosis of heart disease by analyzing the heart function throughout the cardiac cycle. MRI is becoming considered as a gold-standard for cardiac function [41,42]. In this context, the construction of an anatomical shape atlas of the structures in the heart has been of particular interest and its importance has been emphasized in a number of recent studies [43–45]. In this experiment, we evaluate our method on 36 3D CINE MRI scans along with their 2D delineations. These cine steady state free precession (SSFP) MR short axis (SAX) images were obtained with a 1.5T GE Signa MRI. All the images were obtained with a temporal resolution of 20 cardiac phases over the heart cycle, and scanned from the ED phase. The slice thickness is large, which is a tradeoff between spatial and temporal resolution. Thus it is difficult to do real 3D annotations. Manual segmentation was applied in each 2D slice.

Mesh decimation is applied as pre-process (Fig. 6
                        ), and our method is then employed to generate surface correspondences. The quality of resulting meshes are evaluated in two aspects: (1) mesh quality and (2) similarity to the original shape. To evaluate the mesh quality, we report the mean and minimum values of the radius ratio [31]. It is computed from 
                           
                              2
                              
                                 
                                    r
                                 
                                 
                                    R
                                 
                              
                           
                        , where r and R are the radii of the inscribed and circumscribed circles of each triangle, respectively. Larger values are preferred. In the original meshes, the mean is 0.654 and minimum is 0.00028. Such mesh quality is not desirable for applications like simulation and segmentation. After using our method, the mean and minimum values become 0.962 and 0.661. The mesh quality is significantly improved. To evaluate the similarity between the processed mesh and the original mesh, we compute the voxel distance between them. As shown in Fig. 7
                        , most distances between corresponding vertices are within one voxel. The resulting shapes are more smooth and most artifacts are removed, while the shape detail is still preserved. Furthermore, the resulting meshes have the same topology and one-to-one correspondence since they all start from the same reference mesh.

After obtaining one-to-one correspondence, it is straightforward to compute the mean shape and its variances, by using generalized Procrustes analysis and PCA. Fig. 8
                         shows the major modes having largest variances. The first three modes cover more than 80% of the variance. Although the shapes of original data are diverse, the modes are very simple. By changing the variances from −3σ to 3σ, where σ is the standard deviation, the first mode just represents the contraction of the heart. The second mode is the movement along the short axis. The third mode is the twisting. These observations are in accordance with the clinical knowledge. For better visualization, please refer to the video sequences in supplementary materials.

Recent developments on the 320 multi-detector CT technologies have made the volumetric acquisition of 4D high resolution cardiac images in a single heart beat possible. We applied our framework to 10 cardiac CT volumes, which captures a whole cycle of cardiac contraction. The CT data were acquired on a 320-MDCT scanner using a conventional ECG-gated contrast-enhanced CT angiography protocol. The imaging protocol parameters include: prospectively triggered, single-beat, volumetric acquisition; detector width 0.5mm, voltage 120kV, current 200–550mA. Reconstructions were done at 10 equally distributed time frames in a cardiac cycle. The resolution of each time frame is 512 by 512 by 320. The voxel size is 0.35×0.35×0.5mm. 3D annotations are obtained from a semi-automatic segmentation algorithm [46]. Our reconstruction method successfully captured the papillary muscles and the trabeculae of the left ventricle. The challenge of this task is to handle these complex shape details. Our framework is able to provide high quality meshes without removing these details. Furthermore, it can robustly discover the one-to-one correspondence among different time frames.


                        Fig. 9
                         shows the reconstruction results of high resolution cardiac CT images. Each shape contains around 20–25K vertices in order to capture fine details. The three-dimensional structures, their relationship and their movement during the cardiac cycle are much more readily appreciated from the shape model than from the original volumetric image data. After applying detail preserved smoothing and surface registration, we can simply use linear interpolation to obtain higher temporal resolution.

The distance between the registered shape and the target shape is preferred to be as small as possible. This can be well achieved for shapes that are not complex (e.g., left ventricle shapes extracted from MRI). However, it is difficult to handle complex shapes having many local details (e.g., high resolution cardiac shapes). Therefore, we evaluate this measurement on this challenging dataset, and compared our proposed method with several other widely used registration algorithms both qualitatively and quantitatively.


                        Fig. 12 shows the visualization comparisons between our method and three widely-used shape registration algorithms: (1) Coherent Point Drift (CPD) [24], (2) robust point set registration using Gaussian Mixture Models (GMMs) [25], and (3) the Thin Plate Spline robust point matching (TPS-RPM) [47]. We register the shape at the first frame to the one at the fifth frame, and then use color maps to visualize the distance between the registered shape and the ground truth. Green colors mean that the distances are within one voxel. Red colors mean under-segmentation while blue colors mean over-segmentation. Shape registration is very challenging since there are many shape details in this cardiac data. Large regions of the compared three methods are in blue and red, which means inaccurate local fitting. Compared to the three methods, the proposed method has achieved the best accuracy and preserved most visual details.


                        Table 1
                         shows the results of quantitative comparisons. We compare the accuracy of registration measured by the mean and standard deviation of voxel distances between the target and deformed shapes. We also compare the mesh quality measured by the min and mean values of the radius ratio [31] and the running time, since preserving the shape quality and details is one of our major contributions. Usually keeping shape details reduces the mesh quality. However, our proposed method ensures both fine shape details and high mesh qualities, because of the mesh quality term. Furthermore, its computational cost is also comparable to the AFDM, even with this extra energy term. The reason is that shape quality constraint aims to produce evenly distributed vertices, which also speeds up the convergence of the AFDM.


                        Fig. 10
                         compares the results using different smoothing weights, i.e., cotangent or uniform weights. Using cotangent weights can preserve more details than the uniform weights since the vertices are moved toward the tangential direction.


                        Fig. 11
                        
                         visualizes the shape variation along the first and second principal directions. Our framework is robust and general enough to handle such complex shapes. The first mode represents the changing of the volume magnitude, and the second mode captures the changing of shape details such as the papillary muscles and the trabeculae. Again, these findings are in accordance with clinical knowledge, which can be used to categorize the cardiac properties.

Diagnosis of neurological and phychiatric disorders is mostly based on behavioral observations and on data from neuroanatomical measures (MR, CT). In this study, we use proposed a method to create 3D shape atlas of brain regions based on MR images of the rodent brain. Rodents are often used as models of human disease not only because they frequently exhibit key features of abnormal neurological conditions [48] but also because they are a convenient starting point for novel studies. Benefited from the hierarchical scheme, only a small number of samples is needed to build atlas for multiple structures. In our experiments, 11 adult male Sprague–Dawley rats were transcardially perfused with 4% paraformaldehyde. Heads were stored in paraformaldehyde and scanned for MRI. The brains were remained in the heads during scanning in order to avoid tissue and shape distortions during brain extraction. The heads were scanned on a 21.1T Bruker Biospin Avance scanner (Bruker Biospin Corporation, Massachusetts, USA). The protocol consisted of a 3D T2-weighted scan with echo-time (TE) 7.5ms, repetition time (TR) 150ms, 27.7kHz bandwidth, field of view (FOV) of 3.4×3.2×3.0mm, and voxel size 0.08mm, isotropic. Because of this high resolution, real 3D annotation is performed manually by multiple clinical experts. We focus on three complex structures of the rodent brain: the cerebellum, the left and right striatum, and the left and right hippocampus. It is worth mentioning that such atlas has been used as shape priors for segmentation tasks [49].


                        Fig. 13
                         shows the shape variation along the first and second principal directions. Our method is able to capture the spatial relationships among different neighboring structures. The first mode is the changing of the volume size. The second mode is the changing of the local details, such as two protruding parts of the cerebellum.

We implemented this method using Python 2.5 and C++ on a Quad CPU 2.4GHz PC. It took about 5–8s to do geometry processing and shape registration for each data, and 2–4s to construct the atlas and shape statistics. The processing time may increase when there are more vertices in each shape. In our test, each mesh contained around 2000–3000 vertices and 4000–5000 triangles.

In this section we measure the goodness of correspondence established by our proposed method. We follow the measurements that have been widely used [32–34]. Specifically, we measure the model compactness and model generalization.


                        Model compactness: A compact model has as little variance as possible and requires as few parameters as possible to define an instance [32]. Therefore, we measure the compactness of the registered shapes by showing the cumulative variance covered by first several modes. We measure the compactness of both the cardiac shapes and the brain structure shapes.


                        Fig. 14
                         shows the cumulative variances covered by largest modes. The cardiac shapes need six largest modes to capture more than 90% shape variances of all data, and five modes are sufficient for the brain structure shapes (i.e., cerebellum, left and right striatum). It indicates that models created from the proposed method are compact in general, and it helps to generalize shape information with less descriptors.


                        Model generalization: The model generalization measures the capability to represent unseen shapes using a set of training samples. We evaluate this by using the leave-one-out strategy [32]. A model is built using all but one member of the training set and then fitted to the excluded example. Specifically, each time we choose one sample as the “unseen” one and use the model built from the rest to approximate it. After obtaining the approximated shape, we compute the mean distance between corresponding points of the approximation and the testing shape. Smaller distance means better generalization.

We evaluate this measurement on the challenging dataset, the high resolution cardiac shapes. Up to seven largest modes are selected to approximate the unseen sample. Table 2
                         shows the quantitative results. In general the first two largest modes can well approximate the unseen data, and the errors are reduced gradually when more modes are used. In terms of the voxel distance, our proposed method achieves 5.147 using the largest mode, 3.320 using two largest modes, and 2.268 using seven largest modes, compared to the 7.276, 5.723, and 5.085 achieved by AFDM. Our method is consistently better. One potential reason is that our proposed method preserves shape details and ensures high-quality triangular meshes. Thus the models of shape variations can be well built, and approximations using these models are relatively accurate.

@&#CONCLUSIONS@&#

In this paper we presented a novel method to construct 3D shape atlas of different anatomies. Specifically, an algorithm is designed to robustly discover geometric correspondences and effectively model 3D shapes. This method improves the traditional adaptive focus deformable model (AFDM) by incorporating a shape energy, which ensures the mesh quality during deformable registration. Besides robustly establishing surface correspondences, the registered meshes are generally smooth without sacrificing geometric details, which facilitates the extraction of shape statistics. Moreover, we employed a hierarchical strategy to learn shape statistics of complex anatomical structures including multiple parts. It is able to build accurate and concise shape atlas with a limited number of training samples. We extensively validated this method in three very diverse applications relevant with different anatomies and imaging modalities. Compared to other methods, our approach exhibits better performance in both quantitative and qualitative measurements. The proposed approach will in fact benefit many other studies. In the future, we plan to use these generated 3D shape atlas to in segmentation and tracking studies by using it as the shape prior information.

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.cviu.2012.11.018.


                     
                        
                           
                        
                     
                  

@&#REFERENCES@&#

