@&#MAIN-TITLE@&#Preserving isotropic element size functions in adaptivity, quadrilateral and hexahedral mesh generation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We define a quantitative criterion to assess if an element meets a size function.


                        
                        
                           
                           We deduce a method to modify the initial size function using a non-linear equation.


                        
                        
                           
                           The new size function ensures that the elements preserve the prescribed size.


                        
                        
                           
                           Our method can reduce the number of iterations to converge an adaptive process.


                        
                        
                           
                           We show that quad and hex meshers better reproduce the initial size function.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mesh size function

Background mesh

Adaptive process

Quadrilateral mesh

Hexahedral mesh

Gradient-limiting

@&#ABSTRACT@&#


               
               
                  It is well known that the variations of the element size have to be controlled in order to generate a high-quality mesh. However, it is not enough to limit the gradient of the size function to generate a mesh that correctly preserves the prescribed element size. To address this issue, in this work we define a criterion to assess when an element reproduces a size field. Then, using this criterion, we develop a novel technique to modify the initial size function by solving a non-linear equation. The new size function ensures that the elements will preserve the original size function. Moreover, an approximated method is developed to improve the computational cost of solving the non-linear equation. We use these techniques in two applications. First, we show that we can reduce the number of iterations to converge an adaptive process. Second, we show that quadrilateral and hexahedral meshing algorithms benefit from the new size function since it is not needed to perform a refining process to capture the initial size function.
               
            

@&#INTRODUCTION@&#

In many numerical analyses, such as adaptive calculations [1,2], it is of the major importance to generate a mesh that correctly preserves the prescribed element size. On the one hand, the final mesh has to capture areas where small element sizes are prescribed, since the element size is directly related to the accuracy of the final results. On the other hand, the final mesh has to correctly capture areas where large element sizes are imposed, in order to decrease the computational cost of the numerical simulation. That is, if the element size of the final mesh is too large it penalizes the accuracy of the solution, and if the element size of the final mesh is too small it penalizes the computational cost. Therefore, special effort has been focused on generating element size fields that facilitate the generation of the desired mesh [3–5].

One of the most used techniques to define the element size consists in prescribing the values of a scalar function, the size function at the nodes of a background mesh. Then, these values are interpolated over the whole domain. For instance, this technique is used in adaptive simulations where starting with an initial mesh, a size function is determined at its nodes from the computed solution via an error estimate. Then, the original mesh is used as a background mesh to generate a new spatial discretization.

Mesh generation techniques, like advancing front methods, benefit from size functions with good properties. Usually, it is required that the gradient of the size function is not large. However, we will see in this work that this property is not enough to generate a mesh that correctly preserves the size function. In addition, different mesh generation algorithms have different requirements on the size function. For instance, triangular and tetrahedral meshing algorithms [1,2,6] can easily follow the variations of prescribed size function, since they can be refined or de-refined where needed without generating low-quality elements. However, quadrilateral and hexahedral meshes [7,8] cannot be easily refined or de-refined. For this reason, quadrilateral meshing algorithms may miss small regions where a small element size is prescribed. If this is the case, the analysis may lead to inaccurate results.

Current techniques, such as the gradient-limiting algorithms [9–12], modify a given size function by limiting its gradient. Thus, ratio of neighboring element sizes is bounded and it is easier for any mesh generator to provide a high-quality mesh with smooth variation of the element size. However, the final mesh may still not correctly reproduce the initial size function. For instance, if an element size is prescribed in a given area, this area has to be large enough to hold at least one element of that size. Thus, it is still necessary to develop some techniques that, given a prescribed element size field, modify it in such a way that a mesh generation algorithm can provide a discretization that verifies the initial size field.

The main contribution of this work is to introduce the new concept of size-preserving size function. The main idea behind this concept is to compute a new size function by solving an implicit and non-linear equation such that: 1. it ensures that all the elements are smaller or equal to the prescribed element size; and 2. the maximum gradient of the new size function is limited. In addition, we propose an implementation to solve the implicit and non-linear equation that states a size-preserving size function. However, the generation of an exact size-preserving size function is expensive. To reduce the computational cost, we also propose to compute an approximated size-preserving size function. However, the approximated method does not ensure that the original function is preserved. In fact, we show that it can be interpreted in terms of the gradient-limiting technique presented in [12].

The main advantages of size-preserving size functions is that the new size function allows that the final mesh contains the features and the small element sizes of the initial size function. This is of major importance in several applications. For instance, quadrilateral and hexahedral mesh generators benefit from this new size function since these types of meshes are more difficult to refine or coarsen. In addition, the new size function can reduce the number of iterations needed to converge an adaptive process, since we do not need additional iterations to properly reproduce the size field.

The outline of this paper is the following. First, in Section 2, we survey previous work on modifications of size functions for mesh generation and adaption. In Section 3, using a one-dimensional example we motivate this work and introduce the basic definitions. In Section 4, we deduce the size-preserving method and analyze its properties. In Section 5, we detail how to generate a size-preserving size function. In Section 6, we present the simplified approach to reduce the computational cost of generating the new size function. Finally, several examples are presented to illustrate the capabilities of the presented techniques, see Section 7.

@&#RELATED WORK@&#

Ref. [2] states that it is necessary to process the initial size field in order to generate a high-quality mesh that properly reproduces it. Specifically, this work presents a method to modify the size function defined in a background mesh by taking averages of adjacent nodes. However, this procedure does not guarantee that the final mesh correctly preserves the features of the size field. In particular, high variations in the size field might still appear after the smoothing process. In Ref. [10], the authors claim that it is required to limit the gradient of the size function to obtain a high-quality mesh. To this end, they propose an edge-based method to compute the new size function. However, the final mesh may not preserve the initial size field since it only limits the gradient. Ref. [3] generates a size function taking into account the geometric properties of the model. Then, the size function is modified using a node averaging method, similar to [2], but using an octree instead of a triangular background mesh.

Ref. [12] presents a new method to limit the gradient of the prescribed size field. Specifically, the author uses a Hamilton–Jacobi equation to model the gradient-limiting techniques. Then, using specialized methods, they obtain a solution that does not depend so strongly on the mesh topology as using edge-based methods. Similar to other methods, this technique only controls the maximum gradient of the size function. It is worth to notice that the approximated technique presented in our work can be interpreted as a special case of a gradient-limiting method. The main difference between the work presented in [12] and our approach, is that we solve the Hamilton–Jacobi equation using an edge-based method. The technique presented in [12] has been used later in Ref. [4] to smooth the element size function proposed in [3] by the same authors. Similar approach is also used in Ref. [11].

In Ref. [13,14], the authors present a gradient-limiting technique for anisotropic size functions. In addition, they detail a test for checking whether an element has the correct size. However, they only check the size function at the edges of the element and, for this reason, small element sizes may be lost if they are located in the interior of the element or if the size function contains high gradients. Ref. [15], introduces a method to check how well a mesh reproduces an anisotropic size field. This method compares the size of an element to the mean value of the size function over the element. Thus, low element sizes may be lost if high gradients are present in the size function.

The objective of our work is to develop a technique to process an isotropic size function that allows the generation of a high-quality mesh that correctly reproduces the initial size function. On the one hand, the method includes the gradient-limiting constraint [10–12]. On the other hand, and similar to [13–15], it also includes a check of the size function. However, in our approach this checking is implicit in the statement of the technique. It is important to point out that this implicit check allows our approach to ensure that all the elements are smaller or equal to the prescribed element size. Finally, it is worth to notice that the anisotropic case is out of the scope of this analysis.

@&#MOTIVATION@&#

To illustrate the most common problems arising from the use of a size function in a mesh generation process, we consider the following one-dimensional size function defined in the [0,1] interval, see Fig. 1
                     :
                        
                           (1)
                           
                              h
                              (
                              x
                              )
                              =
                              
                                 min
                              
                              {
                              0.5
                              ,
                              0.1
                              +
                              3
                              |
                              x
                              -
                              0.75
                              |
                              )
                              }
                              ,
                           
                        
                     Function (1) is constant almost everywhere, with a valley at x
                     =0.75. The minimum size is 0.1 and the maximum size is 0.5. Fig. 1(a) presents the node distribution generated using an advancing front method where the element size is obtained using the size function (1). Since the size prescribed at x
                     =0 is 0.5, only two elements are generated and the discretization does not preserve the prescribed element size. The main reason of this shortcoming is that the size function contains high gradients that the meshing algorithm cannot reproduce.

To obtain a better discretization, a gradient-limiting technique [9–12] can be applied. Fig. 1(b) presents the gradient-limiting size function obtained from (1), and the node distribution obtained using the same meshing algorithm. The maximum gradient of the new size function is imposed to be ε
                     =1. Note that this node distribution does not correctly reproduce the prescribed element size. Although the element size is smaller around the valley of the size function, the minimum element size is not captured in the final mesh. To compare these discretizations we have to measure how accurately a mesh reproduces a prescribed size function. To this end, we introduce the following definitions.
                        Definition 1
                        An element e reproduces a prescribed size function h(x) if it verifies
                              
                                 (2)
                                 
                                    μ
                                    (
                                    e
                                    )
                                    ⩽
                                    β
                                    
                                    
                                       
                                          
                                             min
                                          
                                          
                                             x
                                             ∈
                                             e
                                          
                                       
                                    
                                    
                                    h
                                    (
                                    x
                                    )
                                    ,
                                 
                              
                           where μ(e) is the size of element e, and β is a scaling factor.

The size of an element can be computed in different ways. For instance, the length of the longest edge, or the mean value of the edge lengths, among others. In this work we compute the size of an element as the length of its longest edge.

A mesh 
                              
                                 M
                              
                            reproduces a prescribed size function h(x) if it verifies
                              
                                 (3)
                                 
                                    μ
                                    (
                                    e
                                    )
                                    ⩽
                                    β
                                    
                                    
                                       
                                          
                                             min
                                          
                                          
                                             x
                                             ∈
                                             e
                                          
                                       
                                    
                                    
                                    h
                                    (
                                    x
                                    )
                                    ,
                                    
                                    ∀
                                    e
                                    ∈
                                    M
                                    .
                                 
                              
                           
                        

By introducing the ratio
                        
                           (4)
                           
                              R
                              (
                              e
                              )
                              =
                              
                                 
                                    μ
                                    (
                                    e
                                    )
                                 
                                 
                                    β
                                    
                                    
                                       
                                          
                                             min
                                          
                                          
                                             x
                                             ∈
                                             e
                                          
                                       
                                    
                                    
                                    h
                                    (
                                    x
                                    )
                                 
                              
                              ,
                           
                        
                     a mesh that correctly reproduces the prescribed element size has to verify
                        
                           (5)
                           
                              R
                              (
                              e
                              )
                              ⩽
                              1
                              
                              ∀
                              e
                              ∈
                              M
                              .
                           
                        
                     
                  


                     Fig. 2
                      plots function (4) for the discretizations generated using the original size function and the gradient-limiting size function with β
                     =1. Since R(e)⩾1 for most of the elements of the meshes, these discretizations do not reproduce the size function.

We have shown that a mesh may not reproduce the prescribed element size function. That is, it may not verify Eq. (3). To overcome this drawback, in this section we introduce the new concept of size-preserving size function. Given the original size function, h(x), we will deduce an alternative size function, called size-preserving size function and denoted by h
                     ∗(x), such that it allows reproducing the size function according to Eq. (3).

In fact, the new size function, h
                     ∗(x), can be written in terms of the original one, h(x). To this end, we consider the one-dimensional example presented in Fig. 3
                     (a). To obtain a mesh that correctly reproduces the size function, we assume that the new element size around a point x
                     ∈
                     Ω has to be h
                     ∗(x). Then, the new node is created at position x
                     ±
                     h
                     ∗(x), depending on the advancing direction of the meshing algorithm, see Fig. 3(a). For this reason, the size of the new element, e, is μ(e)=
                     h
                     ∗(x). Taking into account condition (2), we deduce that the following equation has to be verified:
                        
                           
                              
                                 
                                    h
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              )
                              =
                              μ
                              (
                              e
                              )
                              ⩽
                              β
                              
                                 
                                    
                                       min
                                    
                                    
                                       y
                                       ∈
                                       [
                                       x
                                       -
                                       
                                          
                                             h
                                          
                                          
                                             ∗
                                          
                                       
                                       (
                                       x
                                       )
                                       ,
                                       x
                                       +
                                       
                                          
                                             h
                                          
                                          
                                             ∗
                                          
                                       
                                       (
                                       x
                                       )
                                       ]
                                    
                                 
                              
                              h
                              (
                              y
                              )
                              .
                           
                        
                     
                  

If we want h
                     ∗(x) as big as possible to generate the minimum amount of elements, we have that
                        
                           
                              
                                 
                                    h
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              )
                              =
                              β
                              
                                 
                                    
                                       min
                                    
                                    
                                       y
                                       ∈
                                       [
                                       x
                                       -
                                       
                                          
                                             h
                                          
                                          
                                             ∗
                                          
                                       
                                       (
                                       x
                                       )
                                       ,
                                       x
                                       +
                                       
                                          
                                             h
                                          
                                          
                                             ∗
                                          
                                       
                                       (
                                       x
                                       )
                                       ]
                                    
                                 
                              
                              h
                              (
                              y
                              )
                              .
                           
                        
                     
                  

To add more flexibility to our method, we include a parameter α that determines the trial interval (i.e. the interval in which the minimum of the original size function is computed):
                        
                           
                              
                                 
                                    h
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              )
                              =
                              β
                              
                                 
                                    
                                       min
                                    
                                    
                                       y
                                       ∈
                                       [
                                       x
                                       -
                                       α
                                       
                                          
                                             h
                                          
                                          
                                             ∗
                                          
                                       
                                       (
                                       x
                                       )
                                       ,
                                       x
                                       +
                                       α
                                       
                                          
                                             h
                                          
                                          
                                             ∗
                                          
                                       
                                       (
                                       x
                                       )
                                       ]
                                    
                                 
                              
                              h
                              (
                              y
                              )
                              .
                           
                        
                     
                  

Note that taking α
                     >1 we enlarge the trial interval. Thus, the size-preserving size function can achieve smaller values. On the contrary, taking α
                     <1 we reduce the trial interval and the size-preserving size function can achieve larger values. The previous equation can be expressed in any dimension as:
                        
                           (6)
                           
                              
                                 
                                    h
                                 
                                 
                                    ∗
                                 
                              
                              (
                              x
                              )
                              =
                              β
                              
                                 
                                    
                                       min
                                    
                                    
                                       y
                                       ∈
                                       
                                          
                                             B
                                          
                                          
                                             α
                                             
                                                
                                                   h
                                                
                                                
                                                   ∗
                                                
                                             
                                             (
                                             x
                                             )
                                          
                                       
                                       (
                                       x
                                       )
                                    
                                 
                              
                              h
                              (
                              y
                              )
                              ,
                           
                        
                     where B
                        r
                     (x) is the set of points at distance at most r from x. Note that β can be interpreted as a parameter that controls the maximum ratio R(e) accepted in the final mesh. It is important to point out that Eq. (6) is an implicit and non-linear definition of the size-preserving size function. Fig. 3(b) plots several size-preserving functions for different values of parameter α. This parameter plays an important role in Eq. (6). In fact, it controls:
                        
                           (i)
                           
                              The measure of local minima in the element size function. This ensures that small element sizes prescribed at local minima can be correctly reproduced. That is, an element can be held at each local minima.


                              The maximum gradient allowed. This ensures that a high-quality mesh can be generated. Although we do not have a formal proof, experience has shown that the maximum gradient of the size-preserving size function is limited to β/α.

Although in Eq. (6) parameters α and β are arbitrary, it is recommended to select β
                           ⩽1 and α
                           ⩾
                           β in order to obtain a mesh that satisfies Eq. (3).

Through the rest of the paper, we use β
                           =1 if it is not explicitly stated.


                           For all 
                           
                              x
                           
                           ∈
                           Ω, exists a unique h
                           ∗
                           (
                           
                              x
                           
                           ) such that
                           
                              
                                 
                                    
                                       
                                          h
                                       
                                       
                                          ∗
                                       
                                    
                                    (
                                    x
                                    )
                                    =
                                    β
                                    
                                       
                                          
                                             min
                                          
                                          
                                             y
                                             ∈
                                             
                                                
                                                   B
                                                
                                                
                                                   α
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             (
                                             x
                                             )
                                          
                                       
                                    
                                    h
                                    (
                                    y
                                    )
                                 
                              
                           
                        

For a given 
                              x
                           
                           ∈
                           Ω, let us assume that there exists two values, h
                           ∗(
                              x
                           ) and g
                           ∗(
                              x
                           ), such that
                              
                                 
                                    
                                       
                                          h
                                       
                                       
                                          ∗
                                       
                                    
                                    (
                                    x
                                    )
                                    =
                                    β
                                    
                                       
                                          
                                             min
                                          
                                          
                                             y
                                             ∈
                                             
                                                
                                                   B
                                                
                                                
                                                   α
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             (
                                             x
                                             )
                                          
                                       
                                    
                                    h
                                    (
                                    y
                                    )
                                    ,
                                    
                                    and
                                    
                                    
                                       
                                          g
                                       
                                       
                                          ∗
                                       
                                    
                                    (
                                    x
                                    )
                                    =
                                    β
                                    
                                       
                                          
                                             min
                                          
                                          
                                             y
                                             ∈
                                             
                                                
                                                   B
                                                
                                                
                                                   α
                                                   
                                                      
                                                         g
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             (
                                             x
                                             )
                                          
                                       
                                    
                                    h
                                    (
                                    y
                                    )
                                    ,
                                 
                              
                           respectively. Since h
                           ∗(
                              x
                           )≠
                           g
                           ∗(
                              x
                           ), we can assume, without loss of generality that h
                           ∗(
                              x
                           )<
                           g
                           ∗(
                              x
                           ). For this reason,
                              
                                 
                                    
                                       
                                          B
                                       
                                       
                                          α
                                          
                                             
                                                h
                                             
                                             
                                                ∗
                                             
                                          
                                          (
                                          x
                                          )
                                       
                                    
                                    (
                                    x
                                    )
                                    ⊂
                                    
                                       
                                          B
                                       
                                       
                                          α
                                          
                                             
                                                g
                                             
                                             
                                                ∗
                                             
                                          
                                          (
                                          x
                                          )
                                       
                                    
                                    (
                                    x
                                    )
                                    .
                                 
                              
                           
                        

Consequently, taking the minimum of h(
                              x
                           ) in both balls, we obtain that 
                              
                           
                        

And we obtain a contradiction. Thus, there exists a unique h
                           ∗(
                              x
                           ) such that
                              
                                 
                                    
                                       
                                          h
                                       
                                       
                                          ∗
                                       
                                    
                                    (
                                    x
                                    )
                                    =
                                    β
                                    
                                    
                                       
                                          
                                             min
                                          
                                          
                                             y
                                             ∈
                                             
                                                
                                                   B
                                                
                                                
                                                   α
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   (
                                                   x
                                                   )
                                                
                                             
                                             (
                                             x
                                             )
                                          
                                       
                                    
                                    h
                                    (
                                    y
                                    )
                                    
                                    □
                                 
                              
                           
                        


                     Fig. 4
                     (a) presents the original size function stated in Eq. (1), the corresponding size-preserving size function, and the node distribution of the generated 1D mesh. The size-preserving size function is computed according to Eq. (6) with α
                     =1. Note that the region around the minimum is automatically enlarged in order to held an element of the requested size. In addition, the gradient of the size-preserving size function has been automatically limited.


                     Fig. 4(b) presents the ratio R(e), see Eq. 4, for the meshes generated using: the original, the gradient-limiting and the size-preserving size functions. Note that for the size-preserving size function the distribution of nodes correctly preserves the original size function.

In this section, we present an algorithm to compute a size-preserving size function, h
                     ∗(x), from an original size function, h(x). This process is performed for each node of the background mesh. That is, at each node of the background mesh we compute h
                     ∗(x) such that Eq. (6) is verified.

Given a node, n
                     0, of the background mesh, located at x
                     0
                     ∈
                     Ω, the main idea of the algorithm is to shrink a ball centered at x
                     0 and, at the same time, compute the minimum value of h(y) in the ball. The ball radius, r, is decreased until the following equation is verified:
                        
                           (7)
                           
                              r
                              =
                              α
                              
                                 
                                    
                                       min
                                    
                                    
                                       y
                                       ∈
                                       
                                          
                                             B
                                          
                                          
                                             r
                                          
                                       
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             0
                                          
                                       
                                       )
                                    
                                 
                              
                              h
                              (
                              y
                              )
                              .
                           
                        
                     To compute the nodes that belong to the ball, we store the nodes using a min-heap. A min-heap is a data structure such that its values are stored in ascending order. In this case, the nodes in the min-heap are sorted according to the distance to the center of the ball. Algorithm 1 details the calculation of h
                     ∗(x) for a given node n
                     0. In this algorithm, the distance between an arbitrary node n of the background mesh and node n
                     0 is computed as the distance along the edges. The distance to node n
                     0 is initialized to infinity (for instance, the maximum value for an object of type double).

First, some variables are initialized, Lines 2–6. The initial node, n
                     0, located at distance 0 from the center of the ball, is inserted in the min-heap container. The radius of the ball is initialized as r
                     =
                     αh(x
                     0). The main loop of the algorithm begins at this point. Each node, n, of the min-heap is removed from the container and then it is processed. We denote by d the distance between this node and node n
                     0. In addition, we denote by x
                     n the location of node n and we define an auxiliary variable r′=
                     αh(x
                     
                        n
                     ) that stores the radius of a ball centered at x
                     0 and computed according to the prescribed size at node n. Then, the algorithm updates the value of the ball radius, r, (and thus the value of the size-preserving size function at x
                     0) according to the values of r, r′ and d. Five cases are considered, see Fig. 5
                     :
                        
                           (i)
                           
                              r′<
                              r and d
                              ⩽
                              r′, Lines 14–16

In this case, the radius defined by the current node, r′, is less than the previous value, r. In addition, this node belongs to 
                                 
                                    
                                       
                                          B
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          0
                                       
                                    
                                    )
                                 
                              , since d
                              ⩽
                              r′, see Fig. 5(a). For this reason, the value of r is updated to r
                              =
                              r′. Then, we update the distance of the adjacent nodes to node n according to Algorithm 2.


                              r′<
                              r and r′<
                              d
                              ⩽
                              r, Lines 17–18

In this case, the radius defined by the current node, r′, is also less than the previous value, r. However, the node does not belong to 
                                 
                                    
                                       
                                          B
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          0
                                       
                                    
                                    )
                                 
                               although it belongs to B
                                 r
                              (x
                              0), see Fig. 5(b). We update the value of the radius, r, according to Line 18. Since the node is outside of 
                                 
                                    
                                       
                                          B
                                       
                                       
                                          
                                             
                                                r
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                    (
                                    
                                       
                                          x
                                       
                                       
                                          0
                                       
                                    
                                    )
                                 
                              , we do not need to update the distance of the adjacent nodes.


                              r′<
                              r and r
                              <
                              d.

In this case, no actions have to be taken because the node is outside of the ball B
                                 r
                              (x
                              0), see Fig. 5(c).


                              r′⩾
                              r and d
                              ⩽
                              r, Lines 20–21

The radius, r, is not updated, because r′⩾
                              r. However, the node belongs to B
                                 r
                              (x
                              0), since d
                              ⩽
                              r, see Fig. 5(d). For this reason, the distance of the adjacent nodes has to be updated.


                              r′⩾
                              r and r
                              <
                              d. In this case, no actions have to be taken, because the node is outside of the ball B
                                 r
                              (x
                              0), see Fig. 5(e).

When the min-heap is empty, the process is finished and the value the size-preserving size function is computed as h
                     ∗(
                        x
                     )=
                     βr/α. Thus, by construction, the size-preserving size function is less or equal to the original one.
                        Algorithm 1
                        Computation of h
                           ∗(x) 
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             Return 
                                             h
                                             ∗(
                                                x
                                             )
                                       
                                       
                                          1:
                                          
                                             function 
                                             sizePreserving(BackgroundMesh 
                                                
                                                   M
                                                
                                             , Node n
                                             0, Real α)
                                       
                                       
                                          2:
                                          
                                             NodeMinHeap 
                                                
                                                   N
                                                
                                             
                                          
                                       
                                       
                                          3:
                                          
                                             
                                             setDistance(
                                             n
                                             
                                                0
                                             
                                             ,
                                             
                                             0)
                                          
                                       
                                       
                                          4:
                                          
                                             
                                             insert
                                             
                                                
                                                   (
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   ,
                                                   N
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          5:
                                          
                                             Real v
                                             0
                                             ←
                                             h(x
                                             0)
                                       
                                       
                                          6:
                                          
                                             Real r
                                             ←
                                             α
                                             ·
                                             v
                                             0
                                          
                                       
                                       
                                          7:
                                          
                                             
                                             while 
                                             getSize
                                             
                                                
                                                   (
                                                   N
                                                   )
                                                   >
                                                   0
                                                
                                              
                                             do
                                          
                                       
                                       
                                          8:
                                          
                                             Node n← firstNode
                                             
                                                
                                                   (
                                                   N
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          9:
                                          
                                             
                                             removeNode 
                                             
                                                
                                                   (
                                                   n
                                                   ,
                                                   N
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          10:
                                          
                                             Real d
                                             ←
                                             getDistance(n)
                                       
                                       
                                          11:
                                          
                                             Real v
                                             ←
                                             h(x
                                             
                                                n
                                             )
                                       
                                       
                                          12:
                                          
                                             Real r′←
                                             α
                                             ·
                                             v
                                          
                                       
                                       
                                          13:
                                          
                                             
                                             if 
                                             r′<
                                             r 
                                             then
                                          
                                       
                                       
                                          14:
                                          
                                             
                                             
                                             if 
                                             d
                                             ⩽
                                             r′ then
                                             
                                             
                                             
                                             
                                             
                                             
                                             
                                             ▷Case (i), Fig. 5(a)
                                       
                                       
                                          15:
                                          
                                             
                                             
                                             r
                                             ←
                                             r′
                                       
                                       
                                          16:
                                          
                                             
                                             
                                             updateAdjacentNodesDistance
                                             
                                                
                                                   (
                                                   n
                                                   ,
                                                   r
                                                   ,
                                                   N
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          17:
                                          
                                             
                                             
                                             else if 
                                             d
                                             ⩽
                                             r 
                                             then 
                                             
                                             
                                             
                                             
                                             
                                             
                                             ▷Case (ii), Fig. 5(b)
                                       
                                       
                                          18:
                                          
                                             
                                             
                                             
                                                
                                                   r
                                                   ←
                                                   r
                                                   
                                                      
                                                         r
                                                         -
                                                         d
                                                      
                                                      
                                                         r
                                                         -
                                                         
                                                            
                                                               r
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   
                                                      
                                                         d
                                                         -
                                                         
                                                            
                                                               r
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                      
                                                         r
                                                         -
                                                         
                                                            
                                                               r
                                                            
                                                            
                                                               ′
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          19:
                                          
                                             
                                             
                                             end if
                                          
                                       
                                       
                                          20:
                                          
                                             
                                             else if 
                                             r′⩾
                                             r 
                                             and 
                                             d
                                             ⩽
                                             r 
                                             then
                                             
                                             
                                             
                                             
                                             
                                             ▷Case (iv), Fig. 5(d)
                                       
                                       
                                          21:
                                          
                                             
                                             
                                             updateAdjacentNodesDistance
                                             
                                                
                                                   (
                                                   n
                                                   ,
                                                   r
                                                   ,
                                                   N
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          22:
                                          
                                             
                                             end if
                                          
                                       
                                       
                                          23:
                                          
                                             
                                             end while
                                          
                                       
                                       
                                          24:
                                          
                                             
                                             h
                                             ∗(x
                                             0)←
                                             βr/α
                                          
                                       
                                       
                                          25:
                                          
                                             end Function
                                          
                                       
                                    
                                 
                              
                           
                        

Given a node, n, Algorithm 2 updates the distance from its adjacent nodes to the center of the ball B
                        r
                     (x
                     0). Since this information is transmitted from the nodes with smaller values to the nodes with larger values, the node that holds the smaller value contains the correct value of the distance. Recall that this node, n, is the first node of the min-heap. The new distance, 
                        
                           
                              
                                 d
                              
                              
                                 e
                              
                              
                                 ′
                              
                           
                        
                     , of a node, n
                     
                        e
                     , adjacent to n through edge e is computed as:
                        
                           
                              
                                 
                                    d
                                 
                                 
                                    e
                                 
                                 
                                    ′
                                 
                              
                              =
                              
                                 min
                              
                              {
                              
                                 
                                    d
                                 
                                 
                                    e
                                 
                              
                              ,
                              d
                              +
                              
                                 
                                    l
                                 
                                 
                                    e
                                 
                              
                              }
                              ,
                           
                        
                     where d and d
                     
                        e
                      are the current computed distance of node n and n
                     
                        e
                     , respectively, and l
                     
                        e
                      is the length of edge e. If the new distance, 
                        
                           
                              
                                 d
                              
                              
                                 e
                              
                              
                                 ′
                              
                           
                        
                      is less than r, the current radius of the ball, node n
                     
                        e
                      is inserted in the min-heap with distance 
                        
                           
                              
                                 d
                              
                              
                                 e
                              
                              
                                 ′
                              
                           
                        
                     .
                        Algorithm 2
                        Update the distance of adjacent nodes 
                              
                                 
                                    
                                    
                                    
                                       
                                          1:
                                          
                                             function 
                                             updateAdjacentNodesDistance(Node n, Real r, NodeMinHeap 
                                                
                                                   N
                                                
                                             )
                                       
                                       
                                          2:
                                          
                                             Real d
                                             ←
                                             getDistance(n)
                                       
                                       
                                          3:
                                          
                                             
                                             for all Edge e adjacent to n 
                                             do
                                          
                                       
                                       
                                          4:
                                          
                                             Real l
                                             
                                                e
                                             
                                             ←
                                             length(e)
                                       
                                       
                                          5:
                                          
                                             Node n
                                             
                                                e
                                             
                                             ←
                                             oppositeNode(e,n)
                                       
                                       
                                          6:
                                          
                                             Real d
                                             
                                                e
                                             
                                             ←
                                             getDistance(n
                                             
                                                e
                                             )
                                       
                                       
                                          7:
                                          
                                             Real 
                                                
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         e
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ←
                                                   d
                                                   +
                                                   
                                                      
                                                         l
                                                      
                                                      
                                                         e
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          8:
                                          
                                             
                                             if 
                                             
                                                
                                                   (
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         e
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   <
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         e
                                                      
                                                   
                                                   )
                                                
                                              
                                             and 
                                             
                                                
                                                   (
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         e
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   <
                                                   r
                                                   )
                                                
                                              
                                             then
                                          
                                       
                                       
                                          9:
                                          
                                             
                                             
                                             setDistance
                                             
                                                
                                                   (
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         e
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         d
                                                      
                                                      
                                                         e
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          10:
                                          
                                             
                                             
                                             
                                                
                                                   updateHeap
                                                   (
                                                   
                                                      
                                                         n
                                                      
                                                      
                                                         e
                                                      
                                                   
                                                   ,
                                                   N
                                                   )
                                                
                                              ▷Since the distance of the node has changed
                                       
                                       
                                          11:
                                          
                                             
                                             end if
                                          
                                       
                                       
                                          12:
                                          
                                             
                                             end for
                                          
                                       
                                       
                                          13:
                                          
                                             end function
                                          
                                       
                                    
                                 
                              
                           
                        

According to Section 5, the basic characteristic of the behavior of the size-preserving size functions is that it controls the maximum gradient and the measure of local minima in the element size function. This is achieved by solving an implicit and non-linear equation that depends on two parameters, see Eq. (6). To maintain this behavior and increase the computational efficiency of finding a new size function, in this section we present a simplification that decouples the two previous properties using two independent parameters ε and δ. That is, we compute the approximated size-preserving size function, 
                        
                           
                              
                                 h
                              
                              
                                 ˆ
                              
                           
                           (
                           x
                           )
                        
                     , by imposing the following two conditions.
                        
                           (i)
                           
                              Maximum gradient allowed. The gradient of the new element size function is bounded:
                                 
                                    (8)
                                    
                                       |
                                       ∇
                                       
                                          
                                             h
                                          
                                          
                                             ˆ
                                          
                                       
                                       (
                                       x
                                       )
                                       |
                                       ⩽
                                       ε
                                       ,
                                    
                                 
                              
                           

where ε is the maximum gradient allowed.


                              The measure of local minima in the element size function. For each local minima, x
                              0, of the size function h(x), the measure of the set of points in which the prescribed element size is h(x
                              0), is at least δh(x
                              0). That is, an element has to fit in its own region. This condition can be expressed as:
                                 
                                    (9)
                                    
                                       
                                          
                                             h
                                          
                                          
                                             ˆ
                                          
                                       
                                       (
                                       x
                                       )
                                       =
                                       
                                          min
                                       
                                       {
                                       h
                                       (
                                       x
                                       )
                                       ,
                                       h
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             0
                                          
                                       
                                       )
                                       }
                                       ,
                                       
                                       ∀
                                       x
                                       ∈
                                       
                                          
                                             B
                                          
                                          
                                             δ
                                             
                                             h
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   0
                                                
                                             
                                             )
                                          
                                       
                                       (
                                       
                                          
                                             x
                                          
                                          
                                             0
                                          
                                       
                                       )
                                       .
                                    
                                 
                              
                           

The condition of the maximum gradient allowed, Eq. (8), limits the ratio between the element size of neighboring elements. Therefore, prescribing an upper bound of this value facilitates the generation of a high-quality mesh. As a rule of thumb, the quality of the final mesh is increased as the maximum gradient allowed is decreased. Similar to the gradient-limiting method, to generate high-quality meshes, we should select ε
                     ⩽1. Even if this condition is verified, the final mesh may not capture small values in the size function. To solve this issue, we introduce the measure of local minima condition (9). Specifically, this condition ensures that small element sizes are present in the final mesh. To illustrate the combined effect of conditions (8) and (9), Fig. 6
                      shows a local minimum of a size function for a one dimensional case. In order to ensure that an element of the prescribed size, h
                     0, can be held in the local minimum we have imposed that the measure, d, of the new size function around the local minimum has to be at least δh(x
                     0).
                        Remark 4
                        To obtain a mesh that correctly preserves the original size function, it is recommended to use δ
                           ⩾1 and ε
                           ⩽1.

To illustrate the behavior of the approximated size-preserving size functions we present several size functions computed using different values of parameter ε, Fig. 7
                     (a), and different values of parameter δ, Fig. 7(b). Note that as the ε parameter increases, the maximum gradient also increases, and as the δ parameter increases, the width of the area around the minima point also increases.


                     Fig. 8
                     (a) presents the approximated size-preserving size function computed from the original size function (1) using δ
                     =1 and ε
                     =1. Note that the region around the minimum has been automatically enlarged in order to hold an element of the requested size, and the gradient of the size functions has been bounded to facilitate the generation of a high-quality mesh. Therefore, this simplified approach emulates, by construction, the behavior of the size-preserving function.


                     Fig. 8(b) presents the ratio R(e), see Eq. (4), for the meshes generated using the original, the gradient-limiting, the size-preserving and the approximated size-preserving functions. Note that the mesh generated using the approximated approach correctly captures the low element size. However, there is an element that is 50% larger than the prescribed size. The main reason is that it is an approximated approach and, for this reason, this method cannot ensure a mesh that correctly preserves the original size function.

The proposed procedure to generate an approximated size-preserving size function can be interpreted in terms of the method presented in [12]. Specifically, in this reference the author claims that the gradient-limiting size function is the steady-state solution of
                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         ∂
                                                         h
                                                      
                                                      
                                                         ∂
                                                         t
                                                      
                                                   
                                                   +
                                                   |
                                                   ∇
                                                   h
                                                   |
                                                   =
                                                   
                                                      min
                                                   
                                                   (
                                                   |
                                                   ∇
                                                   h
                                                   |
                                                   ,
                                                   g
                                                   )
                                                   ,
                                                
                                                
                                                   (
                                                   x
                                                   ,
                                                   t
                                                   )
                                                   ∈
                                                   Ω
                                                   ×
                                                   I
                                                   ,
                                                
                                             
                                             
                                                
                                                   h
                                                   (
                                                   x
                                                   ,
                                                   t
                                                   )
                                                   
                                                      
                                                         |
                                                      
                                                      
                                                         t
                                                         =
                                                         0
                                                      
                                                   
                                                   =
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         0
                                                      
                                                   
                                                   (
                                                   x
                                                   )
                                                   ,
                                                
                                                
                                                   x
                                                   ∈
                                                   Ω
                                                   ,
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where g function defines the maximum gradient allowed at each point of the domain, Ω, and 
                           
                              
                                 
                                    h
                                 
                                 
                                    0
                                 
                              
                              (
                              x
                              )
                           
                         is the original size function. Note that Eq. (10) is related to level set methods, see [16] for details. In addition, Ref. [12] proposes several fast methods to solve Eq. (10).

The approximated size-preserving size function can be interpreted by defining g
                        =0 around local minima and g
                        =
                        ε elsewhere. The approximated size-preserving size distribution could be obtained in two steps. First, a maximum gradient function g is computed at the nodes of the background mesh according to Algorithm 3. Second, an approximated size-preserving size function is obtained by solving Eq. (10) using any of the algorithms detailed in [12].
                           Algorithm 3
                           Maximum gradient function 
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                Return: g(n
                                                0), for all nodes 
                                                   
                                                      
                                                         
                                                            n
                                                         
                                                         
                                                            0
                                                         
                                                      
                                                      ∈
                                                      M
                                                   
                                                
                                             
                                          
                                          
                                             1:
                                             
                                                function 
                                                Maximum gradient function (Mesh 
                                                   
                                                      M
                                                   
                                                , Real ε, Real δ)
                                          
                                          
                                             2:
                                             
                                                
                                                for all node 
                                                   
                                                      
                                                         
                                                            n
                                                         
                                                         
                                                            0
                                                         
                                                      
                                                      ∈
                                                      M
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             3:
                                             
                                                
                                                g(n
                                                0)←
                                                ε
                                             
                                          
                                          
                                             4:
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             5:
                                             
                                                
                                                for all node 
                                                   
                                                      
                                                         
                                                            n
                                                         
                                                         
                                                            0
                                                         
                                                      
                                                      ∈
                                                      M
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             6:
                                             
                                                
                                                if isLocalMinimum (n
                                                0) then
                                             
                                          
                                          
                                             7:
                                             
                                                
                                                
                                                g(n
                                                0)←0
                                          
                                          
                                             8:
                                             
                                                
                                                
                                                for all node n at distance less than δ h(x
                                                0)/2 do
                                             
                                          
                                          
                                             9:
                                             
                                                
                                                
                                                g(n)←0
                                          
                                          
                                             10:
                                             
                                                
                                                
                                                end for
                                             
                                          
                                          
                                             11:
                                             
                                                
                                                end if
                                             
                                          
                                          
                                             12:
                                             
                                                
                                                end for
                                             
                                          
                                          
                                             13:
                                             
                                                end function
                                             
                                          
                                       
                                    
                                 
                              
                           

This section presents five examples in order to illustrate the behavior of the size-preserving and the approximated size-preserving size functions. Both functions have been successfully implemented in the ez4u meshing environment [17–19]. The first example shows the advantages of using the size-preserving size function in an adaptive process. The second one illustrates the applicability of the proposed methods to generate a one-dimensional mesh using an advancing front technique. The remaining examples deal with multi-dimensional mesh generation problems. The third example is a 2D application where quadrilateral meshes are generated using the algorithm presented in [8]. The fourth example shows the mesh generated for a complex 2D size function defined using an MRI image. Finally, the fifth example presents a three dimensional hexahedral mesh generated using the receding front method [20,21].


                        
                           Algorithm 4
                           Adaptive process 
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                Return: Mesh 
                                                   
                                                      M
                                                   
                                                
                                             
                                          
                                          
                                             1:
                                             
                                                function 
                                                AdaptiveProcess
                                             
                                          
                                          
                                             2:
                                             
                                                Mesh 
                                                   
                                                      M
                                                   
                                                
                                                ←
                                                createUniformMesh
                                             
                                          
                                          
                                             3:
                                             
                                                BackgroundMesh bm
                                                ←
                                                estimateNewElementSize
                                                
                                                   
                                                      (
                                                      M
                                                      ,
                                                      sizeFunction
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             4:
                                             
                                                
                                                processBackgroundMesh(bm)
                                                ▷none, grad-lim, size-pres.
                                          
                                          
                                             5:
                                             
                                                Boolean converged
                                                ←
                                                checkConvergence
                                                
                                                   
                                                      (
                                                      M
                                                      ,
                                                      bm
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             6:
                                             
                                                
                                                while not 
                                                converged 
                                                do
                                             
                                          
                                          
                                             7:
                                             
                                                
                                                
                                                   
                                                      M
                                                      ←
                                                   
                                                 
                                                createNewMesh
                                                
                                                   
                                                      (
                                                      M
                                                      ,
                                                      bm
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             8:
                                             
                                                BackgroundMesh bm
                                                ←
                                                estimateNewElementSize
                                                
                                                   
                                                      (
                                                      M
                                                      ,
                                                      sizeFunction
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             9:
                                             
                                                
                                                processBackgroundMesh(bm) 
                                                ▷none, grad-lim, size-pres.
                                          
                                          
                                             10:
                                             
                                                Boolean converged
                                                ←
                                                checkConvergence
                                                
                                                   
                                                      (
                                                      M
                                                      ,
                                                      bm
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             11:
                                             
                                                
                                                end while
                                             
                                          
                                          
                                             12:
                                             
                                                end function
                                             
                                          
                                       
                                    
                                 
                              
                           

The objective of this example is to show that the proposed size-preserving approach can decrease the number of iterations of an adaptive process. To this end, we present three different executions of the adaptive process presented in Algorithm 4. We define, for all the executions of the adaptive process, the same analytical element size function:
                           
                              
                                 h
                                 =
                                 
                                    min
                                 
                                 
                                    
                                       
                                          0.25
                                          ,
                                          |
                                          x
                                          -
                                          0.575
                                          |
                                          +
                                          0.25
                                          ·
                                          
                                             
                                                10
                                             
                                             
                                                -
                                                15
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Note that the minimum element size is 0.25×10−15. First, we create a uniform mesh composed of five elements. From the analytical size function, we will compute a background mesh for each iteration of the adaptive process. The new background mesh is constructed from the mesh of the previous iteration. When the new background mesh is obtained, we generate the next mesh. This process is iterated until the mesh reproduces the analytical size function with a relative error below 0.05. That is, we accept all the elements whose length is, at most, 5% above the prescribed size of the analytical size function.

In the first execution, we do not process the size field with any method. Thus, Lines 4 and 9 of Algorithm 4 are not used. In addition, the mesh generation function is defined as a mid-point subdivision of the elements that do not satisfy the prescribed element size. The process takes 50 iterations to generate the final mesh, see Fig. 9
                        (a). Fig. 9(b) shows the background mesh of the last iteration. Note that the final mesh correctly reproduces the prescribed size function. In Fig. 9(c) we present the ratio R(e). Since the mesh reproduces the size function, all the elements have a ratio below the desired relative error. Finally, Fig. 9(d) presents the logarithm of the maximum ratio R(e) for each iteration. Note that the algorithm divides each element in half and, for this reason, the logarithm of R(e) decreases linearly. Thus, the number of iterations is proportional to the ratio between the element size of the initial mesh and the desired element size.

In the second execution, we process the background mesh using a gradient limiting technique, ε
                        =0.8, see Lines 4 and 9 of Algorithm 4. The mesh for each iteration is generated using an advancing front technique. In this example, the adaptive process has not converged in 200 iterations. Fig. 10
                        (a) and (b), show the mesh and the background mesh for the last (200th) iteration, respectively. Fig. 10(c) presents the R(e) ratio for each element. Note that in the region where a small size has been prescribed, the elements are almost four times bigger than the requested size. Finally, Fig. 10(d) shows the logarithm of the R(e) ratio for each iteration. Note that the process is not able to converge to the required mesh. The main reason is that it is not possible to guarantee that, at each iteration, the size field on the background mesh is correctly preserved.

In the last execution, we have processed the background mesh using the proposed size-preserving algorithm with α
                        =1.25, see Lines 4 and 9 of Algorithm 4. In each iteration, the whole mesh is re-generated using an advancing front method. Fig. 11
                        (a) and (b) show the generated mesh and the used background mesh at the last iteration, respectively. Fig. 11(c) shows the R(e) ratio for each element of the final mesh. Note that the mesh correctly reproduces the analytical size function. Finally, Fig. 11(d) shows the logarithm of the R(e) ratio for each iteration. Note that the adaptive process only takes 17 iterations to converge because at each iteration, the used background mesh is correctly reproduced.

In this example we present a sinusoidal size function defined in the [0,1] interval, centered at 0.3 with amplitude and period equal to 0.2 and 0.5, respectively. Thus, the minimum element size is 0.1 and maximum element size is 0.5. In Fig. 12
                         we represent the original size function with a thick solid line, the modified size functions with dashed lines and the corresponding node distributions with thin solid lines.


                        Fig. 12(a) plots the original size function and the node distribution obtained using it. Note that the final mesh does not reproduce the prescribed element size. Fig. 12(b) displays the gradient-limiting size function (using ε
                        =1), and the corresponding node distribution. Although the mesh better reproduces the element size function, it does not generate sufficiently small elements around the minima points of the size function. To generate a mesh that correctly preserves the element size, we compute a size-preserving function with α
                        =1), Fig. 12(c). Note that the size-preserving function presents two features. First, it increases the width of the areas around small element sizes. Second, the gradient of the new size function is limited. These two features allow the generation of a high-quality mesh that correctly reproduces the original size function and captures the minimum element sizes. Finally, we compute an approximated size-preserving size function with parameters ε
                        =1 and δ
                        =1, see Fig. 12(d). In this case, the final mesh correctly captures the minimum element sizes. However, there are some elements that are slightly bigger than the prescribed element size.

In Fig. 13
                        , we present the ratio R(e) for the meshes generated using: the original, the gradient-limiting, the size-preserving, and the approximated size-preserving size functions. Note that only the mesh generated using the size-preserving size function verifies Eq. (5) and correctly preserves the element size. While the mesh generated using approximated size-preserving size function correctly captures the areas of low-element sizes, it generates elements bigger than the requested size. Note that the meshes obtained using the original and the gradient-limiting techniques do not preserve the element size.

In the third example we present the meshes generated using a two dimensional background mesh defined on the [0,1]×[0,1] domain. The original size function is defined as a Cartesian product of two sinusoidal functions. The minimum and maximum element sizes are 0.1 and 1.0, respectively, see Fig. 14
                           (a). To fairly compare the size-preserving and the approximated size-preserving size functions, we have used comparable values for the parameters of the different size functions. That is, we have used ε
                           =1/α and δ
                           =2α. To illustrate the behavior of the three methods, in Fig. 14, we have colored the elements according to their R(e) ratio.


                           Fig. 14(b) presents the mesh generated using a gradient-limiting technique (ε
                           =0.5). Note that the final mesh does not correctly reproduce the initial size function. The elements created in the areas where a small size is prescribed are not small enough. In order to obtain a mesh that preserves the element size, we use a size-preserving size function, with α
                           =2. Fig. 14(c) shows the final mesh generated using it. In this case, the final mesh correctly captures all the features of the initial size function. Finally, an approximated size-preserving size function approach is used (ε
                           =0.5 and δ
                           =4) to generate the mesh, see Fig. 14(d). While the final mesh provides better results than the gradient-limiting approach, some elements are 21% bigger than the requested size.


                           Table 1
                            summarizes the statistics for the meshes generated using the different size functions. Note that the lowest percentage of correct faces according to the prescribed element size is achieved when the gradient-limiting technique is used. The percentage of correct faces according to the prescribed element size is similar when using the size-preserving and the approximated size-preserving techniques, although it is slightly higher when using the former. The new techniques reduce the maximum value of the ratio R(e). In particular, the size-preserving size function achieves a reduction of R(e) above the 33%. Although the approximated size-preserving approach is able to reduce the ratio R(e), it is not able to obtain comparable results to the size-preserving technique. It is worth to notice that the computational cost required to compute the new size function using an approximated size-preserving approach is similar to the computational cost to compute a gradient-limited size function. However, the CPU time required to compute the size-preserving size function is significantly greater than the time required to compute the approximated size-preserving size function.

In this example, we present a quadrilateral mesh generated using a size field derived from an MRI image, courtesy of the OASIS project [22], see Fig. 15
                           (a). The size field is defined in terms of the mean curvature of the MRI field, in order to generate more elements where the variation of the gradient of the MRI field is higher, see Fig. 15(b). With this background mesh, we have generated three meshes. In each mesh, we have computed the interpolation error of the initial MRI field on the corresponding mesh, and the ratio R(e) for the elements. The first mesh is obtained with the gradient-limiting technique. Fig. 16
                           (a) shows the interpolation error of the MRI field on the mesh, and Fig. 16(b) presents the ratio R(e) for the elements. Note that there are elements that are almost 75% bigger than the requested size. The second mesh is obtained using the size-preserving approach. In this case, the results present a reduced interpolation error (Fig. 17
                           (a)), and ratio R(e) (Fig. 17(b)). Finally, the third mesh is obtained using the approximated size-preserving approach. In this case, the results are better than the ones obtained with the gradient-limiting approach, but not as good as the ones obtained with the size-preserving approach, see Fig. 18
                           .


                           Table 2
                            summarizes the statistics for the meshes generated with the different size functions. The behavior of the size functions is similar to the ones reported in the previous example. The gradient-limiting technique, although fast is not able to reproduce the initial size function, obtaining the highest ratio R(e) and the lowest percentage of correct faces. Specifically, there are elements that are almost 75% percent bigger than the requested size. The mesh obtained with the size-preserving approach presents the lowest ratio R(e) and the maximum percentage of correct faces. In this case, 99.99% percent of the faces are correct, and the maximum ratio R(e) is around 1.03. Finally, the approximated size-preserving method is faster than the size-preserving approach and obtains more correct faces and lower ratios R(e) than the gradient-limiting. However, it is slightly slower than gradient-limiting and obtains less correct faces than the size-preserving method.

The last example presents the hexahedral mesh generated for the exterior domain of a sphere using the receding front method [21]. The radius of the inner sphere is 1 unit and the radius of the outer sphere is 4 units. The center of both spheres is the origin of coordinates. The receding front method first pre-computes a set of levels and then, the final mesh is generated according to these levels. In this example, the levels of the mesh in the radial direction are generated using the size function
                              
                                 
                                    h
                                    =
                                    
                                       min
                                    
                                    
                                       
                                          
                                             0.25
                                             ,
                                             
                                                
                                                   |
                                                   r
                                                   -
                                                   2.575
                                                   |
                                                
                                                
                                                   3
                                                
                                             
                                             +
                                             0.0025
                                          
                                       
                                    
                                    
                                    r
                                    ∈
                                    [
                                    1
                                    ,
                                    4
                                    ]
                                    ,
                                 
                              
                           where r is the distance to the origin. In order to properly capture the size function in the radial direction, we pre-process this function according to the size-preserving method and the levels are generated accordingly. Then, a refining process is performed in order to generate isotropic hexahedral elements, see [23,24] for more information. Finally, the mesh is smoothed to obtain high-quality elements. Fig. 19
                           (a) shows a general view of the final mesh, while Fig. 19(b) presents a detailed view. Note that the elements are concentrated around a ring between the inner and the outer boundaries. The main advantage is that we have decoupled the element size related to the radial direction and the element size related to the tangential direction. In the radial direction, a size-preserving technique is applied, while in the tangential direction a local refinement technique is performed. The final mesh contains high-quality elements that reproduce the element size function.

@&#CONCLUSIONS@&#

In this paper, we have presented two new methods for computing good element size functions. They modify the original size function, and allow any mesh generation algorithm to generate meshes that preserve the original size function. For this reason, they facilitate the generation of quadrilateral and hexahedral meshes, since it is not required to refine them to reproduce the initial size function. Moreover, these methods can potentially reduce the number of iterations of an adaptive process, since the prescribed size field is correctly reproduced in each iteration.

The first method, called size-preserving size function, depends on two parameters. It computes the size-preserving size function by solving a non-linear equation. The proposed algorithm modifies the size function at each node of a background mesh ensuring that an element can be held in that area and, at the same time, limits the maximum gradient of the new size function. We have shown that to generate a mesh that preserves the original size function, it is recommended to use β
                     ⩽1 and α
                     ⩾
                     β.

In the second method, we simplify the size-preserving approach in order to obtain a new size function with faster computational times while obtaining similar properties. To this end, we decouple the calculation of the measure of local minima in the element size area of the maximum gradient allowed using two parameters. We have shown that to generate a mesh that preserves the original size function, it is recommended to use δ
                     ⩾1 and ε
                     ⩽1.

The results obtained with the size-preserving method using a parameter α are of equivalent accuracy as the ones obtained with an approximated size-preserving size function using parameters δ
                     =2α and ε
                     =1/α. However, it is not guaranteed that the meshes generated using an approximated size-preserving method correctly preserve the initial size function. For this reason, in some cases it is better to use the size-preserving technique, although the computational requirements are higher. Note that the proposed algorithms to compute the size-preserving and the approximated size-preserving size functions can be directly applied to meshes of any dimension.

Several aspects of the proposed method can be extended in the near future. For instance, we use an edge-based solver to compute the new size functions. Although more expensive from the computational point of view, it could be interesting to analyze the solutions provided by Hamilton–Jacobi solvers, since they are more accurate. In addition, the ideas presented in this work can be extended to anisotropic size fields. This implies to work with an anisotropic metric, and modify some aspects of the proposed algorithms.

@&#REFERENCES@&#

