@&#MAIN-TITLE@&#An integer programming approach for solving the p-dispersion problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Discuss relationship between the p-dispersion problem and a node packing problem.


                        
                        
                           
                           Design an exact algorithm for solving the p-dispersion problem.


                        
                        
                           
                           Demonstrate effectiveness of the proposed method through a computational study.


                        
                        
                           
                           Application of the problem in locating traffic sensors on a highway network.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Location problem

Max–min diversity

Integer programming

Traffic sensor location

@&#ABSTRACT@&#


               
               
                  Given a collection of n items (elements) and an associated symmetric distance dij
                      between each pair of items i and j, we seek a subset P of these items (with a given cardinality p) so that the minimum pairwise distance among the selected items is maximized. This problem is known as the max–min diversity problem or the p-dispersion problem, and it is shown to be np-hard. We define a collection of node packing problems associated with each instance of this problem and employ a binary search among these node packing problems to devise an effective procedure for solving the original problem. We employ existing integer programming techniques, i.e., branch-and-bound and strong valid inequalities, to solve these node packing problems. Through a computational experiment we show that this approach can be used to solve relatively large instances of the p-dispersion problem, i.e., instances with more than 1000 items. We also discuss an application of this problem in the context of locating traffic sensors in a highway network.
               
            

@&#INTRODUCTION@&#

We consider the problem of selecting a subset P (of size p) of items (elements) from a given collection N (of size n) so as to maximize diversity among the selected elements. Typically there is a characteristic vector 
                        
                           
                              s
                              i
                           
                           =
                           
                              (
                              
                                 s
                                 
                                    i
                                    1
                                 
                              
                              ,
                              
                                 s
                                 
                                    i
                                    2
                                 
                              
                              ,
                              …
                              ,
                              
                                 s
                                 
                                    i
                                    K
                                 
                              
                              )
                           
                        
                      associated with each element i in this collection, where sik
                      represents the state or the value of the kth attribute of this element, and the difference between two elements i and j is defined as a normed distance dij
                      between their corresponding characteristic vectors. For example, by a Euclidean distance measure we have 
                        
                           
                              d
                              
                                 i
                                 j
                              
                           
                           =
                           
                              
                                 
                                    ∑
                                    
                                       k
                                       =
                                       1
                                    
                                    K
                                 
                                 
                                    
                                       (
                                       
                                          s
                                          
                                             i
                                             k
                                          
                                       
                                       −
                                       
                                          s
                                          
                                             j
                                             k
                                          
                                       
                                       )
                                    
                                    2
                                 
                              
                           
                        
                     .

As stated in Kuo, Glover, and Dhir (1993) and (Resende, Marti, Gallego, & Duarte, 2010), there are basically two approaches to formulate this problem: the max-sum model and the max–min model. In the max-sum model the objective is to maximize the summation of all pairwise distances between the selected elements in the set P, while in the max–min model the objective is to maximize the minimum pairwise distance among these elements. Resende et al. (2010) refer to the former as the maximum diversity problem (MDP) and to the latter as themax–min diversity problem (MMDP). Both models have numerous applications and they have been the subject of several research articles in the past few decades. The former problem (MDP) has been studied in Kuby (1987); Kuo et al. (1993), and Pisinger (2006), while the latter (MMDP) is addressed in Erkut (1990); Kuby (1987), and Resende et al. (2010). Based on these studies it appears that from the point of view of their computational requirements MDP (max-sum) problem is somewhat easier to solve, but as argued in Kuo et al. (1993) the notion of diversity is better achieved through the max–min criterion (MMDP).

In this paper we address the max–min diversity problem (MMDP), which is also known as the p-dispersion problem (Erkut, 1990 and Resende et al., 2010). More specifically, for each subset P of N we define its associated minimum dispersion, denoted by Φ(P), as the smallest distance dij
                      between any pair of elements i and j in this set, i.e., 
                        
                           Φ
                           
                              (
                              P
                              )
                           
                           =
                           min
                           
                              
                              
                                 
                                    
                                       
                                          i
                                          ,
                                          j
                                          ∈
                                          P
                                       
                                    
                                 
                                 
                                    
                                       
                                          i
                                          ≠
                                          j
                                          
                                          
                                       
                                    
                                 
                              
                           
                           
                              {
                              
                                 d
                                 
                                    i
                                    j
                                 
                              
                              }
                           
                        
                     . The p-dispersion problem is then defined as the problem of finding a subset P, with a given cardinality p, that has the largest associated minimum dispersion Φ(P) among all such subsets.

The p-dispersion problem arises in a number of well documented applications in various fields. Moon and Chaudhry (1984) discuss its application in several network location problems. Erkut (1990) discusses its application in selecting the location of missile silos as well as in selecting locations for branches of a chain (franchise) so as to minimize mutual competition between similar shops or service stations. Pisinger (2006) discusses the application of this problem in telecommunications, such as in selecting locations for radio trans-receivers to service cellular phones in order to minimize interference. Kuo et al. (1993) discuss applications of this problem in several contexts such as in market planning (Keely & Ann, 1989), plant breeding (Porter, Rawal, Rachie, Wien, & William, 1975), social problems (Swierenga, 1977), and locating polluting industry (Dasarathy & White, 1980), among others.

We encountered this problem in the context of a traffic network where we wish to select a collection of locations to install weigh-in-motion sensors so as to obtain (collect) diverse information about the nature of traffic in the network. Due to budget constraints we limit the total number of sensors to p, and we wish to select p locations for these sensors (from among a given collection of n potential locations on the network) so as to maximize diversity in the collected traffic data. To this end, as discussed in Sayyady, Stone, List, Jadoun, and Kim (2013), maximizing the minimum truck traffic dissimilarity among the selected locations would be an appropriate objective function. We shall further discuss this application in Section 5.

In theory, solving the p-dispersion problem is relatively straightforward since it has only a finite number of feasible solutions, i.e., we can enumerate all possible subsets of p elements in the set N and select the subset that has the largest minimum dispersion. But the computational requirements of this approach can be prohibitively large even for relatively small instances of the problem, i.e., instances with relatively small values of n and p. Hence there is a need to develop computationally effective algorithms for solving the problem. As we discuss in the next section, several approaches for solving this problem are proposed in the open literature, and it is shown that these approaches can be employed to effectively solve relatively small to medium size instances of the problem (i.e., with n ≤ 80) within a reasonable execution time. But the computational requirements of these methods become excessive for larger instances of the problem.

In this paper we propose an alternative approach for solving the p -dispersion problem and show that this approach can be used to solve larger instances of the problem (e.g., with 
                        
                           n
                           =
                           1000
                        
                     ) within a reasonable execution time. The approach that we employ is based on the strong relationship between the p-dispersion problem and a corresponding node packing problem (Nemhauser, George, & Wolsey, 1988), and we employ existing methods for solving the latter problem to solve the former.

In Section 2 we review the related literature and discuss several methods that are previously proposed for solving the p-dispersion problem. In Section 3 we discuss the relationship between the p-dispersion problem and a corresponding maximum cardinality node-packing problem. We then use this relationship to devise an exact procedure for solving the p-dispersion problem. In Section 4 we present the results of a computational experiment with the proposed method and show that the resulting procedure is indeed effective in solving relatively large instances of the problem. In Section 5 we discuss the application of this problem in the context of determining a set of locations for traffic sensors within the highway network in the state of North Carolina and present our findings. Section 6 contains a few concluding remarks.

@&#BACKGROUND@&#

As stated above the p-dispersion problem is defined for a collection N of n elements and a given measure of distance dij
                      between each pair of elements i and j in this set. We assume that this distance measure is symmetric, i.e., 
                        
                           
                              d
                              
                                 i
                                 j
                              
                           
                           =
                           
                              d
                              
                                 j
                                 i
                              
                           
                        
                      for all i and j, and we use D to represent the corresponding n by n symmetric matrix. The p-dispersion problem is now defined as the problem of finding a subset P of N, with a given cardinality p, that has the largest associated minimum dispersion Φ(P) among all such subsets. Input for this problem is the n × n matrix D and an integer p < n, and output is the set P .


                     Erkut (1990) and Ghosh (1996) show that the p -dispersion problem is np-hard. Erkut and Neuman (1989) also emphasized the complexity of the p-dispersion problem in their survey paper on location problems with maximization objectives. Hence the computational requirements of any algorithm for solving large instances of this problem is likely to be excessive. Yet, attempts have been made to design effective models and algorithms for solving moderate size instances of the problem. Also heuristic procedures with smaller computational requirements are developed to obtain near optimal solutions for larger instances of the problem. In this section we review these previous approaches and discuss their capabilities and limitations. We also introduce definitions and terminology that we employ in subsequent sections.

We start by presenting a mathematical programming model for the p -dispersion problem. Associated with each element i ∈ N we define a decision variables 
                        
                           
                              y
                              i
                           
                           =
                           1
                        
                      if element i is selected to be in the set P , and 
                        
                           
                              y
                              i
                           
                           =
                           0
                        
                      otherwise. The p-dispersion problem can now be stated as the following mathematical programming model.

                        
                           (IQP)
                           
                              
                                 
                                    
                                       
                                          Maximize
                                          
                                          
                                          
                                          
                                          r
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          M
                                          i
                                          n
                                          i
                                          m
                                          u
                                          
                                             m
                                             
                                                i
                                                ≠
                                                j
                                             
                                          
                                          
                                          
                                             {
                                             
                                                d
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                y
                                                i
                                             
                                             
                                                y
                                                j
                                             
                                             }
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          Subject
                                          
                                          to
                                          
                                          
                                          
                                          
                                       
                                    
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                N
                                             
                                          
                                          
                                             y
                                             i
                                          
                                          =
                                          p
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             y
                                             i
                                          
                                          =
                                          0
                                          
                                          or
                                          
                                          1
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ∈
                                          N
                                       
                                    
                                 
                              
                           
                        
                     Let 
                        
                           r
                           
                              p
                           
                           
                              o
                              p
                              t
                           
                        
                      denote the optimal value of the objective function for this model. Kuby (1987) writes this model as the following equivalent integer linear programming (ILP) model.

                        
                           (ILP1)
                           
                              
                                 
                                    
                                       
                                          
                                             r
                                             
                                                p
                                             
                                             
                                                o
                                                p
                                                t
                                             
                                          
                                          =
                                       
                                    
                                    
                                    
                                       
                                          Maximize
                                          
                                          
                                          
                                          r
                                       
                                    
                                 
                                 
                                    
                                       
                                          Subject
                                          
                                          to
                                          
                                          
                                          
                                          r
                                       
                                    
                                    
                                    
                                       
                                          ≤
                                          M
                                          
                                             (
                                             2
                                             −
                                             
                                                y
                                                i
                                             
                                             −
                                             
                                                y
                                                j
                                             
                                             )
                                          
                                          +
                                          
                                             d
                                             
                                                i
                                                j
                                             
                                          
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ,
                                          j
                                          ∈
                                          N
                                          ,
                                          
                                          i
                                          <
                                          j
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                N
                                             
                                          
                                          
                                             y
                                             i
                                          
                                          =
                                          p
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                             y
                                             i
                                          
                                          =
                                          0
                                          
                                          or
                                          
                                          1
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ∈
                                          N
                                       
                                    
                                 
                              
                           
                        
                     Our computational experiments show that this model can be employed to solve relatively small to medium size instances of the problem (with n ≤ 100) within a reasonable execution time (less than 90 minutes) using a general integer programming (IP) solver such as CPLEX (ILOG, 2011). But the computational requirements of this approach become excessive as the size of the problem grows larger. Kuo et al. (1993) offer a different ILP model for this problem which is somewhat more effective than the above model. But the computational requirements of solving this model also grow prohibitively large as the number of nodes reaches 
                        
                           n
                           =
                           150
                        
                     . In Section 4.1 we discuss the computational requirements associated with these two models in more detail.
                  


                     Erkut (1990) mentions a strategy for solving the p-dispersion problem by using its relationship with the maximal clique problem and with a related IP model that he refers to as the r-separation problem. He then outlines a binary search strategy on the value of r in this context which is quite similar to the approach that we propose here, and it requires solving a sequence of ILP models for the r-separation problem for different values of r. Subsequently he discusses earlier attempts to solve this ILP model via standard branch-and-bound techniques that employ its LP relaxation, and reports disappointing computational results (Chaudhry, McCormick, & Moon, 1986). Erkut (1990) refrains from fully developing this approach. Instead, he proceeds to develop a separate branch-and-bound scheme for solving the p-dispersion problem and carries out a computational experiment to show its effectiveness. He reports a typical computation time of 14 seconds for an instance with 
                        
                           n
                           =
                           30
                           ,
                        
                      and the execution time rapidly grows to half an hour for an instance with 
                        
                           n
                           =
                           40
                        
                      . Erkut (1990) also develops a constructive (greedy) heuristic for solving larger instances of the problem.

Later other authors also observe the relationship between the p-dispersion problem and the maximal clique problem and use this relationship to develop effective procedures for solving the problem. Pisinger (2006) re-state this maximal clique problem as a dense subgraph problem and use a branch-and-bound algorithm that they develop for MDP to solve this dense subgraph problem. They report computational results using this approach for a collection of instances of size n ≤ 80, and the corresponding execution time nears its upper limit of 90 minutes for each of the larger instances. Croce, Federico, and Locatelli (2009) follows up on this approach by employing a heuristic procedure to solve the corresponding maximum clique problem. The resulting procedure is a heuristic (inexact) method for solving the p-dispersion problem. A key difference between these approaches and the approach that we propose here is that instead of solving the maximum clique problem, either exactly as in Pisinger (2006) or heuristically as in Croce et al. (2009), we focus on the associated node packing problem which is structurally similar to the maximum clique problem, and employ an integer programming approach to solve this problem and obtain its optimal solution.


                     Ghosh (1996) observes a similar relationship between the p -dispersion problem and a 0–1 quadratic programming problem with a corresponding threshold value z. He then employs a line search on the value of z and solves a sequence of integer quadratic programming models to obtain an optimal solution for the original p-dispersion problem. Ghosh (1996) reports computational results using this approach with n ≤ 40. He also develops a greedy randomized adaptive search procedure (GRASP) and shows its effectiveness by solving a collection of instances of size n ≤ 40. More recently Resende et al. (2010) also propose a GRASP for this problem in which they employ path relinking strategies and show that the resulting procedure compares favorably to previous heuristic methods for this problem. Kincaid (1992) develops a simulated annealing as well as a tabu search procedure for solving the p-dispersion problem and employs these methods to solve relatively small instances of the problem (n ≤ 33). Ravi, Rosenkrantz, and Tayi (1994) investigate the structure of the problem and offer heuristics and special case algorithms for this problem, and Chaudhry et al. (1986) offer greedy heuristic procedures in this context.

In this paper we employ the relationship between the p-dispersion problem and a related node packing problem. This relationship has similarities with the relationships outlined in Erkut (1990); Pisinger (2006), and Croce et al. (2009), as we discussed above. We then employ this relationship to develop an exact method for solving the p-dispersion problem. Through a computational experiment in which we use the IP solver CPLEX 11 (ILOG, 2011) and employ various strong valid inequalities for the node packing problem, we show that this method can be used to solve relatively large instances of the problem (e.g. 
                        
                           n
                           =
                           500
                        
                     ) within a relatively low execution time (less than one minute), and that the execution time remains below 90 minutes for instances as large as 
                        
                           n
                           =
                           1000
                        
                     .

@&#METHODOLOGY@&#

The methodology that we employ for solving the p-dispersion problem is based on a close relationship between this problem and a corresponding node packing problem. The node packing problem is defined on an undirected graph 
                        
                           G
                           =
                           (
                           V
                           ,
                           E
                           )
                           ,
                        
                      where the set of vertices (nodes) V is the same as the set of elements N in the p-dispersion problem, i.e., for each element i in the set N we have a vertex (node) vi
                      in V, and the set of edges E depends on a given parameter ℓ. Two nodes vi
                      and vj
                      are connected by an edge in G if (and only if) the distance dij
                      between their corresponding elements is strictly less than ℓ, i.e., 
                        
                           E
                           =
                           {
                           
                              (
                              
                                 v
                                 i
                              
                              ,
                              
                                 v
                                 j
                              
                              )
                           
                           :
                           i
                           ,
                           j
                           ∈
                           N
                        
                      and dij
                      < ℓ}. In order to emphasize this dependence of the edge set E on the parameter ℓ we write it as E(ℓ), and denote the corresponding graph as 
                        
                           G
                           (
                           ℓ
                           )
                           =
                           [
                           V
                           ,
                           E
                           (
                           ℓ
                           )
                           ]
                        
                     . The corresponding node packing problem is now defined as the problem of finding a maximum cardinality subset of nodes in G(ℓ) so that no two nodes in this subset are adjacent to each other. The node packing problem is also known as the stable set problem or the independent set problem (Balas & Yu, 1986). Obviously the optimal value of this problem, i.e., the size of the corresponding maximum cardinality subset of non-adjacent nodes, would depend on the parameter ℓ, thus we denote it by 
                        
                           υ
                           (
                           ℓ
                           )
                        
                     . It is also clear that 
                        
                           υ
                           (
                           ℓ
                           )
                        
                      is a non-increasing function of ℓ, with 
                        
                           υ
                           (
                           0
                           )
                           =
                           n
                        
                      and 
                        
                           υ
                           (
                           ∞
                           )
                           =
                           1
                        
                     . Indeed if we let 
                        
                           
                              d
                              min
                           
                           =
                           
                              min
                              
                                 
                                    
                                       
                                          i
                                          ,
                                          j
                                          ∈
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          i
                                          ≠
                                          j
                                          
                                          
                                       
                                    
                                 
                              
                           
                           
                              {
                              
                                 d
                                 
                                    i
                                    j
                                 
                              
                              }
                           
                        
                      and 
                        
                           
                              d
                              max
                           
                           =
                           
                              max
                              
                                 
                                    
                                       
                                          i
                                          ,
                                          j
                                          ∈
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          i
                                          ≠
                                          j
                                          
                                          
                                       
                                    
                                 
                              
                           
                           
                              {
                              
                                 d
                                 
                                    i
                                    j
                                 
                              
                              }
                           
                        
                      we have 
                        
                           υ
                           (
                           ℓ
                           )
                           =
                           n
                        
                      for all ℓ ≤ d
                     min , and 
                        
                           υ
                           (
                           ℓ
                           )
                           =
                           1
                        
                      for all ℓ > d
                     max .

Using the same decision variables as we defined earlier, i.e., 
                        
                           
                              y
                              i
                           
                           =
                           1
                        
                      if element (node) i is selected, and 
                        
                           
                              y
                              i
                           
                           =
                           0
                        
                      otherwise, this problem can be written as the following integer linear programming model that we refer to as ILP-ℓ.

                        
                           (ILP
                                 
                                    −
                                    ℓ
                                 
                              )
                           
                              
                                 
                                    
                                       
                                          υ
                                          (
                                          ℓ
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          Maximize
                                          
                                          
                                          
                                             ∑
                                             
                                                i
                                                ∈
                                                N
                                             
                                          
                                          
                                             y
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          Subject
                                          
                                          to
                                          
                                          
                                             y
                                             i
                                          
                                          +
                                          
                                             y
                                             j
                                          
                                          ≤
                                          1
                                          
                                          
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ,
                                          j
                                          ∈
                                          N
                                          ,
                                          
                                          i
                                          ≠
                                          j
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                          such
                                          
                                          that
                                          
                                          
                                          
                                             d
                                             
                                                i
                                                j
                                             
                                          
                                          <
                                          ℓ
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          
                                          
                                          
                                             y
                                             i
                                          
                                          =
                                          0
                                          
                                          or
                                          
                                          1
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ∈
                                          N
                                       
                                    
                                 
                              
                           
                        
                     This integer linear programming model has been the subject of several studies in recent years, and effective algorithms are proposed for solving relatively large instances of this problem. For an extensive discussion of this model and several associated families of strong valid inequalities see (Nemhauser et al., 1988). The following proposition describes the relationship between the optimal value of this model, i.e., 
                        
                           υ
                           (
                           ℓ
                           )
                           ,
                        
                      and the optimal value of the original p-dispersion problem 
                        
                           r
                           
                              p
                           
                           
                              o
                              p
                              t
                           
                        
                     .

                        Proposition 1
                        
                           If we have ℓ1 
                           and ℓ2 > ℓ1 
                           such that v(ℓ1) ≥ p and v(ℓ2) < p, it follows that
                           
                              
                                 
                                    ℓ
                                    1
                                 
                                 ≤
                                 
                                    r
                                    
                                       p
                                    
                                    
                                       o
                                       p
                                       t
                                    
                                 
                                 
                                 <
                                 
                                    ℓ
                                    2
                                 
                              
                           
                           .
                        

The fact that for the model ILP-ℓ1 we have v(ℓ1) ≥ p implies that we have a collection of at least p non-adjacent nodes on the graph G(ℓ1). This, in turn, implies that we have a collection of at least p elements in the set N whose minimum pairwise distance is at least ℓ1. It follows that the optimal value of the original p-dispersion problem is at least ℓ1, i.e., 
                              
                                 
                                    r
                                    
                                       p
                                    
                                    
                                       o
                                       p
                                       t
                                    
                                 
                                 
                                 ≥
                                 
                                    ℓ
                                    1
                                 
                              
                           . We also know that at 
                              
                                 ℓ
                                 =
                                 
                                    ℓ
                                    2
                                 
                              
                            the optimal value of model ILP-ℓ is strictly less than p. It follows that in the original p-dispersion problem we cannot identify p elements whose minimum pairwise distance is at least equal to ℓ2 (otherwise such a solution provides a feasible solution for model ILP-ℓ2 with the corresponding objective function value larger than v(ℓ2), which is a contradiction). Thus the minimum pairwise distance for any collection of p elements in N is strictly less than ℓ2, i.e., 
                              
                                 
                                    r
                                    
                                       p
                                    
                                    
                                       o
                                       p
                                       t
                                    
                                 
                                 
                                 <
                                 
                                    ℓ
                                    2
                                 
                              
                           .□

This result allows us to devise an exact procedure for solving the p -dispersion problem as we describe below. We refer to this procedure as Procedure A.

By definition the optimal value of the p-dispersion problem, i.e., 
                           
                              
                                 r
                                 
                                    p
                                 
                                 
                                    o
                                    p
                                    t
                                 
                              
                              ,
                           
                         is equal to the distance between a pair of elements in the set N, i.e., a dij
                         value. In order to identify this dij
                         value and the corresponding solution of the p-dispersion problem we carry out a systematic search in the interval [d
                        min , d
                        max ] to identify two values ℓ1 and ℓ2 > ℓ1 such that the interval [ℓ1, ℓ2) satisfies the conditions stated in Proposition 1 and that it contains only one dij
                         value. It then follows that this dij
                         value is equal to 
                           
                              r
                              
                                 p
                              
                              
                                 o
                                 p
                                 t
                              
                           
                        .

First we construct a sorted list of all dij
                         values. More specifically, for a problem with n elements we have a total of 
                           
                              
                                 n
                                 (
                                 n
                                 −
                                 1
                                 )
                              
                              2
                           
                         pairwise distances ( dij
                         values), although the number of distinct dij
                         values might be smaller. We sort these distinct values in a non-decreasing order that we denote as 
                           
                              
                                 h
                                 1
                              
                              ,
                              …
                              ,
                              
                                 h
                                 
                                    K
                                    −
                                    1
                                 
                              
                           
                         (i.e., 
                           
                              
                                 h
                                 1
                              
                              <
                              
                                 h
                                 2
                              
                              <
                              ⋯
                              <
                              
                                 h
                                 
                                    K
                                    −
                                    1
                                 
                              
                           
                        ). Obviously 
                           
                              K
                              −
                              1
                              ≤
                              
                                 
                                    n
                                    (
                                    n
                                    −
                                    1
                                    )
                                 
                                 2
                              
                           
                        . For notational convenience we introduce an additional value 
                           
                              
                                 h
                                 K
                              
                              =
                              
                                 h
                                 
                                    K
                                    −
                                    1
                                 
                              
                              +
                              
                                 δ
                                 min
                              
                              ,
                           
                         where δ
                        min  is the smallest difference between any pair of distinct dij
                         values, i.e., if we let 
                           
                              
                                 δ
                                 i
                              
                              =
                              
                                 h
                                 
                                    i
                                    +
                                    1
                                 
                              
                              −
                              
                                 h
                                 i
                              
                              ,
                           
                         for 
                           
                              i
                              =
                              1
                           
                         to 
                           
                              K
                              −
                              2
                              ,
                           
                         then 
                           
                              
                                 δ
                                 min
                              
                              =
                              
                                 Minimum
                                 
                                    i
                                    =
                                    1
                                    
                                    to
                                    
                                    K
                                    −
                                    2
                                 
                              
                              
                                 {
                                 
                                    δ
                                    i
                                 
                                 }
                              
                           
                        . We now have the following result.

                           Corollary 2
                           
                              Let hk and
                              
                                 
                                    h
                                    
                                       k
                                       +
                                       1
                                    
                                 
                               
                              be two consecutive values among
                              
                                 
                                    
                                       h
                                       1
                                    
                                    ,
                                    …
                                    ,
                                    
                                       h
                                       K
                                    
                                 
                               
                              such that v(hk
                              ) ≥ p and
                              
                                 
                                    v
                                    (
                                    
                                       h
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                    )
                                    <
                                    p
                                 
                              
                              . It follows that
                              
                                 
                                    
                                       r
                                       
                                          p
                                       
                                       
                                          o
                                          p
                                          t
                                       
                                    
                                    =
                                    
                                       h
                                       k
                                    
                                 
                              
                              .
                           

By definition the value of 
                                 
                                    r
                                    
                                       p
                                    
                                    
                                       o
                                       p
                                       t
                                    
                                 
                               is equal to one of the dij
                               values. By Proposition 1 we know that 
                                 
                                    r
                                    
                                       p
                                    
                                    
                                       o
                                       p
                                       t
                                    
                                 
                               is in the interval 
                                 
                                    [
                                    
                                       h
                                       k
                                    
                                    ,
                                    
                                       h
                                       
                                          k
                                          +
                                          1
                                       
                                    
                                    )
                                 
                              . Since the only dij
                               value in this interval is hk
                              , it follows that 
                                 
                                    
                                       r
                                       
                                          p
                                       
                                       
                                          o
                                          p
                                          t
                                       
                                    
                                    =
                                    
                                       h
                                       k
                                    
                                 
                              .□

From this corollary it follows that for any given instance of the problem we can obtain the value of 
                           
                              r
                              
                                 p
                              
                              
                                 o
                                 p
                                 t
                              
                           
                         by searching among the values 
                           
                              
                                 h
                                 1
                              
                              ,
                              …
                              ,
                              
                                 h
                                 K
                              
                           
                         to find two consecutive values hk
                         and 
                           
                              h
                              
                                 k
                                 +
                                 1
                              
                           
                         that satisfy the stated conditions. Of course for each value hi
                         we need to solve the corresponding model ILP-ℓ with 
                           
                              ℓ
                              =
                              
                                 h
                                 i
                              
                           
                         in order to obtain the value v(hi
                        ). Although solving the integer linear programming model ILP-ℓ is significantly easier than solving the corresponding integer quadratic programming model IQP (or its equivalent integer linear programming model ILP1), the corresponding computational requirement is still relatively large. This computational requirement is particularly burdensome in this case since, in order to find two consecutive values hk
                         and 
                           
                              h
                              
                                 k
                                 +
                                 1
                              
                           
                         that satisfy the stated condition, we need to solve the problem ILP-ℓ more than once. Hence it is critical to keep the number of times that we solve this problem as small as possible. To this end we use a binary search as described below.

Let q be the smallest positive integer such that 
                           
                              
                                 2
                                 
                                    −
                                    q
                                 
                              
                              
                                 (
                                 
                                    h
                                    K
                                 
                                 −
                                 
                                    h
                                    1
                                 
                                 )
                              
                              ≤
                              
                                 δ
                                 min
                              
                              ,
                           
                         and let 
                           
                              δ
                              =
                              
                                 2
                                 
                                    −
                                    q
                                 
                              
                              
                                 (
                                 
                                    h
                                    K
                                 
                                 −
                                 
                                    h
                                    1
                                 
                                 )
                              
                           
                        . We divide the interval [h
                        1, hK
                        ] into 2
                           q
                         equal intervals, each of length δ. Letting 
                           
                              
                                 K
                                 ′
                              
                              =
                              
                                 2
                                 q
                              
                              +
                              1
                              ,
                           
                         we use 
                           
                              
                                 h
                                 
                                    1
                                 
                                 ′
                              
                              ,
                              …
                              ,
                              
                                 h
                                 
                                    
                                       K
                                       ′
                                    
                                 
                                 ′
                              
                           
                         to denote the end points of these intervals, i.e., 
                           
                              
                                 h
                                 
                                    1
                                 
                                 ′
                              
                              <
                              
                                 h
                                 
                                    2
                                 
                                 ′
                              
                              <
                              ⋯
                              <
                              
                                 h
                                 
                                    
                                       K
                                       ′
                                    
                                 
                                 ′
                              
                           
                        . Obviously we have 
                           
                              
                                 h
                                 
                                    1
                                 
                                 ′
                              
                              =
                              
                                 h
                                 1
                              
                           
                         and 
                           
                              
                                 h
                                 
                                    
                                       K
                                       ′
                                    
                                 
                                 ′
                              
                              =
                              
                                 h
                                 K
                              
                           
                        . We now carry out the following iterative procedure (binary search) to find an interval that contains the value of 
                           
                              
                                 r
                                 
                                    p
                                 
                                 
                                    o
                                    p
                                    t
                                 
                              
                              =
                              
                                 h
                                 
                                    k
                                    .
                                 
                              
                           
                        
                        
                           
                              
                                 Initialization. Let 
                                    
                                       
                                          t
                                          1
                                       
                                       =
                                       1
                                    
                                  and 
                                    
                                       
                                          t
                                          2
                                       
                                       =
                                       
                                          K
                                          ′
                                       
                                    
                                 . We have 
                                    
                                       v
                                       
                                          (
                                          
                                             h
                                             
                                                
                                                   t
                                                   1
                                                
                                             
                                             ′
                                          
                                          )
                                       
                                       =
                                       v
                                       
                                          (
                                          
                                             h
                                             1
                                          
                                          )
                                       
                                       =
                                       n
                                    
                                  and 
                                    
                                       v
                                       
                                          (
                                          
                                             h
                                             
                                                
                                                   t
                                                   2
                                                
                                             
                                             ′
                                          
                                          )
                                       
                                       =
                                       v
                                       
                                          (
                                          
                                             h
                                             K
                                          
                                          )
                                       
                                       =
                                       1
                                       ,
                                    
                                  and of course 
                                    
                                       
                                          h
                                          
                                             
                                                t
                                                1
                                             
                                          
                                          ′
                                       
                                       ≤
                                       
                                          r
                                          
                                             p
                                          
                                          
                                             o
                                             p
                                             t
                                          
                                       
                                       <
                                       
                                          h
                                          
                                             
                                                t
                                                2
                                             
                                          
                                          ′
                                       
                                    
                                 .


                                 Iterative step (for 
                                 i=1 to 
                                 q). Let 
                                    
                                       t
                                       =
                                       
                                          t
                                          1
                                       
                                       +
                                       
                                          2
                                          
                                             q
                                             −
                                             i
                                          
                                       
                                    
                                 . Solve the integer programming model ILP-ℓ with 
                                    
                                       ℓ
                                       =
                                       
                                          h
                                          
                                             t
                                          
                                          ′
                                       
                                    
                                 . If 
                                    
                                       v
                                       (
                                       
                                          h
                                          
                                             t
                                          
                                          ′
                                       
                                       )
                                       ≥
                                       p
                                       ,
                                    
                                  let 
                                    
                                       
                                          t
                                          1
                                       
                                       ⟵
                                       t
                                    
                                  and keep t
                                 2 unchanged; otherwise (i.e., if 
                                    
                                       v
                                       (
                                       
                                          h
                                          
                                             t
                                          
                                          ′
                                       
                                       )
                                       <
                                       p
                                    
                                 ) let 
                                    
                                       
                                          t
                                          2
                                       
                                       ⟵
                                       t
                                    
                                  and keep t
                                 1 unchanged. By Proposition 1 it follows that in either case after this operation we have 
                                    
                                       
                                          h
                                          
                                             
                                                t
                                                1
                                             
                                          
                                          ′
                                       
                                       ≤
                                       
                                          r
                                          
                                             p
                                          
                                          
                                             o
                                             p
                                             t
                                          
                                       
                                       <
                                       
                                          h
                                          
                                             
                                                t
                                                2
                                             
                                          
                                          ′
                                       
                                       ,
                                    
                                  and the iteration is complete.


                                 Termination criterion. Terminate this iterative procedure when the half open interval 
                                    
                                       [
                                       
                                          h
                                          
                                             
                                                t
                                                1
                                             
                                          
                                          ′
                                       
                                       ,
                                       
                                          h
                                          
                                             
                                                t
                                                2
                                             
                                          
                                          ′
                                       
                                       )
                                    
                                  contains no more than one value among 
                                    
                                       
                                          h
                                          1
                                       
                                       ,
                                       …
                                       ,
                                       
                                          h
                                          K
                                       
                                    
                                 .


                        Discussion. This procedure terminates after at most q iterations. This follows from the fact that after q iterations the values of t
                        1 and t
                        2 will be consecutive integers, i.e., 
                           
                              
                                 t
                                 2
                              
                              =
                              
                                 t
                                 1
                              
                              +
                              1
                           
                         and we have 
                           
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                 
                                 ′
                              
                              ≤
                              
                                 r
                                 
                                    p
                                 
                                 
                                    o
                                    p
                                    t
                                 
                              
                              <
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                    +
                                    1
                                 
                                 ′
                              
                           
                        . Since the length of the interval 
                           
                              [
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                 
                                 ′
                              
                              ,
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                    +
                                    1
                                 
                                 ′
                              
                              ]
                              ,
                           
                         i.e., δ, is less than or equal to δ
                        min , it follows that the half-open interval 
                           
                              [
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                 
                                 ′
                              
                              ,
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                    +
                                    1
                                 
                                 ′
                              
                              )
                           
                         contains no more than one value among 
                           
                              
                                 h
                                 1
                              
                              ,
                              …
                              ,
                              
                                 h
                                 K
                              
                           
                        . This would be the value of 
                           
                              
                                 h
                                 k
                              
                              =
                              
                                 r
                                 
                                    p
                                 
                                 
                                    o
                                    p
                                    t
                                 
                              
                           
                         since the next value in the sequence, i.e., 
                           
                              
                                 h
                                 
                                    k
                                    +
                                    1
                                 
                              
                              ,
                           
                         is larger than 
                           
                              h
                              
                                 t
                                 +
                                 1
                              
                              ′
                           
                         and we have 
                           
                              v
                              
                                 (
                                 
                                    h
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 )
                              
                              ≤
                              v
                              
                                 (
                                 
                                    h
                                    
                                       t
                                       +
                                       1
                                    
                                    ′
                                 
                                 )
                              
                              <
                              p
                              .
                           
                         The collection of nodes selected as the optimal solution of model ILP-ℓ for 
                           
                              ℓ
                              =
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                 
                                 ′
                              
                           
                         at the last iteration of this procedure represent the optimal set P for the corresponding p-dispersion problem.

In order to reduce the computational burden of this procedure we can take advantage of the fact that while solving the integer programming model ILP-ℓ, if we find a feasible solution whose objective function value is equal to or greater than the value p, we can immediately conclude that 
                           
                              v
                              (
                              
                                 h
                                 
                                    t
                                 
                                 ′
                              
                              )
                              ≥
                              p
                           
                         and proceed as outlined in the iterative step above. In this case we no longer need to solve ILP-ℓ to optimality; we can abort the IP solver as soon as such a feasible solution is found and this could lead to saving considerable computation time.

Another measure to further reduce the computational requirements of this procedure would be to use a larger value for the parameter δ (i.e., smaller value for q). This would result in potentially smaller number of iterations, but we can no longer guarantee that the resulting solution is optimal. In this situation the final interval 
                           
                              [
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                 
                                 ′
                              
                              ,
                              
                                 h
                                 
                                    
                                       t
                                       1
                                    
                                    +
                                    1
                                 
                                 ′
                              
                              )
                           
                         might contain more than one value among 
                           
                              
                                 h
                                 1
                              
                              ,
                              …
                              ,
                              
                                 h
                                 K
                              
                           
                        . We could report the smallest such hk
                         value as the best value obtained, but we cannot be sure that it is optimal. The optimal value could be as large as the largest hk
                         value in this interval. In the numeric experiments that we report below neither of these two measures are utilized.

In order to assess the computational requirements of the proposed procedure for solving the p-dispersion problem we carried out a comprehensive experiment in which we employed this procedure to solve two collections of instances of the problem. The first collection consists of several groups of randomly generated instances that are structurally similar to those used in earlier studies. In particular, such instances are previously used to evaluate the effectiveness of other exact methods for solving the p -dispersion problem. In Section 4.1 we report a summary of our findings for these instances. The second collection consists of 120 specific instances from the open literature that are previously solved via heuristic methods. We were able to solve a relatively large number of these instances with our proposed exact procedure and obtain the corresponding optimal solutions. We report our findings in Section 4.2.

In this experiment we constructed a collection of randomly generated instances of the p-dispersion problem and solved each instance using Procedure Aas well the two IP models proposed in Kuo et al. (1993) and in Kuby (1987). These instances are comparable with those used in Erkut (1990); Kincaid (1992), and Pisinger (2006). We start this section by describing these instances. We then present the results of our experiment and make a few observations. We wrote all pertinent programs in C++ and performed all experiments on a 2.66 GHz Intel 2 Quad processor with 3.25 GB RAM, running Windows XP Professional. We used CPLEX 11 (ILOG, 2011) to solve the corresponding integer linear programming models.

We constructed four groups (classes) of instances that we refer to as GEO, WGEO, EXP, and RAN, respectively. Following is a brief description of how we constructed the instances in each group.


                                 GEO: The geometrical instances reflect a typical location problem in the Euclidean space, as presented in Erkut (1990) and Pisinger (2006). The n facilities are randomly located in a 100 × 100 rectangle, i.e., each of the coordinates xi
                                  and yi
                                  for facility i is drawn from a Uniform distribution in the interval [0, 100], and dij
                                  is the Euclidean distance between facilities i and j.
                                 
                              


                                 WGEO: The weighted geometrical instances are constructed to illustrate the case where the facilities have different weights as presented by Pisinger (2006). Similar to the instances in the GEO class, the n facilities are randomly located in a 100 × 100 rectangle, and each facility is assigned a weight wi
                                  in the interval [5, 10]. The distance dij
                                  is then found as wiwj
                                  times the Euclidean distance between facilities i and j.

The next two classes of instances are constructed to observe how the procedure performs when the distances (dij
                                 ’s) do not satisfy the triangle inequality.


                                 EXP: For the exponential instances each dij
                                  value with i < j is randomly drawn from an exponential distribution with mean value 50. We set 
                                    
                                       
                                          d
                                          
                                             i
                                             j
                                          
                                       
                                       =
                                       
                                          d
                                          
                                             j
                                             i
                                          
                                       
                                    
                                  to ensure symmetry.


                                 RAN: Instances with random distribution are adapted from Pisinger (2006). Each dij
                                  with i < j is randomly drawn from the interval [1, 100], and we let 
                                    
                                       
                                          d
                                          
                                             i
                                             j
                                          
                                       
                                       =
                                       
                                          d
                                          
                                             j
                                             i
                                          
                                       
                                    
                                  to ensure symmetry.

In all instances we set 
                                    
                                       
                                          d
                                          
                                             i
                                             i
                                          
                                       
                                       =
                                       +
                                       ∞
                                    
                                  for 
                                    
                                       i
                                       =
                                       1
                                       ,
                                       .
                                       .
                                       .
                                       ,
                                       n
                                    
                                 . Within each class we construct instances of different sizes, i.e., with different values of n , and for each instance we set the value of 
                                    
                                       p
                                       =
                                       0.1
                                       *
                                       n
                                    
                                 . Within each class and for each value of n and p we construct a group of 3 instances of the problem and solve each instance using Procedure A
                                 
                                    1
                                 
                                 
                                    1
                                    Data sets for these instances can be downloaded from <http://go.ncsu.edu/p-dispersion>.
                                 . We report the average execution time for these 3 instances as an entry in Tables 1 and 2. We also report the corresponding standard deviations next to the average values (in parenthesis). We impose a time limit of 90 minutes ( 5400 seconds) on the average execution time for the 3 instances. If the execution time of the 3 instances exceeds 270 minutes (i.e., if the corresponding optimal solutions are not obtained within this time limit), we abort the program at the end of the iteration during which the execution time exceeds the time limit.(i.e., 5400 seconds) and do not report the average execution time. Instead, for these instances (i.e., for GEO instances with 
                                    
                                       n
                                       =
                                       1200
                                       ,
                                    
                                  WGEO instances with 
                                    
                                       n
                                       =
                                       2800
                                       ,
                                    
                                  EXP instances with 
                                    
                                       n
                                       =
                                       190
                                       ,
                                    
                                  and RAN instances with 
                                    
                                       n
                                       =
                                       180
                                    
                                 ) we report [in brackets] the corresponding average lower and upper limits for the optimal value of the objective function (i.e., 
                                    
                                       r
                                       
                                          p
                                       
                                       
                                          o
                                          p
                                          t
                                       
                                    
                                 ) obtained at the time that we abort the procedure. Note that when we abort the procedure at the end of an iteration we have an interval 
                                    
                                       [
                                       
                                          h
                                          
                                             
                                                t
                                                1
                                             
                                          
                                          ′
                                       
                                       ,
                                       
                                          h
                                          
                                             
                                                t
                                                2
                                             
                                          
                                          ′
                                       
                                       )
                                    
                                  that contains the optimal value of the objective function, i.e., we have 
                                    
                                       
                                          h
                                          
                                             
                                                t
                                                1
                                             
                                          
                                          ′
                                       
                                       ≤
                                       
                                          r
                                          
                                             p
                                          
                                          
                                             o
                                             p
                                             t
                                          
                                       
                                       <
                                       
                                          h
                                          
                                             
                                                t
                                                2
                                             
                                          
                                          ′
                                       
                                    
                                 . The lower limit that we record for 
                                    
                                       r
                                       
                                          p
                                       
                                       
                                          o
                                          p
                                          t
                                       
                                    
                                  is the smallest dij
                                 -value in this interval and the upper limit is the largest such dij
                                 -value.

From the reported average execution times in Tables 1 and 2 it appears that the instances in class WGEO are computationally easier to solve, i.e., need less execution time than comparable instances in other groups. The largest instances within this class that we were able to solve via our proposed algorithm within the stated time limits have 
                                    
                                       n
                                       =
                                       2600
                                    
                                  elements (nodes) and the corresponding average execution time is 3558 seconds. The geometric instances (class GEO) are also relatively easy to solve. Our algorithm solves the GEO instances up to 
                                    
                                       n
                                       =
                                       1000
                                    
                                  within the specified time limit (i.e., 90 minutes per instance). The remaining instances, i.e., EXP and RAN instances, are somewhat more difficult to solve. Within the stated time limits we are able to solve instances with as many as 
                                    
                                       n
                                       =
                                       180
                                    
                                  elements (nodes) in the EXP class and as many as 
                                    
                                       n
                                       =
                                       170
                                    
                                  elements (nodes) in the RAN class. It appears that the instances for which the triangle inequality does not hold tend to be more difficult to solve using this approach. This is consistent with observations in the context of other combinatorial optimization problems such as the traveling salesman problem as reported in Lawler, Lenstra, Kan, and Shmoys (1985).

In order to allow a direct comparison of the execution time of our proposed approach with those of the earlier integer programming models, we solved the same collection of instances that we described above using the integer programming models proposed in Kuo et al. (1993) and in Kuby (1987). Note that Prokopyev, Oleg, Kong, and Martinez-Torres (2009) also propose an integer programming model for this problem but the structure of that model is similar to the model proposed in Kuo et al. (1993) , hence we do not include it in this experiment. We used the same software system (i.e., CPLEX 11) to solve these IP models on the same platform that we mentioned above, and we imposed the same time limits as we imposed on Procedure A (i.e., 5400 seconds per instance). The average execution time and the corresponding standard deviation for each collection of 3 instances is given in Tables 1 and 2, in columns adjacent to those corresponding to Procedure A. The dashed lines in these columns indicate that the average execution time exceeded the time limit of 5400 seconds and we aborted the procedure. In two cases we allowed the average execution time to exceed this limit. Both cases occur in Table 2 for the EXP instances with 
                                    
                                       n
                                       =
                                       120
                                    
                                  and 
                                    
                                       n
                                       =
                                       100
                                       ,
                                    
                                  where the corresponding average values are 5409 seconds and 5523 seconds, respectively. We allow these two exceptions since they reveal a sudden increase in the required execution time of the corresponding models as the number of nodes increases.

We observe that within the same computational environment and limits we are able to solve significantly larger instances of the p-dispersion problem via Procedure A than we can via either of these two earlier IP models. For the instances in classes GEO and WGEO in Table 1, we observe that using Procedure A we are able to solve instances with up to 
                                    
                                       n
                                       =
                                       1000
                                    
                                  and 
                                    
                                       n
                                       =
                                       2600
                                    
                                  elements, respectively, within the stated time limits, while the corresponding size limits for the IP model of Kuo et al. (1993) are 
                                    
                                       n
                                       =
                                       150
                                    
                                  elements for the GEO instances and 
                                    
                                       n
                                       =
                                       140
                                    
                                  elements for the WGEO instances. Similar size limits for the IP model of Kuby (1987) are even smaller (
                                    
                                       n
                                       =
                                       80
                                    
                                  for both GEO and WGEO instances). In Table 2 we make a similar observation for the EXP and RAN instances. Although each of the three approaches requires more execution time to solve these instances than it does for comparable instances in the GEO and WGEO groups, it is still true that we are able to solve significantly larger instances of the problem via Procedure A than we can via either of the two IP models.

For comparison, we also note that Erkut (1990) reports that his branch-and-bound algorithm takes (on average) about 14 seconds to solve an instance of size 
                                    
                                       n
                                       =
                                       30
                                    
                                  in the class GEO. This execution time rapidly grows to 150 seconds for an instance with 
                                    
                                       n
                                       =
                                       40
                                    
                                  nodes. Our average execution time for each comparable instance is less than 2 seconds, and the largest instance that we were able to solve within 150 seconds has more than 600 nodes. The largest instance in this class that we are able to solve within our time limit has 1000 nodes and its corresponding average execution time is 2317 seconds.

In a computational experiment that is quite comparable with ours, i.e., solving 10 randomly generated instances for each size within each class, with a time limit of 15 hours imposed on each series of 10 instances, Pisinger (2006) reports that the largest size instance of the p-dispersion problem that he is able to solve within each of the classes GEO, WGEO, EXP, and RAN has, 
                                    
                                       n
                                       =
                                       70
                                       ,
                                    
                                  70, 80, and 80 nodes, respectively. Comparable largest size instances within our experiment have 1000, 2600, 180, and 170 nodes, respectively. Similarly, Pisinger reports that the execution time of his algorithm for an instance of size 
                                    
                                       n
                                       =
                                       70
                                    
                                  within the GEO class is slightly over 650 seconds. The comparable execution time for our algorithm is slightly more than 3 seconds. In order to make a direct comparison between the two methods we attempted to obtain an executable version of the software for the B&B method of Pisinger (2006) and run it on our platform. But unfortunately we did not succeed in obtaining a copy of this software.

Even a comparison with the heuristic procedure proposed in Resende et al. (2010) shows that in most cases the execution time of our proposed exact method is significantly smaller. For example, for a GEO instance with 
                                    
                                       n
                                       =
                                       500
                                    
                                  
                                 Resende et al. (2010) report average execution times slightly more than 788 seconds and 1465 seconds, respectively, using his GPR and GRASP+EvPR implementations. For a comparable instance we obtain an optimal solution with an average execution time less than 31 seconds. For the RAN instances, however, we are not able to solve instances as large as those reported in Resende et al. (2010). The largest instance in this class that we are able to solve (within our stated time limit) has 
                                    
                                       n
                                       =
                                       170
                                    
                                  nodes, while the largest instance that (Resende et al., 2010) reports (albeit with a larger time limit) has 
                                    
                                       n
                                       =
                                       500
                                    
                                  nodes. Of course the solution reported in Resende et al. (2010) is not guaranteed to be optimal and no evidence is provided that it is near optimal either.

Admittedly these earlier computational experiments are carried out on different (and potentially slower) platforms than the one we used in our experiments. Hence some of the difference could be attributed to the difference in the corresponding computing environments. But from the relatively large magnitude of the difference in the reported results as well as from the direct comparisons that we make in Tables 1 and 2 we conclude that our proposed methodology leads to appreciably better solution times and allows us to solve significantly larger instances of the problem.
                              

In the second experiment we employed Procedure A to solve an existing collection of instances that are previously solved via heuristic methods. The collection consists of two sets of instances that we refer to as GEO2 and RAN2, to distinguish them from the GEO and RAN instances that we mentioned above. These instances are the same as those considered in Croce et al. (2009) and solved via their proposed heuristic procedure. Although there are structural similarities between these instances and the GEO and RAN instances that we used in the previous section, there are also differences. For completeness we give a brief description of how these instances are constructed as described in Croce et al. (2009). Data for these instances can be downloaded from the following website http://www.uv.es/rmarti/.

                           
                              
                                 GEO2 These are 60 instances where the distance values dij
                                  are generated by first randomly generating n points with a random number of coordinates between 2 and 21 and with random coordinates in the range [0, 100], and then computing the Euclidean distance between these points. Three n values are considered, namely 
                                    
                                       n
                                       =
                                       100
                                       ,
                                    
                                  250, 500. The p values are 0.1n and 0.3n. For each combination of n and p values 10 distinct instances are provided.


                                 RAN2 These are 60 instances with the same n and p values as the GEO2 instances. The distance values dij
                                  are integer random numbers within the interval [50, 100], with the exception of 
                                    
                                       n
                                       =
                                       500
                                    
                                  and 
                                    
                                       p
                                       =
                                       0.3
                                       n
                                       ,
                                    
                                  where the distance values are integer random numbers in the interval [1, 200].

We attempted to solve every one of the 120 instances in these two sets with the same software and hardware system that we described above. We imposed a time limit of 90 minutes for each instance. For any given instance, if Procedure A terminates within this time limit we observe the optimal value that it obtains and compare it with the corresponding value reported in Croce et al. (2009). If Procedure A did not terminate within this time limit we abort its execution and report no value for that instance. Results are presented in Tables 3 and 4
                         for the GEO2 and RAN2 instances, respectively. We make the following observations.

                           
                              1.
                              For the instances in the set GEO2, within the stated time limit (i.e., 90 minutes) we are able to solve all 20 instances with 
                                    
                                       n
                                       =
                                       100
                                       ,
                                    
                                  all 20 instances with 
                                    
                                       n
                                       =
                                       250
                                       ,
                                    
                                  and 4 of the 20 instances with 
                                    
                                       n
                                       =
                                       500
                                    
                                 . All optimal values and execution times that we obtained are reported in Table 3. The optimal values that we obtain are identical to the corresponding values obtained via the heuristic procedure of Della Croce et al. as reported in Croce et al. (2009). Indeed Croce et al. (2009) had already independently verified that the values they obtain via their heuristic procedure for the instances with 
                                    
                                       n
                                       =
                                       100
                                    
                                  and 
                                    
                                       n
                                       =
                                       250
                                    
                                  are in fact optimal. Here we confirm their observation and further verify that the values they report for 4 of the 20 instances with 
                                    
                                       n
                                       =
                                       500
                                    
                                  are also optimal (namely, for GEO500-2, GEO500-5, GEO500-6, and GEO500-15).

For the instances in the set RAN2, within the stated time limit (i.e., 90 minutes) we were able to solve all 20 instances with 
                                    
                                       n
                                       =
                                       100
                                       ,
                                    
                                  but we were not able to solve any of the instances with larger number of nodes (namely those with 
                                    
                                       n
                                       =
                                       250
                                    
                                  and 
                                    
                                       n
                                       =
                                       500
                                    
                                 ). The optimal values and the execution times for the instances with 
                                    
                                       n
                                       =
                                       100
                                    
                                  are reported in Table 4. Again we observe that the optimal values that we report here are identical to the values reported in Croce et al. (2009).

We used the above model and procedures to solve an instance of the p -dispersion problem that arises in the context of locating traffic sensors in the highway network in the state of North Carolina (NC). In this section we present a summary of our findings. For further details and the complete set of data see Sayyady and Fatemeh (2012).
                  

The 2.7 million miles of paved highways in the U.S. represent a huge national investment in terms of construction, rehabilitation, and maintenance, to provide a viable mode of transportation (Bureau of Transportation Statistics, 2010). This immense investment in the highway infrastructure calls for sophisticated pavement designs to optimize the use of available resources. The Mechanistic-Empirical Pavement Design Guide (MEPDG), which is a state-of-the-art pavement design tool, requires a comprehensive range of traffic data for its successful implementation (ERES, 2002). The required traffic data includes the axle load data and the vehicle classification data. Axle load data represents the amount of load (weight) that axles apply to the pavement. The vehicle classification data represents the traffic volumes by vehicle classes that commute on the pavement.

Among the available technologies to collect traffic data, the Weigh-In-Motion (WIM) sensors are the ones that can collect both axle load data and vehicle classification data. The comprehensive range of traffic data collected by a WIM sensor makes it an attractive data collection technology for traffic agencies. However, the cost of installing, operating, and maintaining WIM sensors is relatively high (U.S. Department of Transportation, 2001). As a result, the resource and budget constraints usually preclude the possibility of placing WIM sensors at every highway segment. Instead, the traffic agencies typically install WIM sensors only at a limited number of locations (say p locations) and infer from them the traffic data for other locations where WIM sensors are not available. Naturally we prefer to select the locations for these WIM sensors so that they capture as much of the diversity (dissimilarity) in the traffic patterns on various highway segments as possible. To this end we would need two things: (i) an appropriate metric to measure the degree of similarity/dissimilarity of the traffic patterns between pairs of highway segments, and (ii) an appropriate methodology to select p highway segments (for installation of WIM sensors) whose traffic patterns provide a reasonable cross-section of the traffic patterns in the entire highway network.

There is an alternative and less expensive data collection technology, known as the Portable Traffic Counter (PTC), that is capable of collecting only the vehicle classification data. Traffic agencies routinely operate these sensors throughout the traffic network to collect the vehicle classification data. In the state of North Carolina (NC) the Department of Transportation (NCDOT) has a total of 
                        
                           n
                           =
                           644
                        
                      locations on the highway network where it has already used PTC sensors and obtained their corresponding vehicle classification data. We refer to each such location as a partially observed location, or a PTC location for short.

A PTC sensor records the number of vehicles in each class based on the FHWA vehicle classification scheme. Fig. 1 shows the FHWA vehicle classification scheme (U.S. Department of Transportation, 2001) that classifies vehicles into passenger cars (classes 1–3) and trucks (classes 4–13).

We define a truck class distribution vector for each PTC location on the network as a vector that specifies the percentage of each class of trucks at that location during a one-year period, based on the FHWA vehicle classification scheme. We use the vehicle classification data (counts) collected by the PTC sensors to obtain the corresponding truck class distribution vectors. To this end, for each PTC location we normalize the counts corresponding to the vehicle classes 4–13 so that they add up to 100. It follows that associated with each PTC location i we have a 10 -dimensional vector 
                        
                           
                              t
                              i
                           
                           =
                           
                              (
                              
                                 t
                                 
                                    i
                                    ,
                                    4
                                 
                              
                              ,
                              
                                 t
                                 
                                    i
                                    ,
                                    5
                                    ,
                                 
                              
                              …
                              .
                              
                                 t
                                 
                                    i
                                    ,
                                    13
                                 
                              
                              )
                           
                        
                      where t
                     
                        i, m
                      is the percentage of trucks in class m at this location. Of course 
                        
                           
                              ∑
                              
                                 m
                                 =
                                 4
                              
                              13
                           
                           
                              t
                              
                                 i
                                 ,
                                 m
                              
                           
                           =
                           100
                        
                     .

We use these normalized vectors to compare the truck traffic patterns among various PTC locations on the network. More specifically, we use the Euclidean norm of the vector 
                        
                           (
                           
                              t
                              i
                           
                           −
                           
                              t
                              j
                           
                           )
                        
                      as a measure of similarity of the truck traffic patterns between two locations i and j, with respective truck class distribution vectors t
                     
                        i
                      and t
                     
                        j
                     .  We denote this distance by dij
                     , and we have 
                        
                           
                              d
                              
                                 i
                                 j
                              
                           
                           =
                           
                              
                                 
                                    ∑
                                    
                                       m
                                       =
                                       4
                                    
                                    13
                                 
                                 
                                    
                                       (
                                       
                                          t
                                          
                                             i
                                             ,
                                             m
                                          
                                       
                                       −
                                       
                                          t
                                          
                                             j
                                             ,
                                             m
                                          
                                       
                                       )
                                    
                                    2
                                 
                              
                           
                        
                     . It follows that smaller values of dij
                      indicate a higher degree of similarity between the truck class distribution vectors for two PTC locations i and j, and larger values of this parameter imply the opposite.


                     Sayyady et al. (2013) showed that locations with similar truck class distributions also have similar axle load distributions. This observation implies that the value of dij
                      as defined above can also be employed to measure the similarity of axle load patterns between PTC locations i and j.

We employ this metric to measure the degree of similarity between the traffic patterns of every pair of PTC locations on the network. The problem of selecting a collection of p locations for the WIM sensors is now formulated as a p-dispersion problem in which N is the collection of PTC locations and the distance between every pair of locations i and j is their corresponding dij
                      values. The optimal solution of this p -dispersion problem provides a collection of p locations that have the highest degree of dissimilarity, as measured by their minimum dispersion in terms of dij
                     , among all such collections of p locations, hence it is a desirable selection for installation of the WIM sensors as discussed above.

As mentioned earlier for this case we have the truck class distribution vectors (t
                     
                        i
                     ’s) for 
                        
                           n
                           =
                           644
                        
                      PTC locations on the highway network in the state of North Carolina. For brevity we do not present the data set here and refer the reader to Sayyady and Fatemeh (2012) for this information (the entire collection of t
                     
                        i
                      vectors is given in the appendix in Sayyady & Fatemeh (2012)). Using these t
                     
                        i
                      vectors we calculate all dij
                      values as discussed above, and for this instance we choose 
                        
                           p
                           =
                           25
                        
                     . The software and hardware systems that we used to solve this instance are the same as what we described in the previous sections. We solved this instance using the procedure that we described in this article. The corresponding optimal solution (optimal locations for placing WIM sensors) was obtained as reported in Sayyady and Fatemeh (2012) and the associated execution time was 144 seconds.

Results of this case study were presented to the Traffic Survey Unit (TSU) at NCDOT. Traffic Engineers at the TSU agreed that its findings are consistent with their objectives in this context, and the results are presently being considered for implementation.

We explored the relationship between the p-dispersion problem and a collection of node packing problems and employed this relationship to devise an effective procedure for solving the p-dispersion problem. Through a computational experiment we showed that this approach is more effective than the previously proposed exact methods for solving the p-dispersion problem, and it allows us to solve appreciably larger instances of the problem within a reasonable execution time. We also discussed an application of the p-dispersion problem in the context of locating traffic sensors in a highway network.

Undoubtedly recent advances in the development of strong valid inequalities (VIs) and design of effective branch-and-bound algorithms for solving the node packing problem is instrumental in making this approach viable for solving relatively large instances of the p-dispersion problem. It is also conceivable that this approach can be made more effective if we devise appropriate techniques to use the solution obtained for the node packing problem at each iteration of the binary search to provide a warm start to the branch and bound algorithm in the subsequent steps. We leave this as a subject for future research.

@&#ACKNOWLEDGMENT@&#

The authors wish to express their sincere gratitude to the two anonymous referees and to the area editor, Professor Jean-Charles Billaut, for their constructive comments and suggestions that resulted in significant improvements in this article.

@&#REFERENCES@&#

