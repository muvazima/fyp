@&#MAIN-TITLE@&#Efficient elementary and restricted non-elementary route pricing

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose an efficient algorithm for the SPPRC based on ng-routes relaxation.


                        
                        
                           
                           This algorithm is extended in order to solve the more difficult ESPPRC.


                        
                        
                           
                           We report for the first time experiments with ng-set sizes up to 64.


                        
                        
                           
                           We solve the ESPPRC for CVRP instances with up to 200 customers.


                        
                        
                           
                           We obtain new lower bounds and optimality proofs for several GVRP instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Routing problems

Column generation

Non-elementary routes

Elementary routes

@&#ABSTRACT@&#


               
               
                  Column generation is involved in the current most efficient approaches to routing problems. Set partitioning formulations model routing problems by considering all possible routes and selecting a subset that visits all customers. These formulations often produce tight lower bounds and require column generation for their pricing step. The bounds in the resulting branch-and-price are tighter when elementary routes are considered, but this approach leads to a more difficult pricing problem. Balancing the pricing with route relaxations has become crucial for the efficiency of the branch-and-price for routing problems. Recently, the ng-routes relaxation was proposed as a compromise between elementary and non-elementary routes. The ng-routes are non-elementary routes with the restriction that when following a customer, the route is not allowed to visit another customer that was visited before if they belong to a dynamically computed set. The larger the size of these sets, the closer the ng-route is to an elementary route. This work presents an efficient pricing algorithm for ng-routes and extends this algorithm for elementary routes. Therefore, we address the Shortest Path Problem with Resource Constraint (SPPRC) and the Elementary Shortest Path Problem with Resource Constraint (ESPPRC). The proposed algorithm combines the Decremental State-Space Relaxation technique (DSSR) with completion bounds. We apply this algorithm for the Generalized Vehicle Routing Problem (GVRP) and for the Capacitated Vehicle Routing Problem (CVRP), demonstrating that it is able to price elementary routes for instances up to 200 customers, a result that doubles the size of the ESPPRC instances solved to date.
               
            

@&#INTRODUCTION@&#

Since the work of Christofides, Mingozzi, and Toth (1981) on the Capacitated Vehicle Routing Problem (CVRP), column generation has become a widely applied technique for exactly solving different routing problems. Currently, it is involved in almost all of the current most efficient approaches to routing problems. These approaches use integer and mixed-integer programming formulations with variables associated with the set of all possible routes. These formulations are set partitioning based, and these constraints impose the selection of the route to serve each customer. We refer to this as SPP formulation. The resolution of its linear relaxation requires the use of column generation techniques. The pricing subproblem to be solved is the Elementary Shortest Path Problem with Resource Constraints (ESPPRC).

The ESPPRC is a shortest path problem on a graph where the customers have an amount of resources that are consumed during a visit. The resource constraints require that the total of the resources consumed by any feasible solution does not exceed the existing limits. There may be edges with negative cost, and these edges may generate negative cycles, but because a feasible solution must be an elementary path, revisiting a customer is strictly forbidden.

The ESPPRC is a difficult to solve 
                        
                           NP
                        
                     -hard problem (Dror, 1994). In general, the current best performing algorithms have acceptable processing times when the optimal solution is a path with at most fourteen customers. We refer to Di Puglia Pugliese and Guerriero (2012) for a review of the approaches proposed throughout the last three decades. Most of the main ideas for the ESPPRC resolution can be found in their work and in the proceedings of Feillet, Dejax, Gendreau, and Gueguen (2004), Chabrier (2006), Righini and Salani (2006), Righini and Salani (2008) and Boland, Dethridge, and Dumitrescu (2006).

Instead of solving the ESPPRC, the original work of Christofides et al. (1981) solves its relaxation, the Shortest Path Problem with Resource Constraints (SPPRC). This relaxation does allow revisiting a same customer in a route. The resulting non-elementary routes are often called q-routes. However, the resource constraints are the same as the ESPPRC, and therefore, every time a customer is visited, the relevant resource consumption is counted, and the total consumption must still respect the existing limits. A recent survey about the SPPRC can be found in Di Puglia Pugliese and Guerriero (2013).

This relaxation has some interesting properties. First, as distinct from the original problem, it can be solved in pseudo-polynomial time using a dynamic programming algorithm. In addition, even relaxing the elementarity constraint, the SPP bounds found by its linear relaxation are usually strong, especially when there are few customers per route. Furthermore, to strengthen the bounds of the linear relaxation, Christofides et al. (1981) also demonstrated that size two cycles can be forbidden with almost no extra effort.

However, even with the 2-cycle elimination restriction, the linear relaxation is still weak, a behavior that motivated researchers to seek better cycle elimination devices to turn the non-elementary routes closer to elementary routes, without dealing with the whole complexity of the ESPPRC. The work of Irnich and Villeneuve (2006) devised an algorithm that solves the SPPRC by forbidding cycles of an arbitrary size. This algorithm is significantly more complicated, resulting in a complexity that grows factorially with the size of the cycles being forbidden. On account of this, their method quickly becomes impractical. Eliminating cycles of size four or more is already too time consuming compared with the bound improvement obtained. Such behavior was verified in practice by Fukasawa et al. (2006) for the CVRP.

Recently, Baldacci, Mingozzi, and Roberti (2011) proposed a compromise between routes and q-routes: ng-routes. These ng-routes are restricted non-elementary routes built accordingly to customer sets, ng-sets, which are associated with each customer and act like their “memory.” Therefore, when a path reaches a given customer, it “forgets” whether another customer was visited if it does not belong to the ng-set of the current customer. Moreover, the further extension is only allowed to customers that are not “remembered”. The ng-sets are usually composed of the closest customers and clearly with a larger size set the problem is harder to solve. This is due to the fact that the ng-routes generated are going to be increasingly closer to elementary routes.

Although the SPPRC with ng-routes can be solved in pseudo-polynomial time for a fixed ng-set size, to the best of our knowledge, there is no work that solves this problem for ng-sets larger than 20. This finding is observed because of the exponential-sized data structure used by Baldacci et al. (2011) to speed up the algorithm.

This work aims at efficiently solving the SPPRC with restricted non-elementary routes and the ESPPRC. The first improvement is obtained by adapting the Decremental State-Space Relaxation (DSSR) technique of Righini and Salani (2008) to the SPPRC with ng-routes. This technique was initially proposed for the ESPPRC, where the elementarity restriction is relaxed and the problem is then solved iteratively, rebuilding the restrictions as needed, until the optimal solution is found. The main difference of our algorithm is instead of relaxing the elementarity of the routes, we relax the restriction imposed by the ng-sets.

Next, we accelerate this approach using completion bounds. Because an iteration of the DSSR is a relaxation for its next iteration, the completion bounds estimate lower bounds for completing the paths being built on a given iteration, and, given an upper bound for the optimal solution (which is usually equal to zero for pricing algorithms), it avoids the extension of paths that may exceed the known upper bound on the next DSSR iteration.

These two techniques were already used together in the work of Pecin (2010). In that work, a column generation procedure that uses the ESPPRC as the pricing subproblem was proposed for the CVRP. Using the algorithm of Fukasawa et al. (2006), instances with up to 100 customers could be solved to optimality pricing only elementary routes.

Finally, we demonstrate how our algorithm for the SPPRC with restricted non-elementary routes can be easily extended to generate only elementary routes. We also highlight the two new elements existing in our approach that allow us to double the size of the ESPPRC instances solved thus far.

The proposed algorithms are then applied to the Generalized Vehicle Routing Problem (GVRP), where the customers to be visited are clusters of vertices. Each cluster has an associated demand and can contain one or more vertices. The demand of each cluster must be fully collected in exactly one vertex of the cluster. This problem is a generalization of the CVRP and the Traveling Salesman Problem (TSP), and, as in the classical CVRP, identical vehicles are given, and routes must start and end at the depot and the capacity of the vehicle must not be exceeded. We report experiments demonstrating that our algorithms are able to solve the SPPRC with ng-set sizes up to 64 and the ESPPRC for hard instances of both the GVRP and CVRP. The CVRP instances are solved through reducing them to GVRP instances. The results of the column generation algorithm also provide a clear idea of the gains in the lower bounds comparing the SPPRC with different ng-set sizes and also with the ESPPRC, as well as the time required for computing them. In addition, several new best lower bounds are identified for the GVRP, especially for large instances.

This paper is organized as follows. Section 2 presents the ESPPRC and explains the required mathematical notation. The ng-route relaxation is described in Section 3. In Section 4, we explain the techniques used to solve the ng-route relaxation. In Section 5, we demonstrate how our algorithm can be used to obtain only elementary routes, and we highlight the main elements that allowed us to build a very efficient method for solving the ESPPRC. Section 6 presents the Generalized Vehicle Routing Problem formally. Section 7 reports the computational results for both the GVRP and CVRP. Finally, Section 8 presents some conclusions.

Let 
                        
                           G
                           =
                           (
                           V
                           ,
                           A
                           )
                        
                      be a graph with arc set A and vertex set V, which is composed of the set of customers 
                        
                           C
                        
                      plus a source vertex s and a destination vertex t, and let 
                        
                           R
                        
                      be a set of resources. For each arc 
                        
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                        
                     , let 
                        
                           
                              
                                 c
                              
                              
                                 ij
                              
                           
                        
                      be the cost of the arc and 
                        
                           
                              
                                 w
                              
                              
                                 ij
                              
                              
                                 r
                              
                           
                        
                      be the consumption of the edge, for each 
                        
                           r
                           ∈
                           R
                        
                     . For each pair 
                        
                           i
                           ∈
                           C
                        
                      and 
                        
                           r
                           ∈
                           R
                        
                      let 
                        
                           
                              
                                 a
                              
                              
                                 i
                              
                              
                                 r
                              
                           
                        
                      and 
                        
                           
                              
                                 b
                              
                              
                                 i
                              
                              
                                 r
                              
                           
                        
                      be two non-negative values, such that the total resource consumption along a path from s to i must belong to the interval 
                        
                           
                              
                                 
                                    
                                       
                                          a
                                       
                                       
                                          i
                                       
                                       
                                          r
                                       
                                    
                                    ,
                                    
                                       
                                          b
                                       
                                       
                                          i
                                       
                                       
                                          r
                                       
                                    
                                 
                              
                           
                        
                     . The ESPPRC aims to find a minimum cost elementary path from s to t that satisfies all resource constraints.

The resources constraints can model different types of restrictions. For instance, most vehicle routing problems consider that the vehicles have a known capacity, and this capacity cannot be exceeded in a single route. Other problems have time windows, which require the route to visit a customer in a given interval of time. Moreover, one can also view the elementarity constraint as resource constraints, where each customer defines a binary resource and when a route visits a customer, it consumes all of the associated resource.

In this work, we deal only with the capacity constraint, in addition to the obvious elementarity constraint. Thus, the customer set has an associated demand function 
                        
                           d
                           :
                           C
                           →
                           Z
                        
                     , and there is a global capacity limit Q, which no feasible solution may exceed. Because we apply our algorithm for routing problems, we can consider the source and the destination vertices as a single vertex called the depot and labeled 0. Therefore, the solution of the problem is a route instead of a path. This is straightforward because most of the applications for the ESPPRC involve a pricing routine embedded in a column generation scheme that solves some type of vehicle routing problem.

Recently, the ng-route relaxation was introduced in the work of Baldacci et al. (2011) for the CVRP and the CVRP with Time Windows (CVRPTW), and it was later extended to the GVRP by Bartolini, Cordeau, and Laporte (2011), where it was used to solve transformed CARP instances. This new relaxation aims at obtaining a better compromise between efficiently priced non-elementary routes and obtaining good lower bounds.

For each customer 
                        
                           i
                           ∈
                           C
                        
                     , let 
                        
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                           ⊆
                           C
                        
                      be a subset of customers that have a relationship with i. A possible representation for this relationship can be a neighborhood relationship, i.e., 
                        
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                        
                      contains the nearest customers of i, including i. These sets are called ng-sets, and they contain the customers that customer i is able to “remember.” For instance, when a path P is being built, by the time it arrives at customer i, it has a set 
                        
                           Π
                           (
                           P
                           )
                        
                      that represents its “memory” thus far. If customer i belongs to set 
                        
                           Π
                           (
                           P
                           )
                        
                     , the extension is forbidden. On the other hand, if i does not belong to set 
                        
                           Π
                           (
                           P
                           )
                        
                     , the extension is allowed and set 
                        
                           Π
                           (
                           P
                           )
                        
                      is updated to “forget” the customers that customer i is not able to “remember,” i.e., the customers that do not belong to 
                        
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                        
                     . It is clear that if a customer is “forgotten,” it can be used to form a cycle in future extensions of path P. At this point, we can conclude that the size of the ng-sets is an important factor in the quality of solutions because the larger the ng-sets are, the greater the smallest cycles that can appear in a path. The size of each ng-set 
                        
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                        
                      is limited by 
                        
                           Δ
                           (
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                           )
                        
                     , which is a parameter defined a priori. Obviously, this size also changes the pricing complexity.

Let 
                        
                           P
                           =
                           (
                           0
                           ,
                           
                              
                                 i
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 i
                              
                              
                                 p
                                 -
                                 1
                              
                           
                           ,
                           
                              
                                 i
                              
                              
                                 p
                              
                           
                           )
                        
                      be a path starting at the depot, visiting a sequence of customers and ending at customer 
                        
                           
                              
                                 i
                              
                              
                                 p
                              
                           
                        
                      and 
                        
                           C
                           (
                           P
                           )
                        
                      be the set of customers visited by path P. The function 
                        
                           Π
                           (
                           P
                           )
                        
                      of prohibited extensions (the “memory”) of path P can be defined as follows.
                        
                           (1)
                           
                              Π
                              (
                              P
                              )
                              =
                              
                                 
                                    
                                       
                                          
                                             i
                                          
                                          
                                             k
                                          
                                       
                                       ∈
                                       C
                                       (
                                       P
                                       )
                                       ⧹
                                       {
                                       
                                          
                                             i
                                          
                                          
                                             p
                                          
                                       
                                       }
                                       :
                                       
                                          
                                             i
                                          
                                          
                                             k
                                          
                                       
                                       ∈
                                       
                                          
                                             
                                                ⋂
                                             
                                             
                                                s
                                                =
                                                k
                                                +
                                                1
                                             
                                             
                                                p
                                             
                                          
                                       
                                       
                                          
                                             N
                                          
                                          
                                             
                                                
                                                   i
                                                
                                                
                                                   s
                                                
                                             
                                          
                                       
                                    
                                 
                              
                              ∪
                              {
                              
                                 
                                    i
                                 
                                 
                                    p
                                 
                              
                              }
                              .
                           
                        
                     
                  

Given 
                        
                           d
                           (
                           P
                           )
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 ∈
                                 C
                                 (
                                 P
                                 )
                              
                           
                           
                              
                                 d
                              
                              
                                 i
                              
                           
                        
                      as the total demand serviced by path P and 
                        
                           c
                           (
                           P
                           )
                        
                      as the total cost of path P, let 
                        
                           L
                           (
                           P
                           )
                           =
                           (
                           
                              
                                 i
                              
                              
                                 p
                              
                           
                           ,
                           d
                           (
                           P
                           )
                           ,
                           Π
                           (
                           P
                           )
                           ,
                           c
                           (
                           P
                           )
                           )
                        
                      be a label associated with a path P, which ends at customer 
                        
                           
                              
                                 i
                              
                              
                                 p
                              
                           
                        
                     . We say that a label 
                        
                           L
                           (
                           P
                           )
                        
                      can be extended to a customer 
                        
                           
                              
                                 i
                              
                              
                                 p
                                 +
                                 1
                              
                           
                        
                      if 
                        
                           
                              
                                 i
                              
                              
                                 p
                                 +
                                 1
                              
                           
                           
                           ∉
                           
                           Π
                           (
                           P
                           )
                        
                      and 
                        
                           d
                           (
                           P
                           )
                           +
                           
                              
                                 d
                              
                              
                                 
                                    
                                       i
                                    
                                    
                                       p
                                       +
                                       1
                                    
                                 
                              
                           
                           ⩽
                           Q
                        
                     . After the extension, the customer 
                        
                           
                              
                                 i
                              
                              
                                 p
                                 +
                                 1
                              
                           
                        
                      becomes the last customer of a new path 
                        
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                           =
                           (
                           0
                           ,
                           …
                           ,
                           
                              
                                 i
                              
                              
                                 p
                              
                           
                           ,
                           
                              
                                 i
                              
                              
                                 p
                                 +
                                 1
                              
                           
                           )
                        
                      and a new label 
                        
                           L
                           (
                           
                              
                                 P
                              
                              
                                 ′
                              
                           
                           )
                        
                      can be obtained from the label 
                        
                           L
                           (
                           P
                           )
                        
                      by the following operations:
                        
                           (2)
                           
                              L
                              (
                              
                                 
                                    P
                                 
                                 
                                    ′
                                 
                              
                              )
                              =
                              (
                              
                                 
                                    i
                                 
                                 
                                    p
                                    +
                                    1
                                 
                              
                              ,
                              d
                              (
                              P
                              )
                              +
                              
                                 
                                    d
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          p
                                          +
                                          1
                                       
                                    
                                 
                              
                              ,
                              Π
                              (
                              P
                              )
                              ∩
                              
                                 
                                    N
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          p
                                          +
                                          1
                                       
                                    
                                 
                              
                              ∪
                              {
                              
                                 
                                    i
                                 
                                 
                                    p
                                    +
                                    1
                                 
                              
                              }
                              ,
                              c
                              (
                              P
                              )
                              +
                              
                                 
                                    c
                                 
                                 
                                    
                                       
                                          i
                                       
                                       
                                          p
                                       
                                    
                                    
                                       
                                          i
                                       
                                       
                                          p
                                          +
                                          1
                                       
                                    
                                 
                              
                              )
                              .
                           
                        
                     
                  

These labels are computed using a forward dynamic programming algorithm and, in contrast to the q-route relaxation, it does not result in a pseudo-polynomial complexity. This algorithm is exponential on the size of 
                        
                           Δ
                           (
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                           )
                        
                     , remaining pseudo-polynomial for fixed 
                        
                           Δ
                           (
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                           )
                        
                     . Furthermore, its efficiency depends on the use of some techniques to speed up its execution.

To reduce the number of possible paths, a dominance rule is incorporated into the algorithm. Given the labels of two paths 
                        
                           L
                           (
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                           )
                        
                      and 
                        
                           L
                           (
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                           )
                        
                     , path 
                        
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        
                      dominates path 
                        
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        
                      if and only if every possible extension from 
                        
                           
                              
                                 P
                              
                              
                                 2
                              
                           
                        
                      can be done from 
                        
                           
                              
                                 P
                              
                              
                                 1
                              
                           
                        
                      with a lower or equal total cost. For this to be true, the following three conditions must hold:
                        
                           (i)
                           
                              
                                 
                                    d
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                    )
                                    ⩽
                                    d
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                              ,


                              
                                 
                                    c
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                    )
                                    ⩽
                                    c
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                               and


                              
                                 
                                    Π
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          1
                                       
                                    
                                    )
                                    ⊆
                                    Π
                                    (
                                    
                                       
                                          P
                                       
                                       
                                          2
                                       
                                    
                                    )
                                 
                              .

As discussed earlier, a basic ng-route relaxation implementation does not allow the use of large ng-sets, a limitation which weakens the quality of the lower bounds found. To address this issue, we provide an efficient implementation, adapting the Decremental State Space Relaxation for the ng-route relaxation. This technique was introduced by Righini and Salani (2008) to solve the ESPPRC. The original version of the algorithm helps reduce the number of labels to be managed during the dynamic programming algorithm that builds elementary paths. First, it relaxes the elementarity of the paths and, at each iteration, identifies which customers are being repeated on the best path found and then prohibits the repetition of these customers in subsequent iterations.

The main difference of our algorithm is that instead of relaxing the elementarity of the paths, the new algorithm relaxes the ng-set of each customer, therefore relaxing the ng-route restrictions.

We start by creating a 
                           
                              (
                              Q
                              +
                              1
                              )
                              ×
                              |
                              C
                              |
                           
                         dynamic programming matrix 
                           
                              M
                           
                        , where each entry 
                           
                              M
                              (
                              d
                              ,
                              i
                              )
                           
                         is a bucket containing labels representing paths that start at the depot and end at customer i with total demand equal to d. At first, we set 
                           
                              M
                              (
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              ,
                              i
                              )
                           
                         with a single label 
                           
                              
                                 
                                    L
                                 
                                 
                                    i
                                 
                              
                              =
                              (
                              i
                              ,
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              ,
                              {
                              i
                              }
                              ,
                              
                                 
                                    c
                                 
                                 
                                    0
                                    i
                                 
                              
                              )
                              ,
                              ∀
                              i
                              ∈
                              C
                           
                        , and all other entries with no label. Next, a forward dynamic programming is used to fill the matrix 
                           
                              M
                           
                        , running from 
                           
                              d
                              =
                              1
                           
                         up to 
                           
                              d
                              =
                              Q
                           
                        .


                        Algorithm 1 presents the pseudocode of our basic dynamic programming procedure. When processing the bucket 
                           
                              M
                              (
                              d
                              ,
                              i
                              )
                           
                        , the algorithm iterates through all labels 
                           
                              L
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         belonging to 
                           
                              M
                              (
                              d
                              -
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              ,
                              j
                              )
                           
                        , for all customers 
                           
                              j
                              ∈
                              C
                           
                        , such that 
                           
                              d
                              -
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              >
                              0
                           
                        . As the basic ng-route relaxation algorithm, the extension from 
                           
                              L
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                           
                         to i can only be performed if 
                           
                              i
                              
                              ∉
                              
                              Π
                              (
                              
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        . If this condition holds, a new label, say 
                           
                              L
                              (
                              
                                 
                                    P
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , is then created and it must be stored in the bucket 
                           
                              M
                              (
                              d
                              ,
                              i
                              )
                           
                        . Therefore, this is the right time to check for the dominance rule, which can be verified for all the labels in 
                           
                              M
                              (
                              
                                 
                                    d
                                 
                                 
                                    ′
                                 
                              
                              ,
                              i
                              )
                              ,
                              ∀
                              
                                 
                                    d
                                 
                                 
                                    ′
                                 
                              
                              ⩽
                              d
                           
                        . Surprisingly, we have found that the algorithm runs faster if the dominance rule is tested only for labels of the same bucket, i.e., for the labels from inside 
                           
                              M
                              (
                              d
                              ,
                              i
                              )
                           
                        . This comes from the fact that labels associated with paths using less capacity are unlikely to dominate others using higher capacity.

In addition, Baldacci et al. (2011) described another way to improve the dominance rule. When the paths of the bucket 
                           
                              M
                              (
                              d
                              ,
                              i
                              )
                           
                         are being computed, the algorithm uses a dominance list associated with the customer i, which stores the best costs for every possible configuration of 
                           
                              Π
                              (
                              P
                              )
                           
                         and 
                           
                              
                                 
                                    d
                                 
                                 
                                    ′
                                 
                              
                              <
                              d
                           
                        , to do the dominance. This way, it is faster to check the list than to iterate through the dynamic programming matrix for each 
                           
                              
                                 
                                    d
                                 
                                 
                                    ′
                                 
                              
                              <
                              d
                           
                        . We do not use this technique because it is not scalable, as the size of the dominance list is exponential in the value of 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , reaching its size limit when 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                              ≈
                              13
                           
                        .


                        Algorithm 1 also presupposes the existence of procedure buildRoutes, which takes matrix 
                           
                              M
                           
                         as a parameter and extracts the best routes from it.
                           Algorithm 1
                           Basic Dynamic Programming ng-Route Algorithm
                                 
                                    
                                       
                                       
                                          
                                             
                                                1: procedure DynamicProgramming(
                                                   
                                                      M
                                                      ,
                                                      N
                                                   
                                                )
                                          
                                          
                                             
                                                2: 
                                                input: matrix 
                                                   
                                                      M
                                                   
                                                 and ng-sets 
                                                   
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ⊆
                                                      C
                                                      ,
                                                      ∀
                                                      i
                                                      ∈
                                                      C
                                                   
                                                .
                                          
                                          
                                             
                                                3: 
                                                output: the best ng-routes with respect to ng-sets 
                                                   
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                                4: 
                                                
                                                   
                                                      M
                                                      (
                                                      d
                                                      ,
                                                      i
                                                      )
                                                      ←
                                                      ∅
                                                      ,
                                                      ∀
                                                      i
                                                      ∈
                                                      C
                                                      ,
                                                      d
                                                      ∈
                                                      {
                                                      0
                                                      ,
                                                      …
                                                      ,
                                                      Q
                                                      }
                                                   
                                                
                                             
                                          
                                          
                                             
                                                5: 
                                                
                                                   
                                                      M
                                                      (
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      i
                                                      )
                                                      ←
                                                      {
                                                      (
                                                      i
                                                      ,
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      {
                                                      i
                                                      }
                                                      ,
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            0
                                                            i
                                                         
                                                      
                                                      )
                                                      }
                                                      ,
                                                      ∀
                                                      i
                                                      ∈
                                                      C
                                                   
                                                
                                             
                                          
                                          
                                             
                                                6: 
                                                for 
                                                
                                                   
                                                      d
                                                      ≔
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      Q
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                7: 
                                                for all 
                                                
                                                   
                                                      i
                                                      ∈
                                                      C
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                8: 
                                                
                                                if 
                                                
                                                   
                                                      d
                                                      -
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      >
                                                      0
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                9: 
                                                
                                                for all 
                                                
                                                   
                                                      j
                                                      ∈
                                                      C
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             10: 
                                                
                                                
                                                for all 
                                                
                                                   
                                                      L
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      )
                                                      ∈
                                                      M
                                                      (
                                                      d
                                                      -
                                                      
                                                         
                                                            d
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ,
                                                      j
                                                      )
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             11: 
                                                
                                                
                                                if 
                                                
                                                   
                                                      i
                                                      
                                                      ∉
                                                      
                                                      Π
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             12: 
                                                
                                                
                                                
                                                
                                                   
                                                      L
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                      ←
                                                      (
                                                      i
                                                      ,
                                                      d
                                                      ,
                                                      Π
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      )
                                                      ∩
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      ∪
                                                      {
                                                      i
                                                      }
                                                      ,
                                                      c
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                      )
                                                      +
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ji
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             13: 
                                                
                                                
                                                
                                                
                                                   
                                                      insertLabel
                                                      ←
                                                   
                                                 
                                                true
                                             
                                          
                                          
                                             14: 
                                                
                                                
                                                
                                                for all 
                                                
                                                   
                                                      L
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     P
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     ′
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                      ∈
                                                      M
                                                      (
                                                      d
                                                      ,
                                                      i
                                                      )
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             15: 
                                                
                                                
                                                
                                                if 
                                                
                                                   
                                                      L
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                 dominates 
                                                   
                                                      L
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     P
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     ′
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             16: 
                                                
                                                
                                                
                                                delete 
                                                   
                                                      L
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     P
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     ′
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             17: 
                                                
                                                
                                                
                                                else if 
                                                
                                                   
                                                      L
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     P
                                                                  
                                                                  
                                                                     i
                                                                  
                                                                  
                                                                     ′
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                 dominates 
                                                   
                                                      L
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             18: 
                                                
                                                
                                                
                                                
                                                
                                                   
                                                      insertLabel
                                                      ←
                                                   
                                                 
                                                false
                                             
                                          
                                          
                                             19: 
                                                
                                                
                                                
                                                
                                                break
                                             
                                          
                                          
                                             20: 
                                                
                                                
                                                
                                                if 
                                                insertLabel 
                                                then
                                             
                                          
                                          
                                             21: 
                                                
                                                
                                                
                                                
                                                   
                                                      M
                                                      (
                                                      d
                                                      ,
                                                      i
                                                      )
                                                      ←
                                                      M
                                                      (
                                                      d
                                                      ,
                                                      i
                                                      )
                                                      ∪
                                                      L
                                                      (
                                                      
                                                         
                                                            P
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             22: 
                                                return buildRoutes (
                                                   
                                                      M
                                                   
                                                )
                                          
                                       
                                    
                                 
                              
                           

The adapted DSSR is an iterative algorithm and it works by relaxing the state space of the original ng-sets 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                           . At each iteration k, the algorithm uses the subsets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                                 ⊆
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                            as a replacement for 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                           . These subsets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                              
                            take the role of 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                            in the definition of the function 
                              
                                 Π
                              
                           , described in Eq. (1), and in the creation of new labels, as shown in Eq. (2). Initially, the algorithm sets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       0
                                    
                                 
                                 ,
                                 ∀
                                 i
                                 ∈
                                 C
                              
                           , as an empty set and executes the basic dynamic programming Algorithm 1. As the best routes found by this dynamic programming are not necessarily ng-routes w.r.t. the original ng-sets 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                           , they cannot be considered as the result of the pricing without verifying their feasibility. This test is performed and the 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                              
                            subsets are updated if necessary, as described hereafter. If at the end of iteration k some subset 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                              
                            is updated, the dynamic programming algorithm is executed again with new subsets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                              
                           .

Let a cycle of customers be defined as a sub-path 
                              
                                 H
                                 =
                                 (
                                 i
                                 ,
                                 …
                                 ,
                                 j
                                 )
                              
                           , where 
                              
                                 i
                                 =
                                 j
                              
                           , and let 
                              
                                 H
                                 (
                                 P
                                 )
                              
                            be the set of all cycles of customers in the path P. To evaluate if the best route 
                              
                                 
                                    
                                       R
                                    
                                    
                                       k
                                    
                                    
                                       ∗
                                    
                                 
                              
                            found in the end of iteration k is an ng-route, the algorithm must check if there is no cycle 
                              
                                 H
                                 ∈
                                 H
                                 
                                    
                                       
                                          
                                             
                                                R
                                             
                                             
                                                k
                                             
                                             
                                                ∗
                                             
                                          
                                       
                                    
                                 
                              
                            which would not be allowed to be created if the original ng-sets 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                            were being used. This happens only when the first customer j of cycle H (we also refer to it as the repeated customer of the cycle) is in all 
                              
                                 
                                    
                                       N
                                    
                                    
                                       l
                                    
                                 
                                 ,
                                 ∀
                                 l
                                 ∈
                                 C
                                 (
                                 H
                                 )
                              
                           , i.e., customer j is not “forgotten” by any other customer of the cycle. In this case, we designate such a cycle H as a forbidden cycle w.r.t the original ng-sets 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                           . If any such cycle H is found, we add the repeated customer j to subsets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       l
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 ,
                                 ∀
                                 l
                                 ∈
                                 C
                                 (
                                 H
                                 )
                              
                           . This prohibits cycle H from appearing in any path obtained in the next iterations. More than that, this prohibits any cycle 
                              
                                 
                                    
                                       H
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 (
                                 j
                                 ,
                                 …
                                 ,
                                 j
                                 )
                              
                            in which 
                              
                                 C
                                 (
                                 
                                    
                                       H
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 ⊆
                                 C
                                 (
                                 H
                                 )
                              
                            from appearing in the next iterations. On the other hand, if no such forbidden cycle is found at the end of iteration k, then the best route 
                              
                                 
                                    
                                       R
                                    
                                    
                                       k
                                    
                                    
                                       ∗
                                    
                                 
                              
                            is an ng-route and the algorithm stops.


                           Algorithm 2 reports the DSSR procedure. The input parameter of the algorithm is the original ng-sets 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 ∀
                                 i
                                 ∈
                                 C
                              
                           . The procedures with self-explanatory names selectBestRoute, isNGRoute and updateNGSets are responsible, respectively, for extracting the best route of a set of routes, determining if a given route is a valid ng-route with respect to ng-sets 
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                    
                                 
                              
                            and to update the subsets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                              
                            to the next iteration. Algorithm 2 also uses the procedure dynamicProgramming, which is presented in Algorithm 1, to obtain ng-routes with respect to subsets 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                              
                            passed as input parameters.
                              Algorithm 2
                              Pure DSSR ng-Route Algorithm
                                    
                                       
                                          
                                          
                                             
                                                
                                                   1: procedure DSSR(
                                                      
                                                         M
                                                         ,
                                                         N
                                                      
                                                   )
                                             
                                             
                                                
                                                   2: 
                                                   input: matrix 
                                                      
                                                         M
                                                      
                                                    and ng-sets 
                                                      
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ⊆
                                                         C
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                      
                                                   .
                                             
                                             
                                                
                                                   3: 
                                                   output: the best ng-routes with respect to ng-sets 
                                                      
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                   .
                                             
                                             
                                                
                                                   
                                                
                                             
                                             
                                                
                                                   4: 
                                                   
                                                      
                                                         
                                                            
                                                               Γ
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ←
                                                         ∅
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                         ,
                                                         ng
                                                         ←
                                                      
                                                    
                                                   false, 
                                                      
                                                         k
                                                         ←
                                                         0
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   5: 
                                                   while not ng 
                                                   do
                                                
                                             
                                             
                                                
                                                   6: 
                                                   
                                                      
                                                         R
                                                         ←
                                                      
                                                    dynamicProgramming (
                                                      
                                                         M
                                                         ,
                                                         Γ
                                                      
                                                   )
                                             
                                             
                                                
                                                   7: 
                                                   
                                                      
                                                         
                                                            
                                                               R
                                                            
                                                            
                                                               k
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         ←
                                                      
                                                    selectBestRoute (
                                                      
                                                         R
                                                      
                                                   )
                                             
                                             
                                                
                                                   8: 
                                                   if isNGRoute
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        R
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                     
                                                                        ∗
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                
                                                   9: 
                                                   
                                                   
                                                      
                                                         ng
                                                         ←
                                                      
                                                    
                                                   true
                                                
                                             
                                             
                                                10: 
                                                   else
                                                
                                             
                                             
                                                11: 
                                                   updateNGSets
                                                      
                                                         
                                                            
                                                               
                                                                  N
                                                                  ,
                                                                  
                                                                     
                                                                        R
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                     
                                                                        ∗
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                12: 
                                                   
                                                      
                                                         k
                                                         ←
                                                         k
                                                         +
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                13: 
                                                   return 
                                                   
                                                      
                                                         R
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                
                                             
                                             
                                                14: procedure 
                                                   isNGRoute(R)
                                             
                                             
                                                15: 
                                                   for all 
                                                   
                                                      
                                                         H
                                                         =
                                                         (
                                                         v
                                                         ,
                                                         …
                                                         ,
                                                         v
                                                         )
                                                         ∈
                                                         H
                                                         (
                                                         R
                                                         )
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                16: 
                                                   
                                                      
                                                         forbiddenCycle
                                                         ←
                                                      
                                                    
                                                   true
                                                
                                             
                                             
                                                17: 
                                                   for all 
                                                   
                                                      
                                                         l
                                                         ∈
                                                         C
                                                         (
                                                         H
                                                         )
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                18: 
                                                   
                                                   if 
                                                   
                                                      
                                                         v
                                                         
                                                         ∉
                                                         
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               l
                                                            
                                                         
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                19: 
                                                   
                                                   
                                                      
                                                         forbiddenCycle
                                                         ←
                                                      
                                                    
                                                   false
                                                
                                             
                                             
                                                20: 
                                                   
                                                   break
                                                
                                             
                                             
                                                21: 
                                                   if 
                                                   forbiddenCycle 
                                                   then
                                                
                                             
                                             
                                                22: 
                                                   
                                                   return false
                                                
                                             
                                             
                                                23: 
                                                   return true
                                                
                                             
                                             
                                                
                                                   
                                                
                                             
                                             
                                                24: procedure 
                                                   updateNGSets(
                                                      
                                                         N
                                                         ,
                                                         R
                                                      
                                                   )
                                             
                                             
                                                25: 
                                                   for all 
                                                   
                                                      
                                                         H
                                                         =
                                                         (
                                                         v
                                                         ,
                                                         …
                                                         ,
                                                         v
                                                         )
                                                         ∈
                                                         H
                                                         (
                                                         R
                                                         )
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                26: 
                                                   
                                                      
                                                         forbiddenCycle
                                                         ←
                                                      
                                                    
                                                   true
                                                
                                             
                                             
                                                27: 
                                                   for all 
                                                   
                                                      
                                                         l
                                                         ∈
                                                         C
                                                         (
                                                         H
                                                         )
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                28: 
                                                   
                                                   if 
                                                   
                                                      
                                                         v
                                                         
                                                         ∉
                                                         
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               l
                                                            
                                                         
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                29: 
                                                   
                                                   
                                                      
                                                         forbiddenCycle
                                                         ←
                                                      
                                                    
                                                   false
                                                
                                             
                                             
                                                30: 
                                                   
                                                   break
                                                
                                             
                                             
                                                31: 
                                                   if 
                                                   forbiddenCycle 
                                                   then
                                                
                                             
                                             
                                                32: 
                                                   
                                                   for all 
                                                   
                                                      
                                                         l
                                                         ∈
                                                         C
                                                         (
                                                         H
                                                         )
                                                      
                                                    
                                                   do 
                                                   
                                                      
                                                         
                                                            
                                                               Γ
                                                            
                                                            
                                                               l
                                                            
                                                         
                                                         ←
                                                         
                                                            
                                                               Γ
                                                            
                                                            
                                                               l
                                                            
                                                         
                                                         ∪
                                                         {
                                                         v
                                                         }
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

It is noteworthy to mention that if the best route found is indeed an ng-route, the algorithm can stop and return only this route. However, if the objective is to find a set of feasible solutions, the algorithm can also return this route together with any other route certified to be an ng-route. Furthermore, if the best route is not an ng-route and one needs to find any feasible solution, any route that is indeed an ng-route can be returned, even if the best route is not feasible. In this case, we consider it as being a heuristic run of the algorithm, not an exact one. This method is useful to quickly price routes on intermediate iterations of column generation algorithms, where there is no need to generate the optimal solution.

To further speed up the algorithm, we calculate completion bounds during the DSSR in a similar manner as performed by Pecin (2010) for the elementary route. At the end of iteration k, the completion bounds are calculated for each customer 
                              
                                 i
                                 ∈
                                 C
                              
                            with every capacity 
                              
                                 d
                                 ∈
                                 {
                                 0
                                 ,
                                 …
                                 ,
                                 Q
                                 }
                              
                           , and then used at iteration 
                              
                                 k
                                 +
                                 1
                              
                           . As mentioned before, the completion bounds are used to estimate a lower bound on the value of a route during its creation, thus discarding any route that would not lead to a negative reduced cost. Given 
                              
                                 
                                    
                                       T
                                    
                                    
                                       k
                                    
                                    
                                       ∗
                                    
                                 
                                 (
                                 d
                                 ,
                                 i
                                 )
                              
                           , the value of the best path which starts at customer i and ends at the depot with total capacity exactly d, the completion bounds 
                              
                                 
                                    
                                       
                                          
                                             T
                                          
                                          
                                             ^
                                          
                                       
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 d
                                 ,
                                 i
                                 )
                              
                            are calculated as shown in (3) and represent the value of the best path that starts at customer i and ends at the depot with total capacity less than or equal d.
                              
                                 (3)
                                 
                                    
                                       
                                          
                                             
                                                T
                                             
                                             
                                                ^
                                             
                                          
                                       
                                       
                                          k
                                       
                                    
                                    (
                                    d
                                    ,
                                    i
                                    )
                                    =
                                    
                                       
                                          
                                             min
                                          
                                          
                                             
                                                
                                                   d
                                                
                                                
                                                   ′
                                                
                                             
                                             ⩽
                                             d
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                
                                                   T
                                                
                                                
                                                   k
                                                
                                                
                                                   ∗
                                                
                                             
                                             (
                                             
                                                
                                                   d
                                                
                                                
                                                   ′
                                                
                                             
                                             ,
                                             i
                                             )
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        

It is important to observe that if the corresponding problem is represented by means of an undirected graph, 
                              
                                 
                                    
                                       T
                                    
                                    
                                       k
                                    
                                    
                                       ∗
                                    
                                 
                                 (
                                 d
                                 ,
                                 i
                                 )
                              
                            can be obtained directly from the dynamic programming matrix. This is true because the value of the best path that starts at the depot and ends at customer i with total capacity exactly d has the same value as 
                              
                                 
                                    
                                       T
                                    
                                    
                                       k
                                    
                                    
                                       ∗
                                    
                                 
                                 (
                                 d
                                 ,
                                 i
                                 )
                              
                           , as shown by Baldacci et al. (2011). The reason for this is that if the best forward path contains a cycle, then the best backward path may also contain this cycle and vice versa because at least one costumer belonging to this cycle must “forget” the customer that repeats. On the other hand, if the problem is represented using a directed graph, to obtain these values, the direction of the edges has to be reversed, as also shown by Baldacci et al. (2011). In this case, the last iteration of the DSSR algorithm has to be executed again before the calculation. This occurs because when a route is traversed in the opposite direction on an asymmetric graph, it does not generate the same cost.

After calculating the completion bounds at the end of iteration k, they can be used at iteration 
                              
                                 k
                                 +
                                 1
                              
                            to avoid the extension of a given label 
                              
                                 L
                                 (
                                 P
                                 )
                                 =
                                 (
                                 j
                                 ,
                                 d
                                 (
                                 P
                                 )
                                 ,
                                 Π
                                 (
                                 P
                                 )
                                 ,
                                 c
                                 (
                                 P
                                 )
                                 )
                              
                            to a customer i if the following conditions hold:
                              
                                 (4)
                                 
                                    c
                                    (
                                    P
                                    )
                                    +
                                    
                                       
                                          c
                                       
                                       
                                          ji
                                       
                                    
                                    +
                                    
                                       
                                          
                                             
                                                T
                                             
                                             
                                                ^
                                             
                                          
                                       
                                       
                                          k
                                       
                                    
                                    (
                                    Q
                                    -
                                    d
                                    (
                                    P
                                    )
                                    ,
                                    i
                                    )
                                    ⩾
                                    0
                                    .
                                 
                              
                           
                        

This equation calculates a lower bound on the value of the reduced cost of any route the label 
                              
                                 L
                                 (
                                 P
                                 )
                              
                            can generate, because 
                              
                                 
                                    
                                       
                                          
                                             T
                                          
                                          
                                             ^
                                          
                                       
                                    
                                    
                                       k
                                    
                                 
                                 (
                                 Q
                                 -
                                 d
                                 (
                                 P
                                 )
                                 ,
                                 i
                                 )
                              
                            is a lower bound on the value of the best path, which would close path P after it is extended to customer i. Obviously, if the value of Eq. (4) is greater or equal than zero, the label 
                              
                                 L
                                 (
                                 P
                                 )
                              
                            cannot generate any route with a negative reduced cost, and therefore, it can be discarded.

It is interesting to highlight that the completion bounds becomes stronger along the iterations of the DSSR, because iteration k is a relaxation of iteration 
                              
                                 k
                                 +
                                 1
                              
                           , i.e., given that 
                              
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                    
                                 
                                 ⊆
                                 
                                    
                                       Γ
                                    
                                    
                                       i
                                    
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 ,
                                 ∀
                                 i
                                 ∈
                                 C
                              
                           . These bounds can be used for other important parts of a branch-cut-and-price algorithm, such as route enumeration and variable fixing.


                           Algorithm 3 reports the pseudocode for pricing ng-routes with DSSR and completions bounds. The procedures selectBestRoute, isNGRoute and updateNGSets have the same meaning as before and generateCompletionBounds is a new procedure that calculates the bounds as shown in (3). The procedure BoundedDynamicProgramming is a slight modification of procedure dynamicProgramming of Algorithm 1, that targets only inclusion of the completion bounds calculated as shown in (4).
                              Algorithm 3
                              DSSR with Completion Bounds ng-Route Algorithm
                                    
                                       
                                          
                                          
                                             
                                                
                                                   1: procedure DSSRwithBounds(
                                                      
                                                         M
                                                         ,
                                                         N
                                                      
                                                   )
                                             
                                             
                                                
                                                   2: 
                                                   input: matrix 
                                                      
                                                         M
                                                      
                                                    and ng-sets 
                                                      
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ⊆
                                                         C
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                      
                                                   .
                                             
                                             
                                                
                                                   3: 
                                                   output: the best ng-routes with respect to ng-sets 
                                                      
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                   .
                                             
                                             
                                                
                                                   
                                                
                                             
                                             
                                                
                                                   4: 
                                                   
                                                      
                                                         
                                                            
                                                               Γ
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ←
                                                         ∅
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                         ,
                                                         ng
                                                         ←
                                                      
                                                    
                                                   false, 
                                                      
                                                         k
                                                         ←
                                                         0
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   5: 
                                                   
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         -
                                                         ∞
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                         ,
                                                         d
                                                         ∈
                                                         {
                                                         0
                                                         ,
                                                         …
                                                         ,
                                                         Q
                                                         }
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   6: 
                                                   while not ng 
                                                   do
                                                
                                             
                                             
                                                
                                                   7: 
                                                   
                                                      
                                                         R
                                                         ←
                                                      
                                                    BoundedDynamicProgramming (
                                                      
                                                         M
                                                         ,
                                                         Γ
                                                         ,
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                      
                                                   )
                                             
                                             
                                                
                                                   8: 
                                                   
                                                      
                                                         
                                                            
                                                               R
                                                            
                                                            
                                                               k
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         ←
                                                      
                                                    selectBestRoute (R)
                                             
                                             
                                                
                                                   9: 
                                                   if isNGRoute
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        R
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                     
                                                                        ∗
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                10: 
                                                   
                                                   
                                                      
                                                         ng
                                                         ←
                                                      
                                                    
                                                   true
                                                
                                             
                                             
                                                11: 
                                                   else
                                                
                                             
                                             
                                                12: 
                                                   updateNGSets
                                                      
                                                         
                                                            
                                                               
                                                                  N
                                                                  ,
                                                                  
                                                                     
                                                                        R
                                                                     
                                                                     
                                                                        k
                                                                     
                                                                     
                                                                        ∗
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                13: 
                                                   generateCompletionBounds (
                                                      
                                                         M
                                                         ,
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                      
                                                   )
                                             
                                             
                                                14: 
                                                   
                                                      
                                                         k
                                                         ←
                                                         k
                                                         +
                                                         1
                                                      
                                                   
                                                
                                             
                                             
                                                15: 
                                                   return 
                                                   R
                                                
                                             
                                             
                                                
                                                   
                                                
                                             
                                             
                                                16: procedure BoundedDynamicProgramming(
                                                      
                                                         M
                                                         ,
                                                         Γ
                                                         ,
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                      
                                                   )
                                             
                                             
                                                17: 
                                                   
                                                      
                                                         M
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         ∅
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                         ,
                                                         d
                                                         ∈
                                                         {
                                                         0
                                                         ,
                                                         …
                                                         ,
                                                         Q
                                                         }
                                                      
                                                   
                                                
                                             
                                             
                                                18: 
                                                   
                                                      
                                                         M
                                                         (
                                                         
                                                            
                                                               d
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         {
                                                         (
                                                         i
                                                         ,
                                                         
                                                            
                                                               d
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ,
                                                         {
                                                         i
                                                         }
                                                         ,
                                                         
                                                            
                                                               
                                                                  
                                                                     c
                                                                  
                                                                  
                                                                     ¯
                                                                  
                                                               
                                                            
                                                            
                                                               0
                                                               i
                                                            
                                                         
                                                         )
                                                         }
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                      
                                                   
                                                
                                             
                                             
                                                19: 
                                                   for 
                                                   
                                                      
                                                         d
                                                         ≔
                                                         1
                                                         ,
                                                         …
                                                         ,
                                                         Q
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                20: 
                                                   for all 
                                                   
                                                      
                                                         i
                                                         ∈
                                                         C
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                21: 
                                                   
                                                   if 
                                                   
                                                      
                                                         d
                                                         -
                                                         
                                                            
                                                               d
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         >
                                                         0
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                22: 
                                                   
                                                   for all 
                                                   
                                                      
                                                         j
                                                         ∈
                                                         C
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                23: 
                                                   
                                                   
                                                   for all 
                                                   
                                                      
                                                         L
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                         ∈
                                                         M
                                                         (
                                                         d
                                                         -
                                                         
                                                            
                                                               d
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ,
                                                         j
                                                         )
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                24: 
                                                   
                                                   
                                                   if 
                                                   
                                                      
                                                         i
                                                         
                                                         ∉
                                                         
                                                         Π
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                25: 
                                                   
                                                   
                                                   
                                                   if checkCompletionBound (
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         ,
                                                         L
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                         ,
                                                         i
                                                      
                                                   ) then
                                                
                                             
                                             
                                                26: 
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         L
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                         ←
                                                         (
                                                         i
                                                         ,
                                                         d
                                                         ,
                                                         Π
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                         ∩
                                                         
                                                            
                                                               N
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         ∪
                                                         {
                                                         i
                                                         }
                                                         ,
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ¯
                                                            
                                                         
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               j
                                                            
                                                         
                                                         )
                                                         +
                                                         
                                                            
                                                               
                                                                  
                                                                     c
                                                                  
                                                                  
                                                                     ¯
                                                                  
                                                               
                                                            
                                                            
                                                               ji
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                27: 
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         insertLabel
                                                         ←
                                                      
                                                    
                                                   true
                                                
                                             
                                             
                                                28: 
                                                   
                                                   
                                                   
                                                   for all 
                                                   
                                                      
                                                         L
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         ∈
                                                         M
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                29: 
                                                   
                                                   
                                                   
                                                   
                                                   if 
                                                   
                                                      
                                                         L
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                      
                                                    dominates 
                                                      
                                                         L
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                30: 
                                                   
                                                   
                                                   
                                                   delete 
                                                      
                                                         L
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                31: 
                                                   
                                                   
                                                   
                                                   
                                                   else if 
                                                   
                                                      
                                                         L
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        P
                                                                     
                                                                     
                                                                        i
                                                                     
                                                                     
                                                                        ′
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                    dominates 
                                                      
                                                         L
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                32: 
                                                   
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         insertLabel
                                                         ←
                                                      
                                                    
                                                   false
                                                
                                             
                                             
                                                33: 
                                                   
                                                   
                                                   
                                                   
                                                   break
                                                
                                             
                                             
                                                34: 
                                                   
                                                   
                                                   
                                                   if 
                                                   insertLabel 
                                                   then
                                                
                                             
                                             
                                                35: 
                                                   
                                                   
                                                   
                                                   
                                                   
                                                      
                                                         M
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         M
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ∪
                                                         L
                                                         (
                                                         
                                                            
                                                               P
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                36: return buildRoutes (
                                                      
                                                         M
                                                      
                                                   )
                                             
                                             
                                                37: procedure 
                                                   generateCompletionBounds(
                                                      
                                                         M
                                                         ,
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                      
                                                   )
                                             
                                             
                                                38: 
                                                   
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         ∞
                                                         ,
                                                         ∀
                                                         i
                                                         ∈
                                                         C
                                                         ,
                                                         d
                                                         ∈
                                                         {
                                                         0
                                                         ,
                                                         …
                                                         ,
                                                         Q
                                                         }
                                                      
                                                   
                                                
                                             
                                             
                                                39: 
                                                   
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         0
                                                         ,
                                                         0
                                                         )
                                                         ←
                                                         0
                                                      
                                                   
                                                
                                             
                                             
                                                40: 
                                                   for 
                                                   
                                                      
                                                         i
                                                         ∈
                                                         C
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                41: 
                                                   for 
                                                   
                                                      
                                                         d
                                                         ≔
                                                         1
                                                         ,
                                                         …
                                                         ,
                                                         Q
                                                      
                                                    
                                                   do
                                                
                                             
                                             
                                                42: 
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         min
                                                         (
                                                         M
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                43: 
                                                   
                                                   if 
                                                   
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         -
                                                         1
                                                         ,
                                                         i
                                                         )
                                                         <
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                      
                                                    
                                                   then
                                                
                                             
                                             
                                                44: 
                                                   
                                                   
                                                   
                                                      
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         ,
                                                         i
                                                         )
                                                         ←
                                                         
                                                            
                                                               T
                                                            
                                                            
                                                               ^
                                                            
                                                         
                                                         (
                                                         d
                                                         -
                                                         1
                                                         ,
                                                         i
                                                         )
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              

Even with the improvements described in Section 4.2, the exact ng-route pricing still requires a long time to be executed. Because of this, a simple but effective heuristic was developed to quickly price a large initial set of routes with negative reduced cost. It was based on the heuristic pricing done for the elementary route pricing by Pecin (2010). The purpose of this heuristic is to reduce the number of calls to the exact ng-route pricing. Therefore, the heuristic ng-route pricing is used as a hot-start for the exact ng-route pricing.

The heuristic closely resembles the q-route pricing without eliminating any cycle. The main difference between the pricing algorithms is that when extending one path, the heuristic ng-route pricing respects the ng-sets 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                           
                        . Its data structure is also a 
                           
                              (
                              Q
                              +
                              1
                              )
                              ×
                              |
                              C
                              |
                           
                         matrix, and each entry consists of just one label. For each customer and each capacity, this label is chosen as the best one with respect to the reduced costs. In addition, as the ng-sets 
                           
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                           
                         must be respected, each label of the dynamic programming matrix must contain the 
                           
                              Π
                           
                         sets for each customer and capacity.

Notice that unlike the exact algorithms, the heuristic algorithms use neither the dominance rules nor the speed-up techniques (DSSR and completion bounds) described in Section 4. Nevertheless, they are responsible for obtaining approximately 90% of the routes during the column generation. Moreover, it is straightforward to verify that the resulting complexity of the algorithms is 
                           
                              O
                              (
                              
                                 
                                    n
                                 
                                 
                                    2
                                 
                              
                              Q
                              )
                           
                        .

To achieve elementarity, we change the definition of the 
                        
                           
                              
                                 Γ
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                        
                      sets used in the DSSR algorithm. Instead of being a subset of the 
                        
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                        
                      sets, which are defined a priori and have a fixed size 
                        
                           Δ
                           (
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                           )
                        
                     , the algorithm uses 
                        
                           
                              
                                 Γ
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                           ⊆
                           C
                        
                     . In this case, it will allow the insertion of any customer of the instance. In addition, the algorithm is quite the same the one described in Section 4. The only difference is in the DSSR feasibility test, described as follows.

The algorithm starts with empties 
                        
                           
                              
                                 Γ
                              
                              
                                 l
                              
                              
                                 0
                              
                           
                           ,
                           ∀
                           l
                           ∈
                           C
                        
                     . At the end of each iteration k, it identifies all cycles on the best solution, and the repeated customer of each cycle 
                        
                           H
                           ∈
                           H
                           
                              
                                 
                                    
                                       
                                          R
                                       
                                       
                                          k
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                        
                      is inserted on subsets 
                        
                           
                              
                                 Γ
                              
                              
                                 l
                              
                              
                                 k
                                 +
                                 1
                              
                           
                           ,
                           ∀
                           l
                           ∈
                           C
                           (
                           H
                           )
                        
                     . Thus, if cycle 
                        
                           H
                           =
                           (
                           i
                           ,
                           …
                           ,
                           j
                           )
                           ,
                           i
                           =
                           j
                        
                     , is identified at the end of iteration k (that is, if cycle H belongs to 
                        
                           H
                           
                              
                                 
                                    
                                       
                                          R
                                       
                                       
                                          k
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                        
                     ), the next DSSR iterations will not generate any path with a cycle 
                        
                           
                              
                                 H
                              
                              
                                 ′
                              
                           
                           =
                           (
                           i
                           ,
                           …
                           ,
                           j
                           )
                        
                     , in which 
                        
                           C
                           (
                           
                              
                                 H
                              
                              
                                 ′
                              
                           
                           )
                           ⊆
                           C
                           (
                           H
                           )
                        
                     . Note, however, that it is still possible to obtain a path that visits customer j more than once at iteration 
                        
                           k
                           +
                           1
                        
                     , as this customer is not present in all subsets 
                        
                           
                              
                                 Γ
                              
                              
                                 l
                              
                              
                                 k
                                 +
                                 1
                              
                           
                        
                     . The algorithm stops when the best route does not contain any cycle, i.e. it is an elementary route, or its reduced cost is non-negative.

The way the algorithm increases the state space along the DSSR iterations resembles the method used by Righini and Salani (2008), however the differences control better the growth of the number of labels, turning the algorithm capable of dealing with larger instances. The DSSR of Righini and Salani (2008) is performed prohibiting the customers which repeat on the best route 
                        
                           
                              
                                 R
                              
                              
                                 k
                              
                              
                                 ∗
                              
                           
                        
                      from repeating again in subsequent iterations until an elementary route is found. This is equivalent to inserting each repeated customer of each cycle 
                        
                           H
                           ∈
                           H
                           (
                           
                              
                                 R
                              
                              
                                 k
                              
                              
                                 ∗
                              
                           
                           )
                        
                      in all subsets 
                        
                           
                              
                                 Γ
                              
                              
                                 i
                              
                              
                                 k
                                 +
                                 1
                              
                           
                        
                     , rather than just considering this inclusion in subsets 
                        
                           
                              
                                 Γ
                              
                              
                                 l
                              
                              
                                 k
                                 +
                                 1
                              
                           
                           ,
                           ∀
                           l
                           ∈
                           C
                           (
                           H
                           )
                        
                     .

We noted in computational experiments that this more aggressive manner of increase of the state space is quite dangerous because the whole algorithm fails if the number of labels to be treated in the dynamic programming becomes critical. In contrast, the size of the largest subset 
                        
                           
                              
                                 Γ
                              
                              
                                 i
                              
                              
                                 k
                              
                           
                        
                      hardly exceeded 20 in our algorithm, even for instances with 200 customers.

Another important difference from our approach and that of Righini and Salani (2008) is the way we use the DSSR to calculate completion bounds at each iteration to accelerate the subsequent DSSR iterations. Computational results reveal that the use of completion bounds allow us to solve the column generation for CVRP instances that would not be solved in an acceptable time if they were not used.

Furthermore, because the algorithm presented here aims to find only elementary routes, instead of using the heuristic pricing presented in Section 4.3, we implemented a heuristic pricing like the one described in Pecin (2010).

The Generalized Vehicle Routing Problem (GVRP) can be defined as follows. Let 
                        
                           G
                           =
                           (
                           V
                           ,
                           E
                           )
                        
                      be a graph with vertex set V and edge set E. There is a special vertex 0 called the depot. The vertices are partitioned into disjoint sets, called clusters, 
                        
                           C
                           =
                           {
                           
                              
                                 C
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 C
                              
                              
                                 t
                              
                           
                           }
                        
                     , where 
                        
                           
                              
                                 C
                              
                              
                                 0
                              
                           
                           =
                           {
                           0
                           }
                        
                      contains only the depot. Given the cluster index set 
                        
                           M
                           =
                           {
                           0
                           ,
                           1
                           ,
                           …
                           ,
                           t
                           }
                        
                     , let 
                        
                           μ
                           (
                           i
                           )
                           ∈
                           M
                        
                      be defined, for each vertex 
                        
                           i
                           ∈
                           V
                        
                     , as the index of the cluster which contains i. There exists a demand function 
                        
                           d
                           :
                           M
                           →
                           
                              
                                 Z
                              
                              
                                 +
                              
                           
                        
                      associated with all clusters, in which the depot has demand 
                        
                           
                              
                                 d
                              
                              
                                 0
                              
                           
                           =
                           0
                        
                     . These demands are to be serviced by a set 
                        
                           K
                        
                      of identical vehicles with capacity Q, located at the depot. The edge set 
                        
                           E
                           =
                           {
                           {
                           i
                           ,
                           j
                           }
                           |
                           i
                           ,
                           j
                           ∈
                           V
                           ,
                           μ
                           (
                           i
                           )
                           
                           ≠
                           
                           μ
                           (
                           j
                           )
                           }
                        
                      contains the edges between all pairs of vertices from different clusters. Associated with these edges, there exists a traversal cost function 
                        
                           c
                           :
                           E
                           →
                           
                              
                                 Z
                              
                              
                                 0
                              
                              
                                 +
                              
                           
                        
                     . Let 
                        
                           R
                        
                      be the set of all possible closed routes starting and ending at the depot. The objective of the GVRP is to select a subset of k routes from 
                        
                           R
                        
                      that: (i) minimizes the total traversal cost (ii) ensures that the demand from every cluster is serviced by a single vehicle on a single vertex from each cluster and (iii) ensures that the total demand serviced by each route does not exceed the vehicle capacity Q.

The GVRP is a generalization of the Capacitated Vehicle Routing Problem (CVRP) and the Generalized Traveling Salesman Problem (GTSP). When all the clusters contain only one vertex, it is simply the CVRP. Similarly, when there is only one vehicle, it is simply the GTSP. It is clear that when both conditions are true, it is simply the Traveling Salesman Problem (TSP). In the view of this, it is easy to see that any solution for the GVRP can be directly used to solve these problems.

This problem is strongly 
                        
                           NP
                        
                     -hard and has gained attention in the literature in recent years. To the best of our knowledge, the first published work to deal with this problem is Ghiani and Improta (2000), where a transformation to the Capacitated Arc Routing Problem (CARP) is presented to use the existing algorithms for the CARP. One instance was proposed and solved using this approach.

Since then, few works have been published on the GVRP. Recently, the work of Bektaş, Erdoğan, and Røpke (2011) has proposed four formulations for the GVRP. After extensive experiments with these formulations, a branch-and-cut algorithm was devised using one of them, an undirected formulation with an exponential number of constraints. The reader may consult this paper for further details on these formulations.

@&#EXPERIMENTAL RESULTS@&#

For the computational experiments, all algorithms were implemented in C++ using Microsoft Visual C++ 2010 Express and IBM ILOG CPLEX Optimizer 12.5 for solving the formulations. The experiments were conducted on an Intel Core i7-3960X 3.30GHz with 64GB RAM running Linux Ubuntu Server 12.04 LTS and are divided into two parts. First, we compare the three exact pricing algorithms described in this paper, that is, the basic dynamic programming, the pure DSSR and DSSR with completion bounds. This is enough to conclude that the latter is the best algorithm, and this evaluation is conducted by running each algorithm inside a column generation schema for some classical CVRP instances. All three algorithms were tested using different values of 
                        
                           Δ
                           (
                           
                              
                                 N
                              
                              
                                 i
                              
                           
                           )
                        
                     , allowing us to analyze the scalability of each one when the state space relaxation is increased. Second, using our best algorithm, we price elementary and restricted non-elementary routes for both GVRP and CVRP instances. To improve the lower bounds and also demonstrate that our algorithm still works well when robust cuts (see this terminology in work of Poggi de Aragão & Uchoa (2003)) are added in the SPP formulation, we included capacity inequalities and strengthened comb, both described in detail in the work of Lysgaard, Letchford, and Eglese (2004). We separated and added these cuts in a similar manner as done by Fukasawa et al. (2006) for the CVRP.

For all tests, the column generation starts by calling the heuristic pricing at each iteration. The heuristic pricing returns the best 20 routes with negative reduced costs. If the heuristic is no longer capable of finding routes with negative reduced cost, the column generation algorithm calls the exact pricing. If the latter succeeds in obtaining at least one route with negative reduced cost, the column generation procedure restarts by calling the heuristic pricing. Otherwise, the column generation stops and the current value is returned as a lower bound. This procedure is stopped prematurely if the time limit of two hours is exceeded.

For the GVRP, we applied our algorithms to the instance datasets recently generated by Bektaş et al. (2011). These instance datasets are derived from the CVRP instance datasets A, B, P and M. The transformation is performed using a method similar to that of Fischetti, Salazar-González, and Toth (1997), which transforms TSP instances into GTSP instances. The number of clusters is 
                           
                              t
                              =
                              ⌈
                              n
                              /
                              θ
                              ⌉
                           
                        , where 
                           
                              θ
                           
                         is a parameter defined a priori. For each original CVRP instance dataset, two new instance datasets were created, using 
                           
                              θ
                              =
                              2
                           
                         and 
                           
                              θ
                              =
                              3
                           
                        , resulting in 158 GVRP instances. All lower and upper bounds shown in the tables were taken from the work of Bektaş et al. (2011).

The name of the GVRP instances follows the general convention of the CVRP instance, although slightly modified to include additional parameters used. The general format is X-nY-kZ-C
                           
                              Ω
                           
                        -V
                           
                              Φ
                           
                        , where X corresponds to the type of the instance, Y refers to the number of vertices, Z corresponds to the number of vehicles in the original CVRP instance, 
                           
                              Ω
                           
                         is the number of clusters and 
                           
                              Φ
                           
                         is the number of vehicles in the GVRP instance. For all problem instances, we calculate the cost matrix using Euclidean distance rounded to the nearest integer value.

For the CVRP, we used just a representative set extracted from the classical instance datasets A, B, E, P and M. All optimal values shown in the tables were extracted from the work of Fukasawa et al. (2006), except the optimal value for instance M-n151-k12, which was first proved by Contardo (2012) and the optimal values for instances M-n200-k17 and M-n200-k16, which were first proved by the recent algorithm proposed by Pecin, Pessoa, Poggi, and Uchoa (2014).

@&#PERFORMANCE EVALUATION@&#

This section evaluates the performance of our three ng-route pricing algorithms: the simple dynamic programming (Algorithm 1), the pure state space relaxation (Algorithm 2) and finally the algorithm that combines the techniques of state space relaxation with completion bounds (Algorithm 3). These algorithms were tested inside a column generation procedure on CVRP instances. The results are shown in Tables 1 and 2
                        
                        . Columns Ins and OPT show the name and the optimum value of each instance. Following these columns, the results for different values of 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         are shown. For each X, where 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              X
                           
                        , NG
                        
                        =
                        
                        X consists of four columns, LB, T1, T2 and T3, which show the lower bound and the total time required to compute it for, respectively, Algorithms 1–3.

The results from Tables 1 and 2 show that for small ng-set sizes (NG
                        
                        =
                        
                        8), the best approach comes from the simple Algorithm 1. This is not a surprise because the maximum number of non-dominated labels per bucket is limited to 
                           
                              
                                 
                                    2
                                 
                                 
                                    X
                                 
                              
                           
                        , and therefore, the total number of labels handled by the algorithm does not explode. In this case, a unique running of the dynamic programming considering the entire state space is in general better than running it in the relaxed state space several times. For an average ng-set size (NG
                        
                        =
                        
                        16), the pure DSSR still does not improve the times of Algorithm 1, but the combination of DSSR and completions bounds provides a great improvement, allowing the running of all instances in a small amount of time (except for instances F-n135-k7 and M-n121-k7). For large ng-set sizes (NG
                        
                           
                              ⩾
                           
                        
                        32), the pure DSSR significantly outperforms the basic dynamic programming algorithm, but it is still a poor algorithm for most instances. However, the DSSR with completions bound drastically improves the times.

We can also note that the bounds for NG
                        
                        =
                        
                        32 are almost as good as the elementary for most instances. This is evidence that the routes found by the pricing with large ng-sets are almost elementary when the average size of the routes is up to 12 or 13 customers, in tipically less time than the time required if the elementary constraint is imposed to the routes. But this is not necessarily a rule. It is noteworthy to mention that the greater is the ng-set size used, the better is the completion bounds obtained. In some cases, the improved completion bounds resulting from the use of a large ng-set may compensate the additional complexity imposed. This is indicated by the time for running the instance M-n121-k7, which is significantly greater for NG
                        
                        =
                        
                        32 than NG
                        
                        =
                        
                        64.

On the other hand, our algorithms spend a lot of time trying to solve the column generation for instances F-n135-k7 and M-n121-k7, especially for large ng-set sizes. This is mainly due to the average size of the routes that are part of an optimum solution for these instances, which is greater than 17, causing the number of labels to be treated by the dynamic programming algorithm to be prohibitive. In particular, instance F-n135-k7 has a vehicle capacity of 2210, a value at least 10 times greater than the capacity of any other instance considered in the tests.

Now, we show the other results obtained with our best pricing algorithm, Algorithm 3. Table 3
                         presents the results of the column generation for the CVRP considering the separation of capacity and strengthened comb cuts. As performed previously, the results are shown for different values of 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        . Note that, considering the randomness factor included on the cut separation algorithms, larger 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         do not necessarily implies in larger lower bounds, as one can check for example on instance A-n80-k10. Table 4
                         shows the results for the elementary routes for the CVRP. The column named Elem shows the bounds and times of the column generation without cuts and the column Elem
                        
                        +
                        
                        Cuts presents the results with cuts. Finally, Table 5
                         shows a summary of the results for the GVRP instances, all with separation of capacity and strengthened comb cuts. Columns Set, Num and 
                           
                              θ
                           
                         show the name of the sets, the number of instances in each set and the 
                           
                              θ
                           
                         used in the transformation, respectively. Columns NG
                        
                        =
                        
                        X show the average gap and average time of the sets for the column generation with the ng-route pricing for 
                           
                              Δ
                              (
                              
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              X
                           
                         (similarly, the results for the elementary routes are presented for each set). These gaps are obtained by comparing our values with the upper bounds available in the work of Bektaş et al. (2011). We select some instances where our algorithms found better solutions than those described by Bektaş et al. (2011). The results for these instances are shown in Table 6
                        . The column Ins shows the name of each instance, and columns LB and UB show the results from Bektaş et al. (2011). Values in bold are those which we also proved to be the optimal solution with our column generation algorithm.

@&#CONCLUSIONS@&#

The strength of the ng-route pricing is the ability of adjusting the size of the ng-sets in order to calculate a lower bound in a reasonable time, which is close as much as possible to the elementary route bound, and this property justifies an efficient implementation of the method. In this paper, we presented an efficient ng-route pricing algorithm for ng-set sizes up to sixty-four, a number at least three times greater than we know so far. Furthermore, we showed how our restricted non-elementary route pricing algorithm can be easily extended in order to price only elementary routes. We highlighted the two elements that allowed us to price elementary routes even for CVRP instances with 200 customers, a result which doubled the size of the ESPPRC instances solved so far. The first element is the way we adapt the Decremental State Space Relaxation (DSSR) technique of Righini and Salani (2008) for the ng-routes context, thus improving their way of increasing the state space along the DSSR iterations. The second is the combination of the DSSR technique with completion bounds, which are calculated in each iteration of the DSSR for the purpose of accelerating the next iteration.

The final algorithm was tested for pricing elementary and restricted non-elementary routes to a set partitioning formulation for both GVRP and CVRP. For the first one, we could improve the lower bounds for up to 13 instances, since we also separated and added capacity and strengthened comb cuts.

@&#ACKNOWLEDGMENTS@&#

The contribution by Rafael Martinelli, Diego Pecin and Marcus Poggi has been partially supported by the Conselho Nacional de Desenvolvimento Científico e Tecnológico (CNPq), processes numbers 140849/2008-4, 141538/2010-4 and 309337/2009-7. This support is gratefully acknowledged.

@&#REFERENCES@&#

