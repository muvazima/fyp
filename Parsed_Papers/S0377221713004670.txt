@&#MAIN-TITLE@&#A fast simulated annealing method for batching precedence-constrained customer orders in a warehouse

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We solve the combined precedence-constrained routing and batching problem.


                        
                        
                           
                           Our method compares very well to heuristics from literature and optimal solutions.


                        
                        
                           
                           We save 5000kilometers in travel distance in our sample warehouse over a 3month period.


                        
                        
                           
                           The method is general and not constrained by the warehouse layout.


                        
                        
                           
                           A∗ is used for the routing, and simulated annealing for batching.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Heuristics

Logistics

Order picking

Batching

Precedence

@&#ABSTRACT@&#


               
               
                  Batching customer orders in a warehouse can result in considerable savings in order pickers’ travel distances. Many picker-to-parts warehouses have precedence constraints in picking a customer order. In this paper a joint order-batching and picker routing method is introduced to solve this combined precedence-constrained routing and order-batching problem. It consists of two sub-algorithms: an optimal A
                     ∗-algorithm for the routing; and a simulated annealing algorithm for the batching which estimates the savings gained from batching more than two customer orders to avoid unnecessary routing. For batches of three customer orders, the introduced algorithm produces results with an error of less than 1.2% compared to the optimal solution. It also compares well to other heuristics from literature. A data set from a large Finnish order picking warehouse is rerouted and rebatched resulting in savings of over 5000kilometres or 16% in travel distance in 3months compared to the current method.
               
            

@&#INTRODUCTION@&#

Order picking is the single most important process in distribution centers. It is also the most laborious one, responsible for a substantial part of the distribution center’s total costs, with estimates as high as 55% (Drury, 1988) to 65% (Coyle, Bardi, & Langley, 1996) mentioned in the literature. Although advances in technology have made the picking process more efficient and the actual percentage of the total costs is most probably less than the figures above indicate, it is still substantial. Travel time is the largest component of the order picking time, with a contribution of up to 50% (Tompkins, White, Bozer, & Tanchoco, 2003). Much research has been devoted to methods reducing order pickers’ travel times, including modifying warehouse layout, using a different storage policy, batching orders, and routing pickers. In this paper, we focus on combined picker routing and order batching.

Our study is inspired by a picker-to-parts order picking process in a large retail warehouse in Finland. In this warehouse, at most three customer orders (or orders for short) can be batched in a single pick tour, each possibly for a different customer (i.e., a store) and a different delivery location within the warehouse. Each customer order has to be picked in a fixed sequence, due to family grouping in the company’s stores. The problem of batching orders and routing pickers while respecting precedence constraints of products is common, particularly in retail organisations, but such restrictions may also play a role in other warehouses (Dekker, De Koster, Roodbergen, & Van Kalleveen, 2004; Chan & Kumar, 2008). Precedence constraints may vary in nature. They may be due to weight restrictions (heavy products at the bottom of the roll container), fragility (light at the top), shape and size (big boxes at the bottom), stackability, but also preferred unloading sequence due to family grouping on the customer’s shelves. Although order batching and picker routing have received quite some attention in the literature, the combined problem of order batching and picker routing while respecting the precedence constraints of the products (and in our problem, including potential multiple drop-off points in a route) has not received much attention.

Batching orders and routing pickers while respecting precedence constraints is complex. Order batching is NP-hard for batches of size three or higher (Gademann & Van de Velde, 2005). Routing pickers while respecting precedence constraints has complexity of O(N
                     2(P
                     +1)
                        N
                     ) (Psaraftis, 1980a), where N is the number of customer orders in the batch and P is the maximum number of items in an order. Finding exact solutions for large orders and large batches becomes rapidly intractable. Our reference company has 2000 orders per day and up to 50 products per order, which have to be batched in batches of three orders. As the problem has to be solved multiple times per day and because of the problem’s complexity, exact computation of the order batching is not feasible and thus a heuristic method is used.

We solve the problem using a generic solution method. For the batching, we use a simulated annealing-based combinatorial search algorithm based on maximising total savings in travel distance. Batching aims to reduce total travel distance by combining multiple similar orders (which have to visit overlapping parts of the warehouse). Selecting the orders to be batched is based on comparing all pairs of orders and estimating the savings due to combining a larger number of orders. This reduces computation times substantially, while the error compared to optimal combinations is within 1.2%. The routing can be solved using an A
                     ∗-type shortest path algorithm. The method is exact and general, not constrained by the particular warehouse layout.

Our contribution is a structured approach for the joint order batching and picker routing problem in warehouses with any layout or any strict sequence constraint. The method is fast, and compares well to optimal solutions and heuristics from literature. In our reference case, travel distance savings of nearly 16% could be achieved.

@&#LITERATURE REVIEW@&#

A classic algorithm for order picking tour construction is the exact and polynomial time algorithm first presented in Ratliff and Rosenthal (1983) and extended in De Koster and Van der Poort (1998) to include multiple drop-offs. The algorithm presented in Ratliff and Rosenthal (1983) is further extended in Roodbergen and De Koster (2001b) to include a middle aisle. This extended version assumes a parallel-aisle warehouse with a maximum of three cross-aisles (see Fig. 1
                     ) and does not account for precedence constraints.

Next to optimal routes, heuristics are often used. In S-shape routing (Randolph, 1993), also known as traversal routing, an order picker travels the whole aisle if he or she needs to pick an item in the aisle visited. An exception is made for the last aisle if the number of aisles is odd. With largest-gap routing (Randolph, 1993), each aisle, except for the first and the last one visited, is exited on the entry side. The first and the last visited aisles are travelled completely. A heuristic combining S-shape and largest-gap routing is presented in Roodbergen and De Koster (2001a).


                     Theys, Braysy, Dullaert, and Raa (2010) consider the applicability of the Lin–Kernighan–Helsgaun (LKH) TSP heuristic (Helsgaun, 2000) to routing order pickers. They compare LKH with several routing heuristics and obtain savings of up to 47% in travel distance. Helsgaun (2000) finds optimal solutions with the LKH heuristic for all previously solved TSP instances available at that time, including a 13,509-city problem, which was the largest problem instance solved to optimality at the time.

A dynamic programming algorithm for solving the single-vehicle many-to-many immediate request dial-a-ride problem (multiple customer destinations, each with a possibly unique drop-off location), which is similar to our routing, is introduced in Psaraftis (1980b, 1983). The time complexity of Psaraftis’ algorithm is O(N
                     23
                        N
                     ) (where n is the total number of customers), and it solves problems for up to ten customers.


                     Kubo and Kasugai (1991) introduce the Precedence-Constrained Travelling Salesman Problem (PCTSP) and a branch-and-bound method for finding exact solutions for cases of up to 49 locations with acceptable computation times. The precedence-constrained path construction problem can be modelled as a case of the Sequential Ordering Problem (SOP) (Escudero, 1988). The SOP can be formulated as an Asymmetric Travelling Salesman Problem (ATSP) with precedence constraints. In the SOP, paths usually have a start and a finish position that differ from each other, while ATSP paths finish where they started. In the general ATSP case, each of the non-visited cities can be the next target with each iteration, but in the SOP, the set of the next possible cities is limited as defined by a directed graph formed from the problem.

A method for batching orders is introduced in Gademann and Van de Velde (2005). The order-batching problem is modelled as a set partitioning problem. A column generation algorithm is used to solve the linear programming relaxation. They rely on the polynomial time algorithm presented in Ratliff and Rosenthal (1983) to calculate the route length. They find that the maximum batch size has the largest impact on the solution time.

The savings algorithm by Clarke and Wright (1964), C&W(i), as well as an extension of it, C&W(ii), are used for batching orders in De Koster, Van der Poort, and Wolters (1999). They are compared to seed algorithms using two routing strategies: S-shape and largest-gap. Seed algorithms consist of two distinct steps: seed order selection and order addition. A single order is selected as the seed order based on criteria, e.g., the highest number of items, longest travel time or the farthest item. Additions can be done using different rules such as adding the order that minimises the sum of the distances of every item of the seed and the closest item in the order, or minimising the additional number of aisles to be travelled. The authors find that seed algorithms work best with S-shape routing and large pick device capacity, while savings algorithms work best with Largest-gap and small pick capacity. C&W(ii) consistently outperforms C&W(i), but is computationally more expensive.


                     Hsieh and Huang (2011) introduce two batch construction heuristics based on data clustering method: K-means Batching (KMB) based on K-means algorithm (MacQueen, 1967); and Self-Organisation Map (SOMB) based on the Self-Organising Map (Kohonen, 1990). KMB functions in a manner similar to traditional seed algorithms, while SOMB uses the Self-Organising Map to choose batches for routing.


                     Albareda-Sambola, Alonso-Ayuso, Molina, and De Blas (2009) use a Variable Neighbourhood Search (VNS) algorithm to batch orders. It uses six different local exchange schemes incorporated into three different search neighbourhoods of varying size to find good batches. Within each neighbourhood, all moves belonging to that neighbourghood are tried, and the one which results in the largest savings is chosen. The larger neighbourhoods are searched as needed – if a current one fails to produce a better solution, the next (larger) neighbourhood is explored for a better solution until no improvement can be made. VNS is compared to the C&W(i), C&W(ii) and seed algorithms and it consistently outperforms them. The authors find that the best performing algorithm from literature is C&W(ii), which is on average 2% worse than VNS. Solution quality comes with added computational complexity – when compared to C&W(ii) a much larger part of the combinatorial batch space explored. For the most complex instance run (250 orders), VNS took almost six times as much time to reach its solution. For routing batches, the authors use the computationally inexpensive S-shape, largest-gap and combined heuristics.


                     Henn and Wäscher (2012) introduce an attribute based hill-climber (ABHC) (Whittley & Smith, 2004) for the order-batching problem. ABHC uses a set of attributes to guide the search out of local minima and a set of moves to explore the neighbourhood of a current solution. Two moves are used to search for new solutions: shifting an order from one batch to another batch and swapping two orders between two batches. S-shape and largest-gap routing are used as routing algorithms. Comparisons are made to three local search algorithms, a Tabu Search heuristic and C&W(ii). ABHC compares favourably to these heuristics, with over 2% better results than those achieved with C&W(ii).

Large-scale order batching in parallel aisle warehouses is considered in Hong, Johnson, and Peters (2012b). The authors introduce a route-selecting order batching (RSB) formulation, a route bin packing formulation for calculating lower bounds, and a heuristic route-packing based order batching procedure (RBP). Instead of constructing routes for batches, they use the S-shape routing method to construct a set of all possible routes given a warehouse layout to which batches can be assigned. Given a batch, a best fit route can be selected with RSB. They assume that each order picker can pick up to ten orders to ten bins, and an average order size is two lines. A comparison of RBP is made to C&W(ii) and seed algorithms, with the RBP dominating the other heuristics and C&W(ii) performing better than the seed algorithms.

A simulated annealing (SA) heuristic for order batching is introduced by Hong, Johnson, and Peters (2012a). The authors deal with narrow-aisle systems with the possibility of picker blocking. In addition to the batching problem, the authors also deal with the sequencing problem, which is also NP-hard. They use four neighbourhood search heuristics in their SA-algorithm: the first one exchanges two orders from different batches; the second swaps the sequence of two batches; the third and fourth impose an acceptance condition on the order exchange to limit the size of neighbourhoods to be searched. Their method aims to minimise total retrieval time, which is the sum of pick and travel time and time due to delays. The algorithm uses a geometric cooling schedule (Cohn & Fielding, 1999), while the criteria for accepting a worse batch are the same as with our algorithm.

In comparison to the methods in the literature, which use multiple deterministic neighbourhood search heuristics, our method uses a single flexible heuristic based on random moves, but in a structured manner. Furthermore, other similar methods (Gademann & Van de Velde, 2005; Albareda-Sambola et al., 2009; Henn & Wäscher, 2012) do explicit batch evaluation, which is computationally expensive, while we estimate the best batches using information inherent in batches of one and two customer orders. Our problem also has precedence constraints in the routing. In combination, the flexible heuristic along with the estimate enable us to escape local minima and explore larger parts of the set of possible batches more thoroughly for good options, leading to good solution quality (especially for large wave sizes) and fast computation. Our simulated annealing method differs from the one in Hong et al. (2012a) as we do not consider sequencing. Also our neighbourhood definition is different, as is the cooling scheme.

In this section we describe the combined batching and routing problem as a variant of the precedence-constrained Travelling Salesman Problem. The process that we describe is as follows. A given number of trucks pick the orders. Each truck starts completely empty and then receives a set of orders to be picked. The number of received orders per truck does not exceed N, the number of bins carried by a truck.

Before the items of an order can be picked, for each order an empty bin has to be collected at the empty bin depot (see Fig. 1). Subsequently, each truck travels through the warehouse to pick the items of the orders in the pre-specified sequence per order. Once all items of an order have been picked, the truck delivers the order at its drop-off location. Once all orders have been completed and the truck is empty again, it receives a new batch of orders. A batch is the set of orders handled in a route by a truck between the moment the truck receives this set and the moment it has dropped off all orders and is empty again.

Given the assignment of orders to batches, the sequence in which the batches are carried out is not relevant for the total picking time.

There is a set 
                           
                              O
                           
                         of orders to be carried out. Each order consists of a number of items that have to be picked at specific pick locations. All items of an order are picked in a roll container of one of the available trucks (see Fig. 2
                        ). Once all items of an order have been picked, it must be delivered at its pre-specified drop-off location (one of the locations marked with 1–7 in Fig. 1).

The set of all ordered items is indicated by 
                           
                              G
                           
                        . Every item 
                           
                              g
                              ∈
                              G
                           
                         is characterised by three attributes: pick location; the customer order to which it belongs to; and the number of the units that need to be picked. The order to which item g belongs is indicated by 
                           
                              o
                              (
                              g
                              )
                              ∈
                              O
                           
                        . The items of each order must be picked in a pre-specified sequence. The sequence number of item 
                           
                              g
                              ∈
                              G
                           
                         of order 
                           
                              o
                              (
                              g
                              )
                              ∈
                              O
                           
                         is indicated by p
                        
                           g
                        . With the distance between items g and 
                           
                              h
                              ∈
                              G
                           
                         we mean the distance between the corresponding pick locations. This distance is denoted by d
                        
                           g,h
                        .

The first item of an order corresponds with picking up an empty bin at the empty bin depot. The last item of an order corresponds with the delivery of the order at its drop-off location. The sets of first and last items are denoted by 
                           
                              
                                 
                                    G
                                 
                                 
                                    f
                                 
                              
                           
                         and 
                           
                              
                                 
                                    G
                                 
                                 
                                    l
                                 
                              
                           
                        , respectively.

Note that the model described in this section is only meant to explain the combined batching and precedence-constrained routing problems in detail. For computational purposes we use other models and techniques that are described later on in this paper.


                        Model In order to model the batching and routing problem, we have (i) to assign the orders to the batches and (ii) to keep track of the sequence of the items of each order. To that end, we first introduce a set 
                           
                              R
                           
                         of potential batches. The number of potential batches should be sufficient to carry out all orders. For example, 
                           
                              |
                              R
                              |
                              =
                              |
                              O
                              |
                           
                         is certainly enough (but often much too large), since this corresponds to the situation that each order is picked on its own. Each batch can contain up to N bins. The set of bins is denoted by 
                           
                              B
                           
                        . The batch to which bin 
                           
                              b
                              ∈
                              B
                           
                         belongs is denoted by 
                           
                              r
                              (
                              b
                              )
                              ∈
                              R
                           
                        .

For each order 
                           
                              o
                              ∈
                              O
                           
                         and bin 
                           
                              b
                              ∈
                              B
                           
                         we introduce a binary decision variable Y
                        
                           o,b
                         to indicate whether or not order o is picked in bin b. Furthermore, let X
                        
                           g,h,r
                         be a binary decision variable indicating whether batch 
                           
                              r
                              ∈
                              R
                           
                         goes directly from item 
                           
                              g
                              ∈
                              G
                           
                         to item 
                           
                              h
                              ∈
                              G
                           
                        . Finally, let 
                           
                              
                                 
                                    U
                                 
                                 
                                    g
                                 
                              
                              ∈
                              N
                           
                         indicate the relative position of item 
                           
                              g
                              ∈
                              G
                           
                         in the tour that picks the order of item g.

Now the model can be described as follows:
                           
                              (1)
                              
                                 
                                    min
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          g
                                          ∈
                                          G
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          h
                                          ∈
                                          G
                                          ⧹
                                          {
                                          g
                                          }
                                       
                                    
                                 
                                 
                                    
                                       d
                                    
                                    
                                       g
                                       ,
                                       h
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       g
                                       ,
                                       h
                                       ,
                                       r
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             subjectto
                                             
                                          
                                       
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      b
                                                      ∈
                                                      B
                                                   
                                                
                                             
                                             
                                                
                                                   Y
                                                
                                                
                                                   o
                                                   ,
                                                   b
                                                
                                             
                                             =
                                             1
                                             
                                             
                                             ∀
                                             o
                                             ∈
                                             O
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          o
                                          ∈
                                          O
                                       
                                    
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       o
                                       ,
                                       b
                                    
                                 
                                 ⩽
                                 1
                                 
                                 
                                 ∀
                                 b
                                 ∈
                                 B
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          h
                                          ∈
                                          G
                                          ⧹
                                          {
                                          g
                                          }
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       g
                                       ,
                                       h
                                       ,
                                       r
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          b
                                          ∈
                                          B
                                          :
                                          r
                                          (
                                          b
                                          )
                                          =
                                          r
                                       
                                    
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       o
                                       (
                                       g
                                       )
                                       ,
                                       b
                                    
                                 
                                 
                                 
                                 ∀
                                 g
                                 ∈
                                 G
                                 ⧹
                                 
                                    
                                       G
                                    
                                    
                                       l
                                    
                                 
                                 
                                 ∀
                                 r
                                 ∈
                                 R
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          g
                                          ∈
                                          G
                                          ⧹
                                          {
                                          h
                                          }
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       g
                                       ,
                                       h
                                       ,
                                       r
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          b
                                          ∈
                                          B
                                          :
                                          r
                                          (
                                          b
                                          )
                                          =
                                          r
                                       
                                    
                                 
                                 
                                    
                                       Y
                                    
                                    
                                       o
                                       (
                                       h
                                       )
                                       ,
                                       b
                                    
                                 
                                 
                                 
                                 ∀
                                 h
                                 ∈
                                 G
                                 ⧹
                                 
                                    
                                       G
                                    
                                    
                                       f
                                    
                                 
                                 
                                 ∀
                                 r
                                 ∈
                                 R
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       U
                                    
                                    
                                       g
                                    
                                 
                                 -
                                 
                                    
                                       U
                                    
                                    
                                       h
                                    
                                 
                                 +
                                 |
                                 G
                                 |
                                 ·
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          r
                                          ∈
                                          R
                                       
                                    
                                 
                                 
                                    
                                       X
                                    
                                    
                                       g
                                       ,
                                       h
                                       ,
                                       r
                                    
                                 
                                 ⩽
                                 |
                                 G
                                 |
                                 -
                                 1
                                 
                                 
                                 ∀
                                 g
                                 ,
                                 h
                                 ∈
                                 G
                                 :
                                 g
                                 
                                 ≠
                                 
                                 h
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       U
                                    
                                    
                                       g
                                    
                                 
                                 -
                                 
                                    
                                       U
                                    
                                    
                                       h
                                    
                                 
                                 ⩾
                                 
                                    
                                       p
                                    
                                    
                                       g
                                    
                                 
                                 -
                                 
                                    
                                       p
                                    
                                    
                                       h
                                    
                                 
                                 
                                 
                                 ∀
                                 g
                                 ,
                                 
                                 h
                                 ∈
                                 G
                                 :
                                 o
                                 (
                                 g
                                 )
                                 =
                                 o
                                 (
                                 h
                                 )
                                 ∧
                                 
                                    
                                       p
                                    
                                    
                                       g
                                    
                                 
                                 >
                                 
                                    
                                       p
                                    
                                    
                                       h
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       Y
                                    
                                    
                                       o
                                       ,
                                       b
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 
                                 ∀
                                 o
                                 ∈
                                 O
                                 
                                 ∀
                                 b
                                 ∈
                                 B
                              
                           
                        
                        
                           
                              (9)
                              
                                 
                                    
                                       X
                                    
                                    
                                       g
                                       ,
                                       h
                                       ,
                                       r
                                    
                                 
                                 ∈
                                 {
                                 0
                                 ,
                                 1
                                 }
                                 
                                 
                                 ∀
                                 g
                                 ,
                                 h
                                 ∈
                                 G
                                 :
                                 g
                                 
                                 ≠
                                 
                                 h
                                 
                                 ∀
                                 r
                                 ∈
                                 R
                              
                           
                        
                        
                           
                              (10)
                              
                                 4
                                 
                                    
                                       U
                                    
                                    
                                       g
                                    
                                 
                                 ∈
                                 N
                                 
                                 
                                 ∀
                                 g
                                 ∈
                                 G
                              
                           
                        According to (2), each order is assigned to exactly one bin, and (3) states that each bin covers at most 1 order. Thus the orders are correctly assigned to the bins.

According to (4), each location related to an item (except a drop-off) is exited so that the corresponding order has been assigned to one of the bins in the batch. Similarly, constraints (5) state that each item, except a first location of an order, is entered so that the corresponding order is assigned to one of the bins of the batch. It follows that all items of an order are picked by the same batch.

Furthermore, constraints (6) are based on the TSP subtour elimination constraints of Miller, Tucker, and Zemlin (1960). According tov (6), the values U
                        
                           g
                         represent the (relative) positions of the items in each batch: if a batch goes directly from item g to item h, then (6) implies U
                        
                           h
                        
                        ⩾
                        U
                        
                           g
                        
                        +1. The values U
                        
                           g
                         need not be consecutive integers within a batch. Anyway, for two items g and h of the same batch we have U
                        
                           g
                        
                        <
                        U
                        
                           h
                         if and only if item g is picked before item h. It also follows that the sequence of items of a batch does not contain subtours.

Furthermore, constraints (7) state that two items belonging to the same order are picked by the same batch in such a way that their (relative) positions in the batch are at least the a priori specified difference. Thus U
                        
                           g
                        
                        <
                        U
                        
                           h
                         if and only if p
                        
                           g
                        
                        <
                        p
                        
                           h
                        . It follows that the precedence constraints of the items of each order are satisfied.

Constraints (8)–(10) specify the binary and non-negative character of the decision variables.

The objective function (1) represents the total routing costs of the batches. Thus the optimal solution of (1)–(10) is the solution with minimum total routing costs.

Our algorithm, Precedence-Constrained Estimated Savings based batching, or PCES for short, incorporates two distinct sub-algorithms:
                        
                           1.
                           an optimal A
                              ∗-algorithm for the routing;

a simulated annealing-based combinatorial search algorithm, SA-REMIX, for searching the space of possible batches.


                     Fig. 3
                      shows the flow diagram of PCES. The initialization is performed by inputting a selected set of customer orders 
                        
                           O
                        
                     , in step 1, usually more than can be processed at once. In step 2, the next set of R customer orders is selected for batching. Then batches with two customer orders are constructed and routed in steps 3 and 4. In step 5, estimates of savings for batches larger than two are calculated. To find the best batch allocation, a combinatorial search is performed in the space of batches with real and estimated savings in step 6. Estimated savings are calculated as needed in steps 5 and 6. In step 7, optimal routes are found for those batches that maximise the savings. We repeat steps 5 and 6 for a fixed number of iterations to find a good solution for the order-batching problem. If some customer orders are left in 
                        
                           O
                        
                     , we return to step 2, otherwise the algorithm terminates with its solution in step 8.

The main reason for batching customer orders is to generate savings in travel distance compared to picking these customer orders independently.

If computationally feasible, all possible routes can explicitly and exhaustively be constructed from all possible customer order combinations and a combinatorial search performed in the exhaustive space, thus minimising the travel distance. The number of possible combinations C up to the maximum batch size N of all R customer orders can be calculated by Eq. (11), below.
                           
                              (11)
                              
                                 C
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                
                                             
                                             
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        subject to R
                        ⩾
                        N and 
                           
                              C
                              ,
                              
                              R
                              ,
                              
                              N
                              ∈
                              N
                           
                        .

Especially with larger batch sizes (N
                        ⩾3), explicitly evaluating all possible batch combinations quickly becomes intractable due to the large number of combinations and the complexity of the routing. We aim to counter this by estimating the savings made for batches of more than two customer orders.

Instead of performing a combinatorial search in the explicitly evaluated search space of all batch travel distances, we search only a part of the space consisting of batches each with real or estimated savings. Real savings are found by constructing routes for batches of size two and subtracting their travel distances from the respective single-order travel distances. Estimates for savings of batches of size three or larger are calculated on the basis of the real travel distances of batches of sizes one and two. With PCES based batching, in addition to routing all batches of size two and one, only those batches with three or more customer orders which are found using SA-REMIX need to be routed. Compared to routing all batches with three or more orders, the number of calls to the routing algorithm for batches of size three or more is reduced from
                           
                              (12)
                              
                                 
                                    
                                       C
                                    
                                    
                                       3
                                       +
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          3
                                       
                                       
                                          N
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   R
                                                
                                             
                                             
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        to R/N (plus a possible remainder if N
                        >3).

We now explain how the travel savings for batches of three and more orders are estimated. Let i, j and k be three orders that can be batched together. If by batching order i with j, some travel distance is saved when compared to picking them independently, batching is beneficial. The savings resulting from batching the two customer orders i and j can be calculated by:
                           
                              (13)
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                              
                           
                        where c
                        
                           i,j
                         is the batched travel distance of customer orders i and j, c
                        
                           i
                         and c
                        
                           j
                         the travel distances for picking customer orders i and j independently. The travel distances in Eq. (13) are the real travel distances which have been evaluated with our routing algorithm.

Likewise, let batching i with k and j with k be beneficial. This would then imply that batching all three of these customer orders into a batch of size three would also be beneficial. If these three customer orders are batched, the savings can be calculated by:
                           
                              (14)
                              
                                 
                                    
                                       S
                                    
                                    
                                       i
                                       ,
                                       j
                                       ,
                                       k
                                    
                                 
                                 =
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 +
                                 
                                    
                                       c
                                    
                                    
                                       k
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       i
                                       ,
                                       j
                                       ,
                                       k
                                    
                                 
                              
                           
                        Expanding from this, if i,
                        
                        j and k are batched, the savings can be estimated by:
                           
                              (15)
                              
                                 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             ‾
                                          
                                       
                                    
                                    
                                       i
                                       ,
                                       j
                                       ,
                                       k
                                    
                                 
                                 =
                                 
                                    
                                       S
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 +
                                 
                                    
                                       S
                                    
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 +
                                 
                                    
                                       S
                                    
                                    
                                       j
                                       ,
                                       k
                                    
                                 
                              
                           
                        By combining (13) and (15), we get the estimated savings of a size three batch:
                           
                              (16)
                              
                                 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             ‾
                                          
                                       
                                    
                                    
                                       i
                                       ,
                                       j
                                       ,
                                       k
                                    
                                 
                                 =
                                 2
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                                 +
                                 2
                                 
                                    
                                       c
                                    
                                    
                                       j
                                    
                                 
                                 +
                                 2
                                 
                                    
                                       c
                                    
                                    
                                       k
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       i
                                       ,
                                       k
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       j
                                       ,
                                       k
                                    
                                 
                              
                           
                        Let 
                           
                              P
                           
                         be a set of n arbitrary customer orders {1…
                        n} and c
                        
                           n
                         be the travel distance of customer order n. Using this notation, if a batch is formed from the customer orders in 
                           
                              P
                           
                        , the savings can be found by:
                           
                              (17)
                              
                                 
                                    
                                       S
                                    
                                    
                                       P
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          ∈
                                          P
                                       
                                    
                                 
                                 
                                    
                                       c
                                    
                                    
                                       i
                                    
                                 
                                 -
                                 
                                    
                                       c
                                    
                                    
                                       P
                                    
                                 
                              
                           
                        Using the same notation as above, we can estimate the total savings resulting from batching N customer orders:
                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             ‾
                                          
                                       
                                    
                                    
                                       P
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          N
                                          -
                                          1
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   ∑
                                                
                                                
                                                   j
                                                   =
                                                   i
                                                   +
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                          
                                          (
                                          
                                             
                                                c
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          
                                             
                                                c
                                             
                                             
                                                j
                                             
                                          
                                          -
                                          
                                             
                                                c
                                             
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        Using (18), estimates can be calculated for all possible combinations up to a given batch size. To use this equation, only the batch tour distances of batches of size one and two are needed. The real savings for batches of size two are calculated, while for size three and more they are estimated. For batches of size one, the savings value is set to zero. In practice, estimates are calculated as they are needed, i.e., in steps 5 and 6 of Fig. 3.

We use the A
                        ∗-algorithm introduced by Hart, Nilsson, and Raphael (1968) to find the optimal pick route. This algorithm’s states are organised in a lattice, as states can be reached through multiple paths. The A
                        ∗-algorithm’s state is defined by the vector m
                        =(m
                        0 ,
                        m
                        1,…,
                        m
                        
                           N
                        ), similar to Psaraftis (1980b) and Psaraftis (1983). m
                        0
                        ∈{1,…,
                        N} defines the customer order in which the last product was placed. m
                        
                           i
                        , i
                        ∈{1,…,
                        N}, is the number of locations visited for customer order i (including the delivery location). See Fig. 4
                         for an example. The algorithm’s state starts with empty bins, and the picker at the depot. The state in the starting location is m
                        1
                        =(m
                        0,0,…,0), where m
                        0 is an arbitrary customer order. To pick an item to customer order i, we increment m
                        
                           i
                         by one and set m
                        0
                        =
                        i. Fig. 5
                         gives an example of the state space for two customer orders with two items to be picked in each of them. The arcs between two adjacent states represent possible state transitions by moving to the next location and picking the item required. The A
                        ∗-algorithm searches the lattice by using the exact travel distance to reach a state plus an estimate for the distance to reach the final state, where all customer orders have been picked and delivered and the picker is at the depot. As long as the estimate underestimates the remaining travel distance, the algorithm is guaranteed to find the optimal solution as it progresses through the lattice, see Hart et al. (1968). Psaraftis (1980b) uses a dynamic programming approach with no estimated distances to prune the search space. He also considers additional constraints which we do not use, such as customer preferences between waiting and riding, and time windows (Psaraftis, 1983).

The shortest total travel distance to reach a state m for a given set of customer orders 
                           
                              V
                           
                         is denoted by 
                           
                              g
                              (
                              m
                              ,
                              V
                              )
                           
                         . For each state and the selected set of customer orders, we calculate an estimate 
                           
                              h
                              (
                              m
                              ,
                              V
                              )
                           
                         for the remaining travel distance from state m to the depot and add it to the state cost. We find the single customer order with the longest remaining travel distance to the goal and set 
                           
                              h
                              (
                              m
                              ,
                              V
                              )
                           
                         to equal that distance. Let 
                           
                              
                                 
                                    h
                                 
                                 
                                    i
                                 
                              
                              (
                              m
                              ,
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         be the travel distance to goal by only visiting the locations of customer order i, i
                        ∈{1,…,
                        N}. The estimate is calculated by:
                           
                              (19)
                              
                                 h
                                 (
                                 m
                                 ,
                                 V
                                 )
                                 =
                                 
                                    
                                       
                                          max
                                       
                                       
                                          i
                                          ∈
                                          {
                                          1
                                          ,
                                          …
                                          ,
                                          N
                                          }
                                       
                                    
                                 
                                 
                                    
                                       h
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 m
                                 ,
                                 
                                    
                                       V
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 .
                              
                           
                        
                     

The estimate of the total distance to the goal state is calculated from 
                           
                              
                                 
                                    e
                                 
                                 
                                    ¯
                                 
                              
                              (
                              m
                              ,
                              V
                              )
                              =
                              g
                              (
                              m
                              ,
                              V
                              )
                              +
                              h
                              (
                              m
                              ,
                              V
                              )
                           
                        . Doing this prevents some of the unnecessary exploration of states that are not part of the optimal tour.

As an example, if we have two customer orders with two products to be picked in each and a delivery location for both orders, a lattice is formed by all the possible states m
                        
                           i
                        , ∀i
                        ∈{1,…,26}. In Fig. 5, all states are enumerated with m
                        1 being the starting state and m
                        26 being the end state. Arrows indicate the reachability of states. We can find the number of states in the lattice from (20) and the time complexity for the algorithm (Psaraftis, 1980a) from (21). Note that in (21) the product is preceded by N
                        2, and not by N as in (20). This is due to the fact that all states in the lattice have at most N incoming arcs (see Fig. 5).
                           
                              (20)
                              
                                 M
                                 =
                                 O
                                 
                                    
                                       
                                          N
                                          
                                             
                                                
                                                   ∏
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                          
                                          |
                                          
                                             
                                                V
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          1
                                          |
                                       
                                    
                                 
                                 ,
                              
                           
                        
                        
                           
                              (21)
                              
                                 T
                                 =
                                 O
                                 
                                    
                                       
                                          
                                             
                                                N
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                
                                                   ∏
                                                
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                          
                                          |
                                          
                                             
                                                V
                                             
                                             
                                                i
                                             
                                          
                                          +
                                          1
                                          |
                                       
                                    
                                 
                                 .
                              
                           
                        where the sum term removes all states that are infeasible such as [1,0,1]. 
                           
                              |
                              
                                 
                                    V
                                 
                                 
                                    i
                                 
                              
                              |
                           
                         is incremented with one as we include the delivery location.

In Fig. 5 on the right side, the possible transitions and distances from state m
                        9 are shown. Let us say the total distance to that state is a
                        9. To calculate the heuristic distance to goal using our method, we can either add all remaining items to bin 1 or 2, but not to both. The heuristic distances are thus 
                           
                              
                                 
                                    h
                                 
                                 
                                    1
                                 
                              
                              (
                              
                                 
                                    m
                                 
                                 
                                    9
                                 
                              
                              ,
                              V
                              )
                              =
                              1
                           
                         (as only one item can be added to order 1) and 
                           
                              
                                 
                                    h
                                 
                                 
                                    2
                                 
                              
                              (
                              
                                 
                                    m
                                 
                                 
                                    9
                                 
                              
                              ,
                              V
                              )
                              =
                              2
                              +
                              4
                              =
                              6
                           
                         (as two items can be added to order 2). 
                           
                              
                                 
                                    h
                                 
                                 
                                    2
                                 
                              
                              (
                              
                                 
                                    m
                                 
                                 
                                    9
                                 
                              
                              ,
                              V
                              )
                           
                         is chosen for the heuristic as per (19). Then the estimate of the total cost of the goal state is 
                           
                              
                                 
                                    e
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    m
                                 
                                 
                                    9
                                 
                              
                              ,
                              V
                              )
                              =
                              
                                 
                                    a
                                 
                                 
                                    9
                                 
                              
                              +
                              
                                 
                                    h
                                 
                                 
                                    2
                                 
                              
                              (
                              
                                 
                                    m
                                 
                                 
                                    9
                                 
                              
                              ,
                              V
                              )
                           
                        . The estimate for the total distance to goal we use is very optimistic. If we use a better estimate, the running times of the algorithm might decrease.

The A
                        ∗-algorithm is used to route batches of two customer orders, as well as the final batches after batching has been finished, in steps 4 and 7 of the PCES algorithm, as explained in Fig. 3, respectively.

After all savings and travel distances for batches of size two have been determined, we have to batch orders in batches of size up to N. Our algorithm, SA-REMIX, is a Neighborhood Search algorithm consisting of a construction phase followed by improvements embedded in a simulated annealing scheme to avoid local optima. We use C&W(i) to form an initial solution. This starting solution gives an upper bound for the total travel distance. Next, we apply a REMIX procedure.


                        REMIX This procedure randomly selects a fixed number of batches from the ones that are currently selected (steps 5 and 6 in Fig. 3). The orders contained in the batches are mixed and randomly sampled again to form a number of new batches. The REMIX procedure is embedded in a simulated annealing routine. The size of the new batches is limited to N. The total travel distance savings of these new batches (d
                        
                           new
                        ) are estimated and compared with those of the original batches (d
                        
                           org
                        ). Let r
                        ∼
                        U[0,1] be a uniformly distributed random variable and t
                        
                           n
                         be the current temperature, where n is the current iteration. New batches are accepted if one of the following two criteria is met:
                           
                              1.
                              if their savings are larger than those of the original batches, i.e., d
                                 
                                    new
                                 
                                 >
                                 d
                                 
                                    org
                                 ;

or, otherwise, if r
                                 <exp((d
                                 
                                    new
                                 
                                 −
                                 d
                                 
                                    org
                                 )/t
                                 
                                    n
                                 ).

If d
                        
                           new
                        /d
                        
                           best
                        
                        >1.1, where d
                        
                           best
                         is the highest savings value found so far, we revert back to the current best solution and continue the search from there.

The initial temperature t
                        0 is set to equal the highest savings value of the batches with two customer orders. Updates to t
                        
                           n
                         are done using Lundy’s (Lundy & Mees, 1986) temperature schedule: t
                        
                           n+1
                        =
                        t
                        
                           n
                        /(1+
                        t
                        
                           n
                        /n).

In this section, we compare the results of our method both with company results and with optimal and heuristic batching, while using our A
                     ∗-routing. We use the company data as input for our experiments. We analysed data consisting of voice-picking logs of almost 35,000 batches (approximately 100,000 customer orders), each consisting of up to three customer orders and an approximate total of 1.8million log entries (i.e. pick locations to be visited), spanning the first three months of 2011. Each log entry includes a slot address, pick time, batch number, customer order number and picker number. Also the sequence in which each customer order should be picked is given. Currently the batches are created by grouping the customer orders per lorry delivery route in a FCFS sequence. The pick routes are constructed using the S-shape heuristic, preserving single-directional aisle travel and strict item precedence.

The experiments are carried out with 1536 customer orders sampled from the data set (about one day’s work). The customer orders of each day are grouped in waves. Each wave represents a number of lorry delivery routes with scheduled departure times within a certain time interval. The current number of customer orders per wave, or wave size R, is up to about 126.

All experiments were run single-threaded on an Intel(R) Core(TM) i7 920 CPU running at 2.67GHz and with 12GB of memory. Due to the exponential complexity of our problem, we also consider the time to solve a given problem instance in addition to the solution quality. The space of possible batch combinations when maximum batch size is three or more increases exponentially with the wavesize R. Thus we increase the number of simulated annealing iterations run with PCES with wavesize. The number of iterations I used in our experiments is I
                     =500,000+(2N
                     −5)R
                     2.

The warehouse is operated by a retail store chain selling non-food products and supplying 148 stores mostly on a daily basis. Orders arrive online and can be processed in five or six waves per day of R customer orders each. Orders are picked manually from pallet racks into customer orders using a picker-to-parts order picking system (De Koster, Le-Duc, & Roodbergen, 2007). Pickers have to travel long distances as the warehouse has 57 aisles of 104 metres each and three cross-aisles, see Fig. 1. The total warehouse area is 75,000square metres, the average pick tour is 880metres, and a warehouse picker travels an average of 7300metres a day. The company sells and stores over 50,000 SKUs. Each warehouse aisle has 52 pick slots, which are divided into four subslots and two storage levels. This amounts to a total of 23,296 different pick locations in the warehouse. We condense these locations into 2912 locations and corresponding items. The distance between two locations is measured using Manhattan distances, taking into account that pickers can only travel along the aisles in one direction, for safety reasons, and to avoid congestion. If the next pick is from a slot which is in the same aisle but in opposite travel direction, the travel distance is calculated respecting these traffic rules. The customer orders must be filled in a predefined sequence, primarily due to family grouping in the stores (De Koster et al., 2007). Each item has a unique pick location in the warehouse. The contents and pick sequences for each of the customer orders are generated a priori by a Warehouse Management System (WMS). Every pick route contains up to three customer orders (a batch), currently all for the same store, in one tour of the warehouse (see Fig. 1), but this might change, depending on potential travel time savings. A picker drives an order picking truck (see Fig. 2) and follows a tour determined by the on-board customer orders, directed by a truck-mounted RF terminal. In addition to the truck terminals, the company uses a pick-by-voice system, which is not used for guiding the pickers, but only for pick confirmation (De Koster et al., 2007). Pickers can overtake each other. The warehouse layout can be seen in Fig. 1. The delivery location of each completed customer order is known in advance: it is the one closest to the dock door from which the outbound lorry will depart to the store.

The warehouse uses a family grouping strategy to allocate items to storage slots, similar to the stores. Such a storage strategy is common in many retail warehouses. Efficiency losses in the warehouse by not using class-based storage are traded-off against efficiency gains in the stores by faster customer order unloading and shelf replenishment (De Koster et al., 2007).

Each order picking tour related to a single batch starts from the depot, see Fig. 1. Before returning to the depot, all relevant pick locations and drop-off points must be visited. There are seven drop-off locations in the warehouse.

To speed up batch evaluation, all batches of three customer orders or more are not explicitly routed in PCES but estimated using (16) or (18). To validate this approach, we sample a set of 10,000 batches (
                           
                              R
                           
                        ) of three customer orders from the sampled data set of 1536 customer orders. The 10,000 batches are all routed, real and estimated savings are calculated for all 
                           
                              r
                              ∈
                              R
                           
                         using (14) and (16), respectively. All batches with negative estimated savings are discarded, as they would never be chosen by SA-REMIX, resulting in just over 5000 batches or the set 
                           
                              
                                 
                                    R
                                 
                                 
                                    +
                                 
                              
                              ⊂
                              R
                           
                        . Both sets of savings, i.e., real and estimated (
                           
                              
                                 
                                    R
                                 
                                 
                                    v
                                 
                                 
                                    +
                                 
                              
                           
                         and 
                           
                              
                                 
                                    R
                                 
                                 
                                    e
                                 
                                 
                                    +
                                 
                              
                           
                        , respectively), are then ordered in descending order to establish real and estimated integer batch ranks 
                           
                              
                                 
                                    w
                                 
                                 
                                    v
                                 
                                 
                                    r
                                 
                              
                           
                         and 
                           
                              
                                 
                                    w
                                 
                                 
                                    e
                                 
                                 
                                    r
                                 
                              
                              ,
                              
                              ∀
                              r
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    +
                                 
                              
                           
                        . For validation of the estimate of a batch r, we use a proportional batch rank error calculated by 
                           
                              
                                 
                                    ∊
                                 
                                 
                                    r
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             w
                                          
                                          
                                             e
                                          
                                          
                                             r
                                          
                                       
                                       -
                                       
                                          
                                             w
                                          
                                          
                                             v
                                          
                                          
                                             r
                                          
                                       
                                    
                                 
                              
                              /
                              |
                              
                                 
                                    R
                                 
                                 
                                    +
                                 
                              
                              |
                           
                        .


                        Fig. 6
                         shows a moving average over 20 values of 
                           
                              
                                 
                                    ∊
                                 
                                 
                                    r
                                 
                              
                              ,
                              
                              ∀
                              r
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    +
                                 
                              
                           
                        , sorted by real batch rank (with 1 being the batch with the highest savings). For the best batch, the average is over batches ranked 1, …, 20, for the second best, it is over 2, …, 21 and so on. In SA-REMIX, we are interested in batches with the highest savings, i.e., finding the best feasible combination of the best ranked batches. Fig. 6 shows that the savings estimates for the best batches are much better than for the rest of the batches. This validates the performance of PCES as seen later in the results.

We compared both the solution quality and the computation time of PCES to the following heuristics for maximum batch sizes three and four: C&W(i) and C&W(ii) from De Koster et al. (1999); the VNS-batching algorithm by Albareda-Sambola et al. (2009); ABHC by Henn and Wäscher (2012) which uses either C&W(i) (our own variant of the ABHC) or C&W(ii) (as in Henn & Wäscher (2012)) as the initial solution; and the generally best performing seed algorithm combination from De Koster et al. (1999) (seed selection by finding the order with the longest travel time, and order addition by the order that minimises the sum of the distances from the closest item in the seed to every item in the order). We imposed a 240min time limit for each wave size.

The results are shown in Fig. 7
                        . Fig. 7a shows the percentage improvement compared to C&W(ii) in travel distance for wave sizes between 12 and 150, for all the other heuristics for a maximum batch size of three customer orders. C&W(i) is the weakest heuristic and always inferior to C&W(ii), as has been shown in the literature previously, see, e.g., De Koster et al. (1999) and Albareda-Sambola et al. (2009). However, C&W(i) is computationally light. The seed selection heuristic did not perform well in our case, so we left it out of the results. Both the VNS and ABHC base their good results on detailed exploration of the combinatorial batch space, thus requiring a lot of batch evaluations. As the space gets larger with larger wave sizes, the number of batch evaluations increases exponentially. Initially, up to wave size 30, the VNS heuristic comes out on top – after this, the time limit for solving the problem kicks in, and the solution quality degrades rapidly, see Fig. 7a. This is partly due to the fact that no initial solution is used – the search starts from each order being in a separate batch.

A similar effect imposed by the time limit and the computationally expensive batch evaluation can be seen with ABHC. Initially, it is the second best algorithm, but within the given time limit it can only make some improvements to the initial solution found with C&W(ii). Henn and Wäscher (2012) suggested that they got comparable results with initial solutions found with a FCFS-algorithm. However, we find that using C&W(ii) to obtain a decent initial solution requires less computation time and produces better results. In general, PCES has better solution quality than C&W(ii) with less computation time (see Fig. 7b). Also, for medium to large wavesizes, its solution quality is better than those of all the other methods, while simulataneously being much faster.

In Fig. 7c we compare the solution quality of PCES and ABHC (initial solution with C&W(i)) to C&W(i) for batches of four customer orders. The number of possible batch combinations is much larger than for batches of size three (see (11)). The routing is also computationally much more expensive. C&W(ii), VNS and thus also ABHC with C&W(ii) all fail to reach a proper solution result withing the time limit and are thus left out from the results. Using PCES yields a mean improvement of 2.3% compared to the batching of C&W(i), while ABHC is able to improve the C&W(i) initial solution by 0.01% on average, mostly because of the timelimit. Computational times of C&W(i) and PCES start are similar for small wave sizes. PCES nears the timelimit as the number of iterations of SA-REMIX is increased quadratically with wave size, while ABHC always hits the time limit.

In both instances of three and four customer orders, PCES exhibits similar behaviour. For small wavesizes (up to 24) the error in the batch savings estimate dominates, and a good result is not reached reliably. However, recall that the estimate (Eqs. (16) and (18)) is quite good in estimating batches with high savings (see Fig. 6), so as the number of such batches increases exponentially with both wave and batch size, the probability of finding a good solution increases with it.

Furthermore, we found that the solution time is proportional to the number of batch evaluations of maximum batch size (three or four in our case).

It is possible to compare the results of our batching procedure with optimal batching for up to 27 customer orders and batches of size three. The optimal routing algorithm is based on the A
                        ∗-routing method presented earlier in this paper, while the order batching part uses dynamic programming, with all possible customer order combinations as state space.

For the optimal batching we vary the wave size R between 12 and 27, in steps of three customer orders. Fig. 7a shows the results. For the optimal algorithm, the solution time increases exponentially with the wave size – calculating the optimal solution for the whole dataset of 1536 orders with 27 customer orders per wave and N
                        =3 took over 23hours. PCES based batching gives results with less than a 1.2% error compared to the optimal solution for N
                        =3. Using PCES, when R increases, the time to solve the problem instance decreases. This is due to a reduction in calls to SA-REMIX. Note also the differences in computation time in Fig. 7b.

For batches of one customer order, wave size does not matter as each customer order is picked separately. For the batches of size two, travel distances are calculated with the package CPLEX 12.4 using the order-batching model presented by Gademann and Van de Velde (2005).


                        Fig. 8
                         shows the benefits of different wave and batch sizes. Having more customer orders per wave reduces the total travel distance, however the reduction decreases for an increased wave size. For waves larger than 150 customer orders, the effect is negligible. When comparing optimal batching for two customer orders to three customer orders, with a wave size of 27 customer orders, two customer order batches appear to lead to 19.4% longer travel distances. If the batch size is increased to four, there are still considerable savings in travel distance when compared to optimal and estimated savings with batches of three customer orders. However, routing for these four-order instances is much more time consuming.

We now compare the effect of PCES batching with the company’s current method, including the mandatory travel directions. Since the company’s routing method is not optimal, we additionally compare the effect of our routing method presented in Section 4.2. The results can be found in Table 1
                        . By rerouting the original batches with a wave size of 126 customer orders, 3.1% or 980kilometres is saved, while rebatching and rerouting together give savings of 15.7% or 5029kilometres.

@&#DISCUSSION@&#

This paper presents PCES batching based on optimal precedence-constrained routing in combination with a simulated annealing algorithm which uses estimated travel distance savings to group orders in batches. Our contribution is in developing a generic method for solving the difficult problem of batching orders with precedence-constrained pick tours. The method uses an estimate for savings generated by combining orders, which appears to perform remarkably well. The estimate uses exact savings from forming batches of size two to generate savings for larger batches. By using the estimate, the number of routings to be calculated reduces dramatically, particularly for larger batches.

The PCES algorithm is able to generate significant savings of up to 15.7% compared to the original batching, or over 5000kilometres for a three-month period. These savings can be achieved without having to make any changes to the warehouse layout or customer order composition. If the cost of order picking is 55% of total warehouse expenses (Drury, 1988) and 50% (Tompkins et al., 2003) of this is due to travelling between picks, the savings on the total operating costs of our sample warehouse would be 4.3%.

The core idea behind PCES is to minimise the number of computationally complex batch evaluations. This makes it very competitive with other state-of-the-art batching heuristics, especially in solution time, but also in quality. Compared to other algorithms, which use a set of deterministic neighbourhood heuristics, the randomness inherent to the REMIX heuristic allows it to be flexible and perform well. For batches of three customer orders, PCES generally finds better solutions than the C&W(ii) algorithm, while its computational complexity is between C&W(i) and C&W(ii), and beating out other algorithms from literature for medium to large sized waves. For four order batches, PCES is peerless in solution quality with a 2.0% improvement over the next best algorithm. However, with small wave sizes of up to 30 customer orders, one would get better results using either of the VNS or ABHC heuristics, due to the inconsistent behaviour of PCES in that range (see Fig. 7). This inconsistency is most likely due to fact that the probability for the estimate to be accurate is much smaller for small waves. As the number of good batches increases exponentially with wave size, so does the probability of the estimate being accurate.

When compared to optimal batching for small wave sizes of up to 27 customer orders and a maximum batch size of three, PCES performs decently, with a 1.2% mean error compared to the optimal solution. Savings in travel distance that are comparable to optimal batching and routing can be achieved with much less computation time. When compared to just picking one bin at a time, Fig. 8 shows that increasing the batch size can result in substantial travel distance savings. Depending on the wave size, for batches of two orders, 30–40% is saved, while for batches of size three and four the savings range from 40% to 54% and 45% to 61%, respectively. Larger wave sizes seem to have a considerable effect on the total travel distance for up to about 100 customer orders. Wave sizes larger than this do not seem to affect solution quality very much.

Another benefit of the PCES batching method is that it allows us to evaluate the effect of different batch sizes in any warehouse with precedence-constrained routing. In case a different routing scheme is followed, it is rather straightforward to replace the routing algorithm presented in Section 4.2 with this other method.

In practice, there may be further opportunities to reduce travel distance even more. We did not consider new storage policies (see Dekker et al. (2004)), which might lead to additional savings. In addition, pickers’ skills appear to vary significantly. Assigning the right pickers to the right batches (orders and products) may also impact total time. This remains work for the future.

@&#ACKNOWLEDGEMENTS@&#

We are thankful to a referee for his/her comments, which helped to substantially improve the paper. We would also like to thank Sebastian Henn for sharing his ABHC code. The funding of the Academy of Finland and the Finnish Funding Agency for Technology and Innovation through the EFFIMA research program, managed by FIMECC, is gratefully acknowledged.

@&#REFERENCES@&#

