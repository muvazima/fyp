@&#MAIN-TITLE@&#A memetic algorithm for the orienteering problem with hotel selection

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An extensive literature review is presented on node routing problems with intermediate facilities.


                        
                        
                           
                           176 New and larger benchmark instances with known optimal solutions are created.


                        
                        
                           
                           A memetic algorithm is designed which improves the results presented in the literature.


                        
                        
                           
                           A sensitivity analysis on the critical characteristics of the OPHS is performed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Orienteering problem

Memetic algorithm

Population management

Intermediate facilities

Hotel selection

@&#ABSTRACT@&#


               
               
                  In this paper, a memetic algorithm is developed to solve the orienteering problem with hotel selection (OPHS). The algorithm consists of two levels: a genetic component mainly focuses on finding a good sequence of intermediate hotels, whereas six local search moves embedded in a variable neighborhood structure deal with the selection and sequencing of vertices between the hotels. A set of 176 new and larger benchmark instances of OPHS are created based on optimal solutions of regular orienteering problems. Our algorithm is applied on these new instances as well as on 224 benchmark instances from the literature. The results are compared with the known optimal solutions and with the only other existing algorithm for this problem. The results clearly show that our memetic algorithm outperforms the existing algorithm in terms of solution quality and computational time. A sensitivity analysis shows the significant impact of the number of possible sequences of hotels on the difficulty of an OPHS instance.
               
            

@&#INTRODUCTION@&#

The Orienteering Problem with Hotel Selection (OPHS) is a recently introduced variant of the orienteering problem (Divsalar, Vansteenwegen, & Cattrysse, 2013). In this problem, on a given complete graph G
                     =(V,
                     E), a set of h
                     +
                     n vertices is given. V=H∪N is composed of two subsets including h hotels, represented by numbers from 0 to h
                     −1, and n points of interests (POI), represented by numbers from h to h
                     +
                     n
                     −1. Hotel 0 and hotel 1 are used as the initial and the final depot respectively; the other hotels are called “extra hotels”. Each POI is assigned a score Si
                     . The symmetric travel time needed between each pair of vertices is given by tij
                     . These travel times can be based on Euclidean distances or a travel time matrix. An ordered set of POIs with a specific start and end hotel is called a trip. The length of each trip d
                     =1,…,
                     D is limited by a given time budget Td
                     . Each of the D connected trips starts and ends in one of the h hotels. The ordered set of trips that starts in the initial depot and ends in the final depot is called a tour. Both the initial and final depot can also be used as an intermediate hotel during the tour. The objective is to find a given number of connected trips visiting each POI at most once and maximizing the sum of collected scores.

Some examples of the large number of potential applications of the OPHS are explained in Divsalar et al. (2013): a submarine performing a surveillance activity composed of consecutive missions, the design of a multi-day tourist trip through an attractive region, or a traveling salesperson who needs to select which of his possible clients to visit during his multiple day tour and also needs to choose the most appropriate hotels to stay the night.

We start this paper with an extensive literature survey on the OPHS and closely related problems. In Section 3 our heuristic algorithm is explained. Benchmark instances, experimental tests and a sensitivity analysis of the problem instance parameters are presented and discussed in Section 4 and the paper is concluded in Section 5.

@&#LITERATURE REVIEW@&#

In the regular Orienteering Problem (OP), there are N vertices available, each with a score Si
                     , and the goal is to find a tour that visits some of these vertices, respects the available time limitation and maximizes the total collected score. The OP is also known as the selective traveling salesperson problem (Gendreau, Laporte, & Semet, 1998) and was introduced by (Tsiligirides, 1984). Since then, it has been considered in the literature for a number of applications such as home fuel delivery (Golden, Levy, & Vohra, 1987) and mobile tourist guides (Schilde, Doerner, Hartl, & Kiechle, 2009; Vansteenwegen, Souffriau, Vanden Berghe, & Van Oudheusden, 2011). Many (meta)heuristics and exact methods have been implemented to solve this problem. A recent survey on the OP and its variants, describing solution techniques, benchmark instances and applications can be found in (Vansteenwegen, Souffriau, & Van Oudheusden, 2011).

The hotel selection variant of the OP, studied in this paper, is closely related to a variant of the Vehicle Routing Problem (VRP) with so-called Intermediate Facilities (IF). To the best of our knowledge, (Angelelli & Speranza, 2002a) were the first to introduce intermediate facilities in a (node routing) VRP. The most important differences between their problem, the periodic VRP with Intermediate Facilities (PVRP-IF) and the OPHS are that in the OPHS each trip length is limited by a time budget and in the PVRP-IF the only time budget is the work shift applied for the whole tour and not per trip. Instead, a capacity constraint on the vehicle limits the number of customers that can be visited in each trip, while the OPHS has no capacity constraint. The tour time constraint and the fact that the number of trips is not fixed in the PVRP-IF makes it more complex to combine the trips in a tour, compared to the OPHS. Furthermore, in the PVRP-IF an empty vehicle leaves the depot and goes directly to an intermediate facility to load the goods. As a result, no customer can be visited on the way from the depot to the first facility. They propose a tabu search (TS) algorithm to solve this problem. In (Angelelli & Speranza, 2002b), the authors modify their PVRP-IF model and present a general model for waste-collection problems.


                     Crevier, Cordeau, and Laporte (2007) also address intermediate facilities in node routing problems with deliveries. They introduce an extension of the multi-depot VRP (MDVRP) in which vehicles may be replenished at intermediate facilities along their route. The Multi-Depot Vehicle Routing Problem with Inter-depot Routes (MDVRPI) deals with m vehicles of capacity Q. In contrast to the PVRP-IF, the MDVRPI is not a periodic problem. Moreover, a different terminology, new applications and a different solution strategy are introduced. The set of all routes assigned to a vehicle is called “rotation” which corresponds to the term “tour” in the OPHS. Based on this comparison, each route for each vehicle in the MDVRPI corresponds to a “trip” in the OPHS. There is a time limitation for a rotation of a vehicle in the MDVRPI. A rotation may be composed of “single-depot” and “inter-depot” routes which indicate if the starting and ending depot of a route are the same or different, respectively. Here again the problem differs from the OPHS in the sense that there is no explicit limitation on the length of each trip, only an implicit limitation based on the capacity of the vehicle. To solve the randomly generated instances of this problem, the authors propose a heuristic combining the adaptive memory principle, a tabu search method for the solution of sub problems, and integer programming. They apply their algorithm to a grocery distribution problem.


                     Tarantilis, Zachariadis, and Kiranoudis (2008) define the VRP with intermediate replenishment facilities (VRPIRF). In the VRPIRF, the goal is to determine optimal routes for a fleet of vehicles that can renew their capacity at intermediate replenishment stations. The VRPIRF is a special case of the MDVRPI in which one of the depots is called the central depot and the others being intermediate replenishment depots. The vehicles start and end their trips at the central depot. The part of the route of a vehicle between two consecutive depots is called a “route segment” and the total demand of the customers visited in each route segment is limited by the capacity of the vehicle. The duration of the whole route for a vehicle cannot exceed a given upper bound. Beside the non-periodic characteristic of the VRPIRF, the problem is very similar to the PVRP-IF except for a small difference: in the PVRP-IF the vehicles leave the central depot empty and immediately go to an intermediate facility and also have to visit an IF immediately before going back to the main depot at the end of their tour. This is not the case in the VRPIRF. Tarantilis et al. (2008) suggest a three-step algorithm to solve the VRPIRF. Their algorithm consists of a cost-saving construction heuristic to create the initial solution, improving it using a tabu search within a variable neighborhood search methodology, and applying guided local search to eliminate low-quality features from the final solution. They apply their algorithm to benchmark instances in the literature as well as to new classes of the VRPIRF benchmark instances. They also mention some applications such as waste-collection when waste disposal is done to multiple dump sites, winter road maintenance when it is done by spreading chemicals and abrasives, and snow plowing.


                     Kim, Kim, and Sahoo (2006) present algorithms for a commercial waste collection VRP with time windows with consideration of multiple site locations and drivers’ lunch break. They characterize this problem as a VRP with time windows and intermediate facilities (VRPTW-IF). In this specific waste collection application, a vehicle that is full needs to go to the closest available disposal facility and this may happen several times per day. There are two capacity constraints: one for the vehicle and another one for the route. The route capacity includes maximum number of stops and lifts, and maximum volume and weight that a driver can handle per day. Kim et al. (2006) take the minimization of route compactness and the workload balance into account besides the two common objective functions of VRPs: minimizing the number of vehicles and the travel time. These authors also state that considering disposal trips is not a simple task. An extended insertion algorithm of Solomon (Solomon, 1987) to consider multiple disposal trips and drivers’ break, and a clustering-based waste collection VRPTW algorithm are proposed.


                     Kek, Cheu, and Meng (2008) introduce two new distance-constrained capacitated VRPs (DCVRP) and show the potential benefit of assigning start and end depots in a flexible way. The DCVRP_Fix is their first problem in which both vehicle capacity and maximum distance constraints are imposed as well as additional service and travel time constraints. It also considers the minimization of vehicle utilization and is applicable to both symmetric and asymmetric problems. In their second problem, the DCVRP_Flex, which is a relaxation of the first variant, the vehicles are allowed to start and end their tour at different depots and to visit any depot for reloading. In the definition of this problem, each vehicle route can pass through any number of depots any number of times as long as range constraints on the total length of any vehicle route are met. Their problem is structurally very similar to the MDVRPI. The main difference is that in the DCVRP_Flex a distance-constrained capacitated version of the VRP is considered to have intermediate facilities available. They solved both the DCVRP_Fix and the DCVRP_Flex problems to optimality using four case studies in Singapore and show the positive benefits of flexible assignment in practice. Comparing the definitions, one can find the similarities between the second version of the problem introduced by Kek et al. (2008) and the OPHS in the sense that in both problems the initial and the final depot are allowed to act as an intermediate depot as well. This is also the case for the MDVRPI. The difference is that in the OPHS the constraint of having a fixed start and end depot should still be satisfied while in the other mentioned problems (the MDVRPI and the DCVRP_Flex) it is relaxed. Moreover, the main difference is still the same: in the DCVRP_Flex, there is no time budget between each two consecutive depots in the route.

Time windows, driver breaks, and multiple disposal facilities in a waste collection VRP are also considered in Benjamin and Beasley (2010). They propose two metaheuristic algorithms using tabu search and variable neighborhood search as well as an algorithm based on variable neighborhood tabu search where the tabu search is used to search the neighborhood. As these authors mention, their problem is a collection problem with disposal facilities and it differs from the delivery problem with replenishment facilities in the sense that, in the collection problem, a vehicle visits a disposal facility to empty itself immediately prior to returning to the depot.

Since the OPHS is a node routing problem, arc routing problems with intermediate facilities (Ghiani & Federico, 2001; Ghiani, Guerriero, Laporte, & Musmanno, 2004; Ghiani, Laganà, Laporte, & Mari, 2008) are not discussed in detail here.

In conclusion, although there are some papers that consider intermediate facilities in node (and arc) routing problems with a cost (or time) minimizing objective function, there does not exist any research with intermediate facilities that considers maximizing the total collected score while the available time is not enough to visit all the customers. Beside this main difference none of the introduced problems imposes a time constraint on each trip length. Moreover, the number of connected trips in the tour of the OPHS is a given parameter of the problem which makes it different from all related problems mentioned above.

Another related problem to the OPHS is the traveling salesperson problem with hotel selection (TSPHS) which is introduced by Vansteenwegen, Souffriau, and Sörensen (2012). In the TSPHS, the traveling salesman should select a hotel every night to rest and has to continue his tour the next day visiting the other customers from the same hotel. As he has to visit all his customers, the number of days is not predefined, but should be minimized as the primary goal in its objective function. The secondary goal is to minimize the total travel length. The authors develop a heuristic that uses two initialization methods and an improvement phase. The improvement phase is composed of seven local search moves and is specifically designed for their problem. Another recently published paper on the TSPHS (Castro, Sörensen, Vansteenwegen, & Goos, 2013) introduces a new mathematical formulation for the problem and designs a metaheuristic approach to solve it. Their suggested solution framework is a memetic algorithm with an embedded tabu search. For a detailed comparison between the TSPHS and the OPHS, we refer to the literature review presented in Divsalar et al. (2013).

In this final part of the literature review, we will briefly discuss the solution method for the OPHS described by Divsalar et al. (2013). In Divsalar et al. (2013), a skewed variable neighborhood search (SVNS) is developed to solve the OPHS. In the initialization phase of their SVNS, all the feasible sequences of hotels are created. Moreover, an orienteering problem is heuristically solved between each pair of hotels and using these results, the list of feasible sequences is sorted. Considering this list, the initial solution is constructed and some of the feasible sequences of hotels are selected and used in the improvement phase. The local search part of the SVNS is composed of nine local search moves as well as a shaking phase. In the shaking phase the hotel sequences are updated and the visited POIs between the hotels are also shaken. They also developed some OPHS benchmark instances with known optimal solution.

In the current paper, the local search part of the algorithm is a variable neighborhood descent (VND) in which less local search moves are used compared to the SVNS and the applied moves like Insert and Move-Best are implemented in a different way than in the SVNS. The (new) implementation of all moves is explained in Section 3.3. Moreover, the way that the two methods deal with the sequences of hotels is totally different. In the SVNS all the feasible sequences of hotels are created in advance which makes it inefficient for instances with a very large number of possible sequences. In the MA, this duty is done by the genetic operators of the algorithm which try to find a better sequence of hotels each time by combining the previously created sequences.

An overview of all mentioned literature is presented in Table 1
                     .

Our choice for a memetic algorithm (MA) to tackle the OPHS is motivated by presenting some examples of successful implementations of an MA in solving the same class of problems. In the next section we will explain the suitable structure of an MA for solving the OPHS.

One can find a detailed survey of employing evolutionary algorithms for different variants of VRPs in Potvin (2009). MAs were first introduced by Moscato (1999) and have been successfully applied for VRPs by Prins (2004). Bouly, Dang, and Moukrim (2010) were the first to propose an MA for a variant of the OP, namely the Team Orienteering Problem (TOP). Their MA uses an Optimal Split procedure (Beasley, 1983) specially developed for the TOP. Their Optimal Split procedure is later improved by Dang, Guibadj, and Moukrim (2013). In recent applications of MAs to VRPs, Mendoza, Castanier, Guéret, Medaglia, and Velasco (2010) propose an MA for the multi-compartment VRP with stochastic demands and Ngueveu, Prins, and Wolfler Calvo (2010) develop an MA for the cumulative capacitated VRP. In the former, at each generation of a new population, crossover, mutation and local search operators are independently applied with a certain amount of probability for each. In the latter, at each iteration, two parents are selected by a binary tournament and a crossover is applied to generate eight children. Then the best child is selected using a kind of roulette wheel selection. Local search is applied to the best child and replaces a randomly selected individual among the 50% worst individuals of the current population.

The structure of the OPHS, and the fact that it is not possible to predict which selection of hotels will result in a good solution, automatically leads to a two-level solution strategy. In this way, one level focuses on the hotel selection and the other part concentrates on the selection of POIs. A memetic algorithm (MA) corresponds naturally to this two-level solution strategy.

An MA is an evolutionary algorithm hybridized with local search techniques. The evolutionary algorithm that we use in our MA is a genetic algorithm (GA) focused on the (re)combination of different sequences of hotels (intermediate facilities). The local search technique is a variable neighborhood descent (VND) with six local search moves. The local search part focuses on finding good sequences of POIs between each pair of hotels in the tour.

For the solution encoding, we use D lists to represent the D trips. Each list starts and ends in a hotel. The start hotel of the first trip is the initial depot which is represented by 0 and the end hotel of the last trip is the final depot which is represented by 1. The POIs are mentioned by numbers between the start and end hotel of each trip based on their sequence of visit in the trip. Fig. 1
                      displays an example of the solution representation in the MA.

In the GA operators only the sequence of hotels is considered. Therefore, each GA chromosome only contains the sequence of visited hotels in the solution. In the example displayed in Fig. 1, the GA chromosome is also shown. The solution quality corresponding to this chromosome is the sum of the scores associated to the POIs visited in the solution.

Algorithm 1 shows the general structure of our algorithm. A detailed explanation of all elements of the algorithm, as well as of the local search moves, is given below.


                     Algorithm 1. General structure of the MA
                     
                        
                           
                        
                     
                  

The proposed MA is composed of two main parts: Initialization and Main-loop. In the Initialization part, a preprocessing step is performed and a potential score for each pair of hotels is determined. Then, the initial population is created. The Main-loop part includes two crossover operators and one mutation operator that are used to populate the Pool of solutions (Pool). At the end of each iteration a new population is selected from the Pool. This process stops when a maximum number of iterations is reached.

During the initialization, a potential score for every pairs of hotels is calculated first in a preprocessing step. Then, the initial population is generated. Algorithm 1a shows the initialization phase and in the following sections each part of it is explained in detail.

An orienteering problem (OP) is heuristically solved between every possible pair of hotels for each trip. Note that each trip can have a different travel time limit and, as a result, each trip can have a different OP that needs to be solved. A very fast and straightforward algorithm which is called Greedy sub-OP heuristic by Divsalar et al. (2013) is used to solve these OPs independently from each other. This means that POIs can be visited more than once in different OPs. However, in this way, a potential score between each pair of hotels is calculated for each trip.

In this step, two three-dimensional matrices are created: one to save the solution, i.e., a sequence of POIs, between each pair of hotels (and for each trip) and the other one to save the score of this solution. From the matrix with scores, for each start hotel, h
                           1
                           ∊
                           H, and for each trip, d
                           ∊{1,…,
                           D}, a list of possible end hotels, h
                           2
                           ∊
                           H, is derived. The possible end hotels are defined by two constraints: 
                              
                                 1
                                 )
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             h
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             h
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                                 ≤
                                 
                                    
                                       T
                                    
                                    
                                       d
                                    
                                 
                              
                           , and 
                              
                                 2
                                 )
                                 
                                    
                                       t
                                    
                                    
                                       
                                          
                                             h
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       1
                                    
                                 
                                 ⩽
                                 
                                    
                                       ∑
                                    
                                    
                                       i
                                       =
                                       d
                                       +
                                       1
                                    
                                    
                                       D
                                    
                                 
                                 
                                    
                                       T
                                    
                                    
                                       i
                                    
                                 
                              
                           . In each list the possible end hotels are sorted based on the potential score of their corresponding trip. When later, during the Main-loop phase, some of the trip scores are updated; these sorted lists of hotels are updated as well.


                           Algorithm 1a. Initialization phase
                           
                              
                                 
                              
                           
                        

Creating the initial population starts by composing sequences of hotels. Each time, the sequence starts in the initial hotel and the next hotels are selected one by one. The matrix of pairs of hotels includes all possible end hotels for each start hotel. This information is used here in making the sequence of hotels. The selection of an end hotel is not a pure random one, but the end hotels with higher scores have a larger probability of being selected (the selection probability is proportional to the score). Obviously, the sequences of hotels have to end in the final depot. If it happens in any trip that the selected hotels make it infeasible to end in the final depot, the algorithm replaces the last selected hotel by a different one based on the same procedure. If there is no more hotel left for the current trip, it goes back another step. After creating a feasible sequence of hotels, local search is applied on it to select POIs in all trips and to make a complete OPHS solution. The whole process is repeated to create enough solutions for the initial population.

The roulette wheel selection method is used to select solutions for both crossover operators and the mutation operator (explained below). This method assigns to each solution in the population a probability for selection proportional to its solution quality. Let fi
                            be the solution quality value of solution Pi
                            in the population P. This solution quality value corresponds to the total collected score of the solution. The probability of a solution to be selected is then calculated as 
                              
                                 
                                    
                                       P
                                    
                                    
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       f
                                    
                                    
                                       i
                                    
                                 
                                 /
                                 (
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       n
                                    
                                 
                                 
                                    
                                       f
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                            (Talbi, 2009).

Setting an adequate stopping condition is crucial to balance solution quality and computation time of the algorithm. In our algorithm we simply use the maximum number of iterations (MaxIteration), i.e., the maximum number of new generations of the population. The exact value for MaxIteration will be discussed in Section 4.2 (line 4 of Algorithm 1).

In each iteration of the main-loop, a Pool of solutions (Pool) is populated by the solutions of the current population as well as new solutions made by applying GA operators. First, the current population is transferred to the Pool. Then, two crossover operators and one mutation operator are used to create new solutions from the current population. These solutions are added to the Pool. The percentage of solutions selected from the current population to apply Crossovers I and II on, is set by CRI_R and CRII_R. Both algorithm parameters are discussed in Section 4.2. Then, the mutation operator is applied on the current population, making more offspring to populate the Pool such that the Pool is twice the size of the current population. Algorithm 1b displays the whole process of populating the Pool. At the end of each iteration, the new population is selected from the Pool.


                           Algorithm 1b. Populating the Pool
                           
                           
                              
                                 
                              
                           
                        

A crossover operator is applied to two solutions selected from the current population as parents, and creates two new solutions, called offspring solutions, that will be added to the Pool.

In both crossover operators, the sequence of hotels is handled in the same way: the hotels of the selected parent solutions are combined using a one-point crossover to create two new hotel sequences. This is done in the following way:
                                 
                                    a.
                                    One of the trips (trip d) of the first parent, P1, is randomly selected. This trip is called the pivot trip.

The algorithm then checks if it is feasible for this pivot trip to start from the initial hotel of the selected trip in the first parent solution, 
                                          
                                             
                                                
                                                   h
                                                
                                                
                                                   1
                                                   ,
                                                   d
                                                
                                                
                                                   P
                                                   1
                                                
                                             
                                          
                                       , and end in the final hotel of the selected trip in the second parent solution, 
                                          
                                             
                                                
                                                   h
                                                
                                                
                                                   2
                                                   ,
                                                   d
                                                
                                                
                                                   P
                                                   2
                                                
                                             
                                          
                                       . This check, 
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         1
                                                         ,
                                                         d
                                                      
                                                      
                                                         P
                                                         1
                                                      
                                                   
                                                   ,
                                                   
                                                      
                                                         h
                                                      
                                                      
                                                         2
                                                         ,
                                                         d
                                                      
                                                      
                                                         P
                                                         2
                                                      
                                                   
                                                
                                             
                                             ⩽
                                             
                                                
                                                   T
                                                
                                                
                                                   d
                                                
                                             
                                          
                                       , can be done efficiently by using the matrix of pairs of hotels.

If the condition in (b) is true, the new sequence of hotels is formed by taking the hotel sequence of the first part of the first parent up to the initial hotel of the pivot trip, 
                                          
                                             
                                                
                                                   h
                                                
                                                
                                                   1
                                                   ,
                                                   d
                                                
                                                
                                                   P
                                                   1
                                                
                                             
                                          
                                       , and combining it with the hotel sequence from the final hotel of the pivot trip in the second parent, 
                                          
                                             
                                                
                                                   h
                                                
                                                
                                                   2
                                                   ,
                                                   d
                                                
                                                
                                                   P
                                                   2
                                                
                                             
                                          
                                       , to the final depot.

If the condition in (b) is false, another trip is selected randomly.

The same strategy is also applied to the second parent to make the second offspring solution. The crossover operator is illustrated in Fig. 2
                              . It should be mentioned that the crossover point to create the second offspring solution is not necessarily the same as the crossover point to create the first.

The difference between the two crossover operators lies in how they continue from these two new hotel sequences.

This crossover operator implements a move specifically developed for the sequences of hotels in each offspring solution (called hotel-exchange). This move evaluates all feasible swaps of two hotels. Based on the scores saved in the matrix of pairs of hotels, the best swap is executed. In this step, for the trips that at least have one hotel changed, the heuristic solution saved in the matrix of pairs of hotels is used. Afterwards, the possible duplicate POIs are removed, first from the trips where at least one of the hotels was changed and then from the other trips in the solution. At the end, local search is applied to further improve the solution. So, in Crossover I, only for some trips the POIs in the parent solutions are used in creating the offspring.

In this operator, the POIs between the hotels in the parent solutions are used for the offspring solutions. For the pivot trip, the first hotel and all the POIs are copied from the first parent, and only the final hotel is derived from the second parent. If this makes the trip infeasible, the POIs with the least ratio of score over the saved time are removed one by one to make the trip feasible. In the end, local search is applied to further improve the solution.

In the mutation operator, one solution is selected as a parent and mutated to create an offspring. To do this, one trip is randomly selected and the last hotel of the trip (equal to the first hotel of the next trip) is updated as described below. In some cases also the last hotel of the next trip need to be updated, but never any of the other hotels.

For each hotel and each trip a sorted list of possible end hotels is available from the matrix of pairs of hotels. The new end hotel for the selected trip (pivot trip) is selected from this list based on the first hotel of the trip. Starting from this new end hotel it is checked that by selecting this hotel the next trip will have a feasible pair of hotels (looking at the end hotel of the next trip). If this new hotel leads to an infeasible sequence for the next trip, the last hotel in the next trip is also considered for updating using the same procedure. If by selecting an end hotel for the pivot trip, it is not possible to find a feasible end hotel for the next trip, the next possible end hotel is considered for the pivot trip. In the few cases that no feasible combination of end hotel for the pivot trip and end hotel for the next trip can be determined, the mutation operator will not modify the parent.

After updating the hotel(s), the two or three affected trips are filled using the solutions saved in the matrix of pairs of hotels. The other trips stay the same in the beginning. To make the solution feasible, first the duplicated POIs are removed from the unchanged trips and then from the affected trips. Finally, local search is applied to further improve the solution.

At the end of each mutation iteration, the matrix of pairs of hotels is updated: the assigned scores for the pairs of hotels which are new in the offspring compared to the parent are updated in the matrix and the sorted list of hotels is updated as well. To ensure the variety of different possible hotel sequences, a tabu list is used to store the recently selected hotels in each trip. The tabu list is updated each time the mutation is performed. The new selected end hotel of each trip (one or two updated hotels), is made tabu for a number of iterations. The number of iterations of mutation for which the same hotel is not selected for the same trip is TabuSize, a parameter of the algorithm. This will be discussed in Section 4.2.


                              Algorithm 1c. Population management
                              
                                 
                                    
                                 
                              
                           

In the next step, the next population is selected from the Pool that currently contains both the current population and the newly created offspring. This selection is done based on a strategy to manage the population considering both the quality and the diversity of the solutions contained in it. In this view, our algorithm belongs to the class of memetic algorithms with population management (MA|PM), introduced in (Sörensen & Sevaux, 2006) and extensively described and analyzed in (Boudia & Prins, 2009). Most population management strategies are based on an incremental genetic algorithm and involve a distance measure between solutions. Here we develop a generational genetic algorithm with a simpler and more flexible procedure to manage population diversity. The process is depicted in Algorithm 1c. In order to apply our population management strategy, all the solutions in the Pool are sorted based on their quality. Afterwards, the solutions with the best solution quality are selected to be in the next population which becomes the current population of the next iteration. The number of selected solutions in this step is equal to BestSel
                           -
                           R
                           ×2×
                           PopSize in which both BestSel
                           -
                           R and PopSize are parameters of the algorithm that will be discussed in Section 4. To fill the rest of the population, the same order is used, but only solutions with a sequence of hotels different from the already selected solutions are chosen. If the number of solutions with different sequences of hotels is not enough to fill the population, the solutions with the minimum solution quality are selected to fill the population. In this way, we try to keep enough diversity in the population.

Local search tries to improve the selection of POIs between the hotels. A variable neighborhood descent with six well known local search moves is implemented. An overview is given in Algorithm 2. Next, all moves are briefly explained.


                        Algorithm 2. Local search
                        
                           
                              
                           
                        
                     


                        
                           
                              
                                 Insert: For each non-included POI, the position with minimum increase in trip length in any of the trips is determined. If this position leads to a feasible solution, the POI is inserted. Then, the next POI is considered until no more insertions are possible.


                                 Move-Best: For every visited POI in every trip, it is checked that removing this POI from its current position and putting it in its best possible position within the whole tour is feasible and decreases the length of the tour. Only the feasible move with the highest decrease in total tour length is completed.


                                 Two-Opt: For each trip, two visited POIs are determined for which the inversion of the order of vertices between them leads to the largest travel time decrease in the trip. Then, the order of visiting the POIs between them is reversed.


                                 Swap-Best: This move exchanges two visited POIs between two different trips to reduce the total travel time. For each pair of trips (d1 and d2) two POIs (one from each trip) are swapped only if the length of at least one of the trips decreases and both trips remain feasible. In order to determine this, four travel time changes are calculated: the amount of time saved in trip d1 by excluding POI i; the amount of time saved in trip d2 by excluding POI j; the best position in trip d1 to include POI j, and the best position in trip d2 to include POI i (least time consuming positions). Only the move leading to the highest total time saving is performed.


                                 Extract-Insert: This move starts from the first visited POI in each trip and checks if by excluding this vertex and inserting as many unvisited POIs as possible in the trip, the score can be increased. If that is the case, this exchange is applied and the algorithm goes to the next visited POI in the trip. The excluded POI is not considered again for insertion. Inserting the POIs is done by Insert, described above.


                                 Extract2-Insert: This move is identical to the previous move, except for the fact that it always considers two consecutive visited POIs for exclusion.

@&#EXPERIMENTS AND RESULTS@&#

The benchmark instances are described briefly in Section 4.1 and the preliminary experiments used to set the parameters are discussed in Section 4.2. The results of the experiments are presented and explained in Section 4.3. An important observation is that the total number of feasible sequences of hotels (TNFS) is a key element determining the difficulty of an OPHS instance and is discussed in Section 4.4. Finally, in Section 4.5, the sensitivity of the results with respect to changes in parameters and parts of the algorithm is analyzed.

In Divsalar et al. (2013), it is explained how different sets of test instances are created with known optimal solutions. These instances are created based on the optimal solution of regular OP instances. In order to create OPHS instances with D trips, D
                        −1 hotels are added at certain POIs in the optimal path and some additional hotels are added on the place of randomly selected POIs from the OP instance. The key point is that these D
                        −1 hotels are added and the trip lengths are fixed in such a way that the optimal OPHS solution corresponds to the optimal OP solution. By solving some larger OP instances to optimality, thanks to a more powerful PC and a better coding, we were able to create more and larger instances of the OPHS with known optimal solutions in the same way. These new instances are also available at http://www.mech.kuleuven.be/en/cib/op. In order to evaluate the performance of the proposed algorithm, it is tested on all previously available benchmark instances as well as the newly created instances. The new set of instances are indicated in Table 2
                         by an * at the beginning of their name in the first column. The algorithm is coded in Visual C++ 2010. All computations were carried out on a personal computer Intel Core 2 with 3.00GHz processor and 4.00GB RAM.

In total there are six parameters involved in the proposed algorithm: MaxIteration, PopSize, CRI_R, CRII_R, BestSel_R and TabuSize. To set these parameters properly, a number of pilot experiments are performed. First, 28 instances are randomly chosen from different sets of instances. Then, for each of the parameters, three different values are determined. Afterwards, the algorithm is applied on the selected set for all 729 possible combinations of different values of parameters. In order to select the appropriate set of parameter values, we made a trade-off between quality of the results and the computation time. Based on these pilot experiments, the parameters are set as follows: MaxIteration
                        =100, PopSize
                        =30, CRI_R
                        =30%, CRII_R
                        =40%, BestSel_R
                        =25% and TabuSize
                        =33% of the number of hotels.

@&#RESULTS@&#

Detailed results for each instance can be found in the tables presented in Appendix A. The results are compared with the known optimal solution and the results of the skewed variable neighborhood search algorithm (SVNS) published in Divsalar et al. (2013). A summary of the results on all presented instances in Appendix A, is displayed in Table 2. The presented sets of instances in this table are ordered based on the maximum total number of feasible sequences of hotels (TNFS) in each set. Our experiments show that TNFS is an important characteristic of an OPHS instance, determining its difficulty. This characteristic is investigated in detail in Section 4.4. In Table 2, the first column shows the set of instances. The name of each set of instances shows the number of hotels, excluding the initial and final depot, as well as the number of trips in each corresponding instance. The second column indicates the number of instances in each set. Then the maximum number of TNFS in each set is presented in the third column. Afterwards, the average gap, the maximal gap and the number of instances for which the optimal solution is found are displayed. Due to randomness in its structure, MA is applied on each instance three times. But since there is no randomness in the SVNS structure, only one result is shown for it. So, for each of these mentioned columns, three sub-columns show the average and the best results of three times applying MA and the result of applying SVNS, respectively. The gap here is the percentage difference between the obtained solution and the optimal solution, calculated this way: 
                           
                              100
                              ×
                              
                                 
                                    
                                       
                                          
                                             Optimal
                                             
                                             result
                                             -
                                             MA
                                             
                                             result
                                          
                                          
                                             Optimal
                                             
                                             result
                                          
                                       
                                    
                                 
                              
                              %
                           
                        . The last column, Average CPU, has two sub-columns and presents the average computational time spent in solving each instance set applying MA and SVNS. The presented computational time of applying the MA shows the average time of three runs on each instance. The (small) difference in computation times reported here for the SVNS compared to those reported in Divsalar et al. (2013) are due to a different computing environment. The times reported here allow a fair comparison of both techniques.

The set of instances with 1 extra hotel (in addition to the initial and final depot) and 2 trips is displayed two times with different results since a second version of the algorithm was applied on this set. This is explained later. The set of instances presented in the fourth row of the results in Table 2, corresponds to the so called SET 4 (Divsalar et al., 2013), but in Table 2 only the five instances with known optimal solution are used.

We start the discussion of the results in Table 2 with the exceptional results on the first set (second row of results). The special characteristic of these very small instances is the very small number of TNFS. Clearly, our MA does not outperform the SVNS on these very small instances (Appendix A, Table A.2). Actually, the whole structure of the MA, focusing on finding the best sequence of hotels, becomes useless when only three feasible sequences of hotels are possible. For these instances, the algorithm should focus only on solving the combination of OPs between the selected hotels. Actually, some extra experiments show that if we add four more local search moves to the Local Search part of our MA algorithm, hereby focusing more on solving the combination of OPs, the average results of our algorithm correspond to the SVNS results, but the MA is still slower (Appendix A, Table A.1). The results obtained by this second version of the algorithm are presented in the first results row of Table 2 and are not counted in the total row (last row) of Table 2.

In all other sets of instances, with the TNFS ranging from 16 to 1.18×1011, for both average and best results of three runs of the MA, the average gap obtained by the MA is less than the average gap obtained by the SVNS. Moreover, the results achieved by the MA are much better than the SVNS results for larger instances. This conclusion can be seen by comparing both average and maximal gaps.

When it comes to the computation time, the comparison shows a different trend. For smaller sets of instances, the SVNS is much faster than the MA. But when the number of TNFS increases, the difference between average computational times decreases and for the largest sets of instances with the largest number of TNFS, the MA is much faster than the SVNS. The results show that for instances with large number of TNFS, the SVNS is very time consuming, but the MA is able to solve these in a reasonable time.

The maximal value of TNFS for any instance is equal to (h)(
                        
                           D
                        
                        −1). However, since there might be some infeasible sequences of hotels, we created and counted all feasible sequences of hotels using the initialization part of the SVNS algorithm. For larger instances, for which SVNS could not find all the feasible sequences due to memory shortage, the maximal value of TNFS is used.


                        Fig. 3
                         is an example of how TNFS is computed using an OPHS instance of 3 trips and 2 intermediate hotels (h
                        =4).

In this example the max value of TNFS
                        =(4)(3−1)
                        =16, but as some of the connections in trip 2 are not feasible (for example, trip 2 is too short to go from hotel 2 to hotel 3), so the actual TNFS for this example is 10.

To have a better insight in the significant impact of TNFS on the complexity of the problem and thus the performance of the MA and SVNS, Figs. 4 and 5
                        
                         present the experimental results graphically. This also allows comparing the results of the two algorithms. In both figures, the horizontal axis shows the maximum number of TNFS in each set of instances. The label SVNS shows the results from the SVNS algorithm presented in Divsalar et al. (2013) and MA-AVG and MA-Best are the labels of the average and best results of three runs of the MA on each set of instances, respectively.

In Fig. 4, the vertical axis shows the average gap, in percentage, between the results of the algorithms and the optimal solution. The figure clearly shows that the average gap increases when the TNFS increases. Moreover, it can be seen that almost everywhere the average gap of the results obtained by the MA is less than the one from the SVNS and when TNFS increases, the distance between the SVNS and the MA results significantly increases.

In Fig. 5, a comparison is shown between the computational time of each of the two algorithms. Considering the Average CPU usage of the three runs of the MA, for smaller instances SVNS is faster. However, when TNFS is significantly increased, the MA is clearly much faster than the SVNS.

Some extra computational experiments, summarized in Table 3
                        , show that small changes in the parameter values do not have a significant impact on the performance of the algorithm. In Table 3, the first column under the name of MA presents the values of the parameter used in the algorithm to obtain the presented results in Table 2. The second and third column under MA show the results of applying these parameter values on the set of instances with 15 extra hotels and 8 trips. The second and third group of three columns present the results of applying the MA with one slightly different parameter value on the same set of instances.

The only changes in parameter values that do have a significant impact on the performance of the algorithm are, obviously, MaxIteration and PopSize. By using higher values for them the quality of the results are increased but at the cost of higher computation time.

Some extra experiments also illustrate that both crossovers and the mutation are useful operators in our MA algorithm. To show this, the crossovers and the mutation are removed one by one and the impact on the selected set of instances is investigated. In the algorithm setting “Without Mutation”, the weights assigned to both crossovers are equal to 50% of the PopSize. The results from this analysis are presented in Table 4
                        . Removing any of these parts significantly increases the average gap with the optimal solutions.

@&#CONCLUSION@&#

The OPHS is a challenging combinatorial optimization problem. Although “intermediate facilities” are considered in some variants of the VRP, the OPHS is studied in only one paper in the literature. A detailed overview of all related problems, also discussing the similarities and differences with the OPHS, is presented in this paper.

We create new and larger instances of the OPHS with up to 15 extra hotels and 10 trips. This size is realistic in the context of tourism applications. These instances are efficiently solved by our algorithm in a reasonable time. Moreover, it is clearly shown that the number of possible sequences of hotels is a critical characteristic of an OPHS instance to indicate its difficulty.

The proposed memetic algorithm is designed to deal with larger instances of the OPHS and it certainly outperforms the only other existing algorithm, SVNS, on these instances. The two-level structure of the MA is efficiently compatible with the two different sets of nodes in each instance: hotels and POIs. Therefore, the higher level uses the genetic algorithm property to make a diverse list of different sequences of hotels. Moreover, the fact of creating a population of solutions considering different sequences of hotels guarantees the diversity of the population. The lower level of the MA is the POI level which uses local search moves to efficiently solve the combination of OPs between the selected hotels. The fact that both quality and diversity in the selection of individuals from the Pool introduces a simple and flexible form of population management and can be considered another advantage of the proposed memetic algorithm. The special design of mutation is another strong point of the algorithm. In this operator, different strategies are used to escape from local optima by perturbating the order of POIs even between unchanged hotels.

Extensions of the OPHS to other versions of the problem, including time windows, hotel scores, route scores or an OPHS with multiple vehicles, can be considered in future work. These proposed variants of the problem will help to model more realistic situations in tourism and other possible applications of the problem.


                     Tables A.1–A.7, A.11 and A.18
                     
                     
                     
                     
                     
                     
                      present results on the benchmark instances of (Divsalar et al., 2013) and Tables A.8–A.10 and A.12–A.17
                     
                     
                     
                     
                     
                     
                     
                     
                     
                     
                      show the results on the new instances. In all displayed tables, the second column, TNFS, shows the total number of feasible sequences of hotels. The optimal value for each instance is displayed in the third column of the tables. Due to randomness in our MA algorithm, it was run three times for each instance. Therefore, the worst, the average, and the best gaps with the optimal values are presented in columns 4–6 of each table 
                        
                           100
                           ×
                           
                              
                                 
                                    
                                       
                                          Optimal
                                          
                                          result
                                          -
                                          MA
                                          
                                          result
                                       
                                       
                                          Optimal
                                          
                                          result
                                       
                                    
                                 
                              
                           
                           %
                        
                     . Then, to be able to have an easy comparison, the results obtained by SVNS are presented in the next column. The computation times are displayed in two columns under the name of CPU. First one, MA-CPU, shows the average computation time of three runs of the MA algorithm and next to that the computation time of the SVNS algorithm is presented. For Table A.16, SVNS is only able to solve 7 out of 13 presented instances. For the other instances in Table A.16 as well as all the instances presented in Table A.17 no feasible solution is found by SVNS in 360s of computation time per instance.

In Tables A.16 and A.17, the presented maximum number of TNFS is the theoretical maximum, which equals H
                     (
                     
                        D
                     
                     −1), since for at least some of the instances the real feasible number of sequences of hotels was too large to calculate.

The presented results in Table A.18 only include the average results of applying MA three times on each instance. In this table, after the instance name and its TNFS, the best feasible (BF), upper bound (UB) and optimal value (OV) for the corresponding instances are presented. The way of creating these instances and the mentioned values are explained in Divsalar et al. (2013).

@&#REFERENCES@&#

