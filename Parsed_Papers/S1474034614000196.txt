@&#MAIN-TITLE@&#A domain-specific knowledge-based heuristic for the Blocks Relocation Problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A knowledge-based heuristic to solve the Blocks Relocation Problem is presented.


                        
                        
                           
                           This heuristic method significantly outperforms other methods from the literature.


                        
                        
                           
                           The computational tests show the effectiveness and efficiency of the heuristic.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Blocks Relocation Problem

Maritime container terminal

Heuristics

Logistics

@&#ABSTRACT@&#


               
               
                  The Blocks Relocation Problem consists in minimizing the number of movements performed by a gantry crane in order to retrieve a subset of containers placed into a bay of a container yard according to a predefined order. A study on the mathematical formulations proposed in the related literature reveals that they are not suitable for its solution due to their high computational burden. Moreover, in this paper we show that, in some cases, they do not guarantee the optimality of the obtained solutions. In this regard, several optimization methods based on the well-known A∗ search framework are introduced to tackle the problem from an exact point of view. Using our A∗ algorithm we have corrected the optimal objective function value of 17 solutions out of 45 instances considered by Caserta et al. (2012) [4]. In addition, this work presents a domain-specific knowledge-based heuristic algorithm to find high-quality solutions by means of short computational times. It is based on finding the most promising positions into the bay where to relocate those containers that are currently located on the next one to be retrieved, in such a way that, they do not require any additional relocation operation in the future. The computational tests indicate the higher effectiveness and efficiency of the suggested heuristic when solving real-world scenarios in comparison with the most competitive approaches from the literature.
               
            

@&#INTRODUCTION@&#

The container yard is an outstanding functional area of maritime container terminals due to the fact that it brings together the main flows of containers; those established between the quayside and the landside [15]. Generally, container yards are split into several blocks, that is, sets of container bays arranged in parallel. A bay is a delimited two-dimensional stock disposed in the vertical direction, where containers can be placed over each other. The container stacking poses a great limitation for their handling because they are accessed by following the Last In First Out (LIFO) policy, in such a way that, only those containers placed at the top of the stacks are accessible directly.

A large variety of handling machinery has been proposed to manage containers. The most common are reach stackers, straddle carriers, Rubber-Tyred Gantry Cranes (RTGCs), Rail-Mounted Gantry Cranes (RMGCs) and Overhead Bridge Cranes (OBGs) [21]. Nowadays, the RMGCs are the most widely extended systems in modern terminals due to their high performance and potential for automation. The dimensions of RMGCs allow to use large-dimensioned container blocks, that is, blocks comprising 40–50 bays composed of 6–8 stacks and 5–6 tiers. This type of cranes can move along the blocks by means of a pair of rail tracks placed on both sides. The access to containers is carried out following a well-defined set of steps in succession [29]. Firstly, the crane is positioned over the bay where the container to retrieve is located. Later, its trolley is moved toward a position above the target stack and its spreader is lowered in order to achieve the target container. Once the container is hooked up, this can be picked up and move it outside the bay.

Accurate information about the containers (weight, destination, size, etc.) allows to reach a fluent exchange between the transportation modes brought at the terminal. Unfortunately, most of the times the available information is somehow inaccurate or incomplete due to the intrinsic features associated with the environment. Some sources of disturbances are traffic jams in which container trucks may be involved, changes in the arrival time of vessels, and so forth. In this regard, the container retrieval order is strongly influenced by unforeseen changes. In spite of conducting an exhaustive analysis of container handling along the yard, some containers can be placed below other ones when they have to be retrieved. This fact gives rise to relocate before those containers currently placed on the containers to retrieve. Implementing this type of movements adversely affects the performance of the terminal because they delay the delivery of goods being, therefore, considered as unproductive.

This paper addresses the Blocks Relocation Problem (BRP), whose main goal is to determine the sequence of movements performed by a gantry crane to retrieve a subset of containers placed into a bay of the yard according to a predefined order. The objective is to find the sequence of movements with the minimum number of relocation operations.

The major contributions of the present paper are the following:
                        
                           i.
                           Exhaustive description of the BRP. A complete analysis of the different variants already addressed in the literature (Restricted and Unrestricted BRP), a classification of the containers according to their priorities and the slots in which they are placed and several useful remarks to exploit the structure of the solutions in optimization techniques are provided.

Study of the mathematical formulations for the BRP published in the related literature. Several examples in which the optimality of the reported solutions by Caserta et al. [4] is not guaranteed are showed.

Development of two exact algorithms based on the A∗ search framework devoted to solve the Restricted and Unrestricted BRP. Several lower bounds and an algorithm aimed at finding an upper bound are proposed to prune the underlying trees. The computational results show that they can be successfully applied to small-sized practical scenarios. Additionally, using our A∗ algorithm we have corrected the optimal objective function value of 17 solutions out of 45 instances considered by Caserta et al. [4] for the Restricted BRP.

Development of a heuristic algorithm aimed at reducing the high computational burden required by the exact approaches when solving the BRP in large scenarios. The computational results indicate that the performance of this solution approach is suitable for a large variety of practical scenarios and provides statistical significant differences with the most competitive algorithms from the related literature.

The remainder of this paper is organized as follows. Firstly, Section 2 presents a complete description of the BRP. Later, Section 3 overviews the most highlighted contributions of the works published in the literature. Section 4 discusses the applicability of the mathematical models proposed so far and provides two exact algorithms based on the well-known A∗ search framework that can be used as benchmark approaches. Section 5 describes a heuristic technique to solve the BRP from an approximate point of view. Section 6 analyses a broad set of computational tests conducted to assess the performance of the suggested approaches and their most influential components. Lastly, Section 7 depicts the summary and main conclusions extracted from the work.

The Blocks Relocation Problem (BRP) is a combinatorial optimization problem described as follows. Given a set of n uniform containers placed into a bay with S stacks and T tiers, the goal of the BRP is to find the sequence of movements with minimum length that should be performed by a gantry crane in order to retrieve k given containers one after the other in a predefined order, where 
                        
                           k
                           ⩽
                           n
                        
                     . A few different objective functions related to the working time of the handling equipment may be proposed. Nevertheless, minimizing the number of movements is the most widely extended in the literature (see Section 3). This is due to the fact that the time used to move the containers among stacks is usually negligible with respect to that required to perform the coupling and lifting/dropping tasks of containers [11].

The BRP is restricted by the dimensions of the bay. The capacity of the bay depends on the number of stacks and tiers, 
                        
                           C
                           =
                           S
                           ×
                           T
                        
                     , that is, the number of slots where containers can be placed for their storage. From a general point of view, each slot could contain at most one container. Furthermore, each container has associated an exclusive priority or group representing its position within the retrieval order. Without loss of generality, it is assumed that the retrieval order is defined by following the container priorities, in such a way that, the container with the highest priority, 1, must be retrieved before container 2; container 2 must be retrieved before container 3; and so forth, until all the k containers with the highest priorities are retrieved. After the retrieval process finishes, the bay will only contain the 
                        
                           m
                           =
                           n
                           -
                           k
                        
                      containers with the lowest priorities. The BRP is already known to be 
                        
                           NP
                        
                     -hard (see Caserta et al. [4]) so that efficient optimization techniques must be developed to tackle medium and large scenarios.

Some notation must be introduced to ease the perusal of the remainder of this paper. Given a container c, let 
                        
                           s
                           (
                           c
                           )
                        
                      and 
                        
                           t
                           (
                           c
                           )
                        
                      be the stack and the tier in which c is currently placed, respectively. Also, let 
                        
                           p
                           (
                           c
                           )
                        
                      be the priority of container c and 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                      the next container to retrieve from the bay. The number of containers placed in the stack s is denoted by 
                        
                           h
                           (
                           s
                           )
                        
                     . The highest priority of a container in the stack s is denoted by 
                        
                           max
                           (
                           s
                           )
                        
                      and defined as follows:
                        
                           (1)
                           
                              max
                              (
                              s
                              )
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   min
                                                
                                                {
                                                p
                                                (
                                                c
                                                )
                                                
                                                |
                                                
                                                s
                                                (
                                                c
                                                )
                                                =
                                                s
                                                }
                                                ,
                                             
                                             
                                                if
                                                
                                                h
                                                (
                                                s
                                                )
                                                >
                                                0
                                             
                                          
                                          
                                             
                                                0
                                                ,
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

The retrieval of containers from the bay can be performed by following two general types of movements. Firstly, retrieval movements are those in which a container currently placed at the top of some stack is moved outside the bay. After implementing a retrieval movement the number of containers into the bay is decreased in one unit. This type of movements are considered as productive because they give answer to specific service requests. It is straightforward to check that each feasible solution for the BRP has exactly k retrieval movements. On the other hand, relocation movements are those in which a container placed at the top of some stack is moved toward the top of another one. The target stack must contain at least one empty slot. Unlike retrieval operations, implementing this type of movement does not decrease the number of containers into the bay. It is worth mentioning that the bay should have empty slots to store the relocated containers. In this regard, at least 
                        
                           H
                           =
                           T
                           -
                           1
                        
                      empty slots must be available before the retrieval process starts. This value stems from the fact of accessing to a container placed at the lowest tier in a full stack, for which the 
                        
                           T
                           -
                           1
                        
                      containers placed on it must be previously relocated to empty slots in the same bay [4].


                     Fig. 1
                      illustrates an example of the BRP in which there is a bay with 6 stacks, 4 tiers and 16 containers that must be retrieved, that is, 
                        
                           k
                           =
                           n
                        
                     . As defined by the capacity of the bay, a maximum of 24 containers can be stored. The priority of each container is represented by a number indicating the order in which it must be retrieved from the bay.

A general classification of the containers according to their priorities and the slots where they are placed is proposed hereunder. Firstly, a non-located container is that placed at a higher tier than another one in the same stack with a higher priority. See striped containers in the example depicted in Fig. 1. Let 
                        
                           Ω
                           (
                           s
                           )
                        
                      be the set of non-located containers in stack s, defined as follows:
                        
                           (2)
                           
                              Ω
                              (
                              s
                              )
                              =
                              {
                              c
                              
                              |
                              
                              (
                              s
                              (
                              c
                              )
                              =
                              s
                              )
                              
                              ∧
                              
                              ∃
                              
                              
                                 
                                    c
                                 
                                 
                                    ′
                                 
                              
                              :
                              (
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ′
                                 
                              
                              )
                              =
                              s
                              )
                              
                              ∧
                              
                              (
                              t
                              (
                              
                                 
                                    c
                                 
                                 
                                    ′
                                 
                              
                              )
                              <
                              t
                              (
                              c
                              )
                              )
                              
                              ∧
                              
                              (
                              p
                              (
                              
                                 
                                    c
                                 
                                 
                                    ′
                                 
                              
                              )
                              <
                              p
                              (
                              c
                              )
                              )
                              }
                              ,
                              
                              ∀
                              0
                              ⩽
                              s
                              <
                              S
                              .
                           
                        
                     The set of non-located containers into the bay is defined by
                        
                           (3)
                           
                              Ω
                              =
                              
                                 
                                    
                                       ⋃
                                    
                                    
                                       0
                                       ⩽
                                       s
                                       <
                                       S
                                    
                                 
                              
                              Ω
                              (
                              s
                              )
                              .
                           
                        
                     Several authors have introduced the related term deadlock referring to those situations in which there is a pair of containers in the same stack and the priority of the lower container is higher than the priority of the upper one [2]. Moreover, a well-located container is that not placed above any other container with a higher priority in the same stack. The set of well-located containers is formally defined as follows:
                        
                           (4)
                           
                              ϒ
                              (
                              s
                              )
                              =
                              {
                              c
                              
                              |
                              
                              (
                              s
                              (
                              c
                              )
                              =
                              s
                              )
                              
                              ∧
                              
                              (
                              c
                              
                              ∉
                              
                              Ω
                              (
                              s
                              )
                              )
                              }
                              ,
                              
                              ∀
                              
                              0
                              ⩽
                              s
                              <
                              S
                              .
                           
                        
                     It should be pointed out that whenever the containers placed in a given stack are well-located, these are disposed by following the incremental order of priorities, in such a way that, the container with the highest priority is that placed at the highest tier. Note that this type of containers are not currently avoiding the retrieval of any other container and, therefore, they do not require additional relocation movements in the future. Examples of well-located containers are those with white background in Fig. 1.

Feasible solutions for the BRP are sequences of movements that, according to the constraints of the problem, allow to achieve a bay configuration where only the m containers with the lowest priorities are placed. The movements can be represented as pairs (
                        
                           a
                           ,
                           b
                        
                     ), where a is the source stack of the container to move and b is its corresponding target stack. Retrieval movements are depicted with a null target stack. It is noteworthy that the moved container is implicitly named in each case because is that placed at the top of the source stack when the movement is performed.

It is a common practice in container terminals to restrict the feasible relocation movements to only those containers placed on the next one to retrieve, 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                      (see Kim and Hong [14] and Caserta et al. [4]). This version of the BRP is usually referred to as Restricted BRP. In spite of the fact that it reduces drastically the size of the search space because it only considers a subset of all the feasible relocation movements, optimal solutions could be ruled out in some cases. In this regard, an optimum solution of the Restricted BRP for the example presented in Fig. 1 is stated as follows: ((
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           0
                        
                     ), (
                        
                           2
                           ,
                           0
                        
                     ), (
                        
                           2
                           ,
                           1
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           2
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           2
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           1
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           0
                           ,
                           2
                        
                     ), (
                        
                           0
                           ,
                           3
                        
                     ), (
                        
                           0
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           4
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     ), (
                        
                           0
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     )). The number of relocation movements in this case is equal to 9.

On the other hand, the version of the problem in which all the feasible relocation movements are considered is known as Unrestricted BRP 
                     [32]. An optimum solution for the example depicted in Fig. 1 is stated as follows: ((
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           1
                        
                     ), (
                        
                           5
                           ,
                           1
                        
                     ), (
                        
                           3
                           ,
                           5
                        
                     ), (
                        
                           3
                           ,
                           1
                        
                     ), (
                        
                           2
                           ,
                           5
                        
                     ), (
                        
                           2
                           ,
                           5
                        
                     ), (
                        
                           2
                           ,
                           3
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           2
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           0
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           0
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     )), where the number of relocation movements is equal to 8. Unlike the Restricted BRP, the relocation movements are not limited exclusively to that container located at the top of 
                        
                           s
                           (
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                           )
                        
                     . In this regard, the optimal solutions for the Unrestricted BRP require the same or less relocation movements than the optimal solutions for the Restricted BRP. In practice, terminal managers prefer decision-making systems aimed at solving the Unrestricted BRP because of its greater reduction in the number of unproductive container operations [3].

This work considers the following assumptions for the complete definition of the BRP:
                        
                           i.
                           The problem is limited to only one container bay. Inter-bay operations are usually discarded in practice because they require additional transportation modes and, therefore, are highly time-consuming. Nevertheless, the BRP addressed in this work could be easily adapted to storage environments with more dimensions. For example, a block with B bays composed of S stacks and T tiers each one. This case can be tackled in a similar way as a single bay with 
                                 
                                    B
                                    ×
                                    S
                                 
                               stacks and T tiers.

The containers have similar dimensions. This eases their management inasmuch as guarantees the stability of the stacks as well as allows to minimize the potential risks for the handling equipment.

All the container priorities are known in advance.

The gantry crane used in the retrieval process must provide the containers as soon as possible in such a way that relocation operations are only performed whenever the next container to retrieve, 
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              , is not accessible from the top of some stack.

Marshalling operations are discarded before the starting of the retrieval process.

New arriving containers are not considered during the retrieval process.

Notwithstanding the BRP is focused from the context of maritime container terminals along the present paper, it is applicable to a large variety of practical storage scenarios in which blocks with the same dimensions must be retrieved according to a prescribed order. Some additional examples of applicability can be found in the storage of pallets or boxes in warehouses.

@&#LITERATURE REVIEW@&#

Over the last years, the logistical problems at container terminals have obtained a great deal of attention within the scientific literature. The main reasons are their huge impact on the container terminal competitiveness and the undoubted importance for the economy of the regions where they are located. Some general overviews of the main logistic processes in this field are provided in the works of Vis and de Koster [30], Steenken et al. [27] and Stahlbock and Voβ 
                     [26].

A point of special interest in the literature has been the solution of logistical problems at container yards. Multitude of works have focused on addressing some topics for their suitable management. For instance, Ng and Mak [18] discuss how to deploy the available yard cranes at the terminal in order to perform the loading and unloading operations associated with the container blocks. Boysen and Fliedner [1] study the yard distribution among the handling equipment to balance their workloads, whereas Petering [20] simulates the impact of block dimensions and storage yard layout on the overall performance of the terminal.

A highlighted position within the literature is dedicated to the works concerning the container relocation problems. A thorough review of the most outstanding works is provided by Caserta et al. [3]. The Container Stacking pursues to define the stacking policies aimed at locating the incoming containers in the blocks in such a way that they are quickly accessible when they are requested [8]. Furthermore, the Pre-Marshalling Problem defines the relocation movements to be applied on the containers found into a given bay so that they can be later retrieved without any additional relocation movement. The interested reader is referred to the works by Lee and Hsu [16] and Expósito-Izquierdo et al. [10] for a complete analysis of this latter problem.

Kim and Hong [14] propose two optimization methods to be applied when a container pickup sequence is given. The work discusses how to determine the slots in which relocated containers must be placed in order to minimize the number of future relocation movements. A Branch and Bound (B&B) with a lower bound based upon the number of containers placed above another one with a higher priority is analysed to determine the optimal solutions. In addition, in order to overcome the high computational time required by the B&B, the number of expected future container relocation movements are determined as a heuristic rule. The experimental results show that the average number of container relocation movements found by the heuristic rule is close to those provided by the B&B at the expense of shorter computational burden.

Caserta et al. [5] present a recursive formulation and a dynamic programming algorithm for the Restricted BRP which is based on determining the states reachable from a given bay by implementing each feasible relocation movement. In order to overcome the exponential growth of the number of states generated through the dynamic programming algorithm and reduce the size of the search space a Corridor Method is proposed. Several corridors are defined in order to limit the stacks where containers can be relocated. The possible target stacks are defined according to their height and distance from the source stack. Some computational tests are carried out with the aim of comparing the performance of the Corridor Method with respect to the B&B developed by Kim and Hong [14]. The results indicate that the proposed method is suitable when solving a wide range of scenarios.

Caserta et al. [2] propose a smart binary encoding for the BRP which allows to develop optimization methods without having in-depth knowledge concerning the current problem features. This representation provides a fast access to relevant information of the stacking area such as which slots are filled or which containers are accessible from the top of some stack. In addition, it allows to easily define which stacking configurations are reachable at each step by means of exactly one relocation movement. An algorithm is developed on the basis of the pilot metaheuristic, in which simple heuristics are included in order to compute the suitability of neighbour stacking configurations. The computational results indicate that this approach overcomes previous optimization techniques from the related literature.

Zhang et al. [32] study how to apply A∗ algorithms to solve the Restricted BRP. Several lower bounds based on the minimum number of relocation movements required to retrieve the containers are analysed in order to be applied jointly. The excessive computational times required by these approaches give rise to develop heuristic methods which provide near-optimal solutions through reasonable computing times.

Lee and Lee [17] present a heuristic method composed of three general stages executed one after the other to retrieve the containers from a bay and move them toward a vessel. The objective function of the problem is extended with the working time of the handling equipment. The first stage defines an initial solution for the problem by means of a greedy strategy, where those containers that are placed above the next one in the prescribed retrieval sequence are relocated to the nearest available stack. The second stage attempts to reduce the number of movements required by the initial solution while its feasibility is kept. A mathematical formulation is proposed for this objective. Finally, the last stage is aimed at reducing the working time of the crane used to retrieve the containers from the bay by means of another mathematical model.

Forster and Bortfeldt [11] provide a general classification concerning all the feasible container relocation movements to be performed on a given incumbent bay configuration. This classification is based upon the relative positions of the containers to the extend that they produce future relocation movements. According to the classification a tree search procedure is developed which determines the most promising movements to perform at each step. Its behaviour is based on determining compound movements dedicated to improve an initial sequence obtained by means of a greedy approach. On the other hand, a lower bound of the minimum number of relocation movements required to retrieve all the containers from the bay is considered to prune some branches of the tree. The performance of the search procedure is compared with the most competitive algorithms from the literature. The results of the experiments allow to draw meaningful conclusions regarding its high effectiveness when solving real-world instances.

Casey and Kozan [6] address an extension of the BRP in a storage area of the container yard where incoming and outgoing containers are arranged by a straddle carrier. Its optimization goal is to minimize the number of relocation movements as well as the working time required by the crane. A mathematical formulation is proposed to model the problem, where a set of constraints is developed with the aim of providing a suitable position for the incoming containers in such a way that the retrieval operations can be performed efficiently. Several simple constructive heuristics aimed at producing high-quality solutions are tested over a large variety of working environments. In addition, three nature-inspired metaheuristics are studied for improving the initial solutions reported by the heuristics. Unfortunately, the computational results show only a slight improvement in the working time of the crane, whereas the metaheuristics are virtually unable to reduce the number of relocation movements.

Caserta et al. [4] present a complete study on the BRP. Firstly, the authors analyze its computational complexity in terms of number of steps required to solve it, proving that it belongs to the set of decision problems of class 
                        
                           NP
                        
                     -hard. In order to model the problem, they develop two binary linear programming formulations for the restricted and unrestricted versions, respectively. The applicability of these models is certainly limited due to the large number of binary variables involved, which give rise to high computational burdens. In addition, the optimality of the obtained results provided by one of these models is not guaranteed in all the cases such as it is discussed in Section 4. The drawbacks of the proposed models are overcome by means of a simple heuristic for the Restricted BRP that, through an evaluation rule concerning the attractiveness of the stacks, determines the target slots where containers must be relocated whenever they are avoiding the retrieval of the next container in the given retrieval sequence. The computational experiments show the reasonable effectiveness and high efficiency of the heuristic algorithm.

In contrast to the most of the aforementioned works, for instance those by Zhang et al. [32] and Caserta et al. [4], this paper introduces a heuristic algorithm aimed at solving the Unrestricted BRP considering the minimization of the number of relocation operations. A different objective is addressed by Casey and Kozan [6]. This means that, as done by Forster and Bortfeldt [11], the solutions reported are out of the scope of the remaining proposals.

Up to now and as far as the authors of the present paper know, only two mathematical formulations have been published in the literature for solving the Blocks Relocation Problem (BRP) (see Caserta et al. [4]). The first formulation referred to as BRP-I is aimed at modelling the Unrestricted BRP. Unfortunately, as pointed out by its authors, it requires an excessive number of binary variables and an upper bound which might make it impractical for medium size contexts. On the other hand, the second formulation referred to as BRP-II and proposed for the Restricted BRP, constitutes a great improvement at decreasing the computational time needed by the previous model due to the particular features of the feasible solutions for this version of the problem.

In spite of the computational time reduction provided by BRP-II, some reported results by Caserta et al. [4] are clearly inconsistent with the principle of optimality and, consequently, a comprehensive review is advised. In order to illustrate this fact, consider the example depicted in Fig. 2
                     , where it is presented a bay with 8 stacks, 5 tiers, 24 containers and for which all the containers have to be retrieved by following the decreasing order of priorities. According to the results provided by Caserta et al. [4], an optimum solution for this example is composed of 11 container relocation movements. However, it can be checked that the following is a feasible solution for the instance at hand: ((
                        
                           7
                           ,
                           6
                        
                     ), (
                        
                           7
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           6
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           7
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           1
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     ), (
                        
                           0
                           ,
                           4
                        
                     ), (
                        
                           0
                           ,
                           -
                        
                     ), (
                        
                           7
                           ,
                           5
                        
                     ), (
                        
                           7
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           7
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           6
                           ,
                           7
                        
                     ), (
                        
                           6
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           0
                           ,
                           -
                        
                     ), (
                        
                           7
                           ,
                           -
                        
                     ), (
                        
                           5
                           ,
                           4
                        
                     ), (
                        
                           5
                           ,
                           -
                        
                     ), (
                        
                           6
                           ,
                           -
                        
                     ), (
                        
                           2
                           ,
                           7
                        
                     ), (
                        
                           2
                           ,
                           -
                        
                     ), (
                        
                           7
                           ,
                           -
                        
                     ), (
                        
                           7
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     ), (
                        
                           1
                           ,
                           -
                        
                     ), (
                        
                           3
                           ,
                           -
                        
                     ), (
                        
                           4
                           ,
                           -
                        
                     )). In this case, only 9 relocation movements are needed to retrieve all the containers. Several additional examples can be found in the original paper for which the optimality of the reported results is not tested properly.

The rest of this section is aimed at analysing two exact algorithms designed on the basis of the well-known A∗ search framework for the different versions of BRP introduced in this work. In spite of the high computational times that they require when solving medium size instances, they can be used as benchmark algorithms for comparability purposes with approximate solution approaches such as that introduced in Section 5.

The A∗ search algorithm is an exact optimization technique which has demonstrated good performance when solving combinatorial optimization problems, especially at searching paths in graphs [9]. It builds a tree composed of nodes that represent the partial solutions for the problem to be solved. The expansion of nodes within the structure of the A∗ search algorithm is based on the evaluation of a scoring function 
                        
                           f
                           (
                           n
                           )
                        
                      for each node n in the tree. The exploration of nodes is carried out according to the best-first strategy, in such a way that, those nodes with the lowest scoring function value are firstly explored. The scoring function is defined as 
                        
                           f
                           (
                           n
                           )
                           =
                           g
                           (
                           n
                           )
                           +
                           h
                           (
                           n
                           )
                        
                     , where 
                        
                           g
                           (
                           n
                           )
                        
                      is a path-scoring function, which determines the cost of going from the root node toward the current node n, whereas 
                        
                           h
                           (
                           n
                           )
                        
                      is a heuristic function that estimates the cost remaining for achieving a goal node of the tree from the node n. The implicit knowledge stemming from the problem at hand is modelled by the scoring function, which guides the search toward the objectives. It should be noted that, in the case of the BRP, at least the non-located containers must be relocated into the bay.

In this work, each new node of the tree is generated by means of one feasible relocation movement, whereas the retrieval movements are performed without generating additional nodes. The path-scoring function 
                        
                           g
                           (
                           n
                           )
                        
                      is defined through the partial evaluation of the objective function, that is, the number of relocation movements performed to achieve the bay configuration represented by the node n. Furthermore, the heuristic function 
                        
                           h
                           (
                           n
                           )
                        
                      estimates the minimum number of relocation movements to perform the retrieval operations for all the remaining containers from the bay configuration represented by the node n. It is worth mentioning that in this work the estimated cost stated by 
                        
                           h
                           (
                           n
                           )
                        
                      and used to achieve a goal node of the tree is always lower or equal to its real cost due to the fact that, as seen below, 
                        
                           h
                           (
                           n
                           )
                        
                      is calculated on the basis of a set of lower bounds for the node n. This means that 
                        
                           h
                           (
                           ·
                           )
                        
                      is an admissible heuristic function. According to the principle of computational optimality of the A∗ search, the shortest path toward a goal node is always found and, therefore, the optimal solution for the BRP is reported. An exhaustive analysis on the optimality properties of the A∗ search is provided by Dechter and Pearl [7].

The value of the admissible heuristic function 
                           
                              h
                              (
                              ·
                              )
                           
                         used by the A∗ search algorithm aimed at solving the Unrestricted BRP is based upon the total number of non-located containers into the bay, defined by Eq. (3). That is,
                           
                              (5)
                              
                                 h
                                 (
                                 n
                                 )
                                 =
                                 |
                                 Ω
                                 |
                                 .
                              
                           
                        
                     

The number of non-located containers is a lower bound for the minimum number of relocation movements due to the fact that each one has to be previously relocated to another stack with the aim of retrieving the container with higher priority placed below it. For example, in Fig. 1 the containers 10, 9, 13, 11, 16 and 7 have to be moved to different slots at least once. Therefore, the lower bound associated with this bay configuration is 6.

As introduced in Section 2, in the Restricted BRP only those containers placed on the next container to retrieve from the bay, 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                        , can be relocated. However, each one of these containers will become a non-located container if it is moved to a stack in which there is another container with a higher priority. This means that it is required to perform one relocation movement for each non-located container into the bay and at least one additional relocation movement for each container placed on 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         whenever it cannot be relocated in a different stack without becoming a non-located one. In this regard, every full stack s is not considered as target stack. The admissible heuristic function 
                           
                              h
                              (
                              ·
                              )
                           
                         used by the A∗ search algorithm aimed at solving the Restricted BRP is formally defined as follows:
                           
                              (6)
                              
                                 h
                                 (
                                 n
                                 )
                                 =
                                 |
                                 Ω
                                 |
                                 +
                                 
                                    
                                       
                                          
                                             
                                                
                                                   c
                                                   
                                                   |
                                                   
                                                   (
                                                   s
                                                   (
                                                   c
                                                   )
                                                   =
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                   )
                                                   
                                                   ∧
                                                   
                                                   (
                                                   t
                                                   (
                                                   c
                                                   )
                                                   >
                                                   t
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                   )
                                                   
                                                   ∧
                                                   
                                                   ∀
                                                   
                                                   0
                                                   ⩽
                                                   s
                                                   <
                                                   S
                                                   ,
                                                   s
                                                   
                                                   ≠
                                                   
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                   ,
                                                   (
                                                   (
                                                   ∃
                                                   
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   :
                                                   (
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   )
                                                   =
                                                   s
                                                   )
                                                   
                                                   ∧
                                                   
                                                   (
                                                   p
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   )
                                                   <
                                                   p
                                                   (
                                                   c
                                                   )
                                                   )
                                                   )
                                                   
                                                   ∨
                                                   
                                                   (
                                                   h
                                                   (
                                                   s
                                                   )
                                                   =
                                                   T
                                                   )
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        For instance, in the bay depicted in Fig. 1 the container 1 can be retrieved directly, whereas the containers 
                           
                              10
                              ,
                              9
                           
                         and 13 are placed on the container 2. It is straightforward to check that these containers will be placed above some container with a higher priority in their next slots. For example, the container 10 will be placed on the container 6 if it is moved to stack 0. Similar situations arise for the remaining stacks. In the example at hand, the minimum number of relocation movements required to retrieve all the containers from the bay when the container 2 is the next one to be retrieved is 9.

An upper bound is included into the A∗ algorithms in order to set a maximum length for the feasible paths in the underlying trees. The initial upper bound is determined according to the pseudocode depicted in Algorithm 1. In this case, the slot of the next container in the prescribed retrieval sequence, 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         (line 4), is checked in such a way that, if there are other containers placed above (line 6), they must be previously relocated to different stacks in the bay. The feasible target stacks are those different to 
                           
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         and with at least one empty slot. One of these feasible stacks is selected at random to relocate the corresponding containers (lines 7 and 8). The container 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         can be retrieved from the bay once placed at the top of its stack (line 10). In response to the retrieval order, the process is repeated for each container (line 3). Finally, with the purpose of providing a tighter upper bound, the method is embedded into a restarting strategy iterated for max times (lines 2–13), where max is a parameter whose value is selected by the user.
                           Algorithm 1
                           Method for calculating the upper bound of the A∗ search algorithm. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: Bay with the containers to retrieve
                                          
                                          
                                             
                                                Input: 
                                                max, number of iterations
                                          
                                          
                                             
                                                Output: Solution for the problem
                                          
                                          
                                             
                                                1: 
                                                   
                                                      BestSolution
                                                      
                                                      ←
                                                      
                                                      ∅
                                                   
                                                
                                             
                                          
                                          
                                             
                                                2: for 
                                                
                                                   
                                                      i
                                                      =
                                                      1
                                                      →
                                                      max
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                3: 
                                                for 
                                                
                                                   
                                                      p
                                                      =
                                                      1
                                                      →
                                                      k
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                4: 
                                                
                                                
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      
                                                      ←
                                                      
                                                   
                                                Find container with priority p
                                             
                                          
                                          
                                             
                                                5: 
                                                
                                                while ! (
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                                istopmost) do
                                             
                                          
                                          
                                             
                                                6: 
                                                
                                                
                                                
                                                   
                                                      c
                                                      
                                                      ←
                                                      
                                                   
                                                Container placed at the top of 
                                                   
                                                      s
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                7: 
                                                
                                                
                                                
                                                   
                                                      s
                                                      
                                                      ←
                                                      
                                                   
                                                Select feasible stack at random for c
                                             
                                          
                                          
                                             
                                                8: 
                                                
                                                Relocate container c from 
                                                   
                                                      s
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                   
                                                 to stack s
                                             
                                          
                                          
                                             
                                                9: 
                                                
                                                end while
                                             
                                          
                                          
                                             10:
                                                Retrieve 
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             11: 
                                                end for
                                             
                                          
                                          
                                             12: Update BestSolution
                                             
                                          
                                          
                                             13: end for
                                             
                                          
                                          
                                             14: return 
                                                BestSolution
                                             
                                          
                                       
                                    
                                 
                              
                           

This section is aimed at describing a heuristic algorithm based upon domain-specific knowledge of the BRP. According to the general classification of optimization techniques proposed by Nickerson [19], domain-specific algorithms exploit knowledge concerning the problem structure in order to achieve a suitable solution for the application environment at hand. For a thorough review of domain-specific algorithms the reader is referred to the book of Rothlauf [23]. The underlying rationale behind the proposed heuristic algorithm is to perform the largest number of retrieval operations, while the expected number of future relocation movements is minimized. Domain-specific knowledge about high-quality solutions for the BRP is used on the basis of a comprehensive analysis of promising container relocation movements at each step of the retrieval process with the aim of identifying the containers to move and their target slots. The structure of the BRP allows to estimate the impact of sequences of relocation movements on the objective function value in an analytical way and, therefore, determine the most attractive ones to apply. Similar domain-specific knowledge-based approaches have been proposed by Vazirani [28], Rothlauf [22] and Gutiérrez and García-Magariño [12].

The first phase in the development of the proposed heuristic algorithm is to carry out the knowledge acquisition in order to construct meaning from heterogeneous information sources [13]. With this goal in mind, a domain knowledge collection and knowledge transformation of data formats has been performed. The knowledge of the BRP has been built up from multiple terminal managers, technical reports, and papers. As indicated by Yan et al. [31], the acquisition of knowledge in this case is composed of three stages: collection, interpretation, and analysis.

The heuristic algorithm proposed in this work models the domain of the BRP by means of a state space structured as a tree [24]. Each state represents a feasible configuration of the bay. The initial state is the configuration given and the goal states are those configurations in which the requested containers have been retrieved from the bay. The knowledge used by the algorithm for generating successive states at lower levels in the tree is represented through the following set of rules:
                        
                           
                              Rule 1.
                           
                           If the container with the highest priority, 
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              , is placed at the top of some stack then retrieve it from the bay.

If the container with the highest priority, 
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              , is not placed at the top of some stack then relocate those containers placed above it in other slots in which they are well-located containers.

If the container with the highest priority, 
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              , is not placed at the top of some stack and Rule 2 is being applied then fill the empty slots of the stacks in which the containers placed above 
                              
                                 
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                 
                               
                              are going to be placed with non-located containers.

The heuristic algorithm uses the previous set of rules for exploring the state space efficiently. Starting from the initial state and for each state of the tree, Rule 1 is checked. If the container with the highest priority, 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                     , is placed at the top of some stack, a new state is expanded in which 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                      has been retrieved from the bay. It should be noted that, according to the optimization criterion for the BRP addressed in this work, using Rule 1 has not any impact on the objective function value. Moreover, whenever Rule 1 cannot be used over a given state, Rule 2 is applied. Rule 2 moves those containers placed above 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                      to other slots of the bay in such a way they are well-located containers. This means that they are not going to require additional relocation movements in the future. Finally, Rule 3 is aimed at exploiting the empty slots into the target stacks used during the application of Rule 2 of the containers currently placed above 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                      in order to reduce the number of non-located containers in the bay. Note that Rule 2 and Rule 3 are compound rules in which a sequence of relocation movements is performed. Both rules are broadly discussed in Sections 5.2 and 5.6, respectively. In contrast to Rule 1, applying Rule 2 and Rule 3 over a given state gives rise to an increase of one unit in the objective function value for each container moved.

Based on the aforementioned set of rules, the proposed heuristic algorithm pursues to identify at each step a well-defined subset of branches that allows to reach a new state in which 
                        
                           
                              
                                 c
                              
                              
                                 ∗
                              
                           
                        
                      has been retrieved from the bay and the number of future relocation movements is minimized. For this purpose, a heuristic evaluation is used to score the branches and guide the search for those parts of the tree in which high-quality solutions are expected to be found. It is worth pointing out that the optimality of the solutions reported by the heuristic algorithm is not guaranteed.

@&#OVERVIEW@&#

As indicated by Expósito-Izquierdo et al. [10], those scenarios in which containers with high priority are placed at low tiers in the bay are more likely to undermine the performance of the handling equipment during container retrieval operations. The main reason is that these containers limit the overall available space for relocating containers without increasing the number of future relocation movements. In this regard, the higher the priority of a container placed at a low tier, the higher the probability of producing new future relocation movements. See the paper of Kim and Hong [14] for an expression about the expected number of additional relocation movements required when a container is relocated. Based on the above, the heuristic algorithm proposed in the present work pursues to place the containers that need a relocation at the lowest tiers with the goal of minimizing the probability of requiring new relocation movements in the future.
                           Algorithm 2
                           Heuristic algorithm for the BRP. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: Bay with the containers to retrieve
                                          
                                          
                                             
                                                Input: 
                                                
                                                   
                                                      β
                                                   
                                                , maximum number of iterations without improvement
                                          
                                          
                                             
                                                Output: Solution for the problem
                                          
                                          
                                             
                                                1: 
                                                   
                                                      BestSolution
                                                      
                                                      ←
                                                      
                                                      ∅
                                                   
                                                
                                             
                                          
                                          
                                             
                                                2: 
                                                   
                                                      Non
                                                      -
                                                      improvement
                                                      
                                                      ←
                                                      
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                3: repeat
                                             
                                          
                                          
                                             
                                                4: 
                                                
                                                   
                                                      NewSolution
                                                      
                                                      ←
                                                      
                                                      ∅
                                                   
                                                
                                             
                                          
                                          
                                             
                                                5: 
                                                while ! (all containers are retrieved) do
                                             
                                          
                                          
                                             
                                                6:
                                                
                                                
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      
                                                      ←
                                                      
                                                   
                                                Find next container to retrieve
                                          
                                          
                                             
                                                7: 
                                                
                                                if 
                                                
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                 is topmost then
                                             
                                          
                                          
                                             
                                                8: 
                                                
                                                Retrieve 
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                 from the bay
                                          
                                          
                                             
                                                9: 
                                                
                                                else
                                             
                                          
                                          
                                             10: 
                                                
                                                
                                                
                                                   
                                                      O
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                      
                                                      ←
                                                      
                                                   
                                                Obtain the set of containers currently placed above 
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             11: 
                                                
                                                
                                                
                                                   
                                                      Ψ
                                                      (
                                                      O
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                      )
                                                      
                                                      ←
                                                      
                                                   
                                                Generate the set of container assignments for 
                                                   
                                                      O
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             12: 
                                                
                                                Evaluate the container assignments 
                                                   
                                                      Ψ
                                                      (
                                                      O
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             13: 
                                                
                                                
                                                
                                                   
                                                      ψ
                                                      
                                                      ←
                                                      
                                                   
                                                Select a container assignment from 
                                                   
                                                      Ψ
                                                      (
                                                      O
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             14: 
                                                
                                                Apply container assignment 
                                                   
                                                      ψ
                                                   
                                                
                                             
                                          
                                          
                                             15: 
                                                
                                                end if
                                             
                                          
                                          
                                             16: 
                                                end while
                                             
                                          
                                          
                                             17: 
                                                
                                                   
                                                      NewSolution
                                                      
                                                      ←
                                                      
                                                   
                                                Solution found
                                          
                                          
                                             18: 
                                                if (NewSolution is better than BestSolution) then
                                             
                                          
                                          
                                             19: 
                                                
                                                
                                                   
                                                      BestSolution
                                                      
                                                      ←
                                                      
                                                      NewSolution
                                                   
                                                
                                             
                                          
                                          
                                             20: 
                                                
                                                
                                                   
                                                      Non
                                                      -
                                                      improvement
                                                      
                                                      ←
                                                      
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             21: 
                                                else
                                             
                                          
                                          
                                             22: 
                                                
                                                
                                                   
                                                      Non
                                                      -
                                                      improvement
                                                      
                                                      ←
                                                      
                                                      Non
                                                      -
                                                      improvement
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             23: 
                                                end if
                                             
                                          
                                          
                                             24: until (
                                                   
                                                      Non
                                                      -
                                                      improvement
                                                      =
                                                      β
                                                   
                                                )
                                          
                                          
                                             25: return 
                                                BestSolution
                                             
                                          
                                       
                                    
                                 
                              
                           

The pseudocode of the proposed heuristic algorithm is depicted in Algorithm 2. It iterates over all the containers to retrieve from the bay, that is, the k containers with the highest priorities (line 5). In each case, the next container to retrieve is found, named 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         (line 6). According to the position of 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                        , two general scenarios can occur. The former is that in which 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         is accessible from the top of some stack (line 7). This scenario allows to remove 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         directly from the bay by applying Rule 1 (retrieval movement (
                           
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              ,
                              -
                           
                        ), line 8). On the other hand, if 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         is not placed at the top of some stack (line 9), the set of containers currently placed above it, 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                        , is obtained (line 10), where
                           
                              (7)
                              
                                 O
                                 (
                                 c
                                 )
                                 =
                                 {
                                 
                                    
                                       c
                                    
                                    
                                       ′
                                    
                                 
                                 
                                 |
                                 
                                 (
                                 s
                                 (
                                 
                                    
                                       c
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 =
                                 s
                                 (
                                 c
                                 )
                                 )
                                 
                                 ∧
                                 
                                 (
                                 t
                                 (
                                 
                                    
                                       c
                                    
                                    
                                       ′
                                    
                                 
                                 )
                                 >
                                 t
                                 (
                                 c
                                 )
                                 )
                                 }
                                 .
                              
                           
                        The heuristic algorithm determines the set of promising slots in which the containers included into 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         would become well-located ones by means of container assignments (line 11). The container assignments relate the containers belonging to 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         with their target slots. Note that each container assignment corresponds to a particular application of Rule 2. The set of container assignments associated with 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         is named 
                           
                              Ψ
                              (
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              )
                           
                        . A cost is associated with each container assignment (line 12). Afterwards, according to their costs, a selection procedure is used to choose a container assignment 
                           
                              ψ
                              ∈
                              Ψ
                              (
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              )
                           
                         (line 13). Finally, once the target slot of each container in 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         is defined, a moving procedure relocates each container to its corresponding target slot (line 14). These steps are individually explained in the following subsections. Since the non-deterministic nature of the heuristic algorithm proposed along this section, multitude of decisions arise in its structure that are subject to random procedures. This fact gives rise to obtain different solutions by means of independent executions. Therefore, a restarting strategy is used in order to provide a high diversification when exploring the search space. The search is finished when at least 
                           
                              β
                           
                         successive iterations of the process have not obtained any improvement on the best objective function value found (line 24). The value of the parameter 
                           
                              β
                           
                         is set by the user.

According to Algorithm 2, when 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         is going to be retrieved those containers placed above it, 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                        , have to be previously relocated on the basis of the LIFO policy. That is, Rule 2 must be applied. One possible way to minimize future relocation movements is to place them in those slots in which they become well-located ones. The target slot of each container 
                           
                              c
                              ∈
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         is defined by the pair 
                           
                              (
                              
                                 
                                    s
                                 
                                 
                                    ¯
                                 
                              
                              (
                              c
                              )
                              ,
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              c
                              )
                              )
                           
                        .

Given the set of containers 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                        , obtaining the container assignments associated with 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         means to enumerate all the feasible slots in which these containers become well-located ones. Fig. 3
                         presents 3 container assignments obtained when 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              =
                              2
                           
                         in the example depicted in Fig. 1. Note that the container 1 has been previously retrieved. In order to ease its suitable understanding, the target slot of each container 
                           
                              c
                              ∈
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         and information concerning the evaluation of container assignments are reported. In this case, the set of containers 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              =
                              O
                              (
                              2
                              )
                              =
                              {
                              10
                              ,
                              9
                              ,
                              13
                              }
                           
                         has to be moved to different slots. Let 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                         be the subset of containers in 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         with target stack s, defined as follows:
                           
                              (8)
                              
                                 O
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             ∗
                                          
                                       
                                       )
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 {
                                 c
                                 
                                 |
                                 
                                 (
                                 c
                                 ∈
                                 O
                                 (
                                 
                                    
                                       c
                                    
                                    
                                       ∗
                                    
                                 
                                 )
                                 )
                                 
                                 ∧
                                 
                                 (
                                 
                                    
                                       s
                                    
                                    
                                       ¯
                                    
                                 
                                 (
                                 c
                                 )
                                 =
                                 s
                                 )
                                 }
                                 .
                              
                           
                        In the first container assignment, all the containers included into 
                           
                              O
                              (
                              2
                              )
                           
                         are going to be moved toward the stack 0. As can be seen, their final positions into this stack are set according to their increasing priority order. The container 13 is placed at the lowest tier, slot 
                           
                              (
                              0
                              ,
                              0
                              )
                           
                        , then the container 10 is placed in slot 
                           
                              (
                              0
                              ,
                              1
                              )
                           
                         and later the container 9 is placed in slot 
                           
                              (
                              0
                              ,
                              2
                              )
                           
                        . In the second container assignment all the containers included into 
                           
                              O
                              (
                              2
                              )
                           
                         are going to be moved toward different stacks. That is, the container 13 is placed in slot 
                           
                              (
                              1
                              ,
                              0
                              )
                           
                        , the container 9 is placed in slot 
                           
                              (
                              4
                              ,
                              0
                              )
                           
                         and the container 10 is placed in slot 
                           
                              (
                              5
                              ,
                              1
                              )
                           
                        . Finally, the third container assignment represents the scenario in which the target slots of the containers in 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         are located in 
                           
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                        .


                        
                           Algorithm 3
                           Procedure to evaluate a container assignment. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: Container assignment to evaluate
                                          
                                          
                                             
                                                Output: Evaluation of the container assignment
                                          
                                          
                                             
                                                1: 
                                                   
                                                      moves
                                                      
                                                      ←
                                                      
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                2: for 
                                                
                                                   
                                                      s
                                                      
                                                      
                                                      ←
                                                      
                                                      
                                                      0
                                                   
                                                
                                                to
                                                
                                                   
                                                      S
                                                      -
                                                      1
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                3: 
                                                if 
                                                
                                                   
                                                      O
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                      
                                                      ≠
                                                      
                                                      ∅
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                4: 
                                                
                                                
                                                   
                                                      r
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                5: 
                                                
                                                
                                                   
                                                      u
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                6: 
                                                
                                                if 
                                                
                                                   
                                                      s
                                                      
                                                      ≠
                                                      
                                                      s
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             
                                                7: 
                                                
                                                
                                                
                                                   
                                                      r
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      h
                                                      (
                                                      s
                                                      )
                                                      -
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            min
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                8: 
                                                
                                                
                                                for 
                                                
                                                   
                                                      c
                                                      ∈
                                                      O
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             
                                                9: 
                                                
                                                
                                                
                                                if 
                                                
                                                   
                                                      ∃
                                                      
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      ∈
                                                      O
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                      
                                                      |
                                                      
                                                      (
                                                      p
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      )
                                                      >
                                                      p
                                                      (
                                                      c
                                                      )
                                                      )
                                                      
                                                      ∧
                                                      
                                                      (
                                                      t
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ′
                                                         
                                                      
                                                      )
                                                      <
                                                      t
                                                      (
                                                      c
                                                      )
                                                      )
                                                   
                                                 
                                                then
                                             
                                          
                                          
                                             10: 
                                                
                                                
                                                
                                                
                                                
                                                   
                                                      u
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      u
                                                      (
                                                      s
                                                      )
                                                      +
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             11: 
                                                
                                                
                                                
                                                end if
                                             
                                          
                                          
                                             12: 
                                                
                                                
                                                end for
                                             
                                          
                                          
                                             13: 
                                                
                                                else
                                             
                                          
                                          
                                             14: 
                                                
                                                
                                                
                                                   
                                                      r
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      t
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                      -
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            min
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             15: 
                                                
                                                
                                                
                                                   
                                                      u
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      |
                                                      O
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                      |
                                                   
                                                
                                             
                                          
                                          
                                             16: 
                                                
                                                end if
                                             
                                          
                                          
                                             17: 
                                                
                                                
                                                   
                                                      moves
                                                      (
                                                      s
                                                      )
                                                      
                                                      ←
                                                      
                                                      r
                                                      (
                                                      s
                                                      )
                                                      +
                                                      u
                                                      (
                                                      s
                                                      )
                                                      +
                                                      |
                                                      O
                                                      
                                                         
                                                            (
                                                            
                                                               
                                                                  c
                                                               
                                                               
                                                                  ∗
                                                               
                                                            
                                                            )
                                                         
                                                         
                                                            s
                                                         
                                                      
                                                      |
                                                   
                                                
                                             
                                          
                                          
                                             18: 
                                                
                                                
                                                   
                                                      moves
                                                      
                                                      ←
                                                      
                                                      moves
                                                      +
                                                      moves
                                                      (
                                                      s
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             19: 
                                                end if
                                             
                                          
                                          
                                             
                                                20: end for
                                             
                                          
                                          
                                             21: return 
                                                moves
                                             
                                          
                                       
                                    
                                 
                              
                           

Given a container assignment, its attractiveness degree is evaluated on the basis of the minimum number of relocation movements required to place the incumbent containers (
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                        ) in their target slots. The pseudocode of the evaluation process is depicted in Algorithm 3. The minimum number of relocation movements required to apply a given container assignment, named moves (line 1), is calculated as the sum of the minimum number of relocation movements associated with each stack 
                           
                              s
                              ,
                              
                              moves
                              (
                              s
                              )
                           
                         (line 17), where
                           
                              (9)
                              
                                 moves
                                 (
                                 s
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   r
                                                   (
                                                   s
                                                   )
                                                   +
                                                   u
                                                   (
                                                   s
                                                   )
                                                   +
                                                   |
                                                   O
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   |
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   O
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   
                                                   ≠
                                                   
                                                   ∅
                                                
                                             
                                             
                                                
                                                   0
                                                   ,
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        It is broken down into the number of containers to remove from 
                           
                              s
                              ,
                              
                              r
                              (
                              s
                              )
                           
                        , the number of intermediate relocation movements to perform on the containers included into 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                              ,
                              
                              u
                              (
                              s
                              )
                           
                        , and the number of relocation movement aimed at moving the containers in 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                         toward their target slots. It is worth pointing out that, for each stack s that is not target of any container, the number of relocation movements is 
                           
                              moves
                              (
                              s
                              )
                              =
                              0
                           
                        .

The number of containers to remove from the target stack s is determined by the container with minimum priority in 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                        . Let 
                           
                              
                                 
                                    min
                                 
                                 
                                    s
                                 
                              
                           
                         be this container. That is,
                           
                              (10)
                              
                                 
                                    
                                       min
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 arg
                                 
                                 max
                                 {
                                 p
                                 (
                                 c
                                 )
                                 :
                                 c
                                 ∈
                                 O
                                 
                                    
                                       (
                                       
                                          
                                             c
                                          
                                          
                                             ∗
                                          
                                       
                                       )
                                    
                                    
                                       s
                                    
                                 
                                 }
                                 .
                              
                           
                        
                     

Therefore, 
                           
                              r
                              (
                              s
                              )
                           
                         is calculated as follows:
                           
                              (11)
                              
                                 r
                                 (
                                 s
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   h
                                                   (
                                                   s
                                                   )
                                                   -
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   )
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   s
                                                   
                                                   ≠
                                                   
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                
                                                   t
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                   -
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         min
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   )
                                                   ,
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The first scenario is that in which 
                           
                              s
                              
                              ≠
                              
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         (line 6). The number of containers to remove from s is determined through the number of containers currently placed in it, 
                           
                              h
                              (
                              s
                              )
                           
                        , and the lowest target tier in which some container from 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                         must be relocated, 
                           
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    min
                                 
                                 
                                    s
                                 
                              
                              )
                           
                         (line 7). Following the first container assignment of the example depicted in Fig. 3, the number of containers to remove from the target stack 0 is 
                           
                              r
                              (
                              0
                              )
                              =
                              h
                              (
                              0
                              )
                              -
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              13
                              )
                              =
                              2
                              -
                              0
                              =
                              2
                           
                        . Moreover, the scenario in which the target stack is the same as that in which 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         is currently placed, 
                           
                              s
                              =
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         (line 13), requires to remove all the containers located between 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         and the target tier of 
                           
                              
                                 
                                    min
                                 
                                 
                                    s
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                              
                              ,
                              
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    min
                                 
                                 
                                    s
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                              
                              )
                           
                        . In this case, the number of containers to remove from 
                           
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         is 
                           
                              r
                              (
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              )
                              =
                              t
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              -
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    min
                                 
                                 
                                    s
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                              
                              )
                           
                         (line 14). In the third container assignment depicted in Fig. 3 the target slot of the container 13 is the same as that in which 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         is currently placed. Therefore, there are not containers to remove from the stack 2, that is, 
                           
                              r
                              (
                              2
                              )
                              =
                              0
                              -
                              0
                              =
                              0
                           
                        .

On the other hand, the containers included into 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                         should be ideally placed according to the decreasing priority order above 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                        , in such a way that, the container 
                           
                              
                                 
                                    min
                                 
                                 
                                    s
                                 
                              
                           
                         is placed at the highest tier among the containers in 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                        . In that way, only one relocation movement per container is required in order to relocate the containers to their target slots. Otherwise, one additional relocation movement is required for each container belonging to 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                         that is not placed according to the decreasing priority order (lines 9 and 10). The reason is that each one must be firstly relocated to some intermediate stack before being at last moved toward its target slot. Therefore, for each stack 
                           
                              s
                              ,
                              u
                              (
                              s
                              )
                           
                         is defined as follows:
                           
                              (12)
                              
                                 u
                                 (
                                 s
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   |
                                                   {
                                                   c
                                                   ∈
                                                   O
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   
                                                   |
                                                   
                                                   ∃
                                                   
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   ∈
                                                   O
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   :
                                                   (
                                                   p
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   )
                                                   >
                                                   p
                                                   (
                                                   c
                                                   )
                                                   )
                                                   
                                                   ∧
                                                   
                                                   (
                                                   t
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ′
                                                      
                                                   
                                                   )
                                                   <
                                                   t
                                                   (
                                                   c
                                                   )
                                                   )
                                                   }
                                                   |
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   s
                                                   
                                                   ≠
                                                   
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                
                                             
                                             
                                                
                                                   |
                                                   O
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   |
                                                   ,
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        For example, in the first container assignment presented in Fig. 3, the containers 10 and 9 have to be moved to intermediate stacks before relocating the container 13 to its target slot 
                           
                              (
                              0
                              ,
                              0
                              )
                           
                        . A special case is that in which the target stack is the same as that in which 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         is currently placed, 
                           
                              s
                              =
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         (line 13). In this case, each container belonging to 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                              
                           
                         must be firstly moved to some intermediate stack and then placed in its target slot. Therefore, at least 
                           
                              |
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                              
                              |
                           
                         relocation movements are required (line 15). In the third container assignment in Fig. 3, the containers 10, 9 and 13 have to be moved to intermediate stacks before being moved to their target slots in the stack 2.

As analysed in Section 5.5, unless retrieval operations are performed, the proposed evaluation strategy never overestimates the minimum number of relocation movements required to relocate the containers placed above 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         in their target slots due to its optimistic point of view. It is assumed that there are sufficient empty slots where those containers to be removed from the target stacks and those to be relocated as an intermediate step in their relocation process do not avoid the relocation of any other container.

The selection strategy of the heuristic algorithm pursues to choose a promising container assignment, 
                           
                              ψ
                              ∈
                              Ψ
                              (
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                              )
                           
                        , that requires the minimum number of relocation movements as possible to be applied on the current bay configuration. At the same time, the selection strategy must allow to keep certain level of randomness in order to achieve a compromise between intensification and diversification during the search. With this goal in mind, at each step, at most 
                           
                              δ
                           
                         container assignments are generated and, afterwards, one of the 
                           
                              α
                           
                         container assignments with the lowest estimation is selected at random. The values of 
                           
                              δ
                           
                         and 
                           
                              α
                           
                         are set by the user.

The pseudocode of the relocation strategy aimed at applying the container assignment 
                           
                              ψ
                           
                         on the current bay configuration is depicted in Algorithm 4. It pursues to move each container 
                           
                              c
                              ∈
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         toward its target slot 
                           
                              (
                              
                                 
                                    s
                                 
                                 
                                    ¯
                                 
                              
                              (
                              c
                              )
                              ,
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              c
                              )
                              )
                           
                         through the minimum number of relocation movements. It is based on a loop that iterates while there is at least one container belonging to 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         that is not placed in its target slot (line 1). At each step, one container, 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                           
                        , is selected with the goal of being relocated (line 2). The relocation of 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                           
                         is performed by emptying its target slot, 
                           
                              (
                              
                                 
                                    s
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              )
                              ,
                              
                                 
                                    t
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              )
                              )
                           
                         (line 3), and relocating those containers currently placed above it (line 4). Finally, the relocation movement 
                           
                              (
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              )
                              ,
                              
                                 
                                    s
                                 
                                 
                                    ¯
                                 
                              
                              (
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              )
                              )
                           
                         is performed (line 5).
                           Algorithm 4
                           Procedure to apply a container assignment. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input: 
                                                
                                                   
                                                      ψ
                                                   
                                                , Container assignment to apply
                                          
                                          
                                             1: while 
                                                
                                                   
                                                      ∃
                                                      
                                                      c
                                                      ∈
                                                      O
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            ∗
                                                         
                                                      
                                                      )
                                                      
                                                      |
                                                      
                                                      (
                                                      s
                                                      (
                                                      c
                                                      )
                                                      ,
                                                      t
                                                      (
                                                      c
                                                      )
                                                      )
                                                      
                                                      ≠
                                                      
                                                      (
                                                      
                                                         
                                                            s
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      c
                                                      )
                                                      ,
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      c
                                                      )
                                                      )
                                                   
                                                 
                                                do
                                             
                                          
                                          
                                             2: 
                                                
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      
                                                      ←
                                                      
                                                   
                                                Select next container to relocate
                                          
                                          
                                             3: Empty the target slot of 
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      ,
                                                      (
                                                      
                                                         
                                                            s
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      )
                                                      ,
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             4: Relocate the containers placed above 
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             5: Move 
                                                   
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                   
                                                 from 
                                                   
                                                      s
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      )
                                                   
                                                 to its target slot, 
                                                   
                                                      (
                                                      
                                                         
                                                            s
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      )
                                                      ,
                                                      
                                                         
                                                            t
                                                         
                                                         
                                                            ¯
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            c
                                                         
                                                         
                                                            +
                                                         
                                                      
                                                      )
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             6: end while
                                             
                                          
                                       
                                    
                                 
                              
                           

According to Algorithm 4, the first step is to select the container 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              ∈
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         that is going to be relocated to its target slot. All the candidate containers to be relocated to their target slots are defined by the set 
                           
                              Θ
                           
                        , where
                           
                              (13)
                              
                                 Θ
                                 =
                                 {
                                 
                                    
                                       min
                                    
                                    
                                       s
                                    
                                 
                                 :
                                 0
                                 ⩽
                                 s
                                 <
                                 S
                                 }
                                 .
                              
                           
                        The container 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                           
                         is that included into 
                           
                              Θ
                           
                         with the minimum number of containers placed above it. That is,
                           
                              (14)
                              
                                 
                                    
                                       c
                                    
                                    
                                       +
                                    
                                 
                                 =
                                 
                                    
                                       
                                          arg
                                          
                                          min
                                       
                                       
                                          c
                                          ∈
                                          Θ
                                       
                                    
                                 
                                 {
                                 |
                                 O
                                 (
                                 c
                                 )
                                 |
                                 }
                                 .
                              
                           
                        This strategy allows to select those containers to relocate more easily at first. A similar idea is discussed by Expósito-Izquierdo et al. [10] for the Pre-Marshalling Problem.

Another relevant issue about the relocation process is how to determine the most appropriate slot to relocate those containers to remove from the target stacks and those placed above 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                           
                        . For each container c to move, an estimation of the suitability degree about the feasible stacks to use as target is computed. In this regard, any stack s different to 
                           
                              s
                              (
                              c
                              )
                           
                         could store c whenever it has at least one empty slot. In addition, 
                           
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         and 
                           
                              s
                              (
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              )
                           
                         are not considered in the evaluation process because these stacks are being cleared in order to retrieve 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                         and relocate the involved containers, respectively. Casey and Kozan [6] propose a set of simple rules for this purpose. However, in the present work the suitability of the stack s is evaluated through the following scoring function:
                           
                              (15)
                              
                                 f
                                 (
                                 s
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   (
                                                   s
                                                   =
                                                   s
                                                   (
                                                   c
                                                   )
                                                   )
                                                   
                                                   ∨
                                                   
                                                   (
                                                   s
                                                   =
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                   )
                                                   
                                                   ∨
                                                   
                                                   (
                                                   s
                                                   =
                                                   s
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         +
                                                      
                                                   
                                                   )
                                                   )
                                                   
                                                   ∨
                                                   
                                                   (
                                                   h
                                                   (
                                                   s
                                                   )
                                                   =
                                                   T
                                                   )
                                                
                                             
                                             
                                                
                                                   k
                                                   +
                                                   1
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   h
                                                   (
                                                   s
                                                   )
                                                   =
                                                   0
                                                
                                             
                                             
                                                
                                                   max
                                                   (
                                                   s
                                                   )
                                                   ,
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Once the suitability degree of each stack is evaluated, one of them is selected by the roulette wheel mechanism. In this case, the probability of selecting the stack 
                           
                              s
                              ,
                              
                              prob
                              (
                              s
                              )
                           
                        , is proportional to its relative value of 
                           
                              f
                              (
                              s
                              )
                           
                        , that is,
                           
                              (16)
                              
                                 prob
                                 (
                                 s
                                 )
                                 =
                                 
                                    
                                       f
                                       (
                                       s
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             s
                                             =
                                             0
                                          
                                          
                                             S
                                             -
                                             1
                                          
                                       
                                       f
                                       (
                                       s
                                       )
                                    
                                 
                                 .
                              
                           
                        
                     

In order to illustrate the relocation strategy, assume the first container assignment presented in Fig. 3 is going to be applied. The target slots of the containers 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         are depicted in Fig. 4
                        a. In this case, only the stack 0 is used as target of 
                           
                              O
                              (
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         and, therefore, 
                           
                              O
                              
                                 
                                    (
                                    2
                                    )
                                 
                                 
                                    0
                                 
                              
                              =
                              {
                              10
                              ,
                              9
                              ,
                              13
                              }
                           
                         and 
                           
                              Θ
                              =
                              {
                              13
                              }
                           
                        . The first container to relocate to its target slot is 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                              =
                              13
                           
                        . According to Algorithm 4 (lines 3 and 4), the containers 
                           
                              6
                              ,
                              12
                              ,
                              10
                           
                         and 9 must be sequentially moved to different stacks in the bay with the aim of emptying the target slot 
                           
                              (
                              0
                              ,
                              0
                              )
                           
                         and accessing to the container 13. Fig. 4b–e shows the relocation of these containers. In each case, the suitability degree of the feasible stacks, 
                           
                              f
                              (
                              ·
                              )
                           
                        , is reported. Afterwards, one of the stacks is selected by means of the roulette wheel mechanism. Fig. 4f presents the scenario in which the slot 
                           
                              (
                              0
                              ,
                              0
                              )
                           
                         is empty and the container 13 is accessible from the top of stack 2. This allows to move the container 13 toward its target slot and retrieve the container 2 from the bay. Finally, the containers 10 and 9 are sequentially moved toward their target slots.

Usually, the target stacks used in the relocation process are not full and, therefore, their remaining empty slots could be exploited in order to store non-located containers with low priority. Note that this process is the application of Rule 3.

For each stack s, let 
                           
                              
                                 
                                    h
                                 
                                 
                                    ˆ
                                 
                              
                              (
                              s
                              )
                           
                         denote the number of containers that will be placed in s after the relocation process finishes. That is,
                           
                              (17)
                              
                                 
                                    
                                       h
                                    
                                    
                                       ˆ
                                    
                                 
                                 (
                                 s
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            max
                                                         
                                                         
                                                            c
                                                            ∈
                                                            O
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        c
                                                                     
                                                                     
                                                                        ∗
                                                                     
                                                                  
                                                                  )
                                                               
                                                               
                                                                  s
                                                               
                                                            
                                                         
                                                      
                                                   
                                                   {
                                                   
                                                      
                                                         t
                                                      
                                                      
                                                         ¯
                                                      
                                                   
                                                   (
                                                   c
                                                   )
                                                   }
                                                   +
                                                   1
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   O
                                                   
                                                      
                                                         (
                                                         
                                                            
                                                               c
                                                            
                                                            
                                                               ∗
                                                            
                                                         
                                                         )
                                                      
                                                      
                                                         s
                                                      
                                                   
                                                   
                                                   ≠
                                                   
                                                   ∅
                                                
                                             
                                             
                                                
                                                   h
                                                   (
                                                   s
                                                   )
                                                   ,
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        Every time a new container 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                           
                         is about to be moved toward its target slot, all the containers placed at the top of some stack are checked. A twofold objective is pursued at this point. Firstly, identifying those containers that could keep the increasing priority order in s and, secondly, exploiting the available empty slots in the most promising way. With these objectives in mind, only those containers with a lower priority than 
                           
                              
                                 
                                    c
                                 
                                 
                                    +
                                 
                              
                           
                         and higher than that of the container currently placed at the top of s are considered. Therefore, only that feasible container with the lowest priority is selected to be relocated to s. This process is carried out while there is at least one empty slot in s. It is noteworthy that the target tiers of the containers included in 
                           
                              O
                              
                                 
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          ∗
                                       
                                    
                                    )
                                 
                                 
                                    s
                                 
                              
                           
                         must be appropriately updated after each empty slot is filled. A similar approach has been previously developed by Expósito-Izquierdo et al. [10].

Following the relocation process illustrated in Fig. 4, consider the scenario in which the container 13 is about to be moved toward its target slot 
                           
                              (
                              0
                              ,
                              0
                              )
                           
                         in the stack 0 (Fig. 5
                        a). As can be seen, the number of containers in the stack 0 after finishing the relocation process is 
                           
                              
                                 
                                    h
                                 
                                 
                                    ˆ
                                 
                              
                              (
                              0
                              )
                              =
                              3
                           
                         and, therefore, there will be one empty slot. As described above, the container 16 can be moved to stack 0 before relocating the container 13 in order to occupy the empty slot in this stack. Once the container 16 is relocated to the stack 0, the target slots of the containers 13, 10 and 9 must be updated appropriately (Fig. 5b). Note that the containers 2 and 3 are retrieved from the bay after relocating the containers 13 and 16, respectively.

This section is aimed at providing a wide computational experience concerning the different optimization approaches proposed along the present work. Its main objective is to assess the performance of these approaches compared to the most competitive algorithms published in the related literature. In addition, the impact of their components are also individually tested in order to check their suitability. In this regard, the following computational experiments can be split into two general parts:
                        
                           i.
                           An analysis about the behaviour of the A∗ search algorithms presented in Section 4. Moreover, the objective function value of the solutions obtained by means of the A∗ search algorithms is compared with those provided by the mathematical formulation presented by Caserta et al. [4].

A complete computational study on the heuristic algorithm introduced in Section 5 and the impact of the filling strategy (Section 5.6) on its performance.

The experiments presented along this section were carried out on a PC with an Intel Core 2 Duo E8500 3.16GHz and 4GB of RAM. Additionally, all the algorithms were programmed by using the Java SE 7 language. The characteristics of the computers used by other authors involved in the comparisons are later reported. The computational results, optimal solutions and additional information about the present work is available for its free consultation.
                        1
                        
                           https://sites.google.com/site/gciports/brp.
                     
                     
                        1
                     
                  

The performance of the algorithms proposed along the present work are tested over the most extended benchmark suite from the literature. It was taken from Caserta et al. [5]. It is composed of 21 groups with 40 instances (a total of 840 instances) generated at random. Each instance represents a container bay with well-delimited dimensions and in which all the slots are filled with one container, that is, all the stacks have the same number of containers and there is no any empty slot in the bay (
                           
                              C
                              =
                              n
                           
                        ). As shown for each particular computational experiment, several empty tiers should be included at the top of the bay in order to implement relocation movements. Therefore, the real number of tiers of any container bay is denoted by 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                           
                        , where 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              >
                              T
                           
                         and, consequently, 
                           
                              H
                              =
                              (
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              -
                              T
                              )
                              ×
                              S
                           
                        . The instance groups are referred to as CVS plus the number of tiers and stacks. It is assumed that all the containers must be retrieved from the bays (
                           
                              k
                              =
                              n
                           
                        ).

The characteristics of the benchmark suite are depicted in Table 1
                        . The columns represent the instance group (Group), the number of stacks (S), the number of tiers (T), the number of containers (n) and the average number of non-located containers in the bays (
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ‾
                                 
                              
                           
                        ), respectively. The number of non-located containers should be understood as an indicator for the degree of difficulty when solving the corresponding instances.

This computational experiment is aimed at assessing the capability of the A∗ search algorithms presented in Section 4 when solving the instances described in Section 6.1. In each case, the upper bound was obtained by setting 
                           
                              max
                              =
                              100
                           
                         (Algorithm 1). In addition, a maximum computational time of 24h was set for each case.


                        Table 2
                         shows the results obtained when solving the Restricted BRP by means of the A∗ search algorithm introduced in Section 4.2. The problems were solved varying the number of tiers in each case. Firstly, two empty tiers were added at the top of the bays (
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              T
                              +
                              2
                           
                        ) in order to represent the stacking capacity of the handling equipment at maritime container terminals, whereas an unlimited number of tiers was considered in the latter case, that is, there are enough tiers to pile up all the containers in the same stack (
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              ∞
                           
                        ). Although this constraint does not correspond to a common scenario at terminals, it is considered to assess the competitiveness of the proposed algorithms over the most general environments. This scenario has been already addressed in the related literature, such as in the work by Forster and Bortfeldt [11]. The column Group shows the instance group solved in each case. The next columns report the computational results when 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              T
                              +
                              2
                           
                         and 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              ∞
                           
                        , respectively. In each case, the number of instances solved to optimality within the maximum computational time and the average number of relocation movements are depicted by the columns No. and 
                           
                              
                                 
                                    f
                                 
                                 
                                    opt
                                 
                              
                           
                        , respectively.

The reported results indicate that, when the dimension of the instance is reasonably large, the A∗ search algorithm is not competitive at solving it. Thus, it was not possible to obtain any optimal solution for the instance groups with dimensions larger than 
                           
                              5
                              ×
                              8
                           
                         within the maximum computational time of 24h set by default. Nevertheless, 561 and 522 instances over 840 could be solved to optimality, respectively. This fact does not happen when the dimension of the instances are small and medium. In those cases, all the instances belonging to 13 groups could be solved to optimality (groups from 
                           
                              CVS
                              
                              3
                              ×
                              3
                           
                         up to 
                           
                              CVS
                              
                              5
                              ×
                              6
                           
                        ). The effectiveness of the algorithm is clearly undermined as the number of tiers gets larger. That is, only 2 instances could be solved to optimality when the dimension of the bay is 
                           
                              5
                              ×
                              7
                           
                         and the number of tiers is not constrained. Additionally, the computational time required by the optimization algorithm is larger when the number of tiers is unlimited. The reason is found in that the number of feasible relocation movements is not restricted by the height of the stacks, in such a way that, it is always possible to relocate the containers to another stack because the availability of empty slots is guaranteed. At the same time, the availability of empty slots also allows to reduce the average number of relocation movements required to retrieve all the containers in almost 1 relocation movement.

Similarly to the restricted case, Table 3
                         reports the results obtained by means of the A∗ search algorithm introduced in Section 4.1 for the Unrestricted BRP when solving the instances from the benchmark suite. The main difference with respect to the Restricted BRP is that a shorter number of instances could be solved to optimality. Only 432 instances out of 840 could be solved to optimality when 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              T
                              +
                              2
                           
                         and 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              ∞
                           
                        . The reason is found in the larger number of feasible relocation movements to perform over a given bay configuration, which results on a greater search space. In this case, several instances with dimension 
                           
                              4
                              ×
                              7
                           
                         could not be solved to optimality. On the other hand, as can be checked, a noticeable improvement in the optimal objective function value is achieved through considering the whole set of relocation movements. However, there are no relevant differences between the average number of relocation movements required in both environments. This is produced due to the fact that the improvement obtained by means of the availability of empty slots is offset by the large variety of feasible relocation movements to be performed.

In general terms, in spite of the optimality of the solutions found by means of the A∗ search algorithms is guaranteed, the large computational times required when solving the instances make them impractical for application in most of real scenarios.

This experiment pursues to check the optimality of the solutions provided by the A∗ search algorithms in comparison with those reported by the mathematical formulation named BRP-II proposed by Caserta et al. [4]. As done in the original paper, the computational experiment is limited to only a subset of 5 instances for each group. The number of empty tiers at the top of each bay is 2, that is, 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              T
                              +
                              2
                           
                        . Table 4
                         shows the comparison between both approaches. The results of the mathematical formulation are those reported by Caserta et al. [4], which were obtained by means of a PC equipped with a Pentium IV and 512MB of RAM and the commercial MIP software. In this regard, the first two columns (Group and Instance) show the instance group and the index of the instance to solve, respectively. The next column (O-1 IP) shows the objective function value of the solutions achieved by the mathematical formulation with a maximum computational time of one day. Finally, the last columns (Restricted A
                        ∗ and Unrestricted A
                        ∗) show the objective function value of the solutions reported by the A∗ search algorithms for the restricted and unrestricted versions of the BRP, respectively. Additionally, average objective function values are shown for each group of instances. It is worth mentioning that the results provided by the A∗ search algorithm for the Unrestricted BRP are only reported in order to ease future computational comparisons.

In spite of the fact that there are 3 instances (CVS 4
                        ×
                        6-1, CVS 4
                        ×
                        6-3 and CVS 4
                        ×
                        6-5) that were not solved to optimality within the maximum computational time of one day by the mathematical formulation, according to the results shown in Table 4 and, as introduced in Section 4, the mathematical formulation proposed by Caserta et al. [4] is incorrect. The reason is that there are 12 instances for which the A∗ search algorithm obtains feasible solutions for the problem with a lower objective function value than those reported by the mathematical formulation. This fact indicates that the optimality of the solutions reported by Caserta el al. [4] is not guaranteed. On the other hand, there are 5 instances for which A∗ search algorithm could not obtain solutions with the objective function value indicated by Caserta el al. [4]. This suggests that the feasibility of the solutions reported by Caserta et al. [4] was not adequately checked.

The following computational experiment is devoted to compare the effectiveness of the heuristic algorithm introduced in Section 5 with the most competitive ones from the related literature. The tree search procedure proposed by Forster and Bortfeldt [11] is considered along this subsection due to the fact that it presents the best results so far and, therefore, overcomes the remaining approaches. Its execution is proposed in the original paper with a stopping criterion based on a maximum computational time of 60s and over a computer equipped with an Intel Core 2 Duo processor (P7350, 16 GFLOPS) with 2GHz and 2GB of RAM.

The first step for the execution of the heuristic approach is to select suitable values for the whole set of required parameters. In this case, an off-line parameter initialization is considered in order to tune properly the values of the parameters used by the heuristic. Firstly, a set of container assignments is generated every time the next container to retrieve, 
                           
                              
                                 
                                    c
                                 
                                 
                                    ∗
                                 
                              
                           
                        , is not placed at the top of some stack in the bay. Intuitively, the maximum number of container assignments to be generated, 
                           
                              δ
                           
                        , must be closely related to the dimensions of the problem to solve. In this case, 
                           
                              δ
                              =
                              S
                              ×
                              T
                           
                         is set. In addition, at each step, one of the 
                           
                              α
                              =
                              10
                           
                         container assignments with the lowest estimated number of relocation movements is selected at random. This value allows to use a reasonable set of high-promising container assignments. Finally, the execution is finished after 
                           
                              β
                              =
                              100
                           
                         iterations without any improvement in the best objective function value reached during the search.


                        Table 5
                         presents the comparison between the two involved optimization techniques for solving the Unrestricted BRP with 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              T
                              +
                              2
                           
                        . The first column Group illustrates the instance group to solve. The column 
                           
                              
                                 
                                    Ω
                                 
                                 
                                    ‾
                                 
                              
                           
                         shows the average number of non-located containers in the bays. Finally, the column A
                        ∗ presents the results reported by the A∗ search algorithm, whereas the columns FB and Heuristic show the results obtained by means of the approaches of Forster and Bortfeldt [11] and that proposed in this work, respectively. The average objective function value (
                           
                              
                                 
                                    f
                                 
                                 
                                    FB
                                 
                              
                           
                        ) and the average computational time (Time), measured in seconds, are presented for the tree search procedure proposed by Forster and Bortfeldt [11]. The original paper indicates that the computational times are similar to those obtained for the case with unlimited tiers. On the other hand, the number of instances solved to optimality (No.), the average number of iterations required to finish the execution (Iter.), the average objective function value (
                           
                              
                                 
                                    f
                                 
                                 
                                    Heu
                                 
                              
                           
                        ), the average computational time (Time), measured in seconds, the relative error against the results reported by the A∗ search algorithm (
                           
                              
                                 
                                    Gap
                                 
                                 
                                    
                                       
                                          A
                                       
                                       
                                          ∗
                                       
                                    
                                 
                              
                           
                        ) and the relative error against the results provided by the heuristic of Forster and Bortfeldt (
                           
                              
                                 
                                    Gap
                                 
                                 
                                    FB
                                 
                              
                           
                        ) are consecutively reported for the heuristic algorithm. The last row in the table presents the average values for the corresponding columns.

The computational results evidence the high competitive performance of the heuristic algorithm proposed in the present work. In this case, a moderate improvement of 1.14% in the average objective function value was obtained over the results obtained by the approach of Forster and Bortfeldt. Nevertheless, the average objective function value was improved for 17 of the 21 instance groups. The improvement is increasingly higher as the dimension of the instances become larger. In this regard, a reduction of almost 4 relocation movements (3.09%) on average is reported in the largest cases (group 
                           
                              CVS
                              
                              10
                              ×
                              10
                           
                        ). Additionally, 394 instances could be solved to optimality over a total of 432 instances reported by the A∗ search algorithm, which means that an average relative error of 1.61% was obtained. The optimality of the remaining solutions is not guaranteed. The number of instances solved to optimality by means of the approach of Forster and Bortfeldt is not reported in the original paper. The non-parametric Wilcoxon Rank Sum test (see Sheskin [25]) has been performed to validate the relevance of the obtained results in a statistical way. This test indicates that there are statistical significant differences between the quality of both optimization techniques with 95% of confidence.

On the other hand, an analysis must be conducted with respect to the computational times required by both approaches. As can be seen, the average computational time used by the tree search procedure proposed by Forster and Bortfeldt increases in a fast way as the dimensions of the instance get larger. In this regard, only 0.1s were required when solving instances belonging to the group 
                           
                              CVS
                              
                              5
                              ×
                              9
                           
                        , whereas the execution of the algorithm was finished after the maximum computational time of 60s set by default was achieved at solving the instances from the group 
                           
                              CVS
                              
                              10
                              ×
                              10
                           
                        . Furthermore, the heuristic algorithm proposed in this work presents a higher robustness in the computational times due to the fact that, although its execution needs a larger computational time when solving most of the small instance groups, this time increases gradually with the dimension of the instances. That is, only 48s were required for solving the largest instances.

Finally, the number of iterations required by the heuristic approach developed in this work increases as the dimensions of the instance get larger. That is, the best solution is achieved in a few iterations, whereas almost one hundred iterations on average are required in the largest cases. Note that, in this experiment, the heuristic stops after 
                           
                              β
                              =
                              100
                           
                         iterations without improvement in the objective function value.

In a similar way, Table 6
                         presents the results for the Unrestricted BRP with an unlimited number of tiers, that is, 
                           
                              
                                 
                                    T
                                 
                                 
                                    ′
                                 
                              
                              =
                              ∞
                           
                        . In this case, the improvement in the average objective function value of the reported solutions is particularly noteworthy. A maximum improvement of almost 13 relocation movements (11.02%) on average for the largest instances (group 
                           
                              CVS
                              
                              10
                              ×
                              10
                           
                        ) was obtained. The average number of relocation movements was reduced in 17 of the 21 instance groups under study. The heuristic obtained 405 optimal solutions over a total of 432 instances, which constitutes an average relative error of 0.86%. Furthermore, Forster and Bortfeldt [11] remark that the optimality of only 69 instances from the obtained results is guaranteed. It is worth mentioning that the Wilcoxon Rank Sum test indicates that there are statistical significant differences between the quality of both optimization techniques with 95% of confidence.

The heuristic approach requires larger computational times than in the case of limited number of tiers. Nevertheless, this time is shorter than that used by the tree search algorithm for solving the largest instances.

The filling strategy allows to exploit the available empty slots during the implementation of the selected container assignment. Fig. 6
                         illustrates the comparison of the behaviour of the heuristic approach when the filling strategy is included. For each group of instances the average objective function value obtained through including the filling strategy and that in which this strategy is not included is reported.

The results in Fig. 6 show that including the filling strategy into the structure of the heuristic approach provides a noticeable improvement in the average number of relocation movements. The behaviour of the heuristic approach is uniform in both cases. In this regard, only a slight improvement was obtained for small size groups of instances, less than 5%. This improvements is over 40% in the largest instances, group 
                           
                              CVS
                              
                              10
                              ×
                              10
                           
                        . The Wilcoxon Rank Sum test reveals that there are statistical significant differences between the computational results obtained by means of both approaches with 95% of confidence.

@&#CONCLUSIONS@&#

The Blocks Relocation Problem (BRP) is aimed at retrieving a subset of the containers located in a bay of the yard of a container terminal according to a prescribed order. This is one core logistic problem for the competitiveness of the container terminals due to the fact that it produces a highlighted impact on the effectiveness of container requests. However, most of the terminal managers do not use proper decision-making systems designed to provide support for the control of operations. Instead, ad hoc or experience-based approaches are widely extended in container terminals leading to a poor performance, high costs and small adaptability to changes in the environment.

This paper presents a general analysis about the main approaches published in the related literature for solving the BRP. In this regard, in spite of the fact that there is a mathematical formulation proposed for its solution, the obtained solutions are incorrect because they do not satisfy the principle of optimality. In order to overcome the lack of suitable optimization techniques for solving the BRP from an exact point of view, two A∗-based search algorithms are developed. Unfortunately, their application in real-world is certainly limited to only small scenarios because they are highly time-consuming.

On the other hand, a domain-specific knowledge-based heuristic algorithm is developed to tackle the BRP in an approximate way. Its behaviour is based on finding the most promising slots where to relocate those containers placed above the next one to retrieve. With this goal in mind, the corresponding containers are relocated in such a way that the probability of requiring new relocation movements in the future is minimized. In addition, a strategy designed to exploit the availability of empty slots in the bay is included. The computational results indicate that this heuristic algorithm presents a higher effectiveness and efficiency than the most competitive optimization approaches from the literature in a wide range of environments.

@&#ACKNOWLEDGEMENTS@&#

This work has been partially funded by the European Regional Development Fund, the Spanish Ministry of Economy and Competitiveness (projects TIN2012-32608, TIN2009-13363 and TIN2008-06872-C04-01), and the Canary Government (project PI2007/019). Christopher Expósito-Izquierdo thanks the Canary Government the financial support he receives through his post-graduate grant.


                     
                        
                           
                              
                              
                              
                                 
                                    
                                       Blocks Relocation Problem:
                                    
                                 
                              
                              
                                 
                                    
                                       B
                                    
                                    Number of bays composing the container block
                                 
                                 
                                    
                                       S
                                    
                                    Number of stacks of the bay
                                 
                                 
                                    
                                       T
                                    
                                    Number of tiers of the bay
                                 
                                 
                                    
                                       C
                                    
                                    Capacity of the bay
                                 
                                 
                                    
                                       H
                                    
                                    Minimum number of empty slots into the bay required to ensure the existence of feasible solutions
                                 
                                 
                                    
                                       n
                                    
                                    Number of containers initially placed into the bay
                                 
                                 
                                    
                                       k
                                    
                                    Number of containers with the highest priorities to retrieve from the bay
                                 
                                 
                                    
                                       m
                                    
                                    Number of containers placed into the bay after the k retrieval operations have been performed
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   c
                                                
                                                
                                                   ∗
                                                
                                             
                                          
                                       
                                    
                                    Next container to retrieve from the bay
                                 
                                 
                                    
                                       
                                          
                                             s
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    Stack in which the container c is placed
                                 
                                 
                                    
                                       
                                          
                                             t
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    Tier in which the container c is placed
                                 
                                 
                                    
                                       
                                          
                                             p
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    Priority of the container c
                                    
                                 
                                 
                                    
                                       
                                          
                                             h
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Number of containers placed in the stack s
                                    
                                 
                                 
                                    
                                       
                                          
                                             max
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    The highest priority of a container in the stack s (Eq. (1))
                                 
                                 
                                    
                                       
                                          
                                             Ω
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Set of non-located containers in the stack s (Eq. (2))
                                 
                                 
                                    
                                       
                                          
                                             Ω
                                          
                                       
                                    
                                    Set of non-located containers into the bay (Eq. (3))
                                 
                                 
                                    
                                       
                                          
                                             ϒ
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Set of well-located containers in the stack s (Eq. (4))
                                 
                                 
                                    
                                       A
                                       ∗ 
                                       Search Algorithm
                                    
                                 
                                 
                                    
                                       
                                          
                                             f
                                             (
                                             n
                                             )
                                          
                                       
                                    
                                    Scoring function used to evaluate the node n
                                    
                                 
                                 
                                    
                                       
                                          
                                             g
                                             (
                                             n
                                             )
                                          
                                       
                                    
                                    Path-scoring function of the node n
                                    
                                 
                                 
                                    
                                       
                                          
                                             h
                                             (
                                             n
                                             )
                                          
                                       
                                    
                                    Heuristic function of the node n (Eq. (5) for Unrestricted BRP and Eq. (6) for Restricted BRP)
                                 
                                 
                                    
                                       max
                                    
                                    Number of iterations to perform in Algorithm 1
                                    
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       Heuristic Algorithm:
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   s
                                                
                                                
                                                   ¯
                                                
                                             
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    Target stack of the container c
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   ¯
                                                
                                             
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    Target tier of the container c
                                    
                                 
                                 
                                    
                                       
                                          
                                             O
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                    Set of containers placed above the container c (Eq. (7))
                                 
                                 
                                    
                                       
                                          
                                             O
                                             
                                                
                                                   (
                                                   c
                                                   )
                                                
                                                
                                                   s
                                                
                                             
                                          
                                       
                                    
                                    Subset of containers from 
                                          
                                             O
                                             (
                                             c
                                             )
                                          
                                        with target stack s (Eq. (8))
                                 
                                 
                                    
                                       
                                          
                                             Ψ
                                             (
                                             O
                                             (
                                             
                                                
                                                   c
                                                
                                                
                                                   ∗
                                                
                                             
                                             )
                                             )
                                          
                                       
                                    
                                    Set of container assignments associated with 
                                          
                                             O
                                             (
                                             
                                                
                                                   c
                                                
                                                
                                                   ∗
                                                
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             ψ
                                          
                                       
                                    
                                    Container assignment to apply
                                 
                                 
                                    
                                       moves
                                    
                                    Number of moves to apply a given container assignment (Algorithm 3)
                                 
                                 
                                    
                                       
                                          
                                             moves
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Minimum number of relocation movements associated with the stack s to apply a given container assignment (Eq. (9))
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   min
                                                
                                                
                                                   s
                                                
                                             
                                          
                                       
                                    
                                    Container from 
                                          
                                             O
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                
                                                
                                                   s
                                                
                                             
                                          
                                        with the minimum priority (Eq. (10))
                                 
                                 
                                    
                                       
                                          
                                             r
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Number of containers to remove from the target stack s (Eq. (11))
                                 
                                 
                                    
                                       
                                          
                                             u
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Number of intermediate relocation movements to perform on the containers included into 
                                          
                                             O
                                             
                                                
                                                   (
                                                   
                                                      
                                                         c
                                                      
                                                      
                                                         ∗
                                                      
                                                   
                                                   )
                                                
                                                
                                                   s
                                                
                                             
                                          
                                        (Eq. (12))
                                 
                                 
                                    
                                       
                                          
                                             α
                                          
                                       
                                    
                                    Number of container assignments with the lowest estimation
                                 
                                 
                                    
                                       
                                          
                                             β
                                          
                                       
                                    
                                    Maximum number of iterations without improvement in Algorithm 2
                                    
                                 
                                 
                                    
                                       
                                          
                                             δ
                                          
                                       
                                    
                                    Number of container assignments generated at each step of the heuristic algorithm
                                 
                                 
                                    
                                       
                                          
                                             Θ
                                          
                                       
                                    
                                    Set of candidate containers to be relocated to their target slots (Eq. (13))
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   c
                                                
                                                
                                                   +
                                                
                                             
                                          
                                       
                                    
                                    Next container to relocate (Eq. (14))
                                 
                                 
                                    
                                       
                                          
                                             f
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Function defining the suitability degree of the stack s to be used as target of intermediate containers (Eq. (15))
                                 
                                 
                                    
                                       
                                          
                                             prob
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Probability of selecting the stack s as target of intermediate containers (Eq. (16))
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   h
                                                
                                                
                                                   ˆ
                                                
                                             
                                             (
                                             s
                                             )
                                          
                                       
                                    
                                    Number of containers that will be placed in the stack s after the relocation process finishes (Eq. (17))
                                 
                                 
                                    
                                       
                                    
                                 
                                 
                                    
                                       Computational Experiments:
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   T
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                    
                                    Number of tiers of the bay used in the computational experiments
                                 
                              
                           
                        
                     
                  

@&#REFERENCES@&#

