@&#MAIN-TITLE@&#Surface point location by walking algorithm for haptic visualization of triangulated 3D models

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We have designed an algorithm for collision detection in haptic visualization.


                        
                        
                           
                           It detects a triangle close to the haptic probe in its collision trajectory.


                        
                        
                           
                           It can be also used for other searching on the surface of triangulated 3D models.


                        
                        
                           
                           It can be successfully used for large models which are even changing in time.


                        
                        
                           
                           No searching data structures are needed, however, the algorithm works fast enough.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Triangle lookup

Searching algorithm

Walking algorithm

Triangulated surface model

Haptic visualization

Collision detection

@&#ABSTRACT@&#


               
               
                  Haptic devices are nowadays gaining popularity because of their increasing availability. These special input/output devices provide, unlike mouse or keyboard, a native 3D manipulation, especially a more precise control and a force interaction. With more accurate description of the model, haptics can achieve more realistic force feedback. Therefore, triangulated surface models are often used for an authentic interpretation of 3D models. A common task in haptic visualization using triangulated surface models is to find a triangle which is in the collision trajectory of the haptic probe. Since the render rate of the haptic visualization is relatively high (usually about 1kHz), the task becomes highly non-trivial for complex mesh models, especially for the meshes which are changing over time. The paper presents a fast and novel location algorithm able to find the triangle which is close to the haptic probe and in the direction of the probe motion vector. The algorithm has negligible additional memory requirements, since it does not need additional searching data structures and uses only the information usually available for triangulated models. Therefore, the algorithm could handle even triangular meshes changing over time. Results show that the proposed algorithm is fast enough to be used in haptic visualization of complex-shaped models with hundreds of thousands of triangles.
               
            

@&#INTRODUCTION@&#

In this paper we focus on the collision detection problem of the haptic device with the surface of 3D model which is defined by a triangular mesh. The goal is to find a triangle (if such a triangle exists) which is in the collision trajectory of the haptic probe to provide appropriate feedback to the user.

Haptic visualization is a tactile feedback method which provides a sense of touch to the user via a haptic device by applying forces, vibrations, or motions while visual perception is usually mediated by a display device. See an example of the haptic device Phantom Omni® used in our experiments in Fig. 1
                     . The haptic visualization finds applications in a variety of areas including haptic surgery simulations [1–3], industry design-based manufacturing [4], or the virtual reality for blind computer users [5]. The majority of the haptic rendering techniques [6,7] require to detect collision (and intersection) of a haptic cursor with the visualized model. However, unlike graphics visualization where a sufficient render rate is about 25Hz, the render rate required by the haptics is about 1000Hz to provide an authentic feedback (as it is mentioned by Colgate and Brown [8] a human skin is sensitive to force change of a frequency higher than 500Hz). Therefore, collisions need to be detected and computed as fast as possible.

Since a higher precision of model representation results in a more realistic perception, many haptic applications [2,6,9,10] use triangulated surface meshes for the representation of models. Existing approaches for the triangulated surface meshes usually deal with static scenes or local changes of the model, where the location methods with search data structures (especially a spatial subdivision techniques) provide adequate results [9]. As mentioned in [10], most of the existing algorithms address collision detection and intersection computation for small models which consist of a few thousands of polygons or they use some kind of down-sampled finite element model [2].

However, in the haptic visualization and interaction used for geometric modeling the model and its topology is often changing, which results in updates of the search data structures. These updates may not be trivial and if the changes in the triangular mesh are frequent, updates of data structures may significantly affect the performance. Moreover, search data structures consume additional memory.

Therefore, the goal is to develop an algorithm which does not utilize additional search data structures and still achieves the performance necessary for the application in the haptic visualization. When the haptic probe is moving on the surface of the model, the render rate required by the haptics is about 1000Hz, thus the longest detection/location should take less than 1ms. When the haptic probe is moving in a free space, the collisions may be detected in a lower rate, since a low delay of the first touch feedback is not noticeable. The frame rate about 100Hz is sufficient, thus the longest detection/location should take less than 10ms.

The problem is more precisely defined as follows. For a given position 
                        
                           q
                        
                      of the haptic probe and its motion vector 
                        
                           m
                        
                      (the current direction of movement of the haptic probe), the goal is to find and return such a triangle from the given surface triangular mesh, which is intersected by the line 
                        
                           λ
                           =
                           [
                           q
                           ,
                           m
                           ]
                        
                      in the distance from 
                        
                           q
                        
                      lower than or equal to a defined maximal allowable distance 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                     . Moreover, 
                        
                           m
                        
                      should direct towards the front face of the found target triangle. If such a triangle does not exist, null should be returned. Note that 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                      should be small enough to ensure unique result. We suppose that the model does not contain errors or holes, all the triangles have uniform orientation and have information about their neighbors.

The proposed solution ranks among walking algorithms, which are popular especially for point location in planar triangular meshes or in tetrahedral meshes. The name of walking algorithms describes their principle: generally, the search goes from a triangle to its neighbor in the direction of the given query point, until the target triangle (which contains the query point) is found. In our case, the walking algorithm is searching in the direction of a triangle, which is intersected by the line defined by the position of the haptic probe and the haptic motion vector (see Fig. 2
                     ). Since the next triangle is chosen with respect to local tests, the utilization of a walking algorithm for a point location on the triangulated surface model is not simple and, to the best of our knowledge, no complex walking algorithm for point location on a triangulated surface model has been published.

The proposed algorithm has negligible additional memory requirements since it does not need additional data structures. It only needs the information about neighboring triangles, which is usually required for other purposes as well. Therefore, the algorithm can handle even triangular meshes which are changing over time. Although the algorithm was developed especially for haptic visualization, it is not limited to the haptic collision detection only. It can be used for all point location problems, where the input contains both: a point close to the surface of the triangulated 3D model and a vector directing towards the model. For example, for a parametric description of the model, we can get a point on the surface as well as a vector directing towards the model (it may be the opposite surface normal at this point).

Results show that the proposed algorithm can handle queries on rather complex-shaped models with hundreds of thousands of triangles in a good time and thus it can be successfully used in haptic visualization. The algorithm is suitable also for models changing in time. Although it is not a primary task of the algorithm, it can also handle queries when the model is composed of multiple components. Moreover, the algorithm is easily and effectively parallelizable which can significantly speed up the search process.

The paper is organized as follows. ‘State of the art’ provides an overview in the task of a collision detection regarding to haptic visualization. ‘Proposed method’ describes the proposed walking algorithms for collision detection in haptic visualization. ‘Experimental results’ presents our experiments performed on well-known triangulated surface models and ‘Conclusion’ concludes the paper.

Collision detection and contact determination problems has been extensively studied in [9,11–17].

The simplest algorithms for collision detection are based on using bounding volumes and spatial, hierarchical decomposition techniques. For such a decomposition, e.g., k–d trees and octrees [11], cone trees, sphere trees [12,13], R-trees and their variants, trees based on S-bounds [15], and oriented bounding boxes [9] are used. Other spatial representations are based on BSP’s [16] and its extensions to multi-space partitions [17].

As it is mentioned, e.g., in [2], it is very difficult to handle interactive rendering framerates for complex models due to a computation of collision detection. Sela et al. [2] propose a haptic surgical simulator where the finite element method (FEM) is used for offline preprocessing of physical properties around the cut. Then the discontinuous free-form deformation (DFFM) is created. Note that only DFFM is used during a real-time cutting stage since a fast solution is needed. A surface model of a skin or flash is represented as a polygonal surface. To handle collision queries of a haptic cursor in a sufficient rate, authors use a preprocessed uniform voxel grid around the model.

Gregory et al. [10] present a hybrid collision detection framework for haptic interaction which uses a hierarchical representation of uniform grids and trees of oriented bounding boxes. Their framework utilizes the frame-to-frame coherence of a haptic probe. However, like other techniques using search data structures, modification for surface triangular meshes which are changing in time is complicated and continuous updating of data structures provides a significant decrease of the speed.

The approach proposed in this paper is based on the walking principle which is usually used for point location in planar triangular meshes or in tetrahedral meshes. The surveys of walking algorithms are presented in [18,19]. [20,21] used a walking algorithm in spherical re-meshing problem for point location on the surface of a triangulated sphere. Some algorithms (e.g. [22]) utilize the walking algorithms for point location on the surface triangular meshes in the local context (following the prior utilization of a search data structure, such as the octree). However, as far as we know, complex walking algorithms have not been applied to the problem of point location or collision detection on the surface triangular meshes.

There are several walking algorithms solving point location problem, and according to the style how they determine the way of the walk they can be divided into three groups: visibility, straight and orthogonal walks. Visibility walks [18,23–25] use local “visibility” tests to determine the way of their walk. These tests look for such an edge of a triangle that defines a line separating the query point and the third vertex of the triangle. The walk then moves across this edge to the neighborhood triangle. Straight walk algorithms [18,26,27] use not only the local comparisons to determine the way of the walk, but also use a line connecting one point of the starting triangle with the query point and traverse triangles crossed by this line. Orthogonal walks [18,21] first navigate along one coordinate axis and then along the other.

A clever selection of the starting triangle for walking may radically improve the speed of the algorithm, since it reduces the number of visited triangles during the walk. If any additional information about the data is known, it can be used in the selection, e.g., the target triangle from the last location query can be used as a starting triangle for the next query, if there is a coherency between queries. Without any knowledge of the data, the initial triangle can be chosen randomly. A better, yet still fast and simple alternative without any additional memory use was proposed in [28], where the initial triangle is selected as the nearest triangle from a set A of randomly chosen triangles from the scanned triangular mesh T. The total number of randomly selected triangles is significantly lower than the total number of triangles in T (
                        
                           ‖
                           A
                           ‖
                           ≪
                           ‖
                           T
                           ‖
                        
                     ). For planar Delaunay triangulation of random points, an analysis of the ideal size of such a random subset has been proposed by [29], leading to the size of 
                        
                           O
                           (
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                           )
                        
                     .

@&#PROPOSED METHOD@&#

A keystone for the walking-based approach is the orientation test of a point against a plane: let us have a plane given by three points t, u, v and a tested point 
                        
                           w
                        
                     . Eq. (1) computes whether 
                        
                           w
                        
                      lies above, on or below the given plane when seen from the side where t, u, v points are CCW oriented. In other words, the test decides whether the orientation of these points is positive, neutral or negative.
                        
                           (1)
                           
                              orientation
                              3
                              D
                              (
                              t
                              ,
                              u
                              ,
                              v
                              ,
                              w
                              )
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      x
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      x
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      x
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      x
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      w
                                                   
                                                   
                                                      x
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      x
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      y
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      y
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      y
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      y
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      w
                                                   
                                                   
                                                      y
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      y
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      u
                                                   
                                                   
                                                      z
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      z
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      z
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      z
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      w
                                                   
                                                   
                                                      z
                                                   
                                                
                                                -
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      z
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     The proposed walking algorithm supposes that the model does not contain errors or holes, all the triangles have uniform orientation and have information about their neighbors. Note that CCW orientation of all the model triangles from the outside of the model is expected in the following text. Let us denote the i-th triangle visited by the proposed walking algorithm as 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                     .

Recall that the goal is to find and return a triangle 
                        
                           ω
                        
                      from the surface triangular mesh T (
                        
                           ω
                           ∈
                           T
                        
                     ), which is intersected by the line 
                        
                           λ
                           =
                           [
                           q
                           ,
                           m
                           ]
                        
                      defined by the haptic probe position 
                        
                           q
                        
                      and the haptic motion vector 
                        
                           m
                        
                     . Generally, the line may intersect the model T in more intersection points, therefore, the intersection point should be in the distance from 
                        
                           q
                        
                      lower than or equal to a defined maximal allowable distance 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                     . Moreover, the haptic motion vector 
                        
                           m
                        
                      should direct towards the front face of 
                        
                           ω
                        
                     . If such a triangle does not exist, null should be returned.

Let us define properly oriented triangle as a triangle that 
                        
                           m
                        
                      direct towards its front face. In the other words, if a triangle defined by vertices 
                        
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                        
                      is a properly oriented triangle, the orientation test 
                        
                           orientation
                           3
                           D
                           (
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 1
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 2
                              
                           
                           ,
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           -
                           m
                           )
                        
                      provides a positive value (an auxiliary point 
                        
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           -
                           m
                        
                      lies above that triangle). Thus, the target triangle 
                        
                           ω
                        
                      is always a properly oriented triangle.

Let us present now the main idea of the proposed location algorithm. It is based on the straight walk principle, however, it uses a plane to guide the search instead a line. First, a proper starting triangle 
                        
                           α
                           ,
                           α
                           ∈
                           T
                        
                      is chosen to start the search; a proper choice will be described later. Let us have a plane 
                        
                           opq
                        
                      given by the points 
                        
                           q
                           ,
                           p
                           =
                           q
                           -
                           m
                        
                      and the center of gravity 
                        
                           o
                        
                      of the triangle 
                        
                           α
                        
                     . The plane 
                        
                           opq
                        
                      cuts the model. The algorithm then walks from the starting triangle through the neighboring triangles cut by 
                        
                           opq
                        
                      and attempts to find the target triangle 
                        
                           ω
                        
                     . Fig. 3
                      shows an example of the walk, Fig. 4
                      shows the same situation in the projection to 
                        
                           opq
                        
                      (only triangles intersected by the plane 
                        
                           opq
                        
                      are projected into the plane).

On one hand, the auxiliary plane 
                        
                           opq
                        
                      guides the walk so that the walking path is given; on the other hand, in the given path starting in the triangle 
                        
                           α
                        
                     , the triangle 
                        
                           ω
                        
                      may not exist. This behavior complicates the location process since the walk following this plane comes back to the starting triangle 
                        
                           α
                        
                      without finding 
                        
                           ω
                        
                     . See an example of an unsuccessful walk in Fig. 5
                     , where the path from the triangle 
                        
                           α
                        
                      to the triangle 
                        
                           ω
                        
                      does not exist and the walk comes back to 
                        
                           α
                        
                      (it may also happen when 
                        
                           α
                        
                      lies in another component than 
                        
                           ω
                        
                      – not the case in Fig. 5). Then the walk is restarted with a new choice of the starting triangle and with another cutting plane 
                        
                           opq
                        
                     . The more complicated shape of the model is, the more such iterations may be needed, however, as will be shown in ‘Experimental results’, the number of required iterations can be greatly reduced by a clever choice of the first triangle.

Walking iterations may be unsuccessful due to non-existence of the target triangle 
                        
                           ω
                        
                     . If there is a possibility that 
                        
                           ω
                        
                      does not exist (as it is in the collision detection), an upper number of the allowed iterations should be set. Then the walk is repeated until the target triangle 
                        
                           ω
                        
                      is found or the upper number of allowed iterations is reached. As will be shown in ‘Experimental results’, even a low upper number of allowed iterations ensures a negligible number of false negative results (results where 
                        
                           ω
                        
                      exists but is not found). Moreover, since a lot of location queries is performed in a very short time, the distance between two positions 
                        
                           q
                        
                      in the consecutive location queries is very low, usually several times lower than 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                     . Therefore, the algorithm can afford to return several consecutive false negative results without consequences before the haptic probe enters the model.

As we mentioned, the number of performed iterations can be significantly lowered by a clever choice of the first triangle 
                        
                           α
                        
                     . Generally, the closer the 
                        
                           α
                        
                      to 
                        
                           ω
                        
                     , the lower the average number of performed iterations is. When the haptic probe is moving, the search problem is solved repeatedly, with two following 
                        
                           q
                        
                      positions being mutually close since the probe movement is continuous. Therefore, it is useful to employ coherence in the choice of the starting triangle – the triangle 
                        
                           ω
                        
                      from the last location query is used as the starting triangle 
                        
                           α
                        
                      for the first iteration of the next location query.

Now let us explain the selection of the starting triangle 
                        
                           α
                        
                      where coherence cannot be employed or if it has not been successful in the first iteration, see Algorithm 1 for a detailed description. The goal of this part is to find a triangle which is ‘close enough’ to 
                        
                           q
                        
                      and properly oriented. The check of the proper orientation helps to minimize the probability of a choice of a triangle which is close to the target triangle 
                        
                           ω
                        
                      in the Euclidean distance but far in the topological distance (measured on the model surface). The algorithm utilizes a random sampling [28] – a subset of the triangles from T is checked on the Euclidean distance from the point 
                        
                           q
                        
                      and the properly oriented triangle nearest to 
                        
                           q
                        
                      is chosen as 
                        
                           α
                        
                     . The quadratic distance from the first of triangle vertices is measured for simplicity and efficiency. The size of the random sample is given by a user parameter k. A bigger k causes more computation but a better choice of the starting triangle and vice versa. If no properly oriented triangle is found in k steps, the search continues until a properly oriented triangle is found. A proper value of k is highly dependent on the specific model, however, 
                        
                           k
                           =
                           2
                           ·
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                        
                      (where n is the number of vertices in T) worked as a good compromise for all the tested models in our experiments.
                        Algorithm 1
                        First triangle selection 
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Now the whole of the location algorithm will be described. First, a proper starting triangle 
                        
                           α
                        
                      is chosen. Then its center of gravity 
                        
                           o
                        
                      and 
                        
                           p
                           =
                           q
                           -
                           m
                        
                      are computed and the cutting plane 
                        
                           opq
                        
                      is defined. Note that the edge intersected by the plane is such an edge which is crossed by the plane between both vertices of the edge (vertices included). Thus, if the plane passes through the triangle vertex, both edges of the triangle defined by this vertex are considered as the edges intersected by the plane. Although it is not commented in the following text, if there are two possibilities how to choose the intersected output edge, an arbitrary one of them can be chosen for the proper continuation of the walk.

There are two tasks on each visited triangle 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                      in the walk: to find the output edge of 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                      intersected by the plane 
                        
                           opq
                        
                      which will be used to go to the next triangle and to decide whether the current triangle 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                      is intersected by 
                        
                           
                              
                                 pq
                              
                              
                                 →
                              
                           
                        
                      in the distance from 
                        
                           q
                        
                      lower than or equal to 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                      or whether the walk will continue.

For the first triangle 
                        
                           α
                        
                     , there are usually two edges intersected by the plane 
                        
                           opq
                        
                     , but due to the proper orientation of 
                        
                           α
                        
                     , we can choose the output edge using orientation tests so that the path over this edge will be probably shorter (points 
                        
                           opq
                        
                      are viewed in the CW order from the first vertex of the output edge and in the CCW order from the second vertex of the output edge, where the order of the edge vertices is given by the orientation of the triangle). For each successive triangle 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                           =
                           (
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                           )
                        
                     , the vertices 
                        
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                        
                      are determined by the input edge 
                        
                           
                              
                                 ∊
                              
                              
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       r
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                      (the edge used to enter the triangle 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                     ) and the vertex 
                        
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        
                      is opposite to 
                        
                           
                              
                                 ∊
                              
                              
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       r
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     . The algorithm determines the output edge by comparing the vertex 
                        
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        
                      to the plane 
                        
                           opq
                        
                      using the 3D orientation test. See Fig. 6
                      for an example of the walk. Note that 
                        
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                        
                      is always above the plane 
                        
                           opq
                        
                      (points 
                        
                           o
                           ,
                           p
                           ,
                           q
                        
                      are in the CCW order when seen from 
                        
                           
                              
                                 l
                              
                              
                                 i
                              
                           
                        
                     ) and 
                        
                           
                              
                                 r
                              
                              
                                 i
                              
                           
                        
                      is always bellow or on the plane. If 
                        
                           
                              
                                 s
                              
                              
                                 i
                              
                           
                        
                      is above 
                        
                           opq
                        
                      (on the left side of 
                        
                           opq
                        
                      in Fig. 6), the output edge is 
                        
                           
                              
                                 ∊
                              
                              
                                 
                                    
                                       r
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       s
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     , otherwise, the output edge is 
                        
                           
                              
                                 ∊
                              
                              
                                 
                                    
                                       s
                                    
                                    
                                       i
                                    
                                 
                                 
                                    
                                       l
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     . Note that the back side of 
                        
                           opq
                        
                      is seen in Fig. 6 (points 
                        
                           o
                           ,
                           p
                           ,
                           q
                        
                      are in the CW order).

Before the algorithm continues through the output edge to the next triangle, it computes the orientation test for the point 
                        
                           q
                        
                      with respect to the plane defined by the output edge and the point 
                        
                           p
                        
                     . If the point 
                        
                           q
                        
                      lies on the same side as the third vertex of 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                      (vertex not defining output edge), a triangle intersected by 
                        
                           
                              
                                 pq
                              
                              
                                 →
                              
                           
                        
                      has been found. Then it is checked, if the triangle is properly oriented. If so, the intersection point of the triangle with 
                        
                           
                              
                                 pq
                              
                              
                                 →
                              
                           
                        
                      is computed. If that intersection point is in a distance from 
                        
                           q
                        
                      lower than or equal to 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                     , the target triangle 
                        
                           ω
                        
                      was found. In all other cases, the algorithm continues through the output edge to the next triangle. See pseudo-code of the algorithm in Algorithm 2.

Note that two orientation tests per each visited triangle 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                      are needed. One test to determine which edge is the output edge and one test to determine whether the current triangle 
                        
                           
                              
                                 τ
                              
                              
                                 i
                              
                           
                        
                      is intersected by 
                        
                           
                              
                                 pq
                              
                              
                                 →
                              
                           
                        
                      (by control on which side of the plane defined by the output edge and by the point 
                        
                           p
                        
                      the query point 
                        
                           q
                        
                      lies). For each found intersected triangle, the controlled side of the plane is changed to the opposite of the previous one, since the algorithm is approaching the next intersected triangle from the opposite side. In order to determine on which side of the plane the query point 
                        
                           q
                        
                      should be, an auxiliary variable is used (the variable mark in Algorithm 2). Additionally, one orientation test and sometimes also one intersection point computation are performed, if this triangle is intersected by 
                        
                           
                              
                                 pq
                              
                              
                                 →
                              
                           
                        
                     . 
                        Algorithm 2
                        Walking algorithm for surface location 
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The described algorithm may need more iterations to find the target triangle (it happens especially when 
                        
                           ω
                        
                      does not exist, then the upper number of iterations is always performed). As these particular iterations are independent, location process can be parallelized, i.e., more threads may run separated walks with different starting triangles at the same time. The thread which first finds the target triangle stops the whole location.

@&#EXPERIMENTAL RESULTS@&#

For the test purposes, we have implemented our algorithm in C++ with adaptive floating point arithmetic [30] to avoid numerical problems. The solutions have been tested on Intel Q6600 2.40GHz in the single thread mode. The SSE2 random generator was used for randomization, since it is declared as up to five times faster then the standard C random generator [31].

The tests are presented on the following well-known 3D models: pawn (304 triangles), triceratops (5660 triangles), cow (5804 triangles), fandisk (12,946 triangles), blob (16,068 triangles), gargoyle (20,000 triangles), venusbody (22,720 triangles), dinosaur (28,136 triangles), horse (39,698 triangles), Headus skull (40,000 triangles), Stanford bunny (71,888 triangles), and brain (588,032 triangles) – see models visualization example in Fig. 7
                     .

For each dataset, we have tested three different variants of input data with the following positions to the surface model:
                        
                           1.
                           points generated on a surface – motion vectors of these points correspond to the opposite normal vectors of triangles of the model,

points generated near a surface – oriented lines 
                                 
                                    λ
                                 
                               defined by these points and their motion vectors intersect triangles on the surface of 3D model in distance lower than or equal to the defined maximal allowable distance 
                                 
                                    
                                       
                                          dist
                                       
                                       
                                          max
                                       
                                    
                                 
                              , input motion vectors are randomly deviated from the opposite surface normals which correspond to the intersected triangles of the model; the maximal deviation is lower than 90°,

points generated further from a surface – oriented lines 
                                 
                                    λ
                                 
                               intersect triangles on the surface of 3D model in a little greater distance than 
                                 
                                    
                                       
                                          dist
                                       
                                       
                                          max
                                       
                                    
                                 
                              , input motion vectors are generated in the same way as in the second variant.

For each tested variant and each dataset, we performed 
                        
                           
                              
                                 10
                              
                              
                                 6
                              
                           
                        
                      location queries on a randomly generated input corresponding to the above variants (input data coherence has not been utilized in tests).

As it is described in ‘Proposed method’, the first triangle is selected as the closest properly oriented triangle to 
                        
                           q
                        
                      from a set of k randomly chosen triangles from T. The determination of proper k depends on the specific dataset, however, we set 
                        
                           k
                           =
                           2
                           ·
                           
                              
                                 n
                              
                              
                                 3
                              
                           
                        
                      as a good compromise through the datasets, where n is the number of vertices in the mesh.

For each dataset, the following parameters were measured:
                        
                           •
                           
                              k is the size of the set of randomly chosen triangles from T which was used to choose the starting triangle,


                              Visited 
                              
                                 
                                    Δ
                                 
                               is the number of visited triangles, where 
                                 
                                    ϕ
                                 
                               shows the average and max shows the maximum number of visited triangles,


                              Tests is the number of performed orientation tests, where 
                                 
                                    ϕ
                                 
                               shows the average and max shows the maximum number of orientation tests,


                              Intersect. dist. 
                              
                                 
                                    ϕ
                                 
                               shows the average number of computations for the intersection point of 
                                 
                                    λ
                                 
                               with a surface triangle and of the corresponding distance computation,


                              Iterations is the number of performed iterations, where 
                                 
                                    ϕ
                                 
                               shows the average and max shows the maximum number of iterations,


                              t (μs) shows the average location time.

All the quantities reflect values for one location query while max values show specific location queries where the appropriate value was maximal.


                     Table 1
                      corresponds to the point location on the surface. Such a situation is useful especially for applications where the target triangle 
                        
                           ω
                        
                      always exists and we need to find it. Thus the algorithm is searching until the triangle is found. The upper number of allowed iterations is irrelevant in this case and it is not restricted. The search behaves well since the opposite surface normals were used as input motion vectors which led to a suitable choice of the starting triangle.

On the other hand, if there is a possibility that the searched triangle 
                        
                           ω
                        
                      does not exist (as it is in the collision detection), the upper number of allowed iterations should be defined. For the second and the third variant of input data we limit the upper number of allowed iterations to 10 since it is a good compromise between performance and accuracy. See Table 2
                      for the tests of the second variant of input data (points generated near the surface). Since the number of iterations is restricted, triangle 
                        
                           ω
                        
                      may not be always found, despite the fact that it exists. Therefore, the number of located triangles 
                        
                           ω
                        
                      is also shown in Table 2 as Found # of 
                     
                        
                           Δ
                        
                      and shows the efficiency of the collision detection.

Although the upper number of allowed iterations is restricted to 10, the average results are worse than in Table 1. It is caused by the input motion vectors which are diverted from the opposite surface normals and it results in the worse choice of the first triangle. Let us denote that the haptic visualization is highly dependent on the specific behavior of the user, thus it is very difficult to measure it. Therefore, input data are generated randomly to provide more objective results. However, in haptic visualization, during the motion on the surface of the object, coherency can be used for the choice of the first triangle, as described in ‘Proposed method’. Moreover, the real motion vectors of the haptic probe are usually less diverted from the opposite surface normals. Both factors cause significantly better results in practical haptic visualization than is shown in Table 2.

As is shown in the table, efficiency is rather high in spite of a low number of iterations such as 10 (always more than 
                        
                           99
                           %
                        
                      of 
                        
                           ω
                        
                      triangles were found). Since the distance traveled by the haptic probe between two consecutive location queries is usually several times lower than 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                     , we have several attempts to detect the collision before the haptic probe enters the model. The probability that the haptic probe enters the model is therefore very low and we did not register it in practice.

The worst test results are on the brain model. It is caused mainly by its size (588k faces), complex shape (a lot of folds) and by the fact that the model consists of more components (the path sometimes does not exist). Although the coherence was not used in the tests and thus location queries are several times slower than in practice, algorithm is still fast enough for haptic visualization, even for big shaped-complicated models as is the brain model. Average time per one location query for the brain model is less than 0.14ms which corresponds to the average number of visited triangles (about 766) for this model and which is better than the requirements. As we can see, the longest walk visits almost 25k triangles (location time less than 3ms), but such cases are very rare and in practice where the coherence is often used in the choice of 
                        
                           α
                        
                     , we have not registered them. Moreover, an occasional execution of a little slower location queries may not be a noticeable problem in haptic visualization.

The tests of the third type of input data (points generated further from the surface in a little larger distance than 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                     ) are in Table 3
                     . The location is slower in comparison with other scenarios, but we must realize that there is no contact of the haptic probe with the surface in such a case. So there is no need of feedback computation. Moreover, since the distance is only a little greater than 
                        
                           
                              
                                 dist
                              
                              
                                 max
                              
                           
                        
                      from the surface, the collision detection is justified. However, in practice, we can skip collision detection in the cases where it is obviously useless, e.g., using several simple bounding objects.

Experiments presented above show that the proposed algorithm behaves well for haptic-related tasks as well as for more general problems. Moreover, it can handle mesh models consisting of several components (continuous path between components does not exist). It is provided by a repetitive random choice of the starting triangle.

The proposed location algorithm is very fast for cases where the haptic cursor is close to the surface. On the other hand, for cases where there is no collision, it is several times slower. But we must realize that in such a case there is no force acting against the user, thus the location query can be slower. Once the haptic probe is in the proximity of the surface, detection becomes very fast and an appropriate force feedback could be computed. This perfectly meets usual requirements for the haptic visualization.

Note that our algorithm can be scaled to comply with various criteria – at the first extreme case the location is very fast at a cost of increasing number of location errors. The second extreme case is perfect correctness of the location, but at a cost of computing time.

In our experiments we set the location parameters to meet haptics requirements (location time less than 1ms and negligible wrong location rate where the target triangle exists and location time less than 10ms where the target triangle does not exist).

We have also performed a haptic visualization test. In cases, where the target triangle does not exist, results were similar to results in Table 3. In cases, where the target triangle exists, the frame-to-frame coherence was utilized for the choice of the first triangle in the most location queries. Therefore, the performance indicators (No. of visited triangles, No. of performed tests, and No. of performed iterations) were significantly better than in Table 2. Average time for one location query was not measured, since it may be inaccurate for individual queries. However, according to other performance indicators, corresponding improvement of average time can be also expected. As it was mentioned above, all the practical haptic visualization tests may differ significantly, since they depend on the used model and mainly on the behavior of the user. Thus the specific measured values are not presented in the text.

@&#CONCLUSION@&#

We have presented the walking algorithm for a triangle location or collision detection problem on the surface (possibly changing) of triangulated 3D models. Although we focus mainly on its application in haptic visualization, the algorithm is also useful for general use. As it is shown in experiments, even for the biggest tested model which is complex-shaped and contains 588k triangles, the average location time is deeply under the required 1ms which is far better than other published methods. The main advantages of the presented algorithm are its capability of handling time-changing models or models consisting of several components, easiness of implementation and negligible memory requirements. The algorithm is also suitable for parallelization.

@&#ACKNOWLEDGMENT@&#

This work has been supported by the Ministry of Education, Youth and Sports of the Czech Republic, Project Kontakt No. LH11006, by University spec. research - 311, and by UWB grant SGS-2013-029 – Advanced Computing and Information Systems.

@&#REFERENCES@&#

