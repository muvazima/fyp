@&#MAIN-TITLE@&#Multiview feature distributions for object detection and continuous pose estimation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Multi-view model of object categories.


                        
                        
                           
                           Suitable to any type of image features, e.g. edges and coarse-scale gradients here.


                        
                        
                           
                           Performs detection, localization and continuous pose estimation in unified manner.


                        
                        
                           
                           Encode appearance at discrete training viewpoints and in-between.


                        
                        
                           
                           Competitive with best task-specific methods, with framework generally applicable.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Appearance-based object recognition

Object detection

Pose estimation

Hough voting

Edges and shape models

Viewpoint synthesis

@&#ABSTRACT@&#


               
               
                  This paper presents a multiview model of object categories, generally applicable to virtually any type of image features, and methods to efficiently perform, in a unified manner, detection, localization and continuous pose estimation in novel scenes. We represent appearance as distributions of low-level, fine-grained image features. Multiview models encode the appearance of objects at discrete viewpoints, and, in addition, how these viewpoints deform into one another as the viewpoint continuously varies (as detected from optical flow between training examples). Using a measure of similarity between an arbitrary test image and such a model at chosen viewpoints, we perform all tasks mentioned above with a common method. We leverage the simplicity of low-level image features, such as points extracted along edges, or coarse-scale gradients extracted densely over the images, by building probabilistic templates, i.e. distributions of features, learned from one or several training examples. We efficiently handle these distributions with probabilistic techniques such as kernel density estimation, Monte Carlo integration and importance sampling. We provide an extensive evaluation on a wide variety of benchmark datasets. We demonstrate performance on the “ETHZ Shape” dataset, with single (hand-drawn) and multiple training examples, well above baseline methods, on par with a number of more task-specific methods. We obtain remarkable performance on the recognition of more complex objects, notably the cars of the “3D Object” dataset of Savarese et al. with detection rates of 
                        
                           92.5
                           %
                        
                      and an accuracy in pose estimation of 
                        
                           91
                           %
                        
                     . We perform better than the state-of-the-art on continuous pose estimation with the “rotating cars” dataset of Ozuysal et al. We also demonstrate particular capabilities with a novel dataset featuring non-textured objects of undistinctive shapes, the pose of which can only be determined from shading, captured here by coarse scale intensity gradients.
               
            

This paper is concerned with the joint recognition and pose estimation of object categories in 2D images. Recognizing that these two tasks represent two sides of a same problem, we tackle them in a unified approach. In general, the pose (3D orientation) of objects cannot be inferred from just one type of image information, e.g. silhouette and edges, to cite a common example. Additional visual cues may be necessary, such as the shading onto the object surface. A key point of our contributions is thus to provide techniques generally applicable in this regard, even to low-level, dense and/or non-descriptive image features. To perform continuous pose estimation, our object model captures, in addition to the appearance at discrete training viewpoints, the deformations between these, detected from the optical flow between training examples. A measure of similarity between generated views of the object (possibly at an unseen viewpoint) and a test image allows us to perform detection, recognition, and pose estimation in a unified manner. The following paragraphs present the principal motivations and key points of the method, comparing them to existing related work. Parts of these contributions were introduced in earlier publications [1,2].

The recognition of objects in 2D images encompasses a number of tasks, detailed below, which are often considered as separate research problems. They are however closely related, and we handle them all with the same model and methods. Notably, we do not train discriminative models, which is the usual approach for the classification tasks.
                           
                              
                                 Localization The goal is to identify the parts of the test image that belong to the object of interest, versus the parts of the image that correspond to background clutter. The result of localization is typically a set of bounding boxes, which encircle candidate objects in the image, each accompanied with a detection score. We handle this task with an algorithm similar to the generalized Hough voting scheme. The model of the object can be learned from one or several training examples: we handle both cases identically by modeling distributions of features through kernel density estimation (see Section 2).


                                 Detection One must decide whether the object of interest appears in the test image or not. This task can be performed alone, or by setting a threshold on scores of localizations to obtain binary detection results.


                                 Classification (among objects or among discrete poses) One must determine which object or which viewpoint among learned ones appears in the image. This traditionally involves learning discriminative classifiers. In our method however, we simply build generative models independently for each learned object or viewpoint, and determine the best match from the similarity measured between the test image and one of those models.


                                 Continuous viewpoint (pose) estimation This more challenging task is handled by extending our generative models to also synthesize unseen (untrained) viewpoints.

The method for performing recognition of objects in 2D images depends heavily on the internal representation chosen to model the appearance of those objects. We are interested in building models of appearance for object categories (or “classes”) rather than specific instances, thus capable of recognizing, to some extent, unseen objects that are similar to a category learned from a few training examples. The goal is for example to train the system with a set of different cars, then to recognize the pose of a new, unseen car. The categories in such a scenario are defined implicitly by the training instances used as examples. In the proposed approach, the appearance of the object under a specific viewpoint is modeled as the distribution of low-level image features, represented, in a non-parametric manner, by the actual image features of one or several training images of the objects under that specific viewpoint. We therefore handle variability in appearance in a probabilistic way; this variability among the training examples can equally come from different objects of a same category, or from variations of appearance of a unique object, e.g. observed under different conditions of illuminations.

We choose to model the 2D appearance of the objects without explicit knowledge of their underlying 3D shape. The motive for this choice is to handle more easily and naturally the variability within categories, both in appearance and shape. As a result, the model is thus trained with simple example images. Existing methods have used explicit, geometrical, 3D models of objects [3], but the modeling of variations in appearance is generally limited in regards with shape [4,5]. One exception is the work of Glasner et al. [6], which uses structure-from-motion to reconstruct accurate 3D models from the training images. They then account for within-category variability simply by merging multiple exemplars in their non-parametric model, in a fashion very similar to the one we use (with our 2D training examples). One drawback of their approach is the initial need for a large number of views to reconstruct accurate 3D models. In comparison, our exemplar-based model can use an arbitrary number of views, which do not need to overlap, and the model can be incrementally updated as more views become available.

Object localization and detection among clutter is commonly achieved with variants of either the “sliding window” or the “Hough voting” approaches. The former (used e.g. in [7]) uses a binary classifier, which is evaluated on a uniform sample of image locations and scales. Such an exhaustive search may prove computationally expensive, and many heuristics have been proposed to alleviate this issue [8]: salient regions, coarse-to-fine-search, etc. Voting techniques based on the well-known generalized Hough transform [9] provides another way to alleviate the complexity issue. Probabilistic formulations of this voting technique have been proposed through the implicit shape models [10,11]. Our algorithm for detection uses this voting scheme, applied to low-level, dense image features. Hough voting was extended to discriminative framework by Maji and Malik [12], by computing optimal weights to the image features of the model. They obtained excellent results, further improved by a subsequent verification step, in which the initial detections are rescored by an SVM-based classifier. We reuse this idea of weighting parts of the learned model; the exact procedure is slightly different, and suited to our non-discriminative features. Although not a central element of our contributions, we will show that this weighting often brings substantial improvements.

The type of image features used to encode the appearance of the objects is a crucial choice. Some methods historically used of the appearance of the object as a whole [13–15], but with the common downsides of poor robustness to occlusions and a need for large numbers of training views. At the opposite end, feature-based methods have relied on “interest points”, precisely located in the images, and characterized by hand-designed descriptors of local appearance, such as SIFT descriptors [16]. Those discrete points can then be matched between the test image and the training examples [3]. While this approach has proved to be highly successful and efficient in many cases, the extraction of such discriminant image features cannot be relied upon in general cases, as it often fails with non-textured objects. The basic approach also does not readily extend to variability within categories. A recent trend is to describe image contents with similar descriptors of appearance over a dense grid across the image, such as done by the successful histograms of oriented gradients (HOG) [7], also used within the state-of-the-art detector of Felzenszwalb et al. [17]. The idea behind those descriptors is to capture statistics or distributions of primitive characteristics (such as intensity gradients) over local image regions. We believe that this approach is indeed the most generally-applicable one, and is the central motivation for our technique. Similarly to, e.g. HOGs, our “distributions of features” capture local statistics densely over the images, but we do not depend on hand-designed descriptors, and we offer a unique formulation suitable to different types of image features. Another notable difference of our method with HOGs is to use gradients extracted at a coarse scale, intended to capture shape (rather than pure appearance) of smooth surfaces, whereas HOGs were most successful with gradients extracted at a much smaller scale, thus essentially capturing sharp transitions like edges.

Most current, state-of-the-art methods for object recognition rely on the use of image edges (e.g. [18,19], among many others), seen as an efficient representation of the silhouette and shape of objects. The typical technique basically consists in building intermediate representations such as contour fragments, which can then be matched discriminatively between training and test images, and used e.g. in a Hough voting scheme. Our approach, which leverages the simplicity of low-level, fine-grained image features, can be applied to edges by considering all edge pixels of the image as features. At the cost of higher computational costs, this approach leads to excellent results as well, while satisfying our aim for a general and straightforward formulation.

A large area of research has focused on the modeling and detection of deformable shapes (see [18] for a review). Interestingly, our simple approach proves competitive with some of those techniques, as demonstrated on the ETHZ shape dataset. Although we neither model continuous contours nor their variations explicitly, our low level features (edge points) can encode similar variations to some degree. Another advantage of our method is its ability to learn shape models similarly from a single or multiple examples, and from only loosely segmented images (with a bounding box). Such capabilities are not commonplace in the domain of shape matching, but were also offered by the work of Ferrari et al. [18].

Finally, our capability of handling dense image features is demonstrated and used with great advantage with intensity gradients, extracted at a coarse-scale over the whole images. Using such gradients provides unique capabilities, as it allows one (1) to effectively handle non-textured objects (see Section 5.6), and, even more importantly, (2) to resolve cases where edges alone would only offer ambiguous information on the presence or the pose of an object in a scene. Indeed, the shading over homogeneous surfaces, captured by such gradients, may sometimes be the sole relevant clue, in particular to identify the exact pose of certain objects, or, for example, to differentiate between hollow versus full objects of similar shapes (see our experiments in Section 5.6).

Object recognition with 2D training examples typically uses viewpoint-specific models, e.g. a model for cars seen from the front, and another for cars seen from the side. Recent contributions have included more and more techniques that handle multiple registered training viewpoints. The object in the test image is then matched against one of these viewpoints and allows performing a coarse estimation of its pose (or 3D orientation) also called pose classification. We refer to this basic approach as a “nearest-neighbor” pose estimation. Some applications (robotic interaction and grasping for example) require however a more precise estimation of the pose [20,21]. This capability was commonly reserved to recognition methods using 3D object models. As discussed above though, they do not cope well with object categories, which are clearly very challenging with regards to the task of pose estimation. Few appearance-based methods have been designed to provide this capability [14]. Most recent multiview models of appearance consider the different training viewpoints independently [21–25], while others try to match and link features across viewpoints [26–28]. Savarese and Fei-Fei [27], for example, model an object as a collection of planar parts that can appear in different views. We follow an intermediate approach, by storing independently the image features that make up the different views, but we also store, along with every each image feature, how its appearance varies with respect to the pose of the object. The multiview models mentioned above only performed localization and classification such as “frontal view” or “side view”, whereas we allow precise, continuous pose estimation.

Simple techniques have been proposed to improve the precision of nearest-neighbor pose classification. They typically involve voting in the 3D pose space followed by averaging [21] or probabilistic smoothing schemes [1,25,29], leading to a precision beyond the resolution of viewpoints given as training examples. While those simple techniques have sometimes given very interesting results, we rather chose, in the work presented here, to explicitly detect, and include in the model, the changes of appearance between the discrete viewpoints seen during training (practically, how image features translate in the image, and thus how the appearance “deforms” between neighboring viewpoints). This information extends our generative model, which can now synthesize arbitrary, untrained viewpoints. We can then finely optimize the 3D pose, starting from the initial nearest-neighbor estimates. Let us mention the work of Torki and Elgammal [30]. In their radically different approach to appearance-based pose estimation, they learn a direct regression from local image features to the pose of the object. This original approach recovers a precise pose, but cannot handle significant clutter or occlusions, and the accurate pose estimation depends on the (supervised) enforcement of a one-dimensional manifold constraint (corresponding to the 1D rotation of the object in the training examples). It is not clear how that approach would extend to the estimation of the full 3D pose of an object. Other recent works such as [31] have looked further at manifold modeling for appearance-based pose estimation, but with an evaluation limited to fairly simple conditions, and the performance of such methods for detection in cluttered scenes is not obvious.

During an off-line training phase, we use an optical flow algorithm between pairs of images to detect how the appearance of each training object varies between these viewpoints. The image features extracted from one of these images can then be deformed into the other, and the interpolation for intermediate viewpoints is straightforward. We thereby obtain a generative model that synthesizes the appearance of the object in any (possibly unseen) viewpoint. This procedure is related to the technique of morphing in computer graphics [32–34], with the difference that we are considering arbitrary numbers of input views, and we do not rely on established correspondences between specific landmarks of the input views. This similarly contrasts with the competing method of Savarese and Fei-Fei [35], which does use specific correspondences between nearby views. Our advantage is to handle non-textured objects with little detail. Although some global consistency in the detected deformations is enforced by the optical flow algorithm, each image feature independently stores its possible deformations. This does not limit the model to a particular class of transformations. In comparison, Savarese and Fei-Fei [35] specifically models affine transformations of object parts, assuming that objects are made of large planar parts. We also use a sparse set of training views (typically spaced about 
                           
                              20
                              °
                           
                         apart on the viewing sphere) and do not require videos or dense sequences of images to track features between frames, as opposed to Sun et al. [36].

Our main contributions can be summarized in the following points.
                           
                              1.
                              We present a general framework for modeling the appearance of objects and object categories, suitable to virtually any type of image features, applicable for detection and recognition without relying on hand-designed local visual descriptors, while still providing performance and efficiency on par with state-of-the-art – arguably more complex – methods.

We show how to handle dense, unmatchable image features, such as coarse-scale intensity gradients. This ultimately enables the method to recognize objects without texture, and to handle cases where shading constitutes the sole source of unambiguous visual information.

We provide a technique for identifying, and storing, within a multiview model of appearance, how the appearance varies between discrete training viewpoints. This ultimately allows performing continuous pose estimation of an object in a novel scene, without relying on an explicit 3D model of the object. This also readily applies to object categories, and not only to specific objects.

This section presents our model of appearance with a bottom-up description. We start by turning a set of image features of a given image into a “distribution of features”, then use those representations to form our model that includes several viewpoints, and possibly several training examples for each viewpoint. We finally show how to detect and recognize those training views in a novel test image.

Our approach is based on a representation of images as continuous probability distributions of image features. The motivation for representing images as distributions is twofold. First, this representation accounts for the inevitable uncertainty of the description of any single image, due to e.g. image noise, quantization errors, uncertainty during feature extraction, etc. Secondly, it also provides, as we will see in the next section, a way of modeling variability in appearance of an object or object category, e.g. given several different examples of this category. It will also give us a more abstract representation of the images that is convenient to manipulate with existing probabilistic techniques, and that generally applies to any type of image features. The approach is first applied and presented for a test image – in which we want to recognize the object of interest – while the next section will then apply it to the training examples.

We start off by extracting, from a given test image, different types of features (detailed in Section 4.1), each type denoted by an index 
                           
                              f
                              =
                              1
                              ,
                              …
                              ,
                              F
                           
                        . These can be as simple as the pixels belonging to edges (which we call “edge points”), or to the value of the intensity gradients for all pixels of the image (“gradient points”). In general, each feature x is thus characterized by (1) its position in the image, noted 
                           
                              x
                              .
                              pos
                           
                         (
                           
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                           
                        ) and (2) some appearance attributes, noted 
                           
                              x
                              .
                              app
                           
                        . In the case of edge points, we use, as an attribute, the local orientation of the edge (an angle in 
                           
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                                 
                                    +
                                 
                              
                              =
                              [
                              0
                              ,
                              
                              π
                              [
                           
                        ); in the case of gradient points, we use the orientation and the magnitude of the gradient. The contents of a given test image form thus, for each type f of features, a set 
                           
                              
                                 
                                    test
                                 
                                 
                                    f
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 
                                    i
                                 
                              
                           
                        , with 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    A
                                 
                                 
                                    f
                                 
                              
                           
                        , the domain of these features. For example with edge points, 
                           
                              
                                 
                                    A
                                 
                                 
                                    edges
                                 
                              
                              =
                              
                                 
                                    R
                                 
                                 
                                    2
                                 
                              
                              ×
                              
                                 
                                    S
                                 
                                 
                                    1
                                 
                                 
                                    +
                                 
                              
                           
                         (see Section 4.1 for details).

We now show how to turn such a set of discrete image features (from a given test image) into a continuous probability distribution. We define and represent such distributions over the appearance space of image features (
                           
                              
                                 
                                    A
                                 
                                 
                                    f
                                 
                              
                           
                        ) in a non-parametric manner, through kernel density estimation (KDE). With this procedure, all image features are used as particles supporting simple kernels, the sum of which represents a continuous distribution. Formally, for each type of image features f, we use the set of features 
                           
                              
                                 
                                    test
                                 
                                 
                                    f
                                 
                              
                           
                         extracted from our test image to define the distribution
                           
                              (1)
                              
                                 
                                    
                                       ϕ
                                    
                                    
                                       
                                          
                                             test
                                          
                                          
                                             f
                                          
                                       
                                    
                                    
                                       f
                                    
                                 
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                test
                                             
                                             
                                                f
                                             
                                          
                                       
                                    
                                 
                                 wt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 
                                 N
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 pos
                                 ;
                                 
                                 x
                                 .
                                 pos
                                 ,
                                 
                                    
                                       σ
                                    
                                    
                                       pos
                                    
                                 
                                 )
                                 
                                 
                                    
                                       K
                                    
                                    
                                       f
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 app
                                 ;
                                 
                                 x
                                 .
                                 app
                                 )
                                 ,
                              
                           
                        with 
                           
                              x
                              ∈
                              
                                 
                                    A
                                 
                                 
                                    f
                                 
                              
                              ,
                              
                              N
                           
                         a Gaussian kernel for the position of the features, 
                           
                              
                                 
                                    K
                                 
                                 
                                    f
                                 
                              
                           
                         a kernel for their appearance attributes (see Section 4.1), and 
                           
                              wt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         the weight of the feature 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                        . Those weights are set uniformly for the features of a test image, i.e. 
                           
                              wt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              
                                 
                                    1
                                 
                                 
                                    |
                                    
                                       
                                          test
                                       
                                       
                                          f
                                       
                                    
                                    |
                                 
                              
                              
                              ∀
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              ∈
                              
                                 
                                    test
                                 
                                 
                                    f
                                 
                              
                           
                        . This representation with KDE will be reused for the training images, where the weights will then take a more complex form (Section 2.4). Practically, Eq. (1) gives us a probability density function that can be easily evaluated for any x. For example, in the case of edge points, we can evaluate the probability of observing a horizontal edge at a specific location in the image.

We have represented our test image as continuous distributions of image features. We will now similarly apply that approach to the training images. Two differences are worth mentioning though.

First, we may observe the object of interest under multiple viewpoints. Each training image t corresponds to a viewpoint 
                           
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                              ∈
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                           
                         (a point on the viewing sphere), and gives, a set of features 
                           
                              
                                 
                                    train
                                 
                                 
                                    
                                       
                                          v
                                       
                                       
                                          t
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                         for each type of feature f (defined similarly to the sets 
                           
                              
                                 
                                    test
                                 
                                 
                                    f
                                 
                              
                           
                         above). Those multiple viewpoints are considered independently at this point, and they each define distributions 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                t
                                             
                                          
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                         as in Eq. (1). Only in Section 3 will we consider multiple viewpoints together, in order to perform continuous pose estimation. As a first step though, we are only interested in recognizing (approximately at least) one of the discrete viewpoints provided as the training examples.

Second, we may be provided with training images of several, different objects (object “instances”) representative of an object category. We assume that all training images are aligned and at the same scale, which can be practically done automatically as explained in Section 5. We now want our distributions of features to reflect statistics relevant to all the different training examples. This is straightforward within our formulation with a KDE: for each viewpoint 
                           
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                           
                        , we simply include, in the set of features 
                           
                              
                                 
                                    train
                                 
                                 
                                    v
                                 
                                 
                                    f
                                 
                              
                           
                        , the features extracted from all training images corresponding to that viewpoint (Fig. 1
                        ). The resulting distributions 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          v
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                        , as defined earlier, are then representative of the occurrence of image features among all those training examples together, and they constitute our model of appearance of an object category. Consequently, the appearance of that category is thus defined implicitly by the instances provided as training examples.

We now would like to detect, or recognize the learned object in the test image. The solution to this task consists in the optimal set of in-plane transformations 
                           
                              
                                 
                                    w
                                 
                                 
                                    ∗
                                 
                              
                           
                         (a translation, rotation and scaling in the image) and viewpoint (out-of-plane transformations) 
                           
                              
                                 
                                    v
                                 
                                 
                                    ∗
                                 
                              
                           
                         (
                           
                              ∈
                              
                                 
                                    S
                                 
                                 
                                    2
                                 
                              
                           
                        ), which corresponds to the training viewpoint recognized in the test image. Let us mention, as a side note, that this result 
                           
                              (
                              
                                 
                                    v
                                 
                                 
                                    ∗
                                 
                              
                              ,
                              
                                 
                                    w
                                 
                                 
                                    ∗
                                 
                              
                              )
                           
                         presents 6 degrees of freedom (DoF), and that it can be equally described in the image space (as we do) or in the “world” space (as Euclidean coordinates for position and orientation). The latter is usually preferred in the field of robotics, and commonly called the 6-DoF pose of the object. Both representations are however equivalent and interchangeable, provided the calibration of the camera.

We will first present how to measure the visual similarity between the test image and the learned object at a specific viewpoint and in-plane transformations. We will then provide an algorithm to identify the optimal set of such transformations, determining the local maxima of that similarity. At this point, we still consider the training viewpoints independently, and thus perform a “nearest-neighbor” classification of the viewpoint. This will serve as a starting pointer later, for a local optimization procedure to perform continuous pose estimation (Section 3).

Let us consider a test image is represented by the distributions of features 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    test
                                 
                                 
                                    f
                                 
                              
                           
                        , and a specific training view t represented by 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          v
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                        . This training view may appear in the test image under any similarity transformations w (in-plane translation, rotation, scaling), trivially applied by a function 
                           
                              
                                 
                                    transform
                                 
                                 
                                    w
                                 
                              
                              (
                              x
                              )
                           
                        . Accounting for such transformations, we measure the similarity between the test and training views with the cross-correlation of the distributions
                           
                              (2)
                              
                                 
                                    
                                       
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      test
                                                   
                                                   
                                                      f
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                          
                                          ★
                                          
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      train
                                                   
                                                   
                                                      w
                                                   
                                                   
                                                      f
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                       
                                    
                                 
                                 (
                                 w
                                 )
                                 =
                                 
                                    ∫
                                    
                                       
                                          
                                             A
                                          
                                          
                                             f
                                          
                                       
                                    
                                 
                                 
                                    
                                       ϕ
                                    
                                    
                                       
                                          
                                             test
                                          
                                          
                                             f
                                          
                                       
                                    
                                    
                                       f
                                    
                                 
                                 
                                    
                                       
                                          x
                                       
                                    
                                 
                                 
                                 
                                    
                                       ϕ
                                    
                                    
                                       
                                          
                                             train
                                          
                                          
                                             v
                                          
                                          
                                             f
                                          
                                       
                                    
                                    
                                       f
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                transform
                                             
                                             
                                                w
                                             
                                          
                                          (
                                          x
                                          )
                                       
                                    
                                 
                                 
                                 d
                                 x
                                 .
                              
                           
                        
                     

To efficiently obtain an approximate evaluation the integral of Eq. (2), we use Monte Carlo integration [37]. This involves drawing samples 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         (
                           
                              ℓ
                              =
                              1
                              ,
                              …
                              ,
                              L
                           
                        ) from the distribution 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    test
                                 
                                 
                                    f
                                 
                              
                           
                         (see Section 4.3), and computing the following sum:
                           
                              (3)
                              
                                 
                                    
                                       
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      test
                                                   
                                                   
                                                      f
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                          
                                          ★
                                          
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      train
                                                   
                                                   
                                                      v
                                                   
                                                   
                                                      f
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                       
                                    
                                 
                                 (
                                 w
                                 )
                                 
                                 ≈
                                 
                                 
                                    
                                       1
                                    
                                    
                                       L
                                    
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                       
                                          L
                                       
                                    
                                 
                                 
                                    
                                       ϕ
                                    
                                    
                                       
                                          
                                             train
                                          
                                          
                                             v
                                          
                                          
                                             f
                                          
                                       
                                    
                                    
                                       f
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                transform
                                             
                                             
                                                w
                                             
                                          
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

We can substitute the distribution 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          v
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                         by its definition with KDE (as in Eq. (1)). Assuming this distribution is represented by 
                           
                              
                                 
                                    L
                                 
                                 
                                    ′
                                 
                              
                           
                         particles 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                           
                         (either the original image features extracted from the training images, or a resampled set of those as will be discussed in Section 4), we have
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      test
                                                   
                                                   
                                                      f
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                          
                                          ★
                                          
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      train
                                                   
                                                   
                                                      v
                                                   
                                                   
                                                      f
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                       
                                    
                                 
                                 (
                                 w
                                 )
                                 ≈
                                 
                                    
                                       1
                                    
                                    
                                       
                                          
                                             LL
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                       
                                          L
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                       
                                          
                                             
                                                L
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                 
                                 wt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 
                                 N
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 pos
                                 ;
                                 
                                    
                                       transform
                                    
                                    
                                       w
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 .
                                 pos
                                 )
                                 ,
                                 
                                    
                                       σ
                                    
                                    
                                       pos
                                    
                                 
                                 )
                                 
                                 
                                    
                                       K
                                    
                                    
                                       f
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 app
                                 ;
                                 
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 .
                                 app
                                 )
                                 .
                              
                           
                        
                     

Now, taking into account several types f of image features (
                           
                              f
                              =
                              1
                              ,
                              …
                              ,
                              F
                           
                        ), the full similarity measure between two images finally uses the product over f of the expression above, which gives
                           
                              (5)
                              
                                 
                                    
                                       similarity
                                    
                                    
                                       test
                                       ,
                                       
                                          
                                             train
                                          
                                          
                                             v
                                          
                                       
                                    
                                 
                                 (
                                 w
                                 )
                                 =
                                 
                                    
                                       
                                          ∏
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                 
                                    
                                       
                                          
                                             
                                                ϕ
                                             
                                             
                                                test
                                             
                                             
                                                f
                                             
                                          
                                          
                                          ★
                                          
                                          
                                             
                                                ϕ
                                             
                                             
                                                
                                                   
                                                      train
                                                   
                                                   
                                                      v
                                                   
                                                
                                             
                                             
                                                f
                                             
                                          
                                       
                                    
                                 
                                 (
                                 w
                                 )
                                 .
                              
                           
                        
                     

We now have the core of the proposed method, with Eqs. (4) and (5): we can easily evaluate the likelihood of observing, in the test image, the object under the viewpoint v and in-plane transformations w. The solution to the problem of object localization corresponds the maxima of Eq. (5), i.e.
                           
                              (6)
                              
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       ∗
                                    
                                 
                                 ,
                                 
                                    
                                       w
                                    
                                    
                                       ∗
                                    
                                 
                                 )
                                 =
                                 arg
                                 
                                    
                                       
                                          max
                                       
                                       
                                          v
                                          ,
                                          w
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                similarity
                                             
                                             
                                                test
                                                ,
                                                
                                                   
                                                      train
                                                   
                                                   
                                                      v
                                                   
                                                
                                             
                                          
                                          (
                                          w
                                          )
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

Our algorithm to solve this maximization problem is detailed in Section 4.2. It efficiently computes the values of the objective function over all image locations (in-plane translations), with a method similar to a Hough voting using samples drawn from our distributions of features.

We now present how to assign adequate weights to samples drawn from the trained model. The model of appearance presented in Sections 2.1 and 2.2 is merely a convenient way of representing the appearance of object categories. Since our goal is specifically to use this model to detect an object among clutter, and to determine its actual pose, we wish to give more weight its parts that are most informative to those tasks. As will be detailed in the Implementation section (Section 4), we choose to preselect samples offline from the trained model for efficiency. Therefore, the weights associated to these samples can also be computed in a pre-processing step, using the procedure described below.

Weighting training data in the context of object recognition is common among many existing methods [12,38–40], where it has shown to increase performance significantly. In comparison to existing methods, our procedure is better suited to non-discriminative low-level image features, and does not rely on large amounts of training examples. It iteratively uses a validation test set to weight each feature relative to how informative it is to discriminate the appearance at a specific pose, versus other poses and against background clutter.

The procedure is performed for each type f of image feature separately; we omit the superscripts f in the following paragraph to lighten the notations. We initially run the algorithm for detection and pose estimation (Section 2.3) with uniform weights on all image features of the training data. The idea is then to decrease the relative weight of those features that lead to incorrect results, from false positive detections (object identified in the background clutter) or from the recognition of incorrect poses (e.g. a car facing right identified as a car facing left). For each training view t (corresponding to a viewpoint 
                           
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                           
                        ), we obtain some incorrect results 
                           
                              
                                 
                                    
                                       
                                          (
                                          
                                             
                                                v
                                             
                                             
                                                n
                                             
                                          
                                          ,
                                          
                                             
                                                w
                                             
                                             
                                                n
                                             
                                          
                                          )
                                       
                                    
                                 
                                 
                                    n
                                 
                              
                           
                         (
                           
                              n
                              =
                              1
                              ,
                              …
                              ,
                              N
                           
                        ) to be used as negative examples (typically a pose estimate off by 
                           
                              20
                              °
                           
                         or more, or an overlap of the detection bounding box less than 0.5 with the ground truth). We then update the weights of all image features 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         of the training view t according to a three step rule:
                           
                              (7)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                
                                                   wt
                                                
                                                
                                                   ′
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             =
                                             1
                                             -
                                             
                                                
                                                   1
                                                
                                                
                                                   N
                                                
                                             
                                             
                                                
                                                   
                                                      ∑
                                                   
                                                   
                                                      n
                                                   
                                                
                                             
                                             
                                                
                                                   ϕ
                                                
                                                
                                                   
                                                      
                                                         train
                                                      
                                                      
                                                         
                                                            
                                                               v
                                                            
                                                            
                                                               t
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            transform
                                                         
                                                         
                                                            
                                                               
                                                                  w
                                                               
                                                               
                                                                  n
                                                               
                                                               
                                                                  -
                                                                  1
                                                               
                                                            
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             wt
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             ←
                                             λ
                                             
                                             
                                                
                                                   wt
                                                
                                                
                                                   ′
                                                
                                             
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             +
                                             (
                                             1
                                             -
                                             λ
                                             )
                                             
                                             wt
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             wt
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             ←
                                             wt
                                             (
                                             
                                                
                                                   x
                                                
                                                
                                                   i
                                                
                                             
                                             )
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               ∑
                                                            
                                                            
                                                               i
                                                            
                                                         
                                                      
                                                      wt
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The first of these steps evaluates the contribution of the image feature 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         to the negative examples (incorrect results), by simply measuring how well that feature “matches” with the training view superimposed onto the test view (according to the in-plane transformations 
                           
                              
                                 
                                    w
                                 
                                 
                                    n
                                 
                              
                           
                        ). The weights are then updated (step 2, with learning rate 
                           
                              λ
                              =
                              0.5
                           
                        , typically), and normalized as to always sum to 1 (step 3). The effect of these steps is thus to actually decrease the relative weight of the features that lead to misdetections of misclassifications of the pose. The whole procedure is then be repeated iteratively: detection is performed, again, on the same validation dataset, but with the new weights for the model, which gives different negative examples, that are used with the three step rule to update the weights. As shown through our experiments, stable weights are usually reached within the order of 4–5 iterations (Section 5.2, Fig. 9).

Note that, if no validation test set is available, the weights can still be computed as described above by reusing, as validation test set, the training images themselves. When performing detection on the training images, the difficulty is then essentially to recognize the object in one viewpoint versus the other viewpoints (and not versus clutter). As a result, the weights then learned from negative results will help to differentiate each training viewpoint: higher weights are given to the image features that are very informative to a specific viewpoint (Fig. 2
                        ). This effect is similar to the one obtained in earlier work [1].

Finally, let us remark that the weighting scheme proposed here could be compared to the classical “term frequency – inverse document frequency” approach used in text mining, where high weights are assigned to words (image features, in our application) specific to a class of documents to retrieve (a specific viewpoint, here), relative to their likelihood of occurrence in general (in background clutter, in our case) [41].

The appearance model presented so far treats the different viewpoints provided in the training data independently, and performs a coarse pose estimation, or pose classification, by recognizing one of those discrete viewpoints. Our objective is now to provide a more accurate estimate of the pose, beyond the resolution of the training viewpoints. We first present a generative model capable of synthesizing the appearance of the learned object (or object category) at an arbitrary viewpoint, interpolating between the known views, then we show how to use it for a local optimization of initial (coarse) results.

The goal of our generative model is basically to fill in the gaps between the discrete training viewpoints. Although it is sometimes possible to establish explicit correspondences between image features of nearby training views, this approach could not be relied upon in general, as it does not generalize to dense or non-discriminative image features. Therefore, we chose instead to identify dense deformations between pairs of adjacent training views, using an optical flow algorithm. Those deformations are then combined and linearly interpolated to deform the image features of the training images into any arbitrary viewpoint (Figs. 3 and 4
                        
                        ). More precisely, we first define a function 
                           
                              dist
                              (
                              v
                              ,
                              
                                 
                                    v
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         that measures the angular distance between two viewpoints on the viewing sphere. We define the set of all pairs of neighboring training viewpoints 
                           
                              V
                              =
                              
                                 
                                    
                                       (
                                       t
                                       ,
                                       
                                          
                                             t
                                          
                                          
                                             ′
                                          
                                       
                                       )
                                       :
                                       dist
                                       (
                                       
                                          
                                             v
                                          
                                          
                                             t
                                          
                                       
                                       ,
                                       
                                          
                                             v
                                          
                                          
                                             
                                                
                                                   t
                                                
                                                
                                                   ′
                                                
                                             
                                          
                                       
                                       )
                                       <
                                       th
                                    
                                 
                              
                           
                         (with a threshold of 
                           
                              th
                              =
                              20
                              °
                           
                         typically). During an off-line training phase, an optical flow algorithm [42] is applied on all pairs of views 
                           
                              (
                              t
                              ,
                              
                                 
                                    t
                                 
                                 
                                    ′
                                 
                              
                              )
                              ∈
                              V
                           
                        .
                           1
                           When building a model of an object category, the deformations are detected using pairs of views of a single object instance at a time, since the detection of optical flow requires fairly similar images to succeed.
                        
                        
                           1
                         Each pair produces a dense flow map 
                           
                              
                                 
                                    UV
                                 
                                 
                                    t
                                    →
                                    
                                       
                                          t
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              (
                              x
                              )
                           
                         that corresponds, in our case, to the local deformation (translation in the image plane) undergone at an image location x when moving from viewpoint 
                           
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                           
                         to 
                           
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                           
                        . We can now define our generative model noted 
                           
                              
                                 
                                    train
                                 
                                 
                                    v
                                 
                              
                           
                        , which corresponds to the set of image features defining the appearance of the object at a novel viewpoint v, as the union of image features of nearby training views, translated appropriately using the precomputed deformations. Formally,
                           
                              (8)
                              
                                 
                                    
                                       train
                                    
                                    
                                       v
                                    
                                 
                                 =
                                 
                                    
                                       
                                          ⋃
                                       
                                       
                                          
                                             
                                                v
                                             
                                             
                                                t
                                             
                                          
                                          :
                                          dist
                                          (
                                          
                                             
                                                v
                                             
                                             
                                                t
                                             
                                          
                                          ,
                                          v
                                          )
                                          <
                                          th
                                       
                                    
                                 
                                 
                                    
                                       deform
                                    
                                    
                                       
                                          
                                             v
                                          
                                          
                                             t
                                          
                                       
                                       →
                                       v
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                train
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The function 
                           
                              
                                 
                                    deform
                                 
                                 
                                    
                                       
                                          v
                                       
                                       
                                          t
                                       
                                    
                                    →
                                    v
                                 
                              
                           
                         adjusts the position of the image features of a training view 
                           
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                           
                         into the novel viewpoint v. It uses a linear combination of two
                           2
                           The use of two precomputed deformations accounts for the two dimensions of the viewing sphere.
                        
                        
                           2
                         precomputed deformations, in order to translate each image feature adequately. We denote these two deformations by the indices of the two viewpoints between which we computed them, and call them 
                           
                              (
                              t
                              ,
                              
                                 
                                    t
                                 
                                 
                                    ′
                                 
                              
                              )
                           
                         and 
                           
                              (
                              t
                              ,
                              
                                 
                                    t
                                 
                                 
                                    ″
                                 
                              
                              )
                           
                        . They are chosen from 
                           
                              V
                           
                         so that the novel viewpoint can be reached (on the viewing sphere) by a positive linear combination of them. Therefore, 
                           
                              ∃
                              α
                              ,
                              
                              β
                              ∈
                              
                                 
                                    R
                                 
                                 
                                    +
                                 
                              
                              :
                              v
                              =
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                              +
                              α
                              (
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                              -
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                              )
                              +
                              β
                              (
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ″
                                       
                                    
                                 
                              
                              -
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                              )
                           
                        . Practically, this means that the viewpoints 
                           
                              
                                 
                                    v
                                 
                                 
                                    t
                                 
                              
                              ,
                              
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ″
                                       
                                    
                                 
                              
                           
                         cannot be collinear on the viewing sphere. In the simple case where training viewpoints spaced on a grid (as in the experiments of Section 5), we simply choose 
                           
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ′
                                       
                                    
                                 
                              
                           
                         and 
                           
                              
                                 
                                    v
                                 
                                 
                                    
                                       
                                          t
                                       
                                       
                                          ″
                                       
                                    
                                 
                              
                           
                         respectively along the changes in azimuth and elevation. It is now straightforward to define the function that combines the two deformations:
                           
                              (9)
                              
                                 
                                    
                                       deform
                                    
                                    
                                       
                                          
                                             v
                                          
                                          
                                             t
                                          
                                       
                                       →
                                       v
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                train
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          :
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          .
                                          pos
                                          =
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          .
                                          pos
                                          +
                                          α
                                          
                                          
                                             
                                                UV
                                             
                                             
                                                t
                                                →
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      ′
                                                   
                                                
                                             
                                          
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          .
                                          pos
                                          )
                                          +
                                          β
                                          
                                          
                                             
                                                UV
                                             
                                             
                                                t
                                                →
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      ″
                                                   
                                                
                                             
                                          
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          .
                                          pos
                                          )
                                          
                                          and
                                          
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                             
                                                ′
                                             
                                          
                                          .
                                          app
                                          =
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          .
                                          app
                                          ,
                                          
                                          ∀
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          ∈
                                          
                                             
                                                train
                                             
                                             
                                                
                                                   
                                                      v
                                                   
                                                   
                                                      t
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

The appearance of the image features is thus left unchanged, but their position in the image is modified using a linear combination of the deformations detected with optical flow. Using a parameterization of the viewpoint with euler angles as we do in our implementation (Section 4.4), this linear interpolation of image location with respect to angles is a simplistic approximation of the underlying transformations (3D rotation and projection onto the image plane). This linear approximation however proved appropriate, since the deformations are detected between fairly close viewpoints (due to the limitations of the optical flow algorithm), and more complex interpolation schemes did not prove more effective in practice.

We use the algorithm of Section 2.3 to obtain initial detections and recognitions of training poses. Those are then used as starting points to run a local optimization, using the generative model described above, in order to refine and obtain a precise pose estimate. The objective function to maximize during this optimization is still the same as described in Section 2.3 (Eq. (5)). The only difference now is that the similarity is measured between the test view and a generated view, at an arbitrary viewpoint. Since the appearance of a generated view varies smoothly across viewpoints, the value of the similarity measure (our objective function) is also guaranteed to be smooth in the neighborhood of the optimum we are seeking. However, no assumption can be made about its convexity, and its complex definition (parameterized on the 6 dimensions of the viewpoint and in-plane transformations) makes the evaluation of its gradient expensive. Fortunately, the initial estimates used as starting points can be assumed to be close approximations of the global optimum. All those conditions motivated the use of a simple hill-climbing algorithm. We iteratively optimize pairs of dimensions at a time, namely the 2 viewpoint angles, the image location, then the scale and in-plane rotation. We empirically observed that a close approximation of the global optimum can be reached in this way after only a few iterations [2].

@&#IMPLEMENTATION@&#

This section presents details that are not specific to the method, but rather choices of implementation. Those specific choices discussed below refer to the implementation used throughout the evaluation of Section 5 and available on the author’s website [43].

We demonstrate the applicability of the method to two different types of image features: edges and intensity gradients extracted at a coarse scale.

Image edges are widely used in the context of object recognition as they are effective and efficient representatives of shape (being rather sparse, compared to dense gradients). Using edges alone will also allow a fair comparison of our results with existing methods. We use the classical intensity-based Canny detector to extract edges from input images. The image features considered are then the pixels belonging to the resulting binary edge map. We attach, to each of these edge point features, an appearance attribute corresponding to the local (tangent) orientation of the edge, defined on 
                              
                                 
                                    
                                       S
                                    
                                    
                                       1
                                    
                                    
                                       +
                                    
                                 
                                 =
                                 [
                                 0
                                 ,
                                 π
                                 [
                              
                           . The kernel associated with that attribute naturally uses a von Mises distribution (similar to a wrapped Normal distribution) on the half-circle (Table 1
                           ).

Note that our distance measure between edges could be compared to the directional chamfer distance [42,44]. The approximation proposed in earlier work (discretization of orientations, approximation of edges by straight segments [42], etc.) can thus be seen as approximations of our more general formulation. Consequently and unsurprisingly, the directional chamfer distance was reported to perform similarly as our base method on the ETHZ shape dataset with hand-drawn examples [42]. This comparison is anecdotal since their exact performance numbers were not available. Moreover, our method includes numerous other improvements like the weights on the features or the learning of models from examples.

The goal of our gradient features is to represent regions in the image of slowly varying intensity, due to e.g. shading on smooth surfaces. It is easy to see how this information is complementary to the edges, which rather capture sharp transitions. We extract gradients by first convolving the image with derivative-of-Gaussian filters in horizontal and vertical orientations. Each pixel of the image with significant gradient magnitude (set by a fixed low threshold) is an image feature, which gets, as its appearance attributes, the orientation of the gradient (an angle in 
                              
                                 [
                                 0
                                 ,
                                 2
                                 π
                                 [
                              
                           ). The extraction of gradients is performed at several coarse scales (typically, 
                              
                                 σ
                                 =
                                 2
                                 ,
                                 …
                                 ,
                                 5
                              
                           , px), and the gradient of largest magnitude is retained. We propose two versions of a kernel suited to the gradient points (Table 1), using the orientation in either an undirected or directed manner. In the undirected manner, the orientation of the gradients is compared only on the half-circle. Two horizontal gradients, from black to white and from black to white would thus be considered identical. In the directed manner, their orientation in that case is considered opposite. We compare both versions in our experiments.

As presented in Section 2.3, performing object detection amounts to identifying maxima of the similarity between the test view and one of the training view. We perform the initial detection using one single type of image features at a time. In practice indeed, in the problem of localization in an image, the meaningful optima of the full similarity function (using several types of image features, Eq. (5)) will also correspond to local optima for each type features alone. For efficiency, we typically run this procedure using the (more sparse) edge points, and then compute the exact similarity scores with (possibly) additional features (Eq. (5)), at those discrete values of 
                           
                              (
                              v
                              ,
                              w
                              )
                           
                         proposed by the voting algorithm. It is however also possible to use dense features alone (gradients for example) with this voting procedure, e.g. if the object does exhibit any meaningful edges, as demonstrated in Section 5.6.

From the definition of our similarity measure we show below that a procedure akin to a traditional Hough voting can approximate this value, which leads to Algorithm 1. On the one hand, considering a single type of features f, Eqs. (4) and (5) specify how to measure the similarity between the test view and a training view v under the in-plane transformations w:
                           
                              (10)
                              
                                 
                                    
                                       similarity
                                    
                                    
                                       test
                                       ,
                                       
                                          
                                             train
                                          
                                          
                                             v
                                          
                                       
                                    
                                 
                                 (
                                 w
                                 )
                                 ≈
                                 
                                    
                                       1
                                    
                                    
                                       
                                          
                                             LL
                                          
                                          
                                             ′
                                          
                                       
                                    
                                 
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                       
                                       
                                          L
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                       
                                          
                                             
                                                L
                                             
                                             
                                                ′
                                             
                                          
                                       
                                    
                                 
                                 wt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 
                                 N
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 pos
                                 ;
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                    
                                       ′
                                    
                                 
                                 .
                                 pos
                                 ,
                                 
                                    
                                       σ
                                    
                                    
                                       pos
                                    
                                 
                                 )
                                 
                                 
                                    
                                       K
                                    
                                    
                                       f
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 .
                                 app
                                 ;
                                 
                                    
                                       x
                                    
                                    
                                       j
                                    
                                 
                                 .
                                 app
                                 )
                                 ,
                              
                           
                        with samples 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         drawn from 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          test
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                              ,
                              
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                           
                         from 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          v
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                        , and 
                           
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              =
                              
                                 
                                    transform
                                 
                                 
                                    w
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        . Let us consider a common 2D voting space 
                           
                              H
                           
                         corresponding to image locations, containing discrete votes at locations 
                           
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              .
                              pos
                           
                         of respective weights 
                           
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              .
                              weight
                           
                        . After convolving this voting space with an isotropic Gaussian kernel of bandwidth 
                           
                              
                                 
                                    σ
                                 
                                 
                                    pos
                                 
                              
                           
                        , the value at a location l is given by:
                           
                              (11)
                              
                                 H
                                 (
                                 l
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 .
                                 weight
                                 
                                 
                                 N
                                 
                                    
                                       
                                          l
                                          ;
                                          
                                             
                                                v
                                             
                                             
                                                j
                                             
                                          
                                          .
                                          pos
                                          ,
                                          
                                             
                                                σ
                                             
                                             
                                                pos
                                             
                                          
                                       
                                    
                                 
                                 .
                              
                           
                        
                     

One can now readily see that Eqs. (10) and (11) can be made equivalent with votes in the Hough space such that 
                           
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              .
                              pos
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                                 
                                    ′
                                 
                              
                              .
                              pos
                              -
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              .
                              pos
                              )
                           
                         and 
                           
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              .
                              weight
                              =
                              wt
                              (
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              )
                              .
                              
                              
                                 
                                    K
                                 
                                 
                                    f
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              .
                              app
                              ,
                              
                                 
                                    x
                                 
                                 
                                    j
                                 
                              
                              .
                              app
                              )
                           
                        . Thus, by casting votes of such locations and weights, the values in the voting space after blurring will approximate our similarity measure for all the discrete image locations represented by the voting space, from which we can then trivially identify the local maxima. The complete algorithm is given in Algorithm 1. It iterates over discrete viewpoints, scales and in-planes rotations,
                           3
                           The discrete steps for the search scales and in-plane rotations are parameters of the algorithm.
                        
                        
                           3
                         then uses, at each iteration, the voting procedure to identify the best image location.
                           Algorithm 1
                           Voting algorithm for object detection, similar to a generalized Hough transform, which uses samples from our distributions of image features. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Input:
                                             
                                          
                                          
                                             
                                                f 
                                                 The type of image features to use for the initial detection.
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            test
                                                         
                                                         
                                                            f
                                                         
                                                      
                                                   
                                                 
                                                 Set of such image features of the test view.
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            train
                                                         
                                                         
                                                            
                                                               
                                                                  v
                                                               
                                                               
                                                                  t
                                                               
                                                            
                                                         
                                                         
                                                            f
                                                         
                                                      
                                                   
                                                 
                                                 With 
                                                   
                                                      t
                                                      =
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      T
                                                   
                                                , sets of image features of the T training views.
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                                Output:
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      R
                                                      =
                                                      
                                                         
                                                            
                                                               
                                                                  (
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        j
                                                                     
                                                                  
                                                                  ,
                                                                  
                                                                     
                                                                        w
                                                                     
                                                                     
                                                                        j
                                                                     
                                                                  
                                                                  )
                                                               
                                                            
                                                         
                                                         
                                                            j
                                                         
                                                      
                                                   
                                                 
                                                 Candidate detections of training viewpoints, i.e. couples of viewpoint/in-plane transformations, local maxima of Eq. (2).
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                                Procedure:
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      R
                                                      ←
                                                      ∅
                                                   
                                                
                                             
                                          
                                          
                                             
                                                For each discrete training viewpoint 
                                                   
                                                      t
                                                      =
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      T
                                                   
                                                
                                             
                                          
                                          
                                             
                                                 
                                                For each discrete step of in-plane rotation r
                                             
                                          
                                          
                                             
                                                 
                                                For each discrete step of image scale s
                                             
                                          
                                          
                                             
                                                
                                                 Initialize 
                                                   
                                                      H
                                                   
                                                 empty 2D Hough accumulator corresponding to image locations
                                          
                                          
                                             
                                                
                                                 
                                                For each 
                                                
                                                   
                                                      ℓ
                                                      =
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      L
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                 Select a sample 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                   
                                                 from 
                                                   
                                                      
                                                         
                                                            ϕ
                                                         
                                                         
                                                            
                                                               
                                                                  test
                                                               
                                                               
                                                                  f
                                                               
                                                            
                                                         
                                                         
                                                            f
                                                         
                                                      
                                                   
                                                 and 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                   
                                                 from 
                                                   
                                                      
                                                         
                                                            ϕ
                                                         
                                                         
                                                            
                                                               
                                                                  train
                                                               
                                                               
                                                                  
                                                                     
                                                                        v
                                                                     
                                                                     
                                                                        t
                                                                     
                                                                  
                                                               
                                                               
                                                                  f
                                                               
                                                            
                                                         
                                                         
                                                            f
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                 Add a vote to 
                                                   
                                                      H
                                                   
                                                 āt location  
                                                
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      .
                                                      pos
                                                      -
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      .
                                                      pos
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                
                                                 of weight  
                                                
                                                   
                                                      
                                                         
                                                            K
                                                         
                                                         
                                                            f
                                                         
                                                      
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            1
                                                         
                                                      
                                                      .
                                                      app
                                                      ,
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      .
                                                      app
                                                      )
                                                      ·
                                                      wt
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         
                                                            2
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                 Convolve (“blur”) 
                                                   
                                                      H
                                                   
                                                 with Gaussian kernel of size 
                                                   
                                                      (
                                                      s
                                                      .
                                                      
                                                         
                                                            σ
                                                         
                                                         
                                                            pos
                                                         
                                                      
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                 Keep each local maxima of 
                                                   
                                                      H
                                                   
                                                : store its corresponding image location in w together with current rotation r and scale s, and 
                                                   
                                                      R
                                                      ←
                                                      R
                                                      ∪
                                                      (
                                                      
                                                         
                                                            v
                                                         
                                                         
                                                            t
                                                         
                                                      
                                                      ,
                                                      w
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

In order to build a model of an object category from several instances, we first identify the discrete viewpoints provided in the training data, and at which the category model will be defined. For each viewpoint, we combine all instances defined at that viewpoint, by aligning the views and simply merging their sets of features (see Fig. 8 for example). To align the views, we trivially translate and/or scale each example as it is added to the model, so as to maximize its similarity (Eq. (5)) with the current model (Fig. 6, top row).

Using our distributions of features requires drawing samples from those. Sampling from distributions defined through KDE involves selecting a particle at random, then drawing a sample from its associated kernel. The set of particles that define category models is representative of the distribution of image features among the training examples, which is highly multimodal. If those examples are only roughly segmented and contain significant clutter, as in the “ETHZ Shape” dataset (see Fig. 6, top row), a large fraction of the particles will account for noise. They correspond to non-meaningful variations of appearance among the training examples that we wish not to capture. To address this specific concern, we propose a variant of the sampling procedure that focuses on the main modes of the distribution. This variant differs in the selection of a particle. Instead of choosing it uniformly at random, we select particles with a probability proportional to their likelihood under the distribution defined by the whole set of features. Formally, given the set of features 
                           
                              
                                 
                                    train
                                 
                                 
                                    f
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                 
                                 
                                    i
                                    =
                                    1
                                 
                                 
                                    
                                       
                                          M
                                       
                                       
                                          k
                                       
                                    
                                 
                              
                           
                        , which define the distribution 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                           
                        , we will select a particle 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         with a probability proportional to 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    
                                       
                                          train
                                       
                                       
                                          f
                                       
                                    
                                 
                                 
                                    f
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        . Similar procedures for drawing samples from the main modes of a distribution have been previously proposed in the literature, e.g. in [45] under the name of “2-level importance sampling”. As a side note, formulated using importance sampling, the technique proposed above corresponds to using 
                           
                              ϕ
                           
                         as the proposal distribution, in order to sample from a distribution 
                           
                              
                                 
                                    ϕ
                                 
                                 
                                    ′
                                 
                              
                           
                         in which the probability densities would have been squared. Visual comparisons of sampling methods are provided in Fig. 6. Moreover, we empirically observed that, after selecting particles, drawing random samples from their associated kernels proved unnecessary or sometimes detrimental, unless using very large numbers of samples. We thus only use the subset of particles themselves as samples. For efficiency, we preselect this subset off-line as a preprocessing step. Those precomputed samples are thus readily available at test time, and this also allows precomputing their associated weights (Section 2.4). A complete overview of the different steps involved in the learning of a category model, then in its use for detection and pose estimation, is provided in Algorithm 2.
                           Algorithm 2
                           Full algorithm for learning model of object category, and for detection followed by continuous pose estimation in a test image. 
                                 
                                    
                                       
                                       
                                          
                                             
                                                Training (off-line)
                                             
                                          
                                          
                                             
                                                 
                                                For each viewpoint
                                          
                                          
                                             
                                                 Extract edge and gradient features from training images of the current viewpoint
                                          
                                          
                                             
                                                 Align features of training images, as to maximize their similarity (Eq. (5))
                                          
                                          
                                             
                                                 Merge aligned features of all those training images
                                          
                                          
                                             
                                                 Pre-draw samples from resulting distribution, assign uniform weights
                                          
                                          
                                             
                                                 Extract edge and gradient features from validation images
                                          
                                          
                                             
                                                 Pre-draw samples from resulting distributions, assign uniform weights
                                          
                                          
                                             
                                                 
                                                For each iteration for learning weights
                                          
                                          
                                             
                                                 Perform detection on validation images (Algorithm 1)
                                          
                                          
                                             
                                                 Update weights using incorrect detections as negative examples (Eq. (7))
                                          
                                          
                                             
                                                 
                                                If training viewpoints are close enough for continuous pose estimation
                                          
                                          
                                             
                                                 Detect deformations between neighboring viewpoints with optical flow
                                          
                                          
                                             
                                                 Store deformation of each pre-drawn sample from the training images
                                          
                                          
                                             
                                                
                                             
                                          
                                          
                                             
                                                Testing (on-line)
                                             
                                          
                                          
                                             
                                                 Extract edge and gradient features from test image
                                          
                                          
                                             
                                                 Draw samples from resulting distribution, assign uniform weights
                                          
                                          
                                             
                                                 Perform detection, using edges only (Algorithm 1)
                                          
                                          
                                             
                                                 Compute full similarity scores of resulting detections, using edges and gradients (Eq. (5))
                                          
                                          
                                             
                                                 
                                                Return detections with highest scores
                                          
                                          
                                             
                                                 
                                                If training viewpoints are close enough for continuous pose estimation
                                          
                                          
                                             
                                                 Consider the detection with the highest score
                                          
                                          
                                             
                                                 
                                                For each iteration for optimizing the viewpoint
                                          
                                          
                                             
                                                
                                                 Generate appearance of the model at a slightly perturbed viewpoint (Eq. (8))
                                          
                                          
                                             
                                                 
                                                 Compute similarity score between test image of generated viewpoint (Eq. (5))
                                          
                                          
                                             
                                                 
                                                 
                                                If similarity score improved then keep perturbed viewpoint
                                          
                                          
                                             
                                                 
                                                Return the detection with the optimized viewpoint
                                          
                                       
                                    
                                 
                              
                           

The manipulation of our low-level image features typically involves large numbers of very simple operations. These are excellent candidates for massively-parallel execution on a graphical processing unit (GPU). The provided software is implemented in Matlab and allows execution on either a CPU or a GPU. As a ballpark figure, on a typical consumer-level desktop computer, execution on a GPU is typically 20 times faster than execution on a CPU, with test times in the order of seconds (e.g. on the “ETHZ shape” dataset) to minutes (on the cars of the “3D Object” dataset). Although some specific effort was spent adapting the algorithm for execution on a GPU, performance has not been our primary concern, and further improvements in performance are certainly possible. Existing work on the implementation of the Hough transform on GPUs [46–48] may be of interest in this context. Also note that the test times of the algorithm scale with the number of image features used. Our fine-grained, undistinctive image features (edge points and gradient points) thus present the worst case in this regards. Using sparser image features with richer descriptors within the proposed method would hugely decrease its computational requirements.

All the contributions of this paper form together a single coherent framework. One of our goals is to demonstrate the versatility of the resulting method, which we therefore evaluate on a variety of tasks and datasets. We present them by order of relative complexity, starting with object detection, first learned from a clean shape template, then learned from images. We then consider the task of coarse, discrete pose estimation (or pose classification), i.e. the recognition of specific trained viewpoints. We finally consider continuous pose estimation. The task of pose estimation is viewed as the most complex task, as it does also involve the detection and recognition of the object within clutter the image. To the extent possible, we reuse existing datasets, such as the “ETHZ shape” [49] and “3D Object” [27], considered as benchmark datasets. This allows direct comparison with recent and state-of-the-art methods on several of the tasks considered. Additionally, we present some of the unique capabilities of our method with a custom dataset of smooth and non-textured objects that can only be recognized from shading and homogeneous image regions, which we make possible through the use of coarse-scale image gradients as image features. All scripts for replicating the experiments of this paper are available, together with the code of the method, on the author’s website [43]. Very few parameters need to be set within the method. A suitable bandwidth for the kernels (Eq. (1)) is set as a fraction of the size of the object in the training images (for example, in the order of 
                        
                           
                              
                                 σ
                              
                              
                                 pos
                              
                           
                           =
                           10
                           
                           px
                        
                      for the ETHZ shape dataset), and the bandwith on the orientation of edges and gradients is set with 
                        
                           κ
                           =
                           128
                        
                      (in a von Mises distribution, which would correspond to a standard deviation of 
                        
                           ∼
                           20
                           °
                        
                      in a wrapped normal distribution). The effect of the other parameters is discussed below, notably the number of samples drawn from the distributions. We identify overlapping detections from the Hough voting algorithm as per a standard procedure, i.e. when their bounding box overlap exceeds 20%, then keep only the one of higher score. One practical effect is that, if two trained vewpoints are matched on a similar location in the test image, only the one with the highest similarity score is retained.

The ETHZ Shape dataset is a standard benchmark for object detection, which features five diverse classes (bottles, swans, mugs, giraffes and apple logos) in a total of 255 images collected from the web by Ferrari et al. [49]. It is considered very challenging because of intraclass shape variations, large scale variability and severe clutter. The goal of evaluating this dataset is to demonstrate that the proposed method achieves adequate performance of shape-based detection. Although we do achieve performance on this task on par with or superior to previously-proposed methods, our method was not specifically aimed at this task, and its many other capabilities will be demonstrated on other experiments presented below. The object classes of the ETHZ dataset are intrinsically defined by their shape, and we therefore focus on the use of image edges, as most competing methods do. We did not obtain significant differences in the results with other image features such as our coarse-scale gradients. We consider each object class separately, with a model (with a single viewpoint) trained for each of them independently. The common evaluation measure for this dataset is to plot detection rates (DR) versus the incidence of false positives (false positives per image, FPPI), while varying the detection threshold. Detection rates at a fixed FPPI of 0.3 are used for direct comparisons. Detections are counted as correct with a bounding box overlap of at least 20% with hand-drawn models, and 50% with models learned from images (again, as in existing work such as [52]). All parameters were kept identical for all object classes, except 
                           
                              
                                 
                                    σ
                                 
                                 
                                    pos
                                 
                              
                           
                        , set from the size of the training template, as stated above.

The first setting we consider is the use of a single, hand-drawn model of each shape for training, as in [49]. The hand-drawn model is treated directly as an edge map, from which we pre-draw samples by selecting points along these edges, and of which we then learn weights. To allow a valid comparison with [18,49], we use all 255 images as test set, and learn weights using incorrect detections (negative examples) in 20 random images collected from the web. We obtain the weights represented in Table 2
                        . One can observe that long, uncharacteristic and easily matchable parts of the contours receive low weights, while high weights are assigned to salient parts with higher curvature, naturally less frequent among the random negative examples used to learn these weights. As expected, the detection results show that those weights significantly improve the results by decreasing the number of false positives (Table 2). While not surpassing the state of the art, we obtain remarkable performance, especially considering the fact that competing methods were specifically designed for the particular task of shape matching of contours, whereas our approach is a much more general one.

The second setting in which we evaluate this dataset involves learning the models from example images. We use the training and test splits of [52], i.e. the first half of the images of each class as the training set. We also use the rough presegmentation of these images provided as ground truth bounding boxes. Those images are aligned and set at a same scale (Section 4.3). We pre-draw samples from the model, of which we learn weights, using, as negative training images, images from the four other classes (as in [52]). The testing is performed on all other images of all classes. The models learned for each class are visualized in Fig. 6. The effect of the proposed sampling method (Section 4.3) versus a random sampling is quite dramatic. The proposed procedure concentrates on the main modes of the distributions, and provides reliable representations of the shape, even with limited numbers of samples. These “cleaner” models hide some undesirable variation from the training data, such as the water waves around the swans, or the inner texture within the apple logos.

We outperform a number of existing methods (Table 3
                        ). We do not reach the near-perfect results of M2HT [12], which uses a discriminative classifier on top of their detections. Interestingly however, their detection algorithm alone achieved a rather low detection rate of only 
                           
                              60.9
                              %
                           
                         at 1.0 FPPI, whereas our detector achieves 
                           
                              72.9
                              %
                           
                         at 0.4 FPPI (averaged over the five classes). They also reported a notable improvement by performing detection at different aspect ratios, which we do not.

We now consider the “3D Object” dataset introduced by Savarese and Fei-Fei [27]. We focus on the “car” object, as it is the most widely used, and gives us the most points of comparison with existing methods. The dataset features 10 different cars, each viewed under 24 viewpoints (8 azimuths and 3 elevations) and 3 scales. The task is both to detect the car among background clutter and to identify its azimuth angle (one of the 8 discrete values, i.e. whether it is view from the front, the left side, the 3/4 front/right side, etc.). Pose estimation is limited to this coarse classification into the trained viewpoints, as these are too distant from each other to use our procedure for continuous pose estimation; finding dense correspondences between views of such complex objects would require viewpoints much closer than 
                           
                              45
                              °
                           
                         apart.

We use similar conditions and evaluation criteria as [27]: the first 5 cars for training and the last 5 for testing. The training images are used both to build the model (with the provided ground truth segmentation), and then to learn weights by using the incorrect detections on them as negative examples (Section 2.4). Results are measured in terms of the rate of correct detections (average precision, or AP), defined by a bounding box overlap of 50%, and the ratio, among correct detections, of correct estimates of the azimuth angle (mean precision in pose estimation, or MPPE). As reported in Figs. 5, 7
                        
                        
                         and Table 4
                        , we outperform most existing methods evaluated on this dataset. The visualization of the weights learned for the image features (Fig. 8
                        
                        ) provides some insight on their significant impact on performance. In the side view for example, the long horizontal lines, which are also frequent in background clutter, receive low weights. The wheels, on the opposite, are more characteristic and much better indicators of a car seen from the side, and thus receive higher weights. Interestingly, this distribution of weights is visually very similar to those obtained by Maji and Malik [12] with their own procedure, on side views of cars of the “UIUC car” dataset. We also observe that using our coarse-scale gradients as features, in addition to edges, brings a slight improvement. The difference is however marginal, as the appearance of the cars is already well defined by their shape and edges alone.

We further evaluate our performance for object detection in clutter using the “tabletop” dataset of Sun et al. [58]. It features a total of 30 objects from 3 categories: computer mice, mugs and staplers. These object categories present more basic shapes than the cars in the “3D Object” dataset, which is a different challenge and provides complementary evaluation points. We use, as the training set, the part of the dataset with objects appearing on a turntable under known viewpoints (“Table-Top-Pose”; see Fig. 1). A model is learned for each object category. Testing is performed on scenes (“Table-Top-Local”) containing one or several instances of the objects in a cluttered office environment; note that those experimental conditions are more challenging than existing evaluations (e.g. in [56]) since those two parts of the dataset feature different imaging and lighting conditions. We perform detection in the test images of each object category separately, and we measure the detection rates with the standard criterion of 
                           
                              50
                              %
                           
                         bounding box overlap. Results are reported in Figs. 10 and 11
                        
                         as precision/recall curves. The use of coarse-scale gradients brings here a significant improvement, in particular on cups, the shape of which produces very characteristic shading patterns. The improvement is marginal for the computer mice: the different instances are very diverse in shape, and observed under fixed lighting conditions in the training images that produce specular highlights, which do not appear in the testing images. The simple gradients are obviously not robust to such variations by themselves, but we believe that they would show a better advantage if the training images presented more varied lighting conditions, although this could unfortunately not be tested with this dataset.

We now evaluate the unique capability to perform continuous pose estimation within our appearance-based method. Few other methods have tackled this problem, especially at the level of object categories, which explains the limited choice of suitable datasets. The most appropriate, in our view, is the “Multiview car” dataset introduced by Ozuysal et al. [59]. It includes about 2000 images of 20 very different cars filmed on rotating stands at a motor show. The dataset is very challenging due to changing lighting conditions, high intraclass variability in shape, appearance and texture, and highly similar views (symmetrical side views, similar front and rear views) which are sometimes hard to differentiate even for a human. The dataset was used in [59] for pose classification in 16 discrete bins, and in [30] for continuous pose estimation. We first evaluate our method, as in [30], on the first car of the dataset, training a model on this single specific car. We select 15, 30 or 40 equally-spaced images of the sequence as training images, and use all other images (spaced about 
                           
                              4
                              °
                           
                         apart) for testing. We obtain superior results to [30] (Table 5
                        ). We then perform experiments at the category level, in conditions similar to those used in [30]. The first 10 cars of the dataset are used for training, and the other 10 for testing. Again, we obtain performance superior to all published results to our knowledge (Table 6
                        ). As highlighted in Fig. 12
                        , the remaining errors in pose estimation correspond to an error of about 
                           
                              180
                              °
                           
                        . This is caused by the symmetric aspects of some cars in the side views, and confusion between front- and rear-facing views.

We further evaluated the generalization capabilities of the model learned from this dataset. We thus use this model, trained from the 10 first rotating cars, for testing on the “3D Object” dataset (see Section 5.2 above). This is a challenging task, as those two datasets present very different conditions in terms of imaging conditions, scale, background clutter, etc. We do the testing specifically on the sixth car of the dataset, the exact pose of which was annotated by Zia et al. [61] by manually fitting 3D models to the images. These annotations are used as ground truth to measure the accuracy of the azimuth angle estimated by our method for continuous pose estimation. We obtain excellent results (Table 7
                         and Fig. 13
                        ), close to the accuracy obtained by the complex method of Zia et al. [61], which basically aligns 3D CAD models of cars with the images, compared to our more general appearance-based procedure.

We further evaluate our method for continuous pose estimation, this time with a model spanning both dimensions of the viewing sphere around the object, as opposed to the single degree of freedom (azimuth angle) of the rotating cars presented above. The choice of datasets for this task that allow comparison with existing methods is limited, here again. We use the “3D pose Volvo car” of Viksten et al. [62,63] (Fig. 14
                        ). This allows a comparison with a classical method [62] that uses discriminative image descriptors with a voting and averaging scheme, which is the classical approach for robust 3D pose estimation (with the disadvantage of being limited to specific object instances). The dataset features a toy car viewed under regular increments of azimuth and elevation angles. We consider two training/test splits: a small and a large training set, with views spaced respectively 
                           
                              20
                              °
                           
                         and 
                           
                              10
                              °
                           
                         apart (on both azimuth and elevation angles), and exactly one test view between each pair of training view, i.e. as a grid on the viewing sphere (as in [62]). In both cases, we obtain results significantly superior to [62] in terms of accuracy (Table 8
                        ). The smaller training set is more challenging for detecting deformations between views, and seemed to reach the limits of the optical flow algorithm we use to detect deformations between neighboring views. The dataset also allows a good visualization of the capabilities of our generative model, by varying continuously the viewpoint around the object. The effect, unfortunately hard to convey in static images (Fig. 15
                        ), is a vivid impression of manipulating a 3D model of the object – although there is no underlying explicit representation of the 3D shape. Videos and an interactive viewing tool are available on the author’s website [43].

We finally demonstrate the interest of using coarse-scale gradients with a new dataset featuring non-textured objects. These toy objects, made of plastic, feature basic shapes with few internal edges (Fig. 16
                        ). This lack of distinctive visual characteristics actually makes them difficult to identify among clutter, and the absence of texture renders the estimation of their pose problematic. For example, considering the knife, one cannot differentiate the (round) handle from the (flat) blade, observing edges and silhouette alone. We made this new dataset available on the author’s website [43]. It comprises examples images of each object with segmentation and pose annotations (used for training), plus a series of test images of cluttered scenes feature these objects, also with ground truth segmentations and annotations (used for evaluation). Results of detection are counted as correct when the overlap of bounding boxes with the ground truth exceeds 
                           
                              50
                              %
                           
                         
                        and the estimated pose is correct (error on viewpoint angles smaller than 
                           
                              20
                              °
                           
                        ). Unsurprisingly, most objects are detected very poorly using edges alone (with our method, though any other contour-based recognition method is expected to work as poorly). Our full method however, using coarse-scale gradients in the measure of similarity between the detections and the training examples, is able to differentiate between similar-looking poses, and achieves far superior detection rates (Fig. 16). Most remaining incorrect detections are due to clutter and confusion from the similar appearance of these simple objects. We also tested the detection of those objects using gradient features alones, without edges. This did not prove effective in practice, since their appearance, defined by these gradients, is very simple and easily confused with the background or other objects. The knife for example, just corresponds to a region without gradients (the flat blade) and a part with gradients oriented orthogonally to the knife’s length (the round handle). Such a description is complementary to the silhouette represented by edges, but is not informative enough by itself to localize such the object among clutter.

@&#DISCUSSION AND CONCLUSIONS@&#

We introduced a representation of 2D appearance as distributions of low-level, fine-grained image features. We used this representation to build multiview models of object categories. Those models encode the appearance of objects at a number of discrete viewpoints, and, in addition, how these viewpoints deform into one another as the viewpoint continuously varies. Those deformations between neighboring viewpoints are detected with an optical flow algorithm, and encoded as translations of individual image features with respect to viewpoint changes. We provide a way to measure the similarity between an arbitrary test image and an object model at a specific viewpoint. We use this measure of similarity to perform a number of tasks: detection and localization in cluttered images (identifying the local maxima of the similarity measure with respect to locations in the test image), discrete pose estimation (identifying the learned viewpoint with the highest similarity measure with the test image) and continuous pose estimation (identifying the maxima of the similarity measure as the viewpoint continuously varies). In contrast with common practice, we address and evaluate a number of related tasks with a single approach. This is reflected in our experimental evaluation, which includes extensive testing on a number of very different benchmark datasets, which are seldom considered together. We demonstrate performance on the “ETHZ Shape” dataset for shape matching and detection in clutter of categories well above baseline methods, on par with a number of more task-specific methods. We also obtain remarkable performance on the recognition of more complex objects, notably the cars of the “3D Object” dataset, with detection rates of 
                        
                           92.5
                           %
                        
                      and an accuracy in pose estimation of 
                        
                           91
                           %
                        
                     . For the task of continuous pose estimation, we obtain results superior to the state-of-the-art on the “rotating cars” dataset.

The limitations of our appearance model lie mostly in the representation of object categories. The distribution of image features are representative of the occurrence of features among the training examples, but they do not encode the co-occurrence of these features. The resulting model can thus represent all combinations of variations present in the examples. A model learned from images of cars and giraffes would not only represent those two types of objects, but also anything looking partially like a car and partially like a giraffe (i.e. combining visual features from different training examples). This may be seen as a strength, as few examples can suffice to represent wide variations of overall appearance. However, this also means that the overall procedure will practically be most effective with training examples sharing strong visual characteristics, and not with categories defined semantically or including instances looking vastly different. This representation of appearance thus also assumes fairly rigid objects (although we still obtained good performance on shape matching of the ETHZ classes). Complex deformable objects would probably be better handled by part-based models (e.g. [17,64]). We believe that this limitation was probably masked by the relative simplicity of the objects in the available datasets. Let us note however that the proposed representation as distributions of features could serve as a building block of part-based models.

The importance of shape and structure in the model leads to another limitation, in the context of object recognition in complex scenes. As opposed to, e.g. the classical “bag of visual words” approach, our model does not encode contextual clues of the scene. For example, blue color and clouds in the background of an image may be indicative of the presence of an airplane. Such information is however not encoded within our model, aimed at individual object recognition. This information could be taken into account at another, higher level, dealing for overall scene understanding.

All limitations discussed above lead to potential avenues for further developments. In addition, on the task of continuous pose estimation, one could explore alternative optimization algorithms to use with our generative model. Improvements in efficiency at this level could render the model suitable for continuous pose tracking, thereby widening its range of applicability even further. The detections of the deformations between the trained viewpoints, which currently uses a standard algorithm to detect optical flow, could also be improved, be made applicable to more distant viewpoints and to other types of training data, e.g. videos of the object. Finally, one could evaluate other types of image features within the proposed approach. We demonstrated its particular applicability to low-level features, although more traditional, higher-level features could also be used, such as histogram-based descriptors [7,16] or region features [65].

The research leading to these results has received funding from the European Community’s Seventh Framework Programme FP7/2007-2013 (Specific Programme Cooperation, Theme 3, Information and Communication Technologies) under Grant Agreement No. 270273, Xperience. Damien Teney is supported by a research fellowship of the Belgian National Fund for Scientific Research (FNRS).

@&#REFERENCES@&#

