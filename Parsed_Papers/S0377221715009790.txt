@&#MAIN-TITLE@&#A hybrid heuristic approach for the multi-commodity pickup-and-delivery traveling salesman problem

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a hybrid heuristic approach for a pickup and delivery routing problem.


                        
                        
                           
                           This problem has applications in the context of inventory repositioning and bike hiring system.


                        
                        
                           
                           It is the first heuristic approach designed for this problem.


                        
                        
                           
                           It can efficiently solve instances with up 400 locations and 5 products.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Pickup-and-delivery

Hybrid approach

Traveling salesman

Local search

@&#ABSTRACT@&#


               
               
                  We address in this article the multi-commodity pickup-and-delivery traveling salesman problem, which is a routing problem for a capacitated vehicle that has to serve a set of customers that provide or require certain amounts of m different products. Each customer must be visited exactly once by the vehicle, and it is assumed that a unit of a product collected from a customer can be supplied to any other customer that requires that product. Each product is allowed to have several sources and several destinations. The objective is to minimize the total travel distance. We propose a hybrid three-stage heuristic approach that combines a procedure to generate initial solutions with several local search operators and shaking procedures, one of them based on solving an integer programming model. Extensive computational experiments on randomly generated instances with up to 400 locations and 5 products show the effectiveness of the approach.
               
            

@&#INTRODUCTION@&#

The Multi-Commodity Pickup-and-Delivery Traveling Salesman Problem (m-PDTSP) is a generalization of the Traveling Salesman Problem in which a capacitated vehicle based at a depot must visit a set of customers. Each location (depot and customers) must be visited exactly once by the vehicle. The travel cost between each pair of locations is known, and not necessarily symmetric. Each customer requires some given quantities of different products and/or provides some given quantities of other different products. A unit of a product collected from a customer can be supplied to any customer that requires this product. It is assumed that the vehicle must start and finish the route at the depot. Another visit to the depot is not allowed. The aim of the m-PDTSP is to find a Hamiltonian route for the vehicle such that it picks up and delivers all the quantities of the different products satisfying the vehicle-capacity limitation and minimizing the total travel cost. Since each customer is visited once, each unit of a product loaded on the vehicle stays on the vehicle until it is delivered. For that reason we say that the m-PDTSP is a non-preemptive problem.

The initial load of any product in the vehicle when leaving the depot is unknown, and must be determined within the optimization problem. The variant of the m-PDTSP where the initial load of any product is fixed can also be solved through the approach described in this paper with a slight modification of the instance. Note that, the initial load being unfixed, the vehicle is allowed to deliver a demand immediately when leaving the depot and collect the associated product afterwards. In other words, there are not a priori precedence relations between pickup and delivery locations of a commodity in the route. Still, the approach described in this paper can be adapted to the variant where the the initial load is required to be zero. This assumption is argued in Hernández-Pérez and Salazar-González (2014).

An application of the m-PDTSP occurs in the context of inventory repositioning, as pointed out by Anily and Bramel (1999). Assume that a set of retailers is geographically dispersed in a region. Often, due to the random nature of the demand, some retailers have an excess of inventory of some products while others need additional stock. In many cases the company may decide to transfer inventory from retailers with low sales to those with high sales. Determining the cheapest way to execute a given stock transfer (with the requirement that each location has to be visited exactly once) is the m-PDTSP.

Another application arises in the context of a self-service bike hiring system, where every night a capacitated vehicle must visit the bike stops in a city to collect or deliver bikes to restore the initial configuration of the system. Chemla, Meunier, and Wolfler-Calvo (2013) and Raviv, Tzur, and Forma (2013), among others, approached the case where the bikes are all identical (i.e., one product) as a 1-PDTSP. When there are different types of bikes (e.g., with and without baby chairs) the problem can be described as the m-PDTSP.

The m-PDTSP is 
                        NP
                     -hard in the strong sense since it coincides with the TSP when the vehicle capacity is large enough. What is more, even checking the existence of a feasible solution for an instance with 
                        
                           m
                           =
                           1
                        
                      is a strongly 
                        NP
                     -complete problem (see Hernández-Pérez & Salazar-González, 2004). The m-PDTSP was introduced by Hernández-Pérez and Salazar-González (2014). They proposed a Mixed Integer Linear Programming model for the m-PDTSP, and described a branch-and-cut algorithm able to solve instances with up to 30 customers and 3 commodities. Since exact algorithms are only able to cope with small instances, heuristic approaches are needed to tackle larger instances in practice. This is the main motivation of our paper.

A closely related problem to the m-PDTSP is the Non-Preemptive Capacitated Swapping Problem (NCSP), proposed by Erdoǧan, Cordeau, and Laporte (2010). As in the m-PDTSP, the NCSP considers one depot, a set of customers, and several commodities with many sources and many destinations. In the NCSP, however, each customer concerns one commodity (either as pickup or delivery location) or two commodities (one as pickup location and another as delivery location). In addition to customer locations, the NCSP also includes transshipment locations, where some commodities can be temporarily dropped off. Customer and transshipment locations may be visited zero, one or two times by the vehicle, while the depot may be visited up to three times. The demand of a customer cannot be split and a commodity cannot be dropped off in an intermediate customer. The NCSP consists of finding a minimum-cost route satisfying all customer’s requests. Erdoǧan et al. (2010) describe a branch-and-cut algorithm to solve instances with up to 20 locations and 8 commodities, and 30 locations and 4 commodities. Bordenave, Gendreau, and Laporte (2009) present a branch-and-cut algorithm to solve the particular case of the NCSP where the vehicle capacity and customer demands are all equal to one. They solved instances with up to 200 locations and 8 commodities.

The one-to-one m-PDTSP is a particular case of the m-PDTSP where each commodity has one origin and one destination. It can be considered as a Dial-a-Ride routing problem without time window requirements. The one-to-one m-PDTSP assumes that the load of the vehicle when leaving the depot is zero, unless the depot is the source of a commodity. Hernández-Pérez and Salazar-González (2009) describe a branch-and-cut algorithm for this problem solving instances involving up to 24 customers and 15 commodities. Rodríguez-Martín and Salazar-González (2011) propose and compare several metaheuristic approaches to solve instances with up to 300 customers and 600 commodities.

Some articles dealing with one-commodity variants are the following. Chalasani and Motwani (1999) study the special case of the 1-PDTSP where the delivery and pickup demands are all equal to one. This problem is called Q-delivery TSP, where Q is the capacity of the vehicle. Anily and Bramel (1999) consider the same problem with the name Capacitated TSP with Pickups and Deliveries. Hernández-Pérez and Salazar-González (2007) present an exact algorithm for the 1-PDTSP solving instances with up to 200 customers. Hernández-Pérez, Rodríguez-Martín, and Salazar-González (2009) describe a hybrid algorithm that combines Greedy Randomized Adaptive Search Procedure and Variable Neighborhood Descent paradigms. Zhao, Li, Sun, and Mei (2009) propose a Genetic Algorithm that on average gives better results. Finally, Mladenović, Urošević, Hanafi, and Ilić (2012) describe a General Variable Neighborhood Search improving the best-known solution for all benchmark instances and solving instances with up to 1000 customers.

As in most of the articles dealing with TSP variants, we have decided to keep the assumption that each customer in the m-PDTSP must be visited once. However, the literature on vehicle routing includes articles that do not make this assumption. In particular, some authors address variants where a customer must be visited at most once (e.g. Fischetti, González, & Toth, 1997; Ghiani & Improta, 2000), or where a customer must be visited at least once (e.g. Archetti & Speranza, 2012; Nagy & Salhi, 2005; Nowak, Ergun, & White, 2009; Salazar-González & Santos-Hernández, 2015). There are also articles on related problems considering more than one vehicle, as in Psaraftis (2011), but, to our knowledge, in all of them each commodity must be transported from one source to one destination. Our paper is the first one proposing an approach for dealing with large instances of a capacitated pickup-and-delivery problem where each commodity may have several sources and several destinations.

The rest of the paper is organized as follows. Section 2 gives the formal definition of the problem and presents the notation used throughout the paper. Section 3 describes the heuristic algorithm to solve the m-PDTSP. Section 4 is devoted to the tuning of the algorithm’s parameters. Computational results are shown in Section 5, and final remarks are made in Section 6.

The m-PDTSP is defined on a complete directed graph 
                        
                           G
                           =
                           (
                           V
                           ,
                           A
                           )
                        
                     . The vertex set 
                        
                           V
                           =
                           {
                           1
                           ,
                           …
                           ,
                           n
                           }
                        
                      represents the locations. Vertex 1 is the depot and can be identified in the rest of the paper as a customer. For each pair of customers i and j we have the arc 
                        
                           a
                           =
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           A
                        
                      and a travel cost cij
                     . Let 
                        
                           K
                           =
                           {
                           1
                           ,
                           …
                           ,
                           m
                           }
                        
                      be the set of products. For each customer i ∈ V and each product k ∈ K let 
                        
                           q
                           i
                           k
                        
                      be the demand of product k associated with i. When 
                        
                           
                              q
                              i
                              k
                           
                           >
                           0
                        
                      customer i provides 
                        
                           q
                           i
                           k
                        
                      units of product k and when 
                        
                           
                              q
                              i
                              k
                           
                           <
                           0
                        
                      customer i requires 
                        
                           −
                           
                              q
                              i
                              k
                           
                        
                      units of product k. We assume that 
                        
                           
                              ∑
                              
                                 i
                                 ∈
                                 V
                              
                           
                           
                              q
                              i
                              k
                           
                           =
                           0
                        
                      for all k ∈ K, i.e., each product is conserved through the route. The capacity of the vehicle is denoted by Q.

As mentioned above, contrary to what happens in the TSP, finding a feasible solution (optimal or not) for the m-PDTSP is a problem with a hard computational complexity. Nevertheless, checking if a given TSP solution is feasible for m-PDTSP can be done in O(mn) time. Indeed, let us consider a path 
                        
                           P
                           →
                        
                      defined by the vertex sequence 
                        
                           
                              v
                              1
                           
                           ,
                           …
                           ,
                           
                              v
                              s
                           
                        
                      for s ≤ n. Let 
                        
                           
                              l
                              i
                              k
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                           :
                           =
                           
                              l
                              
                                 i
                                 −
                                 1
                              
                              k
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                           +
                           
                              q
                              
                                 v
                                 i
                              
                              k
                           
                        
                      be the load of the vehicle when coming out from vi
                     , considering that the vehicle enters customer v
                     1 with load 
                        
                           
                              l
                              0
                              k
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                        
                     . Notice that 
                        
                           
                              l
                              i
                              k
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                        
                      could be negative if 
                        
                           
                              l
                              0
                              k
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                           =
                           0
                        
                      and, therefore, the minimum quantity of load of commodity k for a feasible solution through the path 
                        
                           P
                           →
                        
                      is 
                        
                           −
                           
                              min
                              
                                 i
                                 =
                                 0
                              
                              s
                           
                           
                              {
                              
                                 l
                                 i
                                 k
                              
                              
                                 (
                                 
                                    P
                                    →
                                 
                                 )
                              
                              }
                           
                        
                     . With this notation, 
                        
                           P
                           →
                        
                      is an infeasible path if

                        
                           (1)
                           
                              
                                 
                                    max
                                    
                                       i
                                       =
                                       0
                                    
                                    s
                                 
                                 
                                    {
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       l
                                       i
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          →
                                       
                                       )
                                    
                                    }
                                 
                                 −
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    min
                                    
                                       i
                                       =
                                       0
                                    
                                    s
                                 
                                 
                                    {
                                    
                                       l
                                       i
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          →
                                       
                                       )
                                    
                                    }
                                 
                                 >
                                 Q
                                 .
                              
                           
                        
                     
                  

For example, consider an m-PDTSP instance with 
                        
                           m
                           =
                           Q
                           =
                           3
                        
                      and customers 2, 3, 4 and 5 with demand vectors 
                        
                           (
                           −
                           1
                           ,
                           −
                           1
                           ,
                           +
                           1
                           )
                           ,
                        
                     
                     
                        
                           (
                           +
                           1
                           ,
                           +
                           1
                           ,
                           0
                           )
                           ,
                        
                     
                     
                        
                           (
                           −
                           1
                           ,
                           0
                           ,
                           0
                           )
                        
                      and 
                        
                           (
                           +
                           1
                           ,
                           +
                           1
                           ,
                           0
                           )
                           ,
                        
                      respectively. The path defined by the customer sequence 2, 3, 4 and 5 is infeasible because

                        
                           
                              
                                 
                                    max
                                    
                                       i
                                       =
                                       0
                                    
                                    s
                                 
                                 
                                    {
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       m
                                    
                                    
                                       l
                                       i
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          →
                                       
                                       )
                                    
                                    }
                                 
                                 −
                                 
                                    ∑
                                    
                                       k
                                       =
                                       1
                                    
                                    m
                                 
                                 
                                    min
                                    
                                       i
                                       =
                                       0
                                    
                                    s
                                 
                                 
                                    {
                                    
                                       l
                                       i
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          →
                                       
                                       )
                                    
                                    }
                                 
                                 =
                                 4
                                 >
                                 Q
                                 .
                              
                           
                        
                     
                     Fig. 1
                      illustrates the calculations done in this example.

It is easy to see that the reverse path 
                        
                           P
                           ←
                        
                      of 
                        
                           
                              P
                              →
                           
                           ,
                        
                      defined by the vertex sequence 
                        
                           
                              v
                              s
                           
                           ,
                           …
                           ,
                           
                              v
                              1
                           
                           ,
                        
                      is infeasible if

                        
                           
                              
                                 
                                    ∑
                                    
                                       k
                                       ∈
                                       K
                                    
                                 
                                 
                                    max
                                    
                                       i
                                       =
                                       0
                                    
                                    s
                                 
                                 
                                    {
                                    
                                       l
                                       i
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          →
                                       
                                       )
                                    
                                    }
                                 
                                 −
                                 
                                    min
                                    
                                       i
                                       =
                                       0
                                    
                                    s
                                 
                                 
                                    {
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       l
                                       i
                                       k
                                    
                                    
                                       (
                                       
                                          P
                                          →
                                       
                                       )
                                    
                                    }
                                 
                                 >
                                 Q
                                 .
                              
                           
                        
                     Then 
                        
                           P
                           →
                        
                      can be feasible and 
                        
                           P
                           ←
                        
                      infeasible, and vice versa. For example, 
                        
                           P
                           →
                        
                      is infeasible and 
                        
                           P
                           ←
                        
                      is feasible in Fig. 1.

We define the infeasibility of the path 
                        
                           P
                           →
                        
                      as:

                        
                           
                              
                                 
                                    
                                       
                                          infeas
                                          
                                             (
                                             
                                                P
                                                →
                                             
                                             )
                                          
                                          :
                                          =
                                          max
                                          
                                             {
                                             
                                             0
                                             ,
                                             
                                                max
                                                
                                                   i
                                                   =
                                                   0
                                                
                                                s
                                             
                                             
                                                {
                                                
                                                
                                                   ∑
                                                   
                                                      k
                                                      ∈
                                                      K
                                                   
                                                
                                                
                                                   l
                                                   i
                                                   k
                                                
                                                
                                                   (
                                                   
                                                      P
                                                      →
                                                   
                                                   )
                                                
                                                }
                                             
                                             
                                             −
                                             
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                min
                                                
                                                   i
                                                   =
                                                   0
                                                
                                                s
                                             
                                             
                                                {
                                                
                                                   l
                                                   i
                                                   k
                                                
                                                
                                                   (
                                                   
                                                      P
                                                      →
                                                   
                                                   )
                                                
                                                
                                                }
                                             
                                             
                                             −
                                             
                                             Q
                                             
                                             }
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     A path is feasible when 
                        
                           infeas
                           (
                           
                              P
                              →
                           
                           )
                           =
                           0
                        
                     .

Note that the infeasibility of any path 
                        
                           P
                           →
                        
                      does not depend on the initial loads 
                        
                           
                              l
                              0
                              k
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                        
                      for 
                        
                           k
                           =
                           1
                           ,
                           …
                           ,
                           m
                        
                     . For example, if 
                        
                           
                              l
                              0
                              1
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                        
                      is increased by one unit, then 
                        
                           
                              l
                              i
                              1
                           
                           
                              (
                              
                                 P
                                 →
                              
                              )
                           
                        
                      for all 
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           s
                           ,
                        
                     
                     
                        
                           
                              max
                              
                                 i
                                 =
                                 0
                              
                              s
                           
                           
                              {
                              
                                 ∑
                                 
                                    k
                                    ∈
                                    K
                                 
                              
                              
                                 l
                                 i
                                 k
                              
                              
                                 (
                                 
                                    P
                                    →
                                 
                                 )
                              
                              }
                           
                           ,
                        
                     
                     
                        
                           
                              min
                              
                                 i
                                 =
                                 0
                              
                              s
                           
                           
                              {
                              
                                 l
                                 i
                                 1
                              
                              
                                 (
                                 
                                    P
                                    →
                                 
                                 )
                              
                              }
                           
                           ,
                        
                      and 
                        
                           
                              ∑
                              
                                 k
                                 ∈
                                 K
                              
                           
                           
                              min
                              
                                 i
                                 =
                                 0
                              
                              s
                           
                           
                              {
                              
                                 l
                                 i
                                 k
                              
                              
                                 (
                                 
                                    P
                                    →
                                 
                                 )
                              
                              }
                           
                        
                      increase all by one too. Therefore the value 
                        
                           infeas
                           (
                           
                              P
                              →
                           
                           )
                        
                      remains the same.

We end this section with a mathematical formulation for the m-PDTSP. Let us consider a 0-1 variable xa
                      for each arc a ∈ A assuming value 1 if and only if a is routed by the vehicle. For a subset S ⊂ V we denote by 
                        
                           
                              δ
                              +
                           
                           
                              (
                              S
                              )
                           
                        
                      the set of arcs {(i, j): i ∈ S and j ∈ V∖S} and 
                        
                           
                              δ
                              −
                           
                           
                              (
                              S
                              )
                           
                        
                      the set of arcs {(i, j): i ∈ V∖S and j ∈ S}. Finally, for a subset A′⊆A we write x(A′) instead of 
                        
                           
                              ∑
                              
                                 a
                                 ∈
                                 
                                    A
                                    ′
                                 
                              
                           
                           
                              x
                              a
                           
                        
                     . Then the m-PDTSP can be formulated as:

                        
                           (2)
                           
                              
                                 min
                                 
                                    ∑
                                    
                                       a
                                       ∈
                                       A
                                    
                                 
                                 
                                    c
                                    a
                                 
                                 
                                    x
                                    a
                                 
                              
                           
                        
                     subject to

                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          x
                                          (
                                          
                                             δ
                                             −
                                          
                                          
                                             (
                                             
                                                {
                                                i
                                                }
                                             
                                             )
                                          
                                          )
                                          =
                                          1
                                       
                                    
                                    
                                    
                                       
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ∈
                                          V
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          x
                                          (
                                          
                                             δ
                                             +
                                          
                                          
                                             (
                                             
                                                {
                                                i
                                                }
                                             
                                             )
                                          
                                          )
                                          =
                                          1
                                       
                                    
                                    
                                    
                                       
                                          
                                          for
                                          
                                          all
                                          
                                          i
                                          ∈
                                          V
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          x
                                          (
                                          
                                             δ
                                             +
                                          
                                          
                                             (
                                             S
                                             )
                                          
                                          )
                                          ≥
                                          1
                                       
                                    
                                    
                                    
                                       
                                          
                                          for
                                          
                                          all
                                          
                                          S
                                          ⊂
                                          V
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (6)
                           
                              
                                 
                                    
                                       
                                          
                                             x
                                             a
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                       
                                    
                                    
                                    
                                       
                                          
                                          for
                                          
                                          all
                                          
                                          a
                                          ∈
                                          A
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (7)
                           
                              
                                 
                                    
                                       
                                          x
                                          
                                             (
                                             
                                                ⋃
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                δ
                                                +
                                             
                                             
                                                (
                                                
                                                   S
                                                   k
                                                
                                                )
                                             
                                             )
                                          
                                          ≥
                                          
                                             ⌈
                                             
                                                
                                                   1
                                                   Q
                                                
                                             
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   
                                                      S
                                                      k
                                                   
                                                
                                             
                                             
                                                q
                                                i
                                                k
                                             
                                             ⌉
                                          
                                       
                                    
                                    
                                    
                                       
                                          
                                          for
                                          
                                          all
                                          
                                          
                                             S
                                             k
                                          
                                          ⊂
                                          V
                                          ,
                                          
                                          
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          m
                                          .
                                       
                                    
                                 
                              
                           
                        
                     Constraints (3)–(7) guarantee that x is a Hamiltonian tour. Inequalities (7) are valid for feasible paths and eliminate infeasible paths, as observed in Hernández-Pérez and Salazar-González (2014).

To solve the m-PDTSP we propose a three-stage algorithm. The first stage (initialization phase) consists of a procedure that generates a set of initial (not necessarily feasible) solutions. In the second stage (improvement phase), a Variable Neighborhood Descent (VND) procedure is applied to each of the solutions selected in the first stage. Six operators are proposed to compose this VND. Finally, in the third stage (perturbation and refinement phase), each local minimum is perturbed applying a combination of three shaking procedures. The second and third stages are repeated in the hope of further improvements. Each stage is subject to a stopping criterium, and the best feasible solution found during the whole algorithm is given as the final solution.

The whole scheme can be considered as a hybrid heuristic algorithm since it combines the Multi-Start and the VND metaheuristic paradigms, and it also makes use of Mathematical Programming techniques to perform local search. We describe next in detail each of the components.

This phase creates a set of initial solutions. To generate a (not necessarily feasible) solution we apply a randomized greedy procedure based on the nearest neighbor heuristic approach for the TSP. It extends a partial path starting from a random vertex and iteratively adding a new location until they are all in the path. At each iteration a customer is added at the end of the partial path, trying to obtain a feasible solution of good quality. To this end, we evaluate all possible candidates and introduce a vertex chosen randomly among the nearest three to the last vertex in the path that keeps the partial solution feasible. More precisely, if v
                        1, v
                        2 and v
                        3 are the nearest vertices to the last vertex added that keep the partial tour feasible, we choose vi
                         (
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              3
                           
                        ) with probability αi
                         (
                           
                              
                                 α
                                 1
                              
                              +
                              
                                 α
                                 2
                              
                              +
                              
                                 α
                                 3
                              
                              =
                              1
                           
                        ). If it is not possible to have feasibility, we introduce the vertex that minimizes the infeasibility.

Another feature of this initial phase is that the travel costs are modified trying to obtain a feasible solution (or minimizing the infeasibility of the solution). The distances dij
                         considered are given by:

                           
                              
                                 
                                    
                                       d
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                    
                                    +
                                    C
                                    ·
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   a
                                                   ∈
                                                   A
                                                
                                             
                                             
                                                c
                                                a
                                             
                                          
                                          
                                             |
                                             A
                                             |
                                          
                                       
                                    
                                    ·
                                    
                                       
                                          
                                             2
                                             Q
                                             −
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                m
                                             
                                             
                                                (
                                                |
                                             
                                             
                                                q
                                                i
                                                k
                                             
                                             
                                                |
                                                +
                                                |
                                             
                                             
                                                q
                                                j
                                                k
                                             
                                             
                                                |
                                                )
                                             
                                          
                                          
                                             2
                                             Q
                                          
                                       
                                    
                                 
                              
                           
                        for a parameter C. The constant ∑
                           a ∈ A
                        
                        ca
                        /|A| is used to normalize each instance. The aim of considering this cost modification is to favor a route going from a customer i to a customer j with large (absolute) demand. Similar ideas are presented in Hernández-Pérez and Salazar-González (2004), Zhao et al. (2009) and Mladenović et al. (2012) for the 1-PDTSP.

The procedure is performed MS
                        0 times in the first phase of the algorithm to generate a set of initial solutions. A hash structure is used to avoid saving a route several times in the set. Then the MS
                        1 solutions with the smallest infeasibility and cost are taken as input data for the second phase, next described.

In the second stage of our algorithm, a VND procedure starts from each of the solutions selected in the first stage. VND is a variant of the well-known Variable Neighborhood Search technique in which several local search operators are applied, one after the other, to explore different neighborhoods (see Hansen & Mladenović, 2001). Inspired by the works of Mladenović et al. (2012) for the 1-PDTSP and Rodríguez-Martín and Salazar-González (2011) for the one-to-one m-PDTSP, we propose six operators to explore neighbourhoods of a solution. The best combinations of these operators are described in Section 4.2.

The 2-opt move is the simplest k-opt edge-exchange method. It consists of removing two arcs 
                           
                              (
                              
                                 v
                                 i
                              
                              ,
                              
                                 v
                                 
                                    i
                                    +
                                    1
                                 
                              
                              )
                           
                         and 
                           
                              (
                              
                                 v
                                 j
                              
                              ,
                              
                                 v
                                 
                                    j
                                    +
                                    1
                                 
                              
                              )
                           
                         from the tour and reconnecting the two paths created by adding (vi, vj
                        ) and 
                           
                              (
                              
                                 v
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                              
                                 v
                                 
                                    j
                                    +
                                    1
                                 
                              
                              )
                           
                        . This implies reversing the path from vj
                         to 
                           
                              
                                 v
                                 
                                    i
                                    +
                                    1
                                 
                              
                              ,
                           
                         which may decrease or increase the cost of the new solution. We also consider the tour in the reverse orientation, and the whole operator is denoted by 2-opt. To evaluate the convenience of a move, we first evaluate the infeasibility and then the cost of the solutions. That is, a 2-opt move is performed only if the new solution is less infeasible, or if it has the same infeasibility but is shorter.

It is known for the TSP (see, e.g., Hansen & Mladenović, 2006) that it is not necessary to explore the 
                           
                              n
                              (
                              n
                              −
                              1
                              )
                              /
                              2
                           
                         possible 2-opt moves because, to have a cost reduction, at least one of the added arcs must be shorter than one of the removed arcs. Therefore, to get an efficient implementation, for each vertex vi
                         we first compute a sorted list of its neighbors according to increasing distance from vi
                        . Then, for each arc 
                           
                              (
                              
                                 v
                                 i
                              
                              ,
                              
                                 v
                                 
                                    i
                                    +
                                    1
                                 
                              
                              )
                           
                         to remove, we select the arc 
                           
                              (
                              
                                 v
                                 j
                              
                              ,
                              
                                 v
                                 
                                    j
                                    +
                                    1
                                 
                              
                              )
                           
                         such that

                           
                              
                                 
                                    
                                       c
                                       
                                          
                                             v
                                             i
                                          
                                          
                                             v
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    +
                                    
                                       c
                                       
                                          
                                             v
                                             j
                                          
                                          
                                             v
                                             
                                                j
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    >
                                    
                                       c
                                       
                                          
                                             v
                                             i
                                          
                                          
                                             v
                                             j
                                          
                                       
                                    
                                    +
                                    
                                       c
                                       
                                          
                                             v
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                          
                                             v
                                             
                                                j
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    ,
                                 
                              
                           
                        taking vj
                         from the sorted list for vi
                         until 
                           
                              
                                 c
                                 
                                    
                                       v
                                       i
                                    
                                    
                                       v
                                       j
                                    
                                 
                              
                              ≥
                              
                                 c
                                 
                                    
                                       v
                                       i
                                    
                                    
                                       v
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                 
                              
                           
                        .

However, if the original tour is infeasible (that is, if 
                           
                              infeas
                              (
                              
                                 T
                                 →
                              
                              )
                              >
                              0
                           
                        ) we allow the exploration of longer solutions. To this end we relax the above condition as follows. We introduce a parameter M and allow the algorithm checking all possible 2-opt moves satisfying

                           
                              
                                 
                                    
                                       c
                                       
                                          
                                             v
                                             i
                                          
                                          
                                             v
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    +
                                    
                                       c
                                       
                                          
                                             v
                                             j
                                          
                                          
                                             v
                                             
                                                j
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    +
                                    M
                                    >
                                    
                                       c
                                       
                                          
                                             v
                                             i
                                          
                                          
                                             v
                                             j
                                          
                                       
                                    
                                    +
                                    
                                       c
                                       
                                          
                                             v
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                          
                                             v
                                             
                                                j
                                                +
                                                1
                                             
                                          
                                       
                                    
                                    .
                                 
                              
                           
                        Vertices vj
                         from the sorted list are processed until 
                           
                              
                                 c
                                 
                                    
                                       v
                                       i
                                    
                                    
                                       v
                                       j
                                    
                                 
                              
                              +
                              M
                              ≥
                              
                                 c
                                 
                                    
                                       v
                                       i
                                    
                                    
                                       v
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                 
                              
                           
                        .

The 3-opt move consists of removing three arcs from the solution and reconnecting the paths by adding three arcs. There are four types of 3-opt moves to explore (excluding degenerate cases like 2-opt moves). They are illustrated in Fig. 2. Note that move (b) keeps the orientation of the three paths, while the other three moves require changing the orientation of some paths. As confirmed by our experiments (see Section 4.2), move (b) is likely to keep feasibility of a tour, and for that reason is more adapted for an improvement phase rather than for the perturbation phase. The operator exploring moves of type (b) is denoted by 3-opt-b, the operator exploring the other three moves by 3-opt-acd, and the operator exploring all the four 3-opt moves by 3-opt-abcd.


                        Insertion is a particular case of a 3-opt move where two of the three removed arcs are consecutive. Then, the effect of reconnecting the tour is that of moving a vertex forward or backward in a sequence. The forward insertion tries to find a shorter tour by moving a customer from its current position i to some further position j with j > i. This implies that all customers in positions 
                           
                              i
                              +
                              1
                              ,
                              …
                              ,
                              j
                           
                         have to be shifted backwards one position. Customers in positions 1 to 
                           
                              i
                              −
                              1
                           
                         and 
                           
                              j
                              +
                              1
                           
                         to n remain unchanged. This operator is denoted by fw-ins. The backward insertion works in a similar way, but this time the selected customer, at position i, is moved to a previous position j in the tour, j < i, and intermediate customers are shifted forward one position. The operator is denoted by bw-ins.

Before making a k-opt move, it is necessary to analyze the feasibility of the new tour. This implies evaluating Eq. (1), which requires O(mn) time when each term of the equation is computed. However, it can be done in a more efficient way using binary indexed tree (BIT) data structures as proposed in Mladenović et al. (2012) for the 1-PDTSP. The BIT structure can be used to calculate the maximum (or minimum) of an array of n elements in a time O(log n). This allows to reduce the complexity of the feasibility checking of a m-PDSTP solution to O(mlog n).

Briefly, let 
                           
                              
                                 T
                                 →
                              
                              =
                              
                                 (
                                 
                                    v
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    v
                                    n
                                 
                                 )
                              
                           
                         be a tour and let 
                           
                              
                                 l
                                 i
                                 k
                              
                              
                                 (
                                 
                                    T
                                    →
                                 
                                 )
                              
                           
                         be the amount of product k in the vehicle when leaving vi
                         (
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              n
                           
                        ). A BIT structure is built for each k ∈ K, storing the values 
                           
                              
                                 l
                                 i
                                 k
                              
                              
                                 (
                                 
                                    T
                                    →
                                 
                                 )
                              
                           
                         in the leaves of a the tree. If n is not a power of 2, the structure can be completed with leaves storing 0. Each parent node in the BIT stores the minimum of the quantities stored in its two children nodes. The construction of the BIT can be done in O(n) time for each k. Similarly, an extra BIT structure is used to calculate the maximum of the values 
                           
                              
                                 ∑
                                 
                                    k
                                    ∈
                                    K
                                 
                              
                              
                                 l
                                 i
                                 k
                              
                           
                        . Mladenović et al. (2012) give a pseudo-code and a detailed example of this procedure for the 1-PDTSP which can be easily adapted for the m-PDTSP.

As observed in Hansen and Mladenović (2006), one can analyze all solutions of a k-opt operator and select the best one, or quit the operator with the first solution that improves the initial tour. Based on preliminary experiments, we opted for the strategy that analyzes all solutions.

A related approach for the dial-a-ride routing problem was originally introduced by Psaraftis (1983). This problem is a particular case of the uncapacitated one-to-one m-PDTSP, and the approach in Psaraftis (1983) has not an immediate extension to the m-PDTSP.

To escape from local minima, we make use of shaking procedures, which are random moves to perturb solutions. We now describe three shaking procedures. Different combinations of them are empirically analyzed in Section 4.3.

The first shaking procedure is denoted by 3-opt-rand and performs a random 3-opt move, i.e. it selects three non-consecutive arcs and reconstructs a new tour according to Fig. 2. If the infeasibility of the new tour is bigger than the one of the initial tour, another random move is done. On the other hand, a new tour with worse cost is allowed as long as the infeasibility does not increase. In the worse case, all the 3-opt moves could be examined.

The second shaking procedure is called double-bridge and denoted by db-rand. It performs random 4-opt moves keeping the orientation of the four paths. The type of move is illustrated in Fig. 3
                        . Other types of 4-opt moves were considered but discarded because checking the feasibility issue is quite time consuming and reversing paths rarely improves the feasibility with respect to the initial tour. As before, db-rand is repeated until the infeasibility of the new tour is equal to or smaller than that of the initial tour.

The third shaking procedure, denoted by mip-rand, uses the mathematical formulation (2)–(7). To avoid solving a large and complex model, a given percentage of binary variables are a priori fixed, thus reducing the size of the models. This approach is similar to other variable fixing approaches in the literature like the so-called kernel search (see, e.g., Guastaroba & Speranza, 2012). In our implementation, the variables fixed to 1 are chosen randomly among those corresponding to arcs used in the incumbent solution 
                           
                              T
                              →
                           
                        . The restricted model is then solved using the branch-and-cut algorithm described in Hernández-Pérez and Salazar-González (2014). To speed up the algorithm, a portion of variables with large modified travel cost dij
                         are fixed to 0 also, unless it corresponds to an arc in 
                           
                              T
                              →
                           
                        . The percentages of binary variables fixed to 1 and fixed to 0 are dynamically set in order to keep the optimality gap small. The dynamic setting is explained in Section 4.

The branch-and-cut algorithm is initialized with the current best solution. In addition, it includes a primal heuristic procedure based on the nearest neighborhood for the TSP. More precisely, given a fractional solution x
                        *, it uses the approach described in Section 3.1 with 
                           
                              
                                 d
                                 
                                    i
                                    j
                                 
                              
                              =
                              1
                              −
                              
                                 x
                                 
                                    i
                                    j
                                 
                                 *
                              
                           
                         for each arc (i, j). The procedure is repeated starting from different vertices, and the 2-opt local search operator described in Section 3.2 is applied to the best solution if feasible. The branch-and-cut algorithm stops if a time limit is reached or the number of branching nodes exceeds a given threshold.

To calibrate the algorithm and find reasonable values for its different parameters, we conducted preliminary computational experiments using a set of instances with 
                        
                           m
                           =
                           4
                           ,
                        
                      
                     n ∈ {40, 60, 80, 100, 200, 400} and Q ∈ {40, 60}. The way these instances were generated is explained in Section 5. We considered one instance for each n and Q, and the execution of the algorithm was limited to n seconds on each instance. We will next comment the calibration of the parameters involved in the algorithm.

To tune the parameters C and α of the initial phase, we run it 1000 times over each of the medium and large test instances (n ∈ {100, 200, 400}). The computational time was less than 0.01 seconds for each run. Table 1 shows the percentage of feasible solutions obtained (Fea.), the average percentage of deviation between the best feasible solution found and the best known solution (Avg.), and the percentage of repeated solutions (Rep.) for different values of α and C.

We can see that the value of α does not affect the percentage of feasible solutions much, but it has a great influence in the quality of the solutions. Larger α
                        1 values produce best quality feasible solutions, but also a higher percentage of repeated solutions, especially for small sizes n. On the other hand, the larger the C value, the larger the percentage of feasible solutions and the smaller the quality of those solutions. Note that the algorithm does not find any feasible solution when 
                           
                              Q
                              =
                              40
                           
                         and 
                           
                              C
                              =
                              0
                           
                        . Taken all this into account, we decided to set 
                           
                              α
                              =
                              (
                              1
                              −
                              
                                 2
                                 n
                              
                              ,
                              
                                 1
                                 n
                              
                              ,
                              
                                 1
                                 n
                              
                              )
                           
                         and C to a variable value initialized to 
                           
                              C
                              =
                              2
                           
                         which is increased when the rate of feasible solutions is low and is decreased when the rate of feasible solutions is high. More precisely, when the rate (observed in the last 1000 runs of the initial heuristic) is smaller than 0.5 percent the parameter C is multiplied by 1.2, and when the rate is greater than 20 percent the parameter C is multiplied by 0.9.

The third parameter in the initialization phase is MS
                        0, the number of times that the randomized greedy procedure is launched. The fourth parameter is MS
                        1, the number of solutions selected from the initialization phase. These parameters affect the improvement phase. For that reason we conducted experiments by running the 2-opt operator with different values for MS
                        0 and MS
                        1. Based on our experiments we decided to set 
                           
                              M
                              
                                 S
                                 0
                              
                              =
                              200000
                           
                         and 
                           
                              M
                              
                                 S
                                 1
                              
                              =
                              20
                           
                        . At first glance, the high value of MS
                        0 may be surprising. This decision is explained by three arguments. First, the randomized greedy procedure is quite simple and fast. Second, the improvement operators hardly produce feasible solutions from infeasible ones. More precisely, in our preliminary experiments only 12 percent of infeasible greedy solutions yield feasible solutions through the 2-opt operator. Third, we observed a high correlation coefficient (
                           
                              ρ
                              =
                              0.74
                           
                         in our experiments) between the solution value from the greedy procedure and the solution value after the improvement phase.

In addition to the iteration limit MS
                        0, the phase stops with a time limit of n/4 seconds.

The improvement phase depends on one parameter M, described in Section 3.2 and intended to allow movements between solutions with higher cost and smaller infeasibility. We made experiments with different values of M and decided to set it to zero. This may be explained because local search procedures rarely find feasible solutions when the initial ones are infeasible, as mentioned before.

To decide the operators to be included in the final version of our algorithm, and the order to apply these operators, we have studied the effect of different combinations in the improvement phase. There are many possible combinations, and we have compared some of them through computational experiments. Table 2
                         shows the results from four combinations with better results in terms of solution quality and computational time. These combinations include the operators 2-opt, fw-ins and bw-ins in this order, and differ in the type of 3-opt moves examined. The table shows, for medium and large instances, the average percentage of deviation from the best known solutions (Avg.) and the computational time (Time) obtained by the four permutations. Based on these results we decided to include in the final VND procedure only the following operators: 2-opt, fw-ins, bw-ins and 3-opt-b. We consider that this choice provides a good balance between solution quality and computational time.

This phase is limited in time to at most n/2 seconds.

The time limit for this phase is the total time minus the time consumed by the previous phases.

The parameters of the MIP-based shaking procedure mip-rand are set as follows. We impose a time limit of n/10 seconds and a limit of 200 branching nodes to the MIP solver on each model. The number of random variables fixed to 0 and fixed to 1 is set to p
                        0|A| and p
                        1
                        n respectively, being 
                           
                              
                                 p
                                 0
                              
                              =
                              0
                           
                         and 
                           
                              
                                 p
                                 1
                              
                              =
                              0.2
                           
                         initially. The values of p
                        0 and p
                        1 are increased by 0.05 if the gap between the lower and upper bounds is larger than 20 percent, they are decreased by 0.05 if the restricted model was optimally solved, and they are unchanged otherwise. This process is repeated until a total time limit is reached or 10 iterations have failed to find a better solution. The random component of the process is aimed to generate different tours, and for that reason mip-rand is used as a shaking procedure. We emphasize that the primal-heuristic procedure embedded in the branch-and-cut approach plays an important role in the generation of feasible solutions.

We now describe three different strategies combining the three shaking procedures introduced in Section 3.3.

Strategy I consists of applying 3-opt-rand and db-rand to the current solution. It is an iterative procedure that at iteration l performs 
                           
                              ⌊
                              (
                              l
                              +
                              3
                              )
                              /
                              2
                              ⌋
                           
                         moves for 
                           
                              l
                              =
                              1
                              ,
                              …
                              ,
                              10
                           
                        . A 3-opt move is applied with probability 0.8, thus a double-bridge moves with probability 0.2. We accept a solution from a move even when its cost is larger than the cost of the current solution. However, a worsening is allowed only when the new cost is smaller than 1.05 times the current best value. We must recall also that a solution is also discarded when its infeasibility is larger than the one of the current solution. If a solution from a move is accepted, it replaces the current solution for the next move. The VND in Section 3.2 is applied to the current solution after the last move of the iteration.

Strategy II consists of applying the shaking procedure mip-rand. We must recall that it is an iterative procedure that solves mathematical formulations with fixed randomly-selected variables.

Strategy III applies Strategies I and II, one after the other, with half time and iteration limits.

We conducted preliminary computational experiments to compare the three strategies. Table 3
                         shows average deviations and computing times for small and medium size instances (n ≤ 100). Each row corresponds to 10 runs of the algorithm over each instance. When n is small and the vehicle capacity is not tight (for example, 
                           
                              Q
                              =
                              60
                           
                        ), the three strategies produced similar results, and it is difficult to say if one is better than the others. However, on larger instances (say n ≥ 80) the first strategy outperforms the other two. This is mainly due to the fact that mip-rand typically achieves its time limit with solutions of poor quality for large instances.

Based on these preliminary experiments, the next section analyzes the three strategies for small instances and the algorithm with the first strategy for large instances.

To evaluate the performance of the algorithm we have considered the set of 240 small instances already used in Hernández-Pérez and Salazar-González (2014) with 
                        
                           n
                           =
                           30
                           ,
                        
                      generated using a method similar to that proposed by Mosheiov (1994). A new set of medium and large size instances is generated in the same way. For each number n of locations, the generator produces 
                        
                           n
                           −
                           1
                        
                      random pairs of coordinates (points) in the square 
                        
                           [
                           −
                           500
                           ,
                           500
                           ]
                           ×
                           [
                           −
                           500
                           ,
                           500
                           ]
                           ,
                        
                      and the depot is located in (0, 0). The travel cost cij
                      is computed as the Euclidean distance between the points i and j. The depot does not demand any commodity (i.e. 
                        
                           
                              q
                              1
                              k
                           
                           =
                           0
                        
                      for all k ∈ K). The demands 
                        
                           q
                           i
                           k
                        
                      are randomly generated in 
                        
                           [
                           −
                           10
                           ,
                           10
                           ]
                        
                      for all 1 < i < n and all k ∈ K. For each k ∈ K, the value 
                        
                           q
                           n
                           k
                        
                      is defined to ensure 
                        
                           
                              ∑
                              
                                 i
                                 ∈
                                 V
                              
                           
                           
                              q
                              i
                              k
                           
                           =
                           0
                        
                     . If 
                        
                           
                              q
                              n
                              k
                           
                           ∉
                           
                              [
                              −
                              10
                              ,
                              10
                              ]
                           
                        
                      then the random generator is applied to produce new 
                        
                           q
                           i
                           k
                        
                      values. Observe that 
                        
                           −
                           10
                           
                           m
                           ≤
                           
                              ∑
                              
                                 k
                                 ∈
                                 K
                              
                           
                           
                              q
                              i
                              k
                           
                           ≤
                           10
                           
                           m
                        
                      for all i. For that reason we have considered instances with Q ≥ 10 m. We generated a group of four random instances (A,B,C,D) for each value m ∈ {3, 4, 5}, each n ∈ {100, 200, 400} and each 
                        
                           Q
                           ∈
                           {
                           10
                           
                           m
                           ,
                           10
                           
                           m
                           +
                           20
                           ,
                           10
                           
                           m
                           +
                           40
                           }
                        
                     . Therefore, our benchmark collection of medium and large m-PDTSP instances contains 108 items.

The branch-and-cut algorithm described in Hernández-Pérez and Salazar-González (2014) was able to find the optimal solutions for some small instances with n ∈ {20, 25, 30}, m ∈ {2, 3}, and Q ∈ {10, 12, 15, 17, 20, 25}. Table 4
                     
                      summarizes and compares the computational results given by the branch-and-cut algorithm and the heuristic approaches on the set of instances with 
                        
                           n
                           =
                           30
                        
                     . The branch-and-cut algorithm was able to solve to optimality 206 instances out of the 240 items (see the first two columns). From the results for these instances, there is not a clear difference between the three shaking strategies. We show the results for the three implementations. Each implementation was run 10 times over each instance, thus each heuristic approach was run 2060 times on instances where the optimal solution is known, and 340 times on instance without optimality proofs. Columns Improv. displays the number of times that the objective value of an implementation was equal or better than the one of the branch-and-cut algorithm. Similarly, Columns Avg. and Time give the average deviation and the average time, respectively. It is interesting to observe that the three implementations were successful in finding better solutions on difficult instances for the branch-and-cut approach. Strategy III (i.e. the one combining the three shaking procedures) is the one that performs slightly better, finding 
                        
                           2023
                           +
                           331
                        
                      times a solution that improves or equals the one given by the branch-and-cut algorithm.

To see the effect of the vehicle capacity, we conducted some experiments on an instance with 
                        
                           n
                           =
                           25
                           ,
                        
                     
                     
                        
                           m
                           =
                           3
                        
                      and different capacities. It is a variant of an instance given by Mosheiov (1994) for a related pickup-and-delivery problem. Table 5 shows the computational results of the three implementations compared with the results of the branch-and-cut algorithm. The results are divided in two parts. The top part of the table shows the results obtained when the initial load of the vehicle is unfixed, and the bottom part shows the results when the vehicle leaves the depot with empty load. The time limit of the branch-and-cut algorithm was 10000 seconds. It could not certificate that the solutions of the two instances with Q = 9 were optimum solutions. Regarding the heuristic implementations, the difficulty of obtaining a solution increases when the vehicle capacity decreases. This is due to the complexity of checking the feasibility of tours. In addition, requiring an empty initial load reduces the feasibility region, and makes the problem slightly more difficult. Strategy III gives the lowest average deviation of 0.09 percent, while Strategy II gives the second lowest of 0.16 percent and Strategy I gives 0.28 percent. Regarding computational time, Strategy I was faster than the others on these instances.


                     Table 6
                     
                      shows the computational results obtained by using our implementation with Strategy I on the set of 108 instances with medium and large size. For these instances the optimal solution is not known. Each row corresponds to 10 runs of the algorithm over an instance. Column headings stand for the best solution value found in the 10 runs (Best), the gap between the average and best values (Avg.), and the average computational time (Time) of a run. The table shows that the algorithm is quite robust in the sense that the deviation between the best and average solution values is around 3 percent, never larger than 7 percent. Another aspect to point out is that the best solution values for those instances with tight capacity (
                        
                           Q
                           =
                           10
                           
                           m
                        
                     ) are usually much larger, almost double, than the best solution values for the instances with loose capacity (
                        
                           Q
                           =
                           10
                           
                           m
                           +
                           40
                        
                     ). This fact indicates that the difficulty of the problem increases notably when the capacity is tighter. Regarding computational times, they get larger when n increases, as expected, but they also augment when the number m of products to transport increases and the vehicle capacity Q is tight. This might be due to the fact that the number of k-opt feasibility checks increases. Finally, there are several entries in the table where the computational time exceeds the time limit of n seconds. This occurs because the stopping criterion on a time limit is performed after the end of a shaking procedure.

Finally, although the algorithm presented in this paper has not been designed to tackle the 1-PDTSP, it can be applied to that problem since it is a particular case of the m-PDTSP. Table 7 compares the performance of our approach and other heuristic algorithms described in the literature to solve the 1-PDTSP. GRASP/VND refers to the algorithm proposed by Hernández-Pérez et al. (2009); GA refers to the Genetic Algorithm proposed by Zhao et al. (2009); Seq-GVND and Mix-GVND refer to the algorithms based on the General Variable Neighborhood Search proposed by Mladenović et al. (2012); Strategy I refers to our implementation where the shaking phase uses the first strategy described in Section 4.3. Each row shows the computational results for ten 1-PDTSP instances with a given number of customers n and capacity Q. We report results taken from Mladenović et al. (2012), where the best and average values for GRASP/VNS and GA are based on 10 runs, and for Seq-GVND and Mix-GVND on 20 runs. In addition the table reports the results of our implementation based on 20 runs. For each approach and each row in the table, Best is the average gap between the best value generated by that approach on each instance in that row, and the best value generated by all the approaches on the same instance. Similarly, Avg. is the average gap between the average value generated by that approach on each instance in that row, and the best value generated by all the approaches on the same instance. Finally, Time is the average computational time. For the GA algorithm, there are not results for the instances with Q > 10, and therefore the cells in the table are empty. Observe that the our approach (Strategy I) gives better results than the GRAS/VND and GA methods. However, the GVND algorithms given by Mladenović et al. (2012) outperform our approach. Nevertheless, recall that ours is designed to tackle a more general problem, and for this reason it does not take advantage of certain particularities of the case 
                        
                           m
                           =
                           1
                        
                     . For example, the GVND algorithm uses the fact that if the load of the vehicle when leaving a customer is identical for two customers, they can be interchanged in a k-opt move without requiring the feasibility check. This happens frequently when solving 1-PDTSP instances where the demands of the customers have been generated in the interval [
                        −
                     10, 10].

@&#CONCLUSIONS@&#

This paper proposes a heuristic approach to solve the multi-commodity Pickup-and-Delivery Traveling Salesman Problem. This problem is an interesting and complex routing problem as it generalizes (and is related to) many other variants that have been addressed in the vehicle routing literature during recent years. It concerns the problem of finding a minimum-cost Hamiltonian route for a capacitated vehicle that must collect and deliver several products, each one with possibly several origins and several destinations. We describe and analyze a hybrid approach that merges improvement operators and shaking procedures, one of them based on solving a MIP model. The algorithm has proved to be effective to solve difficult instances with up to 400 customers and 5 products.

@&#REFERENCES@&#

