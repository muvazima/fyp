@&#MAIN-TITLE@&#GPU-accelerated iterative reconstruction from Compton scattered data using a matched pair of conic projector and backprojector

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Acceleration of iterative Compton camera reconstruction using graphics processing unit.


                        
                        
                           
                           Exactly matched pair of conic projector and backprojector.


                        
                        
                           
                           Significantly reduced reconstruction time without loss of accuracy.


                        
                        
                           
                           Improvement of reconstruction accuracy in advanced iterative methods.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Compton camera

Iterative reconstruction

GPU-accelerated reconstruction

Projector and backprojector

Ray-tracing method

@&#ABSTRACT@&#


               
               
                  Background and Objective
                  Iterative reconstruction from Compton scattered data is known to be computationally more challenging than that from conventional line-projection based emission data in that the gamma rays that undergo Compton scattering are modeled as conic projections rather than line projections. In conventional tomographic reconstruction, to parallelize the projection and backprojection operations using the graphics processing unit (GPU), approximated methods that use an unmatched pair of ray-tracing forward projector and voxel-driven backprojector have been widely used. In this work, we propose a new GPU-accelerated method for Compton camera reconstruction which is more accurate by using exactly matched pair of projector and backprojector.
               
               
                  Methods
                  To calculate conic forward projection, we first sample the cone surface into conic rays and accumulate the intersecting chord lengths of the conic rays passing through voxels using a fast ray-tracing method (RTM). For conic backprojection, to obtain the true adjoint of the conic forward projection, while retaining the computational efficiency of the GPU, we use a voxel-driven RTM which is essentially the same as the standard RTM used for the conic forward projector.
               
               
                  Results
                  Our simulation results show that, while the new method is about 3 times slower than the approximated method, it is still about 16 times faster than the CPU-based method without any loss of accuracy.
               
               
                  Conclusions
                  The net conclusion is that our proposed method is guaranteed to retain the reconstruction accuracy regardless of the number of iterations by providing a perfectly matched projector–backprojector pair, which makes iterative reconstruction methods for Compton imaging faster and more accurate.
               
            

@&#INTRODUCTION@&#

Compton imaging is a three-dimensional (3D) emission imaging technique to visualize the gamma-rays that undergo Compton scattering, whose applications are in a variety of fields such as nuclear medicine, gamma-ray astronomy, and security [1–4]. A Compton camera uses two types of detectors, a scatterer and an absorber. The valid events are recorded when the photons that reach the scatterer are Compton scattered and detected by the absorber in coincidence with the events in the scatterer (See Fig. 1
                     ). The scattering angle of a photon is measured using the energies of the electron at rest and the scattered photon [5]. In this case, the incident direction of the emitted photon on the scatterer can be computed within a conic surface of ambiguity. Therefore, the projection and backprojection operations involved in a reconstruction algorithm for Compton imaging must be performed by the conic surface integral rather than the line integral used for conventional tomographic reconstruction. Due to computational complexity of such operations, reconstruction from Compton scattered data using an iterative method has been of a challenging problem.

Recently, with the successful development of block-iterative methods for emission tomography, fast iterative reconstruction methods for Compton imaging have also been proposed [6–9] and further accelerated by using the GPU [6,10]. In fact, there have been substantial developments of accelerating the computational speed of projection and backprojection in iterative reconstruction for both transmission and emission tomography by using the GPU [11]. (An overview of existing methods for Compton camera reconstruction can be found in [12,13].)

Since the size of the system matrix for a typical Compton camera is intractably large, the conventional central processing unit (CPU)-based methods to calculate conic projection and backprojection, which include a caching scheme that pre-calculates elements of the system matrix and repeatedly use them in every iteration, are almost impractical. To parallelize such time-consuming operations, one can consider utilizing the GPU which has attracted great interest in iterative reconstruction for conventional computed tomography. However, unlike the conic projection operation which can be easily parallelized with a ray-tracing [14] forward projector, the conic backprojection operation is challenging. In [6], to develop GPU-accelerated methods that can rapidly perform conic backprojection on the fly, two different approximated schemes were proposed, where none of the two schemes was matched with the ray-tracing forward projector. Although the approximated methods significantly reduced the computation time, they had an unfortunate effect of causing a visually noticeable error in the reconstruction due to the mismatch between the projector and backprojector when compared with the result obtained by the exact calculation using a matched projector–backprojector pair implemented with the CPU. Moreover, the error gradually became larger as the number of iterations increased.

In this work, to avoid the approximation error, which could be significant when a large number of iterations are required, we propose a new GPU-accelerated ray-tracing method (RTM) for both projection and backprojection which does not use any approximations for parallelizing the operations. Since our method is exact, the result is as accurate as those obtained from the non-accelerated method.

The present work is inspired by our work for parallelizing a matched pair of ray-tracing projector and backprojector for iterative cone-beam CT (CBCT) reconstruction [15] where the matched pair clearly provides better reconstruction accuracy than the unmatched pair. One can easily expect that the improvement of the reconstruction accuracy by using a matched projector–backprojector pair will be more apparent when it is applied to low-resolution reconstruction such as the Compton camera reconstruction considered in this work. While the basic idea proposed in [15] is directly applicable to any conventional tomography reconstruction that involves line integral-based projection and backprojection operations, its application to a Compton camera is uniquely challenging because Compton camera reconstruction involves surface integral-based projection and backprojection operations that are considerably more complicated than the simple line integral-based operations.

In this work, to minimize computations for conic backprojection while keeping their accuracy, we propose a new scheme to properly indicate the possible cones that can pass through a voxel. Then the intersecting area of a cone with the voxel is calculated by summing all of the intersecting chord lengths in the voxel. As the procedure to calculate the intersecting area in this case is identical to that for forward projection, the resulting conic projector–backprojector pair becomes exactly matched.

The remainder of this paper is organized as follows. Section 2 presents an exact and parallelizable method to efficiently perform conic projections and backprojections for Compton camera reconstruction. This section also briefly describes an iterative algorithm for Compton camera reconstruction which is used in our experiments for the performance test of our proposed methods. Section 3 presents our simulation studies to compare the computational performance of the proposed GPU-based method with that of the conventional CPU-based method and also with that of other previous GPU-based methods. Section 4 concludes our work.

@&#METHODS@&#

We consider a typical Compton camera geometry consisting of two parallel detector planes as shown in Fig. 1. A valid event in this model is that a photon incident on the camera undergoes Compton scattering in the first detector (the scatterer) and then is completely absorbed in the second detector (the absorber). The quantities measured in this event are: the detected position 
                           
                              m
                              
                                 (
                                 
                                    
                                       x
                                       1
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       1
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       1
                                    
                                 
                                 )
                              
                           
                         in the scatter, the detected position 
                           
                              n
                              
                                 (
                                 
                                    
                                       x
                                       2
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       2
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       2
                                    
                                 
                                 )
                              
                           
                         in the absorber, and the scattering angle ω determined from the amount of energy transferred to the scatter.

In this work, we model both the scatter and the absorber as 2D binned detectors. The detected positions 
                           
                              m
                              
                                 (
                                 
                                    
                                       x
                                       1
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       1
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       1
                                    
                                 
                                 )
                              
                           
                         and 
                           
                              n
                              
                                 (
                                 
                                    
                                       x
                                       2
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       2
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       2
                                    
                                 
                                 )
                              
                           
                         in this case correspond to the center of the m
                        th scatterer bin and the center of the n
                        th absorber bin, respectively. The range of the scattering angle ω is uniformly sampled into S discrete angles. Each cone surface is sampled by N evenly distributed conic rays.

The forward projection is modeled as 
                           
                              
                                 g
                                 i
                              
                              =
                              
                                 ∑
                                 j
                              
                               
                              
                                 H
                                 
                                    i
                                    j
                                 
                              
                              
                                 f
                                 j
                              
                           
                         where f and g denote the source intensity and projection data, respectively, and 
                           
                              
                                 H
                                 
                                    i
                                    j
                                 
                              
                              ≥
                              0
                           
                         denotes the element of the forward projection matrix. Hij
                         can be modeled as 
                           
                              
                                 P
                                 
                                    i
                                    j
                                 
                              
                              ×
                              
                                 P
                                 ω
                              
                           
                         where Pij
                         is the probability that the jth
                         voxel belongs to the cone surface specified by i(m,n,ω), and Pω
                         is the probability related to Compton scattering interaction on the scatterer. While Pω
                         corresponds to the differential cross-section for the Compton scattering, Pij
                         is modeled as the sum up of the intersecting chord lengths of the rays on the ith
                         cone passing through the jth
                         voxel.

The GPU-accelerated conic forward projections are performed in such a way that each thread of the GPU independently and simultaneously computes one or several conic surface integrals. To calculate conic forward projection, we accumulate the intersecting chord lengths of the rays passing through the voxels using the fast RTM [16]. The outline of conical projection when a GPU kernel computes one conical projection is summarized in Table 1
                        .

The backprojection is given by 
                           
                              
                                 s
                                 j
                              
                              =
                              
                                 ∑
                                 i
                              
                               
                              
                                 H
                                 
                                    i
                                    j
                                 
                              
                              
                                 q
                                 i
                              
                           
                         which indicates that the value of qi
                         in the i
                        th projection bin is backprojected to the j
                        th voxel resulting in sj
                        . To achieve a matched projector–backprojector pair, we propose a new voxel-driven backprojection method that uses the same RTM as the forward projection in the GPU. Compared to the previous methods [6] that calculate the intersecting ray lengths in a voxel using approximations, the new method calculates exact values of the intersecting ray lengths. Just like our previous methods, the new method is also parallelizable and optimized for the GPU.

To perform backprojection to a voxel j, for each detected position pair 
                           
                              m
                              
                                 (
                                 
                                    
                                       x
                                       1
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       1
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       1
                                    
                                 
                                 )
                              
                           
                         and 
                           
                              n
                              
                                 (
                                 
                                    
                                       x
                                       2
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       2
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       2
                                    
                                 
                                 )
                              
                           
                        , the range of angular coverage of the sphere V that encloses the voxel j is first determined (see Fig. 2
                        ). The range of angular coverage in Fig. 2 is 
                           
                              
                                 [
                                 
                                    
                                       ω
                                       ⌢
                                    
                                    −
                                    θ
                                    ,
                                     
                                    
                                       ω
                                       ⌢
                                    
                                    +
                                    θ
                                 
                                 ]
                              
                           
                        . Each sampled scattering angle ω falling into the range is then considered as an angle for the cone (the i
                        th cone indexed by (m,n,ω)) that penetrates the voxel j. Having found the sampled rays on the cone surface that pass through the sphere, we use the fast RTM to measure the intersecting chord lengths.

For more details, we first describe how we model the cones in the program. We pre-compute and store the coordinates of detected positions m and n in the scatter and absorber, respectively. For S discrete scattering angles, each of which defines a cone that is sampled into N conic rays, we first compute reference coordinates of the virtual ending points of N × S sampled conic rays whose common cone axis is the line connecting the two detected positions 
                           
                              
                                 m
                                 ¯
                              
                              
                                 (
                                 
                                    0
                                    ,
                                     
                                    0
                                    ,
                                     
                                    
                                       z
                                       1
                                    
                                 
                                 )
                              
                           
                         and 
                           
                              
                                 n
                                 ¯
                              
                              
                                 (
                                 
                                    0
                                    ,
                                     
                                    0
                                    ,
                                     
                                    
                                       z
                                       2
                                    
                                 
                                 )
                              
                           
                        . The ending points are on a 2D virtual plane which is placed far enough from the scatterer so that the rays can pass through the reconstructing volume (see Fig. 3
                        ). The ending points of the rays that belong to a certain cone surface defined by (m,n,ω) can be easily computed by rotating and translating the pre-calculated reference coordinates of the ending points.

For the cone defined by (m,n,ω), the coordinates of the starting and ending points can be computed easily from m, n, ω, and the pre-computed reference coordinates of the ending points of N × S sampled conic rays. Each GPU thread can then perform the calculation of the traditional RTM for forward projection.

For conic backprojection, each GPU thread performs backprojection to each voxel j centered at 
                           
                              V
                              
                                 (
                                 
                                    
                                       x
                                       v
                                    
                                    ​
                                    ,
                                     
                                    
                                       y
                                       v
                                    
                                    ​
                                    ,
                                     
                                    
                                       z
                                       v
                                    
                                 
                                 )
                              
                           
                        . The computation repeats over all possible detected position pairs of m and n. For each pair (m,n), the angular coverage of the sphere V due to scattering is in 
                           
                              
                                 [
                                 
                                    
                                       ω
                                       ⌢
                                    
                                    −
                                    θ
                                    ,
                                     
                                    
                                       ω
                                       ⌢
                                    
                                    +
                                    θ
                                 
                                 ]
                              
                           
                         (see Fig. 2). In order to avoid redundant calculations in backprojection for all detected position pairs, one can calculate the rays passing through the sphere V(x,y,z) by transforming the corresponding cone specified by (m,n,ω) to the reference cone specified by 
                           
                              
                                 (
                                 
                                    
                                       m
                                       ¯
                                    
                                    ,
                                     
                                    
                                       n
                                       ¯
                                    
                                    ,
                                     
                                    ω
                                 
                                 )
                              
                           
                        . In this case, if the range of the angular coverage is in 
                           
                              
                                 [
                                 
                                    β
                                    −
                                    ε
                                    ,
                                     
                                    β
                                    +
                                    ε
                                 
                                 ]
                              
                           
                         (where β is the angle formed by V and the y-axis as show in Fig. 2, and ε is the angular coverage of the sphere which corresponds to a circle on the x-y plane), then the sampled rays in the cone (m,n,ω) that intersects the sphere V (and the voxel j) have the index within the range 
                           
                              
                                 [
                                 
                                    
                                       ⌊
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      β
                                                      −
                                                      ε
                                                   
                                                   )
                                                
                                             
                                             /
                                             ρ
                                          
                                       
                                       ⌋
                                    
                                    ,
                                     
                                    
                                       ⌊
                                       
                                          
                                             
                                                
                                                   (
                                                   
                                                      β
                                                      +
                                                      ε
                                                   
                                                   )
                                                
                                             
                                             /
                                             ρ
                                          
                                       
                                       ⌋
                                    
                                 
                                 ]
                              
                           
                         where ρ = 2π/N. For each ray in the range, the intersecting chord lengths are measured using the fast RTM [16] to find weights for backprojection along the ray.

The outline of our ray-tracing backprojection is summarized in Table 2
                        . The procedure described in Table 2 is performed independently and simultaneously by each thread of the GPU.

While our GPU-accelerated methods are applicable to any iterative reconstruction methods for a Compton camera, we apply here to the complete-data ordered subsets expectation maximization (COSEM) algorithm [17], which is known as one of the most accurate and fast block-iterative algorithms for emission tomography. The COSEM algorithm is attractive in that it converges quickly and avoids the need for a user-specified relaxation schedule which is in fact a serious inconvenience for conventional relaxed OS algorithms [18]. In this subsection, we briefly describe the GPU-accelerated COSEM algorithm for Compton camera reconstruction.

The conventional maximum likelihood (ML) approach to the problem of emission tomography reconstruction is to minimize the following objective function using the expectation maximization (EM) algorithm: 
                           
                              
                                 E
                                 
                                    inc-ML
                                 
                              
                               
                              
                                 (
                                 f
                                 )
                              
                              =
                              
                                 
                                    ∑
                                    
                                       i
                                       j
                                    
                                 
                                 
                                    
                                       H
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       f
                                       j
                                    
                                 
                              
                              −
                              
                                 
                                    ∑
                                    i
                                 
                                 
                                    
                                       g
                                       i
                                    
                                    log
                                    
                                       
                                          ∑
                                          j
                                       
                                       
                                          
                                             H
                                             
                                                i
                                                j
                                             
                                          
                                          
                                             f
                                             j
                                          
                                       
                                    
                                 
                              
                           
                        , which is regarded as the incomplete-data objective in comparison with the complete data objective for the COSEM algorithm.

The COSEM algorithm is based on a re-derivation of the ML-EM algorithm by adding a new parameter to be estimated for the complete data 
                           C
                         with a complete-incomplete data constraint and resulting in an alternating minimization over two parameters (the original parameter f for the underlying source and the new parameter 
                           C
                         for the complete data). The complete-data objective for the COSEM algorithm is given by [17]
                        
                           
                              
                                 
                                    
                                       
                                          
                                          
                                             E
                                             
                                                cmp-ML
                                             
                                          
                                           
                                          
                                             (
                                             
                                                C
                                                ,
                                                 
                                                f
                                                ,
                                                 
                                                ς
                                             
                                             )
                                          
                                          =
                                          
                                          −
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                p
                                             
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ∈
                                                         
                                                            S
                                                            k
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            ∑
                                                            j
                                                         
                                                         
                                                            
                                                               C
                                                               
                                                                  i
                                                                  j
                                                               
                                                            
                                                            log
                                                            
                                                               H
                                                               
                                                                  i
                                                                  j
                                                               
                                                            
                                                            
                                                               f
                                                               j
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          +
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                
                                                   H
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                
                                                   f
                                                   j
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                          
                                           
                                          +
                                           
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   =
                                                   1
                                                
                                                p
                                             
                                             
                                                
                                                   
                                                      ∑
                                                      
                                                         i
                                                         ∈
                                                         
                                                            S
                                                            k
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                            ∑
                                                            j
                                                         
                                                         
                                                            
                                                               C
                                                               
                                                                  i
                                                                  j
                                                               
                                                            
                                                            log
                                                            
                                                               C
                                                               
                                                                  i
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          +
                                          
                                             
                                                ∑
                                                i
                                             
                                             
                                                
                                                   ς
                                                   i
                                                
                                                 
                                                
                                                   (
                                                   
                                                      
                                                         
                                                            ∑
                                                            j
                                                         
                                                         
                                                            
                                                               C
                                                               
                                                                  i
                                                                  j
                                                               
                                                            
                                                         
                                                      
                                                      −
                                                      
                                                         g
                                                         i
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        where the elements Cij
                         of the complete data 
                           C
                         are positive real and obey the constraint 
                           
                              
                                 
                                    ∑
                                    j
                                 
                                 
                                    
                                       C
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                              =
                              
                                 g
                                 i
                              
                           
                         which is imposed via Lagrange parameters ςi
                        , p is the number of subsets of projection angles. The alternating update equations for the COSEM algorithm are obtained by alternatively differentiating the complete data objective with respect to Cij
                         (while keeping fj
                         fixed) and fj
                         (while keeping Cij
                         fixed) and setting each result to zero. The Lagrange parameter vector ς is eliminated by the constraint 
                           
                              
                                 
                                    ∑
                                    j
                                 
                                 
                                    
                                       C
                                       
                                          i
                                          j
                                       
                                    
                                 
                              
                              =
                              
                                 g
                                 i
                              
                           
                        .

The COSEM algorithm first subdivides projection data into an ordered sequence of p disjoint subsets Sk
                        ; k = 1,…,p. An iteration of the COSEM algorithm is defined as a single pass through all p subsets. Table 3
                         shows the outline of the COSEM algorithm, where the following notations [17] are used to express the projection and backprojection operations more explicitly:
                           
                              
                                 
                                    
                                       A
                                       j
                                       
                                          
                                             (
                                             
                                                n
                                                ,
                                                k
                                             
                                             )
                                          
                                       
                                    
                                    
                                       =
                                       
                                          def
                                       
                                    
                                    
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             
                                                S
                                                k
                                             
                                          
                                       
                                       
                                          
                                             C
                                             
                                                i
                                                j
                                             
                                             
                                                
                                                   (
                                                   
                                                      n
                                                      ,
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    ​
                                    ,
                                     
                                    k
                                    =
                                    1
                                    ,
                                     
                                    …
                                     
                                    ,
                                     
                                    p
                                     
                                    ∀
                                    j
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       B
                                       j
                                       
                                          
                                             (
                                             
                                                n
                                                ,
                                                k
                                             
                                             )
                                          
                                       
                                    
                                    
                                       =
                                       
                                          def
                                       
                                    
                                    
                                       
                                          ∑
                                          i
                                       
                                       
                                          
                                             C
                                             
                                                i
                                                j
                                             
                                             
                                                
                                                   (
                                                   
                                                      n
                                                      ,
                                                      k
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    ​
                                    ,
                                     
                                    ∀
                                    j
                                 
                              
                           
                        
                        
                           
                              
                                 
                                    
                                       D
                                       j
                                    
                                    
                                       =
                                       
                                          def
                                       
                                    
                                    
                                       
                                          ∑
                                          i
                                       
                                       
                                          
                                             H
                                             
                                                i
                                                j
                                             
                                          
                                       
                                    
                                    ​
                                    ,
                                     
                                    ∀
                                    j
                                 
                              
                           
                        
                     

Given f
                        0 as an initial image, each iteration of the COSEM algorithm consists of one projection operation in (T-1) to calculate the estimated projection data, one backprojection operation in (T-2) to update the complete data for the given subset, voxel-based operation in (T-3) to update global complete data, and actual voxel update in (T-4). Note that parallelizing the projection and backprojection operations can be achieved by using the proposed method in Section 2.1 of this work, whereas parallelizing the operations in (T-3) and (T-4) is straightforward. With the use of the GPU, all the operations in the COSEM algorithm can be accelerated. The overall procedure for the GPU-accelerated COSEM algorithm can be summarized as follows.
                           
                              (i)
                              Perform projection in (T-1).

Perform backprojection in (T-2) and update 
                                    
                                       
                                          A
                                          j
                                          
                                             
                                                (
                                                
                                                   n
                                                   ,
                                                   k
                                                
                                                )
                                             
                                          
                                       
                                        
                                       for
                                        
                                       ∀
                                       j
                                    
                                 .

Update 
                                    
                                       
                                          B
                                          j
                                          
                                             
                                                (
                                                
                                                   n
                                                   ,
                                                   k
                                                
                                                )
                                             
                                          
                                       
                                        
                                       for
                                        
                                       ∀
                                       j
                                    
                                  using (T-3).

Update 
                                    
                                       
                                          f
                                          j
                                          
                                             
                                                (
                                                
                                                   n
                                                   ,
                                                   k
                                                
                                                )
                                             
                                          
                                       
                                        
                                       for
                                        
                                       ∀
                                       j
                                    
                                  using (T-4).

To test our proposed method, we modeled a Compton camera system with the six detector pairs placed in the direction of the x-, y- and z-axes as shown in Fig. 4
                     . Each detector pair was placed with a radial offset of 10 cm from the center. The distance between the scatterer and the absorber in each detector pair was 5 cm. Both the scatterer and the absorber were sampled into 16 × 16 discrete detector elements, each of which had the size of (3.125 mm)2. The range of the scattering angle of the incident photon at the scatterer was also uniformly sampled into S = 32 discrete angles over 
                        
                           10
                           °
                           ≤
                           ω
                           ≤
                           90
                           °
                        
                     . A cone surface was modeled by N = 120 conic rays. While the number of physical detector elements in our experiment is 16 × 16 × 16 × 16 × 6, with the 32 scattering angles per each detector pair, the effective number of detector elements can be increased up to 16 × 16 × 16 × 16 × 6 × 32, and the corresponding number of conic rays is 16 × 16 × 16 × 16 × 6 × 32 × 120.

We performed simulation studies using a 3D Shepp–Logan phantom shown in Fig. 5(a) with the size of 64 × 64 × 64. The 3D projection data of the Shepp–Logan phantom (64 × 64 × 64 matrix with cubic voxel of (1.5625 mm)3) were obtained from our Compton projector using the RTM.

We implemented the COSEM algorithm [17] using both the CPU-based and the GPU-based methods, where the projection data were subdivided into 64 subsets using the method described in [6]. In addition to our proposed exact GPU-accelerated method (referred to hereafter as GPU-EX), we also tested with the two unmatched, approximated GPU-accelerated methods which were proposed in [6] as schemes 1 and 2 (referred to hereafter as GPU-AP1 and GPU-AP2, respectively). In the first scheme (GPU-AP1), the intersecting chord length of the ray passing through a voxel is approximated by the perpendicular distance from the center of the voxel to the ray. In the second scheme (GPU-AP2), each voxel is regarded as a dimensionless point rather than a cube so that the backprojection can be performed without the need for calculating intersecting chord lengths or their approximations.

Our simulations were performed on a PC with an Intel Core™ i7-3820 3.60 GHz processor (only one core was used). The graphic card used in our simulations was an NVIDIA GeForce™ GTX680 GPU with 2 GB of RAM and 1536 processor cores operating at 0.71 GHz. For forward projection, the thread block size was 16 × 16 and grid size was 8 × 16. For backprojection, the thread block size was 16 × 16 and grid size was 32 × 32.

The computation time per iteration for COSEM reconstruction using the proposed GPU-EX method was 60 seconds, whereas that for the same reconstruction using the CPU-based method was 1003 seconds. The computation times for GPU-AP1 and GPU-AP2 were 21.2 and 6.9 seconds, respectively. (The computation time spent on projection was 552 seconds for CPU-based method, and 3.0 seconds for GPU-based methods.) Note that, the computation times of the GPU-based methods decrease as the number of subsets is decreased [19]. Note also that the computation time of GPU-AP1 in comparison with that of GPU-AP2 is longer because GPU-AP2 does not involve the approximated chord-length computation which is the most time consuming in GPU-AP1. Furthermore, the number of cones to be processed in GPU-AP1 can be greater than that in GPU-AP2.

It is important to point out that the CPU-based method used here was implemented in an efficient way for the CPU so that the projection and backprojection operations could be concurrent. This was done by performing backprojection along the cone that was traced for the forward projection. In this case, the chord lengths calculated for forward projections can be directly used for backprojection without additional calculations. Nevertheless, our GPU-EX method significantly outperforms the efficiently implemented CPU-based method. In our algorithm, since all the variables used in the COSEM algorithm were stored in the GPU memory, there was no data transfer between the host (CPU) and the device (GPU) during iterations. It took only a few milliseconds to load the observed projection data in the pre-processing step and to copy the results after the final iteration in the post-processing step.


                     Fig. 5
                      shows the reconstructed images and Fig. 6
                      shows the difference images between the exact CPU-based method and the GPU-based methods for COSEM reconstruction with noiseless projection data. Unlike the approximated GPU-based methods (GPU-AP1 and GPU-AP2), our GPU-EX method clearly reveals a zero difference image as expected. The artifacts appearing in the reconstructed images due to our limited angular sampling can be reduced by increasing the angular coverage of the detector pairs as in [20,21].

To evaluate the quantitative performance of the proposed method, we calculated the percentage error (PE) of reconstructed images, which is given by
                        
                           
                              
                                 PE
                                 =
                                 
                                    
                                       
                                          ‖
                                          
                                             f
                                             −
                                             
                                                f
                                                ^
                                             
                                          
                                          ‖
                                       
                                    
                                    
                                       
                                          ‖
                                          f
                                          ‖
                                       
                                    
                                 
                                 ×
                                 100
                                 %
                                 ,
                              
                           
                        
                     where f is the true image, 
                        
                           f
                           ^
                        
                      is the reconstructed image, and 
                        
                           
                              ‖
                              .
                              ‖
                           
                        
                      denotes the L
                     2 norm. The numerical results evaluated on the reconstructed images (embedded in Fig. 5 caption) confirm the better performance of our new GPU-EX method over the GPU-AP1 and GPU-AP2 methods. Note also that the GPU-EX method has zero difference from the CPU-based method.

To compare the convergence speed of the GPU-accelerated methods, we also calculated the log-likelihood for several iterations. As shown in Fig. 7
                     , the GPU-EX method converges faster than both GPU-AP1 and GPU-AP2. (Note that the log-likelihood calculated by the GPU-EX method is supposed to be more exact than that by the GPU-AP1 or GPU-AP2 method.)


                     Fig. 8
                      shows the reconstructed images from noisy projections, and Fig. 9
                      shows the difference images between the CPU-based reconstruction and each of the GPU-based reconstructions. Again, the GPU-EX method reveals a complete zero-difference image. The percentage errors also support the better performance of the GPU-EX method.

To validate our proposed method with more realistic data, we conducted a Monte Carlo simulation study. The Monte Carlo data were generated from the Compton Imaging Simulator [22] which is a simulation toolkit built around the GEANT4 detector simulation toolkit. The geometry of the Compton camera used in this Monte Carlo simulation was designed to match the camera geometry shown in Fig. 4 except the number of the detector pairs; only half of the detector pairs placed in the direction of the x-, y- and z-axes were used. The acquired projection data had 27,000,000 gamma ray events in the list mode, which were then binned into the 16 × 16 scatterer and absorber bins and the 32 discrete scattering angles.


                     Fig. 10
                      shows the reconstructed images with 64 subsets and 25 iterations and the difference images between the CPU-based reconstruction and each of the GPU-based reconstructions. Due to the physical effects modeled in the simulator, which include the Doppler broadening effect, as well as the positional and angular errors arisen from the binning process, the reconstructed images in Fig. 10 are relatively blurrier than those in Fig. 8. To measure the accuracy of the GPU-based reconstructions, the percentage errors of GPU-based reconstructions were calculated with respect to the CPU-based reconstruction obtained with the ray-based backprojection. Once again, the percentage error as well as the difference image indicates zero difference between the proposed GPU-EX method and the CPU-based method.

GPU-accelerated methods using unmatched projector–backprojector pairs have been useful for high-performance computing in high-resolution CT reconstruction [11,19,23]. However, the use of such approximated methods for Compton camera reconstruction causes visually noticeable artifacts due to its relatively low resolution compared to the conventional CT [6]. Moreover, since Compton camera reconstruction involves surface integral-based projection and backprojection operations rather than line integral-based operations, the problem of the error accumulation over iterations can be more significant. On the other hand, our exact method is guaranteed to retain the reconstruction accuracy regardless of the number of iterations by providing a perfectly matched projector–backprojector pair.

The key to success of our proposed method is to store the rays forming a conic surface. By storing such rays, one can easily indicate the rays for backprojection to a specific voxel. One can also consider another method for backprojection in which the projection of eight vertices of a voxel onto the virtual detector plane is used. The convex set that bounds eight projected points in the virtual detector plane contains the rays for backprojection to the voxel. However, indicating the starting and ending rays for each sampled cone is computationally expensive.

According to our simulation results using the COSEM algorithm with 64 subsets, the GPU-based method was roughly 16 times faster in computation time per iteration than the CPU-based method. The reconstructed images using our GPU-based method were absolutely identical to those using the conventional CPU-based method.

Note that we proposed our method in an algorithmic perspective to match the conic projector and backprojector. Extending our work to include more practical issues, such as optimal balancing of GPU and CPU resources, can further improve the computational efficiency as done in [24].

Since it is time consuming to find the rays that pass through the voxel in backprojection and perform the ray-tracing projections to determine the corresponding intersecting chord lengths, the proposed method is slower than the approximated methods proposed in [6]. To reduce computational burden, one can consider using other approximated ray-driven methods for both projection and backprojection, which do not actually calculate intersecting chord lengths. In this case, however, the calculation of the system matrix does not correctly model the Beer's law. An alternative method is to use an approximated backprojection method, such as the method used for GPU-AP1 or GPU-AP2, and apply a narrow Gaussian filter or an adaptive Gaussian filter to the backprojection image [12]. However, it is also difficult to choose a Gaussian filter that can model the system matrix accurately.

Although our exact method is slower than the approximated methods, its acceleration rate is still remarkable compared to any acceleration rate that can be achieved by the CPU-based method. The accuracy of our exact method is expected to be more significant when the method is applied to more advanced algorithms, such as the penalized-likelihood reconstruction algorithms, which usually require many iterations to converge. Unlike the approximated methods using unmatched pairs, which tend to increase the mismatch error as the number of iterations increases, our exact method is error-free, thereby producing more reliable results.

@&#ACKNOWLEDGMENT@&#

This work was supported by the Vietnam's National Foundation for Science and Technology Development (NAFOSTED) under Grant 102.01-2013.42 for V.-G. Nguyen, and by the National Research Foundation of Korea grant funded by the Korea government (MSIP) under Grant 2014R1A2A2A01002626 for S.-J. Lee.

@&#REFERENCES@&#

