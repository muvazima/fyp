@&#MAIN-TITLE@&#Enhancing energy minimization framework for scene text recognition with top-down cues

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An energy minimization based approach for scene text recognition with seamless integration of multiple cues.


                        
                        
                           
                           Applied also to the challenging open vocabulary setting, where a word-specific lexicon is unavailable.


                        
                        
                           
                           Comprehensive experimental evaluation on several state-of-the-art benchmarks.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Scene text understanding

Text recognition

Lexicon priors

Character recognition

Random field models

@&#ABSTRACT@&#


               
               
                  Recognizing scene text is a challenging problem, even more so than the recognition of scanned documents. This problem has gained significant attention from the computer vision community in recent years, and several methods based on energy minimization frameworks and deep learning approaches have been proposed. In this work, we focus on the energy minimization framework and propose a model that exploits both bottom-up and top-down cues for recognizing cropped words extracted from street images. The bottom-up cues are derived from individual character detections from an image. We build a conditional random field model on these detections to jointly model the strength of the detections and the interactions between them. These interactions are top-down cues obtained from a lexicon-based prior, i.e., language statistics. The optimal word represented by the text image is obtained by minimizing the energy function corresponding to the random field model. We evaluate our proposed algorithm extensively on a number of cropped scene text benchmark datasets, namely Street View Text, ICDAR 2003, 2011 and 2013 datasets, and IIIT 5K-word, and show better performance than comparable methods. We perform a rigorous analysis of all the steps in our approach and analyze the results. We also show that state-of-the-art convolutional neural network features can be integrated in our framework to further improve the recognition performance.
               
            

@&#INTRODUCTION@&#

The problem of understanding scenes semantically has been one of the challenging goals in computer vision for many decades. It has gained considerable attention over the past few years, in particular, in the context of street scenes [1–3]. This problem has manifested itself in various forms, namely, object detection [4,5], object recognition and segmentation [6,7]. There have also been significant attempts at addressing all these tasks jointly [2,8,9]. Although these approaches interpret most of the scene successfully, regions containing text are overlooked. As an example, consider an image of a typical street scene taken from Google Street View in Fig. 1. One of the first things we notice in this scene is the sign board and the text it contains. However, popular recognition methods ignore the text, and identify other objects such as car, person, tree, and regions such as road, sky. The importance of text in images is also highlighted in the experimental study conducted by Judd et al. [10]. They found that viewers fixate on text when shown images containing text and other objects. This is further evidence that text recognition forms a useful component in understanding scenes.
                     
                  

In addition to being an important component of scene understanding, scene text recognition has many potential applications, such as image retrieval, auto navigation, scene text to speech systems, developing apps for visually impaired people [13,14]. Our method for solving this task is inspired by the many advancements made in the object detection and recognition problems [4,5,7,15]. We present a framework for recognizing text that exploits bottom-up and top-down cues. The bottom-up cues are derived from individual character detections from an image. Naturally, these windows contain true as well as false positive detections of characters. We build a conditional random field (CRF) model [16] on these detections to determine not only the true positive detections, but also the word they represent jointly. We impose top-down cues obtained from a lexicon-based prior, i.e., language statistics, on the model. In addition to disambiguating between characters, this prior also helps us in recognizing words.

The first contribution of this work is a joint framework with seamless integration of multiple cues – individual character detections and their spatial arrangements, pairwise lexicon priors, and higher-order priors – into a CRF framework which can be optimized effectively. The proposed method performs significantly better than other related energy minimization based methods for scene text recognition. Our second contribution is devising a cropped word recognition framework which is applicable not only to closed vocabulary text recognition (where a small lexicon containing the ground truth word is provided with each image), but also to a more general setting of the problem, i.e., open vocabulary scene text recognition (where the ground truth word may or may not belong to a generic large lexicon or the English dictionary). The third contribution is comprehensive experimental evaluation, in contrast to many recent works, which either consider a subset of benchmark datasets or are limited to the closed vocabulary setting. We evaluate on a number of cropped word datasets (ICDAR 2003, 2011 and 2013 [17], SVT [18], and IIIT 5K-word [19]) and show results in closed and open vocabulary settings. Additionally, we analyzed the effectiveness of individual components of the framework, the influence of parameter settings, and the use of convolutional neural network (CNN) based features [20].

The rest of the paper is organized as follows. In Section 2 we discuss related work. Section 3 describes our scene text recognition model and its components. We then present the evaluation protocols and the datasets used in experimental analysis in Section 4. Comparison with related approaches is shown in Section 5, along with implementation details. We then make concluding remarks in Section 6.

@&#RELATED WORK@&#

The task of understanding scene text has gained a huge interest for more than a decade [11,12,20–31]. It is closely related to the problem of Optical Character Recognition (OCR), which has a long history in the computer vision and pattern recognition communities [32]. However, the success of OCR systems is largely restricted to text from scanned documents. Scene text exhibits a large variability in appearance, as shown in Fig. 2, and can prove to be challenging even for the state-of-the-art OCR methods (see Table 1
                      and [11,12]). The problems in this context are: (1) text localization, (2) cropped word recognition, and (3) isolated character recognition. They have been tackled either individually [21,27,33], or jointly [11,20,23,29]. This paper focuses on addressing the cropped word recognition problem. In other words, given an image region (e.g., in the form of a bounding box) containing text, the task is to recognize this content. The core components of a typical cropped word recognition framework are: localize the characters, recognize them, and use statistical language models to compose the characters into words. Our framework builds on these components, but differs from previous work in several ways. In the following, we review the prior art and highlight these differences. The reader is encouraged to refer [34] for a more comprehensive survey of scene text recognition methods.

A popular technique for localizing characters in an OCR system is to binarize the image and determine the potential character locations based on connected components [35]. Such techniques have also been adapted for scene text recognition [12], although with limited success. This is mainly because obtaining a clean binary output for scene text images is often challenging; see Fig. 3
                      for examples. An alternative approach is proposed in [36] using gradient information to find potential character locations. More recently, Yao et al. [31] proposed a mid-level feature based technique to localize characters in scene text. We follow an alternative strategy and cast the character localization problem as an object detection task, where characters are the objects. We then define an energy function on all the potential characters.

One of the earliest works on large-scale natural scene character recognition was presented in [27]. This work develops a multiple kernel learning approach using a set of shape-based features. Recent work [11,37] has improved over this with histogram of gradient features [15]. We perform an extensive analysis on features, classifiers, and propose methods to improve character recognition further, for example, by augmenting the training set. In addition to this, we show that the state-of-the-art CNN features [20] can be successfully integrated with our word recognition framework to further boost its performance.

A study on human reading psychology shows that our reading improves significantly with prior knowledge of the language [38]. Motivated by such studies, OCR systems have used, often in post-processing steps [35,39], statistical language models like n-grams to improve their performance. Bigrams or trigrams have also been used in the context of scene text recognition as a post-processing step, e.g., [40]. A few other works [41–43] integrate character recognition and linguistic knowledge to deal with recognition errors. For example, [41] computes n-gram probabilities from more than 100 million characters and uses a Viterbi algorithm to find the correct word. The method in [43], developed in the same year as our CVPR 2012 work [37], builds a graph on potential character locations and uses n-gram scores to constrain the inference algorithm to predict the word. In contrast, our approach uses a novel location-specific prior (cf. (9)).

The word recognition problem has been looked at in two contexts – with [11,25,37,44,45] and without [19,22,46] the use of an image-specific lexicon. In the case of image-specific lexicon-driven word recognition, also known as the closed vocabulary setting, a list of words is available for every scene text image. The task of recognizing the word now reduces to that of finding the best match from this list. This is relevant in many applications, e.g., recognizing text in a grocery store, where a list of grocery items can serve as a lexicon. Wang et al. [44] adapted a multi-layer neural network for this scenario. In [11], each word in the lexicon is matched to the detected set of character windows, and the one with the highest score is reported as the predicted word. In one of our previous works [45], we compared features computed on the entire scene text image and those generated from synthetic font renderings of lexicon words with a novel weighted dynamic time warping (wDTW) approach to recognize words. In [25] Rodriguez and Perronnin proposed to embed word labels and word images into a common Euclidean space, wherein the text recognition task is posed as a retrieval problem to find the closest word label for a given word image. While all these approaches are interesting, their success is largely restricted to the closed vocabulary setting and cannot be easily extended to the more general cases, for instance, when image-specific lexicon is unavailable. Weinman et al. [22] proposed a method to address this issue, although with a strong assumption of known character boundaries, which are not trivial to obtain with high precision on the datasets we use. The work in [46] generalizes their previous approach by relaxing the character-boundary requirement. It is, however, evaluated only on “roughly fronto-parallel” images of signs, which are less challenging than the scene text images used in our work.

Our work belongs to the class of word recognition methods which build on individual character localization, similar to methods such as [12,48]. In this framework, the potential characters are localized, then a graph is constructed from these locations, and then the problem of recognizing the word is formulated as finding an optimal path in this graph [49] or inferring from an ensemble of HMMs [48]. Our approach shows a seamless integration of higher order language priors into the graph (in the form of a CRF model), and uses more effective modern computer vision features, thus making it clearly different from previous works.

Since the publication of our original work in CVPR 2012 [37] and BMVC 2012 [19] papers, several approaches for scene text understanding (e.g., text localization [29,50–52], word recognition [20,23,30,31,51,53] and text-to-image retrieval [13,51,54,55]) have been proposed. Notably, there has been an increasing interest in exploring deep convolutional network based methods for scene text tasks (see [20,30,44,51,52] for example). These approaches are very effective in general, but the deep convolutional network, which is at the core of these approaches, lacks the capability to elegantly handle structured output data. To understand this with the help of an example, let us consider the problem of estimating human pose [56,57], where the task is to predict the locations of human body joints such as head, shoulders, elbows and wrists. These locations are constrained by human body kinematics and in essence form a structured output. To deal with such structured output data, state-of-the-art deep learning algorithms include an additional regression step [56] or a graphical model [57], thus showing that these techniques are complementary to the deep learning philosophy. Similar to human pose, text is structured output data [58]. To better handle this structured data, we develop our energy minimization framework [19,37] with the motivation of building a complementary approach, which can further benefit methods built on the deep learning paradigm. Indeed, we see that combining the two frameworks further improves text recognition results (Section 5).

We propose a conditional random field (CRF) model for recognizing words. The CRF is defined over a set of N random variables 
                        
                           x
                           =
                           {
                           
                              x
                              i
                           
                           |
                           i
                           ∈
                           V
                           }
                           ,
                        
                      where 
                        
                           V
                           =
                           {
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           N
                           }
                        
                     . Each random variable xi
                      denotes a potential character in the word, and can take a label from the label set 
                        
                           L
                           =
                           {
                           
                              l
                              1
                           
                           ,
                           
                              l
                              2
                           
                           ,
                           …
                           ,
                           
                              l
                              k
                           
                           }
                           ∪
                           ϵ
                           ,
                        
                      which is the set of English characters, digits and a null label ϵ to discard false character detections. The most likely word represented by the set of characters x is found by minimizing the energy function, 
                        
                           E
                           :
                           
                              L
                              n
                           
                           →
                           R
                           ,
                        
                      corresponding to the random field. The energy function E can be written as sum of potential functions:

                        
                           (1)
                           
                              
                                 E
                                 
                                    (
                                    x
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       c
                                       ∈
                                       C
                                    
                                 
                                 
                                    
                                       ψ
                                       c
                                    
                                    
                                       (
                                       
                                          x
                                          c
                                       
                                       )
                                    
                                 
                                 ,
                              
                           
                        
                     where 
                        
                           C
                           ⊂
                           P
                           (
                           V
                           )
                           ,
                        
                      with 
                        
                           P
                           (
                           V
                           )
                        
                      denoting the powerset of 
                        V
                     . Each xc
                      defines a set of random variables included in subset c, referred to as a clique. The function ψc
                      defines a constraint (potential) on the corresponding clique c. We use unary, pairwise and higher order potentials in this work, and define them in Section 3.2. The set of potential characters is obtained by the character detection step discussed in Section 3.1. The neighborhood relations among characters, modeled as pairwise and higher order potentials, are based on the spatial arrangement of characters in the word image.

In the following we show an example energy function composed of unary, pairwise and higher order (of clique size three) terms on a sample word with four characters. For a word to be recognized as “OPEN” the following energy function should be the minimum.

                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          ψ
                                          (
                                          O
                                          ,
                                          P
                                          ,
                                          E
                                          ,
                                          N
                                          )
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ψ
                                             1
                                          
                                          
                                             (
                                             O
                                             )
                                          
                                          +
                                          
                                             ψ
                                             1
                                          
                                          
                                             (
                                             P
                                             )
                                          
                                          +
                                          
                                             ψ
                                             1
                                          
                                          
                                             (
                                             E
                                             )
                                          
                                          +
                                          
                                             ψ
                                             1
                                          
                                          
                                             (
                                             N
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          
                                             ψ
                                             2
                                          
                                          
                                             (
                                             O
                                             ,
                                             P
                                             )
                                          
                                          +
                                          
                                             ψ
                                             2
                                          
                                          
                                             (
                                             P
                                             ,
                                             E
                                             )
                                          
                                          +
                                          
                                             ψ
                                             2
                                          
                                          
                                             (
                                             E
                                             ,
                                             N
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          
                                             ψ
                                             3
                                          
                                          
                                             (
                                             O
                                             ,
                                             P
                                             ,
                                             E
                                             )
                                          
                                          +
                                          
                                             ψ
                                             3
                                          
                                          
                                             (
                                             P
                                             ,
                                             E
                                             ,
                                             N
                                             )
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     The third order terms ψ
                     3(O, P, E) and ψ
                     3(P, E, N) are decomposed as follows.

                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          
                                             ψ
                                             3
                                          
                                          
                                             (
                                             O
                                             ,
                                             P
                                             ,
                                             E
                                             )
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ψ
                                             1
                                             a
                                          
                                          
                                             (
                                             O
                                             P
                                             E
                                             )
                                          
                                          +
                                          
                                             ψ
                                             2
                                             a
                                          
                                          
                                             (
                                             O
                                             P
                                             E
                                             ,
                                             O
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          
                                             ψ
                                             2
                                             a
                                          
                                          
                                             (
                                             O
                                             P
                                             E
                                             ,
                                             P
                                             )
                                          
                                          +
                                          
                                             ψ
                                             2
                                             a
                                          
                                          
                                             (
                                             O
                                             P
                                             E
                                             ,
                                             E
                                             )
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                     
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          
                                             ψ
                                             3
                                          
                                          
                                             (
                                             P
                                             ,
                                             E
                                             ,
                                             N
                                             )
                                          
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             ψ
                                             1
                                             a
                                          
                                          
                                             (
                                             P
                                             E
                                             N
                                             )
                                          
                                          +
                                          
                                             ψ
                                             2
                                             a
                                          
                                          
                                             (
                                             P
                                             E
                                             N
                                             ,
                                             P
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          +
                                          
                                          
                                             ψ
                                             2
                                             a
                                          
                                          
                                             (
                                             P
                                             E
                                             N
                                             ,
                                             E
                                             )
                                          
                                          +
                                          
                                             ψ
                                             2
                                             a
                                          
                                          
                                             (
                                             P
                                             E
                                             N
                                             ,
                                             N
                                             )
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     
                  

The first step in our approach is to detect potential locations of characters in a word image. In this work we use a sliding window based approach for detecting characters, but other methods, e.g., [31], can also be used instead.

This technique has been very successful for tasks such as, face [59] and pedestrian [15] detection, and also for recognizing handwritten words using HMM based methods [60]. Although character detection in scene images is similar to such problems, it has its unique challenges. Firstly, there is the issue of dealing with many categories (63 in all) jointly. Secondly, there is a large amount of inter-character and intra-character confusion, as illustrated in Fig. 4
                              . When a window contains parts of two characters next to each other, it may have a very similar appearance to another character. In Fig. 4(a), the window containing parts of the characters ‘o’ can be confused with ‘x’. Furthermore, a part of one character can have the same appearance as that of another. In Fig. 4(b), a part of the character ‘B’ can be confused with ‘E’. We build a robust character classifier and adopt an additional pruning stage to overcome these issues.

The problem of classifying natural scene characters typically suffers from the lack of training data, e.g., [27] uses only 15 samples per class. It is not trivial to model the large variations in characters using only a few examples. To address this, we add more examples to the training set by applying small affine transformations [61,62] to the original character images. We further enrich the training set by adding many non-character negative examples, i.e., from the background. With this strategy, we achieve a significant boost in character classification accuracy (see Table 3).

We consider windows at multiple scales and spatial locations. The location of the ith window, di
                              , is given by its center and size. The set 
                                 
                                    K
                                    =
                                    {
                                    
                                       c
                                       1
                                    
                                    ,
                                    
                                       c
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       c
                                       k
                                    
                                    }
                                    ,
                                 
                               denotes label set. Note that 
                                 
                                    k
                                    =
                                    63
                                 
                               for the set of English characters, digits and a background class (null label) in our work. Let ϕi
                               denote the features extracted from a window location di
                              . Given the window di
                              , we compute the likelihood, p(cj
                              |ϕi
                              ), of it taking a label cj
                               for all the classes in 
                                 K
                              . In our implementation, we used explicit feature representation [63] of histogram of gradient (HOG) features [15] for ϕi
                              , and the likelihoods p are (normalized) scores from a one vs rest multi-class support vector machine (SVM). Implementation details of the training procedure are provided in Section 5.1.

This basic sliding window detection approach produces many potential character windows, but not all of them are useful for recognizing words. We discard some of the weak detection windows using the following pruning method.

For every potential character window, we compute a score based on: (i) SVM classifier confidence, and (ii) a measure of the aspect ratio of the character detected and the aspect ratio learnt for that character from training data. The intuition behind this score is that, a strong character window candidate should have a high classifier confidence score, and must fall within some range of the sizes observed in the training data. In order to define the aspect ratio measure, we observed the distribution of aspect ratios of characters from the IIIT-5K word training set. A few examples of these distributions are shown in Fig. 5
                              . Since they follow a Gaussian distribution, we chose this score accordingly. For a window di
                               with an aspect ratio ai
                              , let cj
                               denote the character with the best classifier confidence value given by Sij
                              . The mean aspect ratio for the character cj
                               computed from training data is denoted by 
                                 
                                    μ
                                    
                                       a
                                       j
                                    
                                 
                              . We define a goodness score (GS) for the window di
                               as:

                                 
                                    (5)
                                    
                                       
                                          GS
                                          
                                             (
                                             
                                                d
                                                i
                                             
                                             )
                                          
                                          =
                                          
                                             S
                                             
                                                i
                                                j
                                             
                                          
                                          exp
                                          
                                             (
                                             −
                                             
                                                
                                                   
                                                      (
                                                      
                                                         μ
                                                         
                                                            a
                                                            j
                                                         
                                                      
                                                      −
                                                      
                                                         a
                                                         i
                                                      
                                                      )
                                                   
                                                   2
                                                
                                                
                                                   2
                                                   
                                                      σ
                                                      
                                                         
                                                            a
                                                            j
                                                         
                                                      
                                                      2
                                                   
                                                
                                             
                                             )
                                          
                                          ,
                                       
                                    
                                 
                              where 
                                 
                                    σ
                                    
                                       a
                                       j
                                    
                                 
                               is the variance of the aspect ratio for character cj
                               in the training data. A low goodness score indicates a weak detection, which is then removed from the set of candidate character windows.

We then apply character-specific non-maximum suppression (NMS), similar to other sliding window detection methods [5], to address the issue of multiple overlapping detections for each instance of a character. In other words, for every character class, we select detections which have a high confidence score, and do not overlap significantly with any of the other stronger detections of the same character class. We perform NMS after aspect ratio pruning to avoid wide windows with many characters suppressing weaker single character windows they overlap with. The pruning and NMS steps are performed conservatively, to discard only the obvious false detections. The remaining false positives are modeled in an energy minimization framework with language priors and other cues, as discussed below.

We solve the problem of minimizing the energy function (1) on a corresponding graph, where each random variable is represented as a node in the graph. We begin by ordering the character windows based on their horizontal location in the image, and add one node each for every window sequentially from left to right. The nodes are then connected by edges. Since it is not natural for a window on the extreme left to be strongly related to another window on the extreme right, we only connect windows which are close to each other. The intuition behind close-proximity windows is that they could represent detections of two separate characters. As we will see later, the edges are used to encode the language model as top-down cues. Such pairwise language priors alone may not be sufficient in some cases, for example, when an image-specific lexicon is unavailable. Thus, we also integrate higher order language priors in the form of n-grams computed from the English dictionary by adding an auxiliary node connecting a set of n character detection nodes.

Each (non-auxiliary) node in the graph takes one label from the label set 
                           
                              L
                              =
                              {
                              
                                 l
                                 1
                              
                              ,
                              
                                 l
                                 2
                              
                              ,
                              …
                              ,
                              
                                 l
                                 k
                              
                              }
                              ∪
                              ϵ
                           
                        . Recall that each lu
                         is an English character or digit, and the null label ϵ is used to discard false windows that represent background or parts of characters. The cost associated with this label assignment is known as the unary cost. The cost for two neighboring nodes taking labels lu
                         and lv
                         is known as the pairwise cost. This cost is computed from bigram scores of character pairs in the English dictionary or an image-specific lexicon. The auxiliary nodes in the graph take labels from the extended label set 
                           
                              L
                              e
                           
                        . Each element of 
                           
                              L
                              e
                           
                         represents one of the n-grams present in the dictionary and an additional label to assign a constant (high) cost to all n-grams that are not in the dictionary. The proposed model is illustrated in Fig. 6
                        , where we show a CRF of order four as an example. Once the graph is constructed, we compute its corresponding cost functions as follows.

The unary cost of a node taking a character label is determined by the SVM confidence scores. The unary term ψ
                           1, which denotes the cost of a node xi
                            taking label lu
                           , is defined as:

                              
                                 (6)
                                 
                                    
                                       
                                          ψ
                                          1
                                       
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          =
                                          
                                             l
                                             u
                                          
                                          )
                                       
                                       =
                                       1
                                       −
                                       p
                                       
                                          (
                                          
                                             l
                                             u
                                          
                                          |
                                          
                                             x
                                             i
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where p(lu
                           |xi
                           ) is the SVM score of character class lu
                            for node xi
                           , normalized with Platt’s method [64]. The cost of xi
                            taking the null label ϵ is given by:

                              
                                 (7)
                                 
                                    
                                       
                                          ψ
                                          1
                                       
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          =
                                          ϵ
                                          )
                                       
                                       =
                                       
                                          max
                                          u
                                       
                                       p
                                       
                                          (
                                          
                                             l
                                             u
                                          
                                          |
                                          
                                             x
                                             i
                                          
                                          )
                                       
                                       exp
                                       
                                          (
                                          −
                                          
                                             
                                                
                                                   (
                                                   
                                                      μ
                                                      
                                                         a
                                                         u
                                                      
                                                   
                                                   −
                                                   
                                                      a
                                                      i
                                                   
                                                   )
                                                
                                                2
                                             
                                             
                                                σ
                                                
                                                   
                                                      a
                                                      u
                                                   
                                                
                                                2
                                             
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where ai
                            is the aspect ratio of the window corresponding to node xi
                           , 
                              
                                 μ
                                 
                                    a
                                    u
                                 
                              
                            and 
                              
                                 σ
                                 
                                    a
                                    u
                                 
                              
                            are the mean and variance of the aspect ratio respectively of the character lu
                           , computed from the training data. The intuition behind this cost function is that, for taking a character label, the detected window should have a high classifier confidence and its aspect ratio should agree with that of the corresponding character in the training data.

The pairwise cost of two neighboring nodes xi
                            and xj
                            taking a pair of labels lu
                            and lv
                            respectively is determined by the cost of their joint occurrence in the dictionary. This cost ψ
                           2 is given by:

                              
                                 (8)
                                 
                                    
                                       
                                          ψ
                                          2
                                       
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          =
                                          
                                             l
                                             u
                                          
                                          ,
                                          
                                             x
                                             j
                                          
                                          =
                                          
                                             l
                                             v
                                          
                                          )
                                       
                                       =
                                       
                                          λ
                                          l
                                       
                                       exp
                                       
                                          (
                                          −
                                          β
                                          p
                                          
                                             (
                                             
                                                l
                                                u
                                             
                                             ,
                                             
                                                l
                                                v
                                             
                                             )
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where p(lu, lv
                           ) is the score determining the likelihood of the pair lu
                            and lv
                            occurring together in the dictionary. The parameters 
                              
                                 λ
                                 l
                              
                            and β are set empirically as 
                              
                                 
                                    λ
                                    l
                                 
                                 =
                                 2
                              
                            and 
                              
                                 β
                                 =
                                 50
                              
                            in all our experiments. The score p(lu, lv
                           ) is commonly computed from joint occurrences of characters in the lexicon [41–43,65]. This prior is effective when the lexicon size is small, but it is less so as the lexicon increases in size. Furthermore, it fails to capture the location-specific information of pairs of characters. As a toy example, consider a lexicon with only two words CVPR and ICPR. Here, the character pair (P,R) is more likely to occur at the end of the word, but a standard bigram prior model does not incorporate this location-specific information.

To overcome the lack of location-specific information, we devise a node-specific pairwise cost by adapting [66] to the scene text recognition problem. We divide a given word image into T parts, where T is an estimate of the number of characters in the image. This estimate T is given by the image width divided by the average character window width, with the average computed over all the detected characters in the image. To determine the pairwise cost involving windows in the tth image part, we define a region of interest (ROI) which includes the two adjacent parts 
                              
                                 t
                                 −
                                 1
                                 ,
                              
                           
                           
                              
                                 t
                                 +
                                 1
                                 ,
                              
                            in addition to t. With this, we do a ROI based search in the lexicon. In other words, we consider all the character pairs involving characters in locations 
                              
                                 t
                                 −
                                 1
                                 ,
                              
                            
                           t and 
                              
                                 t
                                 +
                                 1
                              
                            in all the lexicon words to compute the likelihood of a pair occurring together. Note that the extreme cases (involving the leftmost and rightmost character in the lexicon word) are treated appropriately by considering only one of the two pairs.

This pairwise cost using the node-specific prior is given by:

                              
                                 (9)
                                 
                                    
                                       
                                          ψ
                                          2
                                       
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          =
                                          
                                             l
                                             u
                                          
                                          ,
                                          
                                             x
                                             j
                                          
                                          =
                                          
                                             l
                                             v
                                          
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         (
                                                         
                                                            l
                                                            u
                                                         
                                                         ,
                                                         
                                                            l
                                                            v
                                                         
                                                         )
                                                         ∈
                                                      
                                                      
                                                      roi
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      λ
                                                      l
                                                   
                                                
                                                
                                                   
                                                      otherwise
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           We evaluated our approach with both the pairwise terms (8) and (9), and found that the node-specific prior (9) achieves better performance. The cost of nodes xi
                            and xj
                            taking label lu
                            and ϵ respectively is defined as:

                              
                                 (10)
                                 
                                    
                                       
                                          ψ
                                          2
                                       
                                       
                                          (
                                          
                                             x
                                             i
                                          
                                          =
                                          
                                             l
                                             u
                                          
                                          ,
                                          
                                             x
                                             j
                                          
                                          =
                                          ϵ
                                          )
                                       
                                       =
                                       
                                          λ
                                          o
                                       
                                       exp
                                       
                                          (
                                          −
                                          β
                                          
                                             
                                                (
                                                1
                                                −
                                                O
                                                
                                                   (
                                                   
                                                      x
                                                      i
                                                   
                                                   ,
                                                   
                                                      x
                                                      j
                                                   
                                                   )
                                                
                                                )
                                             
                                             2
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where O(xi, xj
                           ) is the overlap fraction between windows corresponding to the nodes xi
                            and xj
                           . The pairwise cost 
                              
                                 
                                    ψ
                                    2
                                 
                                 
                                    (
                                    
                                       x
                                       i
                                    
                                    =
                                    ϵ
                                    ,
                                    
                                       x
                                       j
                                    
                                    =
                                    
                                       l
                                       u
                                    
                                    )
                                 
                              
                            is defined similarly. The parameters are set empirically as 
                              
                                 
                                    λ
                                    o
                                 
                                 =
                                 2
                              
                            and 
                              
                                 β
                                 =
                                 50
                              
                            in our experiments. This cost ensures that when two character windows overlap significantly, only one of them are assigned a character/digit label in order to avoid parts of characters being labeled.

Let us consider a CRF of order 
                              
                                 n
                                 =
                                 3
                              
                            as an example to understand this cost. An auxiliary node corresponding to every clique of size 3 is added to represent this third order cost in the graph. The higher order cost is then decomposed into unary and pairwise terms with respect to this node, similar to [67]. Each auxiliary node in the graph takes one of the labels from the extended label set 
                              
                                 
                                    {
                                    
                                       L
                                       1
                                    
                                    ,
                                    
                                       L
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       L
                                       M
                                    
                                    }
                                 
                                 ∪
                                 
                                    L
                                    
                                       M
                                       +
                                       1
                                    
                                 
                                 ,
                              
                            where labels 
                              
                                 
                                    L
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 
                                    L
                                    M
                                 
                              
                            represent all the trigrams in the dictionary. The additional label 
                              
                                 L
                                 
                                    M
                                    +
                                    1
                                 
                              
                            denotes all those trigrams which are absent in the dictionary. The unary cost 
                              
                                 ψ
                                 1
                                 a
                              
                            for an auxiliary variable yi
                            taking label Lm
                            is:

                              
                                 (11)
                                 
                                    
                                       
                                          ψ
                                          1
                                          a
                                       
                                       
                                          (
                                          
                                             y
                                             i
                                          
                                          =
                                          
                                             L
                                             m
                                          
                                          )
                                       
                                       =
                                       
                                          λ
                                          a
                                       
                                       exp
                                       
                                          (
                                          −
                                          β
                                          P
                                          
                                             (
                                             
                                                L
                                                m
                                             
                                             )
                                          
                                          )
                                       
                                       ,
                                    
                                 
                              
                           where 
                              
                                 λ
                                 a
                              
                            is a constant. We set 
                              
                                 
                                    λ
                                    a
                                 
                                 =
                                 5
                              
                            empirically, in all our experiments, unless stated otherwise. The parameter β controls penalty between dictionary and non-dictionary n-grams, and is empirically set to 50. The score P(Lm
                           ) denotes the likelihood of trigram Lm
                            in the English, and is further described in Section 3.2.4. The pairwise cost between the auxiliary node yi
                            taking a label 
                              
                                 
                                    L
                                    m
                                 
                                 =
                                 
                                    l
                                    u
                                 
                                 
                                    l
                                    v
                                 
                                 
                                    l
                                    w
                                 
                              
                            and the left-most non-auxiliary node in the clique, xi
                           , taking a label lr
                            is given by:

                              
                                 (12)
                                 
                                    
                                       
                                          ψ
                                          2
                                          a
                                       
                                       
                                          (
                                          
                                             y
                                             i
                                          
                                          =
                                          
                                             L
                                             m
                                          
                                          ,
                                          
                                             x
                                             i
                                          
                                          =
                                          
                                             l
                                             r
                                          
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         r
                                                         =
                                                         u
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            l
                                                            r
                                                         
                                                         =
                                                         ϵ
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      λ
                                                      b
                                                   
                                                
                                                
                                                   
                                                      otherwise
                                                      ,
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where λ
                           b penalizes a disagreement between the auxiliary and non-auxiliary nodes, and is empirically set to 1. The other two pairwise terms for the second and third nodes are defined similarly. Note that when one or more xi
                           ’s take null label, the corresponding pairwise term(s) between xi
                           (s) and the auxiliary node are set to 0.

We compute n-gram based priors from the lexicon (or dictionary) and then adapt standard techniques for smoothing these scores [41,68,69] to the open and closed vocabulary cases.

Our method uses the score denoting the likelihood of joint occurrence of pair of labels lu
                            and lv
                            represented as P(lu, lv
                           ), triplets of labels lu, lv
                            and lw
                            denoted by P(lu, lv, lw
                           ) and even higher order (e.g., fourth order). Let C(lu
                           ) denote the number of occurrences of lu, C(lu, lv
                           ) be the number of joint occurrences of lu
                            and lv
                            next to each other, and similarly C(lu, lv, lw
                           ) is the number of joint occurrences of all three labels lu, lv, lw
                            next to each other. The smoothed scores [68] 
                           P(lu, lv
                           ) and P(lu, lv, lw
                           ) are now:

                              
                                 (13)
                                 
                                    
                                       P
                                       
                                          (
                                          
                                             l
                                             u
                                          
                                          ,
                                          
                                             l
                                             v
                                          
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      0.4
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            l
                                                            u
                                                         
                                                         ,
                                                         
                                                            l
                                                            v
                                                         
                                                      
                                                      
                                                      are
                                                      
                                                      digits
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            C
                                                            (
                                                            
                                                               l
                                                               u
                                                            
                                                            ,
                                                            
                                                               l
                                                               v
                                                            
                                                            )
                                                         
                                                         
                                                            C
                                                            (
                                                            
                                                               l
                                                               v
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         C
                                                         (
                                                         
                                                            l
                                                            u
                                                         
                                                         ,
                                                         
                                                            l
                                                            v
                                                         
                                                         )
                                                         >
                                                         0
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         α
                                                         
                                                            l
                                                            u
                                                         
                                                      
                                                      P
                                                      
                                                         (
                                                         
                                                            l
                                                            v
                                                         
                                                         )
                                                      
                                                   
                                                
                                                
                                                   
                                                      otherwise
                                                      ,
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (14)
                                 
                                    
                                       P
                                       
                                          (
                                          
                                             l
                                             u
                                          
                                          ,
                                          
                                             l
                                             v
                                          
                                          ,
                                          
                                             l
                                             w
                                          
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      0.4
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         
                                                            l
                                                            u
                                                         
                                                         ,
                                                         
                                                            l
                                                            v
                                                         
                                                         ,
                                                         
                                                            l
                                                            w
                                                         
                                                      
                                                      
                                                      are
                                                      
                                                      digits
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         
                                                            C
                                                            (
                                                            
                                                               l
                                                               u
                                                            
                                                            ,
                                                            
                                                               l
                                                               v
                                                            
                                                            ,
                                                            
                                                               l
                                                               w
                                                            
                                                            )
                                                         
                                                         
                                                            C
                                                            (
                                                            
                                                               l
                                                               v
                                                            
                                                            ,
                                                            
                                                               l
                                                               w
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      
                                                         C
                                                         (
                                                         
                                                            l
                                                            u
                                                         
                                                         ,
                                                         
                                                            l
                                                            v
                                                         
                                                         ,
                                                         
                                                            l
                                                            w
                                                         
                                                         )
                                                         >
                                                         0
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         α
                                                         
                                                            l
                                                            u
                                                         
                                                      
                                                      P
                                                      
                                                         (
                                                         
                                                            l
                                                            v
                                                         
                                                         ,
                                                         
                                                            l
                                                            w
                                                         
                                                         )
                                                      
                                                   
                                                
                                                
                                                   
                                                      else
                                                      
                                                      if
                                                      
                                                      
                                                         C
                                                         (
                                                         
                                                            l
                                                            u
                                                         
                                                         ,
                                                         
                                                            l
                                                            v
                                                         
                                                         )
                                                         >
                                                         0
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         α
                                                         
                                                            
                                                               l
                                                               u
                                                            
                                                            ,
                                                            
                                                               l
                                                               v
                                                            
                                                         
                                                      
                                                      P
                                                      
                                                         (
                                                         
                                                            l
                                                            w
                                                         
                                                         )
                                                      
                                                   
                                                
                                                
                                                   
                                                      otherwise
                                                      .
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           Image-specific lexicons (small or medium) are used in the closed vocabulary setting, while in the open vocabulary case we use a lexicon containing half a million words (henceforth referred to as large lexicon) provided by Weinman et al. [22] to compute these scores. The parameters 
                              
                                 α
                                 
                                    l
                                    u
                                 
                              
                            and 
                              
                                 α
                                 
                                    
                                       l
                                       u
                                    
                                    ,
                                    
                                       l
                                       v
                                    
                                 
                              
                            are learnt on the large lexicon using SRILM toolbox.
                              1
                           
                           
                              1
                              Available at: http://www.speech.sri.com/projects/srilm.
                            They determine the low score values for n-grams not present in the lexicon. We assign a constant value (0.4) when the labels are digits, which do not occur in the large lexicon.

Having computed the unary, pairwise and higher order terms, we use the sequential tree-reweighted message passing (TRW-S) algorithm [70] to minimize the energy function. The TRW-S algorithm maximizes a concave lower bound of the energy. It begins by considering a set of trees from the random field, and computes probability distributions over each tree. These distributions are then used to reweight the messages being passed during loopy belief propagation [71] on each tree. The algorithm terminates when the lower bound cannot be increased further, or the maximum number of iterations has been reached.

In summary, given an image containing a word, we: (i) locate the potential characters in it with a character detection scheme, (ii) define a random field over all these potential characters, (iii) compute the language priors and integrate them into the random field model, and then (iv) infer the most likely word by minimizing the energy function corresponding to the random field.

Several public benchmark datasets for scene text understanding have been released in recent years. ICDAR [17] and Street View Text (SVT) [18] datasets are two of the initial datasets for this problem. They both contain data for text localization, cropped word recognition and isolated character recognition tasks. In this paper we use the cropped word recognition part from these datasets. Although these datasets have served well in building interest in the scene text understanding problem, they are limited by their size of a few hundred images. To address this issue, we introduced the IIIT 5K-word dataset [19], containing a diverse set of 5000 words. Here, we provide details of all these datasets and the evaluation protocol.

The street view text (SVT) dataset contains images taken from Google Street View. As noted in [72], most of the images come from business signage and exhibit a high degree of variability in appearance and resolution. The dataset is divided into SVT-spot and SVT-word, meant for the tasks of locating and recognizing words, respectively. We use the SVT-word dataset, which contains 647 word images.

Our basic unit of recognition is a character, which needs to be localized before classification. Failing to detect characters will result in poorer word recognition, making it a critical component of our framework. To quantitatively measure the accuracy of the character detection module, we created ground truth data for characters in the SVT-word dataset. This ground truth dataset contains around 4000 characters of 52 classes, and is referred to as SVT-char, which is available for download [73].

The ICDAR 2003 dataset was originally created for text detection, cropped character classification, cropped and full image word recognition, and other tasks in document analysis [17]. We used the part corresponding to the cropped word recognition called robust word recognition. Following the protocol of [11], we ignore words with less than two characters or with non-alphanumeric characters, which results in 859 words overall. For subsequent discussion we refer to this dataset as ICDAR(50) for the image-specific lexicon-driven case (closed vocabulary), and ICDAR 2003 when this lexicon is unavailable (open vocabulary case).

These datasets were introduced as part of the ICDAR robust reading competitions [74,75]. They contain 1189 and 1095 word images respectively. We show case-sensitive open vocabulary results on both these datasets. Also, following the ICDAR competition evaluation protocol, we do not exclude words containing special characters (such as &, :), and report results on the entire dataset.

The IIIT 5K-word dataset [19,73] contains both scene text and born-digital images. Born-digital images – category of images which has gained interest in ICDAR 2011 competitions [74] – are inherently low-resolution, made for online transmission, and have a variety of font sizes and styles. This dataset is not only much larger than SVT and the ICDAR datasets, but also more challenging. All the images were harvested through Google image search. Query words like billboard, signboard, house number, house name plate, movie poster were used to collect images. The text in the images was manually annotated with bounding boxes and their corresponding ground truth words. The IIIT 5K-word dataset contains in all 1120 scene images and 5000 word images. We split it into a training set of 380 scene images and 2000 word images, and a test set of 740 scene images and 3000 word images. To analyze the difficulty of the IIIT 5K-word dataset, we manually divided the words in the training and test sets into easy and hard categories based on their visual appearance. An annotation team consisting of three people have done three independent splits. Each word is then tagged as either being easy or hard by taking a majority vote. This split is available on our project page [73]. Table 1 shows these splits in detail. We observe that a commercial OCR performs poorly on both the train and test splits. Furthermore, to evaluate components like character detection and recognition, we also provide annotated character bounding boxes. It should be noted that around 22% of the words in this dataset are not in the English dictionary, e.g., proper nouns, house numbers, alphanumeric words. This makes this dataset suitable for open vocabulary cropped word recognition. We show an analysis of dictionary and non-dictionary words in Table 2
                              
                              .

We evaluate the word recognition accuracy in two settings: closed and open vocabulary. Following previous work [11,19,53], we evaluate case-insensitive word recognition on SVT, ICDAR 2003, IIIT 5K-word, and case-sensitive word recognition on ICDAR 2011 and ICDAR 2013. For the closed vocabulary recognition case, we perform a minimum edit distance correction, since the ground truth word belongs to the image-specific lexicon. On the other hand, in the case of open vocabulary recognition, where the ground truth word may or may not belong to the large lexicon, we do not perform edit distance based correction. We perform many of our analyses on the IIIT 5K-word dataset, unless otherwise stated, since it is the largest dataset for this task, and also comes with character bounding box annotations.

@&#EXPERIMENTS@&#

Given an image region containing text, cropped from a street scene, our task is to recognize the word it contains. In the process, we develop several components (such as a character recognizer) and also evaluate them to justify our choices. The proposed method is evaluated in two settings, namely, closed vocabulary (with an image-specific lexicon) and open vocabulary (using an English dictionary for the language model). We compare our results with the best-performing recent methods for these two cases. For baseline comparisons we choose commercial OCR namely ABBYY [78] and a public implementation of a recent method [79] in combination with an open source OCR.

We use the training sets of ICDAR 2003 character [17] and Chars74K [27] datasets to train the character classifiers. This training set is augmented with 48 × 48 patches harvested from scene images, with buildings, sky, road and cars, which do not contain text, as additional negative training examples. We then apply affine transformations to all the character images, resize them to 48 × 48, and compute HOG features. Three variations (13, 31 and 36-dimensional) of HOG were analyzed (see Table 3). We then use an explicit feature map [63] and the χ
                        2 kernel to learn the SVM classifier. The SVM parameters are estimated by cross-validating on a validation set. The explicit feature map not only allows a significant reduction in classification time, compared to non-linear kernels like RBF, but also achieves a good performance.

The two main differences from our previous work [37] in the design of the character classifier are: (i) enriching the training set, and (ii) using an explicit feature map and a linear kernel (instead of RBF). Table 3 compares our character classification performance with [11,27,37,43,76,77] on several test sets. We achieve at least 4% improvement over our previous work (RBF [37]) on all the datasets, and also perform better than [11,27]. We are also comparable to a few other recent methods [43,76], which show a limited evaluation on the ICDAR 2003 dataset. Following an evaluation insensitive to case (as done in a few benchmarks, e.g., [20,53], we obtain 77% on ICDAR 2003, 75% on SVT-char, 79% on Chars74K, and 75% on IIIT 5K-word. It should be noted that feature learning methods based on convolutional neural networks, e.g., [20,77], show an excellent performance. This inspired us to integrate them into our framework. We used publicly available features [20]. This will be further discussed in Section 5.3. We could not compare with other related recent methods [23,30] since they did not report isolated character classification accuracy.

In terms of computation time, linear SVMs trained with HOG-13 features outperform others, but since our main focus is on word recognition performance, we use the most accurate combination, i.e., linear SVMs with HOG-36. We observed that this smart selection of training data and features not only improves character recognition accuracy but also improves the second and third best predictions for characters.

Sliding window based character detection is an important component of our framework, since our random field model is defined on these detections. We use windows of aspect ratio ranging from 0.1 to 2.5 for sliding window and at every possible location of the sliding window, we evaluate a character classifier. This provides the likelihood of the window containing the respective character. We pruned some of the windows based on their aspect ratio, and then used the goodness measure (5) to discard the windows with a score less than 0.1 (refer Section 3.1). Character-specific NMS is done on the remaining windows with an overlap threshold of 40%, i.e., if two detections have more than 40% overlap and represent the same character class, we suppress the weaker detection. We evaluated the character detection results with the intersection over union measure and a threshold of 50%, following ICDAR 2003 [17] and PASCAL-VOC [80] evaluation protocol. Our sliding window approach achieves recall of 80% on the IIIT 5K-word dataset, significantly better than using a binarization scheme for detecting characters and also superior to techniques like MSER [81] and CSER [79] (see Table 7 and Section 5.4).

The results of the proposed CRF model in closed vocabulary setting are presented in Table 4
                              . We compare our method with many recent works for this task. To compute the language priors we use lexicons provided by authors of [11] for SVT and ICDAR(50). The image-specific lexicon for every word in the IIIT 5K-word dataset was developed following the method described in [11]. These lexicons contain the ground truth word and a set of distractors obtained from randomly chosen words (from all the ground truth words in the dataset). We used a CRF with higher order term (n = 4), and similar to other approaches, applied edit distance based correction after inference. The constant 
                                 
                                    λ
                                    a
                                 
                               in (11) to 1, given the small size of the lexicon.

The gain in accuracy over our previous work [37], seen in Table 4, can be attributed to the higher order CRF and an improved character classifier. The character classifier uses: (i) enriched training data, and (ii) an explicit feature map, to achieve about 5% gain (see Section 5.1 for details). Other methods, in particular, our previous work on holistic word recognition [45], label embedding [25] achieve a reasonably good performance, but are restricted to the closed vocabulary setting, and their extension to more general settings, such as the open vocabulary case, is unclear. Methods published since our original work [37], such as [23,53], also perform well. Very recently, methods based on convolutional neural networks [20,30] have shown very impressive results for this problem. It should be noted that such methods are typically trained on much larger datasets, for example, 10M compared to 0.1M typically used in state-of-the-art methods, which are not publicly available [30]. Inspired by these successes, we use a CNN classifier [20] to recognize characters, instead of our SVM classifier based on HOG features (see Section 3.1). We show results with this CNN classifier on SVT, ICDAR 2003 and IIIT-5K word datasets in Table 4 and observe significant improvement in accuracy, showing its complementary nature to our energy based method. However, there remains a difference in performance between the deep feature based method [20] and [This work, CNN]. This is primarily due to use of CNN features for learning classifiers for individual character as well as bi-grams in [20]. In contrast, our method only uses the pre-trained character classifier provided by Jaderberg et al. [20]. Nevertheless, the improvement observed over [This work, HOG] does show the complementary nature of the two approaches, and integrating the two further would be an interesting avenue for future research.

In this setting we use a lexicon of 0.5 million words from [22] instead of image-specific lexicons to compute the language priors. Many character pairs are equally likely in such a large lexicon, thereby rendering pairwise priors is less effective than in the case of a small lexicon. We use priors of order four to address this (see also analysis on the CRF order in Section 5.4). Results on various datasets in this setting are shown in Table 5
                              
                              . We compare our method with recent work by Feild and Miller [26] on the ICDAR 2003 dataset, where our method with HOG features shows a comparable performance. Note that [26] additionally uses web-based corrections, unlike our method, where the results are obtained directly by performing inference on the higher order CRF model. On the ICDAR 2011 and 2013 datasets we compare our method with the top performers from the respective competitions. Our method outperforms the ICDAR 2011 robust reading competition winner (TH-OCR method) method by 17%. This performance is also better than a recently published work by Weinman et al. [23]. On the ICDAR 2013 dataset, the proposed higher order model is significantly better than the baseline and is in the top-5 performers among the competition entries. The winner of this competition (PhotoOCR) uses a large proprietary training dataset, which is unavailable publicly, making it infeasible to do a fair comparison. Other methods (NESP [82], MAPS [83], PLT [84]) use many preprocessing techniques, followed by off-the-self OCR. Such preprocessing techniques are highly dataset dependent and may not generalize easily to all the challenging datasets we use. Despite the lack of these preprocessing steps, our method shows a comparable performance. On the IIIT 5K-word dataset, which is large (three times the size of ICDAR 2013 dataset) and challenging, the only published result to our knowledge is Strokelets [31] from CVPR 2014. Our method performs 7% better than Strokelets. Using CNN features instead of HOG further improves our word recognition accuracy, as shown in Table 5.

The main focus of this work is on evaluating datasets containing scene text images or a mixture of scene text and born-digital images. Nevertheless, we also tested our method on the born-digital image dataset from the recent ICDAR 2013 competition. Our approach with pre-trained CNN features achieves 78% accuracy on this dataset, which is comparable to other top performers (80.40%, 80.26%, 79.40%), and lower than PhotoOCR (82%), the competition winner using an end-to-end deep learning approach.

To sum up, our proposed method performs well consistently on several popular scene text datasets. Fig. 7 shows the qualitative performance of the proposed method on a few sample images. The higher order CRF outperforms the unary and pairwise CRFs. This is intuitive due to the better expressiveness of the higher order potentials. One of the failure cases is shown in the last row in Fig. 7, where the higher order potential is computed from a lexicon which does not have sufficient examples to handle alphanumeric words.

The size of the lexicon plays an important role in the word recognition performance. With a small-size lexicon, we obtain strong language priors which help overcome inaccurate character detection and recognition in the closed vocabulary setting. A small lexicon provides much stronger priors than the large lexicon in this case, as the performance degrades with increase in the lexicon size. We show this behavior on the IIIT 5K-word dataset in Table 6
                               with small (50), medium (1000) and large (0.5 million) lexicons. We also compare our results with a state-of-the-art methods [25,31]. We observe that [25,31] shows better recognition performance with the small lexicon, when we use HOG features, but as the size of the lexicon increases, our method outperforms [25].
                           

While our sliding window approach for character detection performs well in several scenarios, including text that is not aligned with the image axes to a small extent (e.g., rows 4–6 in Fig. 7), there are other alternatives. In particular, we investigated the use of binarization, MSER [81], and CSER [49] algorithms. In the first experiment, we replaced our detection module with a binarization based character extraction scheme – either a traditional binarization technique [85] or a more recent random field based approach [47]. A connected component analysis was performed on the binarized images to obtain a set of potential character locations. We then defined the CRF on these characters and performed inference to get the text contained in the image. These results are summarized in Table 7. We observe that binarization based methods perform poorly compared to our model using a sliding window detector, both in terms of character-level recall and word recognition. They fail in extracting characters in the presence of noise, blur or large foreground-background variations. MSER [81] or related algorithms (e.g., CSER [49]) may also help to deal with text that is not axis-oriented, but they are not necessarily ideal for character extraction compared to a sliding window method. To study this, we replaced our sliding window based character detection scheme with either one of these approaches. From Table 7 we observe that sliding window character extraction is marginally better than CSER and significantly better than MSER. One of the reasons for this is that the classifier used in the sliding window detector is trained on a large variety of character classes and is less prone to errors than the MSER equivalent. These results further justify our choice of sliding window based character detection, although the challenging problem of effectively dealing with text that is not axis-oriented remains an interesting task for the future.

We propose a pruning step to discard candidates based on a combination of character-specific aspect ratio and classification scores (5), instead of simply using extreme aspect ratio to discard character candidates. This pruning helps in removing many false positive windows, and thus improves recognition performance. We conducted an experiment to study the effect of pruning on the IIIT-5K dataset in the open vocabulary setting, and observed a gain of 4.23% (46.73% vs 42.50%) due to pruning.

We varied the order of the CRF from two to six and obtained accuracy of 32%, 43%, 45%, 43%, 42% respectively on the IIIT 5K-word dataset in the open vocabulary setting. Increasing the CRF order beyond four forces a recognized word to be one from the dictionary, which leads to poor recognition performance for non-dictionary words, and thus deteriorates the overall accuracy. Empirically, the fourth order prior shows the best performance.

Statistical language models have been very useful in improving traditional OCR performance, but they are indeed limited [65,86]. For instance, using a large weight for language prior potentials may bias the recognition towards the closest dictionary word. This is especially true when the character recognition part of the pipeline is weak. We study such impact of language models in this experiment. Our analysis on the IIIT 5K-word dataset suggests that many of the non-dictionary words are composed of valid English n-grams (see Table 2). However, there are few exceptions, e.g., words like 35KM, 21P, which are composed of digits and characters; see last row of Fig. 7. Using language models has an adverse effect on the recognition performance in such cases. This results in inferior recognition performance on non-dictionary words as compared to dictionary words, e.g. on IIIT-5K dataset our method achieves 51% and 24% word recognition accuracy on dictionary and non-dictionary words, respectively.

@&#SUMMARY@&#

This paper proposes an effective method to recognize scene text. Our model combines bottom-up cues from character detections and top-down cues from lexicon. We jointly infer the location of true characters and the word they represent as a whole. We evaluated our method extensively on several challenging street scene text datasets, namely SVT, ICDAR 2003/2011/2013, and IIIT 5K-word and showed that our approach significantly advances the energy minimization based approach for scene text recognition. In addition to presenting the word recognition results, we analyzed the different components of our pipeline, presenting their pros and cons. Finally, we showed that the energy minimization framework is complementary to the resurgence of convolutional neural network based techniques, which can help build better scene understanding systems.

@&#ACKNOWLEDGMENTS@&#

We thank Jerod Weinman for providing the large lexicon. This work was partially supported by the Ministry of Communications and Information Technology, Government of India, New Delhi. Anand Mishra is supported by Microsoft Corporation and Microsoft Research India under the Microsoft Research India Ph.D fellowship award.

@&#REFERENCES@&#

