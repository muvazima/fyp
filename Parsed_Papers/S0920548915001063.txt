@&#MAIN-TITLE@&#A UML-based domain specific modeling language for service availability management: Design and experience

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We present a UML-based domain specific modeling language (DSML) that models the SA Forum Availability Management Framework (AMF) domain model.


                        
                        
                           
                           Our DSML provides designers with the tools needed for designing, editing, and potentially analyzing AMF configurations.


                        
                        
                           
                           Our DSML has been carefully designed to represent AMF concepts, their relations, and constraints.


                        
                        
                           
                           Our DSML has been implemented using IBM Rational Software Architect.


                        
                        
                           
                           We show the effectiveness of our DSML in designing AMF configurations through a case study.


                        
                        
                           
                           We report on our experience in designing this language and the challenges encountered during this process.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Domain-specific modeling languages

UML profiles

High-availability

Availability Management Framework Standard

Service Availability Forum

@&#ABSTRACT@&#


               
               
                  For critical systems, providing services with minimal interruption is essential. Availability Management Framework (AMF), defined by SA Forum for managing highly-available applications, requires configurations of applications consisting of various entities organized according to AMF-specific rules and constraints. Creating such configurations is difficult due to the numerous constrained entities involved. This paper presents UACL (UML-based AMF Configuration Language) and a supporting implementation that models the AMF domain, providing designers with tools needed to design, edit, and analyze AMF configurations. UACL is an extension of UML through its profiling mechanism and has been designed to represent AMF concepts, their relations, and constraints.
               
            

@&#INTRODUCTION@&#

Service availability has long been an important software requirement, especially for safety-critical systems for which any service interruption may have fatal results, hence, the latest increase in attention to effective solutions that usually take the form of high-availability middleware for the development of highly available (HA) systems. The common practice is to have some sort of redundancy models so as failing nodes are detected and their workload is shifted to standbys. However, most existing solutions are proprietary and platform specific, which hinders the portability of the applications from one platform to another. To address this issue, many telecommunications and computing companies have joined forces in the Service Availability Forum (SA Forum) [34], a consortium whose objective is to define open standard specifications in order to support the development and management of HA applications and to enable portability and reusability across different platforms. More specifically, the SA Forum standard service interfaces enable the use of Commercial-Off-The-Shelf (COTS) building blocks for an HA system, which results in the enhanced portability and flexibility of the components. Moreover, since the developers need only to focus on the application logics, SA Forum standards reduce the complexity of the application development.

The SA Forum specifications can be grouped into two categories:
                        
                           •
                           The Application Interface Specification (AIS) [35] which defines a set of services that are needed to fully support the high availability of the application's components.

The Hardware Platform Interface (HPI) [36] which provides standard means to control and monitor hardware components.

There are several implementations of AIS provided by different groups. OpenAIS is an open source project that started at MontaVista [17] as an implementation of AIS and later became part of Linux implementation and was licensed under the Revised BSD license [30]. Other projects such as Corosync also were derived from OpenAIS [5]. The most popular implementation AIS is OpenSAF which is supported by various telecommunication and software companies through OpenSAF Foundation [32].

The major implementation of HPI is OpenHPI, which is provided by the open source community [31].

Among the services defined in AIS, perhaps the most important one is the Availability Management Framework (AMF) [37], which is the middleware service that manages the high availability of the applications' services by coordinating the applications' redundant components. An AMF configuration for a given application is a logical organization of resources that enables AMF to perform workload assignments to provide service availability

The design of AMF configurations requires 1) the description of the software components provided by the vendor in an Entity Types File (ETF), which follows a standard format defined in [38], 2) the description of the deployment infrastructure, 3) the definition of the services to be provided, and 4) the required redundancy model. Such a design requires a good understanding of AMF concepts and their relations. This is a complex task due to the large number of entities and parameters that need to be designed and generated. There are also several constraints imposed by the AMF domain, which tend to crosscut various entities, making the configuration design process very complex. Also, the specifications are described in an informal way, leaving room for ambiguity and misinterpretations.

To address these issues, we have designed a precise and complete modeling language, called UACL
                        1
                     
                     
                        1
                        MAGIC (Modeling and Automatic Generation of Information and upgrade Campaigns for service availability). The acronym MAGIC is used throughout the description of UACL to reflect concepts and elements that have been newly introduced or further refined compared to standard specifications.
                      (a UML-based AMF Configuration Language) to enable the design and analysis of AMF configurations. Our language is a new domain-specific modeling language (DSML) tailored to capture the AMF domain's concepts and semantics.

Using UACL, one can benefit from the advantages of a domain specific modeling language (e.g. usability, the reuse and conservation of domain knowledge and the ease of communication) [42] as well as from the advantages associated with UML, including its standard design notation and accessible tool support.

UACL is a UML profile [27] for the modeling of AMF domain concepts, their attributes, their relationships, and the domain specific constraints. It has been implemented using IBM Rational Software Architect (RSA) [9]. We believe that it is an important contribution to the service high availability community since it aims to enable different activities, such as the design of configurations using domain concepts as first class artifacts, model driven generation of valid AMF configurations, the validation of third party AMF configurations.

In this paper, we also report on our experience in designing such a profile by discussing the challenges we have encountered and that we attribute mainly to three aspects: (a) the lack of a systematic approach for creating profiles, especially for the mapping of the domain concepts to the UML metamodel — in many situations, we have found that there were many alternatives and it was not always obvious which one to choose; (b) the use of Object Constraint Language (OCL) [28] which turned out to be problematic, since most of the domain constraints needed extensive OCL expressions that crosscut several domain contexts; and (c) the lack of flexible tool support. These challenges are discussed along with the lessons learned from the overall project, with the aim of contributing to the modeling community with the results of this experience. It is worth noting that the work described in this thesis is part of a larger research project called MAGIC1 — a collaboration between Concordia University and Ericsson — and the results of this thesis are being used in other MAGIC research streams. The term MAGIC is used throughout the profile.

The remaining part of this paper is structured as follows. In Section 2, we introduce the main concepts in the AMF specification. In Section 3, we present the related work where we reviewed different UML profiles relevant to our domain. In Section 4, we describe the methodology used for the design of our profile, the domain model of the profile, as well as the description of the language and its mapping to theUML metamodel. In Section 5, we present the implementation of UACL and a case study, followed by a discussion of the challenges in Section 6. We conclude the paper in Section 7.

AMF [37] is part of the AIS middleware, responsible for managing the availability of the services provided by an application. AMF fulfills this responsibility by managing the redundant components of an application by dynamically shifting workloads of faulty components to the healthy components. In order to manage the services, AMF requires a configuration that specifies the organization and the characteristics of the entities under its control. These entities model the service providers, the provided services, and the deployment information. An AMF configuration consists of two different sets of concepts: AMF entities and the associated AMF entity types. AMF entities are categorized into different logical entities representing services and service providers' resources. The basic entities are called Components. Components represent hardware or software resources capable of supporting the workload of the application services. Such a workload is referred to as a Component Service Instance (CSI). For example, an instance of MySQL server could be a component called MySQL_1 which is capable of supporting a specific set of clients. The IP addresses of these clients form the description of the workload for this specific instance of MySQL component which is captured through a CSI (MySQL_1_CSI). Components are aggregated into Service Units (SU), logical entities representing the basic redundancy unit for AMF. The aggregation of components (e.g. MySQL_1, Driver Manager_1, and JDBC Connector_1) enables the combination of their functionalities to form higher level services. More specifically, the workloads of the components of an SU are aggregated into a Service Instance (SI), which represents the aggregated workload assigned to the SU. An SI also represents the combined higher level service of the collaborating components within the SU. In our example, the combination of MySQL_1, Driver Manager_1, and JDBC Connector_1 forms a database tier (SU) which can provide service for software systems, developed using Java based technologies.

SUs are further grouped into Service Groups (SG) in order to protect a set of SIs by means of redundancy. SGs are characterized by redundancy models. AMF supports the No-Redundancy, 2N, N+M, N-Way and N-Way-Active redundancy models. These redundancy models differ on the number of SUs that can be active and on standby for the SIs and on how these assignments are distributed among the SUs. In the 2N redundancy model, one SU is active for all the SIs protected by the SG and one is on standby for all the SIs. In the N+M model, N SUs support the active assignments and M SUs support the standbys. N+M allows at the most one active and one standby assignment for each particular SI. An SG with N-Way redundancy model contains N SUs. Each SU can have a combination of active and standby assignments. However, each SI can be assigned active to only one service unit while it can be assigned as on standby to several service units. An SG with the N-Way-Active redundancy model has N SUs which are assigned only as active. It has no SU assigned as on standby. Furthermore, each of the SIs protected by this SG can be assigned to more than one SU. In contrast to N-Way-Active, in the No-Redundancy redundancy model each SI is assigned to at most one SU and each SU can protect at most one SI. An AMF application is composed of one or more service groups. Each SU is deployed on an AMF node and the set of all AMF nodes forms the AMF cluster. Table 1
                      summarizes the AMF entities and their descriptions.

AMF entity types are used to define the common characteristics among multiple instances of the same type. For example, a component type can define all the characteristics/attributes of the MySQL server which are common among all instances of this server. In AMF, all entities except for the deployment entities (i.e., node, NG, and cluster) have a type. The types are derived from a vendor's description of the application in the ETF [38].


                     Fig. 1
                      shows an example of an AMF configuration. In this example, a cluster is composed of two nodes (Windows Server 1 and Windows Server 2). It hosts an application consisting of one SG (MySql SG_1) protecting two SIs (MySql Java Connection_1 and MySql Java Connection_2) in a 2N redundancy model. The MySql SG_1 consists of two SUs, MySql Db Tier_1 and MySql Db Tier_2, each being composed of three components. Although shown in Fig. 1, the distribution of the active and standby assignments is not part of the configuration as defined by AMF, since this is decided by AMF at run-time. The types, part of the configuration, are shown in the right hand side of the figure. The relationship between the type entities and the entities presented in the configuration are as follows: MySQL_1 and MySQL_2 are from the Component Type MySQL Server. JDBC Connector_1 and JDBC Connector_2 are from MySQL Connector/J. Both the SUs are represented by the same SUType called MySQL Db Tier for Java. MySql SG_1 and App1 are from the type MySql Service Group and APT-A, respectively. At the service level, both SIs (MySql Java Connection_1 and MySql Java Connection_2) are from the type MySql Java Connection while the CSIs are from three different types. More specifically, MySQL_CSI_1 and MySQL_CSI_2 are of the type MySQL_CST, JDBC_Con_CSI_1 and JDBC_Con_CSI_2 are from the type MySQL Connector/J_CST and finally, Drv_Mng_CSI_1 and Drv_Mng_CSI_2 are from Driver Manager_CST.

@&#RELATED WORK@&#

There are several UML profiles (some of them standardized) that model concepts such as components and services, which are also key concepts in AMF. The question is therefore: Do we need to define a UML profile from scratch or simply reuse (or extend) an existing one? This question has always been a matter of debate since each option has its own benefits and disadvantages. Unfortunately, there is no formal process of finding out whether it is better to extend an existing profile or to create a new one. In this section, we present a brief review of related UML profiles together with the rationale supporting our decision to create a new profile, instead of extending an existing one.

There are three main UML profiles defined and standardized by OMG [29] which represent some concepts that are also found in AMF. These profiles are: SPT [19], MARTE [24], and the UML profile for QoS&FT [22]. There are also other profiles related to the AMF concepts, namely the DAM Profile [4] and the profile introduced in the HIDENETS project [13]. These two profiles are to some extent either extending or reusing parts or all of one of the aforementioned OMG profiles.

The UML SPT profile [19] focuses on the properties related to the modeling of time and time-related aspects such as the concept of clocks, the key characteristics of timeliness, performance, and schedulability. Despite the fact that the authors introduce a set of sub-profiles in order to extend the core of SPT, which is the general resource modeling framework and which can be used by other profiles for availability analysis, there are no specific means for modeling availability related issues such as redundancy models in SPT. Consequently, when reusing SPT, one should define all necessary constructs for AMF configurations. However, basing this definition on SPT's abstract syntax may complicate the design process of our language by imposing extra constraints inherited from SPT and which are not related to the AMF domain.

The MARTE profile [24], an extension of SPT, defines a package for Non-Functional Properties (NFPs) which supports new user-defined NFPs for different specialized domains [24]. It also defines a package for the purpose of analysis called the Generic Quantitative Analysis Modeling (GQAM). UML profile for QoS&FT defines a general QoS catalogue including a set of general characteristics and categories [22]. In particular, this profile defines a package for availability related concepts, focusing on representing attributes, such as mean time to failure that can be used to measure the availability of services. Similarly to SPT, these profiles omit to model key concepts of high-availability including the redundant structures which play a critical role in highly available systems. Extending them has the same drawbacks as for SPT.

Both NFA and GQAM packages (from the MARTE Profile) have been reused in the design of the Dependability Analysis Modeling (DAM) profile (an extension to MARTE) in order to enhance modeling facilities for the purpose of analyzing dependability [4]. In the DAM profile, the building blocks of a system are limited to components (DaComponent mapped to MARTE::GRM::Resource) and services (DaService mapped to MARTE::GQAM::GaScenario). The DAM profile does not model many key AMF concepts including proxies, service units, component service instance, and so on. In addition, the concept of services in the DAM profile describes the service itself, whereas in AMF, the service describes the workload to be assigned to a service provider at run-time. Adapting the DAM profile to AMF would require as much effort as creating a new profile, if not more. We have decided to opt for the development of a new profile to avoid being restricted with the DAM semantics.

The HIDENETS profile [13] was introduced to model software that runs on the HIDENETS platform. The HIDENETS middleware provides a basis for mobility-awareness and for the distribution of applications. The designers of this profile have reused several standard UML profiles such as SPT, QoS&FT, SysML [26], AUTOSAR Profile [2], and MAM-UML [3]. In addition, the HIDENETS profile is compliant with the AMF specification [37].

HIDENETS utilizes AMF concepts using the façade design pattern. In this profile the authors provided a general AMF façade, the point through which the middleware interacts with the AMF elements. In other words, a set of well-designed AMF compliant components can interact with the HIDENETS middleware through the AMF façade. HIDENETS profile does not model AMF configuration concepts and therefore, cannot be used to fulfill our goal of specifying and analyzing AMF configurations.

The work described in [45] is probably the work most related to this paper. The authors introduced an MDA (Model-Driven Architecture) approach for the automatic generation of SA Forum compliant applications. They have introduced a metamodel for SA Forum compliant applications based on the class diagram introduced for AMF configurations in AMF specification [37]. Based on their work, an application should be first modeled using their metamodel and then, by using an MDA approach, the SA Forum compliant APIs are added and the source code for the application is generated. The authors have also provided the configuration for the subject application. Although this work concentrates more on application development, it also generates the required AMF configuration for the application. This work is limited to in-house software development and does not handle third party software. Moreover, the software development and configuration design are handled at the same time which does not leave much flexibility for configuration and deployment time. After careful examination of the profile described in [45], we found that it does not take into account many AMF domain constraints. Capturing and specifying the constraints is an important step in the definition of a UML profile. In particular, in complex domains such as AMF configurations, class diagrams alone are not sufficient to express all domain specific concepts and their relations. A non-constrained domain model does not guarantee a profile that can be used to validate third party configuration written in this profile, which is one of the objectives of our work. From the implementation point of view, one of the goals of our work is to develop a CASE tool to support different activities. In the case of extending existing profiles, we need to have access to their implementation such as the OMG XML Metadata Interchange (XMI) [20] format that serializes the profile model. We found that the non-standard profiles do not provide open access to their implementation. Although the implementation is available for some of the standard OMG profiles (e.g., MARTE), due to the characteristics of the AMF domain concepts, we could use only small fractions of these implementations. At the same time, building an extension requires importing and handling the whole implementation package. This may result in complexity at the tool development phase as well as performance issues at run-time. For instance, the run-time evaluation of the newly defined constraints of the new language may require the evaluation of several constraints of the referred profile.

In the work by Turenne et al. [47,48], the authors improve on their previous work [11,12], by adding a model for the description of software components specified in ETF. Their model captures the description of the software components which is used to generate the configuration when these components are deployed and not the AMF configuration itself.

In the area of standardization, Lightweight Fault Tolerance (LWFT) [25], which extends the Fault Tolerance (FT) CORBA [23] specification, provides an availability management solution to support real-time applications. The applications however, need to follow CORBA architecture [18]. In [46], the authors discuss the difference between CORBA based solutions and SA Forum in detail.

Unfortunately, there has been little material written on how to create UML profiles. As a result, most existing UML profiles have been defined in an ad hoc manner, ending up being either technically invalid, contradicting the UML metamodel, or of poor quality [14,15,45]. In the work presented in this paper, we followed the approach proposed by Selic in [43]. This approach consists of the following two steps:
                        
                           •
                           Specifying the domain model (or domain metamodel): The domain model specifies the concepts that pertain to the domain specific modeling language and how these concepts are represented. The output of this phase consists of fundamental language constructs, relationships between domain concepts, and any constraints imposed by the domain. The concrete syntax or the notation used to render these concepts, and the semantics of each language construct are also described at this stage.

Mapping the domain model to the UML metamodel: This step consists of identifying the most appropriate UML base concepts for each domain concept specified in the previous step. In this step, the profile designer needs to choose the base UML metaclass which is semantically closest to the semantics of the domain concept. Moreover, the constraints, attributes, and related associations of the selected meta-elements should be verified in order to prevent the contradiction of the domain concepts.

The AMF domain model has been developed by studying the AMF specifications and through constant interactions with an AMF domain expert. A class diagram describing the different types, entities and some of their relationships is provided in the standard. This class diagram is kept simple for the purpose of administration and runtime management. It is not appropriate for the purpose of configuration design and validation as it does not capture all the properties and constraints for an AMF configuration.

The AMF domain elements are modeled as UML classes and the relationships among them are modeled through different types of UML relationships. The well-formedness rules of the AMF domain model elements have been specified using OCL. Fig. 2
                         represents the process of specifying the AMF domain model.

As discussed in the previous sections, AMF concepts are classified into AMF entities and AMF entity types. Accordingly, we group such concepts into two packages named AMF Entity and AMF Entity Type. A further classification distinguishes the entities that provide the services (included in the Service Provider packages) from those representing the services themselves (in the Service package). Similarly, two packages called Service Provider Type and Service Type have been defined to capture the AMF entity types. In addition, the AMF Entity package includes the Deployment package, which contains elements corresponding to the cluster and the nodes. There is no corresponding type package for the Deployment package since the deployment entities are not typed. The following sections summarize the key AMF domain model elements and their relations.

In the standard specification, we can distinguish different AMF component categories along four orthogonal criteria: locality, service availability awareness (SA-awareness for short), containment, and mediation (see Fig. 3
                           ). The SA-awareness criterion distinguishes the components that implement the AMF APIs and directly interact with an AMF implementation to manage service availability. SA-aware components are further specialized using other criteria. The containment criterion identifies the contained components that do not run directly on an operating system but instead use an intermediate environment, referred to as the container component, like a virtual machine (for example, to support Java-like programs). SA-aware components can be categorized further into proxy and container components. Proxies are used to give AMF control over hardware or legacy software, called proxied components. Container components allow AMF to control the life-cycle of contained components. Finally, the locality criterion distinguishes components that reside within an AMF cluster from the external ones. External components are always proxied to be controlled by AMF. These categories are captured in Fig. 3 differently from the standard specification where they are distinguished with attributes.

Unlike the component classification, the component types do not take into consideration the locality criterion. This is because the component type cannot specify whether its components have to be located outside or inside the AMF cluster. In fact, a component type can specify whether its implementation captures 1) the APIs required to interact with AMF or 2) the necessary states for being proxied by another component type. As a result, the component type class models the types of the SA-aware components, the proxied components, and the non-proxied-non-SA-aware components. The SA-aware component type is further specialized to model the type of standalone components whose life cycle is managed directly by the AMF. Moreover, the standalone component type is further specialized into the proxy component type and the container component type which are the types of the proxy and container components, respectively. Fig. 4
                            presents the different categories of AMF component types.

To provide a higher level service, components are grouped into SUs. We distinguish between local and external SUs (see Fig. 5
                           ) depending on whether or not they contain local or external components. SUs are organized into SGs to protect services using different redundancy models: 2N, N+M, N-Way, N-Way-Active and No-redundancy. SGs are specialized based on the redundancy models used to protect their SIs (see Fig. 5). Each redundancy model has different characteristics and therefore, different sets of attributes and relationships with other elements (e.g. SUs). The specialization of SGs based on the redundancy models facilitates the design and analysis of AMF configurations by reducing the complexity of the configuration. The original SG configuration attributes depicted in the AMF specification have been re-organized according to their relevance to the newly introduced SG classes. At the type level, the AMF specification defines an attribute to distinguish between the local and the external SUTypes. In our domain model, we specialize the SUTypes into two classes: MagicAmfLocalSUType and MagicAmfExternalSUType. The SGType and ApplicationType are the same as in the AMF specification as there is no specific reason to specialize them. The CSI and SI entities are captured in our domain model as shown in Fig. 6
                           .

The AMF cluster, the AMF node and the node group represent part of our model for the deployment entities (see Fig. 7
                           ). An AMF cluster is the complete set of AMF nodes in the AMF configuration. An AMF node represents a cluster node that can host AMF entities A node group represents a set of AMF nodes and is used for the deployment of local SUs and SGs. More specifically, each local SU can be configured to be deployed on one of the nodes of a node group and AMF decides the hosting node at runtime.

A detailed description of all domain elements, their attributes and relationships is presented in [41].

We used OCL to describe the constraints on the AMF domain model elements. We have categorized the well-formedness rules into three different groups: 1) configuration attributes, 2) structural constraints, and 3) constraints for ensuring the protection of services that a configuration claims to achieve. The first two groups can be seen as syntactical constraints while the last group of constraints is more about the semantic correctness of the configuration. The complete list of constraints is presented in [41]. In this paper, we provide examples from each category of constraints.

As discussed earlier in this paper, one of the main reasons for the complexity of AMF configurations is the large number of configuration attributes, parameters to be considered and the related constraints. These constraints among the attributes form the category of configuration attributes well-formedness rules. For instance, among the attributes of a component type, the magicSaAmfCtDefDisableRestart attribute specifies whether the restart recovery action is disabled by default for the components of this component type and the magicSaAmfCtDefRecoveryOnError attribute specifies the default recovery action that should be taken by the middleware for the components of this type in case of a failure. Based on the standard, for a certain component type, if the magicSaAmfCtDefDisableRestart is configured to true, then the attribute magicSaAmfCtDefRecoveryOnError must not be set as SA_AMF_COMPONENT_RESTART or SA_AMF_NO_RECOMMENDATION. This constraint is captured in the domain model and specified in OCL as:
                                 
                                    
                                 
                              
                           

Several other restrictions on the attributes defined in the AMF specification are, however, complex and not straightforward to express. This complexity stems from the fact that, in an AMF configuration, these requirements crosscut entities and concepts from different levels. This is the case, for example, when a constraint involves different concepts such as the component capability and the redundancy model.


                              Fig. 8
                               depicts part of the AMF domain model which represents the relationships of the CSType with the component type and the component. Both relationships are represented through association classes. The AMF domain specification states that: for all CSTypes which are provided by a component, the value of the attribute magicSaAmfCompNumMaxActiveCSIs in the association class between component and CSType should be lower than or equal to the value of the attribute magicSaAmfCtDefNumMaxActiveCSIs which is located in the association class between the CSType and the component type of that component. This is an example of a cross-context constraint which has been captured in the domain model and specified in OCL as follows:
                                 
                                    
                                 
                              
                           

The elements of the AMF configurations are strongly related, resulting in a complicated organization of configuration elements. More specifically, the configuration entities and entity types form two levels of abstraction which need to be compliant with each other. In addition, in each level there are nested relationships among the elements (e.g. SG groups SUs and each SU groups components). Therefore, the second category of well-formedness rules is concerned with ensuring the structural consistency of the configuration with respect to the standard. As an example of a structural constraint definition, let us consider the definition of the following property specified by the AMF specification: the only valid redundancy model for the SGs whose SUs contain a container component is the N-Way-Active redundancy model. This is expressed in OCL in the context of the container component category represented by the class MagicAmfContainerComponent, and by using our specific class for the SG associated with the N-Way-Active redundancy model, MagicAmfN-WayActiveSG (see Fig. 9
                              ). We can therefore easily capture this restriction in OCL as follows:
                                 
                                    
                                 
                              
                           

A configuration is semantically valid only if it is capable of providing and protecting the services as required and according to the specified redundancy model. More specifically, given a set of SUs grouped in an SG, one needs to ensure that the set of SUs is capable of handling the SIs configured for the SG. We formalized the service protection problem for all the redundancy model using higher order logic (HOL). Ensuring this (referred to as SI protection problem) requires the exploration of all possible SI-SU assignments. In some cases it is necessary to consider different combinations of SIs, which make the problem complex in most redundancy models. For instance, the problem has combinatorial aspects in N-Way and N-Way-Active, and N+M redundancy models where the SIs can be assigned to more than one SU, so there are many valid assignment combinations. For these cases the problem is NP-hard [39]. We tackled the problem by providing the necessary and sufficient conditions for ensuring the SI protection for each redundancy model. In the case of the 2N redundancy model and the No-Redundancy redundancy model, we have been able to characterize the necessary and sufficient conditions for the general case and specified this in the form of well-formedness rules in OCL. For example the conditions for the 2N redundancy model are summarized as:A service unit in the MagicAmfTwoNSG should be able to be active for all service instances protected by the service group and a service unit in the MagicAmfTwoNSG should be able to be on standby for all service instances protected by the service group (see Fig. 10
                              ).

The OCL constraints (for simplicity we present the constraint for local service units) specifying the well-formedness rule for the active/standby assignment of 2N redundancy model is:
                                 
                                    
                                 
                              
                           

For overcoming the complexity in the case of the N+M, the N-Way-Active, and the N-Way redundancy models, we have characterized some specific cases, where the necessary and sufficient conditions can be checked efficiently and specified them as OCL constraints. The details of the formal description of the SI protection problem as well as the complexity analysis and the proposed solutions are presented in [39].

Although in [43], the author proposes the separation of the domain modeling phase and the mapping phase, he does not provide any guidelines for this mapping, which is perhaps the most challenging activity in defining a well-formed UML profile. The International Telecommunication Union (ITU) also provides guidelines [10], which mainly focus on the profile document, common conventions, and recommendations on how to present the text and notations but not on the mapping phase. A lack of a systematic approach (or at least insightful guidelines) for selecting the most suitable metaclasses makes this phase dependent on the experience of the profile's designer. Other studies [14,15] propose patterns which are based on a few types of relationships that may exist between domain elements and the corresponding metaclasses. However, these guidelines focus on specific scenarios and do not provide a general solution to the mapping problem. In other words, there is no “ready to use” solution that addresses the general issue of selecting the most appropriate UML metaclass for a specific domain element.

During the design of our profile, we have selected the UML metaclasses that carry semantics similar to the domain concepts being represented. As such, the newly defined stereotypes must neither contradict nor violate the UML metamodel. In the presence of multiple candidates, we favored the metaclasses that permitted the reuse of as many UML relationships between the stereotyped elements as possible. Reusing the associations among the metaclasses decreases the complexity of the design. Hence, if it is necessary to have a relationship between two stereotypes, it is better to reuse (if possible) the existing relationships between the corresponding metaclasses. We also opted for the metaclasses that minimized the number of constraints needed to constrain the UML metamodel elements (i.e., to restrict the stereotyped UML metaclasses so as to have them behave according to the rules imposed by the domain). A large number of constraints is an indication that the selected metaclasses might not be the most suitable ones.

One needs to proceed step by step through the full set of domain concepts (specified as classes in the domain model), identifying the most appropriate UML base concepts for each of them. In this step, the objective is to find the UML base concept (UML metaclass) which is conceptually and semantically similar to each domain concept. The output of the mapping phase is a set of new stereotypes and the UML metaclass from which each stereotype is derived. It is important to mention that, since UML 2.0 supports the inheritance relationship between stereotypes, not all domain concepts need to be directly derived from a corresponding UML metaclass. Some of them will be derived from the newly created stereotypes. Fig. 11
                         illustrates the process of mapping the domain model to the UML metamodel, the definition of the concrete syntax for the language, and the specification of the metamodel level constraints. We follow systematically the steps of this process to guarantee the quality of our profile and the remainder of this section is dedicated to presenting each step in detail.

For each stereotype a suitable metaclass is presented (see Appendix A). This selection has been made by mainly considering the semantic alignment of the domain concepts with respect to UML metaclasses. However, the first choice might not be the most appropriate (most semantically aligned) one and further investigation is necessary. More specifically, after finding the candidate metaclasses for each domain concept, two different scenarios may occur:
                              
                                 1.
                                 The candidate metaclass semantically appears to be appropriate: in this case it is always beneficial to look at the child metaclasses specializing the candidate metaclass. In other words, since the child metaclasses specify more features, we may find them semantically more accurate for aligning with the description of the domain concept.

The candidate metaclass turns out to have features which are semantically too restrictive compared to the description of the domain concept. In this case, one should consider the parent metaclass which technically has fewer features.

These guidelines highly support the semantic alignment of the domain concepts with respect to the UML metamodel. Considering these guidelines in the rest of this section, we present the complete set of stereotypes defined in our profile for each domain concept. For each stereotype we also present the most suitable UML concept for mapping. In addition, the rationale behind the selection of each UML metaclass is presented. It is worth noting that, for most domain concepts, there is more than one UML metaclass as an alternative for mapping and the most appropriate alternative has been selected after an extensive study of the UML metamodel and the AMF domain model.

The component in AMF represents the encapsulation of the functionality of software that provides the services. This is similar to the concept of the component in UML, which is defined as “a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment” [21]. Therefore, we mapped the AMF component to the UML component defining a new stereotype called <<MagicSaAmfComponent>>. Similarly, a stereotype is defined for each component category and is indirectly mapped (through inheritance relationships between stereotypes) to the Component metaclass.

Based on the definition of SUs in the AMF domain, an SU is a logical entity that aggregates a set of components by combining the individual functionalities of these components to provide a higher level service. From this perspective, one could see an SU as a service provider, similar to a component, but at a higher level of abstraction. We therefore decided to map the SU to the UML Component metaclass as well. The stereotype <<MagicSaAmfSU>> is used to represent an SU. Local and external SUs are represented using the stereotypes <<MagicAmfLocalServiceUnit>> and <<MagicAmfExternalServiceUnit>>.

One of the key characteristics of a SG is the grouping of SUs. Given the fact that in UML “a package is used to group elements, and provides a namespace for the grouped elements” [21], it may appear that the metaclass Package could be a suitable base class for an SG. However, in addition to its ability to group SUs, an SG also ensures the availability of services by means of redundancy models for a certain set of SIs (assigned to the SUs grouped by the SG). Moreover, UML Component can liberally provide any kind of service. Consequently, we can consider the protection of SIs as a sort of service that is provided by the SG through importing SUs in its namespace. Therefore, similar to an SU, an SG can map to the UML Component metaclass. Considering the fact that the Component metaclass also has a grouping capability, it is the most appropriate candidate base class for the SG.

There are different categories of SGs based on their redundancy model, and so, for each category we have introduced a stereotype. The topmost stereotype (<<MagicSaAmfSG>>), however, has been mapped to the UML Component metaclass.

An application is a logical entity that contains one or more SGs. An application combines the functionalities of the constituent SGs in order to provide a higher level service. Similar to an SU, a UML Component has been found to be the most suitable base class for the stereotype designed to represent an AMF application (<<MagicSaAmfApplication>>).

In the UML specification, a Classifier is an abstract metaclass which is a namespace whose members can include features. A BehavioralClassifier is a specific type of Classifier that may have an interface realization [21]. Since we can consider CSIs as realizations of services which AMF dynamically assigns to components in terms of workload, BehavioredClassifier could be a good candidate for CSI. However, a CSI is the description of the characteristics of the workload which will be assigned to the component at run-time and not the description of the service itself. Therefore, BehavioredClassifier has been discarded. On the other hand, in UML, “a class describes a set of objects that share the same specifications of features, constraints, and semantics” [21], and thus, the metaclass Class is semantically closer to a CSI. As a result, we have used the metaclass Class as a base class for the stereotype that has been defined for CSI (<<MagicSaAmfCSI>>).

An SI is an aggregation of all component service instances (CSIs) to be assigned to the individual components of the SU in order for the SU to provide a particular service. In fact, semantically, an SI shares most of the characteristics of the CSI but at a higher level of abstraction. Consequently, similar to CSI, the metaclass Class can be used as a base class for the stereotype defied for an SI (<<MagicSaAmfSI>>). The only difference existing between the two is that the SI is capable of grouping a set of CSIs. This capability is also captured by the metaclass Class in UML due to the existence of an inheritance relationship between the metaclass Class and the metaclass Classifier.

A node in the AMF domain is a logical entity that represents a complete inventory of SUs and their components. We mapped the AMF node to the UML metaclass Node since, similar to AMF, a node in UML “is a computational resource upon which artefacts may be deployed for execution” [21]. We created the stereotype <<MagicSaAmfNode>> to refer to an AMF node.

Based on the UML specification, “a package is used to group elements, and provides a namespace for the grouped elements” [21]. On the other hand, the complete set of AMF nodes in the AMF configuration defines the AMF cluster. The role of an AMF cluster and node group is the grouping of different AMF nodes. Therefore, the metaclass Package seems to be the most appropriate base class for the AMF cluster and node groups. The stereotypes <<MagicSaAmfCluster>> and <<MagicSaAmfNodeGroup>> are used to refer to these two entities.

In general, the type entity describes the characteristics and features common to all entities of this type. All entities of the same type share the attribute values defined in the entity type. Some of the attribute values may be overridden, and some other ones may be extended by the entity at configuration time. In other words, the type is the generalization of similar entities. For example, the SGType is a generalization of similar SGs that follows the same redundancy model, provide similar availability, and are composed of units of the same SUTypes. Considering the fact that, in UML, the metaclass Class describes a set of objects that share the same specifications of features, constraints, and semantics [21], it can be used as a base class for all AMF entity types.


                              Appendix A presents the summary of the stereotypes defined for AMF entities and entity types as well as the graphical syntax of our language for each stereotype.

We distinguish six different categories of relationships between domain concepts:
                              
                                 •
                                 Provide: This relationship is used between service providers and service elements and represents the capability to provide services.

Type: It represents the relationship which is used between AMF entities and their type (e.g. the relationship between component and component type).

Group: It represents the relationship which is used between grouping and grouped elements (e.g. the relationship between an SU and its enclosing components).

Protect: It represents the relationship which is used between an SG and SIs in order to protect the services they represent.

Deploy: It represents the installation relationship which is used for deployment purposes (e.g. between a service unit and a node or between service group and a node group).

Member node: represents the relationship which is used between a node and a nodegroup or cluster. It is non-exclusive, as a node may be member of different node groups.

A careful selection (i.e. semantic alignment) of metaclasses for our domain concept related stereotypes allowed us to reuse many associations in the UML metamodel for the aforementioned relationships. Reusing the association from the UML metamodel decreases the complexity of the process of defining the profile while improving the quality of the profile. More specifically, if we consider the related associations of each metaclass as part of its semantic, reusing these associations will implicitly support the semantic alignment and compliance of the domain concepts with respect to the UML metamodel. Each relationship has been stereotyped accordingly and mapped to either Association, AssociationClass, or Dependency.

For example, both <<MagicSaAmfSI>> and <<MagicSaAmfCSI>> stereotypes are mapped to the UML metaclass Class and, since the metaclass Class inherits indirectly from the metaclass Classifier in the UML metamodel, there is an association between the classes Class and Classifier called “nestedClassifier”, which allows classifiers to group other classifiers. We reused this association to express the fact that an SI (represented as <<MagicSaAmfSI>>) groups CSIs (represented as <<MagicSaAmfCSI>>). Consequently, as shown in Fig. 12
                           , we defined the stereotype <<groups>> to capture the relationship and map it to metaclass Association. Appendix B summarizes the stereotypes defined for the AMF relationships, their base metaclasses, and the relationship reused from the UML metamodel. More details can be found in [41].

This phase aims at ensuring that the UML stereotyped base metaclasses do not have attributes, associations, or constraints that conflict with the semantics of the domain model. If this is the case, UML itself needs to be restricted in order to match the domain related semantics and to guarantee the consistency of the profile with the semantics of the domain model. To this end, a set of constraints were defined. These constraints can be grouped into two different categories:

For example, the previously defined stereotype <<groups>> can be used only between specific AMF entities. However, UML has the capability of using associations between all sorts of UML elements, including the metaclasses Class, Component, and Node. Therefore, without any constraints it would be possible to use the <<groups>> relationship to group CSIs into an AMF application, which is semantically invalid with respect to the AMF domain. Consequently, different constraints have been defined and expressed in OCL to restrict the UML metamodel in the context of AMF. For instance, the following constraint restricts the UML metamodel to use the <<groups>> stereotype between component and SU:
                                 
                                    
                                 
                              
                           

Similar to the constraints on relationships, there is another group of constraints that should be taken into account. This group targets UML elements in order to restrict the UML metamodel. For example, based on the AMF domain model, components cannot inherit from other components. However, the UML metamodel allows designers to use inheritance between elements that are mapped to UML metaclass Component. Therefore, another set of constraints was required to restrict the standard UML elements according to what is allowed by AMF. We have defined and specified this set using OCL. The following constraint restricts the inheritance on components:
                                 
                                    
                                 
                              
                           

We implemented the extension to the UML metamodel in order to model AMF concepts in IBM Rational Software Architect (RSA) [9]. RSA is a UML 2.4.1 compliant integrated software development environment which supports UML extension capabilities and which is built on top of the Eclipse platform [6]. The combination of RSA and Eclipse Modeling Framework (EMF) [7] provides a powerful capability for integrating new domain concepts with UML in a single toolset. By using the visualization and metamodel integration services, RSA integrates different metamodels, allowing them to reference one another. Therefore, it facilitates the model-driven approach for generating, validating, and analyzing models [16].

Compared to other modeling tools, RSA provides its users with a quicker and simpler way of creating UML profiles in order to address domain-specific concerns [16]. In addition, since RSA's internal model representations are based on EMF metamodels, RSA allows users to visualize and integrate models and model elements from different domain formats. Therefore, RSA has a high degree of interoperability with other modeling tools [16].

Our choice of using RSA also lies in the conclusions of the study conducted by Amyot et al. [1]. The authors compare different UML integrated software development environments which support the design of UML profiles. This comparison is based on the capabilities of the tools such as integration with other tools and the effort required for defining a profile. RSA was found one of the most complete tools in its category. Fig. 13
                         shows the implementation of the UACL using RSA. UACL is primarily designed for the automation of the configuration generation process. In previous work, we have used the XML Metadata Interchange (XMI) format of the profile generated by RSA in a model driven configuration generation process. UACL has also been used for the validation of AMF configurations. Configuration design experts can also view, modify and manipulate the AMF configurations using our tool and benefit from RSA's validation engine [42,43].

Finally, it is worth noting that, based on the AMF standard specification, the configuration needs to be deployed on an SA Forum compliant middleware using an XML file following an Information Model Management (IMM) XML schema. In addition to the tool we have presented in this paper, we have developed a program to map the UACL models into the IMM XML [37] format.

In order to demonstrate its effectiveness, we used our framework to develop a configuration for an online banking system which allows customers to conduct financial transactions using a secure web interface. The features of this system include account transfers, balance inquiries, bill payments, and credit card applications. This case study does not focus on the process of generating the configuration, instead, it presents how a sample AMF configuration can be specified using UACL. In previous work [40], we presented a model-driven solution for the automatic generation of AMF configurations which uses UACL as a core metamodel. The online banking application was designed based on three tier architecture [44]. Fig. 14
                         presents the architecture of the online banking system. In this paper we focus on the design of an AMF configuration for the business tier of this system which consists of the following subsystems:
                           
                              •
                              The electronic billing service which allows clients to view and manage their invoices sent by e-mail. It also provides online money transfers from the client's account to a creditor's or vendor's account.

The authentication service which is responsible for confirming the identity of the clients.

The fund transfer module which provides four different categories of money transfer services:
                                    
                                       ◦
                                       Transferring money between the different accounts belonging to the same client (e.g. between saving and chequing accounts)

Performing money transfers from one client's account to another client's account(s) within the same banking institution

Performing money transfers from a client's account to an account held by a different banking institution

Transferring funds to the Visa account of a client

In this system the user interacts with the system through a web interface and the application layer is supported by an application server. For instance, the application server could be the Red Hat JBoss AS which is an open-source Java EE-based application server [33]. User requests are transferred to the server through Http and the responses are provided accordingly. The availability of the entire set of components in the application layer is managed by the AMF middleware. Moreover, we assume that the APIs required by the AMF middleware are implemented in the software modules and they are capable of supporting all redundancy models.


                        Figs. 15 and 16
                        
                         represent the entity type view of the FundTransfer part of the configuration. It consists of an SGType grouping the FundTransfer SUType, which provides the FundTransfer service type. The SUType consists of three different component types, namely VisaPayment, MoneyTransfer, and ExternalAccountManager. The first two provide the services for transferring funds to other bank accounts and visa accounts while the ExternalAcountManager is responsible for establishing the connection to the accounts to which the money will be transferred. For this purpose,

MoneyTransfer component type supports LocalMoneyTransfer and ExternalMoneyTransfer CSTypes for transferring the money to other bank accounts held within the same banking institution or in other institutions. The provision of these services depends on the provision of the LocalAccountCommunication and ExternalBankCommunication CSType by ExternalAccountManager. The VisaPayment also provides PayVisaBalance CSType which depends on the provision of the VisaAccountCommunication CSType by ExternalAccountManager. MoneyTransfer component type also provides the InternalMoneyTransfer CSType for transferring funds between the various accounts belonging to the same client (e.g. between savings and chequing accounts) which can be carried out independently.


                        Fig. 17
                         shows the entity type view of the Billing SUType grouped aggregated by BillingSGT. Billing SUType groups BillManager component type which provides ViewBill and PayBill CSTypes. Provision of the ViewBill CSType depends on the provision of the EPostService by EPostCommunication component type. The provision of the PayBill CSType is also sponsored by ExternalBankCommunication CSType which is provided by ExternalAccountManager component type (the same component type used in the fund transfer part). Notice that ExternalAccountManager and EPostCommunication component types are aggregated by Billing SUType as well.


                        Fig. 18
                         presents the entity type view of the authentication part of the online banking configuration which includes the Security SGType grouping Authentication SUType. Authentication SUType consists of one component type CertifiedAuthentication which provides CertifiedAuthenticationService CSType.


                        Fig. 19
                         represents the entity view of AMF configuration for the online banking application. FundTransfer service group (see Fig. 20
                        ) which supports N+M redundancy model groups three SUs from FundTransfer SUType, namely FT_Su1, FT_Su2, and FT_Su3. Each SU includes one component from MoneyTransfer, VisaPayment, and ExternalAccountManager component types. For instance, in FT_Su1 Trans_1, Visa_1, and ExtAccMng_1 are instances of the MoneyTransfer, VisaPayment, and ExternalAccountManager, respectively.

On the service side, LocalTransServ, VisaServ, and ExternalTransServ SIs are protected by FundTransfer SG. These SIs are instances of the FundTransferService SvcType. However, the CSIs grouped within each one of these SIs are not instances of the same CSTypes. This is possible since the minimum number of the CSIs of each one of the CSTypes in the SIs is zero due to the configuration properties of the FundTransferSevice SvcType and its CSTypes. It is worth noting that this property has been overridden from the description of the software entities provided by the vendor.

More specifically, LocalCom is an instance of the LocalAccountCommunication CSType and LocalTransfer is an instance LocalMoneyTransfer while VisaCom is an instance of the VisaAccountCommunication and PayVisa is an instance of the PayVisaBalance. Moreover, ExtTransfer and ExtCom_1 are instances of the ExternalMoneyTransfer and the ExternalBankCommunication CSTypes, respectively.


                        Fig. 21
                         shows the entity view of the billing part consists of an SG which protects BillingServ SI from the BillingService SvcType. This SG supports the 2N redundancy model and thus groups two identical SUs (BillingSu1 and BillingSu2) which are instances of the Billing SUType. Each SU includes one component of EPostCommunication, BillManager, and ExternalAccountManager component types. On the service side, the BillingServ SI groups EPost, BillView, BillPayment, and ExtCom_2 CSIs which are instances of the EPostService, ViewBill, PayBill, and ExternalBankCommunication CSTypes, respectively.


                        Fig. 22
                         presents the entity view of the security module of the online banking system which includes Security SG with the N-Way-Active redundancy model. This redundancy model aims at balancing the load of the authentication service on the protected SIs. Security SG includes two SUs, namely Sec_Su1 and Sec_Su2 from Authentication SUType. Each of these SUs aggregates one component of CertifiedAuthentication component type. On the service side, Security SG protects three identical SIs which are the instances of the AuthenticationService SvcType and each one has one CSI of the CertifiedAuthenticationService CSType.

It is worth noting that, since the entity and entity type views are presented separately in this paper, the relationship between each entity and its type entity is not visible in the diagrams. For instance, Fig. 23
                         presents the type relationship between the entities and entity types of the authentication module of the online banking system.

The configuration is deployed in a cluster called OnlineBanking_Cluster which consists of three AMF nodes (Node1, Node2, and Node3). Node1 is hosting Sec_Su1 and FT_Su1 while Node3 is hosting FT_Su3 and Billing_Su1. Sec_Su2, FT_Su2, and Billing_Su2 are hosted by Node3. Fig. 24
                         shows the deployment view of the AMF configuration designed for online banking application using UACL.

Finally, it is worth noting that RSA's live mode validation of OCL constraints ensures the validity of the designed configuration according to the standard specification. Live validation mode is not practical, however, for complex constraints involving various modeling elements, as it decreases the tool's level of performance. For this group of constraints, batch mode validation is the most preferable option. This results in the need to validate the entire configuration using RSA after having completed the design. In the occurrence of an error, RSA locates the error so that the designer can detect the cause and fix it.

After the analysis of the AMF domain and the design of the domain model, the first issue we faced was how to define the UACL language. Although a UML profile may result in a less precise language than a MOF-based language, we avoided a MOF-based solution as it would suffer from a lack of tool support. In general, the advantages of an UML profile seem to far outweigh its drawbacks [8]. The second issue was in deciding whether to extend existing profiles or to create a new one. We investigated existing profiles related to dependability and availability. We targeted both OMG standardized profiles, such as MARTE [24], SPT [19], and QoS&FT [22], as well as the non-standardized profiles reported in the literature, such as the DAM [4] profile and the profile presented by Szatmári et al. in [45]. The evaluation and analysis of these profiles were based on different criteria:
                        
                           1.
                           The capability of the profiles' constructs in capturing the concepts and semantics of the AMF domain and the complexity of extending these constructs when needed. The main goal of this extension is to take advantage of the profile features and reuse their constructs as much as possible. If the concepts of the AMF domain cannot be defined as a combination or extension of the basic constructs of the profile, the extension will be handled in the underlying UML metamodel. This outweighs the benefits of the extension. Most of the analyzed profiles turned out to be unsuitable. For example, the concept of service in the DAM profile addresses the description of the service itself, while in the AMF domain, the service is the description of attributes for the workload that will be assigned to service providers at run-time. In fact, there is a substantial distinction between the concept of service in DAM and in the AMF domain. Therefore, to capture this concept, we need to directly refer to the UML metamodel and not go through the DAM profile.

The implementation of the existing profiles. One of the goals of this work was to develop a CASE tool to support different activities, such as the design and validation of AMF configurations. In the case of extending existing profiles, we needed to have access to their implementation such as the XMI format that serializes the profile model. We found that the non-standard profiles do not provide open access to their implementation. The implementation is available for some of the standard OMG profiles (for instance, for MARTE). However, due to the characteristics of the AMF domain concepts, we could use only small fractions of these implementations. At the same time, building an extension requires importing and handling the whole implementation package. This may result in complexity at the tool development phase as well as performance issues at run-time. For instance, the run-time evaluation of newly defined constraints of the new language may require the evaluation of several constraints of the referred profile.

Because of the characteristics of the AMF domain and the fact that the required additional complexity does not justify the very few benefits of a possible extension, we decided to extend the UML metamodel instead of reusing another profile and adapting it to AMF.

The AMF specification defines the run-time behavior of the middleware with respect to the management of the AMF configurations. At the domain modeling stage, one of the most challenging issues was to capture only the configuration time aspects. In other words, we extracted the configuration time aspects of the configuration by analyzing the run-time behavior of the AMF. It was not straightforward to extract the domain model from the large standard document, as the domain model requires the isolation of the configuration time characteristics from the run-time characteristics of the AMF. More specifically, some of the concepts defined at run-time are based on other related configuration time constraints in order to ensure that the configured application will provide and protect the service independently from a particular AMF service implementation. This also increases the complexity of the domain model, both in the design of the class diagram and in the process of specifying the OCL constraints. For instance, SA Forum standards support the notion of proxied components — the components which need proxy components to interact with the AMF middleware. However, the links between a proxy component and its proxied components are established only at run-time when an AMF service implementation selects and assigns a particular proxy component to a particular proxied component. On the other hand, a configuration time relationship between a proxy and a proxied component is specified through the proxyCSI. This is a particular CSI through which a proxy component is assigned the task of “proxying” a particular proxied component. The concept of proxyCSI was captured in our model through the association end magicSaAmfCompProxyCSI of the association between MagicLocalProxiedComponent and MagicSaCSI classes as shown in Fig. 25
                     . In order to configure a certain proxy component for its proxied components, one can only use the proxyCSI. Therefore, the well-formedness of the configuration can be expressed and checked at configuration time to the extent allowed by the proxyCSI configuration attribute. At configuration time, we have to ensure that there is at least one proxy component capable of being the proxy component for the proxied component. This constraint translates to the existence of a proxy component that supports a component service type (CSType) to which the proxyCSI of the proxied component in question belongs. The OCL expression formalizing this domain constraint is as follows:
                        
                           
                        
                     
                  

Another challenge that we encountered was the identification of UML metaclasses for mapping purposes. More precisely, we had to identify the most appropriate UML metaclasses to extend in order to support the AMF domain concepts. To the best of our knowledge, there is no systematic approach to guide this process.

In addition, a complementary and important aspect needs to be taken into consideration: the tool support. We chose RSA because of its features. However, our experience with RSA also revealed some of its weaknesses when dealing with the implementation of OCL constraints. More specifically, to support the OCL functions that require access to stereotyped elements, RSA implements additional functions like getAppliedSubstereotypes() and isStereotypeApplied(). The main issue with these functions is that they are not compliant with the standard OCL specification and therefore, standard OCL constraints cannot directly be implemented in RSA. For instance, in the context of an entity, if we want to verify the stereotype as being set to <<MagicSaAmfLocalSU>>, we will need the following OCL constraint:
                        
                           
                        
                     
                  

As observed in the above example, additional type casting commands are required in order for the constraint to perform properly. Considering the fact that almost all of the constraints in the UML profiles deal with stereotypes, this drawback has a great impact on the readability of the OCL constraints and therefore, the maintainability of the tool.

Moreover, using tagged definitions in cross-context constraints is rather challenging. An example would be the specification of a typical OCL constraint in the context of one of the stereotypes associated with <<MagicSaAmfSU>> (e.g. <<MagicSaAmfComp>>) to restrict one of the attributes of <<MagicSaAmfSU>> — such as magicSaAmfSURank — so as not to have a value of zero. Despite its common occurrence, this constraint needs to be implemented using a complex expression such as:
                        
                           
                        
                     
                  

As presented above, accessing the attribute magicSaAmfSURank is only possible through a function called getValue() and through specifying the name of the stereotype and the tagged definition. In addition, at the end of the function we need to cast the type of the output of the function to uml::Integer.

One of the main limitations of UACL comes from its inherent complexity rooted in the intricate concepts and their relationships defined in the standard specifications. This complexity does pose limitations on the manual manipulation of the configurations and requires designers to possess a strong understanding of the language and its elements. This complexity can also hinder the maintainability of the profile. Since the main objective of UACL is to provide a modeling framework for the automatic generation of configurations, the complexity of the language has minimal consequences on the effectiveness of the language. This complexity does not affect the automatic configuration generation process.

The other limitation comes from the lack of formal processes to validate the language in order to ensure its compliance with the standard specifications. We have invested a great deal of effort in defining our profile by refining and reusing a generic process discussed in [43]. In addition, our work has undergone an intensive and effective review process with the domain expert and with a team of experienced software designers. However, the lack of a well-defined evaluation mechanism and metrics for (formally) evaluating our UML profiles seems to be a limitation that needs to be addressed in the future. The applicability and usefulness of UACL will be evaluated empirically over time. This will help us improve the profile, enhance the guidelines for defining a UML profile, and perhaps design an evaluation framework.

@&#CONCLUSION@&#

An AMF configuration is the artifact used by an implementation of the AMF middleware service for managing the high availability of services provided by applications under its control. In this paper we reported on the design of UACL, a UML profile for AMF Configurations, and its implementation using the IBM RSA toolkit. The profile has been defined as an extension to the UML2 metamodel. The definition consisted of 1) the analysis of the AMF configuration domain, capturing all the AMF domain concepts, 2) the definition of the concrete syntax of the language, and 3) the specification of the semantics through the mapping to the UML2 metamodel and the definition of constraints.

The experience, as discussed in Section 4, has shown that the most critical aspects of this process were 1) the domain analysis, like dropping the run-time attributes and classes from the domain model, which led to difficulties in specifying the related configuration concepts, such as the domain constraints necessary for the definition of AMF configurations, 2) the identification of metaclasses for mapping purposes, and 3) having adequate tool support. Due to the existing relationships at the level of the UML metaclasses, the selection of inappropriate base classes may result in the definition of a language that is not compliant with the UML semantics. UACL can support AMF configuration design, analysis and validation. Currently, it is being used with other models for the development of a model-based configuration generation approach [40].

@&#ACKNOWLEDGMENTS@&#

This work has been partially supported by the Natural Sciences and Engineering Research Council (NSERC) of Canada (grant number: NSERC IRCPJ 425135-10) and Ericsson.


                     
                        
                           Table 2
                           
                              The summary of the stereotypes defined for AMF entities and entity types.
                           
                           
                              
                              
                              
                              
                                 
                                    Stereotype
                                    Generalization
                                    Notation
                                 
                              
                              
                                 
                                    <<MagicSaAmfCompGlobalAttributes>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<SaAmfCompBaseType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    
                                       <<MagicSaAmfCompType >>
                                    
                                    <<SaAmfCompBaseType>>
                                    
                                 
                                 
                                    <<MagicAmfSaAwareCompType>>
                                    
                                       <<MagicSaAmfCompType>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfStandaloneSaAwareCompType >>
                                    <<MagicAmfSaAwareCompType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfProxyCompType>>
                                    <<MagicAmfStandaloneSaAwareCompType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfContainerCompType>>
                                    <<MagicAmfStandaloneSaAwareCompType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfContainer-ProxyCompType>>
                                    <<MagicAmfProxyCompType>><<MagicAmfContainerCompType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfProxiedCompType>>
                                    << MagicSaAmfCompType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfNon-ProxiedNon-SaAwareCompType>>
                                    << MagicSaAmfCompType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfHealthcheckType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<SaAmfSUBaseType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    
                                       <<MagicSaAmfSUType>>
                                    
                                    <<SaAmfSUBaseType>>
                                    
                                 
                                 
                                    <<MagicAmfLocalSUType>>
                                    
                                       <<MagicSaAmfSUType>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfExternalSUType>>
                                    
                                       <<MagicSaAmfSUType>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<SaAmfSGBaseType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfSGType>>
                                    <<SaAmfSGBaseType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<SaAmfAppBaseType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfAppType >>
                                    <<SaAmfAppBaseType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<SaAmfCSBaseType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfCSType>>
                                    <<SaAmfCSBaseType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<SaAmfSvcBaseType>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfSvcType>>
                                    <<SaAmfSvcBaseType>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    
                                       <<MagicSaAmfComp>>
                                    
                                    
                                       metaclass Component
                                    
                                    
                                 
                                 
                                    
                                       <<MagicAmfLocalComponent>>
                                    
                                    
                                       <<MagicSaAmfComp>>
                                    
                                    
                                 
                                 
                                    <<MagicAmfExternalComponent>>
                                    
                                       <<MagicSaAmfComp>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    
                                       <<MagicAmfSaAwareComponent>>
                                    
                                    
                                       <<MagicAmfLocalComponent>>
                                    
                                    
                                 
                                 
                                    
                                       <<MagicAmfNon-SaAwareComponent>>
                                    
                                    
                                       <<MagicAmfLocalComponent>>
                                    
                                    
                                 
                                 
                                    <<MagicAmfStandaloneSaAwareComponent>>
                                    
                                       <<MagicAmfSaAwareComponent>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfContainedComponent>>
                                    
                                       <<MagicAmfSaAwareComponent>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfLocalProxiedComponent>>
                                    
                                       <<MagicAmfNon-SaAwareComponent>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfNon-ProxiedNon-SaAwareComponent>>
                                    
                                       <<MagicAmfNon-SaAwareComponent>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfContainerComponent>>
                                    <<MagicAmfStandaloneSaAwareComponent>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfProxyComponent>>
                                    <<MagicAmfStandaloneSaAwareComponent>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfContainer-ProxyComponent>>
                                    <<MagicAmfContainerComponent>><<MagicAmfProxyComponent>>
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfHealthcheck>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    
                                       <<MagicSaAmfSU>>
                                    
                                    
                                       metaclass Component
                                    
                                    
                                 
                                 
                                    <<MagicAmfLocalServiceUnit>>
                                    
                                       <<MagicSaAmfSU>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfExternalServiceUnit>>
                                    
                                       <<MagicSaAmfSU>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    
                                       <<MagicSaAmfSG>>
                                    
                                    
                                       metaclass Component
                                    
                                    
                                 
                                 
                                    <<MagicAmfTwoNSG>>
                                    
                                       <<MagicSaAmfSG>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfNPlusMSG>>
                                    
                                       <<MagicSaAmfSG>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfNWaySG>>
                                    
                                       <<MagicSaAmfSG>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfNWayActiveSG>>
                                    
                                       <<MagicSaAmfSG>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfNoRedundancySG>>
                                    
                                       <<MagicSaAmfSG>>
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfApplication>>
                                    
                                       metaclass Component
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfCSI>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfSI>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicAmfCSIAttributeName>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfNode>>
                                    
                                       metaclass Node
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfNodeGroup>>
                                    
                                       metaclass Package
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaAmfCluster>>
                                    
                                       metaclass Package
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                                 
                                    <<MagicSaSmfSwBundle>>
                                    
                                       metaclass Class
                                    
                                    
                                       
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     
                        
                           Table 3
                           
                              Summary of stereotypes related to the relationships between domain concepts in AMF.
                           
                           
                              
                              
                              
                              
                                 
                                    Stereotype
                                    UML metaclass
                                    Reused relationship from UML metamodel
                                 
                              
                              
                                 
                                    <<groups>>
                                    
                                       metaclass Association
                                    
                                    nestedClassifier relationship between Class and ClassifierpackagedElement relationship between Componnet and Packageable Element
                                 
                                 
                                    <<protect>>
                                    
                                       metaclass Association
                                    
                                    nestedClassifier relationship between Class and Classifier
                                 
                                 
                                    <<provide>>
                                    
                                       metaclass Association
                                    
                                    nestedClassifier relationship between Class and Classifier
                                 
                                 
                                    <<type>>
                                    
                                       metaclass Association
                                    
                                    superClass relationship between Componnet and ClassReflective superClass relationship on Class
                                 
                                 
                                    <<membernode>>
                                    
                                       metaclass Dependency
                                    
                                    packagedElement relationship betweenPackageable Element and Package
                                 
                                 
                                    <<deploy>>
                                    
                                       metaclass Dependency
                                    
                                    packagedElement relationship betweenPackageable Element and Package
                                 
                                 
                                    <<MagicSaAmfSutCompType>>
                                    
                                       metaclass AssociationClass
                                    
                                    nestedClassifier relationship between Class and Classifier
                                 
                                 
                                    <<MagicSaAmfSvcTypeCSType>>
                                    
                                       metaclass AssociationClass
                                    
                                    packagedElement relationship between Componnet and Packageable Element.
                                 
                                 
                                    <<MagicSaAmfCtCSType>>
                                    
                                       metaclass AssociationClass
                                    
                                    nestedClassifier relationship between Class and Classifier
                                 
                                 
                                    <<MagicSaAmfCompCsType>>
                                    
                                       metaclass AssociationClass
                                    
                                    nestedClassifier relationship between Class and Classifier
                                 
                                 
                                    <<MagicSaAmfSIDependency>>
                                    
                                       AssociationClass
                                    
                                    nestedClassifier relationship between Class and Classifier inherited by AssociationClass
                                 
                              
                           
                        
                     
                  

@&#REFERENCES@&#

