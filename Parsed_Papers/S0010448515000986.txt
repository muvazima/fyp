@&#MAIN-TITLE@&#SURGEM: A solid modeling tool for planning and optimizing pediatric heart surgeries

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We describe solid modeling challenges faced while developing a surgery planning tool.


                        
                        
                           
                           We support three surgeries: (1) DORV, (2) Fontan procedure and (3) Stenosis repair.


                        
                        
                           
                           DORV and Stenosis repair procedures utilize a simple sketch based interface.


                        
                        
                           
                           For Fontan, the surgeon specifies endpoint locations by clicking.


                        
                        
                           
                           More direct and precise control allows quick exploration of number of surgical options.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Surgery planning

Triangle meshes

Surface intersection

Developable surfaces

Splitting solids

Hole filling

@&#ABSTRACT@&#


               
               
                  Approximately 1% of children are born with a moderate to severe congenital heart defect, and half of them undergo one or more surgeries to fix it. SURGEM, a solid modeling environment, is used to improve surgical outcome by allowing the surgeon to design the geometry for several possible surgical options before the operation and to evaluate their relative merits using computational fluid simulation. We describe here the solid modeling and graphical user interface challenges that we have encountered while developing support for three surgeries: (1) repair of double-outlet right ventricle, which adds a graft wall within the cardiac chambers to split the solid model of the unique ventricle, (2) the Fontan procedure, which routes a graft tube to connect the inferior vena cava to the pulmonary arteries, and (3) stenosis repair, which adds a stent to expand a constricted artery. We describe several solutions that we have developed to address these challenges and to improve the performance, reliability, and usability of SURGEM for these tasks.
               
            

@&#INTRODUCTION@&#

Approximately 1% of children born have a moderate to severe congenital heart defect (CHD)  [1]. More than half of these children undergo at least one invasive surgery in their lifetime  [2]. There are more than 40 different types of CHD, and many involve performing delicate changes to the geometry and topology of the cardiovascular structure. Often, the surgeon faces the problem of evaluating several topological options, such as whether one should implant a graft inside the heart or use an external baffle, compounded with the need to optimize the various geometric parameters such as the location and angle of the connection where a baffle is attached to an artery. The outcome of the surgery (probability of survival, quality of life, and chances of avoiding subsequent surgeries) depends significantly on these choices and optimizations. To assist the surgeon in these delicate surgical planning activities, we have developed an interactive solid modeling environment called SURGEM (short for SURGEry Modeler). It supports loading a detailed triangle mesh which is extracted from medical imaging, such as Cardiac Magnetic Resonance (CMR), and which represents the boundary of the solid model of the cavity of the patient’s heart and of the abutting vasculature. SURGEM lets the surgeon inspect this virtual model and modify its geometry and topology interactively using various input modalities, which include 3D input with a 6 DoF tracker in each hand or simply using a stylus to draw curves or drag points on a touch sensitive tablet (Fig. 1
                     ).

Finally, SURGEM allows the surgeon to export the resulting solid models for off-line Computational Fluid Dynamic (CFD) analysis. The results of this analysis can help the surgeon in selecting the optimal corrective option for the surgery and in understanding an option’s sensitivity to the variations of geometric parameters. This sensitivity analysis is important to predict the robustness of the course chosen and thus anticipate the consequences of the expected discrepancy between the planned model and the physical model that will inevitably result from the operation  [3].

Intuitive SURGEM tools for freely bending and twisting the boundary of the solid model without altering its connectivity have been described elsewhere  [4,5]. These were based on smooth space warps that the surgeon controls either directly though a different screw model controlled with each hand  [6] or with a virtual ribbon held at each end by a different hand  [4].

In this paper, we report on novel and more challenging tools that support designing and performing topological changes and that require more complex processing and optimization of the geometry.

Specifically, we describe, in geometric and algorithmic terms, the solid modeling and graphical user interface challenges that we have encountered while developing support for three specific types of heart surgeries:
                        
                           1.
                           The Double Outlet Right Ventricle (DORV) repair adds an internal graft wall (cut out from a developable baffle surface, i.e. a surface that can be flattened without stretching) to split the solid model of the unique ventricle into two solids and hence creates a bi-ventricular circulation.

The Fontan procedure adds a graft (tubular baffle, possibly with a bifurcation) to connect the inferior vena cava to the pulmonary arteries,

The Stenosis repair inserts a stent to expand a constricted artery into a tube of a circular cross-section of a chosen diameter.

The DORV intraventricular repair surgery targets children born with a heart where the two ventricular chambers and arterial outlets are not properly separated: all outlets from the heart arise from the right ventricle. Throughout the paper, we use the term ventricle to refer to the solid model bounded by the interior surface of the heart. The objective of the repair is to recreate the normal partitioning of the two ventricular chambers (which we will refer to as the RV (right ventricle) and LV (left ventricle)) and the great arteries so as to restore proper routing of blood flow. This might be accomplished, for example, by placing a Teflon (PTFE) baffle inside the ventricle and by suturing it to boundary surface along a suture loop to direct blood from the LV to the aorta. Fig. 2
                         shows a typical configuration before surgery (left) with a unique ventricle and after surgery (right) where the heart has been split in two parts (RV and LV) by the inserted baffle.

While editing the geometry and position of the baffle, the surgeon wishes to achieve the following objectives: (1) Minimize the difference between the volumes of the solid models of the LV and RV models created by the surgery. (2) Ensure that the shape of the baffle and the tracing of the suture loop are not conflicting with any physical constraints or surgical practices.

We designed the DORV intraventricular repair planning interface to make the specification of the baffle easy and to quickly provide feedback on the volumes of the LV and RV resulting from the split.

From a usability perspective, we want to satisfy the following goals: (1) Provide a visualization environment that is simple to operate and allows the surgeon to control the view and clearly see the boundary of the RV along with the suture loop drawn on it, (2) Provide a straightforward to learn, natural to use, and effective paradigm through which the surgeon can quickly design and then carefully adjust the shape of the baffle, and (3) Provide real-time visual feedback to guide these careful adjustments.

From a solid modeling perspective, our challenges are: (1) To ensure that the shape of the baffle is a developable surface, because, while the PTFE material used for the baffle is slightly stretchable in one direction, we want the baffle to be designed in a rest state, so as to avoid imposing unnecessary forces on the wall of the heart. and (2) To obtain valid solid models of the LV and RV, so as to support the computation of their volumes, meshing, and CFD analysis.

Our initial approach was to enable to surgeon to manipulate an untrimmed baffle surface directly (using a variation of  [7–9]) in 3D and then to compute the suture loop automatically as the intersection curve between the untrimmed baffle surface and the interior surface of the RV. That approach was motivated by the following anticipated advantages: (1) We can program a model of the baffle surface that allows bending while ensuring developability and (2) We can leverage the two-handed SURGEM interface with 6 DoF trackers  [4] to support direct manipulation of the untrimmed baffle.

Unfortunately, this approach has several drawbacks: (1) Reliance on 3D input devices is a hindrance, because these are fragile and not commonly available, (2) Precise direct manipulation of the shape and placement of the curved baffle surface in 3D is difficult, and (3) The surgeon needs an intuitive tool for designing the precise path of the suture curve on the heart. For example, Fig. 3
                         shows two different baffles for the same suture loop.

Based on user feedback and experimentation with the early attempts described above, we have opted for a sketch-based solution, described below, in which the surgeon can actually draw the loop directly on the heart surface and then adjust that loop locally as desired or adjust the shape of the baffle surface that is bounded by that loop. It makes the specification of the baffle shape almost as easy as drawing the projection of the suture loop on paper over a suitably aligned image of the heart.

In a typical scenario of this new solution, the surgeon loads a triangle mesh 
                           M
                         that represents the boundary of the ventricle and of the abutting vasculature, rotates the model to obtain a suitable view of the ventricle. Then, using a stylus, the surgeon draws (on a touch screen or tablet) a curved stroke that cuts twice (forth and back) through the screen projection of the portion of the ventricle to indicate where the border of the baffle will be sutured to the boundary of the ventricle.

The stroke is planar. Hence, to compute the 3D geometry of the suture loop, we need to project it back from the screen onto the boundary of the ventricle.

This suture loop does not define a unique developable surface.

We exploit this freedom and provide the surgeon with additional control over the shape of the baffle. Specifically, we define a one-parameter family of developable surfaces that interpolate the suture loop. Intuitively, each one corresponds to a different orientation of the lines (see Fig. 2) of the developable surface. We let the surgeon select the desired member of that family by specifying a seed point on the suture loop. Dragging that point along the suture loop rotates the orientation of the lines and hence provides an intuitive interface for adjusting the shape of the baffle. Real-time graphic feedback supports the direct manipulation interface of this design phase.

Starting from the seed point, we construct a developable surface that fills the “hole” defined by the loop. We represent this surface as a triangle strip, which we merge with the triangle mesh of the ventricle to compute the boundaries of the LV and RV solids.

Then, the surgeon can change the view to inspect the suture loop 
                           L
                         or the baffle surface 
                           S
                         (from different angles and also from the inside of the RV) and can adjust the shape of the suture loop locally by pointing (with the stylus) and dragging a portion of it along the surface of the ventricle or further adjust the shape of the baffle surface.

We also compute and display the 2D drawing of the boundary of the flattened baffle that should be cut from PTFE (Fig. 4
                        ). We highlight three color-coded points on the suture loop in the 2D and 3D views (see Fig. 2) to show correspondence, which helps the surgeon to align the baffle correctly during surgery.

This solution has several advantages: (1) It appears to the surgeon as a natural extension of the traditional surgery planning work flow where the surgeon draws on images of the patient’s anatomy, (2) It makes it possible to produce an initial model of the suture curve in seconds, (3) It supports precise and local editing of the suture loop via a natural pick-and-drag paradigm, (4) It automatically creates the baffle surface and ensure its developability, and (5) It supports some degree of editing of the shape of the baffle for a fixed suture loop.

To support this approach, we must decide how to: (1) Render the surgeon’s current view with perceptual cues that facilitate understanding and help in deciding how to place the suture loop on the surface of the mesh, (2) Draw the suture loop 
                           L
                         around the ventricle from a single view, (3) Support in realtime local point-and-drag operations that deform 
                           L
                         while keeping it on the surface of the RV, (4) Compute a developable surface 
                           S
                         that has 
                           L
                         as its border loop, (5) Let the surgeon control the shape of 
                           S
                         while keeping it developable and bounded by 
                           L
                        , (6) Split the ventricle surface along 
                           L
                        , (7) Quickly reconstruct the water tight triangle meshes that approximate the boundaries of the LV and RV and (9) Compute their volumes.

We describe below our solutions to these challenges.

To facilitate view manipulation, we allow the surgeon to pick a fixed point 
                           P
                         on the mesh 
                           M
                        . We have implemented this by using a z-buffer pick, which returns the visible surface point 
                           P
                         that projects onto stylus. Then, the surgeon can freely rotate the view around 
                           P
                         or advance towards it, while preserving the projection of 
                           P
                         on the screen.

We separate the mesh 
                           M
                         into its front-facing part 
                           
                              
                                 M
                              
                              
                                 F
                              
                           
                         and its back-facing part 
                           
                              
                                 M
                              
                              
                                 B
                              
                           
                        . To reveal the hidden structure of the ventricle surface, we display 
                           
                              
                                 M
                              
                              
                                 B
                              
                           
                         first, then display 
                           
                              
                                 M
                              
                              
                                 F
                              
                           
                         as semitransparent. Furthermore, we overlay a wire frame display of all silhouette edges, but display them using two different styles, so as to distinguish the visible ones from the hidden ones  [10]. The surgeon can inspect the RV surface and the suture curve from the outside and from the inside. Fig. 3 is an example of the visualization capabilities of SURGEM.

In this subsection, we explain how we have implemented the computation of a suture loop from a single stroke drawn on the screen to define its perspective projection.

Our approach was inspired by the GUI used in the “Teddy” drawing tool  [11], where a single stroke drawn by the artist defines a cut-surface that splits a solid model in two parts and removes one of them. We depart from that prior art in several ways: (1) We allow the surgeon to define the front and back portions of the suture loop independently and (2) We use a different approach to compute the water tight model of the two solid parts of the split RV.

Before drawing the suture curve, the surgeon orients the model so as to satisfy several constraints: (1) The target portion of the ventricle where the suture curve will be drawn is not hidden by any other part of the surface, (2) The suture curve to be drawn on the back of that part is not obstructed by any internal feature, and (3) The silhouettes on each side of the target portion are separating it from the background (see Fig. 3).

The surgeon starts the stroke near a silhouette, draws the forward part of the suture loop, stops near the silhouette on the other side, continues in the reverse direction to draw the backward part, and stops near the starting point. By convention, the forward (resp. backward) part is assumed to be the projection of portion of the suture loop that lies on the front (resp. back) part of 
                           M
                        .

We use the following approach to compute the suture loop: (1) We sample the stroke uniformly. (2) We split it into two runs (forward and backward) at the sample furthest from the starting point, (3) We back-project the forward (resp. backward) run samples onto the front (resp. back) part of 
                           M
                        , (4) We append the corresponding 3D points as vertices to the suture loop.

The above solution may fail when the suture loop is partly occluded (i.e., when the stroke overlaps with projections of overhangs of the front or back portions of 
                           M
                        ). In such situations, we start with the first point of the forward part of the stroke, and back-project it onto the visible front part of 
                           M
                        . We assume that the resulting point 
                           P
                         lies on the front part of the suture curve. Then, we start at 
                           P
                         and trace a loop of the intersection of 
                           M
                         with the pencil of rays from the viewpoint that pass through the stroke. This process yields the front portion of the suture loop. We then start with the first point of the backward part of the stroke. We know that it must be on the back part of 
                           M
                        , but it may not be the front most of these candidates, because the front most may lie on an overhang. So, we consider them one by one in depth order. For each one, we trace the back loop. We keep the trace that ends the closest to the starting point of the front part.

The back-projection may be obtained by shooting a ray through the stroke sample and computing its intersection with 
                           M
                        . For very complex meshes, we advocate using the GPU and either using multiple passes and a stencil counter per pixel to generate all the depth layers  [12,13] or using a depth-interval buffer  [14].

This solution allows the surgeon to draw the entire suture loop, both on the front and back surface of the ventricle, in a single stroke and from a single viewpoint. This flexibility is often important because the surgeon knows precisely where the suture loop must pass. Where it is not important to distinguish the front and the back tracings, we have provided an option where the surgeon draws only the first part of the stroke. The second part is created automatically by walking on the stroke backwards.

The surgeon may want to modify the suture loop, instead of redrawing it. To support this, we formulate the suture loop as an interpolating subdivision curve in 3D defined by a set of control points, which we extract via quasi-uniformly spaced sampling. We use a fast implementation  [15] of J-spline  [16] subdivision to draw the loop.

The surgeon can click near a control point and drag it to a new location on 
                           M
                        . We use back-projection for picking the control point is closest to the visible surface point that projects on the stylus and the for dragging it on the visible part of 
                           M
                        . These edits can be done either from the inside of the ventricle or from the outside. For situations where a control point does not lie on a visible portion of the surface, we also provide key-press controls for accessing adjacent control points. As the user is dragging a control point, graphic feedback is provided by updating the suture loop in real-time.

Given a polygonal suture loop 
                           L
                         our challenge is to compute a developable surface that fills the hole defined by 
                           L
                        .

The automatic generation of an optimal developable surface that interpolates a given bounding loop has been investigated in to support design in architecture and apparel  [17]. The problem of finding a valid (i.e., not self-crossing) triangulation of a polygonal loop is a challenging 3D extension of the problem of triangulating a 2D polygon  [18,19]. The related problem of finding a triangulation that interpolates two boundary loops in 3D was studied  [20] in the context of interpolating stacks of cross-sections recovered from medical scans. Some of the solutions were formulated in terms of a minimization of total area.

Here we are not interested in minimizing the area, but instead want to offer the surgeon some control over the shape of the baffle (
                           S
                        ) that could be used to adjust the ratios between the volumes of the LV and RV formed by its insertion. This degree of freedom will allow the surgeon to reduce the difference between the volumes of the two solids. We build the triangle mesh model of 
                           S
                         that is a generalized triangle strip with the first vertex at 
                           P
                        .

Given a suture loop, we construct the baffle surface as a triangle strip, that starts at the user-defined point 
                           P
                         on the loop. We add an isosceles triangle with apex at 
                           P
                        . We then add pairs of triangles by forming quadrilaterals with two equal length edges on opposite sides of the loop and one edge shared with the previous triangle or quad. We split each quadrilateral into a pair of triangles ensuring that the surface is developable, and thus can be fabricated from a planar material. Note that our simple solution can lead to self-intersections in 3D and may also produce a flattened cutout that has self-intersections. However, the suture-loop created by surgeons is typically simple, so the above described procedure works well in practice.

The 2D drawing of the suture loop is accomplished by unrolling (i.e., flattening) the triangle strip one triangle at a time (Fig. 5
                        ). Note that its shape depends on the placement of point 
                           P
                         on the suture loop.

We want to divide 
                           M
                         along the border 
                           B
                         of the triangulation of the baffle 
                           S
                         and construct two watertight meshes by merging one copy of the triangle strip of 
                           S
                         with the LV mesh and the other with the RV mesh. Since 
                           B
                         does not lie on 
                           M
                        , we could split 
                           M
                         along the closest projection of 
                           B
                         onto 
                           M
                        . However, this approach generates many small “sliver” triangles and is prone to problems of numeric precision.

Instead, we simply identify an annulus of the triangles of 
                           M
                         that are stabbed by that projection and mark them as inactive. To do so, we identify the triangles of 
                           M
                         where regularly spaced samples on 
                           B
                         project. If two consecutive samples on 
                           B
                         do not fall on the same triangle or on two edge-adjacent triangles, we identify an edge-adjacent triangle strip that connects these two triangles and also mark them as inactive. We use the shortest path in the dual graph of 
                           M
                         to identify that strip.

If the set of inactive triangles forms an annulus with two manifold bounding loops, we stop. Otherwise, we identify non-manifold vertices of the border of the set of inactive triangles and mark as inactive their incident triangles, until the above condition is satisfied.

We assemble the triangle meshes for LV from 3 sets of triangles: (1) A connected set 
                           L
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                         of the active triangles of 
                           M
                        , (2) a copy 
                           L
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                         of the triangulation of 
                           S
                        , and (3) a set 
                           L
                           
                              
                                 V
                              
                              
                                 3
                              
                           
                         of new triangles that form an annulus interpolating the gap between the borders of 
                           L
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                         and of 
                           L
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                        .

We ensure that the orientation of the triangles of 
                           L
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                         is compatible with those of 
                           L
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                        . To construct 
                           L
                           
                              
                                 V
                              
                              
                                 3
                              
                           
                        , we pick the pair of vertices, one on each loop, that minimize the distance between them.

We initialize the active edge to be the edge between these vertices. We add triangles one at a time. Each new triangle shares an edge with the previous one and has one edge on a boundary loop. We stop when we have closed the annulus.

To improve the quality of the triangulation, we use a dynamic programming approach to minimize the sum of the edge lengths connecting the two loops.

Following  [20,21], we explored other optimization objectives, such as minimizing surface area or triangle aspect ratios, but found that the edge length objective provided the most reliable results.

The asymptotic cost of computing the optimal triangulation with dynamic programming is dominated by the construction of the 
                           n
                         by 
                           m
                         cost matrix 
                           C
                        , where 
                           n
                         and 
                           m
                         are the lengths of the boundary loops.

The entries of the cost matrix are given by: 
                           
                              (1)
                              
                                 
                                    
                                       C
                                    
                                    
                                       i
                                       ,
                                       j
                                    
                                 
                                 =
                                 min
                                 
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          i
                                          −
                                          1
                                          ,
                                          j
                                       
                                    
                                    ,
                                    
                                       
                                          C
                                       
                                       
                                          i
                                          ,
                                          j
                                          −
                                          1
                                       
                                    
                                    )
                                 
                                 +
                                 
                                    ‖
                                    
                                       
                                          e
                                       
                                       
                                          i
                                          j
                                       
                                    
                                    ‖
                                 
                              
                           
                         where 
                           
                              
                                 C
                              
                              
                                 i
                                 ,
                                 j
                              
                           
                           =
                           ∞
                         for any 
                           i
                           ≤
                           0
                         or 
                           j
                           ≤
                           0
                        . After computing this matrix we construct the triangles by walking backwards through the cost matrix starting at 
                           
                              
                                 C
                              
                              
                                 n
                                 ,
                                 m
                              
                           
                         and adding a triangle with an edge on the first loop if 
                           
                              
                                 C
                              
                              
                                 i
                                 −
                                 1
                                 ,
                                 j
                              
                           
                           <
                           
                              
                                 C
                              
                              
                                 i
                                 ,
                                 j
                                 −
                                 1
                              
                           
                         and adding a triangle with an edge on the second loop otherwise.

To construct the triangle mesh for the RV, we use: (1) the other connected set 
                           R
                           
                              
                                 V
                              
                              
                                 1
                              
                           
                         of the active triangles of 
                           M
                        , (2) the other copy 
                           R
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                         of the triangulation of 
                           S
                        , in which the triangles have the reverse orientation from those active in 
                           L
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                        , and (3) an annulus 
                           R
                           
                              
                                 V
                              
                              
                                 3
                              
                           
                         of new triangles computed as explained above.

The result is an assembly of two solids, LV and RV, that touch along a common set of faces of 
                           S
                        .

We use the Corner Table representation  [22] for 
                           M
                        , which assigns consecutive integers to the vertices and to the triangles and which stores the vertex locations in the geometry array G and the connectivity of the triangulations in two arrays, V and O, that define, for each triangle, the integer IDs of its vertices and the integer IDs of opposite corners in the three edge-adjacent triangles.

We do not create separate representation for the meshes of LV and RV. Instead, we modify 
                           M
                         as follows. We do not delete the inactive triangles from 
                           M
                        , but only mark them as inactive. We append the connectivity of the triangles of 
                           L
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                           ,
                           
                           L
                           
                              
                                 V
                              
                              
                                 3
                              
                           
                           ,
                           
                           R
                           
                              
                                 V
                              
                              
                                 2
                              
                           
                        , and 
                           R
                           
                              
                                 V
                              
                              
                                 3
                              
                           
                         to table V, but not O. Hence, to undo these modification and restore the original version of 
                           M
                        , we only need to mark as active all the inactive triangles and to restore the original triangle count.

After triangulating the boundary loops between the heart and baffle for both the LV and RV meshes, we have two watertight meshes. We compute the volume of these meshes by summing the signed volumes of tetrahedra constructed by connecting each triangle in the mesh with an arbitrary center point  [23].

The Fontan surgery is used for children born with a single ventricle. It establishes a conduit that connects blood flow from the systemic veins, specifically the inferior vena cava (IVC), to the pulmonary arteries (PA) to bypass the heart where the second ventricular chamber would be. This connection, in combination with a bi-directional Glenn anastomosis (BDG) connecting the superior vena cava (SVC) to the PA, is commonly referred to as a total cavopulmonary connection (TCPC).

Even with this surgery, patients with a single ventricle have generally poor long-term life expectancy with numerous possible health complications. Research suggests that there are several characteristics of blood flow through the TCPC that can be optimized to reduce or even mitigate the risk for some of these complications. For example, the hemodynamic power loss across the TCPC has been linked with reduced exercise capacity  [24]. Furthermore, the unbalanced distribution of blood flow from the liver (“hepatic blood”) to the lungs has been shown to increase the risk of pulmonary arteriovenous malformations  [25]. Depending on the patient’s specific scenario, our goal with SURGEM is to help the surgeon design a surgical option that: (1) directs hepatic blood flow evenly to both lungs, and (2) minimizes power loss across the TCPC.

The primary design parameters the we can control are the location and angle of the graft’s attachments to the IVC and PA. To evaluate the effects of these design choices on (1) and (2), we use an in-house immerse boundary solver  [26]. Simulating complex cardiovascular anatomy takes significant computational power, so instead of optimizing the Fontan geometry with a completely automated, closed-loop system, we provide an interactive interface through which a surgeon or clinician specifies several alternative geometries that are later evaluated offline.

Finally, while the standard approach to Fontan surgery and the TCPC is to insert a tubular PTFE graft running from the IVC to the PA, an additional benefit of SURGEM is to provide a platform for virtual hypothesis testing. For example, in an effort to improve hemodynamic outcomes, some surgeons are now transitioning from using tubular grafts to using Y-shaped grafts that branch before arriving at the PA  [27]. Such efforts have been greatly facilitated and continue to be explored, thanks to the new capabilities provided by SURGEM, which illustrates its utility.

To explore different alternatives for Fontan grafts, we allow the surgeon to specify the tube endpoint locations by clicking on the surface of the 3D vessels. To specify the angle of attachment between the center-line of the graft and the surface of the attached vessel, we provide a widget that allows the surgeon to specify a unit vector by dragging a point in 2D that we then project onto the hemisphere above the attachment point on the surface. By default, the centerline is orthogonal to the surface at its endpoints.

To provide additional control of the shape of the graft, we place a control point in free space through which the center-line of the graft is constrained to pass. For the Y-shaped graft, we provide another point in free space at which the Y begins to bifurcate. Thus for the unbranched graft the surgeon specifies three points and two attachment directions, and for the Y-graft the surgeon specifies five points (three attachments and two free space points) and three attachment directions.

To aid the surgeon in exploring the robustness of a given surgical option with respect to the actual implementation, we provide a tool for creating automatically a prescribed number of parametric variations within a prescribed range around a specified Fontan graft.

This tool constructs a grid of points near each specified attachment point and a grid of attachment direction at each attachment point. It then constructs a graft for each combination of these alternative points and angles. The surgeon can configure the spacing of this grid and the number of samples generated and can visualize the center-lines of these alternatives grafts from within SURGEM (Fig. 6
                        ).

Our computational goal in the Fontan mode is to allow the surgeon to easily specify the graft geometry, and to output a watertight mesh that combines the original pre-operative vessel mesh with the inserted graft mesh.

We compute the location 
                              P
                            of the endpoint of the graft centerline from a stylus click by back-projecting the stylus location onto the mesh 
                              M
                           , as described in Section  2.4.

To let the surgeon edit the attachment direction, we use a plane that is tangent to 
                              M
                            at 
                              P
                           . Our widget back-projects the stylus location onto that plane and then back-projects the result orthogonally to that plane onto a sphere centered at 
                              P
                           .

We compute the shape of the Fontan graft by sweeping a circular cross-section along a centerline curve.

The centerline is a quartic polynomial curve 
                              C
                              
                                 (
                                 t
                                 )
                              
                            constrained by 3 positions and 2 tangents. For the unbranched graft we have 3 positional constraints (
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    p
                                 
                                 
                                    2
                                 
                              
                            at the ends and 
                              
                                 
                                    p
                                 
                                 
                                    m
                                 
                              
                            in the middle) and two 2 constraints (
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    2
                                 
                              
                           ), defined by: 
                              
                                 (2)
                                 
                                    C
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    
                                       [
                                       
                                          
                                             t
                                          
                                          
                                             4
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             3
                                          
                                       
                                       
                                       
                                          
                                             t
                                          
                                          
                                             2
                                          
                                       
                                       
                                       t
                                       
                                       1
                                       ]
                                    
                                    
                                       [
                                       
                                          
                                             
                                                −
                                                8
                                             
                                             
                                                −
                                                2
                                             
                                             
                                                16
                                             
                                             
                                                −
                                                8
                                             
                                             
                                                2
                                             
                                          
                                          
                                             
                                                18
                                             
                                             
                                                5
                                             
                                             
                                                −
                                                32
                                             
                                             
                                                14
                                             
                                             
                                                −
                                                3
                                             
                                          
                                          
                                             
                                                −
                                                11
                                             
                                             
                                                −
                                                4
                                             
                                             
                                                16
                                             
                                             
                                                −
                                                5
                                             
                                             
                                                1
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                          
                                          
                                             
                                                1
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                             
                                                0
                                             
                                          
                                       
                                       ]
                                    
                                    
                                       [
                                       
                                          
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      m
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      t
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                       ]
                                    
                                    .
                                 
                              
                           
                        

To compute the graft surface, we construct a series of circular cross-sections spaced evenly along the center-line. We compute the curve tangent 
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                            at curve vertex 
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                            by central differences: 
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    c
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              −
                              
                                 
                                    c
                                 
                                 
                                    i
                                    −
                                    1
                                 
                              
                           . The tangent 
                              
                                 
                                    t
                                 
                                 
                                    i
                                 
                              
                            is used as the normal to the cross-sectional plane at 
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                            (see Fig. 7
                           ).

To prevent twisting of the graft, we advect a tangent frame along the curve using parallel transport  [28,29].

We build the graft surface from quads joining consecutive cross-sections, triangulate these quads, assemble them into a manifold mesh, and then merge the graft surface with the pre-operative vessel surface as explained below.

We also support a branched Y-graft (Fig. 8
                           ) with the wide branch connected to the IVC and two narrow branches connected to the PA.

Though it seems more logical to make the cross-sectional area, 
                              
                                 
                                    a
                                 
                                 
                                    w
                                 
                              
                           , of the wide branch to equal the sum, 
                              
                                 
                                    a
                                 
                                 
                                    n
                                    1
                                 
                              
                              +
                              
                                 
                                    a
                                 
                                 
                                    n
                                    2
                                 
                              
                           , of the cross-sectional areas of the narrow branches, all commercially available grafts set the narrow branch diameter to half of the wide branch diameter. Therefore, for compatibility with the available grafts, we use this ratio in our construction.

We represent the centerlines of the three branches as smoothly joined polynomial curves (a quartic for the wide branch, which has an additional control point, and cubics for the narrow ones).

We construct the graft surface for the wide and narrow branches as described in Section  3.2.2, putting twice more samples along the circular cross-sections of the wide branch than of the narrow ones.

To construct the surface that connects the circular border of the wide branch to the two smaller borders of the narrow branches, we conceive a morph in the moving cross-sectional plane between the corresponding polygons and use frames of that morph at corresponding cross-sections.

To compute the morph, we establish correspondence between vertices and use linear LERPS between corresponding vertices, placing the topological change mid-course. Then, we rescale each cross-section to ensure linear evolution of the cross-section area.

We compute a watertight mesh that combines the heart vessels and the graft. It will be used to support flow simulation.

To do so, one could put caps (triangulated disks) at the ends of the graft to turn it into a water-tight mesh and then compute the boundary of the union of the two solids (heart and graft) (Fig. 8 right). Doing so typically introduces many small triangles along the intersection curve. These result from triangulating portions of the original triangles that have been trimmed by the union.

Because geometric fidelity near the intersection curve is not important, we use a fast merging procedure that produces a boundary that approximates the one produced by the union. Our approach takes advantage of the fact that near the intersection curves between the two meshes, the graft has a tubular shape and that the surfaces of the heart, IVC, and PA are relatively smooth in the vicinity of the intersection curve.

Near each end of the graft, our merging method performs the following steps. First, it removes vertices from the heart vessel mesh that are contained within the final cylindrical section of the graft, then removes vertices of the graft mesh that are within the original heart vessel mesh. We remove all triangles incident on these vertices. We keep track of the set of remaining vertices incident on the removed triangles. These vertices form a boundary loop on the heart vessel mesh and a boundary loop on the graft mesh. We add new triangles to bridge the two boundary loops using the method described in Section  2.7.

We perform these steps along each attachment between the graft and heart vessel meshes: twice for an unbranched graft and thrice for a branched graft.

The geometry created in a virtual surgery will always differ, if only slightly, from the real post-operative geometry. Therefore it is important that the proposed surgical plan be robust to small geometric variations  [3]. To inform the surgeon about the effects that variations in the geometry of the graft will produce on the blood flow through the resulting model, we provide an interactive, graphical tool for designing a controlled set of variations on the position and attachment angles of the graft.

To produce a set of slight variations of the attachment location, we construct the plane tangent to an attachment point and sample it with a uniform grid. We then project each sample point onto its nearest point on the surface of the heart. These becomes the new attachment locations, from which we construct a new centerline and graft surface. The spacing and number of samples are both configurable by the surgeon.

To produce a set of slight variations of the attachment direction at each sample, we use the parametrization defined in Section  3.2.1.

These produce a sampling of the four-dimensional space of graft variations. For each sample of that space, we produce a mesh and submit it to CFD analysis.

Results of the analysis are then processed to identify which combinations of angles and positions produce the best geometry (measured using power loss) and also the sensitivity of that measure to local variations of the parameters. The surgeon uses these analysis results when planning the details of the surgery.

Arterial stenosis is a common complication in congenital heart disease. It leads to elevated blood pressure and vascular resistance and potentially unbalanced pulmonary flow (in the case of pulmonary arterial stenosis). Intravascular stents are commonly used to alleviate these effects. The surgeon or catheterization doctor inserts the stent via a catheter at the location of the stenosis. The key surgical planning questions for stenosis repair are: Where should the stent be placed, and how wide and long should the stent be?

In the interface for planning a stenosis repair, the surgeon specifies a vessel to repair by drawing a curve roughly parallel to an imagined centerline of the vessel where the stenosis has occurred. We trace the actual portion of the centerline of the vessel that projects close to the drawn curve segment. We construct a cylindrical stent geometry that starts where the surgeon began drawing and ends where he or she stopped drawing. We automatically compute a stent diameter to match the diameter of the non-stenotic portion of the vessel. Finally, we virtually insert the stent into the surface mesh of the vessel and visualize the result. Before and after results are shown in Fig. 9
                         The resulting mesh can be exported for CFD analysis.

To trace the actual centerline of the vessel, we proceed as follows. We project the curve drawn by the surgeon onto the front-facing triangles of the mesh to produce a polygonalized 3D curve. We use parallel transport to compute a twist-free series of frames at each vertex of that curve, as discussed in Section  3.2.2. For each vertex 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         on that curve, we intersect the vessel mesh with the cross-section plane, ensuring that this intersection is a single connected component. We compute the centroid of the intersection region, and record a displacement vector from 
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                         to that centroid. Once we have computed all such displacement vectors, we use them to snap the curve to the centerline. To improve the smoothness of this approximation model of the centerline, we apply a Laplacian smoothing to the polyline. We improve the result, we repeat these steps: (1) smoothing, (2) reference frame computation, and (3) computation of intersection curves.

We clip the result to the portion that has a normal projection onto the drawn stroke.

To compute the radius of the stent, we use the smallest of the distances from the end-points of the centerline to the corresponding intersection curve.

We use the centerline and radius 
                           r
                         of the stent, computed as explained in the preceding sections, to inflate locally the nearby portion of the mesh so as to simulate the effect of introducing the stent.

We identify the portion of the mesh 
                           M
                         that is along the vessel affected by the operation. To do so, we use proximity with the original curve drawn on the surface of the vessel by the surgeon.

For each vertex 
                           V
                         of that portion, we compute its closest projection 
                           P
                         on the centerline of the stent, compute the target position 
                           
                              
                                 V
                              
                              
                                 ′
                              
                           
                         obtained by snapping 
                           V
                         onto the sphere of center 
                           P
                         and radius 
                           r
                        , and move 
                           V
                         to 
                           V
                           +
                           d
                           V
                           
                              
                                 V
                              
                              
                                 ′
                              
                           
                        , where 
                           d
                         decays as 
                           P
                         approaches the endpoint of the centerline.

To increase smoothness of the resulting surface, we perform several iterations, alternating the above snapping process with the process of recomputing and smoothing the centerline.

The SURGEM tool presented in this manuscript has been used so far in over 30 surgical planning cases for single ventricle and double outlet congenital heart diseases. It provides natural and effective user interactions for orienting the part, for specifying the suture curve, for designing a tubular junction, and for specifying the position of the stent.

The desired view orientation is achieved in a few seconds by (a) clicking on a surface point of interest (PoI) to apply a translation that brings it to the center of the screen, (b) dragging the mouse or stylus to rotate the model around the PoI, and (c) dragging the stylus to zoom on the PoI.

Creating an initial shape for each one of the three surgeries takes only a few seconds: (a) Drawing the initial suture curve with a stylus takes typically less than five seconds. The baffle defined by the suture curve may be inspected immediately by using pull-down menus to hide/reveal one or the other ventricle formed by the insertion of the baffle. (b) The initial shape of a tubular connection is defined by simply clicking on two surface points to locate the endpoints of its centerline, which by default is constructed to be orthogonal to the surface at these endpoints. (c) The initial centerline for a stent can be defined in about two seconds by simply drawing its projection on the screen. The new surface produced by our geometric heuristic is displayed immediately.

Although typically these initial shapes appear acceptable to a novice user, they may not correspond exactly to what the surgeon has in mind. Sometimes, it is easiest to discard that initial shape and simply redraw another version. But in some cases, it is more effective to use small tweaks to edit the shape: (a) To edit the baffle, the operator can rotate the part around the PoI and edit the suture curve by clicking any one of its twelve or so control points and by dragging it along the surface. (b) To edit a tubular connection for a Fontan, the operator can click and drag the mid-course control point along the centerline or use the stylus to rotate the tangent direction at either endpoint. (c) To edit a stent, the operator may use the stylus to drag the stent in either direction along its centerline or use the menu to set the radius of the stent to one of the choices provided by the manufacturer.

In some cases, several initial attempts and then numerous and detailed edits are performed. As reported by users, the total surgery planning time spent on shape specification ranges from 15 s to several minutes, depending on the anatomy and the desired configuration. These informal usage statistics indicate a significant time saving over the previous version of the surgical planning process, which involved an early version of SURGEM that supported free-form surface warping, but no topological alterations. These required a considerably more laborious design phase using a general purpose CAD system and were often omitted, hence depriving the surgeon from the pre-operative benefit of a 3D model  [5].

We have tested these new SURGEM tools on users ranging from experienced surgeons to second year undergraduate students. No matter what the level of experience, with the tool and with the human anatomy, they all praise (1) the simplicity of the graphical interface, (2) the ability to see the interior or hidden structure while planning a shape change, and (3) the real-time feedback after the initial design or during editing.

The only complaint (request for improvement) that we have received so far is about the editing of the centerline for the tubular baffle in the Fontan surgery. In some configurations, being able to adjust the 3D location of the mid-course point of the centerline does not provide enough control over the shape of the centerline. In fact, users have requested a tool that will automatically trace a centerline so that the tube is clear from interferences with the surrounding organs.

@&#CONCLUSION@&#

We have presented a set of tools to support three types of solid modifying operations that are used by surgeons when preparing for a patient specific cardiac operation. Two of these operations extend the traditional Boolean operations between two solids to configurations where one of the solids is an open surface. The third one may be viewed as a beautification of an ill-formed tube. The user input for these operations consists of a few stylus clicks and drags. All pose geometric and algorithmic challenges, which we have addressed by using combinations of known and novel solutions.

The tools proposed here provide surgeons with more direct and precise control to achieve the shape they want and allow them to explore a larger number of surgical options quickly. Still, the process of designing the best shape for a given patient remains difficult and laborious, because the surgeon seeks to optimize a combination of complex objectives (such as reducing power loss and balancing blood flow to both lungs) and must simultaneously take many implicit functional and geometric constraints into consideration (such as accessibility during the operation, spatial interference, accommodation of motion during heart beat, and a large set of surgical best practices). Desirable advanced features that may help with these tasks include: (1) being able to drag the mouse or stylus to adjust the ratio of the volumes of the two ventricles while preserving the designed suture line or at least a set of operator-specified points along it, (2) adjusting the angles at the endpoints of a tubular connection automatically in realtime to optimize blood flow, and (3) physical simulation to compute a more realistic shape of a vessel after the insertion of a stent, and (4) automate the tracing of the Fontan tube amongst obstacles.

@&#ACKNOWLEDGMENTS@&#

We would like to thank the anonymous reviewers for providing excellent suggestions for improving the manuscript.

@&#REFERENCES@&#

