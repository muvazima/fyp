@&#MAIN-TITLE@&#Ordered trajectories for human action recognition with large number of classes

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A technique that captures information of objects with longer duration.


                        
                        
                           
                           A feature selection like approach that delivers better performance than several trajectory variants.


                        
                        
                           
                           Removal of a large number of trajectories related to background noise.


                        
                        
                           
                           We apply our technique on action datasets HMDB51, UCF50 and UCF101 containing largest number of classes till date.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Action recognition

Dense trajectories

Large scale classification

Fisher vector

Bag-of-Words

SVM

@&#ABSTRACT@&#


               
               
                  Recently, a video representation based on dense trajectories has been shown to outperform other human action recognition methods on several benchmark datasets. The trajectories capture the motion characteristics of different moving objects in space and temporal dimensions. In dense trajectories, points are sampled at uniform intervals in space and time and then tracked using a dense optical flow field over a fixed length of L frames (optimally 15) spread overlapping over the entire video. However, among these base (dense) trajectories, a few may continue for longer than duration L, capturing motion characteristics of objects that may be more valuable than the information from the base trajectories. Thus, we propose a technique that searches for trajectories with a longer duration and refer to these as ‘ordered trajectories’. Experimental results show that ordered trajectories perform much better than the base trajectories, both standalone and when combined. Moreover, the uniform sampling of dense trajectories does not discriminate objects of interest from the background or other objects. Consequently, a lot of information is accumulated, which actually may not be useful. This can especially escalate when there is more data due to an increase in the number of action classes. We observe that our proposed trajectories remove some background clutter, too. We use a Bag-of-Words framework to conduct experiments on the benchmark HMDB51, UCF50 and UCF101 datasets containing the largest number of action classes to date. Further, we also evaluate three state-of-the art feature encoding techniques to study their performance on a common platform.
               
            

@&#INTRODUCTION@&#

Human action recognition requires the modelling of the coordinated motions – the actions – of different parts of the human body and their interaction with other objects or persons nearby. Offline applications include event detection, e.g. injury detection in team sport matches; efficient video retrieval, e.g. spotting a person in news footage; and video indexing. Online applications include automatic surveillance in public places, shopping malls, hospitals etc.; interactive applications, e.g. video games; robotics and more.

In early research, human action recognition focussed on classifying only very few (6–11) action classes, which mostly involved motion of the whole body without much interaction with nearby objects or people. Experimental validations were mainly carried out on videos collected in very controlled environments, such as in a laboratory, staged by a single person on several occasions. However, with the widespread use of the internet these days, users are uploading millions of videos on social networking sites such as YouTube and Facebook. This has created challenges for developing robust techniques for action recognition in real-world videos, even more so when considering a much larger number of action classes.

Real-world videos can contain movements of the entire body or of only some specific regions, e.g. facial expressions or moving a limb, possibly repetitive, whole-body movements such as walking and running, or a number of sequences of body movements, such as walking in a queue or cross-walking at an intersection. It is of interest to investigate how to adapt, generalise or fuse the existing techniques to model any kind of human actions. In real-world videos, context (e.g. the environment/situation) and interaction of the body with the context (e.g. objects/persons) are also important to correctly classify the actions being performed. In this paper, we focus on a feature representation scheme for large scale human action recognition in realistic videos.

We select the local representation based Bag-of-Words (BoW) technique to test our proposed hypothesis. Firstly, interest points are detected at different spatio-temporal locations and scales for a given video. Then, local feature descriptors are computed in the spatio-temporal neighbourhood of the detected interest points, which capture shape (gradient) or motion (optical flow) or similar measurements describing the human action dynamics. We observe that trajectories obtained by a Kanade–Lucas–Tomasi (KLT) tracker [1], either densely sampled [2] or sampled in one of the variants [3–6], have been consistently performing well on several benchmark action recognition datasets. Hence, we focus our current work on trajectories only.

We conjecture that objects moving for a longer duration contain more discriminative information for action classification. Hence, we propose a scheme to select such trajectories from the base (dense) trajectories in a very computationally and memory efficient way. We refer to such selected trajectories as ‘ordered trajectories’. We study and present our results on the large scale action datasets HMDB51, UCF50 and UCF101 containing at least 50 different action classes. All experiments are performed in a BoW framework using a Support Vector Machine (SVM) classifier. In this paper, we make the following contributions:
                        
                           1.
                           A technique that captures information of objects with longer duration trajectories.

A feature selection like approach that selects about half of the dense trajectories, yet delivers better performance than the original and several other trajectory variants.

Removal of a large number of trajectories related to background noise.

In the remainder of the paper, Section 2 contains a review of the latest advances in feature representations w.r.t. large scale action recognition. Section 3 describes the proposed framework. Section 4 details the local feature descriptors, codebook generation, classifier and datasets used to conduct our experiments. Section 5 presents and discusses the results obtained on the benchmark datasets. Finally, conclusions are drawn in Section 6.

Several techniques to detect interest points and construct local feature based representations exist in the literature. Laptev et al. [7] first proposed the usage of Harris 3D corners as an extension of the traditional Harris corner points. Later on, cuboid detectors obtained as local maxima of the response function of temporal Gabor filters on a video were proposed by Dollár et al. [8]. Willems et al. [9] proposed a Hessian interest point detector, which is a spatio-temporal extension of the Hessian saliency measure for blob detection in images. Wang et al. [10] proposed a dense sampling approach wherein the interest points are extracted at regular positions and scales in space and time. Spatial and temporal samplings are often done with 50% overlap. Further, Wang et al. [2] extend the dense sampling approach by tracking the interest points using a dense optical flow field.

We focus particularly on trajectory based techniques of the last 5years as they have been found to perform better than most other techniques on larger action recognition datasets, e.g. UCF50 and HMDB51, with 50 or more action classes. For the sake of presentation of our work, we review trajectory based techniques from three perspectives. Firstly, we review those works that propose a variant of trajectories [4,5] and/or new local feature descriptors [3]. Secondly, we review those works, which construct features in different scales/volumes obtained by dividing the video along height, width and time, and then aggregate these. This is akin to the popular Spatio-Temporal Pyramidal approach [11–13]. The trajectories and their variants can also be aggregated together. Thirdly, we review those works, where some trajectories are selected from those obtained by the above approaches. All three categories for feature representation are still in practice and found to yield good results on different action recognition datasets. They are described below.

Uemura et al. [14] proposed human action recognition based on the KLT tracker and the SIFT descriptor. Multiple interest point detectors were used to provide a large number of interest points for every frame. Sun et al. [15] proposed a hierarchical structure to model spatio-temporal contextual information by matching SIFT descriptors between two consecutive frames. Actions were classified based on intra- and inter-trajectory statistics. Messing et al. [16] proposed an activity recognition model based on the velocity history of Harris 3D interest points (tracked with a KLT tracker). Matikainen et al. [17] proposed a model to capture the spatial and temporal context of trajectories, which were obtained by tracking Harris corner points in a given video using a KLT tracker.

Wang et al. [2] proposed dense trajectories to model human actions. Interest points were sampled at uniform intervals in space and time, and tracked based on displacement information from a dense optical flow field. Kliper-Gross et al. [5] proposed Motion Interchange Patterns (MIP) for capturing local changes in motion trajectories. Based on dense trajectories [2], Jiang et al. [4] proposed a technique to model the object relationships by encoding pairwise dense trajectory codewords. Global and local reference points were adopted to characterise motion information with the aim of being robust to camera movements. Jain et al. [3] proposed another variant of dense trajectories recently, showing that significant improvement in action recognition can be achieved by decomposing visual motion into dominant (assumed to be due to camera motion) and residual motions (corresponding to the scene motions). Raptis [18] extracted spatio-temporal structures by forming clusters of dense trajectories to serve as candidates for the parts of each action. Peng et al. [19] developed a set of new descriptors: spatial context descriptors to capture complex spatial structures of appearance and motion and temporal context descriptors to depict clear motion and appearance changes from successive patches. Both types of descriptors are computed from dense trajectories.

Each technique has attempted to capture and model some type of characteristic information of objects moving in the video. However, none explicitly tried to capture the information of objects moving for a longer duration. We conjecture that valuable information for action recognition is contained in longer object trajectories.

To encode spatial information within the bag-of-features representation, the Spatial Pyramidal approach was first proposed by Lazebnik et al. [12] for object classification in images, but has since also been successfully used in videos. Here, the video sequence is split into sub-volumes and a histogram is computed for each sub-volume. The final histogram is obtained by concatenating or accumulating all histograms of the sub-volumes. Illustrations are given in Fig. 1
                        . For example, when the original video is divided into three horizontal sub-volumes, as shown in Fig. 1(b), three separate codebooks are to be constructed for each sub-volume. Using those dense trajectories that fall in a particular sub-volume, feature histograms are generated. These feature histograms are concatenated to yield the overall feature vector for the video. In this case, the feature vector will be 3 times larger than the one obtained on full-volume dense trajectories. In another case, as can be seen in Fig. 1(f) where the original video is divided into eight sub-volumes, the final vector will be 8 times larger than the one obtained by the full-volume dense trajectories.

Zhao and Elgammal [20] divide each frame into cells, over which Dollár's features [8] are computed. Additionally, motion features from neighbouring frames are used in a weighted scheme, which takes into account the distance of the neighbour from the actual frame. A spatial-pyramid matching, similar to [12], is then applied to compute the similarity between frames. Finally, frames are classified individually and a voting scheme is used for action recognition in the video. Ullah et al. [13] used six spatial subdivisions of a video and computed local features and models for each subdivision. They found significant improvement in the recognition rate compared to using the original video.

Wang et al. [6] compute features using dense trajectories in a Spatio-Temporal Pyramidal approach and show highest performance on most of the action recognition datasets. Zhu et al. proposed a Generalized Pyramid Matching Kernel (GPMK) based on a multi-channel BoW representation constructed from dense trajectories. It is an extension to the spatial–temporal pyramid matching (STPM) kernel. Instead of the predefined and fixed weights used in STPM, their technique computes channel weights of GPMK adaptively based on the kernel target alignment from training data. Duan et al. [21] proposed the Aligned Space–Time Pyramid Matching technique to effectively measure the distances between two videos that may be from different domains for the purpose of visual event recognition in videos. Each video clip is divided into space–time volumes over multiple levels and the pairwise distances between any two volumes are computed. Liu et al. [22] compute extensive pyramidal features (EPFs), which include the Gabor, Gaussian, and wavelet pyramids. These features were meant to encode the orientation, intensity, and contour information and, therefore, provide an informative representation of human poses. They further employ the AdaBoost algorithm to learn a subset of discriminative and representative features.

A main drawback with these kinds of approaches is that they tend to be computationally expensive.

Nowak et al. [23] showed by extensive experiments that uniform random sampling can provide performances comparable to dense sampling of interest points. Another independent study [24] showed that action recognition performance can be maintained with as little as 30% of the densely detected features. Chakraborty et al. [25] presented an approach for selecting robust STIP detectors by applying surround suppression combined with local and temporal constraints. They show that such a technique performs significantly better than the original STIP detectors. Shi et al. [26] showed that with proper sampling density, a state-of-the-art performance can be achieved by randomly discarding up to 92% of densely sampled interest points. Peng et al. [19] proposed a motion boundary based dense sampling strategy to select a few dense trajectories, while preserving the discriminative power.

These studies have motivated us to search for a smaller, yet richer set of trajectories from the dense trajectories.

Moving object tracking involves locating the objects of interest, maintaining their identities and building their trajectories throughout a given video sequence. One of the most successful techniques employed in this domain is tracking by data association. In this technique, initially a pre-learnt object detector is applied to detect the objects of interest in every frame. Then, linking of the detections is performed to obtain the trajectories of the objects of interest. The main challenges include missed detections, false alarms, inaccurate detections, occlusions, and similar appearance among multiple objects. Three popular strategies [27] in use to counter these challenges are: local data association, global data association, and hierarchical data association methods.

The local data association strategy performs frame-by-frame tracking [28] based on local measures, such as cues from position, appearance, size, and colour of detections in neighbouring frames. Then, an algorithm is applied to match the detection responses. However, any noisy target detections affect the data association considerably and, thus, the local association methods are likely to lead to a drift in such situations. Global data association strategies utilise inference over multiple objects by seeking to resolve the drift problem over a longer period. For example, Perera et al. and Stauffer [29,30] use the Hungarian algorithm [31] to simultaneously optimise all trajectories of moving objects. However, these approaches are computationally exponential, both in memory and time.

The hierarchical association framework combines the local linking and global association methods for better tracking performance. These methods progressively connect the short detections or tracklets into longer ones. They typically split the data association into two separate optimisation problems: linking detections locally in the lower stages and linking trajectories globally in the higher stages. For example, Xing et al. [32] proposed a two-stage association method, which combines local and global trajectories association to track multiple objects through occlusions. A particle filter was used to generate a set of reliable trajectories in the local stage and a modified Hungarian algorithm was used to optimise the data association in the global stage. Similarly, Zhang et al. [27] proposed a unified framework for automatically relearning from local to global information. The local-to-global trajectory models were used to link detections from consecutive frames into trajectories and also link separated trajectories that belong to the same targets into long trajectories.

Our proposed technique to find longer trajectories has close similarities to those employed in moving object tracking. Dense trajectories are used to obtain trajectories of moving objects at local level. Cues based on the position (of the trajectories) are taken for linking these dense trajectories to obtain longer trajectories. The difficulties in directly adapting moving object tracking to human action recognition are discussed in Section 4.1. The novelties of the proposed technique compared to tracking are described in Section 5.3.

The overall layout of the proposed framework is shown in Fig. 2
                     . Firstly, base trajectories are detected. The proposed ordered trajectories are generated by searching through base trajectories for potential matches to other trajectories to create longer duration trajectories. Local descriptors – Motion Bound Histograms (MBH), Histograms of Oriented Gradients (HOG), Histogram of Optical Flow (HOF) – are collected from the base trajectories that are found to constitute ordered trajectories. Only the Trajectory Shape descriptor is computed for the generated ordered trajectories. Feature vectors are constructed from these local descriptors using a feature encoding technique. These feature vectors are used to learn a classifier. Separate codebooks are constructed for each type of descriptor. We use dense trajectories, proposed by Wang et al. [2] (and their improved version [33]), in our work as the base trajectories, which we briefly summarise next.

Firstly, points uniformly spaced over each frame in 8 spatial scales are sampled. This ensures that points are equally spread in all spatial positions and scales. By experimentation, Wang et al. [6], report that a sampling step size of W=5
                        pixels yields good results over several benchmark datasets. Points in homogeneous regions are removed, by applying the criterion of Shi and Tomasi [34], if the eigenvalues of the auto-correlation matrix are very small. The threshold T set on the eigenvalues for each frame I is
                           
                              (1)
                              
                                 T
                                 =
                                 0.001
                                 ×
                                 
                                    max
                                    
                                       j
                                       ∈
                                       I
                                    
                                 
                                 min
                                 
                                    
                                       λ
                                       j
                                       1
                                    
                                    
                                       λ
                                       j
                                       2
                                    
                                 
                              
                           
                        where (λ
                           j
                        
                        1,λ
                           j
                        
                        2) are the eigenvalues of point j in the frame I.

The sampled points are then tracked by applying median filtering over the dense optical field. For a given frame It
                        , its dense optical flow field ω
                           t
                        
                        =(u
                        
                           t
                        ,
                        v
                        
                           t
                        ) is computed w.r.t. the next frame I
                        
                           t
                           +1, where u
                        
                           t
                         and vt
                         are the horizontal and vertical components of the optical flow. A point p
                        
                           t
                        
                        =(x
                        
                           t
                        ,
                        y
                        
                           t
                        ) in frame It
                         is tracked to another position p
                        
                           t
                           +1
                        =(x
                        
                           t
                           +1,
                        y
                        
                           t
                           +1) in frame I
                        
                           t
                           +1 as follows
                           
                              (2)
                              
                                 
                                    p
                                    
                                       t
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       x
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                    
                                       y
                                       
                                          t
                                          +
                                          1
                                       
                                    
                                 
                                 =
                                 
                                    
                                       x
                                       t
                                    
                                    
                                       y
                                       t
                                    
                                 
                                 +
                                 
                                    
                                       M
                                       ∗
                                       
                                          ω
                                          t
                                       
                                    
                                 
                                 |
                                 
                                    
                                    
                                       
                                          x
                                          t
                                       
                                       
                                          y
                                          t
                                       
                                    
                                 
                              
                           
                        where M is a 3×3pixels median filtering kernel.

The algorithm proposed by Farnebäck [35] is used to compute dense optical flow. To avoid drifting from their initial locations during the tracking process, tracking is performed on a fixed length L number of frames at a time. Through experimentation [6], L
                        =15 frames is found suitable. In a post-processing stage, trajectories with sudden large displacements are removed.

Four kinds of local feature descriptors are computed on the neighbourhood of the points derived by the above trajectories. These were MBH, HOG, HOF and Trajectory Shape. Each descriptor captures some specific characteristics of the video content. HOG descriptors capture the local appearance, while HOF descriptors capture the changes in the temporal domain. The space–time volumes (spatial size 32×32pixels) around the trajectories are divided into 12 equal-sized 3D grids (spatially, 2×2 grids and temporally, 3 segments). For computing HOG, gradient orientations are quantised into 8 bins. For computing HOF, 9 bins are used with one more zero bin in comparison to HOG. Thus, the HOG descriptors are 96-dimensional and the HOF descriptors are 108-dimensional.

The MBH descriptors are based on motion boundaries. These descriptors are computed by separate derivatives for the horizontal and vertical components of the optical flow. As MBH captures the gradient of the optical flow, constant camera motion is removed and information about changes in the flow field (i.e. motion boundaries) is retained. An 8-bin histogram is obtained along each component of x and y. Both histogram vectors are normalised separately with their L
                        2 norm, each becoming a 96-dimensional vector. In our experiments, we built separate codebooks for MBH descriptors along x and y. The trajectory shape descriptor encodes local motion patterns. For a trajectory of given length L (number of frames) and containing a sequence of points (p
                        
                           t
                        
                        =(x
                        
                           t
                        ,
                        y
                        
                           t
                        )), the trajectory shape is described in terms of a sequence of displacement vectors Δp
                        
                           t
                        
                        =(p
                        
                           t
                           +1
                        −
                        p
                        
                           t
                        )=(x
                        
                           t
                           +1
                        −
                        x
                        
                           t
                        ,
                        y
                        
                           t
                           +1
                        −
                        y
                        
                           t
                        ). The resulting vector is normalised by the sum of displacement vector magnitudes.
                           
                              (3)
                              
                                 T
                                 =
                                 
                                    
                                       Δ
                                       
                                          p
                                          t
                                       
                                       ,
                                       …
                                       ,
                                       Δ
                                       
                                          p
                                          
                                             t
                                             +
                                             L
                                             −
                                             1
                                          
                                       
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                j
                                                =
                                                t
                                             
                                             
                                                t
                                                +
                                                L
                                                −
                                                1
                                             
                                          
                                       
                                       
                                          
                                             Δ
                                             
                                                p
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

For L
                        =15 frames, a 30-dimensional trajectory shape descriptor is obtained. The dense trajectories code available online [2] is used in all experiments.

In this section, we first present our hypothesis and later describe the generation of the proposed ordered trajectories from the extracted base trajectories.

Several trajectory based techniques exist to capture and model some type of characteristic information of objects moving in the video. For example, as shown in Fig. 3
                        , let trajectories A, B, C of fixed span L begin from frames i,(i
                        +1),(i
                        +2), respectively. Ordinarily, all these trajectories would have been considered when constructing the feature vector for the video. However, the following observations are made
                           
                              •
                              Trajectories, such as A, that continue for a longer span or duration can be expected to capture the characteristic information of the primary object(s) motion.

Trajectories, such as B, and to some extent C, that fade out slowly can be expected to capture information about secondary or background object(s) motion.

We hypothesize that longer duration trajectories contain more valuable information than all the remaining trajectories put together (as these contain noise, which can affect the training process). However, computing trajectories of longer duration has the following issues that need to be addressed
                           
                              •
                              Limitation of optical flow techniques that may not keep track of changes over long duration.

With different length trajectories, the local descriptors computed around each of them would be having different dimensions. For example, trajectories A, B, C with a span of L
                                 +2, L, L
                                 +1 would result in a Trajectory Shape descriptor dimension of 34, 30, and 32, respectively. Handling these in a BoW setting is not easy and straightforward.

We propose a technique to address these primary drawbacks. We hypothesize that any trajectory, even if it is of a longer duration (>
                        L) should be constituted by base trajectories, i.e. trajectories of duration L. We can capture the information of moving objects with a longer duration if we can search for those base trajectories, which constitute the longer duration trajectories. Since the local descriptors of each of these base trajectories are of fixed dimensions, they are directly used in computing feature vectors for the given video. Hence, we do not need to recompute MBH, HOG, and HOF descriptors for the trajectories of longer duration. For example, as seen in Fig. 3, trajectories beginning from frame i can be compared with trajectories beginning from (i
                        +1) to find the trajectories that have longer duration L
                        +1.

Further, the proposed technique can be recursively applied. Base trajectories spanning over L frames can be compared with each other to obtain trajectories with span L
                        +1. These L
                        +1 - length trajectories can be compared with each other to further generate trajectories with span L
                        +2 (results are shown in Section 5.2.2).

The search for base trajectories constituting longer duration trajectories can be performed in a very simple and efficient manner. We only need a sequential matching of trajectories beginning every two consecutive frames. In this way, we can collect all base trajectories very efficiently, even if the long duration trajectory has undergone major motion changes from where it began. We refer to such collected base trajectories as ordered trajectories.

Moreover, as in Fig. 3, we first compare trajectories beginning from frame i with trajectories beginning from frame (i
                        +1) and trajectories beginning from frame (i
                        +1) with trajectories beginning from frame (i
                        +2) and so on. It can be noted that the matching of trajectories beginning from frame i is already being done with trajectories beginning from frame (i
                        +2). This can, hence, be treated as a more efficient way to match trajectories than other techniques such as clustering all trajectories together [18].

The two main stages involved in the generation of ordered trajectories – the matching stage and the generation stage – are now described in detail.

The objective in this stage is to search for trajectories that have a matching trajectory (beginning from the immediate next frame). Consider a trajectory of points P
                        
                           i
                        
                        ={p
                        
                           i
                        } with length L beginning from frame i. Let the trajectories beginning from the immediate next frame i
                        +1 be denoted as Q
                        
                           i
                           +1
                        
                           j
                        
                        ={q
                        
                           i
                           +1
                        
                           j
                        }. The objective can then be redefined as finding a trajectory in the set Q
                        
                           i
                           +1
                        
                           j
                         that matches the trajectory Pi
                        .

Several solutions exist in the literature for this objective. For example, this is essentially similar to a detection-to-track association problem in the moving object tracking domain. Cues such as temporal, kinematic, appearance, and colour of the object trajectories are used to find the matching trajectory. The trajectories in moving object tracking are usually obtained by tracking detected objects of interest. However, the dense trajectories obtain trajectories of any moving object using an optical flow algorithm (described in Section 3.1). Hence, dense trajectories also contain tracks of many non-interest objects; sometimes more than for the primary object itself. Thus, cues such as appearance and colour are not considered in our approach. Our objective is now refined as finding a matching trajectory Q
                        
                           i
                           +1
                        
                           j
                         such that tracks of non-interest objects are also minimised. We focus on the kinematic cue – the position of the trajectories.

Based purely on kinematics, two trajectories can be tested for a possible match in several ways. For example, probabilities capturing the nature of the position, velocity, orientation, etc. have been used to constitute the cost function and optimised by the Hungarian algorithm for object trajectory assignment in moving object tracking. However, it has to be recalled that the dense trajectories are computed at every interval gap of W
                        =5pixels in (x, y) directions and in multiple scales, so that there are many trajectories related to one main object of interest, e.g. a human body. However, in the moving object tracking domain, the trajectory of a human body is considered as a whole. Hence, the kinematic based cost function should be chosen properly in the action recognition domain.

We now present our intuition in selecting the kinematic based cost function. The objective is to search for a trajectory Q
                        
                           i
                           +1
                        
                           j
                         that can match the trajectory Pi
                        . Trajectories Q
                        
                           i
                           +1
                        
                           j
                         and Pi
                         begin from frames i
                        +1 and i, respectively. The simplest cost function for two trajectories is a corresponding point-to-point distance given by
                           
                              (4)
                              
                                 |
                                 |
                                 
                                    
                                       
                                          
                                             p
                                             
                                                i
                                                +
                                                1
                                             
                                          
                                          −
                                          
                                             q
                                             
                                                i
                                                +
                                                1
                                             
                                             j
                                          
                                       
                                    
                                    2
                                 
                                 +
                                 
                                    
                                       
                                          
                                             p
                                             
                                                i
                                                +
                                                2
                                             
                                          
                                          −
                                          
                                             q
                                             
                                                i
                                                +
                                                2
                                             
                                             j
                                          
                                       
                                    
                                    2
                                 
                                 +
                                 …
                                 +
                                 
                                    
                                       
                                          
                                             p
                                             
                                                i
                                                +
                                                L
                                                −
                                                1
                                             
                                          
                                          −
                                          
                                             q
                                             
                                                i
                                                +
                                                L
                                                −
                                                1
                                             
                                             j
                                          
                                       
                                    
                                    2
                                 
                                 |
                                 |
                                 
                                    
                                    2
                                 
                              
                           
                        
                     

An algorithm, such as the Hungarian algorithm, can be used to optimise this cost function. The trajectory, Q
                        
                           i
                           +1
                        
                           k
                        ,
                        k
                        ∈
                        j, which yields the lowest distance, can be considered as a match for the trajectory Pi
                        . However, the number of dense trajectories is really large and the Hungarian algorithm can be expensive in time. Hence, we propose a simplified cost function and search algorithm as follows.

The first term of Eq. (4) is taken as the simplified cost function, given as
                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   p
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                
                                                −
                                                
                                                   q
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                   j
                                                
                                             
                                          
                                          2
                                       
                                    
                                    2
                                 
                              
                           
                        
                     

We select the second point p
                        
                           i
                           +1
                        =(x
                        
                           i
                           +1,
                        y
                        
                           i
                           +1) from the trajectory Pi
                         and compute its distance distance(p
                        
                           i
                           +1,
                        q
                        
                           i
                           +1
                        
                           j
                        ) to all first points of the trajectories Q
                        
                           i
                           +1
                        
                           j
                         (see Fig. 4
                        ). The trajectory Q
                        
                           i
                           +1
                        
                           k
                        ,
                        k
                        ∈
                        j with the lowest distance is taken and compared with a threshold distance d
                        
                           th
                         to ascertain if it is a matching trajectory for Pi
                         or not. This threshold distance d
                        
                           th
                         is fixed by using the help of the spacing gap of the dense trajectories. Dense trajectories are computed with a spacing gap of W
                        =5pixels in (x,
                        y) directions. Hence, the threshold distance d
                        
                           th
                         is fixed as 
                           W
                           
                              2
                           
                         in all experiments. More details on the efficiency (in terms of computation time) of the proposed algorithm over the Hungarian algorithm are given in Section 5.3.
                           Algorithm 1
                           Generating ordered trajectories
                                 
                                    
                                 
                              
                           

This process is repeated for every L
                        =15 frames, i.e. for every trajectory P
                        
                           i
                        ,
                        i
                        =1,2,…
                        N
                        −
                        L
                        −1, where N is the total number of frames in the given video source. For some trajectories P
                        
                           i
                        
                        
                           j
                        , there may not exist any matching trajectories. The pseudo-code for matching trajectories for an entire video is shown in Algorithm 1. For each video, this computation is performed only once. All matching trajectories – P
                        
                           i
                        ,
                        Q
                        
                           i
                           +1
                        
                           j
                         – obtained are conjectured to constitute longer trajectories with duration L
                        +1.

The objective of this stage is to compute the local descriptors – MBH, HOG, HOF and trajectory shape – of the longer trajectories obtained in Section 4.2. MBH, HOG and HOF descriptors of the trajectories Pi
                         and Q
                        
                           i
                           +1
                        
                           j
                         (which have been identified to constitute longer trajectories) are accumulated to construct feature vectors for MBH, HOG and HOF, respectively. These three types of descriptors are not recomputed. Only the trajectory shape local descriptor is recomputed for the longer duration trajectories, which is explained now.

There are two steps involved in computing the trajectory shape of the longer trajectory. In the first step, the matching trajectories Pi
                         and Q
                        
                           i
                           +1
                        
                           j
                         are merged to form a longer duration trajectory PQ
                        
                           i
                        
                        ={pq
                        
                           i
                        },
                        i
                        =1,2,…
                        i
                        +
                        L with duration L
                        +1. Merging is now explained, with the help of Fig. 5
                        . Remember that trajectories are a sequence of points with length L defined as P
                        
                           i
                        
                        ={p
                        
                           i
                        } and Q
                        
                           i
                           +1
                        
                           j
                        
                        ={q
                        
                           i
                           +1
                        
                           j
                        }. The first element of the longer duration trajectory {pq
                        
                           i
                        } consists of p
                        
                           i
                        
                        =(x
                        
                           i
                        ,
                        y
                        
                           i
                        ). The last element of the longer duration trajectory {pq
                        
                           i
                           +
                           L
                        } consists of q
                        
                           i
                           +
                           L
                        
                        =(x
                        
                           i
                           +
                           L
                        ,
                        y
                        
                           i
                           +
                           L
                        ), respectively. The second element of the longer duration trajectory {pq
                        
                           i
                           +1} consists of the mean of p
                        
                           i
                           +1 and q
                        
                           i
                           +1. The third element of the longer duration trajectory {pq
                        
                           i
                           +2} consists of the mean of p
                        
                           i
                           +2 and q
                        
                           i
                           +2, and so on.

Once the sequence of points of the longer trajectory PQ
                        
                           i
                         is generated, the trajectory shape descriptor is computed using Eq. (3). As L
                        =16 now, the length of the trajectory shape descriptor is 32.

Separate dictionaries are built for each descriptor. We accumulate descriptors from a video of a particular class and randomly select 25% of the total number of descriptors. In this way, we collect information for each class from the training dataset and a subset of 100,000 descriptors is selected randomly. This subset of descriptors is clustered to obtain the visual words.

The next step in constructing a BoW representation is encoding a feature using the codebook. In the literature, there exist several encoding methods, such as Hard Assignment (HA), Soft Assignment [36], Sparse encoding [37], and Locality-constrained Linear encoding [38]. Most of these techniques are based on the count of descriptors belonging to different visual words. Most recently, the Vector of Locally Aggregated Descriptors (VLAD) and Fisher Vector (FV) encodings have been applied to action recognition datasets. These techniques are based on a measure determining how much a descriptor belongs to a particular (assigned) visual word. We apply HA, VLAD and FV encoding schemes in our experiments. Brief details of each encoding technique are given below.
                           
                              •
                              Hard Assignment (HA)

HA has been the foremost and one of the most popular techniques for action recognition. This technique computes the frequency of the visual words (of the dictionary) for given video. In our experiments, dictionaries are constructed with k-means clustering. The number of visual words k is set to 4000, which was shown to give good results [10]. We initialised k-means 8 times and kept the result with the lowest error. After creating a codebook C
                                 ={μ
                                 1,
                                 μ
                                 2,…,
                                 μ
                                 
                                    k
                                 }, local descriptors are assigned to the closest visual word as
                                    
                                       (6)
                                       
                                          q
                                          :
                                          
                                             R
                                             d
                                          
                                          →
                                          C
                                          ⊂
                                          
                                             R
                                             d
                                          
                                       
                                    
                                 
                                 
                                    
                                       (7)
                                       
                                          x
                                          ↦
                                          q
                                          
                                             x
                                          
                                          =
                                          arg
                                          
                                             min
                                             
                                                μ
                                                ∈
                                                C
                                             
                                          
                                          |
                                          |
                                          x
                                          −
                                          μ
                                          |
                                          |
                                          
                                             
                                             2
                                          
                                       
                                    
                                 where the norm operator ||.||2 refers to the L
                                 2 norm.

Vector of Locally Aggregated Descriptors (VLAD)

This is a very recent technique applied successfully to action recognition by Jain et al. [3]. In this encoding, the difference between the descriptors and the closest visual word is collected as residual vectors. For each visual word of dimension d (dimension of the local feature descriptor), a sub-vector v
                                 
                                    i
                                  is obtained by accumulating the residual vectors as
                                    
                                       (8)
                                       
                                          
                                             v
                                             i
                                          
                                          =
                                          
                                             
                                                ∑
                                                
                                                   x
                                                   :
                                                   q
                                                   
                                                      x
                                                   
                                                   =
                                                   
                                                      μ
                                                      i
                                                   
                                                
                                             
                                          
                                          x
                                          −
                                          μ
                                       
                                    
                                 
                              

The obtained sub-vectors are concatenated to yield a D-dimensional vector, where D
                                 =
                                 k
                                 ×
                                 d. Further, two-stage normalisation is applied. Firstly, the ‘power–law normalisation’ [39] is applied. It is a component-wise non-linear operation. Each component v
                                 
                                    j
                                 ,
                                 j
                                 =1 to D is modified as
                                    
                                       (9)
                                       
                                          
                                             v
                                             j
                                          
                                          =
                                          
                                             
                                                
                                                   v
                                                   j
                                                
                                             
                                             α
                                          
                                          ×
                                          
                                          sign
                                          
                                             
                                                v
                                                j
                                             
                                          
                                          ,
                                       
                                    
                                 where α is a parameter such that α≤1. In all experiments, k
                                 =256 and α=0.2. Secondly, the vector is L
                                 2 – normalised as 
                                    v
                                    =
                                    
                                       v
                                       
                                          v
                                       
                                    
                                  to yield the VLAD vector.

We use two types of classifiers according to the type of encoding technique used. For HA encoded features, we build a non-linear SVM LIBSVM [40] with an RBF-χ2 kernel k(H
                        
                           i
                        
                        
                           c
                        ,
                        H
                        
                           j
                        
                        
                           c
                        ) computed as
                           
                              (13)
                              
                                 k
                                 
                                    
                                       H
                                       i
                                       c
                                    
                                    
                                       H
                                       j
                                       c
                                    
                                 
                                 =
                                 
                                    1
                                    A
                                 
                                 
                                    
                                       
                                          
                                             
                                                H
                                                i
                                                c
                                             
                                             −
                                             
                                                H
                                                j
                                                c
                                             
                                          
                                       
                                       2
                                    
                                    
                                       
                                          H
                                          i
                                          c
                                       
                                       +
                                       
                                          H
                                          j
                                          c
                                       
                                    
                                 
                              
                           
                        where H
                        
                           i
                        
                        
                           c
                        
                        =
                        h
                        
                           in
                         and H
                        
                           j
                        
                        
                           c
                        
                        =
                        h
                        
                           jn
                         are the frequency histograms of the visual word occurrences of the c
                        
                           th
                         descriptor for the i
                        
                           th
                         video; A is the average χ2 distance between the training samples.

For N types of descriptors, a multi-channel setup is used
                           
                              (14)
                              
                                 K
                                 
                                    i
                                    j
                                 
                                 =
                                 exp
                                 
                                    
                                       −
                                       
                                          1
                                          N
                                       
                                       
                                          
                                             ∑
                                             
                                                c
                                                =
                                                1
                                             
                                             N
                                          
                                       
                                       k
                                       
                                          
                                             H
                                             i
                                             c
                                          
                                          
                                             H
                                             j
                                             c
                                          
                                       
                                    
                                 
                              
                           
                        
                     

For VLAD and FV encoded features, all features are concatenated and a linear SVM (LIBLINEAR [41]) is used. The one-versus-all approach is applied in all cases and the class with the highest score is selected.

The proposed technique is applied to three benchmark datasets: HMDB51 
                        [42], UCF50 
                        [43] and UCF101 
                        [44]. HMDB51 contains 51 action categories. A complete list of actions and the data is available online (dataset at http://serre-lab.clps.brown.edu/resources/HMDB/). Digitised movies, public databases such as the Prelinger archive, videos from YouTube and Google videos were used to create this dataset. For evaluation purposes, three distinct training and testing splits are specified in the dataset. These splits were built to ensure that clips from the same video are not used for both training and testing. For each action category in a split, 70 training and 30 testing clips indices are fixed so that they fulfil the 70/30 balance for each meta tag. UCF50 has 50 action classes. A complete list of actions and the data is available online (dataset downloaded from http://crcv.ucf.edu/data/UCF50.php). This dataset consists of 6680 realistic videos collected from YouTube. As specified by Reddy and Shah [43], we evaluate the 25-fold group wise cross-validation classification performance on this dataset. The UCF101 dataset is an extension of UCF50 with 101 action categories, also collected from realistic action videos, e.g. from YouTube. Three train-test splits were provided for consistency in reporting performance. Sample classes are shown in Fig. 6
                        .

@&#RESULTS AND DISCUSSIONS@&#

In this section, the results obtained by applying the proposed ordered trajectories are presented.

This section contains results obtained by taking dense trajectories [2] as base trajectories.

Results obtained by using the HA encoded ordered trajectories on the HMDB51, UCF50 and UCF101 datasets are presented in Table 1
                           . The overall performance on HMDB51 and UCF50 datasets is 47.3% and 85.5%, resp., which is 0.7–1% (absolute) more than the traditional dense trajectories [2] computed at five different scales in space and time [6]. The results for the individual local feature descriptors show that only the trajectory shape descriptor performs better than the Spatio-Temporal Pyramidal approach by 3–4% (absolute) due to the trajectory descriptor being computed on the matching dense trajectories. In the case of the other descriptors – MBH, HOG, and HOF – we only retain the corresponding descriptors of matching trajectories.

The effect of the proposed ordered trajectories can be observed in Fig. 7
                           . The ordered trajectories have not lost the principal object (person). At the same time, some background clutter, e.g. steps in (c) ‘Push up’, windows in (e) ‘Shoot bow’ has been filtered out by the proposed technique.

For a sample video of 13s duration, 819KB file size, 320×240 pixels resolution, the number of dense trajectories extracted is shown in Table 2
                           . The number of dense trajectories computed at the original scale in space and time, as shown in Fig. 1(a), is 21647. By the proposed technique, 11,657 ordered trajectories are obtained, which is about 50% of the actual number of dense trajectories.

A natural question that may follow is “Why not compute dense trajectories directly for L
                           =16?". Actually, dense trajectories are first detected at different scales in space. A trajectory that may have ended in one scale, may have continued in the next frame on the upper or lower scale. Dense trajectories do not exclusively combine such trajectories. The numbers of dense trajectories computed for L
                           =16 and L
                           =17 are shown in Table 2. Although their number is slightly smaller than for L
                           =15, it is still nearly twice the number of the proposed ordered trajectories detected at L
                           =15.

We now give an idea of the time taken for computing dense and ordered trajectories. Our experiments have been carried out on a server with a 16-core Xeon processor (2.4GHz) and 64GB RAM. For a typical video containing 407 frames (13s duration) and frame size 320×240 pixels, 23,748 dense (base) trajectories are detected, with a computation time of 2min 15s. The proposed technique to compute ordered trajectories from dense trajectories took 0.6s only. The ordered trajectories detected thus were 13,060 in number, only about 50% of the actual dense trajectories. The code uses a single core only.

The performance of ordered trajectories for the three different encoding techniques is shown in Table 3
                           . Hard Assignment captures only frequency information of the visual words (of the codebook) for a given video. The VLAD encoding technique captures the first order (deviations from the visual words) characteristics. Fisher Vectors capture first and second order (covariance deviation) statistics. In a recent study on large scale image classification [39], Fisher Vectors have been found to perform best. The same can be observed from Table 3: Fisher Vectors perform better among the three encoding techniques. The proposed ‘ordered trajectories’ perform better than the base (dense) trajectories in all situations.

HA encoded features use non-liner SVMs. From a computational point of view, learning non-linear SVMs takes nearly O(N
                           2) to O(N
                           3) operations, where N is the size of the training dataset. VLAD and FV encoded features use linear SVMs, whose learning cost is around O(N) only. Performance wise, we thus note that FV and VLAD encoding have advantage over HA encoded features. This is particularly useful in datasets with a large number of action classes.

For a fair and consistent evaluation, the results are compared with the most recent studies in the literature. We also include a brief description of their methodology for ease of comparison. Studies were primarily divided based on the type of feature encoding type employed.
                              
                                 1.
                                 HA based encoding

The corresponding results are shown in Table 4
                                    . The performance of dense trajectories [2] on HMDB51 and UCF50 is 84.5% and 46.6%, respectively, as reported in [6]. The performance by using the proposed ordered trajectories on these datasets is 85.5% and 47.3%, respectively. This is nearly 0.7–1% (absolute) better than for the actual dense trajectories. The results obtained by the Spatio-Temporal Pyramidal approach of dense trajectories is 85.6% and 48.3% respectively. This is 0.1–1% (absolute) better than our proposed technique. However, it has to be noted that our results are obtained using only 5 channels while the Spatio-Temporal Pyramidal approach uses 30 channels. The length of the feature vectors in some of these channels can also be as high as 3–8 times than those used in the original dense trajectories or the proposed ordered trajectories.

Shi et al. 2013 [26] suggested that random selection of 10,000 dense trajectories can yield 83.3% and 47.6%, respectively. With the proposed technique, we see that only less important information, such as on the background, is omitted, as shown in a few examples in Fig. 7.

VLAD based encoding

The corresponding results are shown in Table 5
                                    . Most recently, Jain et al. [3] employed the VLAD encoding on the HMDB51 dataset and reported a recognition rate of 52.1%. This can be due to two reasons: firstly, due to the combination of dense trajectory results and ω-trajectories (motion compensated dense trajectories) [3] results and, secondly, due to the VLAD encoding scheme. The same encoding scheme is used on the proposed ordered trajectory descriptors and included in the results in Table 5. Dense trajectories with VLAD encoding yield 48.0% [3] correct recognition, while ordered trajectories with VLAD encoding yield 49.9%. It can be observed that the results for the proposed ordered trajectories are 1.9% (absolute) better when VLAD encoding is used. Similar to the setup used in Jain et al. [3], we use the proposed ordered trajectories in conjunction with dense trajectories and obtain 53.3%.

This section presents results obtained by taking improved dense trajectories [33] as base trajectories. The corresponding results are shown in Table 6
                        . Improved dense trajectories are an improved version of the dense trajectories obtained by estimating camera motion by matching feature points between frames using SIFT descriptors and computing dense optical flow. The obtained matches are used to estimate a homography with RANSAC. Further, a human detector was used to separate motion due to humans from camera motion. The estimate is also used to cancel out possible camera motion from the optical flow. This technique has been shown to improve significantly the motion-based descriptors such as MBH and HOF. Oneata et al. [47] used only the MBH descriptors of improved trajectories in a Spatio-Temporal Pyramidal (6 volumes in total) with SURF descriptors from every tenth frame for action recognition. Both [33,47] use FV encoding.

Initially, we follow the experimental set-up described in Wang and Schmid [33] to compute the improved trajectories and obtained Fisher Vectors. Upon fusing (concatenating) the ‘ordered trajectories’ with the improved trajectories, we find that it results in better recognition rates than those reported by the improved recognition rates by 1.5% (absolute). Details are shown in Table 6. As ordered trajectories are long duration trajectories, and improved trajectories are similar to the shorter base dense trajectories, we believe this supports our hypothesis that information carried by the ordered trajectories is complementary. This result has been obtained using only the camera motion compensated improved trajectories, without any human detector.

The performance of the proposed ordered trajectories for different values of L is now discussed. The recognition rates obtained on the HMDB51 dataset for different values of L are shown in Table 7
                           . Two observations are made. Firstly, the ordered trajectories are equal or better than the improved dense trajectories for different values of L. This supports our hypothesis that longer duration (L
                           +1) trajectories are richer than base trajectories with duration L. Secondly, the best results are obtained for L
                           =15. This is in line with the observations made by Wang et al. [6] and their choice of L
                           =15 for general usage.

In this section, we show some results that reinforce our hypothesis that trajectories of objects with longer duration (ordered trajectories) tend to contain richer information. All experiments for this section are conducted using improved dense trajectories without human detection [33]. We refer to OT
                           
                              L
                              +1 as ordered trajectories, having duration (L
                           +1) selected from improved dense trajectories; OT
                           
                              L
                              +2 as ordered trajectories, having duration (L
                           +2) selected from OT
                           
                              L
                              +1, and so on. Further, we define a ratio factor r
                           
                              i
                            as
                              
                                 (15)
                                 
                                    
                                       r
                                       i
                                    
                                    =
                                    
                                       
                                          N
                                          
                                             O
                                             
                                                T
                                                
                                                   L
                                                   +
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          N
                                          L
                                       
                                    
                                 
                              
                           where 
                              
                                 N
                                 
                                    O
                                    
                                       T
                                       
                                          L
                                          +
                                          i
                                       
                                    
                                 
                              
                              =
                           
                           number of ordered trajectories (OT
                           
                              L
                              +
                              i
                           ) and N
                           
                              L
                           
                           =number of improved dense trajectories with L.
                        

Similar to a compression factor, a lower value of r
                           
                              i
                            gearing towards 0 indicates a smaller number of ordered trajectories, yet yielding competitive performance to the base trajectories. A distribution of ratios, r
                           
                              i
                            s (Eq. (15)) for OT
                           
                              L
                              +1, OT
                           
                              L
                              +2 and OT
                           
                              L
                              +3 for HMDB51 and UCF101 datasets is shown in Figs. 8 and 9
                           
                           , respectively. At a first glance, it can be observed that in many videos, the number of ordered trajectories is about half the number of the base improved dense trajectories. In some videos, the amount of ordered trajectories is even less than half. This can be very useful, particularly in large data classifications. In those cases where only a few ordered trajectories are detected, we observe that the base trajectories are themselves few in number or detected in distant segments. Surely, in such cases the chances of finding longer duration trajectories are low. Moreover, in some classes such as ‘Playing flute’, where there is hardly any motion detected at all, the base trajectories are very scant.

Further, it can be observed that the number of videos with a ratio r
                           
                              i
                           
                           <0.5 tends to increase (i.e. the number of longer duration trajectories decreases) when the proposed technique is applied recursively. For example, the number of OT
                           
                              L
                              +3 is lower than the number of OT
                           
                              L
                              +2, which in turn is lower than the number of OT
                           
                              L
                              +1. However, ordered trajectories are observed to perform better than the actual baseline trajectories, as shown in Table 8
                           . Moreover, when used in conjunction with base trajectories, they are complementary and an improvement in performance is observed in all three datasets. These experiments quantitatively support that objects with longer trajectories contain richer information than base trajectories of fixed length.

The performance of OT
                           
                              L
                              +2 is better than base trajectories by 0.1–1.9% (absolute), but slightly lower than OT
                           
                              L
                              +1 by 0.3–0.5% (absolute). This indicates that our proposed selection of ordered trajectories – from base or ordered trajectories – is valid and indicative of the selection of a richer set of trajectories.

Our hypothesis of searching for longer duration trajectories of moving objects has close similarities with the domain of moving object tracking. Moving object tracking is composed of obtaining ‘tracks’ for salient/interest objects and then ‘linking’ them later on, in the event of occlusion, loss of tracking, etc. to form longer trajectories of the objects. However, our proposed technique has the following novelties:
                           
                              •
                              On the choice of ‘tracks’

Generally, in moving object tracking, ‘tracks’ are obtained for objects that are initialised in the beginning or by suitable techniques to select salient/interest objects. Usually, in human action recognition, human body parts are the most salient or main object of interest. Murthy et al. [50] detect human body parts in each frame and their parts were ‘linked’ by the Hungarian algorithm [31] to yield longer trajectories – so called body part trajectories. Fisher Vector encoding was used to construct the feature vectors. The performance is shown in Table 9
                                 . On all three benchmark datasets, improved dense trajectories were found to perform better than body parts and their trajectories. Hence, our choice of dense trajectories as base trajectories to find longer duration trajectories can be expected to perform better than general moving object tracking. Moreover, dense trajectories [6] are also shown to perform better than the KLT tracker [1] that constructed KLT trajectories by selecting 100 interest points in each frame.

On the choice of ‘linking’

A popular technique for linking ‘tracks’ of moving objects is by choice of a suitable cost function and an optimisation algorithm to minimise it. Cost functions are generally based on temporal, kinematics and appearance [29]; colour histogram matching [51], or mean colour matching [52] of the tracks. Our cost function is based on kinematics (object positions only). As we cannot initialise manually any particular object as our primary interest, we did not include colour or appearance in the current version of our work on longer trajectories. However, in moving object tracking, the primary objects/targets of interest are initialised in the first frame and/or on consecutive frames based on combination of detections that are formed from either background subtraction or frame differences. So, appearance, colour etc. features are very useful to locate/link the objects in the consecutive frames in the moving object tracking domain, but not in the current application.

For a typical video of 407 frames (duration of 13s) and the same computation conditions as in Section 5.1.4, 1004 body part interest points were detected in the static video frames. Using the Hungarian algorithm, 4915 body part trajectories are generated in 39.3s by using the technique proposed by Murthy et al. [50]. However, using the proposed search algorithm, longer duration trajectories were generated in 0.6s only from the original 23,748 dense trajectories. This shows the efficiency of our algorithm in terms of computation time.

@&#FUTURE WORK@&#

Recently, Basharat et al. [53] have reported computational efficiency by proposing a greedy assignment algorithm significantly faster than the Hungarian algorithm. In future, we will investigate its feasibility in our application. Local descriptors such as HOG are based on appearance. So, matching HOG descriptors is similar to integrating appearance into the cost function. This will also be undertaken in future.

@&#CONCLUSIONS@&#

A technique to capture motion characteristics of objects with longer duration has been proposed. It computes base trajectories and selects only a few from them, constituting trajectories of objects with longer duration. These selected trajectories are termed ordered trajectories. Local descriptors of these ordered trajectories are found to yield better performance than that obtained by the original base trajectories. Moreover, information other than the main objects of interest captured by the dense trajectories is also found out to be removed effectively by the proposed technique.


                     
                        
                           
                              Video corresponding to Fig. 7 (e)
                           
                           
                        
                     
                     
                        
                           
                              Video corresponding to Fig. 7 (a)
                           
                           
                        
                     
                     
                        
                           
                              Video corresponding to Fig. 7 (b)
                           
                           
                        
                     
                     
                        
                           
                              Video corresponding to Fig. 7 (d)
                           
                           
                        
                     
                  

Supplementary data to this article can be found online at http://dx.doi.org/10.1016/j.imavis.2015.06.009.

@&#REFERENCES@&#

