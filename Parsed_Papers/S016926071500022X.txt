@&#MAIN-TITLE@&#Improvement of retinal blood vessel detection using morphological component analysis

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A novel scheme for extracting retinal blood vessels based on morphological component analysis (MCA) algorithm is presented in this paper.


                        
                        
                           
                           We separate lesions from retinal images to improve the final vessel map results.


                        
                        
                           
                           The Morlet Wavelet Transform is used to enhance retinal blood vessels.


                        
                        
                           
                           Adaptive thresholding is employed in order to segment retinal vessels.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Retinal blood vessel

Diabetic retinopathy

Morphological component analysis (MCA)

Morlet Wavelet Transform

Adaptive thresholding

@&#ABSTRACT@&#


               
               
                  Detection and quantitative measurement of variations in the retinal blood vessels can help diagnose several diseases including diabetic retinopathy. Intrinsic characteristics of abnormal retinal images make blood vessel detection difficult. The major problem with traditional vessel segmentation algorithms is producing false positive vessels in the presence of diabetic retinopathy lesions. To overcome this problem, a novel scheme for extracting retinal blood vessels based on morphological component analysis (MCA) algorithm is presented in this paper. MCA was developed based on sparse representation of signals. This algorithm assumes that each signal is a linear combination of several morphologically distinct components. In the proposed method, the MCA algorithm with appropriate transforms is adopted to separate vessels and lesions from each other. Afterwards, the Morlet Wavelet Transform is applied to enhance the retinal vessels. The final vessel map is obtained by adaptive thresholding. The performance of the proposed method is measured on the publicly available DRIVE and STARE datasets and compared with several state-of-the-art methods. An accuracy of 0.9523 and 0.9590 has been respectively achieved on the DRIVE and STARE datasets, which are not only greater than most methods, but are also superior to the second human observer's performance. The results show that the proposed method can achieve improved detection in abnormal retinal images and decrease false positive vessels in pathological regions compared to other methods. Also, the robustness of the method in the presence of noise is shown via experimental result.
               
            

@&#INTRODUCTION@&#

Retinal vessel segmentation and quantitative measurement of vessel variations is crucial in many research efforts related to vascular features. Analysis of vascular structures could be used to diagnose several diseases such as diabetic retinopathy, glaucoma and hypertension. In many clinical investigations, segmentation of retinal blood vessel becomes a prerequisite for the analysis of vessel parameters such as tortuosity and vessel width. Manual segmentation of blood vessels is a time consuming task that requires remarkable skills. Therefore, the development of algorithms for automatic vessel segmentation and vessel diameter estimation is of paramount importance. It is commonly acknowledged in the medical community that the first stage in the development of a computer-assisted diagnostic system is the automatic quantification of retinal vessels [1].

Retinal vessel segmentation is still a challenging issue that has been widely studied in the literature. These studies can be classified into six categories: (1) matched filtering, (2) multi-scale algorithms, (3) pattern recognition methods, (4) vessel tracking, (5) model-based techniques and (6) mathematical morphology [1].

In matched filtering methods, retinal images are filtered by various vessel-like kernels which are designed to model a specific feature in the image at different positions and orientations. The presence of the desired feature is recognized using the matched filter response [1]. Jiang and Mojon [2] proposed a method based on a verification-based multi-threshold probing scheme. In this method, the image was probed with different thresholds and a vessel map was obtained by combining images derived from probed thresholds followed by post-processing algorithms. The method was evaluated on the DRIVE dataset, reporting an average accuracy of 0.92 and an area of 0.94 under the ROC curve. In [3] a 2D Gaussian matched filter was used to enhance the retinal images and simplified pulse coupled neural network (PCNN) was employed to segment the blood vessels by firing neighborhood neurons. Then, a 2D Otsu thresholding was used to search for the best segmentation results. The final vessel map was obtained through the analysis of regional connectivity. The evaluation of the methodology yielded a true positive rate of 0.80 and a false positive rate of 0.02 on the STARE dataset. Bankhead et al. [4] proposed a method based on Wavelet Transform. The methodology achieved a sensitivity of 0.7027 and specificity of 0.9717 on the DRIVE dataset. A method based on Gabor Wavelet and multilayered thresholding was proposed in [5]. The evaluation of the method on the DRIVE and STARE datasets achieved an average accuracy of 0.9502. The objective of the multi-scale approaches is to detect vessels with varying widths. Vlachos and Dermatas [6] proposed a multi-scale line tracking vessel detection method, which started from seed points derived from a brightness selection rule from a normalized histogram, and terminated when a cross-sectional profile condition became invalid. The multi-scale confidence image map was achieved by combining the multi-scale line tracking results. The final vessel network was derived from the quantization map of the multi-scale confidence matrix followed by a post-processing step which removed erroneous artifacts. The method attained an average accuracy of 0.92, a sensitivity of 0.74 and a specificity of 0.95. A vessel detection method based on line detection was proposed in [7]. This algorithm is based on the fact that changing the length of a basic line detector produces line detectors with varying scales. The final vessel map was obtained by combining line responses at varying scales. The method was evaluated on the DRIVE and STARE datasets, yielding an average accuracy of 0.9407 and 0.9324, respectively.

Pattern recognition methods are divided into two subclasses: supervised and unsupervised methods. Supervised methods use some prior information to create the vessel map, while detection of vessels in the unsupervised methods is performed without any prior labeling information. Niemeijer et al. [8] created a feature vector comprising of the green channel of the image and the responses of Gaussian matched filter. Then, the K-Nearest Neighbor (KNN) algorithm was used to estimate the probability map. Finally, the retinal vessel map was created by thresholding the probability map. Staal et al. [9] introduced an algorithm based on the extraction of image ridges, which coincided approximately with vessel centerlines. With line elements, the image was partitioned into patches by assigning each image pixel to the closest line element. A feature vector was created for each pixel using the patch properties and the line elements as inputs to the KNN classifier. In [10] a method based on radial projection and semi-supervised self-training was proposed for vessel segmentation using SVM. The vessel centerlines were located using radial projection and the major structure of vessels was extracted by applying a semi-supervised self-training classifier. The average accuracy, sensitivity and specificity were 0.94, 0.74 and 0.97, for DRIVE dataset and 0.94, 0.72 and 0.97 for STARE dataset, respectively. Kande et al. [11] proposed an unsupervised fuzzy-based vessel segmentation algorithm. In this method, first the contrast of retinal images was enhanced by a matched filter, and then a weighted fuzzy C-means clustering algorithm was used to identify the vascular tree structures. The combination of 2-D Gabor Wavelet and supervised classification was employed by Soares et al. [12] for retinal vessel segmentation. A feature vector comprising of pixel intensity and Gabor Wavelet Transform responses at multiple scales was used as inputs for a Gaussian mixture model classifier to classify each pixel as either a vessel or non-vessel pixel. The method achieved an average accuracy of 0.9466 and 0.9480 on the DRIVE and STARE datasets, respectively. A method based on neural networks was proposed in [13], which used a 7-d feature vector composed of moment invariant and gray level features. Finally a neural network was employed for the purpose of training and classification. The method was evaluated on the DRIVE and STARE datasets, yielding an accuracy of 0.9452 and 0.9526, respectively. Ricci and Perfetti [14] introduced a method based on line operators and SVM classifier for pixel classification. The line operator was based on the evaluation of the average gray level along lines of fixed length that passed through the target pixel at different directions. The evaluation of the method yielded an average accuracy of 0.9563 and 0.9584 on the DRIVE and STARE datasets, respectively.

The vessel tracking methods segment vessel map between two points based on local information. An automatic model-based algorithm for vessel segmentation was proposed in [15]. The algorithm utilized a parametric model of a vessel which exploited geometric properties for parameter definitions.

In model-based approaches, the retinal vessel map was extracted by applying the explicit vessel models. Diri et al. [16] proposed a method for retinal vessel segmentation using a Ribbon of Twins active contour model. This method used two pairs of contours to capture each vessel edge, while maintaining the width consistency. The method proposed by Lam et al. [17] was based on regularization-based multi-concavity modeling. The method was evaluated on the DRIVE and STARE datasets, yielding an accuracy of 0.9472 and 0.9567, respectively. Espona et al. [18] proposed a vessel segmentation method based on classical snake in combination with blood vessel topological properties. The method achieved an accuracy, sensitivity and specificity of 0.9316, 0.6634 and 0.9682 on the DRIVE dataset, respectively.

Miri [19] proposed a vessel segmentation method based on Fast Discrete Curvelet Transform (FDCT) and multi-structure mathematical morphology. The contrast of the image was enhanced using FDCT and multi-structure morphological operations were used for vessel detection. The method achieved an accuracy, sensitivity and specificity of 0.9458, 0.7352 and 0.9795, respectively on the DRIVE dataset. Fraz et al. [20] proposed a vessel segmentation method using a combination of vessel centerline detection and morphological bit plane. The centerlines were extracted using a first order derivative of a Gaussian filter. A multidirectional morphological top-hat operator with linear structural elements followed by bit plane slicing of the vessel enhanced image was used to determine the shape and orientation of the vessels.

Nevertheless, one of the challenges in reliable segmentation of retinal blood vessels is the appearance of several structures in retinal images such as exudates, microaneurysms and hemorrhages. These components degrade the performance of the vessel detection algorithm. To overcome this problem, it is recommended to separate these areas from retinal images before applying the vessel map segmentation algorithm. Recently, decomposing signals into their building components has attracted a growing attention to signal and image processing. Successful separation of signal content is pivotal to its analysis, enhancement and compression. A number of approaches have been presented to expand this idea [21–27]. In recent papers [28–30], a new decomposition method called Morphological Component Analysis (MCA) that is based on sparse representation of signals has been presented. In the MCA, it is supposed that each signal is a linear mixture of different layers, or Morphological Components, which are distinctive in terms of morphology. Moreover, a range of decomposition applications including texture separation from non-texture parts [19,28,31,32], denoising [28,33], inpainting applications [34] and medical image processing [35] have been investigated by researchers.

One way to detect retinal lesions is the use of segmentation algorithms. Several segmentation algorithms have been proposed in the literature with each focusing on detecting a certain type of lesion [36–39]. In order to detect and remove all lesions from retinal images, different segmentation algorithms are needed, since the lesions may be different in terms of color and size. In this paper, a different approach to lesion detection has been employed. The main contribution of the proposed method is using MCA to separate lesions from vessels and handle noise. Since vessels and lesions are morphologically distinct, MCA can be utilized to separate different lesions without any segmentation algorithms. In other words, the lesions can be separated using the MCA algorithm without employing segmentation algorithms. Then, the final vessel map is obtained from a clean retinal image using a segmentation algorithm. The removal of lesions from retinal images can improve the results of vessel map segmentation.

Experimental results have shown the efficacy of the proposed algorithm for vessel map segmentation since it has a high segmentation accuracy not only in the normal retinal images but also in the images with signs of diabetic retinopathy. Also, we demonstrate that in addition to lesion separation, the noise is well removed from the retinal images since MCA naturally handles the data disturbed by additive noise. Thus, the proposed vessel detection algorithm is effectively robust to the presence of noise in the image.

The rest of the paper is organized as follows. In Section 2 a brief review of the concept of MCA algorithm and the dictionaries used in it is presented. The proposed vessel detection method is presented in Section 3. Experimental results are provided in Section 4. Finally, in Section 5, concluding remarks are stated.

In the past decade, sparsity has developed as one of the primary concepts in a variety of signal-processing applications such as restoration, feature extraction, source separation and compression. For a long time, sparsity has attracted researchers about theoretical and practical signal properties in several areas of applied mathematics such as computational harmonic analysis, statistical estimation and theoretical signal processing [40].

Starck et al. [28,29] proposed a new decomposition method, i.e. Morphological Component Analysis (MCA), based on sparse representation of signals. In the MCA, it is supposed that each signal is a linear mixture of different layers, namely Morphological Components, which are distinctive in terms of morphology. For this method to be successful, it is assumed that a dictionary of atoms is available for separation of every component that allows its construction by a sparse representation. The signal content is often complex, and there is no single dictionary that is optimal enough to efficiently represent all the signal components. Thus, it is presumed that each morphological component of the signal is sparsely represented in a specific transform domain. When all transforms (each linked to a morphological component) are aggregated in a single dictionary, each brings about the sparse representation of the part of the signal it is serving, yet still inefficient in representing other contents in the mixture.

Here, we show how to decompose a signal into its building components using the MCA algorithm proposed by Stark et al. [29], starting with the model of the problem. Since the choice of dictionaries plays a pivotal role in separating different components from each other, Shearlet transform [41] and Non-Subsampled Contourlet transform [42] which are applied to MCA algorithm will be discussed later.

Suppose that the sample signal y
                        ∈
                        R
                        
                           N
                         is the linear combination of K morphological components x
                        
                           k
                         and it is possibly noisy:
                           
                              (1)
                              
                                 
                                    
                                       y
                                    
                                    =
                                    
                                       ∑
                                       
                                          k
                                          =
                                          1
                                       
                                       K
                                    
                                    
                                       
                                          
                                             x
                                          
                                          k
                                       
                                       +
                                       ε
                                    
                                     
                                    
                                       σ
                                       ε
                                       2
                                    
                                    =
                                    
                                       var
                                    
                                    [
                                    ε
                                    ]
                                    <
                                    +
                                    ∞
                                 
                              
                           
                        
                     

The MCA framework aims at solving the inverse problem associated with the recovering of components (x
                        
                           k
                        )
                           k=1, …, K
                         from their observed linear mixture. MCA assumes that each component x
                        
                           k
                         can be sparsely represented in an associated basis Φ
                        
                           k
                        , i.e.
                           
                              (2)
                              
                                 
                                    
                                       
                                          x
                                       
                                       k
                                    
                                    =
                                    
                                       
                                          ϕ
                                       
                                       k
                                    
                                    
                                       
                                          α
                                       
                                       k
                                    
                                     
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    K
                                 
                              
                           
                        where α
                        
                           k
                         is a sparse coefficient vector (that is, only a few coefficients are large enough). Thus, by aggregating several transforms (Φ
                        1, …, Φ
                        
                           k
                        ), a dictionary can be developed in a way that for each k, the representation of x
                        
                           k
                         in Φ
                        
                           k
                         will be sparse, but not in other Φ
                        
                           l
                         for l
                        ≠
                        k. That is, the sub-dictionaries (Φ
                        1, …, Φ
                        
                           k
                        ) need to be mutually incoherent. Therefore, the sub-dictionary Φ
                        
                           k
                         has a discriminating role in different types of content, favoring the component x
                        
                           k
                         over all other parts. Drawing on recent advances in computational harmonic analysis, the efficacy of a number of novel representations such as the Wavelet Transform, Curvelet, Contourlet, steerable or complex Wavelet pyramids in sparse representation of certain kinds of signals and images have been shown. Thus, with regard to the decomposition, the dictionary is developed by taking the union of one or several (sufficiently incoherent) transforms, with each corresponding to an orthogonal basis.

The augmented dictionary (Φ
                        1, …, Φ
                        
                           k
                        ), nonetheless, presents an over-complete representation of x. Given that the number of unknowns is greater than the number of equations, the system x
                        =
                        Φα is underdetermined. In [28,29] a method of estimating the components (x
                        
                           k
                        )
                           k=1,…,K
                         has been proposed which is based on solving the following constrained optimization problem:(3)
                           
                              
                                 
                                    
                                       min
                                    
                                 
                                 
                                    
                                       α
                                       1
                                    
                                    ,
                                    …
                                    ,
                                    
                                       α
                                       k
                                    
                                 
                              
                              
                                 ∑
                                 
                                    k
                                    =
                                    1
                                 
                                 K
                              
                              
                                 |
                                 |
                                 
                                    
                                       α
                                    
                                    k
                                 
                                 |
                                 
                                    |
                                    p
                                    p
                                 
                              
                               
                              s
                              .
                              t
                              .
                              
                                 
                                    
                                       
                                          y
                                          −
                                          
                                             ∑
                                             
                                                k
                                                =
                                                1
                                             
                                             K
                                          
                                          
                                             
                                                
                                                   Φ
                                                
                                                k
                                             
                                             
                                                
                                                   α
                                                
                                                k
                                             
                                          
                                       
                                    
                                 
                                 2
                              
                              ≤
                              σ
                           
                        where 
                           
                              |
                              |
                              
                                 α
                              
                              |
                              
                                 |
                                 p
                                 p
                              
                           
                         is sparsity promotion (the most interesting regime is for 0≤
                        p
                        ≤1) and σ is typically chosen as τσ
                        
                           ɛ
                        , where 
                           
                              
                                 σ
                                 ε
                                 2
                              
                           
                         is the noise variance and τ is a constant. The constraint in this optimization problem is related to the presence of noise and the model used for imperfections. In the absence of any noise and the exactness of the linear superposition model (σ
                        =0), the inequality constraint replaces with an equality constraint.

In general, finding a solution to problem (3), especially for p
                        <1 is very difficult. It is even an NP-Hard problem for p
                        =0. However, if all component coefficients α
                        
                           l
                         except for the kth one are constant, then a solution can be obtained by hard thresholding (for p
                        =0) or soft thresholding (for p
                        =1) of the coefficients of the marginal residuals 
                           
                              
                                 
                                    r
                                 
                                 k
                              
                              =
                              
                                 y
                              
                              −
                              
                                 ∑
                                 
                                    l
                                    ≠
                                    k
                                 
                              
                              
                                 
                                    
                                       Φ
                                    
                                    l
                                 
                                 
                                    
                                       α
                                    
                                    l
                                 
                              
                           
                         in Φ
                        
                           k
                        . Other components, free of these marginal residuals r
                        
                           k
                        , contain potentially significant information about x
                        
                           k
                        . This concept is derived from the coordinate relaxation algorithm [43], which is cycled through the components at each iteration, and applies a thresholding to the marginal residuals.

In addition to coordinate relaxation, iterative thresholding with varying thresholds is another critical ingredient of MCA. As such, MCA can be regarded as a stage-wise hybridization of matching pursuit (MP) [44] with block coordinate relaxation (BCR) [43] that enables it to approximately solve (3). Therefore, MCA is a salient-to-fine process in which the most salient contents of each morphological component is calculated iteratively at each iteration. Then, these estimates are gradually refined as the threshold λ is reduced to λ
                        min.

As mentioned earlier, the choice of dictionaries plays an important role in separating content of signals. Obviously, the best dictionary is the one that leads to the sparsest representation. In this study, known transforms have been used for representing image components. Thus, a brief description of these transforms is given here.

The important information of an image is often located around its edges which separate image objects from the background. These features correspond to the anisotropic structures in the image [41]. Since Wavelets have isotropic support, they fail to capture image geometric information such as lines and curves. If the basis of a transform is nearly parallel to the image edges, they can exploit the anisotropic regularity of a surface along edges [45]. Shearlet Transform is designed to efficiently encode such anisotropic features [41].

Scaling of the Shearlets is according to a parabolic scaling law which is encoded in matrices A
                        2j
                         or 
                           
                              
                                 
                                    
                                       A
                                    
                                    ˜
                                 
                                 
                                    2
                                    j
                                 
                              
                           
                        , exhibiting directionality by parameterizing slope encoded in the shear matrices S
                        
                           k
                         or 
                           
                              
                                 
                                    
                                       S
                                    
                                    ˜
                                 
                                 k
                              
                           
                        , which are defined by (4) and (5) for j
                        ≥0, k
                        ∈
                        Z:
                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      A
                                                   
                                                   
                                                      2
                                                      j
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     2
                                                                     j
                                                                  
                                                               
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         
                                                            
                                                               0
                                                            
                                                            
                                                               
                                                                  
                                                                     2
                                                                     
                                                                        j
                                                                        /
                                                                        2
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                ,
                                                 
                                                
                                                   
                                                      S
                                                   
                                                   k
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               1
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                         
                                                            
                                                               0
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         A
                                                      
                                                      ˜
                                                   
                                                   
                                                      2
                                                      j
                                                   
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     2
                                                                     
                                                                        j
                                                                        /
                                                                        2
                                                                     
                                                                  
                                                               
                                                            
                                                            
                                                               0
                                                            
                                                         
                                                         
                                                            
                                                               0
                                                            
                                                            
                                                               
                                                                  
                                                                     2
                                                                     j
                                                                  
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                                ,
                                                 
                                                
                                                   
                                                      
                                                         S
                                                      
                                                      ˜
                                                   
                                                   k
                                                
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               1
                                                            
                                                            
                                                               k
                                                            
                                                         
                                                         
                                                            
                                                               0
                                                            
                                                            
                                                               1
                                                            
                                                         
                                                      
                                                   
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        for 
                           
                              ϕ
                              ,
                              ψ
                              ,
                              
                                 ψ
                                 ˜
                              
                              ∈
                              
                                 L
                                 2
                              
                              (
                              
                                 R
                                 2
                              
                              )
                           
                         the cone-adapted discrete Shearlet system 
                           
                              S
                              H
                              (
                              ϕ
                              ,
                              ψ
                              ,
                              
                                 ψ
                                 ˜
                              
                              ;
                              c
                              )
                           
                         is defined by (5). The parameter c is a positive constant which controls the sampling density.
                           
                              (5)
                              
                                 
                                    S
                                    H
                                    (
                                    
                                       ϕ
                                    
                                    ,
                                    
                                       ψ
                                    
                                    ,
                                    
                                       
                                          ψ
                                       
                                       ˜
                                    
                                    ;
                                    c
                                    )
                                    =
                                    
                                       Φ
                                    
                                    (
                                    
                                       ϕ
                                    
                                    ;
                                    
                                       c
                                       1
                                    
                                    )
                                    
                                       Ψ
                                    
                                    (
                                    
                                       ψ
                                    
                                    ;
                                    c
                                    )
                                    
                                       
                                          Ψ
                                       
                                       ˜
                                    
                                    (
                                    
                                       
                                          ψ
                                       
                                       ˜
                                    
                                    ;
                                    c
                                    )
                                    ,
                                 
                              
                           
                        where Φ is a scaling function and Ψ and 
                           
                              
                                 
                                    Ψ
                                 
                                 ˜
                              
                           
                         as Shearlets which are defined as follows:
                           
                              (6)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Φ
                                                
                                                (
                                                
                                                   ϕ
                                                
                                                ;
                                                c
                                                )
                                                =
                                                
                                                   
                                                      
                                                         
                                                            ϕ
                                                         
                                                         m
                                                      
                                                      =
                                                      
                                                         ϕ
                                                      
                                                      (
                                                      ⋅
                                                      −
                                                      c
                                                      m
                                                      )
                                                      :
                                                      m
                                                      ∈
                                                      
                                                         z
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   Ψ
                                                
                                                (
                                                
                                                   ψ
                                                
                                                ;
                                                c
                                                )
                                                =
                                                
                                                   
                                                      
                                                         
                                                            ψ
                                                         
                                                         
                                                            j
                                                            ,
                                                            k
                                                            ,
                                                            m
                                                         
                                                      
                                                      =
                                                      
                                                         2
                                                         
                                                            3
                                                            j
                                                            /
                                                            4
                                                         
                                                      
                                                      
                                                         ψ
                                                      
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         k
                                                      
                                                      
                                                         
                                                            A
                                                         
                                                         
                                                            2
                                                            j
                                                         
                                                      
                                                      ⋅
                                                      −
                                                      c
                                                      m
                                                      )
                                                      :
                                                      j
                                                      ≥
                                                      0
                                                      ,
                                                      |
                                                      k
                                                      |
                                                      ≤
                                                      [
                                                      
                                                         2
                                                         
                                                            j
                                                            /
                                                            2
                                                         
                                                      
                                                      ]
                                                      ,
                                                      m
                                                      ∈
                                                      
                                                         Z
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                       
                                          
                                             
                                                
                                                   
                                                      Ψ
                                                   
                                                   ˜
                                                
                                                (
                                                
                                                   
                                                      ψ
                                                   
                                                   ˜
                                                
                                                ;
                                                c
                                                )
                                                =
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  ψ
                                                               
                                                               ˜
                                                            
                                                         
                                                         
                                                            j
                                                            ,
                                                            k
                                                            ,
                                                            m
                                                         
                                                      
                                                      =
                                                      
                                                         2
                                                         
                                                            3
                                                            j
                                                            /
                                                            4
                                                         
                                                      
                                                      
                                                         
                                                            ψ
                                                         
                                                         ˜
                                                      
                                                      (
                                                      
                                                         
                                                            S
                                                         
                                                         k
                                                         Y
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  A
                                                               
                                                               ˜
                                                            
                                                         
                                                         
                                                            2
                                                            j
                                                         
                                                      
                                                      ⋅
                                                      −
                                                      c
                                                      m
                                                      )
                                                      :
                                                      j
                                                      ≥
                                                      0
                                                      ,
                                                      |
                                                      k
                                                      |
                                                      ≤
                                                      [
                                                      
                                                         2
                                                         
                                                            j
                                                            /
                                                            2
                                                         
                                                      
                                                      ]
                                                      ,
                                                      m
                                                      ∈
                                                      
                                                         Z
                                                         2
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Shearlets are obtained by applying translation, anisotropic scaling matrices A
                        2j and shear matrices S
                        
                           k
                         to fixed generating functions Ψ. The matrices A
                        2j and S
                        
                           k
                         lead to windows which can be elongated along arbitrary orientations, and the geometric structures of singularities in images can be efficiently represented by them [45]. Fig. 1
                         shows the tiling of frequency plane using Shearlet Ψ. As can be seen, Shearlet Ψ can provide a nearly optimal approximation for a piecewise smooth function f with C
                        2 smoothness except at points lying on C
                        2 curves.

The main objective of Contourlet Transform is to obtain an optimal approximation rate of piecewise smooth functions with discontinuities along twice continuously differentiable curves. Accordingly, it covers areas with smooth subsection contours [46]. The NSCT is a shift-invariant version of Contourlet Transform. The Contourlet Transform employs the low-pass filter for multi-scale decomposition, and the directional filter bank for directional decomposition. To achieve the shift-invariance and get rid of the frequency aliasing of the Contourlet Transform, the down-samplers and the up-samplers are eliminated during the decomposition and reconstruction of the image. The NSCT is built based on the non-subsampled pyramids filter banks (NSFB) and the non-subsampled directional filter banks (NSFB) [42,47], which is shown in Fig. 2
                        .

In this section, the proposed vessel detection algorithm based on component separation is discussed in detail. Here, the input of the developed system is a color retinal image taken by a fundus camera, and its output is the retinal vessel map. The proposed method is composed of three fundamental parts: (1) preprocessing, which involves green channel selection, the removal of useless parts of retinal images, and illumination enhancement, (2) retinal image cleaning, which includes removing lesions and noise from the retinal images and (3) vessel segmentation.

Among the color image components, green channel exhibits the best vessel-background contrast of the RGB-representation in retinal images, whereas the red channel can still be saturated, and the blue channel offers poor dynamic range [13]. With the purpose of vessel map segmentation, at first the green channel I
                           
                              G
                            is extracted from the RGB retinal images. The use of gray-level images instead of color-images decreases the computational time.

Retinal images normally contain a region of interest (ROI) at the center of the image, which is surrounded by a dark background. Given that only ROI pixels are used for vessel detection, these useless parts (i.e. the additional dark background) are removed from retinal images to accelerate further processing stages. To find the retinal ROI, the Otsu thresholding algorithm [48] is applied to the green channel of the retinal image. The resulting binary image is represented by one large connected region, which is the retina FOV. However, some missed labeled pixels on the retinal background and foreground are created. Theses noisy regions are removed through morphological opening and closing, respectively. Empirically, the size of the structuring element is assumed to be 7. The useless parts of the retinal image are removed by finding the bounding box which only contains retinal FOV. Finally, the cropped retinal image is resized to 512×512 pixels to accelerate further processing stages. The removal of useless parts of retinal images is shown in Fig. 3
                           .

Fundus images often contain background intensity variation caused by non-uniform illumination. This effect may degrade the performance of the vessel segmentation algorithm. To remove these background lightening variations, the retinal image background I
                           
                              B
                            is created by a median filter of size 30. Then, the enhanced retinal image I
                           
                              E
                            is computed by subtracting I
                           
                              B
                            from I
                           
                              G
                            according to (7). Finally the values of I
                           
                              E
                            are normalized to the range of 0 and 1.
                              
                                 (7)
                                 
                                    
                                       
                                          
                                             I
                                          
                                          E
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       =
                                       
                                          
                                             I
                                          
                                          G
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       −
                                       
                                          
                                             I
                                          
                                          B
                                       
                                       (
                                       i
                                       ,
                                       j
                                       )
                                       .
                                    
                                 
                              
                           
                        

As mentioned earlier, the abnormal signs of diabetic retinopathy make the detection of retinal vessels very difficult. Retinal lesions may be wrongly detected as vessels and may produce false positives in the final vessel map. Thus, the removal of retinal lesions before applying the vessel segmentation algorithm can significantly improve the final retinal vessel map. As shown in Fig. 4
                        , blood vessels appear as curved-like structures, whereas lesions appear as spot-like structures. Since vessels and lesions have different morphological structures, the MCA algorithm can be used to separate these components. In other words, we use the MCA algorithm to remove lesions from retinal images and produce clean images before applying vessel segmentation algorithm. For perfect separation of these components from each other using the MCA algorithm, it is crucial to choose two appropriate dictionaries, each of which sparsely represents one of the morphologically different components. In the following subsection, a description on the selected dictionaries has been given.

As mentioned in the preliminary section, for the MCA method to be successful, there should be a dictionary or a transform for every component to be separated that enables its construction through a sparse representation, even though it is highly inefficient in representing other contents of the mixture. Using appropriate dictionaries, each of which sparsely represents one of the components, the MCA algorithm can successfully separate the morphologically distinct components. In this paper, the authors intend to separate two structurally distinct components of retinal images, i.e. lesions and vessels. Thus, transforms known for sparse representation of either curved-like structures or spot-like structures were chosen. These dictionaries are highly structured and have fast implementation. In this section, a brief description of our candidate dictionaries is presented and then the MCA algorithm which uses the candidate dictionaries to decompose retinal images is discussed.

The blood vessels appear as curved-like structures in retinal images. The curved-like features correspond to the anisotropic structures of data, which can be distinguished by their location and orientation. Thus, the efficient representation of vessel parts requires a directional transform which is optimal for representing curved-like features in the image. Of many directional representation systems proposed in the last decades, Shearlet is considered to be the most versatile and successful one, as it has an extensive list of desirable properties. To name a few, note that Shearlet systems can be produced by only one function; they offer an exact resolution of the wavefront sets; they enable compactly supported analyzing elements; they are related to the fast decomposition algorithms, and they present an integrated treatment of the continuum and digital realm [41]. In this paper, Non-Subsampled Shearlet Transform (NSST) is used for representing vessel parts of retinal images. Using NSST, the retinal images were decomposed into 4 scales and 8 orientations in each level. Following the NSST decomposition, one low-pass image and 24 band-pass images were obtained, all of which have the same size of the input image.
                                 
                                    
                                       
                                       
                                       
                                          
                                             Algorithm 1: MCA decomposition algorithm
                                          
                                       
                                       
                                          
                                             1.
                                             Parameters: The image I
                                                
                                                   E
                                                 which is represented as a 1D vector, the dictionary 
                                                   
                                                      
                                                         Φ
                                                      
                                                      =
                                                      [
                                                      
                                                         
                                                            Φ
                                                         
                                                         v
                                                      
                                                      ,
                                                      
                                                         
                                                            Φ
                                                         
                                                         l
                                                      
                                                      ]
                                                   
                                                , number of iterations per layer N
                                                iter, stopping threshold λ
                                                
                                                   min
                                                .
                                          
                                          
                                             2.
                                             Initialize: number of sub-dictionaries K
                                                =
                                                2, 
                                                   
                                                      
                                                         Φ
                                                      
                                                      =
                                                      [
                                                      
                                                         
                                                            Φ
                                                         
                                                         v
                                                      
                                                      ,
                                                      
                                                         
                                                            Φ
                                                         
                                                         l
                                                      
                                                      ]
                                                   
                                                 where Φ
                                                
                                                   v
                                                 and Φ
                                                
                                                   l
                                                 correspond to NSST and NSCT, respectively. 
                                                   
                                                      
                                                         
                                                            Φ
                                                         
                                                         l
                                                         +
                                                      
                                                   
                                                 and 
                                                   
                                                      
                                                         
                                                            Φ
                                                         
                                                         v
                                                         +
                                                      
                                                   
                                                 are also pseudo-inverse of sub-dictionaries. Let 
                                                   
                                                      
                                                         k
                                                         *
                                                      
                                                      =
                                                      a
                                                      r
                                                      g
                                                      m
                                                      a
                                                      
                                                         x
                                                         k
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        Φ
                                                                     
                                                                     k
                                                                  
                                                                  
                                                                     y
                                                                  
                                                               
                                                            
                                                         
                                                         ∞
                                                      
                                                      k
                                                      =
                                                      1
                                                      ,
                                                      …
                                                      ,
                                                      K
                                                   
                                                ; set 
                                                   
                                                      λ
                                                      =
                                                      
                                                         λ
                                                         0
                                                      
                                                      =
                                                      m
                                                      a
                                                      
                                                         x
                                                         
                                                            k
                                                            ≠
                                                            
                                                               k
                                                               *
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        Φ
                                                                     
                                                                     k
                                                                  
                                                                  
                                                                     y
                                                                  
                                                               
                                                            
                                                         
                                                         ∞
                                                      
                                                   
                                                ; set y
                                                =
                                                I
                                                
                                                   E
                                                 and initial solution 
                                                   x
                                                
                                                
                                                   
                                                      v
                                                   
                                                
                                                =0, 
                                                   x
                                                
                                                
                                                   
                                                      l
                                                   
                                                
                                                =0.
                                          
                                          
                                             3.
                                             Perform N
                                                
                                                   iter
                                                 times:
                                          
                                          
                                             Part A – Update of x
                                                
                                                   v
                                                 assuming x
                                                
                                                   l
                                                 is fixed:
                                          
                                          
                                             
                                             
                                                – Calculate the residual r
                                                =
                                                y
                                                −
                                                x
                                                
                                                   
                                                      v
                                                   
                                                
                                                −
                                                x
                                                
                                                   
                                                      l
                                                   
                                                .
                                          
                                          
                                             
                                             
                                                – Calculate the NSST of x
                                                
                                                   
                                                      v
                                                   
                                                
                                                +
                                                r and obtain 
                                                   
                                                      
                                                         
                                                            α
                                                         
                                                         v
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         v
                                                         +
                                                      
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      +
                                                      
                                                         r
                                                      
                                                      )
                                                   
                                                .
                                          
                                          
                                             
                                             
                                                – Hard threshold the coefficient vector α
                                                
                                                   v
                                                 with the λ threshold and obtain 
                                                   
                                                      
                                                         
                                                            α
                                                            ˆ
                                                         
                                                         v
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                             
                                                – Reconstruct x
                                                
                                                   
                                                      v
                                                   
                                                 by 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         v
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         v
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  α
                                                               
                                                               ˆ
                                                            
                                                         
                                                         v
                                                      
                                                   
                                                .
                                          
                                          
                                             Part B – Update of x
                                                
                                                   l
                                                 assuming x
                                                
                                                   v
                                                 is fixed:
                                          
                                          
                                             
                                             
                                                – Calculate the residual r
                                                =
                                                y
                                                −
                                                x
                                                
                                                   l
                                                
                                                +
                                                x
                                                
                                                   v
                                                .
                                          
                                          
                                             
                                             
                                                – Calculate the NSCT of x
                                                
                                                   l
                                                
                                                +
                                                r and obtain 
                                                   
                                                      
                                                         
                                                            α
                                                         
                                                         l
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         l
                                                         +
                                                      
                                                      (
                                                      
                                                         
                                                            x
                                                         
                                                         l
                                                      
                                                      +
                                                      
                                                         r
                                                      
                                                      )
                                                   
                                                .
                                          
                                          
                                             
                                             
                                                – Hard threshold the coefficient vector α
                                                
                                                   l
                                                 with the λ threshold and obtain 
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  α
                                                               
                                                               ˆ
                                                            
                                                         
                                                         l
                                                      
                                                   
                                                .
                                          
                                          
                                             
                                             
                                                – Reconstruct x
                                                
                                                   l
                                                 by 
                                                   
                                                      
                                                         
                                                            x
                                                         
                                                         l
                                                      
                                                      =
                                                      
                                                         
                                                            Φ
                                                         
                                                         l
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  α
                                                               
                                                               ˆ
                                                            
                                                         
                                                         l
                                                      
                                                   
                                                .
                                          
                                          
                                             4.
                                             Update the threshold 
                                                   
                                                      λ
                                                      =
                                                      λ
                                                      ×
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     
                                                                        
                                                                           λ
                                                                           0
                                                                        
                                                                     
                                                                     
                                                                        τ
                                                                        
                                                                           σ
                                                                           ε
                                                                        
                                                                     
                                                                  
                                                               
                                                            
                                                         
                                                         
                                                            1
                                                            /
                                                            (
                                                            1
                                                            −
                                                            
                                                               N
                                                               
                                                                  i
                                                                  t
                                                                  e
                                                                  r
                                                               
                                                            
                                                            )
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          
                                             5.
                                             If λ
                                                >λmin, return to Step 2. Else, finish.
                                          
                                          
                                             6.
                                             Output: Morphological components 
                                                   x
                                                
                                                
                                                   v
                                                 and 
                                                   x
                                                
                                                
                                                   l
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           

The retinal lesions appear as spot-like structures in retinal images. Efficient representation of these structures requires a directional transform which is optimal for representing the areas. The Contourlet Transform achieves an optimal approximation rate of piecewise smooth functions with discontinuities along twice continuously differentiable curves. Therefore, it captures areas with smooth subsection contours [49]. In this paper, the Non-Subsampled Contourlet Transform (NSCT) is selected to represent the lesion parts of retinal images. It utilizes the Laplacian pyramid [50] to capture point discontinuities and directional filter banks with the aim of linking point discontinuities into linear structures. In the DFB stage, the McClellan Transform of filter derived from the VK book is used [51]. Using these filters, images were decomposed into 4 scales with 8 orientations in each level. Following a 4-level NSCT decomposition, one low-pass sub-band image and 24 band-pass directional sub-band images were obtained, all of which have the same size of the input retinal image.

As discussed in the previous subsections, NSST and NSCT provide optimally sparse expansions for curved-like structures and areas with smooth subsection contours, respectively. The MCA algorithm [29], which is used to separate vessels from lesions in the enhanced retinal image 
                              I
                           
                           
                              E
                           , is shown in Algorithm 1.

In this algorithm, x
                           
                              v
                            and x
                           
                              l
                            that are initialized to zero are the vessel and the lesion parts of the retinal image, respectively. In the first part of the algorithm, the lesion part 
                              x
                           
                           
                              l
                            is fixed and a vessel part x
                           
                              v
                            is sought. The component x
                           
                              l
                           , is removed from the residual r, and is likely to contain the salient information of x
                           
                              v
                            as 
                              
                                 
                                    
                                       Φ
                                    
                                    v
                                 
                              
                            optimally provides a sparse representation for curved-like structures. In the NSST decomposition, if a Shearlet with a specific scale and angle is approximately aligned along a curve, the corresponding coefficient in the α
                           
                              v
                            will be large. Otherwise, it would be close to zero. Then, a solution can be achieved by hard thresholding the coefficients α
                           
                              v
                            with threshold λ and choosing the largest coefficients 
                              
                                 
                                    
                                       
                                          
                                             α
                                          
                                          ˆ
                                       
                                    
                                    v
                                 
                              
                           . The initial value of the threshold λ
                           =
                           λ
                           0 can be automatically set to an adequately large value (λ
                           0
                           =
                           max
                           
                              k≠k*||Φ
                           
                              k
                           
                           y||∞ where 
                              
                                 
                                    k
                                    *
                                 
                                 =
                                 a
                                 r
                                 g
                                 m
                                 a
                                 
                                    x
                                    k
                                 
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Φ
                                                
                                                k
                                             
                                             
                                                y
                                             
                                          
                                       
                                    
                                    ∞
                                 
                              
                           ). Hard thresholding in the algorithm denotes component-wise thresholding: HT
                           
                              λ
                           (u)=
                           u
                           if|u|>
                           λ, and it is equal to zero otherwise. In the following part, similar steps are performed for the other component, i.e. lesion part x
                           
                              l
                            by choosing a sub-dictionary Φ
                           
                              l
                            which is appropriate for representing sparsely spot-like structures. Therefore, the most salient content of each morphological component is iteratively computed. The threshold λ is reduced across the iterations of the MCA algorithm. In a precise representation of the data with the morphological components, λ
                           min should be set to zero. However, MCA is naturally capable of handling data disturbed by additive Gaussian noise ɛ with bounded variance 
                              
                                 
                                    σ
                                    ε
                                    2
                                 
                              
                            as noted earlier. In fact, this algorithm is a coarse-to-fine iterative procedure, and the bounded noise can be controlled by ceasing iteration when the residual is at the noise level, thus λ
                           
                              min
                           
                           =
                           τ
                           
                              σɛ
                           , is chosen, where σɛ is the noise standard deviation and is known also τ is a constant, typically between 3 and 4. The robustness of the algorithm in the presence of additive noise will be shown in the next section. As such the algorithm can be potentially successful in separating the contents of the image, in such a way that 
                              
                                 
                                    
                                       Φ
                                    
                                    v
                                 
                                 
                                    
                                       
                                          
                                             α
                                          
                                          ˆ
                                       
                                    
                                    v
                                 
                              
                            is mainly the vessel and 
                              
                                 
                                    
                                       Φ
                                    
                                    l
                                 
                                 
                                    
                                       
                                          
                                             α
                                          
                                          ˆ
                                       
                                    
                                    l
                                 
                              
                            is mostly the lesion part. As noted earlier, this expectation is based on the assumptions according to which 
                              
                                 
                                    
                                       Φ
                                    
                                    v
                                 
                              
                            and Φ
                           
                              l
                            are highly efficient in representing one content type and yet highly ineffective in representing the other. In Fig. 5
                           , the separation of the vessel and the lesion parts by the MCA algorithm has been shown.


                           Fig. 6
                            shows the results of the vessel and lesion separation using NSST and NSCT. As it can be seen, the retinal lesions are completely separated from the vessels. The additional contents of the image which are not represented sparsely by these dictionaries are also allocated to the noise part.


                           Fig. 7
                            shows more examples of applying the MCA sparse decomposition algorithm to abnormal retinal images selected from the MESSIDOR dataset [52]. Fig. 7(a) depicts the original abnormal retinal images, and the results of lesion and vessel separation are shown in Fig. 7(b and c). As shown in Fig. 7, the MCA algorithm with the selected transforms can separate lesions from vessels in such a way that clean retinal images are prepared for further processing stage.

Blood vessels have Gaussian cross sections with varying width and orientation. In order to enhance these structures, the Morlet Wavelet ψ
                        
                           
                              M
                           
                         Transform, which is a multi-resolution analysis technique with a Gaussian kernel, is employed:
                           
                              (8)
                              
                                 
                                    
                                       
                                          ψ
                                       
                                       M
                                    
                                    (
                                    t
                                    )
                                    =
                                    e
                                    x
                                    p
                                    (
                                    j
                                    
                                       
                                          k
                                       
                                       0
                                    
                                    t
                                    )
                                    exp
                                    
                                       
                                          −
                                          
                                             1
                                             2
                                          
                                          |
                                          
                                             A
                                          
                                          t
                                          
                                             |
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              j
                              =
                              
                                 
                                    −
                                    1
                                 
                              
                           
                         and 
                           
                              
                                 A
                              
                              =
                              d
                              i
                              a
                              g
                              
                                 
                                    
                                       ε
                                       
                                          −
                                          1
                                          /
                                          2
                                       
                                    
                                    ,
                                    1
                                 
                              
                              ,
                              ε
                              >
                              1
                           
                         is a diagonal matrix that defines the anisotropy of the filter. The nonzero parameter k
                        0
                        ∈
                        R
                        2 is the wave vector of the plane wave (spatial frequency). The angular selectivity increases with |k
                        0|, and the use of anisotropy ϵ
                        >1 in the matrix A. As such, the modulus becomes a Gaussian elongated in the x direction [53]. We empirically set the ϵ parameter to 5 and k
                        0
                        =[0,2].

Before applying the Wavelet Transform to the vessel part of retinal images (x
                        
                           v
                        ), the green channel of the vessel image is inverted to make vessels brighter than the background. Then, retinal image x
                        
                           v
                         which is represented as a 1D vector, is decomposed by Morlet Wavelet ψ
                        
                           M
                         at scale a and direction θ as follows [53]:
                           
                              (9)
                              
                                 
                                    
                                       
                                          w
                                       
                                       ψ
                                    
                                    (
                                    
                                       b
                                    
                                    ,
                                    θ
                                    ,
                                    a
                                    )
                                    =
                                    
                                       c
                                       
                                          −
                                          1
                                          /
                                          2
                                       
                                    
                                    
                                       1
                                       a
                                    
                                    ∫
                                    
                                       
                                          
                                             ψ
                                          
                                          M
                                          *
                                       
                                       (
                                       
                                          a
                                          
                                             −
                                             1
                                          
                                       
                                       
                                          r
                                          
                                             −
                                             θ
                                          
                                       
                                       (
                                       
                                          t
                                       
                                       −
                                       
                                          b
                                       
                                       )
                                       )
                                       
                                          
                                             x
                                          
                                          v
                                       
                                       (
                                       t
                                       )
                                       
                                          d
                                          2
                                       
                                       
                                          t
                                       
                                    
                                 
                              
                           
                        where 
                           
                              c
                              ,
                              
                                 
                                    ψ
                                 
                                 M
                                 *
                              
                              ,
                              θ
                              ,
                              
                                 b
                              
                           
                         and a are the normalizing constant, complex conjugate Morlet Wavelet, rotation angle, displacement vector and scale parameters, respectively.

In each scale, the Wavelet Transform is applied over orientations from 0° to 180° with a step angle of 20°. We select the coefficients with maximum modulus over all directions as a response. Fig. 8
                         shows the maximum modulus over all directions at scale 2 and 3.
                           
                              (10)
                              
                                 
                                    
                                       
                                          M
                                       
                                       ψ
                                    
                                    (
                                    b
                                    ,
                                    a
                                    )
                                    =
                                    
                                       
                                          max
                                       
                                       θ
                                    
                                    |
                                    
                                       
                                          W
                                       
                                       ψ
                                    
                                    (
                                    
                                       b
                                    
                                    ,
                                    θ
                                    ,
                                    a
                                    )
                                    |
                                 
                              
                           
                        The final enhanced image I
                        
                           F
                         is computed as the maximum modulus of the coefficients obtained in all scales as follows
                           
                              (11)
                              
                                 
                                    
                                       
                                          I
                                       
                                       F
                                    
                                    
                                       
                                          max
                                       
                                       a
                                    
                                    
                                       
                                          M
                                       
                                       ψ
                                    
                                    (
                                    b
                                    ,
                                    a
                                    )
                                 
                              
                           
                        
                     

The retinal vessel map is achieved by thresholding the enhanced image I
                        
                           F
                        . The threshold value is computed by using the x value corresponding to the 0.88 of the Cumulative Density Function (CDF) of the enhanced image I
                        
                           F
                         obtained from its histogram. Since the vessel pixel percentage in the FOV is typically around 12–14% [4], the threshold value is set to the value with a CDF value of 88%. Fig. 7(d) shows the enhanced retinal images using the Morlet Wavelet transform and Fig. 7(e) depicts the final vessel map of the clean retinal images.

@&#EVALUATION@&#

To develop and test the retinal vessel segmentation algorithm, two publicly available datasets, DRIVE and STARE, with available gold-standard images were used.


                        DRIVE: The DRIVE (Digital Retinal Images for Vessel Extraction) [54] is a publicly available dataset, containing a total of 40 color fundus photographs. The images were taken by a Canon CR5 non-mydriatic 3-CCD camera with a 45° field of view (FOV). Each image was captured by 8 bits per plane at 768×584 pixels. The set of 40 images was divided into a test and training set both containing 20 images. All images were manually segmented by the observers.


                        STARE: The STARE dataset [55] contained 20 images for blood vessel segmentation. The images were captured by TopCon TRV-50 fundus camera at 35° field of view. Each image was captured by 8 bits per plane at 605×700 pixels. The observers manually segmented all the images.

@&#IMPLEMENTATION@&#

The proposed method was implemented by MATLAB 2013 and the algorithm was applied on the DRIVE and STARE datasets. In the preprocessing stage, the useless parts of retinal images were removed. Then, the green channel of the retinal image was resized to 512×512 pixels and the uneven illumination of the image was removed by median filter of size 30. At the next stage, the MCA algorithm was applied to the preprocessed images using NSST and NSCT Transforms with 4 resolutions and 8 directions for vessel and lesion parts, respectively. In the MCA algorithm, the number of iterations N
                        
                           iter
                         and τ were empirically set to 20 and 3, respectively. Experimental results have shown that increasing the number of iterations does not have any impact on the results of separation. The parameter λ
                        min is calculated based on the noise level of the images. Having separated lesions from vessels, the vessel images were inverted so that the vessels appeared brighter than the background. Then, the Morlet Wavelet Transform was used to decompose the image in 2 scales and several directions from 0° to 180° with a step angle of 20°. The final vessel map was obtained by thresholding the enhanced vessel image.

@&#RESULTS@&#

In order to evaluate the efficiency of the proposed method, the performance of the algorithm was measured by true positive (TP), false positive (FP), true negative (TN), and false negative (FN) metrics. TP is defined as the number of vessel pixels correctly detected in the retinal images; FP is the number of non-vessel points detected as vessel; TN is the number of non-vessel pixels correctly detected and FN is the number of vessel points detected as non-vessel points by the system. These metrics also help us obtain more meaningful performance measures such as sensitivity, specificity and accuracy as follows:
                           
                              (12)
                              
                                 
                                    s
                                    e
                                    n
                                    s
                                    i
                                    t
                                    i
                                    v
                                    i
                                    t
                                    y
                                    =
                                    
                                       
                                          T
                                          P
                                       
                                       
                                          T
                                          P
                                          +
                                          F
                                          N
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    s
                                    p
                                    e
                                    c
                                    i
                                    f
                                    i
                                    c
                                    i
                                    t
                                    y
                                    =
                                    
                                       
                                          T
                                          N
                                       
                                       
                                          F
                                          P
                                          +
                                          T
                                          N
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    a
                                    c
                                    c
                                    u
                                    r
                                    a
                                    c
                                    y
                                    =
                                    
                                       
                                          T
                                          P
                                          +
                                          T
                                          N
                                       
                                       
                                          T
                                          P
                                          +
                                          T
                                          N
                                          +
                                          F
                                          P
                                          +
                                          F
                                          N
                                       
                                    
                                 
                              
                           
                        The sensitivity reflects the ability of the algorithm to detect the vessel pixels; specificity is the ability to detect non-vessel pixels; and the accuracy is the proportion of identified vessel pixels which are true vessel pixels. In addition, the performance of the proposed method was measured by receiver operating characteristic (ROC) curve. An ROC curve plots the fraction of the true positive rate (TPR) versus false positive rate (FPR). TPR is the fraction of vessel pixels correctly detected as vessels, whereas FPR is the fraction of non-vessel pixels wrongly identified as vessels. The closer the curve approaches the top left corner, the better is the performance of the system. The area under the curve (AUC), which is equal to 1 for an optimal system, is considered to be a measure used for qualifying this behavior. The ROC curve of the proposed method was obtained by changing the threshold value of the vessel segmentation algorithm. The ROC curve for two DRIVE and STARE datasets are shown in Fig. 9
                        . The blue line represents the performance of the method on the DRIVE dataset and the red line corresponds to the performance of the method on the STARE dataset. The AUC was computed to be 0.9544 and 0.9526 for the DRIVE and STARE datasets, respectively.

Performance measures were calculated only based on FOV pixels. The performance of the proposed method for the images derived from the DRIVE and STARE datasets is shown in Table 1
                        . The two last rows of this table correspond to the average and standard deviation value of sensitivity, specificity and accuracy. The minimum and maximum values of these performance measurements are highlighted in bold. In order to compare the proposed method with other state-of-the-art methods, sensitivity, specificity and accuracy were used as measures of performance evaluation. Table 2
                         presents the results of performance comparisons in terms of sensitivity, specificity and accuracy on the DRIVE and STARE 0000datasets with the following published algorithms: Jiang and Mojon [2], Bankhead et al. [4], Akram and Shoab [5], Vlachos and Dermatas [6], Nguyen et al. [7], Niemeijer et al. [8], Staal et al. [9], You et al. [10], Kande et al. [11], Soares et al. [12], Marin et al. [13], Ricci and Perfetti [14], Delibasis et al. [15], Diri et al. [16], Lam et al. [17], Espona et al. [18], Miri and Mahloojifar [19], Fraz et al. [20]. All of these methods were briefly described in section I. The values of the performance measures shown in Table 2 were reported by the authors of each of the above mentioned papers. If the values are not available for a specific dataset, it is indicated by a gap in the table. The comparison of the proposed method with other approaches on the DRIVE and STARE datasets shows that the method proposed in this paper provides better results than most of the existing algorithms and is even superior to the second human observer's performance. The mean accuracy achieved by the proposed method is only outperformed by the method proposed by Ricci and Perfetti [14] on the DRIVE dataset. As shown in this table, the results of the application of the proposed method on the STARE dataset, which contains an abundant number of abnormal images, are comparable with other state-of-the-art methods. There are 10 abnormal images in the STARE dataset while the DRIVE dataset contains only 4 images related to pathology. The results demonstrate that separating lesions from vessels prior to vessel segmentation provides appropriate results, especially in images with pathology regions.

A common drawback of most of the state-of-the-art methods is that they tend to produce a false vessel detection around the pathological regions such as dark and bright lesions. This lowers the overall accuracy of the method especially on the STARE images. To demonstrate the robustness of the proposed method in the pathological conditions, we drew a subjective comparison between our method and some of the algorithms mentioned in Table 2. To this end, two abnormal retinal images, as shown in Fig. 10
                         were selected from the DRIVE dataset. The final vessel map of these images presented by [4,7–9,12,56] are shown in Fig. 11
                        . The segmentation methods of Niemeijer et al. [8], Martinez-Perez et al. [56] and Staal et al. [9] are accessible in the DRIVE website
                           4
                        
                        
                           4
                           
                              http://www.isi.uu.nl/Research/Databases/DRIVE/.
                        . We obtained the source code of Soares
                           5
                        
                        
                           5
                           
                              http://sourceforge.net/p/retinal/wiki/Main%20Page/.
                         et al. [12], Bankhead
                           6
                        
                        
                           6
                           
                              http://sourceforge.net/projects/aria-vessels/.
                         et al. [4] and Nguyen
                           7
                        
                        
                           7
                           
                              http://people.eng.unimelb.edu.au/thivun/projects/retinal_segmentation/.
                         et al. [7] methods from their websites. As shown in Fig. 11, the pathological conditions can affect the results of these methods. However, the separation stage can solve this problem as well.

To show the effect of the separating lesions from vessels on the vessel segmentation, several segmentation algorithms such as Soares et al. [12], Bankhead et al. [4] and Nguyen et al. [7] were applied to the separated retinal images. Having separated vessels from lesions of retinal images on the DRIVE and STARE datasets, we ran the mentioned algorithms on the clean retinal images. A comparison of the results of the proposed vessel detection algorithm and the above mentioned algorithms with and without separation stage is shown in Figs. 12 and 13
                        
                         for two abnormal images, as depicted in Fig. 10. Table 3
                         also represents the percentage of the proposed vessel detection algorithm and the algorithms proposed by [4,7,12] with and without separation stage. As can be seen, the separation stage significantly increases the overall accuracy of vessel segmentation algorithms.

To be thorough, it was decided to test the proposed vessel detection method with noisy images. Three different types of noise were added to the original retinal images as shown in Fig. 14
                        . The degraded images were segmented by the proposed vessel detection method. The review of literature on the effects of noise on processing of retinal images suggested that the use of Gaussian noise with 0 mean and 10−3 standard deviation [57,58] and Salt&Peppere noise affected 5% of the retinal image [59]. Two sets of noisy retinal images were constructed by adding Gaussian noise with a mean of 0 and a standard deviation of 10−3, Poisson noise, and Salt&Pepper noise with 5% density to the clean retinal images in the DRIVE and STARE datasets. The results of the application of the proposed vessel detection method on noisy images are presented in Table 4
                        . As it can be seen, the effects of noise do not degrade the performance of the proposed vessel detection method, significantly.

The selected transforms were successful in separating vessels and lesions in most of the retinal images, but in some images, the MCA algorithm was unable to distinctly separate these components. This limitation has been shown in Fig. 15
                        . As can be seen, although the Shearlet Transform has an acceptable performance in most parts of the image, some parts of vessel with high tortuosity are missed, appearing in the lesions part. Also, some large lesions could not be completely removed from the image by NSCT. These problems happened in images with severe diabetic retinopathy stage. Despite this problem, the results provided by the proposed approach are better than that of other existing approaches. To overcome this limitation, adaptive dictionaries can be used instead of global transforms to separate different components of retinal images.

@&#CONCLUSION@&#

In this paper, a novel vessel segmentation method based on morphological component analysis (MCA) algorithm is presented. The abnormal signs of retinal images complicated the vessel segmentation algorithm. Given the high ability of the MCA algorithm in separating image components, the use of this algorithm with appropriate transforms could remove lesions from retinal images. Therefore, the clean retinal images were prepared for vessel map detection. Removing lesions from retinal images could improve the results of vessel map segmentation. The experimental results indicate the ability of the proposed method in segmenting blood vessels in images with the signs of diabetic retinopathy. Moreover, the proposed method is robust to noise since the MCA algorithm is able to separate noise from the image in addition to morphological components. After removing lesions and noise from retinal images, the vessels are enhanced by the Morlet Wavelet Transform. In the last stage, the final vessel map is obtained through adaptive thresholding of Morlet responses. The average accuracy of the vessel segmentation on both DRIVE and STARE datasets is 95.25% and 95.75%, respectively. Despite the success of the MCA algorithm in separating lesions from vessels, there are some cases in which this algorithm does not perform well. This is especially the case in retinal images with severe diabetic retinopathy in which the lesions are very big or the tortuosity of vessels is high. Despite this problem, the proposed method outperforms other existing vessel segmentation methods and generated highly competitive results, both in terms of visual and performance measures, as compared to methods reported in the literature. To overcome the limitation of the algorithm, a learned dictionary can be used instead of pre-determined transforms to separate different components of retinal images. By learning dictionaries from the images, the complex components of retinal images can be captured well.

@&#REFERENCES@&#

