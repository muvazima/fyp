@&#MAIN-TITLE@&#An improved database synchronization mechanism for mobile data using software-defined networking control

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           SDN based batch level synchronization.


                        
                        
                           
                           Reduced response time.


                        
                        
                           
                           Live test results of obstacle and non-obstacle mode of 2 G and 3 G networks.


                        
                        
                           
                           IDBSync consumes fewer discharging units than the existing solutions.


                        
                        
                           
                           Vendor independency.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Mobile database

SDN

Synchronization

Replication

IDBSync

Batch level processing

@&#ABSTRACT@&#


               Graphical abstract
               
                  
                     
                        
                           Image, graphical abstract
                           
                        
                     
                  
               
            

@&#INTRODUCTION@&#

In this new era of information technology, wireless mobile communication is undergoing rapid growth triggered by information explosion and technology revolution. The next-generation wireless systems are expected to support high data rates, and several small-sized mobile devices with high computing capabilities will dominate the market [1]. According to the Cisco VNI forecast, mobile phone traffic reached 885 petabytes in the year 2012 and is predicted to reach 11.2 exabytes by the end of the year 2017 [2]. Cellular M2M connections, which have already grown into a significant market in the past years, are expected to increase annually by more than 30% from 2015 [3]. Considering these facts, the current systems lack efficient data archiving capabilities, and the incentives for data sharing are weak and conventional, which underlines the need for proper data management. The emergence of SDN has created networks free from vertical integration of the control plane and data plane in the same device [4], and thus, a decision made on an independent control plane is forwarded to devices embedded with the data planes. One of the characteristics of mobile devices is asymmetry with respect to communication. The bandwidth from server to clients is much greater than the bandwidth from clients to server. Mobile devices have limited storage capabilities and rely on battery power, and therefore, processing should be optimized such that power consumption is minimized [5]. Hence, on the mobile-side, either much less processing should be performed or the processing should be optimized. Moreover, the mobile applications cannot access as much data as web-based applications. As a result, the mobile device is supported to download the required data alone from the server, and the downloaded data are stored with the local database of the mobile device [6]. The mobile device usually downloads data required from the server through a middleware synchronization server. The synchronization server is retained as middleware to reduce the load on the server-side, hence enabling the server to process requests from the clients at a faster pace [7,8]. The synchronization server performs the process of data synchronization to maintain the integrity of the data and also to mitigate conflicts and inconsistencies during access and modification of the data. Data synchronization refers to the concept of retaining multiple copies of data that are coherent with one another to maintain data integrity [9]. Several homogeneous solutions are available and have been implemented by commercial DBMS vendors. In other words, the commercial algorithms provide solutions for server and client DBMSs from the same vendor. The solution to this situation is to employ vendor-dependent techniques such as triggers, time stamps, etc. [9]. Because triggers or stored procedures might use different formats or parameters, this method could cause dependency on a specific vendor. Next-generation mobile technologies aim to offer data management solutions that are heterogeneous. An IDBSync mechanism has been proposed that is embedded in the control plane of a remotely located synchronization server and makes decisions to instruct the synchronization of data to the data plane of the client devices and database server. As such, a complete system setup is created to improvise data synchronization between mobile devices and the synchronization server. The existing solutions are less likely to be used for next-generation technologies, and the new solutions offered must be heterogeneous in nature.


                     Organization of the paper: The remainder of the paper is organized as follows. Section 2 describes the related works in the area of research, Section 3 describes the framework of mobile data synchronization, Section 4 describes batch-level processing, Section 5 describes how the BaSyM table is used to group similar cases from the data planes to the control plane of the synchronization server, Section 6 explains the system implementation and performance analysis, and finally, Section 7 concludes the paper.

@&#RELATED WORKS@&#

Mobile databases and traditional database systems differ from each other due to device constraints. Mobile databases are resistant to asymmetry in communications, frequent disconnections, power limitations and screen size [10,11]. Recently, a large body of research has been focused on data synchronization schemes. Several primitive and new synchronization algorithms are discussed by HammarBerg et al. [12] and Shen et al. [13]. A few of the primitive solutions include time-based, hash-value-based, version and logical/global clock-based synchronizations. The proposed work extends the idea of partial synchronization with a remedial course of action against the use of message digest algorithms in synchronization environments. Full synchronization synchronizes all data regardless of the changes made. Partial synchronization synchronizes only the changed data between the server and client but at the cost of maintaining additional information. Starobinski et al. proposed a characteristic polynomial synchronization method for PDA devices [14]. The devices used in the mobile adhoc networks rely on energy efficient synchronization solutions. One of these solutions is the Weight Based Synchronization (WBS) protocol that uses the size of synchronized node clusters as a catalyst for synchronization in MANET [15].

Choi et al. [16] proposed a synchronization algorithm for mobile databases (SAMD) by maintaining the message digest to achieve vendor independence. Message digest values [MDV] are used to compare tuples between the server and clients. The synchronization server generates a MDV for every tuple in a table for each and every client and server. A subset of the problems with message digest algorithms are described:

                        
                           –
                           No two different data items can contain the same message digest (MD) value. Hence, whenever a message is modified, the MD has to be recomputed.

The computational cost is high compared with replication-based solutions, and replicating a table or tuple ultimately involves a minimal computational cost compared with calculation of a message digest value for a tuple.

Because a message digest image is maintained for every row, the process of generating the message digest value might slow the effective time used for synchronization because the mobile devices are moving objects and are reluctant to seamless connections. In this work, awareness of message digest values between the client and server is often stateless, causing a seamless connection. However, this method might lead to poor correlation of data management between mobile data and the associated message digest value in both the server and client databases. Certain vendor-dependent solutions are also used to improve synchronizations but might not be applicable for next-generation heterogeneous data technologies. A vendor-independent solution has been proposed that makes use of the partial synchronization technique and uses batch-level processing to speed up the synchronization process instead of using message digest values for rows in any table.

Synchronization enables each node connected to the network to have access to consistent information [17]. The synchronization algorithm's embedded control plane should use a mechanism to efficiently handle conflicting updates because conflicts occur when more than one database modifies the same data concurrently. Conflicts that are not resolved in a proper manner can lead to data inconsistency, which affects data integrity. Another problem is that because the mobile devices are subjected to bandwidth limitations and frequent disconnections, they might stay disconnected from the server for a long duration [18]. This disconnection is not a serious issue when downloading of data from the server occurs or when the devices work with local data, but if the connection becomes disconnected during data transfer from client to server, the server database enters an inconsistent state. Hence, a commit is made on the server side to ensure consistency. IDBSync is formulated in such a manner that the database is never in an inconsistent state because of conflicting updates. The mobile databases have a significant impact on the mobile and client sides. Because we apply the concepts of SDN, our mechanism is designed to run on both the mobile and server side to evaluate the performance, which is restricted to the server side in the existing mechanism.

Record-level synchronization makes use of network transmission more often than necessary and results in poor utilization of network bandwidth. Because the data usage per transmission is large, this situation creates a considerable impact on the performance of the system. Therefore, it becomes essential to optimize data transmission while performing synchronization. This process can be performed using batch level processing, which processes data synchronization in batches.

The proposed IDBSync method addresses the problems described above. The server and client maintain a duplicate of the data table on their respective sides. The synchronization server identifies and groups similar cases into a batch to minimize the frequency of network usage, as discussed in Section 5, and thus optimizes network bandwidth utilization.

The classical framework with the proposed SDN uses the control and data plane embedded for synchronization in a mobile environment, as shown in Fig. 1
                     . The server-side database maintains all data required for use by mobile applications. When the client needs to access the data, it sends the request to the synchronization server. The synchronization server forwards the request to the server, and the server fetches the set of records that satisfy the request. The server sends the data to the synchronization server, which forwards the data to the client that requested the data. Thus, both the server and client now maintain the same copies of the data, and either the server or client or both can modify the data independently. This modification should be reflected to the other party in which case synchronization comes into the picture. Articles from Saito et al. [19] and Ding et al. [20] provide an overview of the basic types of synchronization, and any one of the synchronization types can be used for mobile data management.

Mobile units are vulnerable to intermittent connections, and the impact of network partitioning leads to failed transformation of data from the previous network. Whenever a client mobile node requests a data item from the server, it is identified with the location because every BS (base station) covers a certain communication range and mobile nodes can only communicate with others via this BS. In such cases, replication is a fruitful solution for improving data availability to mobile users.

Creating and managing duplicate versions of data items minimizes access latency. Replication of popular data objects at a server closer to the users can improve access time for the users and reduce network bandwidth usage [21]. Selective replication is one suitable technique in Content Delivery Networks (CDN) [22]. Our mechanism makes use of a replica of the data table at both servers in the control plane and on the client sides of the data plane. The replica table contains the old copy of the data table, whereas the data table contains the updated data. In this work, the replica table is maintained to make a comparison with the data table and accordingly set the flag table. Because this mechanism is used with mobile applications that make use of fewer data and selectively (rows that are accessed frequently by client devices) accessed data compared with web applications, maintaining a replica table will not add significant overhead to the cost of the current mobile operation systems equipped with high-end facilities. The replica table aids in providing vendor-independent solutions for synchronization.

The following tables are used by the proposed mechanism:

                           
                              
                                 
                                 
                                 
                                    
                                       
                                          Data table:
                                       
                                       Contains the data used by client and server during data access.
                                    
                                    
                                       
                                          Replica table:
                                       
                                       Duplicate of data table.
                                    
                                    
                                       
                                          Flag table:
                                       
                                       Indicates whether data have been changed.
                                    
                                    
                                       BaSyM table:
                                       Full outer join results of flag tables from server and client.
                                    
                                 
                              
                           
                        
                     

The server and the client contain a data table, a replica of the data table and a flag table. The replica table in the server is not the replica of the entire table but a subset of the data table. This subset is the set of records that were sent to the mobile client. The fields of the data table depend on the application for which the database is used. The fields of the flag table are primary key fields that are the same as the primary key of the data table and a flag field that takes the values 0 or 1. The BaSyM table in the synchronization server consists of a primary key field and flag fields from the flag tables of server and client; a complete explanation of batch processing and the use of BaSyM is given in Section 4. The current and upcoming mobile environments are capable of maintaining numerous memory occupying applications, and no obstacles will occur to keeping the replica and flag table in the client side. This effort can be achieved by converting the replica tables to data tables between average frequencies of updates.


                        Fig. 2
                         represents the flow of data in the IDBSync mechanism, which is composed of a set of mobile clients, a synchronization server and a database server. Clients, mobile devices and mobile users are used interchangeably in the following discussion. The sequence of events in IDBSync is described as follows.

                           
                              1.
                              The clients request data from the server.

The synchronization server forwards the data request from the client to the server.

The server responds to the synchronization server with the requested data.

The synchronization server forwards the data to the client. The clients populate the data tables with data from the server and also create a local replica table and copy the data from the data table to the replica table. Requisition of the same data by client 1 and client 2 is indicated by a circle in Fig. 2.

The clients perform local processing of data on their own data tables. The time until the next modification depends on the user activity, and any update from the server at this point will use the latest copy based on the policy of multi-version locking [23]. Once local processing is completed, the recent copy is returned for the next comparison. The synchronization server only holds the data requested from/responded to the clients and database server, and synchronization batches will be dispatched to both parties(clients and server), even for a single update in a batch. Therefore, regardless of time, the synchronization server will send updated synchronization batches after every fraction of updates.

Processing for synchronization begins at this step. At the end of step 5, the data tables of the clients contain the modified data and replica tables.

The server and the client send their flag tables to the synchronization server. The synchronization requests of client 1 and client 2 cannot be handled at the same time because this leads to data inconsistency, which in turn affects data integrity. Hence, priority is given to either client 1 or client 2 depending on the application. In this case, client 1 is given priority.

The synchronization server performs a full outer join on the updated flag tables of the server and client to produce a BaSyM table. The BaSyM table is used to find out whether the data are modified by either the client or server or both.

Similar cases are grouped together, synchronization is performed as a batch and server/client flag tables are updated.

The server and client 2 send their flag table to the synchronization server to produce an updated BaSyM table.

The synchronization performed at client 2 and the server is similar to the process described in steps 8 and 9.

Many vendor-dependent solutions exist for creating synchronization policies and profiles in mobile databases. "SYBASE iAnywhere" provides a solution for creating the SQL Anywhere remote database and synchronization profiles [24]. In traditional database systems, the database operations are usually performed using a row-by-row method. However, in accessing remote databases via the network, row-wise operation tends to be inefficient because it results in frequent network access. To overcome this drawback, the IDBSync mechanism filters out the rows that can be synchronized together such that synchronization can be performed in batch mode based on the flag tables. Batch processing reduces a considerable amount of database round trips, which improves the overall performance and also results in efficient use of network bandwidth because it allows multiple heterogeneous statements in a single network call. The end result is reduced network traffic associated with the overhead. In general, batch processing contacts the database only once for synchronization of tuples that fall under the same case. If there are extra data in a single batch, the extra data are placed in the subsequent batches in which case the network is used more than once, but the calls are subsequent, indicating that the frequency of network usage is still minimized. Thus, batch-level processing reduces the round trips between application and database server, which are normally located in different systems, and leads to better performance.

A collection of long intensive queries running concurrently on a given server can cause serious performance degradation. Clearly, segregation of the short and long queries or those pertaining to a specific category is needed. Avoidance of a few users running intensive long queries, which significantly affect the majority of users running short queries [25], is one of the major motivations behind the invention of batch-level query processing. The BaSyM is an approach that groups the tuples based on the place of modification (place referring to client or server) and subsequently performs the corresponding synchronization. This process is performed with the aid of flag tables generated from the client and server data tables. The categorization or cases are built upon each other to generate one-stop synchronization for all pertinent tuples under a certain case or category.

One instance of generating a BaSyM table is illustrating in Fig. 3
                           , where PK represents Primary Key, Ci (i
                           =1,2,…,n) denotes the column number, and flag s and flag c indicate the flag values in the server and user equipment or clients, respectively. We assume that a row with primary key E1 is inserted,B1 is updated in the server database, the row corresponding to A1 is deleted, and B1 is updated in the client database.

                              
                                 1.
                                 In the client database, the data table and replica table are compared, and flags are set in the flag tables.

Similarly, the flags are set in the server flag tables.

The flag tables in the synchronization server are updated, and a full outer join operation is performed to produce the BaSyM table.

Similar cases are filtered from the BaSyM table and sent as a single batch for synchronization. A detailed explanation of the use of a BaSyM table for synchronization is given in the next section.

Our proposed IDBSync mechanism uses BaSyM for synchronization between mobile clients and database servers. The BaSyM table runs in a control-plane-like structure and forwards synchronization activities to the data planes of the mobile devices in a wireless network. The synchronization policy is applied according to the respective cases. Data tables are modified due to insertion, deletion or update of records, and the modifications are reflected in the replica table. Different cases of the synchronizations performed are detailed in the following text.

When an insert is performed in the data table of the client/server, the same row is inserted in its replica, and the corresponding primary key is inserted in the flag table with the flag value set. When a delete operation is used, the corresponding row in the replica is modified such that all columns have null values except for the primary key column, and the flag is set. During the update, the corresponding row in the replica is also updated, and the flag is set. This data table can now be deleted because the replica table reflects all changes made in the data table. This process is applicable for both the server and client table.

Whenever a modification occurs in the data table or replica tables, the flags in the flag tables are correspondingly set and categorized as cases 01, 10, and 11 based on the updated flag tables of the server and client at the synchronization server, and a full outer join operation is performed to generate a join table. This table contains all rows that describe the modification of data by either the server or the client or both. The possible cases are described below in the notations used in procedures (1–6).

                        
                           
                              
                              
                                 
                                    
                                       Procedure 1: Insert
                                    
                                 
                                 
                                    
                                       1 begin
                                    
                                 
                                 
                                    
                                       2 INS-LIST=DATATABLE- REPLICA
                                    
                                 
                                 
                                    
                                       3 for ∀id ∈ INS-LIST
                                    
                                 
                                 
                                    
                                       4 begin
                                    
                                 
                                 
                                    
                                       5 insert TUPLE (id) into REPLICA
                                    
                                 
                                 
                                    
                                       6 insert id into FLAGTABLE, set FLAG
                                    
                                 
                                 
                                    
                                       7 end
                                    
                                 
                                 
                                    
                                       8 end
                                    
                                 
                              
                           
                        
                     
                  

The rows that appear only in DATATABLE but not in REPLICA are chosen, i.e., the inserted rows. This information is contained in INS-LIST. For each id in INS-LIST, TUPLE (id) is selected from DATATABLE and inserted into REPLICA. In addition, a tuple with the id and set flag is inserted into FLAGTABLE.

                        
                           
                              
                              
                                 
                                    
                                       Procedure 2: Delete
                                    
                                 
                                 
                                    
                                       1 begin
                                    
                                 
                                 
                                    
                                       2 DEL-LIST=REPLICA- DATATABLE
                                    
                                 
                                 
                                    
                                       3 for ∀id ∈ DEL-LIST
                                    
                                 
                                 
                                    
                                       4 begin
                                    
                                 
                                 
                                    
                                       5 set TUPLE (field ≠ id)=NULL where TUPLE (id)=id
                                    
                                 
                                 
                                    
                                       6 set FLAG in FLAGTABLE where FLAGTABLE.id=id
                                    
                                 
                                 
                                    
                                       7 end
                                    
                                 
                                 
                                    
                                       8 end
                                    
                                 
                              
                           
                        
                     
                  

The rows that appear only in REPLICA and not in DATATABLE are selected, i.e., the deleted rows. This information is contained in DEL-LIST. For each tuple in DEL-LIST, all fields except id are set to NULL. In FLAGTABLE, FLAG for id is set.

                        
                           
                              
                              
                                 
                                    
                                       Procedure 3: Update
                                    
                                 
                                 
                                    
                                       1 begin
                                    
                                 
                                 
                                    
                                       2 UPD-LIST=(REPLICAid == DATATABLEid) and ∃field (REPLICAfield ≠ DATATABLEfield)
                                    
                                 
                                 
                                    
                                       3 for ∀id in UPD-LIST
                                    
                                 
                                 
                                    
                                       4 begin
                                    
                                 
                                 
                                    
                                       5 update TUPLE (id) in REPLICA
                                    
                                 
                                 
                                    
                                       6 set FLAG in FLAGTABLE where FLAGTABLE.id=id
                                    
                                 
                                 
                                    
                                       7 end
                                    
                                 
                                 
                                    
                                       8 end
                                    
                                 
                              
                           
                        
                     
                  

The rows in DATATABLE and REPLICA that have the same id but different fields are selected, i.e., the updated rows. This information is contained in UPD-LIST. For each row in UPD-LIST, the row is updated in REPLICA. In addition, the FLAG for id is set in FLAGTABLE.

                        
                           
                              
                              
                                 
                                    
                                       Procedure (case_01)4: Server to client module
                                    
                                 
                                 
                                    
                                       1 begin
                                    
                                 
                                 
                                    
                                       2 SID= TUPLE (select id (flags=1,flagc=0) from JOINTABLE) from REPLICAs
                                       
                                    
                                 
                                 
                                    
                                       3 for ∀tuple ∈ SID
                                    
                                 
                                 
                                    
                                       4 begin
                                    
                                 
                                 
                                    
                                       5 delete tuple from REPLICA
                                    
                                 
                                 
                                    
                                       6 insert tuple into REPLICAc
                                       
                                    
                                 
                                 
                                    
                                       7 end
                                    
                                 
                                 
                                    
                                       8 end
                                    
                                 
                              
                           
                        
                     
                  

The rows in the JOINTABLE that have their flagc set to 0 and flags set to 1 are selected first. All tuples of the replica that have an id belonging to the selected id in the join table are retrieved in the server side. For each retrieved tuple, the corresponding old entry is deleted first in the client side, and the new entry from the server is inserted.

                        
                           
                              
                              
                                 
                                    
                                       Procedure 5(case_10): Client to server module
                                    
                                 
                                 
                                    
                                       1 begin
                                    
                                 
                                 
                                    
                                       2 SID=TUPLE(select id (flagc=1, flags=0) from JOINTABLE) from REPLICAc
                                       
                                    
                                 
                                 
                                    
                                       3 commit in server
                                    
                                 
                                 
                                    
                                       4 for ∀tuple ∈ SID
                                    
                                 
                                 
                                    
                                       5 begin
                                    
                                 
                                 
                                    
                                       6 delete tuple from REPLICAs
                                       
                                    
                                 
                                 
                                    
                                       7 insert tuple from REPLICAs
                                       
                                    
                                 
                                 
                                    
                                       8 end
                                    
                                 
                                 
                                    
                                       9 end
                                    
                                 
                              
                           
                        
                     
                  

In the join table, the rows with flagc set to 1 and flags set to zero are selected first. In the client side, the rows with the same selected id from the JOINTABLE are retrieved. The server side database is committed to roll back in case of any disconnection during synchronization. For each retrieved tuple in the client side, the corresponding old entry is deleted, and the new entry is updated in the server.

                        
                           
                              
                              
                                 
                                    
                                       Procedure 6(case_11): Server/client lead module
                                    
                                 
                                 
                                    
                                       1 begin
                                    
                                 
                                 
                                    
                                       2 if server leads
                                    
                                 
                                 
                                    
                                       3 begin
                                    
                                 
                                 
                                    
                                       4 call case_10
                                    
                                 
                                 
                                    
                                       5 end
                                    
                                 
                                 
                                    
                                       6 if client lead
                                    
                                 
                                 
                                    
                                       7 begin
                                    
                                 
                                 
                                    
                                       8 call case_01
                                    
                                 
                                 
                                    
                                       9 end
                                    
                                 
                                 
                                    
                                       10 end
                                    
                                 
                              
                           
                        
                     
                  

In case in which both the client and server update the same row, priority is given to either the client or server. In case in which the server is given priority, case_01 is called. In the case of client lead, procedure case_10 is implemented. The priority depends on the application. Next, similar cases are filtered as a batch, which is transmitted to either the server or client accordingly. Finally, all of the null rows in the replica tables of both the server and client are deleted, and this replica table acts as the data table for the next round of synchronization to ensure correctness in the data tables of both the server and client at the end of synchronization process.

The possible combinations of no operation (N), insertion (INS), update (UPD) and deletion (DEL) operations that can be performed in the database are given in Table 1
                        . The proposed mechanism uses the applicable cases shown below to group batches for synchronizing tuples.

A study on conflict resolution is performed. Non-conflicting operations can be synchronized via cases 01 and 10. The combination 11 indicates that both the server and client have updated the rows in their respective data tables, and in the case of server lead criteria, else cases 10 or 01 will be executed. A similar analysis can be performed for combinations 12, 15 and 16 in Table 1. Thus, the IDBSync mechanism ensures resolution of conflicts during concurrent updating of data tables.

IDBSync is implemented with the objective of producing a faster synchronization mechanism for the heterogeneous mobile environment, and the proposed mechanism is tested in a heterogeneous environment with various mobile devices and database servers with different operating systems. Thus, the proposed mechanism was implemented using Java on MySQL and Oracle 10g with multiple clients (smart phones, Android applications, tablets and laptops) and server databases, respectively, to test the heterogeneity. The proposed mechanism was tested using a data operations set limited to 5000 rows with a row size ranging from 6–10. Attributes were added in the data tables of the server and clients as an initial step, followed by various data operations and testing of up to 1000 iterations. The same experiment was repeated for homogeneous (with the same operating system in mobile devices and database servers) and heterogeneous database environments with respect to obstacle and non-obstacle modes using Eq. (1). The system setup was purely tested for business data.

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          
                                             O
                                             r
                                          
                                          =
                                          
                                             ∑
                                             
                                                i
                                                =
                                                α
                                             
                                             β
                                          
                                          C
                                          
                                             R
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                 
                                 
                                    
                                       
                                          [
                                          
                                             
                                                
                                                   O
                                                   r
                                                
                                             
                                             =
                                          
                                          
                                             O
                                             b
                                             s
                                             t
                                             a
                                             c
                                             l
                                             e
                                             
                                             r
                                             a
                                             n
                                             g
                                             e
                                          
                                          ,
                                          
                                             CR
                                             i
                                          
                                          
                                             =
                                             
                                                C
                                                o
                                                v
                                                e
                                                r
                                                a
                                                g
                                                e
                                                
                                                R
                                                a
                                                n
                                                g
                                                e
                                             
                                             ,
                                             
                                             α
                                             =
                                             
                                                A
                                                v
                                                e
                                                r
                                                a
                                                g
                                                e
                                                
                                                C
                                                o
                                                v
                                                e
                                                r
                                                a
                                                g
                                                e
                                                
                                                M
                                                o
                                                d
                                                e
                                             
                                             
                                             β
                                             =
                                             
                                                F
                                                u
                                                l
                                                l
                                                
                                                C
                                                o
                                                v
                                                e
                                                r
                                                a
                                                g
                                                e
                                                
                                                M
                                                o
                                                d
                                                e
                                             
                                             ]
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

The response time is calculated based on the time required to synchronize the modification (insert/delete/update) with the client/server. Due to the vast amount of networking issues, the complete experiment for homogeneous and heterogeneous was tested with obstacles. This test was performed by adding a full to average coverage mode in the test scenario, and the results are recorded in Fig. 4
                        . Although the complete experiment is tested for obstacle and non-obstacle modes, the average response time of the proposed mechanism is calculated in an obstacle mode for a heterogeneous environment. Thus, Table 2
                         shows a significantly reduced response time compared with its peers.

The scalability of the proposed mechanism was tested by accumulating the number of items to be synchronized with the client/server with values ranging from 500 to 5000 rows. The first dark line of the Fig. 5
                         indicates a gradual and constant accumulation of response time for all 5000 rows. The second shadowed and third dotted line above the first line differentiates the response time variance after gradual addition of rows. Thus, the scalable number of rows in IDBSync has a minimal response time compared with the SAMD and commercial algorithms.

The energy consumption of any mobile device depends on the overall battery with standing ability on its own, and in this work, the proposed mechanism is tested with various capacities of lithium ion batteries. The response time is proportionally tested using an amount of battery discharging units with the aid of a third-party device and application programs such as fuel gauge. After various experiments in 2 G and 3 G networks, IDBSync consumed fewer discharging units than the existing solutions. The recorded discharging units for IDBSync in a heterogeneous environment and the average energy consumption variance with the existing mechanism are given in Table 3
                        , Figs. 6
                         and 7
                        , respectively.

@&#CONCLUSION@&#

This worked proposes a novel scheme for a SDN embedded data synchronization mechanism between server and client databases. The control plane of SDN synchronizes information across the data planes of mobile devices and the database server and uses a BaSyM table to make decisions on synchronizing various data planes of mobile clients. IDBSync not only provides a vendor-independent solution but also improves the use of network bandwidth, minimizes energy consumption and resolves conflicts. Vendor independence is achieved by maintaining a replica table at each site, and the utilization of network bandwidth is improved by making use of batch-level processing. The conflict resolution scheme is further improved by identifying the conflicting operations and applying suitable cases. The proposed system can also be extended for big data with the aid of NoSQL. The proposed IDBSync mechanism also demonstrates better performance and reduced energy consumption compared with commercial approaches for synchronization with respect to the running time for database operations.

@&#ACKNOWLEDGMENTS@&#


                  Gunasekaran Raja gratefully acknowledges support from the Raman Post-Doctoral Fellowship. Gunasekaran Raja, Kottilingam Kottursamy, Vaishnavi Srinivasan gratefully acknowledges support from NGNLabs, Department of Computer Technology, Anna University, Chennai.

@&#REFERENCES@&#

