@&#MAIN-TITLE@&#A variable neighborhood search for the capacitated vehicle routing problem with two-dimensional loading constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a variable neighborhood search to address the routing aspect.


                        
                        
                           
                           We adapt a skyline heuristic to examine the loading constraints.


                        
                        
                           
                           We propose an efficient data structure to record the loading information.


                        
                        
                           
                           We outperform all existing approaches on numerical experiments.


                        
                        
                           
                           We improve or match the best known solutions for majority of benchmark instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Routing

Packing

Variable neighborhood search

Skyline heuristic

2L-CVRP

@&#ABSTRACT@&#


               
               
                  This paper addresses the capacitated vehicle routing problem with two-dimensional loading constraints (2L-CVRP), which is a generalized capacitated vehicle routing problem in which customer demand is a set of two-dimensional, rectangular, weighted items. The objective is to design the route set of minimum cost for a homogenous fleet of vehicles, starting and terminating at a central depot, to serve all the customers. All the items packed in one vehicle must satisfy the two-dimensional orthogonal packing constraints. A variable neighborhood search is proposed to address the routing aspect, and a skyline heuristic is adapted to examine the loading constraints. To speed up the search process, an efficient data structure (Trie) is utilized to record the loading feasibility information of routes, but also to control the computational effort of the skyline spending on the same route. The effectiveness of our approach is verified through experiments on widely used benchmark instances involving two distinct versions of loading constraints (unrestricted and sequential versions). Numerical experiments show that the proposed method outperforms all existing methods and improves or matches the majority of best known solutions for both problem versions.
               
            

@&#INTRODUCTION@&#

This paper considers an important extension of the classical vehicle routing problem (VRP), called capacitated vehicle routing problem with two-dimensional loading constraints (2L-CVRP). This problem is a combination of two most important NP-hard optimization problems in distribution logistics, the capacitated vehicle routing problem (CVRP) and two-dimensional bin packing problem (2BPP). In the 2L-CVRP, the demand of customers is formed by several two-dimensional rectangular weighted items, while vehicles are identical with the same weight capacity and loading surface. The purpose is to design routes with minimum cost for given vehicles to serve all the customers and, at the same time, load the corresponding items into the vehicles successfully.

The 2L-CVRP is particularly important in both practical and theoretical aspects. The CVRP is a simplified model for practical operators. However, in the real world, logistics managers usually have to deal with routing and packing problems simultaneously. Moreover, because of the weight, fragility or the large height of freight, numerous real life applications involve the delivery of rectangular-shaped items that cannot be stacked on each other, such as household appliances, delicate pieces of furniture, etc. Therefore, 2L-CVRP has an obvious commercial value. From a theoretical perspective, 2L-CVRP is composed of two NP-hard problems (CVRP and 2BPP); thus, it is also a challenging NP-hard problem of high complexity. The CVRP (Toth and Vigo, 2002) has been extensively studied (Gendreau, Hertz, and Laporte, 1994; Prins, 2004). The loading component of 2L-CVRP is closely related to the two-dimensional bin packing problem (2BPP), which aims at packing a given set of rectangular items into the minimum number of identical rectangular bins. For more related literature, the reader is referred to Lodi, Martello, and Vigo (1999) and Lodi, Martello, and Monaci (2002).

Routing and packing problems have been studied intensively but separately, with the combined problem only being introduced in recent years. The 2L-CVRP was first presented by Iori, Salazar-González, and Vigo (2007), and only small-scale instances were solved via an exact algorithm based on the branch-and-cut technique. For larger scale problems, Gendreau, Iori, Laporte, and Martello (2008) proposed the first meta-heuristic approach, Tabu Search (TS). Then, Zachariadis, Tarantilis, and Kiranoudis (2009) developed the Guided Tabu Search (GTS), which incorporates the rationale of Tabu Search and Guided Local Search, and relies on a bundle of heuristics to check the feasibility of loading. The Extended Guided Tabu Search (EGTS) and simulation annealing (SA), which introduce a new scoring-based heuristic to improve packing, were proposed by Leung, Zhou, Zhang, and Zheng (2011) and Leung, Zheng, Zhang, and Zhou (2010), respectively. For a population-based algorithm, the effective saving-based Ant Colony Optimization (ACO) was presented by Fuellerer, Doerner, Hartl, and Iori (2009), and its performance was proven to be quite satisfactory. Recently, Duhamel, Lacomme, Quilliot, and Toussaint (2011) proposed the Greedy Randomized Adaptive Search Procedure combined with Evolutionary Local Search (GRASP  ×  ELS) algorithm, whereby the loading component is examined via solving the resource constrained project scheduling problem (RCPSP). This algorithm outperforms all previous methods and obtains new better solutions for several instances; however, only the Unrestricted version of 2L-CVRP was solved. Lately, Zachariadis, Tarantilis, and Kiranoudis (2013) proposed an innovative compact meta-heuristic, named as promise routing-memory packing (PRMP), which obtains excellent performance and improves best known solutions for many instances.

The more general problem, capacitated vehicle routing problem with three-dimensional loading constraints (3L-CVRP), has received increasing attention from researchers. Several algorithms proposed for solving 2L-CVRP were extended to 3L-CVRP, e.g., TS (Gendreau, Iori, Laporte, and Martello, 2006), GTS (Tarantilis, Zachariadis, and Kiranoudis, 2009), ACO (Fuellerer, Doerner, Hartl, and Iori, 2010), and GRASP  × ELS (Lacomme, Toussaint, and Duhamel, 2013). In addition, Ma, Zhu, and Xu (2011) provided a combined tabu search with local search. Bortfeldt (2012) introduced a hybrid algorithm, which employs tabu search for routing and tree search algorithm for loading. Zhu, Qin, Lim, and Wang (2012) developed a two-stage tabu search for routing, adopted enhanced heuristics for loading and obtained excellent results. Iori and Martello (2010) provided a review in regard to vehicle routing problems with two- and three-dimensional loading constraints. Wei, Zhang, and Lim (2014) introduced a heterogeneous fleet vehicle routing problem with three-dimensional loading constraints (3L-HFVRP).

The VNS (Hansen, Mladenović, Brimberg, and Pérez, 2010) has been proven quite effective to solve the VRP and its variants (Fleszar, Osman, and Hindi, 2009; Hemmelmayr, Doerner, and Hartl, 2009; Imran, Salhi, and Wassan, 2009; Paraskevopoulos, Repoussis, Tarantilis, Ioannou, and Prastacos, 2007). Motivated by these successes, this paper develops a variable neighborhood search (VNS) for 2L-CVRP, which incorporates a skyline heuristic for solving the loading component. To the best of our knowledge, this is the first implementation of VNS for 2L-CVRP. In our method, an insertion-based heuristic is adopted to generate the initial solution, which is used for further improvement. Regarding the routing aspect, VNS can explore the solution space systematically and effectively. Moreover, in order to ensure the loading feasibility of routes, an effective skyline heuristic is employed to solve the packing part of the problem. To accelerate the procedure, a data structure (Trie) is used to record the loading feasibility information, which avoids checking the visited routes repeatedly. In addition, it is also used to control the number of times the skyline heuristic is called for the same route. The proposed algorithm was tested extensively on 2L-CVRP benchmark instances and compared with previously published algorithms. The results demonstrate that our algorithm outperforms all other methods and identifies many new best solutions, especially for large scale instances.

The remainder of this paper is organized as follows. Section 2 describes the problem in detail. Section 3 presents the proposed variable neighborhood search methodology, while Section 4 provides a detailed description of the skyline heuristic for examining the loading subproblem. The extensive computational results on benchmark instances and comparisons with other algorithms are presented in Section 5. Finally, the conclusions are given in Section 6.

The 2L-CVRP is defined on a complete undirected graph G = (V, E), where V = {0, 1, …, N} is the vertex set and E = {(i, j)|i, j ∈ V, i ≠ j} is the edge set. Vertex 0 represents the central depot and the set of vertices {1, 2, …, N} denotes the location of customers. Each edge (i, j) ∈ E associates with a travel cost cij
                      that corresponds to the cost for going from vertex i to j or from vertex j to i. At the central depot, a fleet of K homogeneous vehicles is available. Each vehicle has weight capacity D and a two-dimensional rectangular loading surface of width W and length L. The loading area is denoted as A = W × L. The demand of each customer i (i = 1, …, N) is defined as a set of mi
                      rectangular items denoted as Ii
                     , and the total weight of Ii
                      is di
                     . Each item Iir
                      ∈ Ii
                     (r = 1, …, mi
                     ) is characterized by a specific width wir
                      and length lir
                     . In addition, the total area of items Ii
                      is denoted as 
                        
                           
                              a
                              i
                           
                           =
                           
                              ∑
                              
                                 r
                                 =
                                 1
                              
                              
                                 m
                                 i
                              
                           
                           
                              w
                              
                                 i
                                 r
                              
                           
                           
                              l
                              
                                 i
                                 r
                              
                           
                        
                     . For 2L-CVRP, a feasible solution must satisfy the following constraints:

                        
                           (a)
                           Every vehicle starts and terminates its route at the central depot.

All the customers must be served by using no more than the given K vehicles.

Each customer is visited exactly once, and all the demanded items must be loaded into the vehicle.

The capacity, length, and width of every vehicle cannot be exceeded by loaded items.

Each item has a fixed orientation that cannot be rotated. In other words, each item is loaded with its width (length) parallel to the corresponding width (length) of the vehicle surface.

All items of customers assigned to the same route must be loaded into the vehicle successfully without any overlap.

The objective of 2L-CVRP is to minimize the total travel cost of routes which serve all the customers and satisfy all the constraints, as well. This paper considers two versions of this problem: Unrestricted 2L-CVRP and Sequential 2L-CVRP. The Unrestricted 2L-CVRP is described in the previous paragraph, which only concerns loading items into the vehicle. Sequential 2L-CVRP considers both loading and unloading operators, in which an additional LIFO (last in first out) constraint is imposed: when visiting a customer, his or her items can be unloaded by straight movements parallel to the length dimension of the vehicle surface, without the need to rearrange items that belong to other customers in the same route. In other words, no item of customer j in the same route to be served later than customer i can be placed between items of i and the rear door of the vehicle. This arises in practical cases when it is difficult to move the items due to their weight or fragility, especially when the items are unloaded by means of forklift trucks from the rear door of vehicles. Fig. 1
                      gives an example of the two versions.

Variable Neighborhood Search (VNS) is first proposed by Mladenović and Hansen (1997) to solve combinatorial and global optimization problems. VNS is derived from the idea of systematically changing neighborhoods during the search. The underlying theory to obtain a better local optimum is that a local optimum under one neighborhood structure is not necessary so far from another.

In the classical implementation of VNS algorithm, four key components should be specified: (i) method to construct an initial solution; (ii) the set of neighborhood structures NS, which helps to slightly diversify the starting point of local search; (iii) local search, which improves the solution quickly; and (iv) acceptance criterion that determines the termination of the search. In general, the VNS starts with initializing a solution and the set of neighborhood structures NS. Subsequently, the main solution search procedure, which includes a random shaking and a local search component, is repeated until the given stopping criterion is met. In each iteration of the main solution search, given the current solution S, a random neighboring S′ of S is generated with a neighborhood structure NSk
                      (k is set to 1 before the first iteration). S′ is taken as a temporary solution, and then optimized by the local search to determine the local optimum S′′. If the obtained new solution S′′ is better than the incumbent best solution, the algorithm updates the best solution and sets S to S′′. Then the search continues with the new starting point S′′ and k is reset to 1. In other words, a new random neighboring solution is generated from S′′ according to neighborhood structure NS
                     1 in the next iteration. Otherwise, S remains the starting point and a random neighbor is generated according to neighborhood NS
                     
                        k + 1 in the next iteration. This process repeats until all neighborhoods are attempted and no new better solution is identified.

Our variable neighborhood search for 2L-CVRP is given in Algorithm 1
                     . Here, our algorithm is slightly different with classical VNS, i.e., instead of generating only one random point, up to K random points are produced from each neighborhood structure (Line 8). For each random point, we try to find the local optimum by the local search. When any improvement is found, we resume the search with the new solution and revert the neighborhood structure back to NS
                     1 immediately. Otherwise, we jump to the next neighborhood structure. This helps to better explore the current neighborhood structure.

In addition, in order to better explore and exploit the search space, after trying all neighborhood structures, a diversification procedure is introduced to produce a new initial solution based on the incumbent best solution (Line 16). Then the main solution search procedure resumes with the new initial solution. The diversification procedure differs from the neighborhood structures, in that it will drive the search to other regions which neighborhood structures cannot easily reach. This process is repeated until the given time is elapsed.

We describe our method to construct the initial solution in Section 3.1 and the set of neighborhood structures in Section 3.2. Our local search LocalSearch used to find the local optimum is given in Section 3.3 and the diversification procedure Diversify is presented in Section 3.4. Finally, we present some acceleration strategies in Section 3.5.

The initial solution is constructed via an insertion-based mechanism. At first, K empty routes are generated for all given vehicles. The customers are sorted by the decreasing value of total area of its items ai
                         (i = 1, …, N), as the loading constraints play the key role in determining the feasibility of the solution. Then, the customers are inserted into the routes one by one according to the sorted sequence. Assume the sorted sequence is T. For each customer Ti
                        (i = 1, …, N), we first try to assign it to the route which has the least unoccupied loading surface, but can accommodate Ti
                         feasibly. This helps to increase the utilization of loading surface. If such a route is found, the customer is inserted into this route in the position, which leads to the minimum incremental cost. In particular for Sequential 2L-CVRP, the loading feasibility of all possible insertion positions needs to be examined, then the feasible and optimal position is picked. If it is determined that Ti
                         cannot be inserted into any of K routes, the customer sequence is updated by exchanging the positions of customers Ti
                         and Tj
                         (j is randomly selected from 1, …, i − 1), and the construction algorithm restarts with the new customer sequence. The above process repeats until a feasible solution is obtained. The average numbers of iterations to obtain a feasible initial solution are 2 for both versions. In the worst case, the numbers may reach up to 38 and 28 for Unrestricted and Sequential versions, respectively.

The neighborhood structures, which are utilized to slightly diversify the starting point of local search, is at the heart of VNS. Each neighborhood should attain a proper balance between perturbing the incumbent solution and retaining the good part of the current solution (Hemmelmayr et al., 2009). We employ six neighborhood structures derived from the following two move classes.

Segment exchange (SE): Two sequences of consecutive customers from different routes exchange their positions. The procedure starts by taking a random segment of customers from a randomly chosen route, and then attempts to exchange the positions systemically with another random segment from a different randomly chosen route. If the resulting solution is infeasible, the exchange is cancelled. The above procedure is repeated until the resulting solution is feasible. On average, the numbers of iterations to obtain a feasible solution are 10.8 and 19.5 for Unrestricted and Sequential versions, whereas the numbers may reach up to 70 and 108 for the versions in the worst case. In order to obtain a feasible solution easily, the exchange is only performed between segments of the same length. Moreover, the longer the segment length, the lower the probability to obtain a successful exchange. In this study, the segment length is limited to 2 and 3, and the corresponding neighborhoods are denoted as SE2 and SE3, respectively.

Move combination (MC): It consists of two randomly chosen simple moves from the six move types presented in Section 3.3. We first select two types randomly from the six types. For each type, we repeatedly try to perform a random move until the resulting solution of this move is feasible. On average, the numbers of iterations to obtain a feasible solution are 8.3 and 12.2 for Unrestricted and Sequential versions, whereas the numbers may reach up to 27 and 49 for the versions in the worst case. This neighborhood is marked as MC2.

Our final neighborhood structures perform each individual move class several times which is controlled by the variable strength. Considering the purpose of neighborhood structures, the used strength is 1 and 2. Therefore, the derived six neighborhood structures are SE21 (perform SE2 once), SE22 (perform SE2 two times), SE31, SE32, MC21, and MC22. The random order of neighborhoods is adopted by shuffling the sequence of neighborhood structures randomly when finding a new best solution.

The local search procedure LocalSearch is utilized to obtain a local optimal solution of the temporal solution generated from neighborhood structures. Our local search is made up of six basic move types (Zachariadis et al., 2009), which can improve the solution quickly and efficiently. The detailed operators are described as follows.

                           
                              1.
                              
                                 intra-swap: swap the positions of a pair of customers within the same route.


                                 inter-swap: swap the positions of a pair of customers from different routes.


                                 intra-shift: a customer is shifted from its position to elsewhere within the same route.


                                 inter-shift: a customer of one route is sent to another route.


                                 intra-2opt: for a given route, two non-adjacent arcs are deleted, the middle segment of route is reversed, and then two new arcs are added to link the route again. This often helps removing arc crossings.


                                 inter-2opt: two arcs from different routes are eliminated so that each route is cut into two parts, then each first part of one route is concatenated with the last part of the other route to generate two new routes. If one route is empty, the other route is split into two routes. Thus, route split is a special case of this operator. This move brings more dramatic change to the solution.

The local search method adopts the first improvement strategy to systemically explore all possible moves of six types in order to obtain better solutions. In other words, the method tries all possible moves of the current type until the first improving move is found, then this move is performed immediately. Otherwise, the next move type is applied until all types are tried and no improvement is found. Note that only a loading-feasible solution is accepted during the procedure.

In our search, six move types are employed in random order. At the beginning, the order of six move types is randomly generated. The procedure tries each move type in the generated order. If an improving solution is found for the current type, a new order of move types is generated through randomly shuffling the old one, and then the procedure restarts with the new solution and new order of move types. Otherwise, the procedure proceeds to the next type.

Considering an instance with N customers and K vehicles, the number of pairs of customers is N(N − 1)/2, so the complexity of examining all moves of swap (intra- and inter-) is O(N
                        2). Similarly, there are N + K − 1 possible positions for the insertion of each customer; therefore, the complexity of shift types is O(N(N + K)). The cardinality of all cutting arcs is N + K; hence, trying all intra-2opt and inter-2opt requires O((N + K)2) = O(N
                        2) (K ≪ N) computational effort.

The diversification procedure Diversify is incorporated to escape from the incumbent local optimum, since the local search is usually stuck at a local optimal solution. We use the incumbent best solution as the input of the procedure Diversify to obtain a new initial solution.

A ruin-reconstruct mechanism is utilized to diversify the search process. The basic idea of the ruin-reconstruct approach is to generate a new solution by destructing the input feasible solution first and then rebuilding a complete solution from the resulting partial solution, which is similar to the ruin-recreate heuristic proposed by Ropke and Pisinger (2006) and Schrimpf, Schneider, Stamm-Wilbrandt, and Dueck (2000). First, several randomly chosen customers are removed from the solution and put into a pool temporarily. Then, the rebuilding process starts. The customers in the pool are first sorted by decreasing area of their demanded items and reinserted into the partial solution one by one. The route and position for a customer is decided by the same rule used in the constructing heuristic (Section 3.1). A slight difference occurs when a customer cannot be inserted into any route feasibly. If such a case occurs, a route is chosen randomly, and customers in this route are randomly erased, one at each time, until the given customer can be inserted into this route successfully. This is similar to the concept of the ejection chains method (Lim and Zhang, 2007), which has been proved to be effective to solve tightly constrained problems. The erased customers are put into the pool, and the rebuilding process restarts with the new pool. The rebuilding process is repeated until a complete solution is found, i.e., the pool is empty.

In our implementation, the number of removed customers is set to min (0.5 × N, 0.1 × N + nonImp), where N is the total number of customers, and nonImp is the number of iterations without improvement after calling the VNS. The larger the number nonImp, the harder it is to escape from the local optimum. By setting the number of removed customers in such a manner, the solution generated retains most good characteristics of the input solution and brings greater difference while the number nonImp is larger.

The packing method is time-consuming and is called quite frequently, which dramatically contributes to the overall computational effort. To accelerate the proposed algorithm, unnecessary calls to the packing method should be avoided, such as duplicated examination and checking for unpromising solutions. Therefore, three strategies used in our methodology are explained as follows.

Based on the characteristics of the problem, a common strategy is employed. During the local search procedure, for a feasible solution, moves within a route (Intra- moves) are always feasible for Unrestricted 2L-CVRP. Thus, they are executed without any examination. For Inter-Shift, routes obtained by removing a customer must be loading-feasible for both Unrestricted and Sequential versions; these examinations can be avoided too.

Furthermore, it is beneficial not to spend time on unpromising solutions by using the “evaluating first-packing second” strategy, which was first explicitly explained by Bortfeldt (2012). The cost of a move is first evaluated, and the packing heuristic is applied only when the move leads to a better solution. This operator prevents loads of feasibility examination of unpromising solutions; therefore, much computational time is saved.

In addition, in order to speed up our procedure, we use a special data structure (Trie) to keep track of the loading feasibility of routes already examined. A similar strategy is also employed by other authors, e.g., tree structure (Zachariadis et al., 2009), pool (Fuellerer et al., 2009), hash table (Zachariadis et al., 2013), and have been demonstrated to be quite useful to save running time. However, our Trie is different from the Trie used in previous literature (Leung, Zhang, Zhang, Hua, and Lim, 2013). We will present the details of our Trie in Section 4.

We use the procedure TabuPack to check the packing feasibility of a route. The TabuPack procedure is given in Algorithm 2
                     , which is adapted from the 2DRPSolver proposed by Wei, Oon, Zhu, and Lim (2011) for the two-dimensional rectangle packing problem. It takes a route tour RT containing the ordered customers visited by a vehicle, and a parameter iter used to control the number of iterations as input. If the procedure finds a feasible packing for this vehicle, it reports a const success; otherwise, it returns a const failure.

The TabuPack is actually a sequence-based tabu search procedure. For each sorted sequence of rectangles, we use a heuristic packing subroutine HeuristicPack (see Section 4.1 for details) to try to pack the rectangles into the vehicle surface as much as possible. We first use the following three sorting rules to generate an initial sequence R of the rectangles belonging to the customers in RT (line 2):

                        
                           1.
                           sort by area of the rectangle in decreasing order;

sort by width of the rectangle in decreasing order;

sort by length of the rectangle in decreasing order.

Especially for the Sequential 2L-CVRP, we will first sort all the rectangles by the reverse visiting order of its customers, and then use the above sorting rules to sort the rectangles of each customer.

If the HeuristicPack finds a packing pattern that places all rectangles in R, success will be returned. Otherwise, we attempt to optimize the solution in terms of area utilization through a tabu search mechanism. The number of iterations is determined by the input parameter iter (Lines 6–13). The neighborhood operator simply swaps two randomly selected rectangles in the current sequence, and the same subroutine HeuristicPack will be called on the modified sequence. We generate n (n is the number of rectangles in the input customers) such sequences that are not forbidden by the tabu list, select the one that produces the solution with the highest area utilization, and insert the corresponding swap into the tabu list; and this swap is forbidden for the next 3n iterations. At any point in the process, if a packing pattern is identified that places all n rectangles, then the procedure halts with success. If this does not occur, then TabuPack reports a failure.

In order to speed up our procedure, we use a special data structure (Trie) to keep track of the loading feasibility of routes already examined. Our Trie stores not only the feasibility information of routes, but also the iteration number iter in the previous call of the TabuPack for the same route. More specifically, given a sequence of customers RT representing a route, in order to determine whether the route is feasible, we first retrieve the information from the Trie. Let the stored feasibility information be packed, the stored iteration number be iter
                     0 and the number of rectangles of customers in the route be n. We make different decisions based on the following four cases:

                        
                           1.
                           the route does not exist in the Trie: call TabuPack(RT, 1), store the results including the iter value 1, sequence of this route and packing results into the Trie, then return the results;


                              packed = = success: return success;


                              packed = = failure, iter
                              0 < n: call TabuPack (seq, min (2 × iter
                              0, n)), update the feasibility of this route and the new iteration value min (2 × iter
                              0, n) in the Trie and return the results;


                              packed = = failure, iter
                              0 = =n : return failure.

The Trie could save time in two aspects. For the route whose feasible packing has been found by TabuPack, the stored information in the Trie could avoid the unnecessary call of TabuPack on the same routing later (case 2). For the route whose feasible packing is not found currently, we will iteratively double the effort spent on this route (cases 1 and 3). Thus, more effort will be spent on the difficult instance. However, in order to not spend too much time on the same route, we limit the maximum call to the number of rectangles of the customers in the route. Once this limitation is reached, we regard this route as infeasible and will not call the TabuPack on this route anymore (case 4). The experiments show that this strategy is very useful for the difficult instance; the details are given in Section 5.4.2.

Our HeuristicPack procedure takes as input a sequence of rectangles R. The purpose of HeuristicPack is to pack the sequence of rectangles into the vehicle surface as much as possible. It is adapted from the 2DRP_Heuristic heuristic proposed by Wei et al. (2011) for the two-dimensional rectangle packing problem. The HeuristicPack heuristic is a skyline-based best-fit algorithm. It uses a skyline to represent the packing pattern, and the candidate positions to place a rectangle are given by the “concave” points on the skyline (see Section 4.1.1 for more details).

The procedure places the rectangles one by one. In each step, it selects a placement (i.e., a rectangle along with a candidate position) according to a fitness measure and places the selected rectangle at that position. Such step is repeated until no feasible placements remain (either because there are no more rectangles, or no more positions can accommodate any rectangles). For the Sequential 2L-CVRP, we only consider the placement whose resulting packing does not violate the LIFO constraint.

We use a function f(r, p) to measure the fitness of packing a rectangle r at a candidate position p. The fitness function f(r, p) produces a vector which consists of six components. The (r, p) is said to be fitter than (r′, p′) if f(r, p) is lexicographically smaller than f(r′, p′) (i.e., two vectors are compared component by component, and the order of the first different component determines the order of the two vectors). We select the lexicographically smallest placement from all feasible placements. The six components of f(r, p) are:

                           
                              (1)
                              
                                 
                                    f
                                    (
                                    r
                                    ,
                                    p
                                    )
                                    =
                                    (
                                    
                                       o
                                       n
                                       l
                                       y
                                       F
                                       i
                                       t
                                       (
                                       r
                                       ,
                                       p
                                       )
                                    
                                    ,
                                    
                                       w
                                       a
                                       s
                                       t
                                       e
                                       (
                                       r
                                       ,
                                       p
                                       )
                                    
                                    ,
                                    −
                                    
                                       f
                                       n
                                       (
                                       r
                                       ,
                                       p
                                       )
                                    
                                    ,
                                    
                                       o
                                       r
                                       d
                                       (
                                       r
                                       )
                                    
                                    ,
                                    y
                                    (
                                    p
                                    )
                                    ,
                                    x
                                    (
                                    p
                                    )
                                    )
                                 
                              
                           
                        
                     

where

                           
                              1.
                              
                                 onlyFit(r, p): if rectangle r is the only rectangle remaining that can fit onto p, this value is 0; otherwise, this value is 1;


                                 waste(r, p): the total amount of adjacent wasted space that is created if r is placed at p (see Section 4.1.2 for details);


                                 fn(r, p): the number of sides of the rectangle that exactly matches the segment that it is touching in the skyline, called its fitness number (see Section 4.1.3 for details);


                                 ord(r): the order of r in the ordered set R;


                                 y(p): the y-coordinate of position p;


                                 x(p): the x-coordinate of position p.

A packing pattern is represented by a rectilinear skyline, which is the contour of a set of consecutive vertical bars. It is expressed as a sequence of k horizontal line segments (s
                           1, s
                           2, …, sk
                           ) satisfying the following properties: (1) the y-coordinate of sj
                            is different from the y-coordinate of s
                           
                              j + 1, j = 1, …, k − 1; and (2) the x-coordinate of the right endpoint of sj
                            is the same as the x-coordinate of the left endpoint of s
                           
                              j + 1, j = 1, …, k − 1. Fig. 2
                            gives an example of a skyline, in which each line segment sj
                            is labeled as j at its left endpoint. The candidate positions are given by the “concave” points in the skyline, which are depicted by dots in Fig. 2.

Our second component of fitness function is the amount of adjacent waste space, which is calculated as the total volume of wasted space of the four types given in Fig. 3
                           (a)–(d). Let 
                              
                                 w
                                 _
                                 m
                                 i
                                 n
                              
                            and 
                              
                                 h
                                 _
                                 m
                                 i
                                 n
                              
                            be the minimum width and height, respectively, of the remaining rectangles, excluding r. The shaded area in case (a) is always considered as wasted space. The shaded areas in cases (b) and (c) are considered wasted if the length of the gap is less than 
                              
                                 w
                                 _
                                 m
                                 i
                                 n
                              
                           . Finally, the shaded area in case (d) is wasted if the gap is less than 
                              
                                 h
                                 _
                                 m
                                 i
                                 n
                              
                           .

Our third component of the fitness function is the fitness number, which is defined as the number of sides of the rectangle that exactly matches the segment that it is touching in the skyline. If the bottom side of a rectangle is equal to the length of sj
                           , it is regarded as an exact match. For the left (resp. right) side of a rectangle, an exact match occurs if its height is equal to the y-coordinate of s
                           
                              j − 1 (resp. s
                           
                              j + 1) minus the y-coordinate of sj
                           . Any side of a rectangle that touches the left, right or bottom side of the sheet is not considered an exact match unless it fills all the remaining space on that side. However, when the top edge of a placed rectangle touches the top of the sheet, this is considered an exact match. The fitness number can be either 0, 1, 2, 3 or 4, as shown in Fig. 4
                           , in which the number in each rectangle depicted is its fitness number. Note that the rectangles in this Fig. 4 are only given for illustrative purpose. They could be larger or smaller, which would lead to other fitness values.

This section presents the computational results based on the widely used benchmark instances generated by Gendreau et al. (2008). The algorithm was coded in C++, and all experiments were executed on an Intel Xeon E5430 with a 2.66 gigahertz (Quad Core) CPU and 8 gigabytes RAM running the CentOS 5 Linux operating system. The runtime limit for each instance is set according to its scale: 900 seconds for N ≤ 50, 1800 seconds for 50 < N ≤ 100 and, 3600 seconds for N > 100. The detailed computational results presented in this section and the test data are available online at www.computational-logistics.org/orlib/2l-cvrp.


                        Gendreau et al. (2008) generated the 180 2L-CVRP instances by extending the 36 well-known classical CVRP instances introduced by Toth and Vigo (2002). In particular, each customer is associated with a set of two-dimensional items. In addition, the loading surface (L, W) is fixed as (40, 20) for all instances, and the available vehicle number is specified. According to the characteristics of demanded items, as shown in Table 1
                        , five 2L-CVRP instances are created for each of the 36 CVRP problems. In Class 1, each customer is assigned with one item of unit length and width so that the packing is always feasible. Therefore, Class 1 can be regarded as a pure CVRP problem which is used to evaluate the performance of proposed algorithms in terms of routing aspect. For Classes 2–5, the number of items demanded by customer i, mi
                        , is a random value in a given interval (see Table 1, column 2). Moreover, each item is classified into one of the three shape categories with equal probability. The Unrestricted and Sequential versions share the same test data, but Sequential 2L-CVRP should consider additional unloading constraint when examining the feasibility of routes.

We executed our approach 10 times for each instance by setting the random seed from 1 to 10. We compare our variable neighborhood search (VNS) with the existing approaches for 2L-CVRP in the literature:

                           
                              1.
                              
                                 ACO: an ant colony optimization method by Fuellerer et al. (2009);


                                 SA: a simulated annealing method by Leung et al. (2010);


                                 EGTS + LBFH: an extended guided tabu search by Leung et al. (2011);


                                 GRASP × ELS: a hybrid procedure combining a greedy randomized adaptive search and evolutionary local search by Duhamel et al. (2011);


                                 PRMP: a meta-heuristic named as promise routing-memory packing by Zachariadis et al. (2013).

The computational environments for these approaches are summarized in Table 2
                        . All these approaches were executed 10 times for each instance by setting different random seeds. In the following tables, the cost listed is the best cost achieved over 10 runs. Due to space limitations, we only list the details of the best known solution (BKS) among all previous approaches and two effective methods for each version: GRASP × ELS, PRMP for Unrestricted 2L-CVRP and ACO, PRMP for Sequential 2L-CVRP.

We first test our approach on the pure CVRP benchmark instances of Class 1. Table 3
                            provides the best results obtained by our method over 10 runs on each instance of Class 1. Our approach managed to produce better value for three instances and robustly matched the best value for 28 instances compared to the best ones obtained by previous approaches. Thus, the routing component of our approach is proved to be rather effective.


                           Table 4
                            provides the average and best results obtained by our method on each of the instances of Classes 2–5 for Unrestricted 2L-CVRP. We observe that the proposed method is rather stable, as the percentage gaps between the average and best solution achieved over the 10 runs were limited to 0.24 percent, 0.23 percent, 0.23 percent and 0.18 percent, for the problems of Classes 2, 3, 4 and 5, respectively.


                           Table 5
                            compares the best cost averaged over the four instances (Classes 2–5) of each test problem (problems 1–36) against previous approaches for the Unrestricted 2L-CVRP. Our VNS could find better value for 20 problems, compared to the best value obtained by previous approaches, and match the best value for 8 problems.


                           Table 6
                            gives the comparisons between the best cost found by VNS and the best cost obtained by previously published approaches on 144 instances of the Unrestricted 2L-CVRP. Our VNS could find better value for 65 instances and match the best value for 54 instances, compared to the best solutions obtained by previous approaches.


                           Table 7
                            provides the average and best results obtained by our method on each of the instances of Classes 2–5 for Sequential 2L-CVRP. We observe that the percentage gaps between the average and best solution achieved over the 10 runs were limited to 0.48 percent, 0.34 percent, 0.29 percent and 0.35 percent, for the problems of Classes 2, 3, 4 and 5, respectively. Thus, our approach is also rather robust for the Sequential 2L-CVRP.


                           Table 8
                            compares the best cost averaged over the four instances (Classes 2–5) of each test problem (problems 1–36) against previous approaches for the Sequential 2L-CVRP. Our approach could find better value for 25 instances and match the best value for 10 instances, compared to the best solutions obtained by previous approaches.


                           Table 9
                            presents the comparison between the best cost found by VNS and the best cost obtained by previously published approaches on 144 instances of the Sequential 2L-CVRP. Our VNS could find better value for 88 instances and matches the best value for 54 instances, compared to the best solutions obtained by previous approaches.

In summary, some interesting phenomena can be observed. According to Tables 6 and 9, our VNS algorithm performs better for Sequential 2L-CVRP. The VNS method improves the previous best known solutions (BKS) by 0.05–0.53 percent on Unrestricted Classes 2, 4 and 5, while the improvement on the Sequential classes is at least 0.58 percent. In addition, it is clear that more improvement is obtained on Classes 4 and 5 compared to Classes 2 and 3 for both two problem versions. Furthermore, the proposed VNS performs quite well on large-scale instances, in which almost all BKS are improved for Classes 2–5 of Unrestricted problems 25–36 and Sequential 18–36. Therefore, our proposed VNS is an effective algorithm for 2L-CVRP.

In terms of computational time, it is difficult to compare the running times of different algorithms fairly because different algorithms were coded in different programming languages and tested on different machines. However, the time limit for each instance shows that the proposed VNS is rather efficient, as well.

To investigate the convergence behavior of our VNS, we perform an additional experiment on the large-scale instances 31–36 of Class 5. For each instance, we ran VNS one time (the random seed is set to 1) for 3600 CPU seconds. The results are shown in Fig. 5
                        . We plotted the minimum cost found by VNS for each instance as the computational time increases; note that the x-axis values increase exponentially. We can see from this figure that our VNS approach exhibits rapid convergence for most of these instances. For the Unrestricted 2L-CVRP, our VNS converged after 1024 seconds on all instances. For the Sequential 2L-CVRP, our VNS converged after 2048 seconds on all instances, except the instance 36.

To investigate the behavior of our VNS, we perform additional experiments on a subset of selected instances. For each class, one out of three instances are selected, i.e., instance 3, 6, ..., 33 and 36. Therefore, 60 instances are selected in total. The following experiments were run on these instances. For each instance, we executed VNS once (the random seed is set to 1).

Note that our initial solution is constructed via an insertion based heuristic. In order to investigate the improvement achieved by the VNS over this initial solution, we record the cost of the initial solution and the running time of the construction process. The results are shown in Tables 10
                            and 11
                           . The column Imp is the improvement obtained by the VNS, which is calculated as 100(Cinit
                            − Cfinal
                           )/Cinit
                           . The results show that the average improvement is larger than 40 percent for all classes of both Unrestricted and Sequential 2L-CVRP. The average ratio (column ratio) of the running time of the construction over the total useful time is about 10 percent for most classes of 2L-CVRP.

In order to analyze the effect of the skyline heuristic, we replace the skyline heuristic packing procedure TabuPack with the packing procedure LH
                           2SL
                            used by Gendreau et al. (2008) and LBFH by Leung et al. (2011). All the other parts remain the same. The comparative results are given in Table 12
                           , in which the cost is averaged over the instance with the same id. We can see that the results of VNS are much better than VNS + LH
                           2SL
                            and VNS+LBFH. Combined with the results in

Table 3, we can conclude that the skyline heuristic makes a significant contribution to the final result in our approach.

Note that when checking the feasibility of a route by TabuPack, we iteratively double the effort spent on the same route until the maximum effort allowed is reached. In our implementation, a parameter iter is used to control the effort spent by TabuPack, and iter is doubled from 1 until the maximum allowed value n (the number of rectangle) is reached. Another alternative implementation is to set the effort to the maximum effect allowed directly, which means that iter is set to n instead of 1 in the first call of TabuPack. Thus, TabuPack is called only once for each route. We modify the VNS to use this alternative implementation and give the results of the modified VNS as VNS1 in Table 12. The results show that VNS is slightly better than VNS1, especially for the large instances (instance 30, 33 and 36) of the Sequential version. These instances are the most difficult instances in our test set. Thus, the method of iteratively doubling the effort spent on the same route is very useful for the difficult instances.

One of the differences between our VNS and classical VNS is that up to K (K is the number of vehicles) random points, instead of one, are produced by each neighborhood structure. In order to test the effect of this strategy, we test another three versions by setting the number of random points to 1, K/2 and 2K, respectively. The results are summarized in Table 13
                           . We can see that the results are improved by generating more than one random point, especially for the large instances. However, there is not much difference among the results of generating K/2, K, and 2K random points. Thus, in our implementation, we set this parameter to K.

Our diversification procedure Diversify is used to escape from the incumbent local optimum. To investigate the effect of the diversify procedure, we test another version by removing the procedure Diversify (Line 16 in Algorithm 1). Moreover, in our implementation of VNS, the number of erased customers is set to min (0.5 × N, 0.1 × N + nonImp). To analyze the sensitivity of this parameter on the final results, we test another two versions by setting this parameter to N/10 and N/2, respectively. The comparative results are shown in Table 14
                           .

From this table, we can see that the results using diversification are similar to those of without diversification for the Unrestricted version. However, for the Sequential version, the results are improved after using Diversify. The results obtained by setting the number of erased customers to the tested three values are similar. Thus, to achieve good performance on different instances, we set the number of erased customers to min (0.5 × N, 0.1 × N + nonImp).

@&#CONCLUSIONS@&#

In this paper, we propose a variable neighborhood search algorithm for the capacitated vehicle routing problem with two-dimensional loading constraints. The variable neighborhood search, which incorporates a diversification procedure to help escape from the local optima, is developed to mainly address the routing aspect. An adapted skyline heuristic is invoked to handle the loading constraints. In addition, some efficient strategies are used to accelerate the procedure. Moreover, an innovative manner of using data structure Trie is introduced not only to record the loading feasibility information of routes already examined, but also to control the effort of examining the loading constraints. Numerical experiments show that the proposed VNS method is superior to all previously published algorithms, and it could find better value for 65 instances of Unrestricted 2L-CVRP and 88 instances for Sequential 2L-CVRP out of 144 instances. Furthermore, the computational time is also competitive. Thus, the proposed VNS is quite robust, effective and efficient for this problem.

@&#ACKNOWLEDGMENT@&#

This work was partially supported by the National Natural Science Foundation of China (Grant no. 71401065 and 61272003).

@&#REFERENCES@&#

