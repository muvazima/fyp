@&#MAIN-TITLE@&#Clustering condition-based maintenance for systems with redundancy and economic dependencies

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We consider multi-unit systems with both redundancy and economic dependencies.


                        
                        
                           
                           We are the first to consider Condition-Based Maintenance for such systems.


                        
                        
                           
                           Preventive maintenance can be used to avoid more expensive corrective maintenance.


                        
                        
                           
                           Utilizing redundancy by postponing corrective maintenance can reduce costs.


                        
                        
                           
                           Our policy significantly outperforms previously considered maintenance policies.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Reliability

Maintenance

Redundancy

Economic dependencies

Dynamic programming

@&#ABSTRACT@&#


               
               
                  Systems that require maintenance typically consist of multiple components. In case of economic dependencies, maintaining several of these components simultaneously can be more cost efficient than performing maintenance on each component separately, while in case of redundancy, postponing maintenance on some failed components is possible without reducing the availability of the system. Condition-based maintenance (CBM) is known as a cost-minimizing strategy in which the maintenance actions are based on the actual condition of the different components. No research has been performed yet on clustering CBM tasks for systems with both economic dependencies and redundancy. We develop a dynamic programming model to find the optimal maintenance strategy for such systems, and show numerically that it can indeed considerably outperform previously considered policies (failure-based, age-based, block replacement, and more restricted (opportunistic) CBM policies). Moreover, our numerical investigation provides insights into the optimal policy structure.
               
            

Binary variable indicating whether or not a replacement (preventive or corrective) should be performed on component i
                     

Deterioration parameter of component i
                     

Cost of a corrective replacement on component i
                     

Cost of a preventive replacement on component i, 
                           
                              
                                 c
                                 p
                                 i
                              
                              <
                              
                                 c
                                 c
                                 i
                              
                           
                        
                     

Fixed set-up cost for maintenance

Optimum cumulative cost from period t on

Pdf of the deterioration increments of component i
                     

Number of components in the system that need to function for the system to function

Fixed failure level of component i
                     

Number of components in the system

Penalty for a system failure

System reliability, given deterioration levels of 
                           
                              
                                 x
                                 1
                              
                              ,
                              
                                 x
                                 2
                              
                              ,
                              …
                              ,
                              
                                 x
                                 N
                              
                           
                         for components 
                           
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              N
                              ,
                           
                         respectively

Reliability of component i, given a deterioration level of xi
                        
                     

Set of all component labels, 
                           
                              
                                 S
                                 N
                              
                              :
                              =
                              
                                 {
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 N
                                 }
                              
                           
                        
                     

Condition of component i at time t, 
                           
                              
                                 X
                                 0
                                 i
                              
                              =
                              0
                           
                        
                     

Condition of component i after possible maintenance has been performed

Increase in deterioration on component i during t, 
                           
                              
                                 X
                                 
                                    t
                                    +
                                    1
                                 
                                 i
                              
                              =
                              
                                 
                                    X
                                    ¯
                                 
                                 t
                                 i
                              
                              +
                              
                                 Y
                                 t
                                 i
                              
                           
                        
                     

@&#INTRODUCTION@&#

Maintenance costs can constitute up to 60 percent of the production costs of manufacturing firms, of which one third may be due to unnecessary or poorly executed maintenance (Mobley, 2002). For this reason, a lot of research has been developed in the field of maintenance strategies over the past decades, e.g. McCall (1965); Thomas (1986); Wang (2002), aiming to determine the right moment for performing maintenance. Whereas failure-based maintenance is always performed too late, i.e., after a failure has occurred, preventive maintenance strategies such as block replacement or age-based maintenance are typically too conservative, as they tend to schedule maintenance more often than required. Condition-based maintenance (CBM) can be a more efficient strategy, as it postpones maintenance activities where possible while limiting failures due to constant monitoring of certain conditions, such as vibration and temperature (Gertsbakh, 1977; 2000). Nevertheless, most of the existing research focuses on preventive maintenance policies rather than CBM.

Most contributions develop maintenance policies for simple systems consisting of a single unit (Wang, 2002). However, the simplicity of these models compared to the complex reality may be one of the factors explaining the lack of success in applications of maintenance policies (Van der Duyn Schouten, 1996), which is why research is shifting more and more to realistic systems that contain multiple components. Literature reviews on maintenance policies for multi-unit systems are given by Cho and Parlar (1991); Dekker, Wildeman, and van der Duyn Schouten (1997); Van der Duyn Schouten (1996); McCall (1965); Thomas (1986); Wang (2002). Again, most of this research focuses on preventive maintenance rather than on CBM.

When dealing with multi-unit systems, three types of dependencies can exist: economic dependence, structural dependence, and stochastic dependence. Applying a single-unit model to a multi-unit maintenance problem is only optimal if none of these dependencies applies (Cho & Parlar, 1991). In this paper, we focus on economic dependencies, which means that combining maintenance actions can yield a lower total cost than maintaining each component separately (Castanier, Grall, & Bérenguer, 2005). This is for example the case when fixed set-up costs need to be paid, which are independent of the number of components that require maintenance. Economic dependencies are very common in most continuous operating systems, such as aircrafts, powerplants, or chemical processing facilities (Wang, 2002). Combining maintenance on different components is also known as clustering or opportunistic maintenance. There is often a great cost saving potential by implementing an opportunistic maintenance policy for multi-unit systems with economic dependencies (Wang, 2002).

In practice, many multi-unit systems employ redundancy, which is the most common approach to increase availability and prevent downtime of the equipment (Moghaddass, Zuo, & Pandey, 2012). Consider for example a gas distribution company that has plants with redundant pumps to distribute gas, to ensure a continuous operation of the system and to prevent that clients will be without gas. A well-known type of redundancy in systems with spares or in so-called fault-tolerant systems is the k-out-of-N system, which has wide applications in both industrial and military systems (Kuo & Zuo, 2003). A k-out-of-N system is a system consisting of N components which functions as long as at least k components function. Many settings can be viewed as special cases of the k-out-of-N system; the 1-out-of-N system represents a parallel system (fully-redundant), the N-out-of-N system represents a series system (non-redundant), and the k-out-of-N system with 1 < k < N is also known as a partially-redundant system (Boland & Proschan, 1983; Misra, 2012).

While scheduling maintenance, systems with redundancy have the unique property that the system could still function even if some components have failed. Hence, failed components do not always require immediate replacement. In case of economic dependencies, it might be cheaper to postpone the maintenance until other components require maintenance as well. Of course, doing so does increase the risk of down-time as (some of) the remaining units also fail unexpectedly. Obviously, condition monitoring could reduce that risk, but CBM has so far not been considered for multi-unit systems with economic dependencies and redundancy. To the best of our knowledge, this paper is the first to do so.

The remainder of this article is organized as follows. In Section 2, a short overview of relevant literature is given. Section 3 describes the system under investigation. Section 4 explains the dynamic programming model used to optimize the maintenance policy. In Sections 5 and 6, results of a numerical investigation are presented, describing the optimal policy and comparing it to classical policies. Section 7 concludes the paper.

@&#LITERATURE REVIEW@&#

Many authors have considered one or more of the following elements: CBM, redundancy, or economic dependencies. Fig. 1
                      gives a schematic overview of the types of systems considered. Although the figure is intended as an illustration, all articles are included that combine at least two of the elements. Interestingly, there is just a single study on CBM for systems with redundancy (Lu & Jiang, 2007). Moreover, this study does not consider economic dependencies, as we do.

Examples of articles that consider corrective or preventive maintenance policies for systems with redundancy, in the form of k-out-of-N systems, are given by Bjarnason, Taghipour, and Banjevic (2014); Park and Pham (2012); de Smidt-Destombes, van der Heijden, and van Harten (2004); 2006); 2007); 2009). In fact, failure-based maintenance is considered in Bjarnason et al. (2014), while block replacement is studied in Park and Pham (2012); de Smidt-Destombes, van der Heijden, and van Harten (2007). Both de Smidt-Destombes, van der Heijden, and van Harten (2009) and de Smidt-Destombes et al. (2004) study purely corrective maintenance that is initiated as soon as the number of failed components exceeds some critical level, while in de Smidt-Destombes, van der Heijden, and van Harten (2006) both failed and degraded components are replaced at those times. An example of an article that is only focused on CBM is given by Wang, Chu, and Mao (2009), in which a preventive replacement threshold is considered for a multi-unit system. So far, CBM has only been considered for a system with redundancy in Lu and Jiang (2007), where failure-based maintenance, time-based maintenance, and CBM with a preventive replacement threshold are compared for a k-out-of-N standby system without economic dependencies.

In Dekker et al. (1997), a literature review on maintenance policies for multi-unit systems with economic dependencies is given. An example of a preventive replacement policy developed for a multi-unit series system with economic dependencies is that by Zhou, Xi, and Lee (2009), while CBM policies are considered for a two-unit series system with economic dependencies by Barbera, Schneider, and Watson (1999); Castanier et al. (2005). Furthermore, maintenance actions are grouped based on condition-monitoring information for a multi-unit system with economic dependencies in Bouvard, Artus, Bérenguer, and Cocquempot (2011), and a CBM policy with risk-thresholds for preventive and opportunistic replacements is considered for a multi-unit system with economic dependencies in Tian and Liao (2011). Finally, an article that considers systems with different structures (including k-out-of-N) and economic dependencies is given by Vu, Do, Barros, and Bérenguer (2014), in which periodic age-based maintenance actions are grouped.

To our knowledge, despite the widespread presence in industry of systems with both redundancy and economic dependencies, no research has been performed on CBM for such systems. We will cover this gap by developing a dynamic programming model to optimize the CBM policy for a k-out-of-N system with economic dependencies. An advantage of applying dynamic programming for this explorative study is that the structure of the optimal policy can be explored (numerically) and compared to commonly used strategies. Previously, dynamic programming has also been applied in, for example, Barbera et al. (1999); Zhou et al. (2009).

We consider a k-out-of-N system, defined here as a system consisting of N (nonidentical) components that functions as long as at least k components function (1 ≤ k ≤ N). All functioning components are subject to failure, that is, we consider a hot standby system. The deterioration process that we consider shows similarities to that of the two-unit series system considered by Barbera et al. (1999). Let SN
                         denote the set of all component labels, i.e., 
                           
                              
                                 S
                                 N
                              
                              :
                              =
                              
                                 {
                                 1
                                 ,
                                 2
                                 ,
                                 …
                                 ,
                                 N
                                 }
                              
                           
                        . The condition, or deterioration level, of component i can be described by a random variable 
                           
                              
                                 X
                                 t
                                 i
                              
                              ,
                           
                         for i ∈ SN
                         and 
                           
                              t
                              ∈
                              N
                           
                        . After a replacement (say at time tr
                        ), component i is assumed to be as-good-as-new, i.e., 
                           
                              
                                 X
                                 
                                    
                                       t
                                       r
                                    
                                 
                                 i
                              
                              =
                              0
                              ,
                           
                         while a deterioration level exceeding the fixed failure level Li
                         implies that component i has failed. Immediately following possible replacements, which are assumed to be instantaneous, component i is subject to a random increase in deterioration 
                           
                              
                                 Y
                                 t
                                 i
                              
                              ,
                           
                         for i ∈ SN
                         and 
                           
                              t
                              ∈
                              N
                           
                        . Hence, if component i is not replaced at the start of time unit t, its deterioration level at time unit 
                           
                              t
                              +
                              1
                           
                         is equal to 
                           
                              
                                 X
                                 
                                    t
                                    +
                                    1
                                 
                                 i
                              
                              =
                              
                                 X
                                 t
                                 i
                              
                              +
                              
                                 Y
                                 t
                                 i
                              
                           
                        . If, on the other hand, component i is replaced, its deterioration level becomes 
                           
                              
                                 X
                                 
                                    t
                                    +
                                    1
                                 
                                 i
                              
                              =
                              
                                 Y
                                 t
                                 i
                              
                           
                        . The probability density function of the i.i.d. non-negative deterioration increments 
                           
                              Y
                              t
                              i
                           
                         of component i is denoted by fi
                        , for i ∈ SN
                         and 
                           
                              t
                              ∈
                              N
                              ,
                           
                         which can be either continuous or discrete.

At the start of each time unit, the condition of each component is known. If there are less than k functioning components, the system has failed, and a penalty cost p for a system failure is incurred. Next, a decision is needed on what components to replace. If component i is replaced, either the preventive replacement cost 
                           
                              c
                              p
                              i
                           
                         or the corrective replacement cost 
                           
                              c
                              c
                              i
                           
                         is incurred, depending on whether the component has failed. Typically, a corrective replacement is more expensive than a preventive replacement (i.e., 
                           
                              
                                 c
                                 c
                                 i
                              
                              >
                              
                                 c
                                 p
                                 i
                              
                           
                        ), due to for example the unexpected nature of a failure or the fact that a preventive replacement could be an easy fix, while a failure can cause additional damage on other parts of the equipment, implying a more expensive replacement. This distinction is also made in, for example, Bouvard et al. (2011); Castanier et al. (2005); de Jonge, Klingenberg, Teunter, and Tinga (2015); Lu and Jiang (2007); Park and Pham (2012); Zhou et al. (2009). In addition, as soon as at least one of the components is replaced, the shared set-up cost cs
                         is incurred. In practice, this shared set-up cost can arise from e.g. ordering spare parts, traveling to the plant, or shutting down the system.

The dynamic programming model that we will use for optimizing the maintenance policy is partially based on that in Barbera et al. (1999). We introduce the function Ri
                     ( · ), which equals 1 if component i is functioning (i.e., its deterioration level xi
                      is below the fixed failure level), and 0 if it has failed. Hence,

                        
                           
                              
                                 
                                    R
                                    i
                                 
                                 
                                    (
                                    
                                       x
                                       i
                                    
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                1
                                                ,
                                             
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   
                                                      x
                                                      i
                                                   
                                                   <
                                                   
                                                      L
                                                      i
                                                   
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                0
                                                ,
                                             
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   
                                                      x
                                                      i
                                                   
                                                   ≥
                                                   
                                                      L
                                                      i
                                                   
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     We further introduce the function 
                        
                           R
                           (
                           
                              x
                              1
                           
                           ,
                           
                              x
                              2
                           
                           ,
                           …
                           ,
                           
                              x
                              N
                           
                           )
                           ,
                        
                      which equals 1 if the system functions, and 0 if it has failed, given that components 
                        
                           1
                           ,
                           2
                           ,
                           …
                           ,
                           N
                        
                      have deterioration levels 
                        
                           
                              x
                              1
                           
                           ,
                           
                              x
                              2
                           
                           ,
                           …
                           ,
                           
                              x
                              N
                           
                           ,
                        
                      respectively. This function can be expressed as follows:

                        
                           
                              
                                 R
                                 
                                    (
                                    
                                       x
                                       1
                                    
                                    ,
                                    
                                       x
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       x
                                       N
                                    
                                    )
                                 
                                 =
                                 
                                    {
                                    
                                       
                                          
                                             
                                                1
                                                ,
                                             
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   
                                                      ∑
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      N
                                                   
                                                   
                                                      R
                                                      i
                                                   
                                                   
                                                      (
                                                      
                                                         x
                                                         i
                                                      
                                                      )
                                                   
                                                   ≥
                                                   k
                                                
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                0
                                                ,
                                             
                                          
                                          
                                             
                                                if
                                                
                                                
                                                   
                                                      ∑
                                                      
                                                         i
                                                         =
                                                         1
                                                      
                                                      N
                                                   
                                                   
                                                      R
                                                      i
                                                   
                                                   
                                                      (
                                                      
                                                         x
                                                         i
                                                      
                                                      )
                                                   
                                                   <
                                                   k
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     Maintenance costs are determined at the start of a time unit t. For this, the binary variable δi
                      is used to indicate whether any replacements (preventive or corrective) are performed on component i, while 
                        
                           
                              x
                              ¯
                           
                           t
                           i
                        
                      denotes the condition of component i after possible replacements have been performed, i.e.,

                        
                           
                              
                                 
                                    
                                       
                                          δ
                                          i
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      1
                                                      ,
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      a
                                                      
                                                      replacement
                                                      
                                                      (preventive
                                                      
                                                      or
                                                      
                                                      corrective)
                                                      
                                                      is
                                                   
                                                
                                             
                                             
                                                
                                                
                                                   
                                                      
                                                      performed
                                                      
                                                      on
                                                      
                                                      component
                                                      
                                                      i
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      0
                                                      ,
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      no
                                                      
                                                      replacement
                                                      
                                                      is
                                                      
                                                      performed
                                                      
                                                      on
                                                      
                                                      component
                                                      
                                                      i
                                                      ,
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             x
                                             ¯
                                          
                                          t
                                          i
                                       
                                    
                                    
                                       =
                                    
                                    
                                       
                                          
                                             (
                                             1
                                             −
                                             
                                                δ
                                                i
                                             
                                             )
                                          
                                          ·
                                          
                                             x
                                             t
                                             i
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     The penalty for a system failure at the start of time unit t (before possible replacements are performed) is given by

                        
                           (1)
                           
                              
                                 p
                                 ·
                                 (
                                 1
                                 −
                                 R
                                 
                                    (
                                    
                                       x
                                       t
                                       1
                                    
                                    ,
                                    
                                       x
                                       t
                                       2
                                    
                                    ,
                                    …
                                    ,
                                    
                                       x
                                       t
                                       N
                                    
                                    )
                                 
                                 )
                                 .
                              
                           
                        
                     If at least one component is replaced, the set-up cost cs
                      is incurred, which can be expressed as

                        
                           (2)
                           
                              
                                 
                                    (
                                    1
                                    −
                                    
                                       ∏
                                       
                                          i
                                          =
                                          1
                                       
                                       N
                                    
                                    
                                       (
                                       1
                                       −
                                       
                                          δ
                                          i
                                       
                                       )
                                    
                                    )
                                 
                                 ·
                                 
                                    c
                                    s
                                 
                                 .
                              
                           
                        
                     Furthermore, if component i is replaced while it is still functioning, the preventive replacement cost 
                        
                           c
                           p
                           i
                        
                      is incurred. Hence, the total preventive replacement costs at time t for all components are equal to

                        
                           (3)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    δ
                                    i
                                 
                                 ·
                                 
                                    R
                                    i
                                 
                                 
                                    (
                                    
                                       x
                                       t
                                       i
                                    
                                    )
                                 
                                 ·
                                 
                                    c
                                    p
                                    i
                                 
                                 .
                              
                           
                        
                     If component i has failed, it could be replaced correctively, meaning that the total corrective replacement costs (depending on whether or not the component is replaced) are given by

                        
                           (4)
                           
                              
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 
                                    δ
                                    i
                                 
                                 ·
                                 
                                    (
                                    1
                                    −
                                    
                                       R
                                       i
                                    
                                    
                                       (
                                       
                                          x
                                          t
                                          i
                                       
                                       )
                                    
                                    )
                                 
                                 ·
                                 
                                    c
                                    c
                                    i
                                 
                                 .
                              
                           
                        
                     In the dynamic programming model, let Ct
                      denote the optimum cumulative cost from period t onwards. These costs consist of the direct costs at time t (consisting of the penalty cost for a system failure (1), the set-up costs (2), the preventive replacement costs (3), and the corrective replacement costs (4)) and the expected costs from period 
                        
                           t
                           +
                           1
                        
                      onwards. Hence, Ct
                      can be expressed as follows:

                        
                           (5)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          
                                             C
                                             t
                                          
                                          
                                             (
                                             
                                                x
                                                t
                                                1
                                             
                                             ,
                                             
                                                x
                                                t
                                                2
                                             
                                             ,
                                             …
                                             ,
                                             
                                                x
                                                t
                                                N
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          =
                                          
                                             min
                                             
                                                
                                                   δ
                                                   1
                                                
                                                ,
                                                
                                                   δ
                                                   2
                                                
                                                ,
                                                …
                                                ,
                                                
                                                   δ
                                                   N
                                                
                                             
                                          
                                          
                                             {
                                             p
                                             ·
                                             
                                                (
                                                1
                                                −
                                                R
                                                
                                                   (
                                                   
                                                      x
                                                      t
                                                      1
                                                   
                                                   ,
                                                   
                                                      x
                                                      t
                                                      2
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      x
                                                      t
                                                      N
                                                   
                                                   )
                                                
                                                )
                                             
                                             +
                                             
                                                (
                                                1
                                                −
                                                
                                                   ∏
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   N
                                                
                                                
                                                   (
                                                   1
                                                   −
                                                   
                                                      δ
                                                      i
                                                   
                                                   )
                                                
                                                )
                                             
                                             ·
                                             
                                                c
                                                s
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          +
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             N
                                          
                                          
                                             δ
                                             i
                                          
                                          ·
                                          
                                             R
                                             i
                                          
                                          
                                             (
                                             
                                                x
                                                t
                                                i
                                             
                                             )
                                          
                                          ·
                                          
                                             c
                                             p
                                             i
                                          
                                          +
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             N
                                          
                                          
                                             δ
                                             i
                                          
                                          ·
                                          
                                             (
                                             1
                                             −
                                             
                                                R
                                                i
                                             
                                             
                                                (
                                                
                                                   x
                                                   t
                                                   i
                                                
                                                )
                                             
                                             )
                                          
                                          ·
                                          
                                             c
                                             c
                                             i
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          +
                                          
                                             ∫
                                             0
                                             ∞
                                          
                                          ⋯
                                          
                                             ∫
                                             0
                                             ∞
                                          
                                          
                                             C
                                             
                                                t
                                                +
                                                1
                                             
                                          
                                          
                                             (
                                             
                                                
                                                   x
                                                   ¯
                                                
                                                t
                                                1
                                             
                                             +
                                             
                                                y
                                                1
                                             
                                             ,
                                             
                                                
                                                   x
                                                   ¯
                                                
                                                t
                                                2
                                             
                                             +
                                             
                                                y
                                                2
                                             
                                             ,
                                             …
                                             ,
                                             
                                                
                                                   x
                                                   ¯
                                                
                                                t
                                                N
                                             
                                             +
                                             
                                                y
                                                N
                                             
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          
                                             ·
                                             
                                                ∏
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                N
                                             
                                             
                                                [
                                                
                                                   f
                                                   i
                                                
                                                
                                                   (
                                                   
                                                      y
                                                      i
                                                   
                                                   )
                                                
                                                ]
                                             
                                             d
                                             
                                                y
                                                N
                                             
                                             ⋯
                                             d
                                             
                                                y
                                                1
                                             
                                             }
                                          
                                          .
                                       
                                    
                                 
                              
                           
                        
                     We are interested in minimizing the long-run average cost per time unit. This can be achieved by starting with (for example) 
                        
                           
                              C
                              T
                           
                           
                              (
                              
                                 x
                                 T
                                 1
                              
                              ,
                              
                                 x
                                 T
                                 2
                              
                              ,
                              …
                              ,
                              
                                 x
                                 T
                                 N
                              
                              )
                           
                           =
                           0
                        
                      for all 
                        
                           x
                           T
                           i
                        
                      and sufficiently high T, and recursively applying (5) until both the average cost per time unit, 
                        
                           
                              C
                              t
                           
                           
                              (
                              
                                 x
                                 t
                                 1
                              
                              ,
                              
                                 x
                                 t
                                 2
                              
                              ,
                              …
                              ,
                              
                                 x
                                 t
                                 N
                              
                              )
                           
                           −
                           
                              C
                              
                                 t
                                 +
                                 1
                              
                           
                           
                              (
                              
                                 x
                                 
                                    t
                                    +
                                    1
                                 
                                 1
                              
                              ,
                              
                                 x
                                 
                                    t
                                    +
                                    1
                                 
                                 2
                              
                              ,
                              …
                              ,
                              
                                 x
                                 
                                    t
                                    +
                                    1
                                 
                                 N
                              
                              )
                           
                           ,
                        
                      and the corresponding maintenance policy have converged. Subsequently, the long-run average cost will become independent of the initial system state. Furthermore, the resulting optimal maintenance policy will only depend on the system state, and thus becomes independent of time.

In the next section, we numerically investigate the performances of our dynamic program, and compare these with previously considered maintenance policies.

We first consider a 1-out-of-2 system consisting of two identical components, with a discrete state space. In this setting with two components, the optimal policy can easily be presented in two-dimensional tables, showing the optimal maintenance action for each combination of deterioration states of both components. This allows easy interpretation of the optimal policy and comparison to other policies. By considering identical components, we can omit the superscripts denoting to which component a certain cost corresponds.

We next describe a base scenario. We remark that the specific parameter settings are somewhat arbitrary and indeed selected as they allow us to highlight important characteristics of the optimal policy. Effects of parameter variations will later be explored in a sensitivity analysis. The preventive replacement costs are 
                           
                              
                                 c
                                 p
                              
                              =
                              5
                           
                         per component, whilst the corrective replacement costs are 
                           
                              
                                 c
                                 c
                              
                              =
                              11
                           
                         per component. In case at least one component is replaced, the set-up costs of 
                           
                              
                                 c
                                 s
                              
                              =
                              4
                           
                         are incurred, and if the system fails the penalty costs 
                           
                              p
                              =
                              300
                           
                         are incurred. The deterioration increments follow a Poisson distribution with mean 
                           
                              μ
                              =
                              0.7
                              ,
                           
                         and a component fails once its deterioration level reaches the fixed failure limit 
                           
                              L
                              =
                              5
                           
                        . The choice of a Poisson distribution guarantees a discrete state space, which enables us to consider a finite number of states in the dynamic programming model.

The optimal maintenance policy and corresponding average cost obtained with the dynamic program converge relatively quickly for this case and other scenarios; at most 30 iterations are needed. Our computations are made using Python 3.4.3 on a computer with a 3.30 GHz quad core processor and 8.00 Gigabyte of RAM. For this example, it takes 0.05 seconds to find the optimal maintenance policy and corresponding average cost.


                        Fig. 2
                         shows the long-run optimal maintenance policy for this example, where for any combination of the deterioration levels X
                        1 and X
                        2 the optimal maintenance actions are represented. These maintenance actions are independent of time. Note that ‘00’ corresponds to no replacements at all, ‘10’ means that only component 1 is replaced, ‘01’ means that only component 2 is replaced, and ‘11’ corresponds to a complete system replacement. The long-run average costs corresponding to this optimal maintenance policy are equal to 3.42 per time unit.

Note the non-monotonic behavior of the optimal policy, for instance by considering the “
                           
                              
                                 X
                                 1
                              
                              =
                              0
                           
                        ” row. For deterioration levels of up to 3 for component 2, it is not replaced as component 1 is in good condition, and there is redundancy. However, if component 2 further deteriorates into state 4 (implying imminent failure), then it is preventively replaced in order to avoid higher corrective replacement costs. This motivation disappears if component 2 has already failed (state 5). In that case, the corrective replacement is postponed until component 1 has a deterioration level of at least 2, thus utilizing the redundancy. Of course, this behavior is driven by the (realistic) assumption that a corrective replacement is more costly than a preventive replacement. None of the more common maintenance policies allows this sort of behavior, as we will discuss after listing them.

                           
                              
                                 Failure-based maintenance: This strategy can be interpreted as a simple inspection policy, where only failed components are replaced.


                                 Multi-threshold maintenance without OM: Components are correctively replaced upon failure, and preventively as soon as their deterioration level reaches a certain threshold value ξ (0 ≤ ξ ≤ L), which needs to be optimized. No opportunistic maintenance (OM) is considered.


                                 Multi-threshold maintenance with OM: This policy is similar to the policy above, but each component has an additional (opportunistic) threshold value. A component is replaced preventively if its deterioration level exceeds the preventive maintenance threshold ξ (0 ≤ ξ ≤ L), independent of the states of other components, and also if its deterioration level exceeds the opportunistic maintenance (OM) threshold ζ (0 ≤ ζ ≤ ξ), provided that at least one other component requires a replacement. Both ξ and ζ need to be optimized.


                                 Age-based maintenance: A component is replaced correctively upon failure or preventively as soon as it reaches age A. This replacement age A needs to be optimized.


                                 Block replacement without intermediate CM: The complete system is replaced periodically with periodicity P, which needs to be optimized. If a component fails, it remains in the failed state until the next scheduled system replacement, so no corrective maintenance (CM) is performed between two system replacements.


                                 Block replacement with intermediate CM: This policy is similar to the policy above, but in addition components are replaced correctively upon failure. This does not affect the moment of the next system replacement. Also here the periodicity P needs to be optimized.

The costs corresponding to the different maintenance policies are obtained by using simulation, for which we consider 10,500 periods (of which the first 500 time units are used as the warm-up time) and 100 replications. The resulting minimal long-run average costs per time unit along with the corresponding standard error are given in Table 1
                        . Also the optimal parameters of the different maintenance policies are included.

From Table 1, we observe that the standard errors are small, indicating significant cost differences between the various policies. Hence, we can conclude that failure-based maintenance performs worst, which makes sense as this is the least advanced policy. Also the preventive maintenance policies, such as age-based maintenance and block replacement, perform much worse than the optimal case, with costs that are about 50 percent higher. An interesting observation is the fact that replacing failed components between two consecutive system replacements in the block replacement strategy reduces costs substantially compared to leaving failed components in the failed state until the next planned replacement.

Furthermore, even compared to the most advanced condition-based maintenance policies which use threshold values to schedule replacements, a large cost saving can apparently be obtained by allowing for a different structure of the policy. Figs. 3
                         and 4
                         show the optimal multi-threshold maintenance policies without and with opportunistic maintenance, respectively. It turns out that these policies are too restrictive, by scheduling replacements more often than actually required, leading to costs that are about 10 percent higher than necessary.

The non-monotonic behavior of the optimal policy, in that it could be optimal to preventively replace a component that is close to failure (in order to avoid higher corrective replacement costs), and to postpone a corrective replacement on a failed component until the other component has deteriorated a bit more, is caused by the assumption that the costs of a corrective replacement cc
                         exceed those of a preventive replacement cp
                        . To illustrate this, Fig. 5
                        
                         shows the optimal policy for corrective replacement costs of 
                           
                              
                                 c
                                 c
                              
                              =
                              9
                           
                         and 
                           
                              
                                 c
                                 c
                              
                              =
                              7
                           
                         (whereas we considered 
                           
                              
                                 c
                                 c
                              
                              =
                              11
                           
                         in the original example). Indeed, as the corrective replacement costs approach the preventive replacement costs 
                           
                              
                                 c
                                 p
                              
                              =
                              5
                              ,
                           
                         performing a preventive replacement to avoid a corrective replacement becomes less rewarding. In fact, for 
                           
                              
                                 c
                                 c
                              
                              =
                              7
                              ,
                           
                         this effect has disappeared already. In line with this, preventive replacements are performed less often as the costs of a corrective replacement decrease.

Furthermore, to give an indication of the performances of our model for these lower corrective replacement costs, Table 2
                         shows the minimal long-run average costs per time unit for different maintenance policies and for different values of the corrective replacement costs cc
                         along with the percentage increase in costs compared to the optimal policy. For ease of comparison, we also included the original case with 
                           
                              
                                 c
                                 c
                              
                              =
                              11
                           
                        .

Although the non-monotonic behavior of the optimal policy may disappear for values of cc
                         close to cp
                        , we observe that the cost difference compared to for example the multi-threshold policies increases for decreasing values of cc
                        . Indeed, the optimal policy has a completely different structure than considered in other maintenance policies. Hence, our model still significantly outperforms previously considered maintenance policies, indicating that it is of value for varying cost scenarios.

Another cost parameter that significantly influences the resulting optimal policy is the set-up cost cs
                        . If chosen too low, no need for clustering exists, while if chosen too high, all replacements are clustered. In the latter case, the non-monotonic behavior of the optimal policy also disappears. To illustrate this, Fig. 6 shows the optimal policy for set-up costs of 
                           
                              
                                 c
                                 s
                              
                              =
                              6
                           
                         and 
                           
                              
                                 c
                                 s
                              
                              =
                              8
                           
                         (whereas we considered 
                           
                              
                                 c
                                 s
                              
                              =
                              4
                           
                         in the original example). Indeed, as the set-up costs increase, replacements are clustered more often, while for 
                           
                              
                                 c
                                 s
                              
                              =
                              8
                              ,
                           
                         all replacements are clustered. In line with this, we observe that performing a preventive replacement to avoid a corrective replacement becomes less rewarding as the set-up costs increase.


                        Table 3
                         shows the minimal long-run average costs per time unit for different maintenance policies and for different values of the set-up costs cs
                         along with the percentage increase in costs compared to the optimal policy.

Even though performing a preventive replacement to avoid a corrective replacement becomes less rewarding for increasing set-up costs, we observe that our dynamic program still significantly outperforms previously considered maintenance policies. Interestingly, the cost difference with the multi-threshold maintenance policy without opportunistic maintenance increases as the set-up costs increase, while the cost difference for the same policy with opportunistic maintenance decreases. Hence, clustering becomes more rewarding for higher set-up costs.

The k-out-of-N system is a system in which k components need to function, but redundancy
                         is incorporated by installing N > k components. When deciding on the number of redundant components to install, one is trading off the maintenance costs (for additional components) and the system availability. First, to gain insights into this tradeoff, we will determine the long-run average cost per time unit for different values of k and N. We continue to consider identical components as in the base case, and set 
                           
                              
                                 c
                                 p
                              
                              =
                              5
                              ,
                           
                        
                        
                           
                              
                                 c
                                 c
                              
                              =
                              11
                              ,
                           
                        
                        
                           
                              
                                 c
                                 s
                              
                              =
                              4
                              ,
                           
                        
                        
                           
                              p
                              =
                              300
                              ,
                           
                        
                        
                           
                              μ
                              =
                              0.7
                              ,
                           
                         and 
                           
                              L
                              =
                              5
                           
                        . In all cases, 30 iterations of the dynamic program proved to be sufficient for the cost to converge. Computation time was not much affected by the value of k, but exponentially increasing in N. It took approximately 0.01, 0.05, 0.5, 7.6, and 180 seconds to analyze systems with 
                           
                              N
                              =
                              1
                              ,
                              2
                              ,
                              3
                              ,
                              4
                              ,
                           
                         and 5 components, respectively. Table 4
                         shows the resulting average costs.

From Table 4, it follows that 
                           
                              N
                              =
                              2
                           
                         is sufficient for a system with 
                           
                              k
                              =
                              1
                           
                        . Adding more components will not reduce costs, as the additional maintenance costs do not outweigh the reduced unavailability cost. Note that the cost does not increase in N either, even for relatively large values of N. Such large systems retain efficiency by keeping some components continuously in the failed state. For all k, it holds true that by installing one redundant component (i.e., 
                           
                              N
                              =
                              k
                              +
                              1
                           
                        ), costs are reduced substantially compared with 
                           
                              N
                              =
                              k
                           
                        . This reduction in costs increases to 30.9 percent as k increases to four. Furthermore, adding another redundant component offers little benefit for any value of k considered.

Second, we observed non-monotonic behavior of the optimal maintenance policy for the 1-out-of-2 system in Section 5.1. To investigate whether this result carries over to systems with more components, we now consider the 3-out-of-4 system in some more detail. We choose 3-out-of-4 as it is the largest system solvable in a few seconds. The corresponding optimal policy describes for each component when it should be replaced, depending on the complete system state. Such a policy can become rather complex for large N, but for the 3-out-of-4 system it is summarized in Table 5.

We observe that this maintenance policy exhibits non-monotonic behavior as well. Compare for instance the actions in states (4, 0, 0, 0) and (5, 0, 0, 0), i.e., states where component 1 is in state 4 or 5 and components 2, 3, and 4 are as-good-as-new. If 
                           
                              
                                 X
                                 1
                              
                              =
                              4
                              ,
                           
                         it is optimal to only replace component 1, while if 
                           
                              
                                 X
                                 1
                              
                              =
                              5
                              ,
                           
                         no replacements are performed at all. Instead, the corrective replacement on component 1 is postponed until components 2, 3, and 4 have deteriorated somewhat more, thus exploiting the redundancy and economic dependencies. This implies that the obtained insights do indeed carry over to systems with more than two components.

Third, to explore the performances of the dynamic program for systems with more than two components, Table 6 shows a cost comparison for the 3-out-of-4 system with other maintenance policies.

From comparing Table 6 for a 3-out-of-4 system with Table 1 for a 1-out-of-2 system, we observe first that the cost difference with the multi-threshold maintenance policy decreases to 3.8 percent for 
                           
                              N
                              =
                              4
                           
                        . This implies that a multi-threshold policy might be suitable for systems with many components, although it could still be rewarding to postpone corrective replacements and thus utilize the redundancy. Second, we observe that the optimal multi-threshold maintenance policy does not include opportunistic replacements. Indeed, as the number of components increase, an opportunistic replacement threshold of 
                           
                              ζ
                              =
                              2
                           
                         (as for the 1-out-of-2 system) would imply much more frequent replacements in case of a 3-out-of-4 system, which does not outweigh the savings in set-up costs.

To gain somewhat more insight into the behavior of the optimal policy, we now consider an example with better condition information. To achieve that, we return our attention to the 1-out-of-2 system and assume a fixed failure level of 
                           
                              L
                              =
                              10
                           
                        . In this way, each component can be in 11 different states rather than 6 as in the previous example. Furthermore, we consider preventive replacement costs 
                           
                              
                                 c
                                 p
                              
                              =
                              3
                              ,
                           
                         corrective replacement costs 
                           
                              
                                 c
                                 c
                              
                              =
                              8
                              ,
                           
                         set-up costs 
                           
                              
                                 c
                                 s
                              
                              =
                              5
                              ,
                           
                         and a penalty cost 
                           
                              p
                              =
                              500
                           
                         for two identical components with a mean increase in deterioration per time unit of 
                           
                              μ
                              =
                              2.5
                           
                        . It takes 0.13 seconds to find the optimal policy in this example. Fig. 7 presents the resulting optimal maintenance policy. The costs corresponding to this policy are equal to 4.85 per time unit.

Similarly to the previous case, it turns out that it is optimal to perform a preventive replacement in case of an imminent failure, while a corrective replacement is postponed until the other component has deteriorated to a certain extent. Furthermore, we observe an almost linear diagonal structure in the optimal policy, indicating that the multi-threshold policies are too restricted as they only allow (graphically) for horizontally linear structures. The structure of our optimal policy shows similarities to that obtained for a two-unit series system by Barbera et al. (1999), although in this case with redundancy, we observe that preventive replacements are scheduled less often, and that corrective replacements are sometimes postponed. Also our structure is not completely linear, so allowing for a more flexible structure could reduce costs. Table 7 shows the different (minimal) costs for the various possible maintenance strategies along with the standard errors and, if applicable, the corresponding optimal parameter(s).

Again, failure-based maintenance is the most expensive maintenance strategy, while also the preventive maintenance policies age-based maintenance and block replacement perform much worse than condition-based maintenance. The difference between the multi-threshold policy with opportunistic maintenance and the optimal maintenance policy is equal to 3.3 percent in this case (versus 12.0 percent if no opportunistic maintenance is included).

In the numerical investigation so far, we assumed that the deterioration increments of all components follow a Poisson distribution. This guarantees a discrete state space, and hence a finite number of states in the dynamic program. This allowed easy representation and interpretation of the results. Also, there are many practical cases where condition monitoring is not perfect and therefore not done on a continuous scale. We did already investigate the effect of having better condition information (i.e., of having a larger state space), and in this section, we explore whether the resulting insights carry over to the case of continuous degradation. Since the gamma process is the most appropriate process to model continuous degradation over time (van Noortwijk, 2009), we consider exponentially distributed deterioration increments. We consider the same costs as in the first example in the numeric investigation, i.e., 
                        
                           
                              c
                              p
                           
                           =
                           5
                           ,
                        
                     
                     
                        
                           
                              c
                              c
                           
                           =
                           11
                           ,
                        
                     
                     
                        
                           
                              c
                              s
                           
                           =
                           4
                           ,
                        
                      and 
                        
                           p
                           =
                           300
                           ,
                        
                      set the failure level equal to 
                        
                           L
                           =
                           2
                           ,
                        
                      and scale the deterioration parameter to 
                        
                           α
                           =
                           
                              1
                              
                                 0.7
                              
                           
                           ·
                           
                              5
                              2
                           
                           ≈
                           3.6
                        
                     . Due to the large number of nested integrals required in the dynamic program, we approximate the integrals numerically by applying the extended midpoint rule (Press, Teukolsky, Vetterling, & Flannery, 1992), dividing the area into a 45x45 grid. Furthermore, we assume that the maximum deterioration level of a component never exceeds 1.5 · L, because the extended midpoint rule cannot cope with infinite integral bounds. Initial testing reveals that this does not affect the results. The maintenance policy that we obtain by applying the dynamic program is an approximation of the optimal policy, since we still discretize the state space for numerical reasons. The resulting policy is shown in Fig. 8. The computing time was approximately equal to 3.8 seconds for 20 iterations.

As for the discrete state space, the property that a preventive replacement is performed to avoid a (more expensive) corrective replacement is clearly visible. Table 8
                      shows the minimal costs obtained with the other maintenance policies along with the standard errors and the corresponding optimal parameter(s). Since we discretized the state space in the dynamic program, the resulting average cost is not accurate. For a fair comparison with the other maintenance policies, we therefore use simulation to find the average cost corresponding to the (approximated) optimal policy. Note that although we approximated the optimal dynamic program, it still outperforms the other maintenance policies.

We can conclude that our policy is applicable to systems with various types of degradation, but also that performing a preventive replacement to avoid a corrective replacement can be profitable for a wide class of systems with redundancy and economic dependencies, where a corrective replacement is more costly than a preventive replacement.

@&#CONCLUSION@&#

This paper is the first to consider CBM for a multi-unit system with both (hot standby) redundancy, through a k-out-of-N structure, and economic dependencies. We developed a dynamic programming model to find the optimal maintenance strategy for such systems. For various systems, either with a discrete or a continuous state space, we observed some interesting characteristics of the optimal policies. First, we observed a rather different structure of the optimal policy than those possible by using more common CBM policies with degradation threshold values corresponding to different maintenance actions. In particular, we observed non-monotonic behavior in the optimal policy in that for certain states of the system, it could be optimal to preventively replace a component that is close to failure, while a corrective replacement on that same component would be postponed until the other component has deteriorated a bit more. Furthermore, a numerical comparative cost study revealed that the optimal maintenance policy considerably outperforms all previously considered policies (failure-based, age-based, block replacement, and more restricted CBM policies).

In practice, companies generally replace components immediately upon failure, despite the redundancy in their equipment. The insights we obtained in the structure of the optimal policy can, for example, help companies decide on when to postpone corrective replacements to save costs, thus utilizing their redundancy.

The structure of the optimal policy is, however, rather complex, especially when considering more than two components. For that reason, future research should be performed on investigating whether the (numerically) observed optimal policy structure can be (approximately) expressed using policy parameters. This would facilitate a much faster optimization. Furthermore, in the current model the system is inspected every time unit, after which possible replacements are performed. Including aperiodic inspection could be profitable (Castanier et al., 2005), and is certainly possible in this setting. Although in practice minimizing the total maintenance costs might be one of the main goals, maximizing availability is also deemed important. In the current model, availability is guaranteed by imposing a large penalty for system unavailability, but no information is available on the actual availability. This could be an interesting field of future research as well.

@&#ACKNOWLEDGMENT@&#

This project was co-funded by the Dutch Institute for Advanced Logistics (Dinalog).

@&#REFERENCES@&#

