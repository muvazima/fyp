@&#MAIN-TITLE@&#Subsampling-based acceleration of simple linear iterative clustering for superpixel segmentation

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An accelerated simple linear iterative clustering algorithm is proposed for real-time superpixel segmentation.


                        
                        
                           
                           High interpixel redundancy of images is exploited for effective prediction of the best segments.


                        
                        
                           
                           We show that the proposed algorithm boosts performance of SLIC up to five times.


                        
                        
                           
                           We show that the proposed algorithm produces almost the same superpixel segmentation performance as the conventional SLIC algorithm.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Superpixels

Segmentation

Acceleration

Fast implementation

Subsampling

@&#ABSTRACT@&#


               
               
                  Simple linear iterative clustering (SLIC) that partitions an image into multiple homogeneous regions, superpixels, has been widely used as a preprocessing step in various image processing and computer vision applications due to its outstanding performance in terms of speed and accuracy. However, determining a segment that each pixel belongs to still requires tedious, iterative computation, which hinders real-time execution of SLIC. In this paper, we propose an accelerated SLIC superpixel segmentation algorithm where the number of candidate segments for each pixel is reduced effectively by exploiting high spatial redundancy within natural images. Because all candidate segments should be inspected in order to choose the best one, candidate reduction significantly improves computational efficiency. Various characteristics of the proposed acceleration algorithm are investigated. The experimental results confirmed that the proposed superpixel segmentation algorithm runs up to about five times as fast as SLIC while producing almost the same superpixel segmentation performance, sometimes better than SLIC, with respect to under-segmentation error and boundary recall.
               
            

@&#INTRODUCTION@&#

Superpixel segmentation is the process of partitioning an image into multiple segments, so-called superpixels, which are homogeneous in the sense that pixels within each segment are similar with respect to certain characteristics such as color and texture. Although superpixel segmentation usually yields over-segmented results rather than object-level segments, it drastically reduces the number of image primitives with minimal loss of information and offers an easy way to extract the most likely image objects with as few segments as possible. In addition, since superpixel segmentation provides a more natural and perceptually meaningful representation of the input image, it is more convenient and effective to extract region-based visual features using superpixels [1]. This is why superpixel segmentation is widely used as a preprocessing step for various computer vision applications like foreground object detection [2,3], motion segmentation [4], object recognition [5], depth map enhancement [6,7], and saliency object detection [1].

After the superpixel concept was originally presented by Ren and Malik [8] as defining perceptually homogeneous regions using the normalized cuts (NCuts) algorithm, numerous superpixel segmentation algorithms have been proposed in the literature, for example, the mean shift algorithm [9], graph-based methods [10,11], Turbopixels [12], and simple linear iterative clustering (SLIC) [2]. Although each method has its own advantages and drawbacks that make it better suited for a particular application, SLIC, proposed by Achanta et al., has attracted a great deal of attention and has been utilized [3,6,11]. As summarized in the literature [2], SLIC outperforms the other algorithms in several desirable properties for superpixel segmentation; SLIC is capable of quickly creating compact and uniform superpixels, offers explicit control over the amount of superpixels and their compactness, and accurately aligns superpixels with object boundaries.

Thanks to the high performance of SLIC in execution time, accuracy, and compactness, SLIC has been widely employed in a wide range of practical computer vision applications. Therefore, in this paper, we only focus on how to further enhance the-state-of-the-art, SLIC.

SLIC is an iterative algorithm based on k-means clustering in which the best cluster for each sample is sought from among all available clusters. Because the cluster search involves an inspection process requiring distance calculations and comparisons per cluster, k-means clustering usually requires a huge amount of repeated computation. In contrast, a high speed-up is achieved in SLIC, such that the best cluster (i.e. the best segment for each pixel) is chosen from among only a few spatially neighboring segments, rather than all segments in the image. Such a modification to k-means clustering, i.e. the reduction of candidate clusters, achieves drastic computation reduction.

Nevertheless, considering that superpixel segmentation is usually used as a preprocessing step in image processing and computer vision applications, computational challenges should be further addressed for practical real-time implementation of the applications. However, there have been, ironically, few efforts to further improve conventional SLIC due to the aforementioned somewhat-high performance improvement of SLIC in execution time, accuracy, and compactness.

Kim et al. attempted to improve segmentation accuracy with respect to boundary adherence by updating cluster representatives only with pixels having a similar luminance [13]. In Ref. [14], a GPU-based parallel implementation of SLIC was presented to speed up execution time. In Ref. [15], Borovec and Kybic presented an implementation of SLIC where repetitive distance calculation is simplified by using pre-computed look-up tables (LUTs). However, LUTs usually increase memory usage by a huge amount.

In this paper, we propose an accelerated SLIC superpixel segmentation algorithm that significantly reduces processing time without hardware parallelism while producing almost the same segmentation results as SLIC.

In the proposed algorithm, the number of candidate clusters is reduced further by exploiting interpixel redundancy in the images. The cluster search is first performed on subsampled pixels. Based on clustering results for the subsampled pixels, we can sift candidate clusters for the remaining pixels and successfully get rid of implausible candidates without any inspection computation. Consequently, the number of candidate clusters for the cluster search lessens without loss of segmentation accuracy.

This paper is organized as follows. In the next section, we review the conventional SLIC algorithm. In Section 3, both the proposed acceleration approaches are explicated in detail. Performance evaluation and comparison of the proposed algorithms are presented in Section 4. Finally, the conclusion is given in Section 5.

Before describing the proposed accelerated SLIC algorithm in detail, we review the conventional SLIC algorithm [2] after defining some notations.

A pixel i in an input image I of size 
                        
                           L
                           ×
                           M
                           =
                           N
                        
                      is represented as a feature vector consisting of both its color in the CIELAB color space and its position: 
                        
                           
                              f
                              i
                           
                           =
                           
                              
                                 [
                                 
                                    l
                                    i
                                 
                                 ,
                                 
                                    a
                                    i
                                 
                                 ,
                                 
                                    b
                                    i
                                 
                                 ,
                                 
                                    x
                                    i
                                 
                                 ,
                                 
                                    y
                                    i
                                 
                                 ]
                              
                              T
                           
                        
                     . Similarly, cluster Ck
                      is represented with the mean color and the center of mass of the cluster: 
                        
                           
                              f
                              
                                 C
                                 k
                              
                           
                           =
                           
                              
                                 [
                                 
                                    l
                                    
                                       C
                                       k
                                    
                                 
                                 ,
                                 
                                    a
                                    
                                       C
                                       k
                                    
                                 
                                 ,
                                 
                                    b
                                    
                                       C
                                       k
                                    
                                 
                                 ,
                                 
                                    x
                                    
                                       C
                                       k
                                    
                                 
                                 ,
                                 
                                    y
                                    
                                       C
                                       k
                                    
                                 
                                 ]
                              
                              T
                           
                        
                     . Let 
                        
                           D
                           (
                           i
                           ,
                           
                              C
                              k
                           
                           )
                        
                      denote a distance metric between i and Ck
                     , which is defined as

                        
                           (1)
                           
                              
                                 D
                                 
                                    (
                                    i
                                    ,
                                    
                                       C
                                       k
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       
                                          D
                                          c
                                       
                                       
                                          
                                             (
                                             i
                                             ,
                                             
                                                C
                                                k
                                             
                                             )
                                          
                                          2
                                       
                                       +
                                       
                                          λ
                                          2
                                       
                                       ·
                                       
                                          D
                                          s
                                       
                                       
                                          
                                             (
                                             i
                                             ,
                                             
                                                C
                                                k
                                             
                                             )
                                          
                                          2
                                       
                                    
                                 
                                 ,
                              
                           
                        
                     where 
                        
                           λ
                           =
                           r
                           /
                           S
                           ,
                        
                      and r and S represent a regularization factor controlling compactness and an initial clustering sampling interval, respectively. In [2], a default value of 10 was used for r.

                        
                           (2)
                           
                              
                                 
                                    D
                                    c
                                 
                                 
                                    (
                                    i
                                    ,
                                    
                                       C
                                       k
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      l
                                                      i
                                                   
                                                   −
                                                   
                                                      l
                                                      
                                                         C
                                                         k
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      a
                                                      i
                                                   
                                                   −
                                                   
                                                      a
                                                      
                                                         C
                                                         k
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      b
                                                      i
                                                   
                                                   −
                                                   
                                                      b
                                                      
                                                         C
                                                         k
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                          2
                                       
                                    
                                 
                              
                           
                        
                     and

                        
                           (3)
                           
                              
                                 
                                    D
                                    s
                                 
                                 
                                    (
                                    i
                                    ,
                                    
                                       C
                                       k
                                    
                                    )
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      x
                                                      i
                                                   
                                                   −
                                                   
                                                      x
                                                      
                                                         C
                                                         k
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                          2
                                       
                                       +
                                       
                                          
                                             
                                                (
                                                
                                                   
                                                      y
                                                      i
                                                   
                                                   −
                                                   
                                                      y
                                                      
                                                         C
                                                         k
                                                      
                                                   
                                                
                                                )
                                             
                                          
                                          2
                                       
                                    
                                 
                              
                           
                        
                     indicate Euclidean distances in color and spatial domains, respectively.

The procedure of the conventional SLIC algorithm is described below. SLIC consists of four steps; initialization, cluster assignment, update, and postprocessing.

For color images in the CIELAB color space, K cluster centers are initially sampled on a regular grid S. To prevent the initial cluster centers from being located on object boundaries, the initial cluster centers are re-located to the lowest gradient position within their 3 × 3 neighborhood.

In the cluster assignment step, each pixel i is associated with the nearest cluster center, in the sense of (1), by inspecting neighboring cluster centers whose search regions overlap the position of i. Here, cluster inspection involves a distance calculation in (1) and a comparison. In [2], the size of the search region was set to 2S × 2S around the cluster center.

Let Ωi
                     , L(i), and 
                        
                           Π
                           
                              C
                              k
                           
                        
                      denote a set of cluster centers whose search regions contain i, a label associated with i, and a set of pixels constituting Ck
                     , respectively. That is, 
                        
                           L
                           
                              (
                              i
                              )
                           
                           =
                           
                              C
                              k
                           
                           ∈
                           
                              Ω
                              i
                           
                        
                      and 
                        
                           
                              Π
                              
                                 C
                                 k
                              
                           
                           =
                           
                              {
                              i
                              |
                              L
                              
                                 (
                                 i
                                 )
                              
                              =
                              
                                 C
                                 k
                              
                              }
                           
                        
                     .

Even though K clusters exist in the image, the cluster inspection for each pixel i is performed only with neighboring candidate clusters. The number of candidate clusters to be inspected, |Ωi
                     |, is usually much smaller than K, which leads to a significant speed advantage over the conventional k-means clustering, where each pixel is compared with all K clusters.

In the update step, each 
                        
                           f
                           
                              C
                              k
                           
                        
                      is updated in accordance with the 
                        
                           Π
                           
                              C
                              k
                           
                        
                      that is determined in the cluster assignment step. The cluster assignment and update steps are repeated until the segmentation converges. At the end of this clustering procedure, orphaned pixels forming small-sized clusters are merged into the nearest cluster to enforce connectivity.

Because images are generally characterized by large regions of constant or near-constant pixel values, there is considerable spatial correlation between adjacent pixels, so-called interpixel redundancy, which is the most important characteristic of images for image compression.

In the context of superpixel segmentation, interpixel redundancy implies that if a pixel i is associated with a certain cluster, its neighboring pixels also highly tend to belong to the cluster. In order to exploit interpixel redundancy, in the proposed algorithm, a subsampling method is applied to the SLIC cluster assignment step.

For clear notation, let Λ and ΛC
                         be a set of 2:1 subsampled pixels, i.e. every second pixel, both horizontally and vertically, and the remaining pixels except Λ, respectively. Therefore, the number of pixels belonging to Λ, |Λ|, becomes N/4, and |ΛC
                        | becomes (3N)/4.

Specifically, after the SLIC initialization step is executed, pixels on Λ are first associated with their closest clusters through the cluster search, as in SLIC. At that point, the remaining pixels in ΛC
                         have not been associated with any cluster yet. However, it is guaranteed that, for a pixel i ∈ ΛC
                        , some of its 8-connected neighboring pixels are already labeled. Letting Φi
                         denote the set of 8-connected neighboring pixels around i, the cluster search for i ∈ ΛC
                         is performed with the candidate clusters in 
                           
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              =
                              
                                 {
                                 L
                                 
                                    (
                                    j
                                    )
                                 
                                 |
                                 j
                                 ∈
                                 Λ
                                 ∩
                                 
                                    Φ
                                    i
                                 
                                 }
                              
                           
                         in the proposed algorithm. It is noteworthy that 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                              
                           
                         is usually less than |Ωi
                        |. In consequence, computation reduction on cluster inspection can be achieved.

The process of the proposed cluster assignment algorithm using interpixel redundancy is demonstrated in Fig. 1
                        , where small squares indicate pixels and the subsampled grid Λ is represented as thick outlined squares. As described before, for i ∈ Λ, Ωi
                         contains all the clusters within a region of 2S × 2S, and thus, becomes {C
                        1, C
                        2, C
                        3, C
                        4} in this example.

Assume that the closest clusters for the subsampled pixels are determined as marked inside the pixels. Then, for the in-between yellow pixels (except the central one), 
                           
                              Ω
                              
                                 Φ
                                 i
                              
                           
                         can have two different clusters, at most. As a result, the distance metric in (1) is calculated only twice, at most. In the same way, for the central yellow pixel, cluster inspection is performed with only three clusters: C
                        1, C
                        2, and C
                        4.

Inside a superpixel, all the pixels in Λ are assigned to an identical cluster. Then, for i ∈ ΛC
                        , 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                                 =
                                 1
                              
                           
                        . It is notable that, in that case, i is associated with the same cluster without the distance calculation of (1) in the proposed cluster assignment step.

If the distance between each pixel and its closest cluster center is required for computing residual error E, the distance for i (in the case of 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                                 =
                                 1
                              
                           
                        ) can be approximated by averaging the distances for neighboring pixels j, j ∈ Φi
                         ∩ Λ.

Because the case of 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                                 =
                                 1
                              
                           
                         frequently occurs, this distance approximation also further reduces execution time significantly. Nonetheless, it is confirmed in our experiments that it does not affect superpixel segmentation performance. The proposed accelerated SLIC algorithm is summarized in Algorithm 1
                        .

In the proposed acceleration approach, effective reduction of the number of candidate clusters to be inspected induces computational efficiency. In this subsection, we analyze how much the proposed algorithm reduces the number of cluster searches, compared to SLIC.

In SLIC, the cluster search is performed the same number of times as the number of candidate clusters, even though only one candidate is available. The expected number of candidate clusters per pixel is simply expressed as

                           
                              (4)
                              
                                 
                                    
                                       
                                          
                                             
                                                E
                                             
                                             [
                                             |
                                             Ω
                                             |
                                             ]
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   E
                                                
                                                [
                                                |
                                             
                                             
                                                Ω
                                                i
                                             
                                             
                                                |
                                                ]
                                             
                                             =
                                             
                                                ∑
                                                c
                                             
                                             
                                                p
                                                (
                                                |
                                             
                                             
                                                Ω
                                                i
                                             
                                             
                                                |
                                                =
                                                c
                                                )
                                             
                                             c
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                Γ
                                                
                                                   SLIC
                                                
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where E[ · ] and Γ
                        SLIC indicate the expectation operator and the number of cluster searches per pixel in SLIC, respectively.

In contrast, E[|Ω|] in the proposed algorithm can be expressed as

                           
                              (5)
                              
                                 
                                    
                                       
                                          
                                             
                                                E
                                             
                                             [
                                             |
                                             Ω
                                             |
                                             ]
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                
                                                   |
                                                   Λ
                                                   |
                                                
                                                N
                                             
                                             
                                                
                                                   E
                                                
                                                [
                                                |
                                             
                                             
                                                Ω
                                                i
                                             
                                             
                                                |
                                                ]
                                             
                                             +
                                             
                                                
                                                   
                                                      |
                                                   
                                                   
                                                      Λ
                                                      C
                                                   
                                                   
                                                      |
                                                   
                                                
                                                N
                                             
                                             
                                                
                                                   E
                                                
                                                [
                                                |
                                             
                                             
                                                Ω
                                                
                                                   Φ
                                                   i
                                                
                                             
                                             
                                                |
                                                ]
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                1
                                                4
                                             
                                             
                                                
                                                   E
                                                
                                                [
                                                |
                                             
                                             
                                                Ω
                                                i
                                             
                                             
                                                |
                                                ]
                                             
                                             +
                                             
                                                3
                                                4
                                             
                                             
                                                
                                                   E
                                                
                                                [
                                                |
                                             
                                             
                                                Ω
                                                
                                                   Φ
                                                   i
                                                
                                             
                                             
                                                |
                                                ]
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                1
                                                4
                                             
                                             
                                                ∑
                                                c
                                             
                                             
                                                p
                                                (
                                                |
                                             
                                             
                                                Ω
                                                i
                                             
                                             
                                                |
                                                =
                                                c
                                                )
                                                c
                                                +
                                             
                                             
                                                3
                                                4
                                             
                                             
                                                ∑
                                                
                                                   c
                                                   =
                                                   1
                                                
                                                4
                                             
                                             
                                                p
                                                (
                                                |
                                             
                                             
                                                Ω
                                                
                                                   Φ
                                                   i
                                                
                                             
                                             
                                                |
                                                =
                                                c
                                                )
                                             
                                             c
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The proposed algorithm can achieve computational efficiency in two respects. (1) Around some clusters having irregular shapes and smaller sizes than others, the number of candidate clusters grows drastically, even to nine. However, in the proposed algorithm, 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                              
                           
                         is limited to four, at most, for three-quarters of the pixels. (2) As mentioned before, even the cluster inspection is not required if 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                                 =
                                 1
                              
                           
                        . Therefore, in the proposed algorithm, the number of cluster searches per pixel, Γ
                        Proposed, is lower than E[|Ω|] as follows:

                           
                              (6)
                              
                                 
                                    
                                       Γ
                                       
                                          Proposed
                                       
                                    
                                    =
                                    
                                       1
                                       4
                                    
                                    
                                       ∑
                                       c
                                    
                                    
                                       p
                                       (
                                       |
                                    
                                    
                                       Ω
                                       i
                                    
                                    
                                       |
                                       =
                                       c
                                       )
                                       c
                                       +
                                    
                                    
                                       3
                                       4
                                    
                                    
                                       ∑
                                       
                                          c
                                          =
                                          2
                                       
                                       4
                                    
                                    
                                       p
                                       (
                                       |
                                    
                                    
                                       Ω
                                       
                                          Φ
                                          i
                                       
                                    
                                    
                                       |
                                       =
                                       c
                                       )
                                    
                                    c
                                    .
                                 
                              
                           
                        
                     

In order to demonstrate how effectively the proposed algorithm reduces Γ, statistics of |Ωi
                        | and 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                              
                           
                         were obtained using the implementation of our proposed algorithm based on the original SLIC implementation [16] for the 10 images shown in Fig. 2
                        , and are summarized in Tables 1
                         and 2
                        , respectively.

When the conventional cluster search is used, Γ
                        SLIC becomes 3.74, according to the statistics in Table 1. Over half the pixels have four candidate clusters to be inspected. More clusters should be inspected for some pixels within complex patterned regions, whereas for pixels located along the image boundary, their |Ωi
                        | is smaller than four, since the search ranges of 2S × 2S overlap the image partially.

In the proposed cluster search, candidate clusters are reduced significantly, as shown in Table 2. It is notable that 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                              
                           
                         is smaller than Γ
                        SLIC for a surprising 99.8% of pixels on ΛC
                        , on average. In particular, for 70.8% of pixels where 
                           
                              Ω
                              
                                 Φ
                                 i
                              
                           
                         has only a single candidate cluster, no computation is required for the distance calculation, which reduces execution times drastically. Based on the statistics in Tables 1 and 2, Γ
                        Proposed becomes 1.39. Therefore, in the proposed algorithm, the cluster inspection is performed 2.69 times less than in SLIC.


                        Fig. 3
                         gives some insights into such candidate reductions by depicting |Ωi
                        | and 
                           
                              
                                 |
                              
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              
                                 |
                              
                           
                         together. The cardinality distribution in Fig. 3(b) was obtained at the fifth iteration when running the proposed algorithm with 
                           
                              S
                              =
                              40
                           
                         and 
                           
                              r
                              =
                              10
                              ,
                           
                         and Fig. 3(d) illustrates an enlarged part of Fig. 3(b) in detail. In order to visualize the cardinality distribution clearly, we used another implementation based on SLIC in the VLFeat library [17] where maximally four candidate clusters are available even for pixels on Λ. Therefore, |Ω| can be represented distinctly in four different colors (White: 1, Green: 2, Red: 3, Yellow: 4).

Pixels on Λ are indicated in yellow due to 
                           
                              
                                 |
                              
                              
                                 Ω
                                 i
                              
                              
                                 |
                                 =
                                 4
                                 ,
                              
                           
                         whereas it is hard to find yellow ones on ΛC
                        . On ΛC
                        , almost all pixels inside superpixels are represented in white, whereas green and red pixels appear along superpixel boundaries and on junctions with three branches, respectively. As a result, 
                           
                              p
                              (
                              |
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              |
                              =
                              c
                              )
                           
                         becomes exponentially smaller as c increases.


                        
                           
                              p
                              (
                              |
                              
                                 Ω
                                 
                                    Φ
                                    i
                                 
                              
                              |
                              =
                              1
                              )
                           
                         increases with increments of S and r. This is because individual superpixels become larger with a decrease in K as S increases, while the number of pixels on superpixel boundaries and junctions with three branches become smaller. The increment of r makes superpixels more compact and rounded, which tends to prevent adjacent pixels from alternating clusters.

@&#EXPERIMENTAL RESULTS@&#

In order to demonstrate the performance of the proposed algorithm, we implemented two versions of it based on the original C-based SLIC [16] and a modified SLIC in the open source C-based VLFeat library [17]. The four implementations were tested with the Berkeley database [18] containing three-hundred 321 × 481 images with ground truth segmentation data. The implementations were run on a 3.50GHz processor with 16GB of RAM.


                        Fig. 4
                         shows the segmentation speed improvement of SLIC by applying the proposed acceleration algorithm, where the original SLIC and the SLIC in the VLFeat library are referred to as “SLIC1” and “SLIC2”, respectively, and the corresponding proposed algorithms as “Proposed1” and “Proposed2”. The compactness parameter r was set to 10 as the default value used in Ref. [2].

The cluster search routines in the four implementations were built without compiler optimization in order to demonstrate pure algorithmic performance. Specifically, the implementations except functions of the cluster search were compiled with compiler optimization enabled, and were linked with static library files of the cluster search functions built without compiler optimization.

Because SLIC is an iterative clustering algorithm, the execution times of the four implementations are related to the number of iterations, and both quantities change with similar tendency, as shown in Fig. 4. The performance of “SLIC1” and “SLIC2” varies, largely depending on K, whereas “Proposed1” and “Proposed2” show stable performance with respect to both the number of iterations and execution times. “Proposed1” and “Proposed2” promote convergence by smoothing jagged segment boundaries, and thus, require a lot fewer iterations than “SLIC1” and “SLIC2”, respectively, with identical termination conditions. Nonetheless, segmentation results are not degraded by such fast convergence of the proposed algorithms, as described in the next subsection.

Let τ denote the computational efficiency gain of “Proposed” over “SLIC”, which is calculated as a ratio of the measures of “Proposed” relative to “SLIC”. Table 3
                         summarizes τ with respect to the number of iterations and execution time. τ in execution time is much larger than τ in the number of iterations. The difference between the two gains can be regarded as performance improvement resulting from the proposed acceleration approach.

In Fig. 5
                        , we compare the time required for the implementations to segment images of increasing size. In order to examine maximum performance of the algorithms, the cluster search functions were also built with compiler optimization enabled. We used eight 768 × 512-, four 1366 × 768-, and ten 1920 × 1080-sized images as well as the Berkeley database. For images of the smallest size, “SLIC1”, “Proposed1”, “SLIC2”, and “Proposed2” can be performed in real time, specifically, 49, 18, 31, and 18 msec, respectively, on average, whereas only our proposed algorithms took less than 50 msec for images at 768 × 512 pixels. The four graphs in Fig. 5 show SLIC’s inherent O(N) complexity. It is notable that the proposed subsampling approach achieves significant speed enhancement and lowers the increasing slope of the required time with respect to image size.

In this subsection, segmentation performance of SLIC and the proposed algorithms is compared. Fig. 6
                         shows a visual comparison of superpixels obtained by both the algorithms.

The segmentation results of “SLIC” are followed by those of corresponding “Proposed” in each image set. The average superpixel size is 100 pixels in the upper left of each image and 400 in the lower right. It is hard to find any difference between any pair of results. Even the segmentation results for the fish eye indicate that the proposed algorithm produces more accurate segments.

In order to objectively compare segmentation performance of the algorithms, we use two standard measures for boundary adherence [2,12,19], under-segmentation error and boundary recall.

Under-segmentation error measures boundary adherence, which is expressed as

                           
                              (7)
                              
                                 
                                    
                                       
                                          ɛ
                                       
                                       U
                                    
                                    =
                                    
                                       1
                                       N
                                    
                                    
                                       [
                                       
                                          
                                             ∑
                                             
                                                i
                                                =
                                                1
                                             
                                             G
                                          
                                          
                                             
                                                (
                                                
                                                   
                                                      ∑
                                                      
                                                         
                                                            s
                                                            j
                                                         
                                                         
                                                            |
                                                         
                                                         
                                                            s
                                                            j
                                                         
                                                         ∩
                                                         
                                                            g
                                                            i
                                                         
                                                         >
                                                         B
                                                      
                                                   
                                                   
                                                      |
                                                      
                                                         s
                                                         j
                                                      
                                                      |
                                                   
                                                
                                                )
                                             
                                             −
                                             N
                                          
                                       
                                       ]
                                    
                                    ,
                                 
                              
                           
                        where sj
                         and gi
                         represent a resultant segment and a ground truth segment, respectively, and | · | is the size of a segment in pixels. G indicates the number of all the ground truth segments for the image, and B is the minimum number of pixels in sj
                         overlapping gi
                        , which is set to 5% of |sj
                        | in the experiments. Superpixels that do not tightly fit the ground truth segments result in a high value of ε
                           U
                        .

Boundary recall measures the fraction of the ground truth edges that fall within at least two pixels of a superpixel boundary. A high boundary recall indicates that very few true edges were missed.

The under-segmentation error of each algorithm is presented in Table 4
                        . “Proposed1” shows slightly degraded results, compared to “SLIC1”, whereas “Proposed2” yields slightly better scores than “SLIC2” in the implementations based on the VLFeat library. Table 5
                         shows the boundary recall measures for the implementations. Here, performance differences between SLIC and the corresponding proposed algorithms are ignorable, compared to those between “SLIC1” and “SLIC2”.

As mentioned before, a post-processing step to enforce connectivity is performed in common for all the algorithms. Since, however, small-sized clusters are merged into their adjacent clusters without any consideration as to similarity in the post-processing step, segmentation accuracy can be degraded through the post-processing step. In the proposed subsampling-based approach, the merging process is performed 68% less than in SLIC. That means that the proposed cluster search algorithm produces more regular segments, instead of isolated small-sized segments, compared to SLIC.

@&#CONCLUSIONS@&#

In this paper, we presented an accelerated SLIC superpixel segmentation algorithm. Based on interpixel redundancy in images, the subsampling approach is applied to cluster assignment to reduce the number of candidate clusters effectively. The experimental results confirmed that the proposed algorithm runs nearly five times as fast as the conventional SLIC algorithm while producing very similar superpixel segmentation performance, sometimes better than the conventional SLIC algorithm, with respect to boundary adherence and boundary recall. Therefore, the proposed superpixel segmentation algorithm can be suitable for real-time computer vision applications.

@&#REFERENCES@&#

