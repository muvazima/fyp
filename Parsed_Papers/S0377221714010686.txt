@&#MAIN-TITLE@&#Dynamic scaling on the limited memory BFGS method

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Updates of the well known LBFGS method are approximately equilibrated.


                        
                        
                           
                           The initial diagonal matrix is modified to equilibrate and to approximate the Hessian.


                        
                        
                           
                           Numerical results indicate that the proposed scaling strategy is very effective.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

(B)Large scale optimization

(I)Nonlinear programming

Limited memory quasi-Newton methods

Column scaling

Equilibrated matrix,

@&#ABSTRACT@&#


               
               
                  This paper describes a limited-memory quasi-Newton method in which the initial inverse Hessian approximation is constructed based on the concept of equilibration of the inverse Hessian matrix. Curvature information about the objective function is stored in the form of a diagonal matrix, and plays the dual role of providing an initial matrix and of equilibrating for limited memory BFGS (LBFGS) iterations. An extensive numerical testing has been performed showing that the diagonal scaling strategy proposed is very effective.
               
            

@&#INTRODUCTION@&#

In this paper, we consider minimization of a function of a large number of variables,

                        
                           
                              
                                 min
                                 f
                                 (
                                 x
                                 )
                                 ,
                              
                           
                        
                     where 
                        
                           f
                           :
                           
                              R
                              n
                           
                           →
                           R
                        
                      is a nonlinear and twice continuously differentiable objective function. Limited-memory BFGS method is one of the most versatile, effective and widely used classes of methods in tackling large scale problems. This approach uses Hessian approximations that can be stored compactly by using the information gathered via a few vectors of length n.

A related issue is concerned with the formulation of an effective limited-memory quasi-Newton method, motivating this work. The problem is how to select the initial approximation to the Hessian at each iteration to improve the behavior of this method. Several authors studied the use of diagonal initial matrices. Diagonally scaling a matrix is intended to cluster eigenvalues or to reduce the condition number of the matrix. To compute these conversion matrices a minimal additional work is required. Moreover diagonally scaling preserves the sparsity of the matrix, if it is the case.

The simplest way of diagonal scaling is setting the initial matrix to be a multiple of the identity matrix. Liu and Nocedal (1989) propose such multiple as yTs/yTy that attempts to estimate the size of the true inverse Hessian matrix along the most recent search direction. Such starting matrix approximates an eigenvalue of the inverse Hessian and appears to be the most successful in practice, see Nocedal and Wright (2006). Al-Baali (1995) investigated alternative choices for initial approximation of the inverse Hessian to yield improvement over the LBFGS method with the Liu and Nocedal choice. In one of his approaches, he argues that an alternative choice for the scalar is better than the usual one.

Another approach is Jacobi scaling of a symmetric matrix A. It is defined by 
                        
                           Δ
                           =
                           diag
                           {
                           
                              a
                              
                                 11
                              
                              
                                 1
                                 /
                                 2
                              
                           
                           ,
                           …
                           ,
                           
                              a
                              
                                 n
                                 n
                              
                              
                                 1
                                 /
                                 2
                              
                           
                           }
                        
                     . It is known that such scaling is effective for sparse matrices whenever they are very diagonally dominant, see Van der Sluis (1969).

Quasi-Newton diagonal updating, due to Zhu, Nazareth, and Wolkowicz (1999) is based upon weak quasi-Newton relation with matrices further restricted to be diagonal. The interpretation of a diagonal initial matrix, as a matrix that attempts to capture curvature information is incompatible with subsequently updating this matrix to a full one. This method performs poorly and suffers from a tendency to generate search direction numerically orthogonal to the gradient one, see Auroux (2000) and Roma (2005).

Far more effective scaling procedure of the Hessian matrix is equilibration so that all its columns (rows) have the same length in some norm. Other equilibration algorithms exist to achieve a number of different objectives such as unit diagonal elements, equal row or column p-norms, bounded elements. Note to that the objectives may be achieved either exactly or approximately. Let us note also that there is a recommendation to equilibrate the matrix in some norm before applying any algorithm for solving a system of linear equations, since the most effective results occur for equilibrated matrices because a small perturbation of one column (or row) is then of the same magnitude as that of any other column (or row), see Wilkinson (1961) and Bunch (1971).

One of the most frequently used norms in the numerical solution of linear equations is the l
                     1-norm under which column scaling is carried out by dividing each column of the positive definite matrix by the sum of the absolute values of the column entries. In this way, required equilibration means normalization to 1.


                     Roma (2005) proposed a diagonal preconditioner based on l
                     1-norm equilibration. In his paper the quantities that are a lower estimate of the l
                     1-norm of the jth column vector of the inverse Hessian were computed. These values used to build the diagonal preconditioner and no scaling is performed on those columns for which the estimate of their l
                     1-norm is small. It is found appropriate to apply similar equilibration in the frame of the LBFGS method. The reason is that the LBFGS method can be regarded as numerical solution of linear system in which the search direction is computed so as to satisfy the secant equation. The main difference between the approach proposed in this paper and Roma’s is in the strategy taken for those columns for which the estimate of their l
                     1-norm is small. To be precise, instead of performing no scaling for such columns, the scaling multiplier proposed by Liu and Nocedal (1989) is used to replace the corresponding diagonal entries of the initial scaling matrix.

In the following section, we shall present some details about theoretical properties and practical implementation of modified LBFGS algorithm employed by the method of this paper. In Section 3, we will describe the detailed algorithm of equilibrated limited memory BFGS method based upon two loop recursive procedure. The global and local convergence results of the equilibrated limited memory BFGS method are presented in Section 4. In Section 5 we compare the Dolan and Moré (2002) performance profile of the new algorithm with LBFGS by Liu and Nocedal (1989). The conclusion is finally outlined in Section 6.

In this section, the limited-memory BFGS method is briefly recalled, a more precise description of the LBFGS method can be found in Liu and Nocedal (1989) and Nocedal and Wright (2006). Then the focus will be on diagonal scaling technique which can be efficiently used in the context of LBFGS method.

It is well known, the ordinary LBFGS method, proposed by Liu and Nocedal (1989), is adopted from the BFGS method to solve large scale problems. Each step of the BFGS method has the form

                        
                           
                              
                                 
                                    x
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    x
                                    k
                                 
                                 −
                                 
                                    α
                                    k
                                 
                                 
                                    H
                                    k
                                 
                                 
                                    g
                                    k
                                 
                                 ,
                              
                           
                        
                     where αk
                      is the step size, gk
                      denotes the gradient of f at xk
                     , and Hk
                      is updated at every iteration to obtain H
                     
                        k + 1, defined by

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          
                                             H
                                             
                                                k
                                                +
                                                1
                                             
                                          
                                          =
                                          
                                             (
                                             I
                                             −
                                             
                                                ρ
                                                k
                                             
                                             
                                                
                                                   s
                                                   k
                                                
                                                
                                                   
                                                      y
                                                   
                                                   k
                                                   T
                                                
                                             
                                             )
                                          
                                          
                                             H
                                             k
                                          
                                          
                                             (
                                             I
                                             −
                                             
                                                ρ
                                                k
                                             
                                             
                                                
                                                   y
                                                   k
                                                
                                                
                                                   s
                                                   k
                                                   T
                                                
                                             
                                             )
                                          
                                          +
                                          
                                             ρ
                                             k
                                          
                                          
                                             
                                                s
                                                k
                                             
                                             
                                                s
                                                k
                                                T
                                             
                                          
                                          ,
                                          
                                          
                                             ρ
                                             k
                                          
                                          =
                                          
                                             1
                                             
                                                
                                                   y
                                                   k
                                                   T
                                                
                                                
                                                   s
                                                   k
                                                
                                             
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     that satisfies the secant equation H
                     
                        k + 1
                     yk
                      = sk
                     , in which sk
                      = x
                     
                        k + 1 − xk
                      and yk
                      = g
                     
                        k + 1 − gk
                     .

To explain the strategy of the limited memory BFGS method, we first assume that m is a given small positive integer. The LBFGS method keeps the m most recent correction pairs, 
                        
                           
                              
                                 {
                                 
                                    s
                                    i
                                 
                                 ,
                                 
                                    y
                                    i
                                 
                                 }
                              
                              
                                 i
                                 =
                                 k
                                 −
                                 m
                              
                              
                                 k
                                 −
                                 1
                              
                           
                           ,
                        
                      to update m times, the initial matrix 
                        
                           
                              H
                              k
                              0
                           
                           =
                           
                              
                                 s
                                 
                                    k
                                    −
                                    1
                                 
                                 T
                              
                              
                                 y
                                 
                                    k
                                    −
                                    1
                                 
                              
                           
                           /
                           
                              
                                 y
                                 
                                    k
                                    −
                                    1
                                 
                                 T
                              
                              
                                 y
                                 
                                    k
                                    −
                                    1
                                 
                              
                           
                           I
                           ,
                        
                      and computes the product

                        
                           
                              
                                 
                                    p
                                    k
                                 
                                 =
                                 −
                                 
                                    H
                                    k
                                 
                                 
                                    g
                                    k
                                 
                                 ,
                              
                           
                        
                     efficiently via performing two-loop recursion procedure as follows.

                        Algorithm 1
                        LBFGS two loop recursion


                        
                           q ← gk
                           ;


                           For    i = k − 1, k − 2, …, k − m
                        


                           Compute
                           
                              
                                 
                                    ρ
                                    i
                                 
                                 =
                                 
                                    1
                                    
                                       
                                          y
                                          i
                                          T
                                       
                                       
                                          s
                                          i
                                       
                                    
                                 
                              
                           ;


                           
                              
                                 
                                    α
                                    i
                                 
                                 ←
                                 
                                    ρ
                                    i
                                 
                                 
                                    s
                                    i
                                    T
                                 
                                 q
                              
                           ;


                           q ← q − αiyi
                           ;


                           end(for)
                        


                           
                              
                                 r
                                 ←
                                 
                                    H
                                    k
                                    0
                                 
                                 q
                              
                           ;


                           For    i = k − m, k − m − 1, …, k − 1


                           
                              
                                 χ
                                 ←
                                 
                                    ρ
                                    i
                                 
                                 
                                    y
                                    i
                                    T
                                 
                                 r
                              
                           ;


                           r ← r + si
                           (αi
                            − χ);


                           end(for)
                        


                           Stop with result Hkgk
                            = r.

This recursion has advantages of reasonable implementation cost. On one hand, the multiplication by the initial matrix 
                        
                           H
                           k
                           0
                        
                      is isolated from the rest of the computations, allowing this matrix to be chosen frequently and to vary between iterations. We consider this feature of great importance because the inverse Hessian matrix Hk
                      can change drastically during the course of the optimization iteration and to use the same initial approximation to the inverse Hessian throughout the run is questionable. Therefore, the idea of having a dynamic initial matrices that can be handle inexpensively is appealing. On the other hand, within recursion approach, it is not necessary to form the Hessian matrix explicitly because it requires only the computation of matrix–vector products involving this matrix, see Nocedal and Wright (2006). These features motivate several practical modification strategies. Al-Baali (1995) suggests an initial matrix in the form of a scalar multiple of the identity as 
                        
                           
                              H
                              k
                              0
                           
                           =
                           
                              v
                              k
                           
                           I
                        
                      where

                        
                           
                              
                                 
                                    v
                                    k
                                 
                                 =
                                 max
                                 
                                    {
                                    
                                       
                                          
                                             s
                                             
                                                k
                                                −
                                                1
                                             
                                             T
                                          
                                          
                                             y
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                       
                                       
                                          
                                             y
                                             
                                                k
                                                −
                                                1
                                             
                                             T
                                          
                                          
                                             y
                                             
                                                k
                                                −
                                                1
                                             
                                          
                                       
                                    
                                    ,
                                    
                                       
                                          
                                             s
                                             
                                                k
                                                −
                                                m
                                             
                                             T
                                          
                                          
                                             y
                                             
                                                k
                                                −
                                                m
                                             
                                          
                                       
                                       
                                          
                                             y
                                             
                                                k
                                                −
                                                m
                                             
                                             T
                                          
                                          
                                             y
                                             
                                                k
                                                −
                                                m
                                             
                                          
                                       
                                    
                                    }
                                 
                                 .
                              
                           
                        
                     This strategy is justified by the fact that under certain conditions such as vk
                      ≥ 1, self scaling methods converge globally and superlinearly on convex objective functions, see Al-Baali (1992); 1995).

In general the performance of a method involving the solution of a generic linear system, e.g. Ax = b, can be accelerated by equilibrating the linear system to improve the eigenvalue distribution of A, see Schneider and Zenios (1990). It is worthwhile noticing the fact that computing the LBFGS search direction is equivalent to solving the linear system H
                     −1
                     p = −g.

Therefore in the sequel of this section we seek for an initial scaling matrix which equilibrates the Hessian updates while being able to imbed in the framework of the LBFGS method. For this purpose we use an equilibration strategy based on columns scaling of the inverse Hessian matrix H(xk
                     ) which uses the ℓ1-norm. For simplicity, we drop the iteration index k in the linear system H
                     −1
                     p = −g or equivalently p = −Hg. If the entries and the columns of the inverse Hessian matrix are denoted by hij
                      and aj
                     , respectively, for i, j = 1, …, n, then we have aj
                      = Hej
                      where ej
                      = (0, …, 1, …, 0)
                        T
                      is the jth unit vector. We can choose diagonal matrix M such that

                        
                           
                              
                                 M
                                 =
                                 diag
                                 {
                                 ∥
                                 
                                    a
                                    1
                                 
                                 
                                    ∥
                                    1
                                 
                                 ,
                                 …
                                 ,
                                 ∥
                                 
                                    a
                                    n
                                 
                                 
                                    ∥
                                    1
                                 
                                 }
                                 ,
                              
                           
                        
                     and we deduce that the matrix HM
                     −1 is a column equilibrated matrix in the ℓ1-norm.

The following results analyze the condition number, denoted by κ
                     1 in the ℓ1-norm, and the eigenvalues distribution of the equilibrated matrix HM
                     −1. Their proof can be found in the paper of Roma (2005) and Higham (2002).

                        Proposition 1
                        
                           If H is nonsingular and Dn denotes the set of n × n nonsingular diagonal matrices, then
                           
                              
                                 
                                    
                                       
                                          κ
                                          1
                                       
                                       
                                          (
                                          H
                                          
                                             M
                                             
                                                −
                                                1
                                             
                                          
                                          )
                                       
                                       ≤
                                       
                                          min
                                          
                                             D
                                             ∈
                                             D
                                             n
                                          
                                       
                                       
                                          κ
                                          1
                                       
                                       
                                          (
                                          H
                                          D
                                          )
                                       
                                       .
                                    
                                 
                              
                           
                        

Therefore in terms of condition number in ℓ1-norm, the proposed column scaling matrix is the best among all column scaling matrices.

                        Proposition 2
                        
                           Let ρ(HM
                           −1) = max   { |λi
                           |: λi
                             
                           eigenvalues  
                           of  
                           HM
                           −1 } be the spectral radius of the matrix HM
                           −1. Thenρ(HM
                           −1) ≤ 1.

This proposition implies that the use of the proposed scaling matrix enables to have clustered eigenvalues and hence the algorithm will identify the solution in smaller number of iterations.

We turn our attention now to embedding this diagonal scaling strategy in the framework of the LBFGS method. The idea to attain a practical algorithm is focusing on the computation of the Hessian–vector product. By simply setting

                        
                           (2)
                           
                              
                                 
                                    
                                       
                                          
                                             σ
                                             j
                                          
                                          =
                                          
                                             |
                                             
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   h
                                                   
                                                      i
                                                      j
                                                   
                                                
                                             
                                             |
                                          
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     for each jth column, j = 1, …, n we get a reasonable estimate (a lower estimate) of the ℓ1-norm of the columns of the Hessian matrix. We do not compute σj
                     ,  j = 1, …, n explicitly, but rather, it requires only to supply Hessian–vector products of the form He, where e = (1, …, 1)
                        T
                     . Then absolute values are applied component-wise on the resulting vector. As a special case of this result, we see that σj
                      = ‖aj
                     ‖1, for  all j = 1, …, n whenever the Hessian is a matrix with nonnegative entries. In this case this scaling matrix possesses attractive theoretical properties stated above.

We could consider building M from the quantities (2) as

                        
                           (3)
                           
                              
                                 
                                    
                                       
                                          M
                                          =
                                          diag
                                          {
                                          
                                             
                                                σ
                                                ˜
                                             
                                             1
                                          
                                          ,
                                          
                                             
                                                σ
                                                ˜
                                             
                                             2
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                σ
                                                ˜
                                             
                                             n
                                          
                                          }
                                          ,
                                       
                                    
                                 
                              
                           
                        
                     where for j = 1, …, n,

                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          
                                             
                                                σ
                                                ˜
                                             
                                             j
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         σ
                                                         j
                                                      
                                                   
                                                   
                                                      
                                                         
                                                         
                                                            σ
                                                            j
                                                         
                                                         >
                                                         δ
                                                         ,
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            
                                                               y
                                                               T
                                                            
                                                            s
                                                         
                                                         
                                                            
                                                               y
                                                               T
                                                            
                                                            y
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         
                                                         otherwise
                                                         ,
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     for some small δ > 0. The parameter δ is chosen to be 10−6. Therefore a simple modification into Roma’s approach (Roma, 2005) is applied to the definition of the diagonal matrix M that uses the current curvature information. Scaling is also performed on those columns for which σj
                      is small. As observed, at each iteration of the LBFGS method, the positive diagonal matrix M that equilibrates the Hessian, is approximately computed by means of a single product of the Hessian matrix times the vector e = (1, 1, …, 1)
                        T
                     , thus limiting the additional cost only to an extra matrix–vector product, for each iteration.

In this section, we present a description of our “equilibration of the LBFGS” (ELBFGS) method. As we mentioned in Section 2, the LBFGS method does not require the storage of the n × n full inverse Hessian matrix, instead it stores a modified version of H implicitly using 2m vectors of length n, where m is a small positive integer and n is the number of variables.

To describe the updating process, suppose at step k, we have stored m most recent correction pairs 
                        
                           
                              {
                              
                                 s
                                 i
                              
                              ,
                              
                                 y
                                 i
                              
                              }
                           
                           
                              i
                              =
                              k
                              −
                              m
                           
                           
                              k
                              −
                              1
                           
                        
                     . We first choose the initial inverse Hessian approximation 
                        
                           
                              H
                              k
                              0
                           
                           =
                           
                              γ
                              k
                           
                           I
                           ,
                        
                      where

                        
                           
                              
                                 
                                    γ
                                    k
                                 
                                 =
                                 
                                    
                                       
                                          s
                                          
                                             k
                                             −
                                             1
                                          
                                          T
                                       
                                       
                                          y
                                          
                                             k
                                             −
                                             1
                                          
                                       
                                    
                                    
                                       
                                          y
                                          
                                             k
                                             −
                                             1
                                          
                                          T
                                       
                                       
                                          y
                                          
                                             k
                                             −
                                             1
                                          
                                       
                                    
                                 
                                 ,
                              
                           
                        
                     see Nocedal and Wright (2006). Then the matrix 
                        
                           H
                           k
                           0
                        
                      which is now the multiple of the identity matrix is modified to take account of nearly column equilibration of Hk
                      in ℓ1-norm. For this purpose, we invoke Algorithm 1 involving the Hessian–vector product to compute Hke. This results in a diagonal matrix M by which those elements of M that are greater than 10−6 take the place of the corresponding elements of 
                        
                           H
                           k
                           0
                        
                      while other elements of the matrix 
                        
                           H
                           k
                           0
                        
                      are left unchanged. The yielded matrix 
                        
                           H
                           k
                           0
                        
                      is used both to equilibrate and to scale Hk
                      using the recursion procedure of Algorithm 1 in which the next search direction − Hkgk
                      is computed. Therefore ELBFGS method invokes the Algorithm 1 twice to calculate the required matrix–vector products.

In this section, the global and local convergence properties of the ELBFGS algorithm are stated. Technically, the equilibrated LBFGS matrix Hk
                      is obtained by updating a bounded matrix 
                        
                           
                              H
                              k
                              0
                           
                           ,
                        
                      
                     m times, using the BFGS formula. For the purposes of our analysis, we shall use the direct update 
                        
                           
                              B
                              k
                           
                           =
                           
                              H
                              k
                              
                                 −
                                 1
                              
                           
                           ,
                        
                      which is the Hessian approximation to the objective function, associated with the Eq. (1). It is worth noting that the R-linear convergence result for the LBFGS method obtained under mild conditions by Liu and Nocedal (1989) is still valid for the modified LBFGS method considered here. The reason is that the new updating formula can be written like the LBFGS formula, except that the initial matrix is replaced by a diagonal matrix with different entries rather than a diagonal matrix with identical entries. Therefore at the beginning of each iteration we assume that 
                        
                           
                              B
                              k
                              0
                           
                           =
                           
                              
                                 
                                    H
                                    k
                                    0
                                 
                              
                              
                                 −
                                 1
                              
                           
                        
                      where 
                        
                           
                              
                                 H
                                 k
                                 0
                              
                           
                           
                              −
                              1
                           
                        
                      is a diagonal matrix whose elements are defined by (4).

                        Algorithm 2
                        ELBFGS


                        
                           Given an initial point x
                           0, m > 0, 0 < c
                           1 < c
                           2 < 1, a symmetric positive definite initial matrix
                           
                              
                                 
                                    B
                                    0
                                 
                                 =
                                 
                                    
                                       B
                                    
                                    0
                                    0
                                 
                              
                           ;


                           k ← 0;


                           repeat
                        


                           Compute the search direction
                           
                              
                                 
                                    p
                                    k
                                 
                                 ←
                                 −
                                 
                                    
                                       B
                                    
                                    k
                                    
                                       −
                                       1
                                    
                                 
                                 
                                    g
                                    k
                                 
                              
                           ;


                           Compute x
                           
                              k + 1 = xk
                            + αkpk where αk is chosen to satisfy the Wolfe conditions
                           
                              
                                 (5)
                                 
                                    
                                       
                                          
                                             
                                                f
                                                (
                                                
                                                   x
                                                   k
                                                
                                                +
                                                
                                                   α
                                                   k
                                                
                                                
                                                   p
                                                   k
                                                
                                                )
                                             
                                          
                                          
                                             ≤
                                          
                                          
                                             
                                                f
                                                
                                                   (
                                                   
                                                      x
                                                      k
                                                   
                                                   )
                                                
                                                +
                                                
                                                   c
                                                   1
                                                
                                                
                                                   α
                                                   k
                                                
                                                
                                                   g
                                                   k
                                                   T
                                                
                                                
                                                   p
                                                   k
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 (6)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   g
                                                   T
                                                
                                                
                                                   (
                                                   
                                                      x
                                                      k
                                                   
                                                   +
                                                   
                                                      α
                                                      k
                                                   
                                                   
                                                      p
                                                      k
                                                   
                                                   )
                                                
                                                
                                                   p
                                                   k
                                                
                                             
                                          
                                          
                                             ≥
                                          
                                          
                                             
                                                
                                                   c
                                                   2
                                                
                                                
                                                   g
                                                   k
                                                   T
                                                
                                                
                                                   p
                                                   k
                                                
                                                ,
                                             
                                          
                                       
                                    
                                 
                              
                           
                           where c
                           1 ∈ (0, 1)  and  c
                           2 ∈ (c
                           1, 1)are some constants.


                           If k > m, discard the vector pair {s
                           
                              k − m
                           , y
                           
                              k − m
                           } from storage.


                           Compute and save sk
                            = x
                           
                              k + 1 − xk and yk
                            = g
                           
                              k + 1 − gk
                           ;


                           Update
                           
                              
                                 
                                    
                                       B
                                    
                                    k
                                    0
                                 
                                 ,
                                 
                                 
                                 m
                              
                            
                           times, using the pairs
                           
                              
                                 
                                    
                                       {
                                       
                                          s
                                          i
                                       
                                       ,
                                       
                                          y
                                          i
                                       
                                       }
                                    
                                    
                                       k
                                       −
                                       m
                                       +
                                       1
                                    
                                    k
                                 
                                 ,
                              
                            
                           via following formula:


                           for  
                           l = m − 1   down  
                           to   0

                              
                                 (7)
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      B
                                                   
                                                   k
                                                   
                                                      (
                                                      m
                                                      −
                                                      l
                                                      )
                                                   
                                                
                                                =
                                                
                                                   
                                                      B
                                                   
                                                   k
                                                   
                                                      (
                                                      m
                                                      −
                                                      1
                                                      −
                                                      l
                                                      )
                                                   
                                                
                                                −
                                                
                                                   
                                                      
                                                         
                                                            B
                                                         
                                                         k
                                                         
                                                            (
                                                            m
                                                            −
                                                            1
                                                            −
                                                            l
                                                            )
                                                         
                                                      
                                                      
                                                         s
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                      
                                                      
                                                         s
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                         T
                                                      
                                                      
                                                         
                                                            B
                                                         
                                                         k
                                                         
                                                            (
                                                            m
                                                            −
                                                            1
                                                            −
                                                            l
                                                            )
                                                         
                                                      
                                                   
                                                   
                                                      
                                                         s
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                         T
                                                      
                                                      
                                                         
                                                            B
                                                         
                                                         k
                                                         
                                                            (
                                                            m
                                                            −
                                                            1
                                                            −
                                                            l
                                                            )
                                                         
                                                      
                                                      
                                                         s
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                      
                                                   
                                                
                                                +
                                                
                                                   
                                                      
                                                         y
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                      
                                                      
                                                         y
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                         T
                                                      
                                                   
                                                   
                                                      
                                                         y
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                         T
                                                      
                                                      
                                                         s
                                                         
                                                            k
                                                            −
                                                            l
                                                         
                                                      
                                                   
                                                
                                                ;
                                             
                                          
                                       
                                    
                                 
                              
                           
                           Set
                           
                              
                                 
                                    B
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 =
                                 
                                    
                                       B
                                    
                                    k
                                    
                                       (
                                       m
                                       )
                                    
                                 
                              
                           ;


                           k ← k + 1;


                           until termination
                        

Now to state the global convergence of Algorithm 2 and its convergence rate, we make the following assumptions on the objective function f.

                        Assumption 1
                        
                           
                              
                                 (a)
                                 
                                    
                                       
                                          Ω
                                          =
                                          {
                                          x
                                          ∈
                                          
                                             R
                                             n
                                          
                                          :
                                          f
                                          
                                             (
                                             x
                                             )
                                          
                                          ≤
                                          f
                                          
                                             (
                                             
                                                x
                                                0
                                             
                                             )
                                          
                                          }
                                       
                                     
                                    is a convex set.


                                    f is twice continuously differentiable.


                                    f is uniformly convex function, i.e. there exist positive constants M
                                    1 
                                    and MLBFGS such that
                                    
                                       
                                          (8)
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            M
                                                            1
                                                         
                                                         
                                                            
                                                               ∥
                                                               z
                                                               ∥
                                                            
                                                            2
                                                         
                                                         ≤
                                                         
                                                            z
                                                            T
                                                         
                                                         G
                                                         
                                                            (
                                                            x
                                                            )
                                                         
                                                         z
                                                         ≤
                                                         
                                                            M
                                                            2
                                                         
                                                         
                                                            
                                                               ∥
                                                               z
                                                               ∥
                                                            
                                                            2
                                                         
                                                         ,
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    for all
                                    
                                       
                                          z
                                          ∈
                                          
                                             R
                                             n
                                          
                                       
                                     
                                    and all x ∈ Ω.


                           Let x
                           0 
                           be a starting point, for which f satisfies
                           Assumption 1, and suppose matrices
                           
                              
                                 B
                                 k
                                 0
                              
                            
                           are symmetric positive definite initial matrices, for which
                           
                              
                                 {
                                 ∥
                                 
                                    B
                                    k
                                    0
                                 
                                 ∥
                                 }
                              
                           
                           and
                           
                              
                                 {
                                 ∥
                                 
                                    
                                       
                                          B
                                          k
                                          0
                                       
                                    
                                    
                                       −
                                       1
                                    
                                 
                                 ∥
                                 }
                              
                            
                           are bounded. Then, the sequence {xk
                           }generated by 
                           Algorithm 2 
                           converges to the unique x*on Ω, and the convergence rate is R-linear, that is, there is a constant 0 ≤ r < 1, such that
                           
                              
                                 (9)
                                 
                                    
                                       
                                          
                                             
                                                f
                                                
                                                   (
                                                   
                                                      x
                                                      k
                                                   
                                                   )
                                                
                                                −
                                                f
                                                
                                                   (
                                                   
                                                      x
                                                      *
                                                   
                                                   )
                                                
                                                ≤
                                                
                                                   r
                                                   k
                                                
                                                
                                                   (
                                                   f
                                                   
                                                      (
                                                      
                                                         x
                                                         0
                                                      
                                                      )
                                                   
                                                   −
                                                   f
                                                   
                                                      (
                                                      
                                                         x
                                                         *
                                                      
                                                      )
                                                   
                                                   )
                                                
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The proof of Theorem 3 can be found in Liu and Nocedal (1989).

This section evaluates the performance of the ELBFGS algorithm on a set of 1022 unconstrained optimization test problems. At the same time, we compare the performance of ELBFGS with the standard LBFGS algorithm proposed by Liu and Nocedal (1989) and the modified limited memory BFGS method described by Al-Baali (1995), denoted by MLBFGS in this paper. All codes are written in Fortran 77 in double precision and implement the same stopping criterion

                        
                           
                              
                                 
                                    
                                       ∥
                                       g
                                       ∥
                                    
                                    2
                                 
                                 ≤
                                 
                                    
                                       ϵ
                                       max
                                       {
                                       1
                                       ,
                                       ∥
                                       x
                                       ∥
                                    
                                    2
                                 
                                 
                                    }
                                    ,
                                 
                              
                           
                        
                     where ε = 10−5. All algorithms use exactly the same line search strategy, based on quadratic and cubic interpolations. Line searches are terminated when the following strong Wolfe conditions are satisfied.

                        
                           (10)
                           
                              
                                 f
                                 
                                    (
                                    
                                       x
                                       k
                                    
                                    +
                                    
                                       α
                                       k
                                    
                                    
                                       p
                                       k
                                    
                                    )
                                 
                                 ≤
                                 f
                                 
                                    (
                                    
                                       x
                                       k
                                    
                                    )
                                 
                                 +
                                 
                                    c
                                    1
                                 
                                 
                                    α
                                    k
                                 
                                 
                                    g
                                    k
                                    T
                                 
                                 
                                    p
                                    k
                                 
                                 ,
                              
                           
                        
                     
                     
                        
                           (11)
                           
                              
                                 
                                    |
                                 
                                 
                                    g
                                    T
                                 
                                 
                                    (
                                    
                                       x
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                    +
                                    
                                       α
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                    
                                       p
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                    )
                                 
                                 
                                    p
                                    
                                       k
                                       −
                                       1
                                    
                                 
                                 
                                    |
                                    ≤
                                 
                                 
                                    c
                                    2
                                 
                                 
                                    |
                                    
                                       g
                                       
                                          k
                                          −
                                          1
                                       
                                       T
                                    
                                    
                                       p
                                       
                                          k
                                          −
                                          1
                                       
                                    
                                    |
                                 
                                 ,
                              
                           
                        
                     with c
                     1 = 0.01 and c
                     2 = 0.9 (see for example Fletcher, 1987; Zhu et al., 1999).

We examine 73 test problems (the same were used by Al-Baali, 1992; 1995) which are selected from Andrei (2008) with the standard starting points. For each test problem, 14 runs with dimension ranging from 1000 to 50,000 are performed. Numerical testing of the methods is carried out with m = 5. A small sample of results is given in Tables 1–3
                     
                     
                     . They are representative of what has been observed.

The meanings of some of the variables used in the following tables are as follows:

                        
                           –DIM: the number of variables.

–n-I: the number of iterations.

–n-F: the total number of function or gradient evaluations.

We observe that the performance of the ELBFGS method is substantially better than those of LBFGS and MLBFGS in most cases. We note that the number of iterations and the number of function and gradient calls required to solve some problems by ELBFGS are smaller than approximately 35 percent of the number required by LBFGS (e.g., DIXMAANG). The opposite is on some test problems where for solving them the original scaling of limited memory BFGS and MLBFGS is better than the dynamic scaling. However, cases like this rarely occurred.

For the methods being analyzed, the fraction P of problems is plotted for any given method within a factor τ of the best number of iterations and number of function-gradient evaluations, based on the performance profiles of Dolan and Moré (2002). The percentage of the test problems for which a method is better is given on the left axis of the plot. The right hand side of the plot gives the percentage of the test problems that are successfully solved by these algorithms, respectively. As it can be observed, the use of the diagonal scaling ELBFGS enables a considerable computational saving on most problems with respect to LBFGS and MLBFGS methods, in terms of number of iterations and number of function and gradient calls, and on the most test problems the gain is impressive.

It is observed from Figs. 1 and 2
                     
                      that the ELBFGS is always the top performer for the most values of τ.

Comparison can be proceeded by means of overall relative geometric means and arithmetic means of algorithms ELBFGS and MLBFGS over LBFGS method based on measurements including number of iterations and number of function and gradient evaluations. The results are given in Table 4
                     .


                     Table 4 shows favorable relative reduction in the criteria being considered for ELBFGS method over LBFGS method.

Another analysis of the results can be carried on by considering the cumulative results, that is the total number of iterations and the total number of function and gradient evaluations needed to solve all the problems in toto. These cumulative results are reported in Table 5
                     . They confirm the effectiveness of ELBFGS in terms of all the criteria considered.

Note that the storage is exactly the same for both methods. But from arithmetics point of view, ELBFGS method implements two loop recursion procedure twice, resulting (4m + 1)n additional multiplications which are inexpensive. This means that the cost of building and applying initial diagonal approximation to the inverse Hessian is very low, thus succeeding not only to offset the additional computational effort, but also allowing to obtain an overall computational saving.

@&#CONCLUSION@&#

In the paper Liu and Nocedal (1989), Liu and Nocedal proposed limited-memory variants of the quasi-Newton approach in order to overcome the difficulty of computational storage and manipulation of full Hessian approximation matrices to solve large scale optimization problems. In their algorithm an initial diagonal matrix, which is a scalar multiple of the identity matrix, is invoked to rather approximate the inverse Hessian at each iteration.

In this paper we attempted to gain a different initial scaling matrix based upon the concept of a column equilibrated matrix in ℓ1-norm. This results in a diagonal matrix with elements resulting from a column equilibration of the Hessian approximation. The elements of the initial diagonal matrix are equal either to the absolute value of the sum of the column entries or to the scalar multiplier of the standard LBFGS depending on the given threshold value. This combination is done in such a way that it ensures positive diagonal elements. The diagonal scaling matrix has been embedded within an extra two loop recursion procedure prior to embarking the main approach of Hessian–vector product in the frame of LBFGS algorithm. This provides an initial matrix which is capable to equilibrate the limited memory BFGS updates at current step. This strategy suggests great reduction in the iteration cost of ELBFGS algorithm.

The major advantage of our modified method, ELBFGS algorithm is that it preserves the convergence properties of the LBFGS method, and yet it is able to upgrade the efficiency properties such as number of iterations, number of function-gradient calls without causing additional storage demand and no additional considerable computational cost. Our experiments showed that the ELBFGS is superior to the LBFGS and MLBFGS algorithms.

@&#ACKNOWLEDGMENTS@&#

We would like to acknowledge respective referee for his useful suggestions and comments on the previous versions of this paper, which improve this paper significantly.

@&#REFERENCES@&#

