@&#MAIN-TITLE@&#iBump: Smartphone application to detect car accidents

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Use smartphones with their built-in smart sensors to automatically detect & report car accidents.


                        
                        
                           
                           Reporting is done as soon as an accident happens.


                        
                        
                           
                           Data is continuously collected from the smartphone’s accelerometer.


                        
                        
                           
                           Data is intelligently analyzed using Hidden Markov Models (HMM) and Dynamic Time Warping (DTW).


                        
                        
                           
                           Data analysis determines the severity of the accident and reduces false positives.


                        
                        
                           
                           Once the accident is confirmed an SMS is sent to the police, medical services, & family members.


                        
                        
                           
                           The SMS includes the accident’s location, severity, and owner’s medical information.


                        
                        
                           
                           The application will notify the emergency responders within seconds of the accident.


                        
                        
                           
                           The application will help reduce the response time and perhaps help in reducing fatalities.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Dynamic Time Warping (DTW)

Hidden Markov Models (HMMs)

Pattern recognition

Accident detection

Smartphone application

@&#ABSTRACT@&#


               
               
                  Traffic accidents are a fact of life. While accidents are sometimes unavoidable, studies show that the long response time required for emergency responders to arrive is a primary reason behind increased fatalities in serious accidents. One way to reduce this response time is to reduce the amount of time it takes to report an accident. Smartphones are ubiquitous and with network connectivity are perfect devices to immediately inform relevant authorities about the occurrence of an accident. This paper presents the development of a system that uses smartphones to automatically detect and report car accidents in a timely manner. Data is continuously collected from the smartphone’s accelerometer and analyzed using Dynamic Time Warping (DTW) and the Hidden Markov Models (HMMs) to determine the severity of the accident, reduce false positives and to notify first responders of the accident location and owner’s medical information. In addition, accidents can be viewed on the smartphone over the Internet offering instant and reliable access to the information concerning the accident. By implementing this application and adding a notification system, the response time required to notify emergency responders of traffic accidents can potentially reduce the response time which may help in reducing fatalities.
               
            

@&#INTRODUCTION@&#

Smartphones are becoming more advanced and complex, and support a large number of sensors including audio recorders, Global Positioning Systems (GPSs), accelerometers and light and temperature sensors in addition to many others [1]. There are many opportunities of implementing consumer applications that intelligently exploit the built-in sensors of smartphones.

In addition, most smartphones support wireless data services which provides additional opportunities for building consumer applications that exploit the sensors and the network connectivity afforded by the various types of connectivity ranging from SMS, GPRS and 3G/4G.

While there has been considerable progress in the use of advanced driver-assistance systems (ADAS), lane departure warning system, and collision avoidance systems, the high cost of these systems has prompted researchers to consider using sensors on smartphones to warn a driver and to prevent unsafe driving behavior [2]. Sathyanarayana et al. [3] propose the use of a variety of sensors in the car including accelerometers to measure driver distraction. Threshold-based techniques using accelerometer data have been previously proposed to detect and report accident in motorcycles [4]. However, in a motorcycle accident since the motorcycle typically falls after an accident, it is much easier to use thresholds on accelerometer data to detect an accident. The situation is more complex in a car where the smartphone is typically inside the car and there is a great possibility of false positives if such a simplified approach is used. Another closely related problem of detecting an accident is that of fall detection which has attracted significant research in the past few years [5]. For example, Tamura et al. [6] used an accelerometer and gyro data to detect falling behavior based on simple thresholding techniques. Shi et al. [7] describe a more advanced system that applied a support vector machine (SVM) classifier to accelerometer data to detect falling behavior. Naïve Bayes classifiers have also been used to detect falling behavior [8]. Similarly, Abbate et al. [9] describe a system that uses a smartphone base accelerometer data with neural networks to successfully detect falls and reduce false positives. Finally, Kerdegari et al. [10] conducted a comparative analysis of a variety of pattern classification techniques like Multilayer Perceptron, Naive Bayes, Decisions trees, Support Vector Machine, ZeroR and OneR in conjunction with accelerometer data to detect falling behavior.

There are also many built-in systems that are used to detect car accidents using the electronic control units in the car, such as the OnStar AACN, and the ODB-II. Built-in sensors in the car can be used to detect changes in acceleration, or even to detect whether an airbag was ejected, which is a clear indication that a car accident has occurred [11]. WreckWatch is a wireless smartphone-based application that detects and reports traffic accident [11]. The system uses an accelerometer and audio data from the smartphone. The system uses a rule-based approach that combines thresholding on accelerometer and audio data to detect accidents and to reduce false positives. Similarly, Dai et al. [12] describe a system that uses various types of thresholding on acceleration data to detect several categories of drunk driver behavior including weaving, drifting, swerving and turning with wide radius. Another approach has been to combine data from car’s OBD-II networks with those from smartphones [13].

The contribution of this paper is the development of a hybrid approach that uses Dynamic Time Warping (DTW) and Hidden Markov Models (HMM) in conjunction with the built-in accelerometer in smartphones to detect and report car accidents using existing telecom and Internet infrastructure. The approach is practical as it only requires the end user to download the application on their smartphones without the need to buy expensive car built-in accident detection systems. The proposed approach has been successfully tested in a variety of situations using simulation data.

The remainder of this paper is organized as follows: Section 2 describes the components of the proposed system. Section 3 describes the system implementation. Section 4 presents experimental results. Finally, Section 5 concludes the paper.


                     Fig. 1
                      shows the proposed system. The system is based on a smartphone application that continuously detects if there is an accident using the built-in accelerometer. In the case of an accident, the severity is detected and the location is identified using the built-in GPS. The system then sends an SMS to emergency services and registered emergency contacts notifying them of the user’s information, accident, its severity, and its location. The system consists of two main parts: an Android application to be downloaded and an application server. Each part is described below.

An Android application, as shown in Fig. 2
                        (a), is downloaded on to a smartphone with a built-in accelerometer and supporting smartphone location services like a built-in GPS and/or GSM triangulation. As Fig. 2(b) shows, the application allows a user to enter their personal information including name, ID, blood type, and phone numbers of individuals to inform in case of an accident. The application runs in the background and if an accident occurs, the application immediately sends an SMS to the police, emergency services, and registered emergency contacts with user’s information and geo-location. After sending SMSes, the application gives the user an option to register a false alarm which if done, sends SMSes to the various parties indicating that the previous SMS was a false alarm (Fig. 2(c)).

The application server is a web-based application built using Apache, PHP, MySQL and JQuery. The application server provides the following services.
                           
                              •
                              Real-time reporting of accidents with geolocation.

Various report showing current accidents and their location and trends.

User registration and tracking.

A screen shot of the application server is shown in Fig. 3
                        .

The system was developed based on crash data generated using a physical apparatus as shown in Fig. 4
                     . A 3-axis accelerometer interfaced to a microcontroller was mounted on a metal surface of the testing model. Various severities of crashes were simulated by extending the spring to various lengths and by letting the accelerometer crash into the fixed surface. Accelerometer data during this movement was stored and retrieved for later analysis. The accelerometer embedded in the smartphone, which usually has a range of 3G, allowing for more accurate results when determining between fall accidents and daily user activities, since falls and daily user activities, such as running or walking, usually have acceleration magnitude between 0Gs and 6Gs. However, the accelerometer values that are recorded during a car accident are usually higher than 6Gs, which is difficult to detect using a smartphone accelerometer that has a maximum reading of 3Gs. Therefore, the apparatus used accelerometers with a range of ±16Gs and this data was clipped to a threshold of 3Gs in order to verify that the proposed algorithm worked accurately in detecting car accidents on the smartphone.

The data retrieved from the apparatus was used to construct two different algorithms for crash detection. The development of each algorithm is described next.

Dynamic Time Warping (DTW) is a time series alignment algorithm developed originally for speech recognition. It align’s two sequences of feature vectors by warping the time axis iteratively until an optimal match (according to a suitable metrics) between the two sequences is found [14]. The standard DTW has a time and space complexity of O(n
                        2) where n is the length of the sequences being compared [15]. DTW has been successfully used to compare data streams [16].

As Fig. 4 shows, the apparatus described earlier was used to collect 30 samples for each of the three severity states by varying the length with which the spring was pulled. Fig. 5
                         shows sample accident data from the apparatus. The no-accident state data was collected by including actual data from a car including cases of sudden acceleration, sudden brake, and uneven road. Fig. 6
                         shows actual no-accident data reflecting a car driving on an uneven road.

The raw data thus collected from the accelerometer consisted of ax
                        , ay
                        , and az
                         as the acceleration on x-axis, y-axis and z-axis, respectively, and was transformed into single magnitude of acceleration (MA) as shown in Eq. (1).
                           
                              (1)
                              
                                 MA
                                 =
                                 
                                    
                                       
                                          
                                             a
                                          
                                          
                                             x
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             a
                                          
                                          
                                             y
                                          
                                          
                                             2
                                          
                                       
                                       +
                                       
                                          
                                             a
                                          
                                          
                                             z
                                          
                                          
                                             2
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In order to apply this technique, it was assumed that a vehicle can be in one of four states; no-accident, low severity, medium severity and high severity accident. Training data was collected for each of the four states using the apparatus and subsequently DTW was then used to distinguish between the four states [17].

HMM is a modeling tool that can be reliably employed for modeling and analyzing time-series with spatial or temporal variability and has been applied in many gesture and speech recognition projects with good results. For example, GestureWrist is a wrist-watch that recognizes distinct hand gestures using capacitance and acceleration sensors [18].


                        Fig. 7
                         shows the basic approach for developing the HMM-based algorithm. Sensing step consists of recording the accelerometer data. Since the smartphone accelerometers currently only measure a range of [−3Gs,3Gs], the original test data which has a range of [−16Gs,+16Gs] is clipped to this 3G range. Weighted Moving Average (WMA) filtering was used next to smooth out the data (α
                        =0.2) as shown in Eq. (2) where a is the ax
                        , ay
                        , and az
                        
                        .
                        
                           
                              (2)
                              
                                 
                                    
                                       a
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 =
                                 α
                                 ∗
                                 
                                    
                                       a
                                    
                                    
                                       i
                                       -
                                       1
                                    
                                 
                                 +
                                 (
                                 1
                                 -
                                 α
                                 )
                                 ∗
                                 
                                    
                                       a
                                    
                                    
                                       i
                                    
                                 
                              
                           
                        
                     

Different values of α were used and empirically the value of 0.2 provided the best results.

As Fig. 7 shows, the filtered data is submitted next to a vector quantization unit. Vector Quantization is mainly used to convert three-dimensional sampled data to one-dimensional sequences of discrete symbols or prototype vectors, such that these vectors are used as inputs for both the training and recognition phases of the HMMs. The collection of these vectors is referred to as the codebook.

Two codebook encodings were used. The first codebook encoding used the K-means algorithm. The K-means algorithm is a well-known clustering algorithm [19]. The K-means algorithm was used with the squared Euclidean distance d
                        2 as shown in Eq. (3).
                           
                              (3)
                              
                                 
                                    
                                       d
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 
                                    
                                       a
                                    
                                    
                                       1
                                    
                                 
                                 ,
                                 
                                    
                                       a
                                    
                                    
                                       2
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                   x
                                                
                                             
                                             -
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                   x
                                                
                                             
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                   y
                                                
                                             
                                             -
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                   y
                                                
                                             
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                                 +
                                 
                                    
                                       
                                          
                                             
                                                
                                                   a
                                                
                                                
                                                   1
                                                   z
                                                
                                             
                                             -
                                             
                                                
                                                   a
                                                
                                                
                                                   2
                                                   z
                                                
                                             
                                          
                                       
                                    
                                    
                                       2
                                    
                                 
                              
                           
                        After applying the K-means algorithm with a cluster size of 8, the original continuous acceleration vector a(t) is reduced to a discrete codebook scalar cb(t) where cb(t) can take one of eight discrete states. Cluster size of 8 was chosen empirically.

The second codebook called Slope-codebook encoding used the slope of MA (see Eq. (1)) to encode the original a(t) into three states of (1) decreasing, (2) no change, and (3) increasing. Fig. 8
                         shows the original accelerometer data for the mild accident case and Fig. 9
                         shows the result of applying the Slope-codebook to the data. Similarly, Fig. 10
                         shows the original accelerometer data for the severe accident case and Fig. 11
                         shows the result of applying the Slope-codebook to the data.

The basic approach in applying HMMs consists of constructing a single HMM for each of the vehicle states. Several well-known algorithms for training the models of the HMM technique exist. Both Viterbi and Baum–Welch algorithms were utilized for training [20]. The readings recorded from the apparatus were divided into two sets: a training set for training the algorithm, and a testing set for testing how well the training was and for analyzing the algorithm’s performance. After gathering different readings from the test they are placed into a matrix that is given as input to the classifier algorithm during training. The training algorithm determines the right function to be able to distinguish between the different types of severity. Based on the features of each severity from data, the training algorithm tries to find the exact line that separates these severities. The algorithm continues searching until the error rate is less than or equal to provided threshold. Once the error rate is less than or equal than specified, the Baum–Welch algorithm returns the function that represents the line that separates the severities. The Baum–Welch algorithm determines the probability of occurrence of the test set and uses it as a learning mechanism for the model. Even though the complexity of the original Baum–Welch algorithm is O(n
                        2), the algorithm is only run once on the in order to train the algorithm to be able to accurately specify which model the data belongs to, and is not run on the actual application on the Smartphone. After the training phase, the Viterbi forward–backward algorithm is run to find the most probable sequence of states or paths for a model given an observed sequence coded using the codebook. The model that results in the highest probability is selected as the one to which the observed sequence belongs. There is one model for each of the no-accident, and severity states and the observed sequence is the sequence of state changes as specified in the actual data being collected, filtered and converted using a code book as shown in Figs. 9 and 11.

@&#EXPERIMENTAL RESULTS@&#

In order to test the DTW algorithm, 25 test cases were developed for each of the states for a total of 100 test cases. The algorithm was executed on each of the test cases to make a prediction about the actual state. The results are shown in the form of a confusion matrix in Table 1
                     . The confusion matrix shows the comparison of predicted vs. actual results. For example, in Table 1, out of 25 no-accident cases, 23 were predicted correctly by DTW and only 2 cases were false positives. Furthermore, all 75 accident cases were predicted correctly as accident cases.

The accident condition shown in Table 1 includes all three severity levels using DTW. As the table shows, the DTW method was able to achieve an overall performance of (23+75)/100=98% accuracy in distinguishing between a no-accident and an accident state. The severity levels were combined into one category using DTW because it was not able to adequately differentiate between the severity levels. This distinction was adequately established by using the HMM technique as described below.

In order to test the K-means-codebook HMM approach, 25 test cases for the no-accident condition and 25 test cases for the accident state were used. The results are shown in Table 2
                     . As the table shows, this approach resulted in (18+25)/50=86% accuracy in distinguishing no-accident from the accident state.

Even though the results for HMM in detecting accident vs. no-accident were worse than DTW, the second codebook approach using Slopes helped distinguish between the various levels of severity. As Table 3
                      shows, this approach obtained an accuracy of (24+25)/50=98% in distinguishing between mild and severe accidents.

Consequently, a two-tiered approach as shown in Fig. 12
                      can be used. The K-means codebook and DTW are collectively used to detect whether there is an accident. In case of a disagreement, DTW is preferred because it has a lower false positive rate. If an accident is detected, Slope-based HMM is used to differentiate between mild and severe accidents.

The application of the two-tiered approach on a typical Samsung Galaxy Nexus Android smartphone, with Dual-core 1.2GHz processor and 1GB RAM, resulted in an average response time of 295ms. This response time is more than adequate for detecting and reporting car accidents.

@&#CONCLUSIONS@&#

In this paper a hybrid approach using Dynamic Time Warping (DTW) and Hidden Markov Models (HMMs) has been implemented and tested to detect and report car accidents using smartphones. As opposed to the threshold-based methods, this pattern-based hybrid approach yields a low false positive rate of 2%. Even though the approach seems promising, it needs to be tested in the field using automotive crash simulation and detection systems. One key advantage of this approach is that it only requires the user to download and run the application on their smartphone without any extra equipment or cost. This system can be used in any moving vehicle without the need for expensive car built-in accident detection systems. Future work includes porting the application to run on other smartphone platforms such as IOS and Windows.

@&#ACKNOWLEDGMENTS@&#

The authors would like to thank Rona Kanbar, Sarah Al-Otaibi, and Farah Al-Haddad for their help in collecting data and in implementation and testing activities.

@&#REFERENCES@&#

