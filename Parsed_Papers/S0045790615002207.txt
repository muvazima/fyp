@&#MAIN-TITLE@&#A session protocol for wireless sensor networks. Application to oil spills monitoring

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Collection of measurements on a dynamic and non-connected wireless sensor network.


                        
                        
                           
                           Proposition of a session protocol to reconstitute a consistent information system.


                        
                        
                           
                           Definition of a clustering metric and of a contextual inheritance relation.


                        
                        
                           
                           Simulations of the protocol behavior on Riverbed Opnet Modeler.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Wireless sensor networks

Session protocol

Riverbed Opnet Modeler

@&#ABSTRACT@&#


               
               
                  Wireless sensor networks may be used for the surveillance of large systems (bridges, tunnels, etc.) or in the management of disasters such as forest fires, or oil spills. In some of these applications, the topology of the network is going to be dynamic: a connected system can evolve into a clustered system that presents a break of the global connectivity. Using a collector which will regularly visit the disjoint clusters enables to restore a discreet connectivity.
                  A session layer protocol is proposed to reconstitute a consistent global information system. It enables the collector to reconstruct the communication context with the previously visited clusters, knowing they could have moved, merged, or have split. A node sensor model has been integrated into the Riverbed Opnet Modeler network simulation environment. Simulations show the benefits of the protocol, and particularly how it provides a better trajectory planning of the collector.
               
            

@&#INTRODUCTION@&#

In order to illustrate our work, we have chosen in this paper an application of oil spills observation. In 1972, the world program IGOSS of continuous monitoring of the pollution of the seas was initiated (Integrated Global Ocean Services System). In 1979, a report suggests to deploy sensors on the oil slicks, to study the evolution of the pollution by hydrocarbons [1]. The more recent emergence of wireless sensor networks reinforces this idea. Indeed, compared to the classical visual aerial flyover, they will allow a continuous and real time monitoring of the drift of the oil slicks, their size, their consistency, etc. From the beginning of the oil spill, many sensor nodes are randomly scattered to observe it. The major difficulty is to cope with the dynamics of the system which implies a variation of the network topology. It is primarily caused by two types of mobility which are:
                        
                           –
                           the mobility of the slicks that causes a topological change in the network which may imply a communication interruption. Indeed, at the beginning of the spill, the oil immediately tends to spread on the surface of the water into slicks, which in theory form regular circles whose diameter increases eight times in the hour following the spill, then five times before the end of the week. Then, wind, waves, and the Coriolis force (due to the rotation of the Earth) contribute to stretch, move, and fragment the slicks until their decomposition into droplets;

the mobility of the nodes themselves which are dispersed on oil slicks. Indeed, under the influence of external factors such as wind, the nodes can move randomly which may affect radio connections when they are distant from each other. Similarly, the effect of endogenous factors such as the depletion of the battery or the node failure may affect the topology of the network and cause information routing problems.

The dynamics of the network may lead to a partial or total loss of connectivity for one or several nodes, and so to the inconsistency of the global information system (non-connected communication graph). Therefore, we propose a 3-levels architecture for a coherent information system, based on the measurement, the collection and the processing of data relative to the spread of oil (Fig. 1
                     ):
                        
                           –
                           
                              Level 1: the measurement (viscosity, temperature, location, etc.) is performed by each sensor and transmitted to a cluster head. This one is elected to represent several nodes, enabling to prioritize communications in order to reduce their number and locate them. Indeed, thousands of sensors may be deployed, and the system can quickly reach high dimensions. The elective process and the partitioning metric are briefly described in Section 2, to aid comprehension, even if it is not the aim of the paper;


                              Level 2: the collection of the nodes measurements is carried out by one (or more) collector (s) (robot, airplane, etc.) which will visit (at a fixed or variable period) the cluster heads. As the clusters are evolving in location, size, number, and in representation (the head may have changed) and because we cannot have a continuum of the evolution of the slicks monitoring, we propose to implement a “session” layer with the objective of re-contextualizing each return of the collector from its previous visit. The trajectory of the collector will be defined on the basis of specific session parameters.


                              Level 3: data processing is realized at a central level called “Information System”, which is supplied with data gathered by the collector(s). In this article, we are not studying this aspect of the overall problem. It will be therefore not be discussed in detail.

So, the second level of the proposed architecture consists in a mobile sink (we call collector) that is responsible for data collection and that is based on a session layer. A particular interest of this session protocol is shown in Fig. 2
                     : the mobile sink should move all along the monitored area in order to collect the data disseminated in the sensor nodes (upper part of Fig. 2). However, in order to increase the refreshment frequency of the global information system, it should avoid covering the whole area (especially when the distribution of the nodes is not uniform).
                        
                           –
                           Clustering is used as a first step to disseminate data from a set of nodes into a single node (and reduce yet the number of points to visit).

The session protocol will then check that the information stored in clusters is sufficiently representative regarding the application requirements (here, regarding the size of the oil slick). If it is not the case, the related point on the trajectory will be once again removed.

It will also contribute to improve the trajectory of the mobile sink as follows: the contextualization performed by such session layer will be used in order to predicate future nodes location and hence ensures the communication capability between the collector and the nodes. Thus, it leads to a smaller subarea to cover regardless of the trajectory strategy used. Three strategies are presented in Fig. 2: space curves (a), grid based (b), random (without session c) and controlled (our proposal d).

The next section discusses related works. Section 3 shows the clustering strategy proposed for those networks. Section 4 reminds the formalization of a session and details the session protocol. The performance of the protocol is finally analyzed in Section 5 through numerous simulations, and discussed in Section 6.

@&#RELATED WORKS@&#

This paper focuses on mobile sink wireless sensor networks. It is hence related to the use of mobile collectors, the session layer mechanisms and finally the mobile sink trajectory.

Firstly, using mobile collectors was particularly discussed for the improvement of routing [2] or, as in this paper, for collecting information as in [3]. One might think that researches leaded about datamules [3,4] are close to our problem. Indeed, the objective is also to collect disseminated data. But the recurrence of this collection, and the mobility of data are not taken into account by datamules. Furthermore no relationship is envisaged between two visits.

Secondly, to our knowledge, few works focused the session layer for networks similar to our case study. Ref. [5] define a session layer for DTN (Delay Tolerant Networks) with as objectives the partial support of the order of transactions (bundle), a publisher/subscriber/custodian service model, and the obsolescence management (of the bundles). Content management is handled through a URL for each group of bundles, with in addition a stamping mechanism to provide time control. In comparison, a single group may have changed in our case study, not only its value, but also its perimeter as defined in Section 4.1.1.

Regarding the roles management defined in [5], the collector corresponds to the custodian (generally a router which acts as a DTN proxy) but here, the network connection will be provided by the displacement of the collector. The major synchronization points in [6] are finally associated with a sequence number (for the management of the order of packets on a network, knowing that in our case study, it is a simple point-to-point link) and a stamping which assumes a clock synchronization we do not consider.

Then, even if Fig. 2 shows how the session protocol may help in reducing the number of points to visit and in predicting their location, a controlled mobility of the collector has still to be selected. Several works have defined trajectory strategies for mobile sinks. Approaches like [7–9] consist mainly of comparing predetermined trajectories, adapting the data dissemination to the sink location or predicting future sink locations from its past movement.

In [7], the authors suggested a proactive data dissemination approach that would enable a mobile sink to effectively gather a representative view of a monitored region covered by n sensor nodes by visiting any m nodes, where m
                     ≪
                     n. The limitation of the number of nodes/groups to visit is a common objective with our paper. The proposed strategy enables the mobile sink to follow any trajectory through the deployment region, thus decoupling the data dissemination management from the mobile sink’s trajectory. However the data dissemination is controlled (based on random walks and with overhead) whereas the measurements in our paper depends on the application dynamics (that are non controlled and non uniform). The main difference with us is also related to the representativeness of the nodes which is not common or constant. It means that the set of nodes that has to be visited cannot be randomly selected but should be part of a predefined path. Moreover, the predefined path has to take into consideration the nodes mobility. Our session protocol helps here to identify which nodes are representative and to predicate their locations (and hence the sink future locations). When the set of nodes and their locations are determined, strategies to consider are free and might be the same in our work as the ones selected in [7].

In [8], the trajectory is based on the “Hilbert Space Filling Curve” algorithm adapted according to the node density. As it is noted, a space filling curve is typically defined as the limit of a sequence of curves which guarantee the filling of a d-dimensional space by traversing each and every pre-defined point in the space once and only once, in a particular order. Regarding this paper, when the session protocol has defined the set of nodes to visit, space filling curves like those studied in [8] might be used. However, this is based on the predefined mobility model. Regarding the application dynamics, it means that such model has to be computed at each cycle (variable density, variable location, variable list of nodes, etc.) and may be quite different in terms of network coverage and scalability.

Ref. [9] presents a classification of the different data dissemination strategies. As noted by the authors, our approach is interesting since “the flexibility to adapt dissemination strategies according to applications” requirements have proved to be more efficient”. Among the mobility strategies defined in [9], the random is not selected here since the sink’s movement depends on network and external conditions. The solution consists here in a controlled/predictable mobility specified by the session protocol. Due to the sensor nodes mobility (related to the application dynamics), grid based or flat architectures are not selected (they will not be optimal during the whole experiments), but a cluster-based approach based on a N to M dissemination is preferred. Ref. [9] note in this way that cluster-based techniques are better for large scale wireless sensor networks and it can also be mentioned that oil slicks might be easily mapped onto clusters.

To summarize, our paper looks, not for a special trajectory, but for a specification of rendez-vous points for the trajectory. Two factors of the performance of the selected trajectory may impact the proposed protocol. Firstly, a longer trajectory would decrease the visit frequency and hence the global information system refreshment. Secondly, a wide-meshed trajectory may compromise the communication capability between the collector and the cluster nodes.

Compared to our previous works [10], this paper defines the synchronization points, highlights the benefits of the session protocol in terms of models reducing (of the number of groups to be visited), develops the efficiency of the protocol regarding the clusters size, the network size, the monitored area and the nodes density, and analyzes how the trajectory length (or exactly, the sub area to be monitored) is impacted by the session protocol.

The characteristics of sensor networks require the establishment of self-organization mechanisms in order to partition the network into a number of homogenous groups of nodes called “clusters.” Indeed, the number of nodes, their low capacity of transmission and processing, their mobility, and their limited energy, do not enable each one to communicate directly with the “sink” where all the data must converge. A cluster is a subset of connected nodes, and clustering is the process for grouping nodes into disjointed clusters (Fig. 3
                     ).

A particular node called Cluster Head (CH), allows to coordinate the members of its cluster, to aggregate and/or process the measured data and to transmit them to the data collector. The cluster head is a priori selected, or elected by all the network nodes, according to a specific metric or combination of metrics. In [11], after having studied and analyzed the numerous metrics which are available in the literature [12], we have proposed an algorithm for the election of the cluster head. It is based on a metric adapted to the specific characteristics of our application, which has to be minimized. It includes the following parameters: residual energy, density and mobility of the nodes. Our application with an high dynamics suggests that we choose to elect the cluster head in the smallest possible k-neighborhood. The metric is based on a 1-density, and so, cluster members will be at most 2 hops from the head.

The metric is expressed as:
                        
                           
                              
                                 
                                    m
                                 
                                 
                                    i
                                 
                              
                              (
                              t
                              )
                              =
                              (
                              1
                              -
                              α
                              )
                              ·
                              
                                 
                                    M
                                 
                                 
                                    i
                                 
                              
                              (
                              t
                              )
                              /
                              (
                              
                                 
                                    ε
                                 
                                 
                                    i
                                 
                              
                              (
                              t
                              )
                              ·
                              α
                              ·
                              
                                 
                                    ρ
                                 
                                 
                                    i
                                    ,
                                    1
                                 
                              
                              (
                              t
                              )
                              )
                           
                        
                     with: 
                        
                           α
                        
                      is the an application dependent parameter, 
                        
                           
                              
                                 ρ
                              
                              
                                 i
                                 ,
                                 1
                              
                           
                           (
                           t
                           )
                           =
                           
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       ,
                                       1
                                    
                                 
                                 (
                                 t
                                 -
                                 Δ
                                 t
                                 )
                              
                              
                                 
                                    
                                       N
                                    
                                    
                                       i
                                       ,
                                       2
                                    
                                 
                                 (
                                 t
                                 -
                                 Δ
                                 t
                                 )
                              
                           
                        
                     
                     
                        
                           
                              
                                 ρ
                              
                              
                                 u,
                                 1
                              
                           
                           (
                           t
                           )
                        
                      is the node i density [13], 
                        
                           
                              
                                 ε
                              
                              
                                 i
                              
                           
                           (
                           t
                           )
                        
                      is the residual energy of node i, 
                        
                           
                              
                                 N
                              
                              
                                 i
                                 ,
                                 k
                              
                           
                           (
                           t
                           )
                        
                      is the number of k-hops neighbors of the node i and 
                        
                           
                              
                                 M
                              
                              
                                 i
                              
                           
                           (
                           t
                           )
                           =
                           
                              
                                 (
                                 |
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 t
                                 )
                                 -
                                 
                                    
                                       d
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 t
                                 -
                                 Δ
                                 t
                                 )
                                 |
                                 )
                              
                              
                                 Δ
                                 t
                              
                           
                        
                      the mobility of the node i, in which :
                        
                           
                              
                                 
                                    d
                                 
                                 
                                    i
                                 
                              
                              (
                              t
                              )
                              =
                              
                                 
                                    1
                                 
                                 
                                    |
                                    
                                       
                                          N
                                       
                                       
                                          i
                                          ,
                                          1
                                       
                                    
                                    (
                                    t
                                    )
                                    |
                                 
                              
                              
                                 ∑
                              
                              v
                              ε
                              
                                 
                                    N
                                 
                                 
                                    i
                                    ,
                                    1
                                 
                              
                              (
                              t
                              )
                              
                                 
                                    dist
                                 
                                 
                                    (
                                    i
                                    ,
                                    v
                                    )
                                 
                              
                              (
                              t
                              )
                              ,
                              
                              and
                              
                              
                                 
                                    dist
                                 
                                 
                                    (
                                    i
                                    ,
                                    v
                                    )
                                 
                              
                              (
                              t
                              )
                              =
                              
                                 
                                    
                                       
                                          (
                                          
                                             
                                                X
                                             
                                             
                                                i
                                             
                                          
                                          (
                                          t
                                          )
                                          -
                                          
                                             
                                                X
                                             
                                             
                                                v
                                             
                                          
                                          (
                                          t
                                          )
                                          )
                                       
                                       
                                          2
                                       
                                    
                                    +
                                    
                                       
                                          (
                                          
                                             
                                                Y
                                             
                                             
                                                i
                                             
                                          
                                          (
                                          t
                                          )
                                          -
                                          
                                             
                                                Y
                                             
                                             
                                                v
                                             
                                          
                                          (
                                          t
                                          )
                                          )
                                       
                                       
                                          2
                                       
                                    
                                 
                              
                           
                        
                     The algorithm implemented in each node is illustrated by the state-chart of Fig. 4
                     . It uses Hello messages so that each node discovers its neighborhood. These messages inform it about the parameters of each of its neighbors (density, mobility, and energy node). So, it will be able to calculate its own metric m(i) to be compared with those of its neighbors m(helloj
                     ). Messages Invite and Join enable respectively the cluster head and an ordinary node, to propose to join the cluster and to accept this proposal.

We validated the algorithm into a node model under the network simulation Riverbed Opnet Modeler environment with the following simulation parameters.

All nodes are in conformance with the non-slotted and non-beaconed IEEE 802.15.4 MAC layer [14]. This protocol enables to optimize the lifetime and journey range that the batteries provide. The energy model we have chosen was proposed by Jurčík and Koubâa, and is described in [15]. Then we have selected the Random Waypoint mobility model proposed by [16], and refined by [17]. Even it has been criticized in [18], it is certainly the most used: after its movement, a node stops during a finite time, chooses randomly a destination, moves again, and so on until the end of the simulation. At the beginning, all nodes are concentrated in one corner of the square monitored area. The considered nodes speeds correspond to realistic weather conditions. Fig. 5
                      summarizes these choices and describes the node model under the Riverbed Opnet Modeler environment. It shows where the algorithm has been implemented.

We have also developed a tool we have named photographer (Fig. 6
                     ) enabling us to visualize the dynamics of the clusters creation. We were able to show how to choose the density and mobility weight parameter α, according to the application characteristics (speed of the nodes, etc.). This parameter ensures a good stability of the partitioning: maximization of the time during which a node remains cluster head, while minimizing the number of created clusters.

The “measurement” level has been now described, and we can study the “collection” level which is the aim of this paper. It consists of moving collectors which have to gather the measured information and transmit them at the “Information System” (IS) level. But as a consequence of the dynamics of the application, the collectors may find between two successive visits in a same region, a situation that has potentially significantly evolved. This changing context is an obstacle to the restoration of a coherent information system which should overcome the connectivity breaks of the “measurement” level. Remember that the collector has to recover a discreet connectivity when the dispersion of nodes makes the communication graph non-connected. We illustrate this problem in the following example.

Let us consider two clusters C1, C2 and CH(C1), CH(C2) their respective cluster heads. Between two visits of the collector, both C1 and C2 merge into a single cluster C3 (with or without other nodes belonging previously neither to C1 nor to C2). Several cases can occur depending on the result of the implementation of the clustering algorithm:
                        
                           –
                           
                              Case1: CH(C1) becomes head of the new cluster C3. Thus CH(C3)CH(C1)


                              Case2: CH(C2) becomes head of the new cluster C3. Thus CH(C3)CH(C2)


                              Case3: a former member (v) of the cluster C1 or C2 becomes head of C3. Thus CH(C3)(v).


                              Case4: a node (u), which belongs neither to C1 nor to C2, becomes head of C3. Thus CH(C3)(u).

In both cases 1 and 2, the collector when it comes back, finds CH(C3)CH(C1) or CH(C3)CH(C2), and will collect the information for the area covered by the cluster C3. It must be aware of the context evolution. This is quite simple because it previously knew C1 and C2. But in cases 3 and 4, the collector finds CH(C3)(v) or CH(C3)(u), and it may be difficult for it to associate this situation with the context of its previous visit in this area covered by C3.

In all four cases, the collector has a representativeness problem of the information measured in the area. In other words, how the collector can understand that information given by the new CH(C3) come from the previous C1 and C2 areas it knew before, considering that there is no location coordinates of these areas, and that its correspondents have potentially changed? In these conditions, trajectory planning will be difficult. Fig. 7
                      shows two other scenarios. The problem can be generalized to m clusters which merge or split into n new clusters, as it will be defined in Section 4.1.

It is therefore necessary to implement a session protocol at the “collection” level that will enable the collector to retrieve the context of its previous visits. It will resume the dialogue with the former or possibly the new elected cluster head, consolidate information specific to each area, classify them in the correct order, and thus recreate the global context of the collection of the data. In other words, even with discrete connections when it visits the cluster heads, the collector can rebuild a consistent information system over the former established connections. For example, in the case of a merging of clusters where the head is changing, the collector may give it a session identifier deducted from those given to the heads of the former merged clusters.

The topology of the network is constantly changing depending on the evolution of the dispersion of oil on the sea. Thus, groups of sensor nodes can merge and form a larger group. Conversely, a group of sensor nodes can be divided into two or more subgroups. These dynamic groups are of variable size, and so informationally significant or not (is this interesting to visit a group of few nodes representing a very small slick?).

We therefore define the session and the inheritance, on which are based the merging or the splitting of slicks that represent the different scenarios of the network dynamics. The session and the inheritance will pilot the visiting strategy of the collector(s).

A session represents the exchange of an informational subset of the global information system S(k) between a collector and the groups of nodes 
                              
                                 Gi
                              
                           . It therefore has a spatial and temporal dimension. k evolves at each new visit of the collector, and therefore represents the discretization of the global sensor network connectivity. Note that the same notation will be used now, for the group of nodes 
                              
                                 Gi
                              
                           , and for the session 
                              
                                 Gi
                              
                            that represents the informational subset of S(k) provided by 
                              
                                 Gi
                              
                            at time k.

In order the collection to be efficient, the exchange has to be informationally significant. Therefore it can be limited to a group of nodes (cluster) of sufficient size ({|G|⩾
                           n). A too small cluster will thus not be associated to a session thanks to this size threshold n. For example, a one square-meter slick represented by two nodes will not be visited because it is informationally negligible. A session therefore represents the exchange of information with a cluster consisting of at least n nodes. The value of the number n depends on the total number of nodes, but mostly on the accuracy with which we want to observe the physical phenomenon. A large value of n will provide a macroscopic view of reality. A small value of n will give a more precise image, but will considerably complicate the visiting program of the collector(s).

The association of a session to a cluster enables to limit the trajectory of the collector to the cluster heads. We consider that for each visit of the collector to the cluster head representing a group of nodes 
                              
                                 Gi
                              
                           , this latter can provide the following parameters: the set of all of its members identifiers {Gi}, its location 
                              
                                 Pos
                                 (
                                 CH
                                 (
                                 Gi
                                 )
                                 )
                              
                           , the location of the most distant member from the head 
                              
                                 Pos
                                 (
                                 Cmk
                                 )
                              
                           , and the nodes measurements which may be pre-processed (for example, the average D
                           avg of the measurements).

This relationship is essential, because it will enable the continuity of the context between two collector visits, even if the cluster heads have changed. Indeed, a cluster may have lost or gained some nodes, may have elected a new head, may have merged with another, or may have been divided into several other clusters. The collector must be able to associate the new context it discovers, to the situation it has observed during its previous visit. We define the inheritance relation as:
                              
                                 
                                    Gi
                                    ∈
                                    S
                                    (
                                    k
                                    +
                                    1
                                    )
                                    
                                    inherits from
                                    
                                    Gj
                                    ∈
                                    S
                                    (
                                    k
                                    )
                                    <
                                    =
                                    >
                                    ∃
                                    g
                                    ⊂
                                    Gi
                                    /
                                    g
                                    ⊂
                                    Gj
                                    
                                    and
                                    
                                    |
                                    g
                                    |
                                    ⩾
                                    ξ
                                    .
                                    n
                                 
                              
                           
                           
                              
                                 ξ
                              
                            represents the variation of the number of defectors around the minimum size to form a group. It is positive and can be less than 1 to avoid the creation of a new session when defectors from several groups merge to form a new group (double inheritance).

A session is a merging of other sessions if it inherits from at least two sessions. The merging represents the case where a significant part of two or more groups merge to create a new group.

A session is split into two or more other sessions if each one inherits from the original session when the group with which it was associated is divided in groups of sufficient size (as described on top of Fig. 7).

A session is considered as newly created if it is associated with a group of sufficient size and if it does not inherit from any existing session. A session disappears if no session inherits from it, or if the group it belonged to no longer contains at least n nodes.

As there is a break of connectivity, it is important to note that a session is organized in two phases. The first one, called “collection”, is to gather on the collector the measured information. The second phase consists in a classical session layer exchange, to manage synchronization points between the collector and the Information System. The session layer is classically located at level 5 of the OSI model, and between the clustering and the application layers in our reduced model, as shown in Fig. 8
                           . The service offered by the session layer is defined in the standard [19] and is especially implemented in X.25, SCP (Secure Copy Protocol) and SIP (Session Initiation Protocol). Some researches have been conducted in order to adapt SIP to Wireless Sensor Networks (WSN) and particularly Zigbee-based WSN. In this objective, [20] use SIP for signaling, registration and redirection between a device and a server. On the other hand, [21] define a mapping between the Zigbee binding mechanisms and the SIP publish/subscribe mechanisms. In both cases, synchronization problems related to measurements collection are not taken into account, which is essential for us, for rebuilding a consistent information system.

As mentioned in [22] synchronization points are used to identify parts of the data stream with the double aim to isolate the various logical parts of the dialogue, and to allow recovery in case of error or incident. In this paper, the concept of incident will be associated with the break of the network connectivity, and the dialogue will be resumed at each cycle of the mobile collector when it returns to the level 3 of the architecture. The major synchronization points are used to completely separate the parts of the communication which precede and which follow a new collector cycle. They define a dialogue unit and correspond to the snapshots of the network established at each cycle of the collector. Minor synchronization points enable to structure each dialogue unit. In our protocol, the minor synchronization points will be associated to the exchanges between the collector and each sensors group which is represented by a session. Fig. 9
                            illustrates the concept of synchronization point. It shows that the major synchronization points correspond to the view of the information system at each return of the collector to its “base camp”, when minor synchronization points correspond to each of the exchanges between the collector and the visited cluster heads.

In this paper, we define a session layer with point-to-point connections, and therefore we focus on the associated connection management mechanisms, but do not address the management of conflicts.


                           Fig. 10
                            gives an overview of the various exchanges and interactions between the components of the architecture, from the physical measurement on a sensor, to the contextualization (the dynamic specification) of data within the “Information System” (IS). These exchanges are explained now in the two following Sections 4.2.2.1 and 4.2.2.2. Partitioning-related messages are not reported here.

The primary function of the mobile collector is to collect the measurements carried out by all of the nodes. As mentioned earlier, rather than to ask all sensors, the collector visits a cluster head which is representative of an oil slick. The production of this measurement is described by the “enhanced” state diagram of a sensor given by Fig. 11
                              . The yellow states (ordinary, head, member1 and member2) correspond to the clustering process (see Fig. 4). For the last three, the sensor measures periodically (period τ) and emits a measure data (d event) to its cluster head. To reduce the consumption of resources (memory and CPU) and thus to reduce the energy consumption, the processing (function updateData()) of received data (d event) is limited to storing a list of the members of the cluster sensors {Gi}, the surface of the cluster (Pos (CH) and Pos (Cmk)) and to the calculation of an aggregated data (for example D
                              avg if the head performs a preprocessing on the measured data in calculating the average). This aggregation introduces a loss of context since the cluster (slick) is dynamic.

At the beginning of a cycle (startCycle()), the collector moves (move()), and sends a connect() message to a cluster head to initiate a session in order to retrieve collected data. Then, it sends a S_get-data() to which the head responds with the aggregated data of its cluster (D
                              avg). Then, the collector requests the context of the cluster with the message S_get-context(). The head thus returns {Gi}, Pos (CH) and Pos (Cmk), which ends the session between the collector and the cluster. The last received message allows the collector to run (via the updateSessions() function) the inheritance tests which have been defined above, and thus to recover the evolution of the cluster and identify the corresponding loss of context. This sequence is repeated by the collector for all the cluster heads (Fig. 12
                              ).

Finally, the collector will thus have a view of the dynamics of the network and will update its trajectory to reach the sufficiently representative groups. This trajectory may be planned as in [23] or [24].

The session layer is designed to provide to the collector and the “Information System” the means for the synchronization of their dialogue and the contextualization of information. This requires the establishment of a session connection and of the scheduling of data exchanges. At each cycle, the collector initiates a S_connect() message. The IS responds favourably with an accept() message. The collector sets (synchronization) recovery points of the update of the data (message S_sync-major(t)). The recovery interval is not necessarily periodic, and the shorter the cycle, the more a «continuous» connectivity will be approached. The connection will be closed by a message (disconnect) of the IS, after the collector has requested a disconnection S_finish().

For each group for which the collector has recovered information, an activity that corresponds to a local synchronization is initiated. Three types of activities are defined. The first is representative of the emergence of a new slick, and so a new group. When receiving a message S_session-start(), the IS creates (create()) in its local database a new session, and returns its identifier (sei) to the collector. This identifier allows it to associate data and context (S_data() message) before suspending the session by a message S_session-interrupt(). A suspended session will be resumed following the reception of a message S_session-resume() as shown in Fig. 13
                              .

This way, the collector will update the attributes of the session (message S_data()), which will be suspended until the next cycle. During this activity, the inheritance relationships obtained by comparison between two major synchronization points (between two cycles), are marked. Finally, given the mobility of slicks, and their splits or mergings, the collector may request (message S_session-end ()) the suppression of a session. In this case, the IS will remove the associated object (discard()) before confirming its deletion (message ack).

Session exchanges are asynchronous regarding the measurement cycles and the self-organization (clustering) of the network. They are raised after the visit by the collector of the area to monitor, and they achieve for the IS a discreet connectivity. Indeed, this protocol allows for each image of the oil spill (obtained at each cycle), some relationships with the previous images. There will thus be a spatial representativeness (position and size of the group) and also a temporal representativeness (relationships between the groups). This latter will be used to predict the slicks deviation, and so, the collector trajectory.

Numerous strategies can be envisaged, such those proposed in [7,8] or gathered in the surveys written by [9,25] about distributed mobile sink routing in wireless sensor networks. The following seems to be suitable for our specific very dynamic application:

Initially (at the beginning of the disaster), when all nodes are concentrated in a single slick, the collector could follow a spiral path in order to detect the cluster heads and collect their locations from which it will compute the next trajectory. Then, in the steady state, it could update the following visit by using a predictive method (an Ambrosini method for example) which takes into account the knowledge of the last information system instances S(k), S(k
                        −1), … S(0) (position of the cluster heads and their assumed motions regarding the weather conditions such as the wind speed and direction, ocean currents…). Then the minimal Hamiltonian path can be calculated (thanks to an appropriate heuristic) in order to visit all these cluster heads (exactly once). The uncertainty of the prediction should be commensurate with the range of the cluster heads.

To demonstrate the good behavior of the proposed protocol, we have run simulations under the network simulation Riverbed Opnet Modeler environment. The objective is to evaluate the protocol regarding three metrics: the number of sessions, the number of out-session nodes, and the number of new sessions between two visits of the collector. Results are also analyzed regarding performances obtain without the session protocol.
                        
                           –
                           the number of sessions is the number of significant clusters to visit. Any cluster of at least n members is a session

the number of out-session nodes enables us to estimate the static aspect of our network at a given time, and therefore the ability to cover the entire area to monitor. The lower it is, the closer the observation is to reality.

the number of new sessions between two visits of the collector enables us to estimate the dynamic aspect of the network. The lower it is, the more accurate the monitoring of the oil-spill evolution is, and therefore the prediction of the future positions of the cluster heads is better. This will make the planning of the future collector trajectory easier.

During the simulation, we will vary the number of nodes for a session to be representative (n), the nodes speed, and the ξ parameter that represents the variation of the number of defectors around the minimum size to form a group. Simulation also will be done for several network topologies (total number of nodes and monitored area surface).

In order to have reasonable simulations computing time, the observed area and the number of nodes are limited. In the same way, the visiting period is reduced in order to make the simulation shorter. Regarding the speeds, and just to have an idea, a 40km/h wind induces a 0.2m/s nodes speed on the slicks which can move up to 1m/s due to ocean currents. A “Random Waypoint” mobility model is used again. At the beginning of the simulation, all nodes are concentrated in a corner of the square monitored area. The parameters considered for the simulation are gathered in the following table:
                           
                              
                                 
                                 
                                 
                                    
                                       Parameters
                                       Values
                                    
                                 
                                 
                                    
                                       MAC layer protocol
                                       Non-beaconed IEEE 802.15.4
                                    
                                    
                                       Transmission range
                                       50m
                                    
                                    
                                       Mobility model
                                       Random Waypoint
                                    
                                    
                                       Monitored area (m)
                                       350×350 and 625×625
                                    
                                    
                                       Nodes number
                                       100 and 500
                                    
                                    
                                       Clustering weight α
                                       
                                          
                                             
                                                0.5
                                             
                                          
                                       
                                    
                                    
                                       Simulation duration
                                       300s
                                    
                                    
                                       Seeds
                                       30
                                    
                                    
                                       
                                          Hello messages period
                                       1s
                                    
                                    
                                       Collector visiting period
                                       5s
                                    
                                    
                                       Minimal session size (n)
                                       10, 25 and 50 nodes
                                    
                                    
                                       Nodes speed (V)
                                       1 and 2m/s
                                    
                                    
                                       
                                          ξ
                                       
                                       50%, 100%, 150% and 200%
                                    
                                    
                                       Number of simulations
                                       2×2×4×3×2×30=2880
                                    
                                 
                              
                           
                        
                     


                        Fig. 14
                         shows the evolution of the number of sessions, at a nodes speed V
                        =1m/s (left column) and V
                        =2m/s (right column) for several values of the number n 
                        
                           
                              (
                              n
                              ∈
                              {
                              10
                              ,
                              25
                              ,
                              50
                              }
                              )
                           
                        . It gives also the number of clusters that will be visited by the collector when the session protocol is not implemented (curves number of clusters). This Fig. 14 highlights that the session protocol enables to significantly reduce the number of points that the collector would have to visit. For instance (lower left graph) for n
                        =10, when the number of clusters is in average of 6 after 1min, less than two sessions would provide a significant subset of the information system. After three minutes, the ratio is 36 clusters to 7 sessions. It can be noticed that the higher the value of n, the smaller the number of sessions.

These curves were obtained with ξ
                        =100%. They do not change if we take successively ξ
                        =50%, 150%, or 200%. This parameter has no effect on the number of sessions. Regarding the nodes speed, the profile of the curves remains identical for V
                        =2m/s. For n
                        =10, the number of sessions remains less than 15 whereas the number of clusters is around 90 at the end of the simulations (lower right graph). At this time, the nodes are highly scattered such that according to the threshold n, the physical phenomenon to observe may be considered as finished.

If we compare Fig. 14a and c or b and d, it can be noticed that the more the number of nodes, the more the number of sessions. If we compare now Fig. 14a and b or c and d, we remark that the more the monitored surface, the less the number of sessions. Furthermore, the number of nodes and the monitored surface do not seem to have an influence on the performance of the protocol, since the profile of the curves remains similar. Note that for a small number of nodes and large sessions (n
                        =50) the observation stops earlier. In fact, the number of sessions decreases when the speed and the network area are increasing, because the nodes density decreases faster, and thus, the threshold of nodes rejection n is reached faster too. So, n has to be set regarding the density of the network.


                        Fig. 15
                         shows the evolution of the number of out-session nodes at a nodes speed V
                        =1m/s, for different values of the number n 
                           
                              (
                              n
                              ∈
                              {
                              10
                              ,
                              25
                              ,
                              50
                              }
                              )
                           
                         and for two different numbers of nodes. It is important to note here that the number of out-session nodes takes only into consideration the number of nodes that belongs to a too small cluster to be considered as a session. When the session protocol is implemented, the total number of nodes for which the measure will not be collected, is obtained by summing the number of out-session nodes with the number of out-cluster nodes. When the protocol is not implemented, only out-cluster nodes are considered.

It can be noticed that the higher the value of n, the higher the number of out-session nodes, because in seeking “large” sessions, many “small” clusters are neglected. Even if the monitoring seems less accurate when n grows compared to the number of out-cluster nodes, it is important to remember that the objective is to maintain an informationally significant subset which depends on the clusters sizes, and not necessary the connectivity with all nodes. Furthermore, for a small number of nodes, a great n leads to 100% of out-session nodes. Once again, a compromise has to be found between n (the user expected observation accuracy) and the observation frequency.

These curves were obtained with ξ
                        =100%. They do not change if we take successively ξ
                        =50%, 150%, or 200%. This parameter has no effect on the number of out-session nodes. For V
                        =2m/s, the profile of the curves is identical.


                        Fig. 16
                         presents the evolution of the number of new sessions, at a nodes speed V
                        =1m/s, for several values of the number n 
                           
                              (
                              n
                              ∈
                              {
                              10
                              ,
                              25
                              ,
                              50
                              }
                              )
                           
                        . At low speed, and for all values of ξ (100% in Fig. 16), the curves do not identify a trend to decide on the influence of the parameters.

On the other hand, at high speed curves are more expressive and influenced by the parameter ξ. Fig. 17
                         present the evolution of the number of new sessions, at a nodes speed V
                        =2m/s, respectively for ξ
                        =50%, 100%, 150%, and 200%, for different values of the number n 
                           
                              (
                              n
                              ∈
                              {
                              10
                              ,
                              25
                              ,
                              50
                              }
                              )
                           
                        , and for two different numbers of nodes, and two monitored area surfaces.

Remember that ξ represents the variation of the number of defectors around the minimum size to form a group. For ξ values equal to 50% and 100%, the number of new created sessions increases for small values of n and decreases for high values of n. That is the expected result, that is to say a low loss of context, enabling the collector to find “known” sessions from one visit to the next. For high values of ξ (150% and 200%), we can notice that the number of new sessions decreases with time, even for high values of n, but faster than previously, due to the amplifier character of ξ for the inheritance of more and more small oil slicks.

Concerning the influence of the number of nodes and of the surface, the curves remain similar, since it is a percentage around the number n of nodes to form a group, regardless to the nodes density.

@&#DISCUSSION@&#

We have demonstrated that the higher the value of n, the more the number of out-session nodes increases, which we want to avoid, since the gap between the real and the measured worlds increases because large part of the WSN capability is not taken into account.

We have shown that when ξ is small, the number of new sessions tends to increase, which we still want to avoid, since they represent a loss of context, and therefore a difficulty for the collector trajectory planning at each of its “tours”. Since a group only inherits if its size satisfies 
                        
                           g
                           ⩾
                           ξ
                           .
                           n
                        
                     , a compromise has to be found between the static monitoring of the physical phenomenon carried out by n, and the monitoring of the dynamics of this same phenomenon carried out by ξ.

To deal with this contradiction, the information system operator must not only supply the simulator with parameters corresponding to the specific situation to monitor (size of the oil spill, weather, etc.), but also refine its requirements in terms of observation accuracy (size of smallest slick you want to observe), percentage of the total number of nodes in the network whose measurements have to be taken into account, and so on (density of nodes, etc.). This operator has finally to define the periods of visit, the tolerance to the amount of non-contextualized information, etc. All these prior settings will enable to find by simulation the optimum values of n and ξ for a given disaster.

Another advantage of the session protocol is to maintain relations between two collector cycles. In fact, the minor synchronization points (introduced in Fig. 9) enables to retrieve faster an information subset that satisfies the threshold level, and hence to stop the collector trajectory. The shorter the trajectory is, the lower the connectivity loss is, due to the discrete observation. This point is shown in Fig. 18
                     .

The area represented by the nodes (the surface of the physical phenomenon interesting to observe) either belonging to all the clusters or only belonging to sessions is given. Without sessions, it continuously grows to cover the whole monitored area (625×625=390,625m2). By implementing the session protocol, it decreases when the dispersion becomes significant, enabling the collector to focus only on the highest density zones. Its trajectory is thus reduced.

@&#CONCLUSION@&#

To our knowledge, this proposal is quite original and is a real novelty in the field of sensor networks. It is distinguished from the work on the datamules, or on the DTN (Delay Tolerant Network). Indeed, beyond the data collection, it takes into account the informational context we seek to preserve during the successive visits of the collector. Future work should focus on:
                        
                           –
                           the study of the energy consumption of our session protocol which must remain reasonable, because it is partly implemented on limited capacity nodes;

the use of a transmission power control of nodes for the clustering, taking into account the optimal coverage of the monitored area ;

the use of realistic mobility models separately incorporating mobility of the group (slicks) and individual mobility (nodes);

the simultaneous deployment of several mobile collectors.

@&#REFERENCES@&#

