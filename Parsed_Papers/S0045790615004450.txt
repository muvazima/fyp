@&#MAIN-TITLE@&#An efficient method for ECG beat classification and correction of ectopic beats

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A method based on radial basis function system for cancelling out ectopic beat by classification between normal and abnormal beats is proposed.


                        
                        
                           
                           The proposed solution addresses for ECG recordings.


                        
                        
                           
                           Several experiments have demonstrated the enhancement of the proposed method in comparison to other techniques.


                        
                        
                           
                           The results suggest that clinical information can be maintained.


                        
                        
                           
                           This method provides the best approach for obtaining both ectopic beat reduction and low distortion of the signal recordings.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

ECG

Beat classification

Ectopic beat

Radial Basic function

Classification

@&#ABSTRACT@&#


               
               
                  The analysis of the surface Electrocardiogram (ECG) is the most extended non-invasive technique in cardiological diagnosis. The ectopic beats are heart beats remarkably different to the normal beat morphology that provoke serious disturbances in electrocardiographic analysis. These beats are very common in atrial fibrillation (AF), causing important residua when ventricular activity has to be removed for atrial activity (AA) analysis. These beats may occur in both normal subjects and patients with heart disease, and their presence represents an important source of error which must be handled before any other analysis. In this work, a method is proposed to cancel out ectopics by classification between normal and abnormal beats. The systems is based on Radial Basis Function Neural Network (RBFNN). This new approach is compared to state-of-the-art techniques for the ectopic classification and cancellation in the MIT database. The results clearly demonstrated the improved ECG beats classification accuracy compared with other alternatives and a very accurate reduction of ectopic beats together with low distortion of the QRST complex.
               
            

@&#INTRODUCTION@&#

The analysis of Electrocardiogram (ECG) signal provides a non-invasive and reasonably priced technique to investigate the heart function for the different cardiac conditions. The main problem in heart disease diagnosis using ECG is that the normal ECG may differ for each person and sometimes one type of disease shows distinct ECG morphologies in different patients ECG signals. Also, two dissimilar diseases may have approximately the same effects on normal ECG signals. These problems complicate the heart disease diagnosis. In view of the high mortality rate of heart diseases, faithful detection and classification of ECG arrhythmias is essential for the treatment of patient in the clinics. Therefore, computer-based analysis and classification of ECG signal signifies an expert way to detect and treat different kinds of cardiac diseases [1].

The presence of ventricular ectopic beats in the electrocardiogram is a sign of disturbance of the depolarization process, disorganizing the ventricles blood pumping function and preceding, in many cases, malignant cardiac arrhythmias. Although this sign of decreased heart function is helpful in the prediction of life-threatening arrhythmias, such as ventricular fibrillation or tachycardia, its presence makes difficult the study of other cardiac diseases from the ECG. To this respect, the presence of ectopic beats perturbs the impulse pattern initiated by the sinoatrial node and implies that RR intervals cannot be used for heart rate variability (HRV) analysis, which is a tool commonly used in the evaluation of the autonomic nervous system. Similarly, ectopics are a frequent and unsolved problem in atrial fibrillation (AF) longtime analysis, thus turning useless a considerable number of AF recordings that, otherwise, could be enrolled in any kind of study [1].

In the last decades, the application of mathematical models and statistical analyzes for better interpretation of the physiologic cardiac events has offered many advantageous solutions for fast automatic recognition of ventricular ectopic beats. ECG recording is also used as a tool for the analysis of Atrial Fibrillation (AF), where it is needed to separate the Atrial Activity (AA) from other cardioelectric signals and the ectopic beats are one common problem for that extraction. In this regard some of the most popular methods are based on assessment of the QRS complex as the most characteristic wave in ECG. Classical techniques extract heuristic ECG descriptors, such as the QRS morphology [2–6], ECG beat classification [7,8] and interbeat RR intervals [3,9]. Other ECG descriptors rely on QRS frequency components calculated either by Fourier and Wavelet transform [10,11]. More sophisticated methods apply QRS template matching procedures, based on different transforms, e.g., Karhunen–Loève transform [12], techniques based on average beat subtraction (ABS) [13] and Matching Pursuits [14], to approximate the variety of temporal and frequency characteristics of the QRS complex waveforms. Other techniques for computerized arrhythmia detection employ cross-correlation with predefined ECG templates to identify markers for the individual wave components in one cardiac cycle [15]. Although, some of the cited studies have proved the individual advantage of using ECG templates based mainly on sophisticated mathematical transforms, other studies have emphasized the particular benefit of a number of heuristic QRS features [16].

Artificial neural networks (ANNs) are a kind of powerful methods that have been applied to many areas with success such as adaptive control, pattern classification, medical research, etc. [17–23]. One of the common approaches in ECG beat classification is ANNs that have shown accurate performance in different classification tasks. Among ANNs, Multi-Layer Perceptrons (MLPs) [24] and Radial Basis Function (RBF) [9,25] networks have been of considerable interest. Combining neural classifiers is one approach to improving the classification performance, particularly for complex problems. RBF networks are much easier to be designed and trained than neural networks. From the point of generalization, RBF networks can respond well for patterns which are not used for training. The RBF neural networks can approximate any continuous function defined on a compact set to any prescribed degree of accuracy by sufficiently expanding the networks structure [19]. The idea behind combinations is the so-called divide-and-conquer principle, according to which a complex computational task is solved by dividing it into a number of computationally simple tasks and then combining the solutions of those tasks [17,20,26]. In this paper, we present a method for ectopic beat classification and suppression using a RBF. This RBF network has been developed like hierarchically layered structure. It starts with a small number of RBF and then adds new RBF if the approximation error is larger than some predetermined threshold. They were applied on the large collection of morphological QRS descriptors used by Christov [2]. We have tested the performance of the defined classification methods for two classes, which feature with particular QRS behavior (class 1: NB, PVC, LBBB, RBBB, PB and class 2: EB), as well as independence of the content and the size of the learning set. Although EB cancellation may remove relevant medical information, this work is focused on the analysis of atrial fibrillation recordings, where the target signal is the atrial activity. As a consequence, normal and ectopic ventricular activity will be sooner or later removed.

The paper is organized as follows: Section 2 introduces the materials used in this study. Section 3, presents our proposed approach. The description of the experiments and the discussion of the results are given in Section 4, respectively. Finally, the conclusions of this paper are summarized in Section 5.

The study involved all ECG recordings from PhysioNet Database (MIT-BIH Atrial Fibrillation Database, Long-Term AF Database, MIT-BIH Arrhythmia Database, AF Termination Challenge Database, MIT-BIH Normal Sinus Rhythm Database, St. Petersburg Institute of Cardiological Technics 12-lead Arrhythmia Database, Normal Sinus Rhythm RR Interval Database.) [27]. The sampling frequency is 360 Hz and the resolution is 200 samples per mV. All heartbeats were recognized by the fiducial points in the databases and the original databases’ annotations were accepted. This study also used simulated signals. These signals were created through the combination of normal sinus rhythm ECGs, containing ventricular ectopics, with AA segments extracted MIT-BIH arrhythmia database (MITDB). ECG recordings were obtained from lead V1 of patients with different cardiac diseases collected from all of the European ST-T database (EDB) and the PhysioNet Database [27]. We defined two groups of heartbeats: (i) Group 1 ‘NVBs’ for beats NB, PVC, LBBB, RBBB and PB, (ii) Group 2 ‘EVBs’ for ectopic beats.

Before the ECG analysis we applied some preprocessing filters to the input ECG signal in order to prevent against artifacts that might impede the accurate measurements and classification of the heartbeats [1,28,29]. All these signals have been classified in three groups. 40% random signals have been chosen to integrate the first group, which have been employed in network training. The second group (25%) has helped to validate the proper neural working. And the third group (35%) has helped to compare ANN.

@&#METHOD@&#

ANNs are a type of non-linear processing system ideally suited to a wide range of tasks, especially those in which there is no existing algorithm for task completion. ANNs can be trained to solve certain problems using a learning method and sample data [17,20,26]. In this way, identically constructed ANN can be used to perform different tasks based on the training received. With proper training, ANNs are capable of generalization, the recognition of similarities among different input patterns, especially patterns corrupted by noise [17]. Training is the development of increasing networks in which nodes are systematically added in the hidden layer during the learning process [20,30].

RBF neural networks are function approximation models that can be trained by means of examples to implement a desired input–output mapping [26]. In fact, RBF models are closely related to function approximation models used to perform interpolation [20]. Under certain mild conditions, RBF neural networks are capable of approximating arbitrarily well any function [19].

The proposed RBF network in the present work has a hierarchically layered structure. It starts with a small number of RBFs and then adds new RBFs if the approximation error is larger than some predetermined threshold and there is no existing RBF that can efficiently represent the current input. Moreover, some of the existing RBFs can be removed if the approximation error is small and other conditions still are satisfied [19]. In this study, different types of RBFs have been employed to develop the proposed noise cancellation. The implementations using Gaussian RBF (GRBF) and raised-cosine RBF (RCRBF) are discussed and compared. Although the GRBF network possesses the property of universal approximation, the network’s training and output evaluation are still time consuming. This is because the GRBF has the unbounded support and thus each RBF has non-zero output over the whole input space. On the other hand, the RCRBF is proposed because of its compact support [31]. The property of compact support enables much faster network training and output evaluation as the complexity of the network and the dimensionality of the input space increase [25].

The performance of a proposed RBF neural network depends on the number and centres of the radial basis functions, their shapes, and the method used for learning the input–output mapping [19]. One characteristic of these functions is that any function can be approximated by a linear combination of radial basis functions (i.e. f(x) ≈ ∑wiξj
                        (x)). Then, it’s possible to do a linear combination of this type of data that approximates the function that generated these data. To achieve this approach, this study uses a regression where several radial basis functions have been used [25,32,33].

In this section we present the proposed RBF initialization and training strategies used in this paper. In the classification scenario a proposed neural network performs a mapping from a continuous input space 
                           
                              X
                              (
                              =
                              
                                 R
                                 d
                              
                              )
                           
                         into a finite set of classes 
                           
                              Y
                              =
                              {
                              
                                 w
                                 1
                              
                              ,
                              .
                              .
                              .
                              
                                 w
                                 t
                              
                              }
                           
                         . In our neural network we have created two clases, which feature with particular QRS behavior (class 1: NB, PVC, LBBB, RBBB, PB and class 2: EB). In the training phase the parameters of the network are determined from a finite training set: 
                           
                              S
                              =
                              {
                              
                                 (
                                 
                                    x
                                    μ
                                 
                                 ,
                                 
                                    w
                                    μ
                                 
                                 )
                              
                              
                              μ
                              =
                              1
                              ,
                              .
                              .
                              .
                              N
                              }
                              ,
                           
                         each feature vector xμ
                         ∈ 
                           
                              R
                              d
                           
                         is labeled with its class membership wμ
                         ∈ Y . In the recall phase further unlabeled observations x ∈ 
                           
                              R
                              d
                           
                         are presented to the network which estimates their class membership w.

Regarding the two aforesaid different implementations of RBFs, the GRBF is characterized by the following activation function:

                           
                              (1)
                              
                                 
                                    
                                       ϕ
                                       j
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    exp
                                    
                                       (
                                       −
                                       
                                          
                                             
                                                ∥
                                                x
                                                
                                                   (
                                                   t
                                                   )
                                                
                                                −
                                                
                                                   c
                                                   j
                                                
                                                
                                                   (
                                                   t
                                                   )
                                                
                                                ∥
                                             
                                             2
                                          
                                          
                                             2
                                             
                                                σ
                                                2
                                             
                                          
                                       
                                       )
                                    
                                    ,
                                 
                              
                           
                        
                     

whereas the RCRBF is a compact support RBF given by

                           
                              (2)
                              
                                 
                                    
                                       ϕ
                                       j
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         1
                                                         2
                                                      
                                                      
                                                         (
                                                         1
                                                         +
                                                         cos
                                                         
                                                            (
                                                            
                                                               
                                                                  
                                                                     π
                                                                     (
                                                                     x
                                                                     
                                                                        (
                                                                        t
                                                                        )
                                                                     
                                                                     −
                                                                     
                                                                        c
                                                                        j
                                                                     
                                                                     
                                                                        (
                                                                        t
                                                                        )
                                                                     
                                                                     )
                                                                  
                                                                  
                                                                     σ
                                                                     (
                                                                     t
                                                                     )
                                                                  
                                                               
                                                            
                                                            )
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   i
                                                   f
                                                   
                                                   
                                                   
                                                      |
                                                      x
                                                      (
                                                      t
                                                      )
                                                      |
                                                   
                                                   ≤
                                                   σ
                                                   
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                             
                                          
                                          
                                             
                                                0
                                             
                                             
                                                
                                                   i
                                                   f
                                                   
                                                   
                                                   
                                                      |
                                                      x
                                                      (
                                                      t
                                                      )
                                                      |
                                                   
                                                   >
                                                   σ
                                                   
                                                      (
                                                      t
                                                      )
                                                   
                                                
                                             
                                          
                                       
                                       }
                                    
                                    ,
                                 
                              
                           
                        where 
                           
                              x
                              
                                 (
                                 t
                                 )
                              
                              =
                              
                                 
                                    [
                                    x
                                    
                                       (
                                       t
                                       )
                                    
                                    ,
                                    x
                                    
                                       (
                                       t
                                       −
                                       1
                                       )
                                    
                                    ,
                                    …
                                    ,
                                    x
                                    
                                       (
                                       t
                                       −
                                       
                                          N
                                          0
                                       
                                       +
                                       1
                                       )
                                    
                                    ]
                                 
                                 T
                              
                           
                         is the vector of the input nodes and cj
                        (t) the center in the kth hidden node. In addition, σ(t) represents the width of the centres and can be defined as the variance of the input vector, ‖.‖ denotes the Euclidean norm. The proposed RBF neural network mapping with M basis functions is then:

                           
                              (3)
                              
                                 
                                    
                                       y
                                       k
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    =
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          M
                                       
                                    
                                    
                                       w
                                       
                                          k
                                          j
                                       
                                    
                                    
                                       ϕ
                                       j
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    +
                                    
                                       w
                                       
                                          k
                                          0
                                       
                                    
                                 
                              
                           
                        where the w
                        
                           k0 denote the bias, which may be absorbed into the summation by including an extra basis function ϕ
                        0 whose activation is set equal to 1. This mapping can be represented as the network diagram of Fig. 1
                         with the radial basis functions in the hidden layer and linear summation on the output layer. In our classification scenario the number of output units corresponds to the number of classes (1 of coding). Categorization is performed by assigning the input vector x the class of the output unit with maximum activation.

Normally, in a two-stage training approach for RBF neural networks, the kernel function centres are determined by clustering approach. The popular clustering techniques is FCM, which belong to unsupervised clustering approaches on the basis of computing distance. FCM is a data clustering technique in which each data point belongs to a cluster, providing a method that shows how to group the data that populate multidimensional space into a specific number of different clusters. It starts with a set of initial guesses for cluster centres, which are intended to mark the mean location of each cluster. With these initial cluster centres, it assigns every data point a membership grade to each cluster. By iteratively updating the cluster centres as well as the membership grades for each data point, FCM moves the cluster centres to the right location within the data set [17,20,26]. In this paper, based on FCM, a fuzzy clustering method is implemented.

The number of hidden layer neurons is a major problem for neural networks, also a matter for experimentation. For some clustering methods, including FCM, the number of clusters needs to be given in advance. Until now there are two main options: validity measures and compatible clustering merging. In the former one, samples must be clustered several times, each time with a different number of clusters, 
                              
                                 k
                                 ∈
                                 [
                                 2
                                 ,
                                 n
                                 ]
                              
                           . The latter one starts with a large number of clusters, then proceeding by gradually merging similar clusters to obtain fewer clusters. Here k should be large enough so that the nonlinearity of system could be captured accurately. However, cluster number essentially depends on nonlinear extent of given data sample. When lacking of enough prior knowledge, trial and error method is usually used to choose proper value step by step, therefore, the computation burden is undoubtedly aggravated.

In this paper, based on FCM, a fuzzy clustering approach is adopted, where we can specify the range of hidden layer neurons. Let 
                              
                                 
                                    x
                                    i
                                 
                                 ∈
                                 R
                              
                            be the data of patterns represented in feature space. Start cluster number at 
                              
                                 k
                                 =
                                 n
                                 /
                                 2
                                 ,
                              
                            then judge whether new centre should be added according to network performance. If the result is not satisfactory, choosing a new cluster centre 
                              
                                 c
                                 
                                    k
                                    +
                                    1
                                 
                              
                            from the remaining samples which is different from the existed ones [c
                           1, c
                           2,…ck
                           ]. Update membership matrix, start algorithm with new centres. Repeat the above steps until satisfactory result or maximum neuron k < n is reached. Here this cluster range is an experience value.

The FCM algorithm performs clustering by solving

                              
                                 (4)
                                 
                                    
                                       M
                                       i
                                       n
                                       .
                                       
                                          J
                                          m
                                       
                                       
                                          (
                                          u
                                          ,
                                          c
                                          ,
                                          x
                                          )
                                       
                                       =
                                       
                                          ∑
                                          
                                             i
                                             =
                                             1
                                          
                                          n
                                       
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          k
                                       
                                       
                                          u
                                          
                                             j
                                             i
                                          
                                          m
                                       
                                       
                                          
                                             ∥
                                             
                                                x
                                                i
                                             
                                             −
                                             
                                                c
                                                j
                                             
                                             ∥
                                          
                                          
                                             2
                                          
                                          2
                                       
                                    
                                 
                              
                           
                           
                              
                                 (5)
                                 
                                    
                                       
                                          
                                             
                                                u
                                                =
                                                [
                                                u
                                                j
                                                i
                                                ]
                                                ,
                                                u
                                                j
                                                i
                                                ∈
                                                [
                                                0
                                                ,
                                                1
                                                ]
                                             
                                          
                                          
                                       
                                       
                                          
                                             
                                                
                                                   ∑
                                                   
                                                      j
                                                      =
                                                      1
                                                   
                                                   k
                                                
                                                
                                                   u
                                                   
                                                      j
                                                      i
                                                   
                                                
                                                =
                                                1
                                                ,
                                                
                                                   ∑
                                                   
                                                      i
                                                      =
                                                      1
                                                   
                                                   n
                                                
                                                
                                                   u
                                                   
                                                      j
                                                      i
                                                   
                                                
                                                >
                                                0
                                                ,
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         i
                                                         =
                                                         1
                                                         ,
                                                         2
                                                         ,
                                                         …
                                                         ,
                                                         n
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         j
                                                         =
                                                         1
                                                         ,
                                                         2
                                                         ,
                                                         …
                                                         ,
                                                         k
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Step 1) For given data set, fix k ∈ [n/2, n]; admissible error ε > 0; initial cluster centre c
                           0; fuzzification constant m, which denotes the degree of fuzzification (1 < m < ∞). If m → 1, the membership degrees of any pattern to any cluster tend to be either 0 or 1, and approaches hard c-means; on the other hand; if m → ∞, the membership degrees of any pattern to any cluster tend to be equal to 1/k , thus producing the highest level of fuzziness. Although no theoretically optimal value has been determined, the most common choice is 
                              
                                 m
                                 =
                                 2
                              
                           .

Step 2) Calculate 
                              
                                 u
                                 
                                    (
                                    t
                                    )
                                 
                                 =
                                 
                                    [
                                    
                                       u
                                       
                                          j
                                          i
                                       
                                    
                                    
                                       (
                                       t
                                       )
                                    
                                    ]
                                 
                              
                           . uji
                           (t) is the membership value of vector xi
                            to clusters centre cj
                           ; 
                              
                                 
                                    d
                                    
                                       j
                                       i
                                    
                                 
                                 =
                                 
                                    
                                       ∥
                                       
                                          x
                                          i
                                       
                                       −
                                       
                                          c
                                          j
                                       
                                       ∥
                                    
                                    2
                                 
                              
                            is the Euclidean distance between xi
                            and cj
                           :

                              
                                 (6)
                                 
                                    
                                       
                                          u
                                          
                                             j
                                             i
                                          
                                       
                                       
                                          (
                                          t
                                          )
                                       
                                       =
                                       
                                          1
                                          
                                             
                                                ∑
                                                
                                                   r
                                                   =
                                                   1
                                                
                                                k
                                             
                                             
                                                {
                                                
                                                   
                                                      [
                                                      
                                                         
                                                            
                                                               d
                                                               
                                                                  j
                                                                  i
                                                               
                                                            
                                                            
                                                               (
                                                               t
                                                               −
                                                               1
                                                               )
                                                            
                                                         
                                                         
                                                            
                                                               d
                                                               
                                                                  r
                                                                  i
                                                               
                                                            
                                                            
                                                               (
                                                               t
                                                               −
                                                               1
                                                               )
                                                            
                                                         
                                                      
                                                      ]
                                                   
                                                   
                                                      2
                                                      
                                                         m
                                                         −
                                                         1
                                                      
                                                   
                                                
                                                }
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Step 3) Calculate c(t). And 
                              
                                 c
                                 
                                    (
                                    t
                                    )
                                 
                                 =
                                 
                                    [
                                    
                                       c
                                       1
                                    
                                    ,
                                    
                                       c
                                       2
                                    
                                    ,
                                    .
                                    .
                                    .
                                    
                                       c
                                       k
                                    
                                    ]
                                 
                              
                            is the array of clusters centres; for ∀j
                           
                              
                                 (7)
                                 
                                    
                                       
                                          c
                                          j
                                       
                                       
                                          (
                                          t
                                          )
                                       
                                       =
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   [
                                                   
                                                      u
                                                      
                                                         j
                                                         i
                                                      
                                                   
                                                   
                                                      (
                                                      t
                                                      )
                                                   
                                                   ]
                                                
                                                m
                                             
                                             
                                                x
                                                i
                                             
                                          
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   [
                                                   
                                                      u
                                                      
                                                         j
                                                         i
                                                      
                                                   
                                                   
                                                      (
                                                      t
                                                      )
                                                   
                                                   ]
                                                
                                                m
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

Step 4) If maximum of iterations is reached or stop criterion 
                              
                                 
                                    ∥
                                    c
                                    (
                                    t
                                    )
                                    −
                                    c
                                    (
                                    t
                                    −
                                    1
                                    )
                                    ∥
                                 
                                 ≤
                                 
                                    ɛ
                                 
                              
                            is met, then stop; otherwise, jump to step 2.

The proposed FCM algorithm for RBF neural networks can be described as follows:

Step 1: Initialization. Cluster number 
                              
                                 k
                                 ∈
                                 [
                                 k
                                 m
                                 i
                                 n
                                 ,
                                 k
                                 m
                                 a
                                 x
                                 ]
                                 ,
                              
                            cluster centre c
                           0, admissible error ε ≥ 0.

Step 2: Use FCM algorithm, calculate U(t) by using Eq. (6). And then calculate C(t) : ∀j, by using Eq. (7).

Step 3: If the stop criterion 
                              
                                 
                                    ∥
                                    C
                                    (
                                    t
                                    )
                                    −
                                    C
                                    (
                                    t
                                    −
                                    1
                                    )
                                    ∥
                                 
                                 ≤
                                 
                                    ɛ
                                 
                              
                            is met, the process of clustering stops and then goes to the next step; otherwise, let 
                              
                                 t
                                 =
                                 t
                                 +
                                 1
                                 ,
                              
                            jumps to Step 2.

Step 4: Calculate output connection weights and cluster, and save the best feasible solutions with training and validation data sets.

In order to compare the performance, the following criteria is adopted, namely root mean squared error (RMSE):

                              
                                 (8)
                                 
                                    
                                       R
                                       M
                                       S
                                       E
                                       =
                                       
                                          
                                             
                                                1
                                                n
                                             
                                             
                                                ∑
                                                
                                                   i
                                                   =
                                                   1
                                                
                                                n
                                             
                                             
                                                
                                                   (
                                                   
                                                      y
                                                      i
                                                   
                                                   −
                                                   
                                                      
                                                         y
                                                         i
                                                      
                                                      ¯
                                                   
                                                   )
                                                
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           where yi
                            is the true value, 
                              
                                 
                                    y
                                    i
                                 
                                 ¯
                              
                            is the prediction value. If RMSE cannot reach given accuracy, then 
                              
                                 k
                                 =
                                 k
                                 +
                                 1
                                 ,
                              
                            goes to Step 5; otherwise stops the algorithm and jumps to Step 6.

Step 5: According to matrix U, find new cluster centre 
                              
                                 c
                                 
                                    k
                                    +
                                    1
                                 
                              
                            by computing

                              
                                 (9)
                                 
                                    
                                       M
                                       i
                                       
                                          n
                                          t
                                       
                                       
                                          ∑
                                          
                                             1
                                             ≤
                                             i
                                             ≤
                                             j
                                             ≤
                                             k
                                             ,
                                             i
                                             ≠
                                             j
                                          
                                       
                                       
                                          (
                                          
                                             u
                                             
                                                n
                                                i
                                             
                                          
                                          −
                                          
                                             u
                                             
                                                n
                                                j
                                             
                                          
                                          )
                                       
                                    
                                 
                              
                           
                        

Then based on the new cluster centres 
                              
                                 [
                                 
                                    c
                                    1
                                 
                                 ,
                                 
                                    c
                                    2
                                 
                                 ,
                                 .
                                 .
                                 .
                                 
                                    c
                                    k
                                 
                                 ,
                                 
                                    c
                                    
                                       k
                                       +
                                       1
                                    
                                 
                                 ]
                              
                            jumps to Step 2, to calculate new U.

Step 6: Output of the results. Only the model that has the minimum RMSE value is selected as the best model.

A graphical inspection of an ECG with ectopics allows to appreciate that these disturbances. The Q-wave onset and the T-wave offset of each ectopic were located making use of a based delineator [1]. To define all the ectopic segments with the same duration, the median values of the QR (QR) and RT (RT) intervals were obtained and the Q-wave onset and T-wave offset for the kth ectopic were defined as 
                              
                                 
                                    q
                                    k
                                 
                                 =
                                 
                                    r
                                    k
                                 
                                 −
                                 
                                    
                                       Q
                                       R
                                    
                                    ¯
                                 
                              
                            and 
                              
                                 
                                    t
                                    k
                                 
                                 =
                                 
                                    r
                                    k
                                 
                                 +
                                 
                                    
                                       R
                                       T
                                    
                                    ¯
                                 
                                 ,
                              
                            respectively. Where rk
                            is the R-peak of the kth beat. The index k ranges from 1 to the number of detected ectopics and corresponds with the i positions of these abnormal beats. Hence, the kth beat could be represented by the column vector

                              
                                 (10)
                                 
                                    
                                       
                                          
                                             
                                                x
                                                k
                                             
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   [
                                                   x
                                                   
                                                      (
                                                      
                                                         q
                                                         k
                                                      
                                                      )
                                                   
                                                   
                                                   
                                                   
                                                      (
                                                      
                                                         q
                                                         k
                                                      
                                                      +
                                                      1
                                                      )
                                                   
                                                   .
                                                   .
                                                   .
                                                   x
                                                   
                                                      (
                                                      
                                                         t
                                                         k
                                                      
                                                      −
                                                      1
                                                      )
                                                   
                                                   
                                                   x
                                                   
                                                      (
                                                      
                                                         t
                                                         k
                                                      
                                                      )
                                                   
                                                   ]
                                                
                                                T
                                             
                                          
                                       
                                       
                                          
                                          
                                             =
                                          
                                          
                                             
                                                
                                                   [
                                                   
                                                      x
                                                      k
                                                   
                                                   
                                                      (
                                                      1
                                                      )
                                                   
                                                   
                                                   
                                                      x
                                                      k
                                                   
                                                   
                                                      (
                                                      2
                                                      )
                                                   
                                                   .
                                                   .
                                                   .
                                                   
                                                      x
                                                      k
                                                   
                                                   
                                                      (
                                                      L
                                                      −
                                                      1
                                                      )
                                                   
                                                   
                                                   
                                                      x
                                                      k
                                                   
                                                   
                                                      (
                                                      L
                                                      )
                                                   
                                                   ]
                                                
                                                T
                                             
                                          
                                       
                                    
                                 
                              
                           being L the number of samples.

To generate the cancellation template of a concrete ectopic beat, only the most similar N complexes to it were chosen. Similarity among ectopics was obtained in terms of the crosscorrelation index (k ), which can be defined for the kth and lth abnormal beats as

                              
                                 (11)
                                 
                                    
                                       k
                                       =
                                       
                                          
                                             E
                                             [
                                             
                                                x
                                                k
                                             
                                             
                                                x
                                                l
                                             
                                             ]
                                          
                                          
                                             
                                                σ
                                                k
                                             
                                             
                                                σ
                                                l
                                             
                                          
                                       
                                    
                                 
                              
                           being E[·] the mathematical expectation operator and k and l the corresponding standard deviations of both beats. Thus, for the kth ectopic, its more similar N beats were assembled in a matrix 
                              
                                 
                                    u
                                    k
                                 
                                 ∈
                                 
                                    R
                                    
                                       L
                                       ×
                                       N
                                    
                                 
                                 ,
                              
                            such that

                              
                                 (12)
                                 
                                    
                                       
                                          u
                                          k
                                       
                                       =
                                       
                                          [
                                          
                                             x
                                             
                                                k
                                                1
                                             
                                          
                                          ,
                                          
                                             x
                                             
                                                k
                                                2
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             x
                                             
                                                k
                                                N
                                             
                                          
                                          ]
                                       
                                    
                                 
                              
                           
                        

This vector was taken as cancellation template. Thus, the ectopic cancellation can be achieved as

                              
                                 (13)
                                 
                                    
                                       
                                          y
                                          k
                                       
                                       =
                                       
                                          x
                                          k
                                       
                                       −
                                       
                                          u
                                          k
                                       
                                    
                                 
                              
                           
                        

@&#EXPERIMENTAL RESULTS@&#

The performance of RCRBF neural networks was evaluated and compared with GRBF. Conventional radial basis function neural networks were trained by a hybrid learning scheme [19]. The centres of the RBF were determined according to an unsupervised procedure relying on the k-means algorithm. The widths of the GRBF were computed according to the nearest heuristic prototype [34]. The centres of the RBF were fixed during the supervised learning process. Radial basis function neural networks were trained by a fully supervised procedure based on gradient descent [20,34]. This procedure involved the update of the output weights and the centres {ck
                        } of the radial basis functions.

The results of these experiments are summarized in Table 1
                        , which shows the number of adaptation cycles required for training the neural networks mentioned above, and the percentage of errors produced on average by the trained neural networks on the training and testing sets. According to Table 1, RCRBF networks produced the smallest percentage of errors on both training and testing sets among all the RBF models tested in the experiments. As can be seen, RCRBF achieved smaller Etr
                         and Ets
                         to 40 radial basis function. Furthermore, the number of cycles is less than GRBF thereby improving processing time and computational complexity. These results prove that the performance of the RCRBF-based method is higher than GRBF because its ECG beat classification is more accurate.

Big O notation is used in Computer Science to describe the performance or complexity of an algorithm. Big O specifically describes the worst-case scenario, and can be used to describe the execution time required or the space used (e.g. in memory or on disk) by an algorithm [35]. Table 2
                         shows the complexity of proposed systems, where N is the number of samples used in the input system. As can be seen, the MLP system lasts longer processing time but all three systems have a growth in logarithmic time processing 
                           
                              (
                              O
                              (
                              log
                              (
                              n
                              )
                              )
                              )
                           
                        . The removal of ectopic beats is usually performed in patients with atrial fibrillation and heart rate variability. This type of analysis is usually performed offline [1].

In applications where the goal is to create a system that generalizes well in unseen examples, the problem of over-training has emerged. This arises in over-complex or over-specified systems when the capacity of the network significantly exceeds the needed free parameters. In order to avoid this problem, cross-validation technique to check the presence of over-training and select optimal parameters in order to minimize the generalization error has been used [26]. As can be observed, Fig. 2
                         shows the cross-correlation study for RCRBF, which has been selected because of its better adaptation to the problem. In this figure an optimum training point is obtained .

The performance of the studied methods was also tested on clinical data from Physionet. The performance was evaluated by estimating the ectopic beat reduction (EBR), i.e., the beat-by-beat reduction of the ectopic-peak amplitude that the algorithm under evaluation is able to achieve. Therefore, the EBR was a vector of values defined as:

                           
                              (14)
                              
                                 
                                    E
                                    B
                                    R
                                    
                                       (
                                       d
                                       B
                                       )
                                    
                                    =
                                    10
                                    log
                                    
                                       (
                                       
                                          R
                                          
                                             E
                                             C
                                             G
                                          
                                       
                                       /
                                       
                                          R
                                          
                                             E
                                             B
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        where RECG
                         is the R-peak amplitude of the original ECG, and REB
                         is the residual ectopic peak amplitude.

In this paper, we enumerated our classifier performance using the most familiar metrics: sensitivity (SE) and Specificity (SP). The techniques used to measure the performance of our classifier in each of these three areas are explained below by the following equations:

                           
                              (15)
                              
                                 
                                    S
                                    E
                                    
                                       (
                                       %
                                       )
                                    
                                    =
                                    
                                       
                                          T
                                          P
                                       
                                       
                                          T
                                          P
                                          +
                                          F
                                          N
                                       
                                    
                                    ×
                                    100
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    S
                                    P
                                    
                                       (
                                       %
                                       )
                                    
                                    =
                                    
                                       
                                          T
                                          N
                                       
                                       
                                          F
                                          P
                                          +
                                          T
                                          N
                                       
                                    
                                    ×
                                    100
                                 
                              
                           
                        where TP is the number of the true positive classifications (beats with annotation ‘V’ classified in Group 2 ‘EBs’); TN is the number of the true negative classifications (beats with annotations ‘N,’ ‘A,’ ‘S,’ ‘L,’ ‘R,’ ‘P’ classified in Group 1 ‘NBs’); FP is the number of the false positive classifications (beats with annotations ‘N,’ ‘A,’ ‘S,’ ‘L,’ ‘R,’ ‘P’ classified in Group 2 ‘EBs’); FN is the number of the false negative classifications (beats with annotation ‘V’ classified in Group 1 ‘NBs’).

The most crucial metric for determining overall system performance is usually accuracy. We defined the overall accuracy of the classifier for each file as follows:

                           
                              (17)
                              
                                 
                                    A
                                    c
                                    c
                                    u
                                    r
                                    a
                                    c
                                    y
                                    
                                       (
                                       %
                                       )
                                    
                                    =
                                    
                                       
                                          C
                                          o
                                          r
                                          r
                                          e
                                          c
                                          t
                                          l
                                          y
                                          
                                          c
                                          l
                                          a
                                          s
                                          s
                                          i
                                          f
                                          i
                                          e
                                          d
                                          
                                          s
                                          a
                                          m
                                          p
                                          l
                                          e
                                          s
                                       
                                       
                                          T
                                          o
                                          t
                                          a
                                          l
                                          
                                          n
                                          u
                                          m
                                          b
                                          e
                                          r
                                          
                                          o
                                          f
                                          
                                          s
                                          a
                                          m
                                          p
                                          l
                                          e
                                          s
                                       
                                    
                                 
                              
                           
                        
                     

@&#RESULTS AND DISCUSSIONS@&#

The rules for classification of ventricular ectopic beats were trained and tested with independent ECG databases to obtain unbiased accuracy evaluation, i.e., training and testing with different MIT database.

Classification result is shown in terms of confusion matrix of the neural network. The confusion matrix illustrating the classification results of the Multilayered Perceptron (MLP) is shown in Table 3
                     . According to Table 3, all EVB class samples (360) and all NVB class samples (799) are classified correctly and there is no misclassification in both of the classes using RBF. The classification performance was achieved with 99.79% .


                     Table 4
                      shows the comparative result of individual class sensitivities and specificity of various classifiers, trained using different number of neurons. The number of correct classification result of training and testing data using different number of neurons in hidden layer are exposed in the first half of Table 4 using back propagation network (BPN), MLP and RBF classifier. The second part of Table 4 shows the number of correct classification of individual class (EVB and NVB) as well as percentage of SE and SP of different methods. As can be appreciated, the percentage of accuracy for testing data (1160) gives the best result using RBF and BPN gives the worst result (93.10%) using 15 and 45 neurons in the hidden layer. Similarly, for training data (1545) the best result is obtained (99.87%) using RBF with (40) neurons in the hidden layer. The experimental results exhibit that RBF provides the best result that is 99.72% of SE and SP.

As can be appreciated, Tables 5
                      and 6
                      contain the calculated statistical indices for the training MIT database, including the SP values for the respective beat annotations in Group1 ‘NVBs’ and the SE values for the beats belonging to Group 2 ‘EVBs’ for simulated and real ECG signals. In this table, the classification methods based in: Estimation of morphology and RR interval features with linear discriminants classifier [3], estimation of morphology features with neural networks classifier [2] and estimation
                     
                      of morphology features with Kth nearest neighbors classifier [14] have been compared. Note that significant statistical differences between RBF and other methods are reported for all the analyzed recordings. In both cases, a similar behavior can be observed for the five analyzed methods. To this respect, a notably better performance is appreciated for the proposed algorithm in comparison with the others. Thus, it classified correctly 98.76% and 98.71% of the analyzed beats from simulated and real ECG signals, respectively. The classification rate was significantly more limited for the other methods.

Moreover, receiver operating characteristic (ROC) analysis has been applied to compare the classification ability of our networks. The ROC analysis suppresses the requirement for a threshold value by appraising the performance of the classifier over the whole range of possible values [19,20]. A plot of sensitivity versus 1-specificity is made over a range of threshold values to obtain the ROC curve. The area under the ROC curve (AROC) was used as a measure of classification performance. AROC represents the probability of correct classification for a randomly chosen pair of EV and NV beats [19,20]. This curves are displayed in Fig. 3 to compare the diagnostic ability of the five Neural network classifiers. Sensitivity, specificity, accuracy (Ac) and AROC are summarized in Tables 5 and 6. As can be observed, the RBF network provided the best classification performance with an accuracy of 98.71% (98.92% sensitivity and 98.64% specificity). An AROC of 0.98 was obtained. The performance achieved by Iliev, Krasteva and Christov method was slightly lower than that of RBF when classification accuracy is considered. An SE of 95.97%, an SP of 94.86%, an accuracy of 95.35% and an AROC of 0.95 were obtained by Iliev method, whereas Krasteva method achieved 95.21% sensitivity, 94.03% specificity, 94.35% accuracy and 0.94 AROC.

On the other hand, the proposal method has been compared with systems based in ABS. Table 7 summarizes the obtained values of EBR for ECG recording. Note that significant statistical differences between RBFNN and ABS are reported for all the analyzed recordings.

As a graphical summary, Fig. 4 shows the ectopic beat reduction corresponding to an ECG recording. As can be appreciated, the proposed method obtains a more accurate cancellation template, and maintain the remaining QRS complexes. That is because of a good ectopic beats classification and corresponding reduction.

@&#CONCLUSIONS@&#

This work has presented how the proposed method has been used for ectopic beats cancellation from ECG recordings. This was evaluated using a large dataset, which can be considered very similar to the conditions met in clinical environment. The achieved high sensitivity for Group2 ‘EVBs’ and high specificity for all annotations in Group1 ‘NVBs,’ prove that the provided parameter set could be a reliable facility for automatic recognition. The proposed method can be applied to a wide number of ECG recording situations, such as multichannel ECG or long-term holter monitoring. In all these practical cases, the ANN-based system has outperformed other methods, thus facilitating clinical analysis for medical professional use. The results have shown that proposed system is able to obtain a very accurate representation of ECG, thus providing high quality ectopic beat reduction ECG recordings. As conclusion, suffice is to say that the proposed method obtains both ectopic beats reduction and low modification of QRST complex results in comparison with other methods.

@&#ACKNOWLEDGMENTS@&#

This work was sponsored by University of Castilla-La Mancha, the Project PI10/01215 from Instituto de Salud Carlos III and Virgen de la Luz Hospital of Cuenca (Spain).

@&#REFERENCES@&#

