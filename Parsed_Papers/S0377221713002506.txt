@&#MAIN-TITLE@&#Optimal ship navigation with safety distance and realistic turn constraints

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We consider the optimal ship navigation problem in the presence of obstacles.


                        
                        
                           
                           We explicitly account for safety distance and realistic ship turn radius constraints.


                        
                        
                           
                           We present a graph theoretic solution on an appropriately weighted directed graph.


                        
                        
                           
                           Our methodology is illustrated on a merchant ship ice navigation example.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Graph theory

Shortest path

Ship navigation

Turn-radius constraint




                     A




                     ∗ algorithm

@&#ABSTRACT@&#


               
               
                  We consider the optimal ship navigation problem wherein the goal is to find the shortest path between two given coordinates in the presence of obstacles subject to safety distance and turn-radius constraints. These obstacles can be debris, rock formations, small islands, ice blocks, other ships, or even an entire coastline. We present a graph-theoretic solution on an appropriately-weighted directed graph representation of the navigation area obtained via 8-adjacency integer lattice discretization and utilization of the A
                     ∗ algorithm. We explicitly account for the following three conditions as part of the turn-radius constraints: (1) the ship’s left and right turn radii are different, (2) ship’s speed reduces while turning, and (3) the ship needs to navigate a certain minimum number of lattice edges along a straight line before making any turns. The last constraint ensures that the navigation area can be discretized at any desired resolution. Once the optimal (discrete) path is determined, we smoothen it to emulate the actual navigation of the ship. We illustrate our methodology on an ice navigation example involving a 100,000 DWT merchant ship and present a proof-of-concept by simulating the ship’s path in a full-mission ship handling simulator.
               
            

@&#INTRODUCTION@&#

Seaborne shipping is a major form of transportation that accounts for about 90% of world’s trade. As of 2011, there are more than 100,000 seagoing commercial ships in the world transporting over 8000 million tons of cargo each year (UN, 2011). As the world’s population grows and countries increase their participation in international commerce, seaborne shipping continues to expand as a low cost, acceptable risk, and environment friendly form of transportation. In this study, we consider a ship navigation problem wherein the objective is find the (time-wise) shortest path from a given starting point s to a termination point t in the presence of obstacles subject to (i) safety distance and (ii) turn-radius constraints. We define an obstacle as any region in any shape or size that the ship needs to avoid in its s
                     −
                     t voyage. These obstacles can be debris, rock formations, small islands, ice blocks, other ships, or even an entire coastline. We assume that the obstacles are static, i.e., they do not move or change shape during the ship’s navigation, and we do not take into consideration environmental effects such as winds, waves, or sea currents. Our methodology involves directed 8-adjacency integer lattice discretization of the navigation area and utilization of the A
                     ∗ algorithm on the resulting graph.

A novel aspect of our research is that we account for the following three real-world ship navigation phenomena as part of the turn-radius constraints: (1) the ship’s port (left) and starboard (right) turn radii are different, (2) ship’s speed reduces while turning, and (3) the ship needs to navigate a certain minimum number of lattice edges along a straight line before altering course. The third constraint ensures that the navigation area can be discretized at any resolution needed. These three constraints together will be referred to as the ship-turn constraints. In addition, we fully parameterize turn-radius and safety distance constraints in the following sense: (i) different (left and right) turn-radii and turn-speed can be specified based on the particular characteristics of the ship, and (ii) safety distances can be defined at the obstacle level based on the nature of the obstacle. Implementation of our methodology requires non-trivial modifications to the underlying graph in order to preserve optimality. These modifications include making certain number of copies of each vertex, defining an appropriate neighborhood structure, and assigning edge lengths accordingly. Once the optimal (discrete) path is determined, we smoothen it to emulate the actual (continuous) navigation of the ship. We illustrate our methodology on an ice navigation example in a full-mission ship handling simulator with a 100,000 DWT full-load-condition tanker ship and present a proof-of-concept by simulating the ship’s actual path. Here, DWT stands for deadweight tonnes, which is a measure of how much the tanker can carry safely including cargo, fuel, fresh water, and passengers (Gillmer, 1975).

There exists a vast amount of literature on deterministic shortest paths and ship navigation—both in continuous and discrete settings. For the most part, continuous-space studies on ship navigation involve complex differential equations and/or calculus of variation with curvature constraints. These types of approaches typically do not scale well in the presence of a large number of arbitrarily-shaped obstacles and ship-turn constraints. Existing discrete-space studies, on the other hand, impose overly simplistic turn constraints while ignoring safety distance requirements. To our knowledge, ours is the first study in the literature that accounts for safety distance and the ship-turn constraints as described above in a graph-theoretical framework that also allows for full parametrization of these constraints.

The rest of this manuscript is organized as follows: Section 2 provides an overview of previous work on ship navigation (both in continuous and discrete settings) and reviews existing studies on turn constraints. Section 3 formally defines the optimal ship navigation problem. Section 4 presents our navigation methodology in detail including the lattice discretization, modeling of the safety distance and turn constraints, and smoothing of the optimal path. Section 5 demonstrates our approach on an ice navigation example and Section 6 provides the output of a full-mission ship handling simulator. Summary, conclusions, and directions for future research are presented in Section 7. Lastly, Appendix A provides a brief overview of the A
                     ∗ and Dijkstra’s algorithms.

In many real-world applications, a challenging yet critical task is to find shortest paths for wheeled vehicles, aircrafts, and ships in different terrains subject to various operational constraints. Hence, path planning problems and deterministic shortest paths in general have been studied extensively; particularly within the fields of transportation science, operations research, artificial intelligence, and robotics. Arguably, the most commonly used shortest path methods in the literature are the Dijkstra’s Algorithm (Dijkstra, 1959) and the A
                     ∗ Algorithm (Hart et al., 1968, 1972).

Dubins’ car (Dubins, 1957) is an example of a forward-moving wheeled vehicle with a maximum turn angle. (Note that this turn angle is with respect to the vehicle’s present direction and that a maximum turn angle constraint can be converted to an equivalent minimum turn-radius constraint.) Path planning problems for Dubins’ car were primarily studied within the context of non-holonomic path planning (Bicchi et al., 1996). These types of problems are typically modeled as partial differential equation systems in continuous space and solved by numerical methods. This solution approach, however, is not effective in general due to the difficulty in incorporation of real-world physical constraints (Takei et al., 2010). The rapidly-exploring random tree (RRT) method of LaValle (1998) is an effective continuous-space algorithm for Dubins’ car that can handle a wide range of environmental constraints. However, the path obtained by the RRT method is not necessarily optimal as it is based on generation of random way-points over the course of navigation (Yang and Sukkarieh, 2008). To our knowledge, there are currently no available non-holonomic models that can be utilized for application of the RRT method for ship navigation. In addition, incorporating asymmetric left and right turn constraints as well as decreased speeds during turns into RRT seem to be rather difficult.

Ship navigation in the presence of obstacles is inherently a continuous-space problem. However, incorporation of realistic operational constraints in a continuous setting is a challenging task. Therefore, previous researches on this topic primarily focused on discretization of the navigation area in various ways. A major advantage of a discretization approach is that it allows for utilization of well-established and extremely rich machinery of graph theory and network flows. For instance, the work of Fagerholt et al. (2000) on ship navigation utilizes a visibility graph discretization where the graph is constructed only partially during the solution process for improved efficiency. The study by Lee et al. (2002), on the other hand, uses pre-specified way points for discretization and employs a modified depth-first search algorithm. Neither of these studies consider any turn or safety distance constraints.

Regarding turn constraints for ships, their incorporation in a continuous setting requires nonlinear maneuvering equations (Fang et al., 2005; Bhattacharyya and Haddara, 2006; Bakolas and Tsiotras, 2011) and is difficult in general (Hilten and Wolkenfelt, 2000). In graph-theoretical settings, generic maximum turn angle constraints in the literature seem to be limited to symmetric one-edge ahead turn constraints. However, such a limitation implies that resolution of the navigation area is essentially dictated by the turn-radius, which in turn, eliminates any possibility of working with a finer resolution for improved accuracy. These one-edge ahead turn constraints were modeled in various ways such as (1) vertex replication (Caldwell, 1961; Boroujerdi and Uhlmann, 1998; Clossey et al., 2001; Soler et al., 2007; Albiach et al., 2008), (2) modification of the Dijkstra’s Algorithm (Solka et al., 1995; Gutierrez and Medaglia, 2008), and (3) transformation of the original graph (Villeneuve and Desaulniers, 2005; Royset et al., 2009; Perugia et al., 2011; Geisberger et al., 2011; Mico and Soler, 2011; Pugliese and Guerriero, 2012). A comparison of the vertex replication method and modified Dijkstra’s Algorithm for road networks can be found in Vanhove and Fack (2012). Our methodology is based on the vertex replication technique where we split each vertex into copies labeled by the direction the ship is coming from as well as the distance traveled. Thus, immediate navigation history is incorporated into the present location, which in turn enables enforcement of the ship-turn constraints as defined in Section 1.

A research area closely related to ours is mission planning for routing of military aircraft and unmanned aerial vehicles (Zabarankin et al., 2002; Bartlett et al., 2005). Some of these studies also consider minimum turn radius constraints (Szczerba et al., 2000; Royset et al., 2009; Zabarankin et al., 2006; Edison and Shima, 2011). Such mission planning studies, however, are not readily adaptable to ship navigation problems due to the fact that ships differ considerably from aircrafts and aerial vehicles with respect to their technological and operational constraints. In particular, aerial mission planning research often takes into account limited fuel storage constraints, which fundamentally changes the structure of the underlying problem and makes it computationally intractable (Royset et al., 2009). On the other hand, such fuel capacity constraints do not typically exist in ship navigation.

In this section, we formally define the optimal ship navigation problem in the presence of obstacles, or the OSN problem in short. Without loss of generality, we assume that the navigation area is rectangular. In addition, we only consider polygon-shaped obstacles. This should not be seen as a limitation since a polygon approximation can be used to represent any geometric shape at any level of accuracy (Wu and Leou, 1993). We also assume that these polygons are non-self-intersecting as self-intersecting polygons can easily be transformed into non-self-intersecting ones without changing the geometric shape of the obstacle that the polygon represents. Nonetheless, we allow for non-convex and overlapping polygons. The terms polygon and obstacle shall be used synonymously in the rest of this work. The notation in Table 1
                      characterizes our ship navigation model. In the model, one mile refers to one nautical mile, which corresponds to 1.151 (land) miles or 1.852kilometer. Ship’s speed is expressed in knots, with one knot representing a speed of one nautical mile per hour.

For any obstacle p
                     ∈
                     P, its buffer zone B
                     
                        p
                      is defined as the region whose boundary is comprised of points that are d
                     
                        p
                      meters away from the closest point on the obstacle’s boundary. In our model, we require that the ship does not enter the buffer zone of any obstacle, which we call the safety distance constraint. The ship’s left and right turning diameters are defined as ℓ×
                     c
                     
                        l
                      and ℓ×
                     c
                     
                        r
                      respectively where ℓis the ship’s length between perpendiculars (LBPs) in meters. LBP refers to the length of the ship along the water line from the forward-surface of the stem to the after-surface of the sternpost. This method for specifying a ship’s turn radius is typical in seaborne navigation (American Bureau of Shipping, 2006). The ship’s turning angle at any point (with respect to its present direction) is constrained to be upper bounded by that of the curvature of the circle with respective left and right turn diameters.

The Optimal Ship Navigation (OSN) Problem is then defined as follows: Given a set of obstacles P inside the navigation area A, a starting point s and a destination point t, find the time-wise shortest s
                     −
                     t path for a ship with straight (non-turn) speed k, turn speed k
                     ′, LBP ℓ, left-turn coefficient c
                     
                        l
                     , and right-turn coefficient c
                     
                        r
                      subject to safety distance and ship-turn constraints. Note that due to reduced turning speeds, time-wise shortest paths are likely to be different than Euclidean-distance shortest paths.

@&#METHODOLOGY@&#

In this section, we first present an algorithm that computes safety buffer zones around each obstacle. We then describe our lattice discretization and explain implementation of the ship-turn constraints. Next, we illustrate how the optimal (discrete) path can be smoothed in order to emulate the actual (continuous) navigation of the ship.

As mentioned earlier, this study assumes that (polygon-shaped) obstacles inside the navigation area are static. In reality, however, obstacles such as ice blocks or anchored ships may move slightly due to environmental conditions such as winds, waves, or sea currents. Unexpected changes in these conditions may also cause a certain deviation in the ship’s planned course. In addition, it might be the case that vicinity of an obstacle is unsafe due to the nature of the obstacle. For instance, under-water sections of icebergs are sometimes dangerous for close-by ship navigation. Due to these reasons, even though obstacles are assumed to be static, we allow for a buffer zone around each obstacle. These zones are defined as the regions whose boundary is comprised of points that are d
                        
                           p
                         meters away from the closest point on obstacle p’s boundary.

Our methodology for computing buffer zones is based on defining a sequence of uniformly-spaced vertices for each pair of edges in the original polygon such that the safety distance constraint is satisfied. The outcome of the process is another polygon that satisfies the safety distance constraint at all points, which we call the buffer zone polygon and denote by B
                        
                           p
                         for obstacle p. A step angle, denoted by δ, is used to determine the number of vertices to be defined for each pair of edges. The step angle δ is taken as 3 degrees in our implementation. As an example, suppose the angle between one pair of edges for an obstacle is 120 degrees, meaning that the angle between these edges’ normal vectors is 60 degrees. For the resulting buffer zone polygon, we define uniformly-spaced 60/3=20 vertices in total corresponding to this edge pair. Provided in Fig. 1
                         is a pseudo-code of our algorithm for buffer zone polygon calculation and illustrated in Fig. 2
                         are two examples. In the rest of this manuscript, we will only be concerned with buffer zone polygons as what the ship needs to avoid in its s
                        −
                        t voyage are these buffer zones—not the actual obstacles.

As discussed earlier, identification of the shortest path in the OSN problem in a continuous setting is a rather difficult task. Therefore, we consider a discrete approximation of the continuous setting on a subgraph of the 8-adjacency integer lattice. In particular, this discretization is the directed graph G
                        =(V,
                        E) whose vertices are all of the pairs of integers i, j such that 1⩽
                        i
                        ⩽
                        x
                        max and 1⩽
                        j
                        ⩽
                        y
                        max, where x
                        max and y
                        max are given integers. There are directed edges between all pairs of the following four types of vertices: (1) (i,
                        j) and (i
                        +1,
                        j) with unit length, (2) (i,
                        j) and (i,
                        j
                        +1) with unit length, (3) (i,
                        j) and (i
                        +1,
                        j
                        +1) with length 
                           
                              
                                 
                                    2
                                 
                              
                           
                         units, and, (4) (i
                        +1,
                        j) and (i,
                        j
                        +1) with length 
                           
                              
                                 
                                    2
                                 
                              
                           
                         units. One vertex in G is designated as the starting point s, another vertex in G is designated as the termination point t. The ship is to traverse from s to t in G, only using edges whose start and end vertices are both outside of buffer polygons of any obstacle in P. Consistent with our lattice discretization, we only consider 45-degree turns in this work.

Unit (i.e., non-diagonal) edge length in the lattice, denoted by α, is determined by a one-mile-resolution-factor f such that α
                        =1/f. For instance, f
                        =20 implies that one (nautical) mile corresponds to 20 unit edges with α
                        =1/20=0.05 miles, or about 93meters. Diagonal edge length is then computed as 
                           
                              
                                 
                                    2
                                 
                              
                              α
                              ≃
                              131
                              
                              meters
                           
                        . Now, suppose that the navigation area is A
                        
                           x
                        
                        =12miles by A
                        
                           y
                        
                        =8miles. With f
                        =20, x
                        max and y
                        max can be computed as x
                        max
                        =
                        f
                        ×
                        A
                        
                           x
                        
                        =240 and y
                        max
                        =
                        f
                        ×
                        A
                        
                           y
                        
                        =160. This setup shall be used in our subsequent illustrations and examples.

As mentioned earlier, our definition of ship-turn constraints is comprised of the following: (1) the ship’s left and right turn radii are different, (2) ship’s speed reduces while turning, and (3) the ship needs to navigate a certain minimum number of lattice edges along a straight line before altering course. In order to illustrate how these constraints can be implemented in practice, we shall use a typical 100,000 DWT merchant ship as a running example with the following characteristics: LBP ℓ=232 meters, right-turn coefficient c
                        
                           r
                        
                        =4.7, left-turn coefficient c
                        
                           l
                        
                        =4.1, cruising speed k
                        =10.0knots, and turning speed k
                        ′
                        =8.0knots (American Bureau of Shipping, 2006).

Right-turn diameter for the above ship is calculated as ℓ×
                        c
                        
                           r
                        
                        =232×4.7≃1090meters whereas the left-turn diameter is given by ℓ×
                        c
                        
                           l
                        
                        =232×4.1≃951meters. In order to determine the number of edges in the lattice discretization corresponding to right and left turns, we first find the smallest octagons that fully contain circles with the right and left-turn diameters respectively. Edge lengths of these octagons are computed using elementary geometry as illustrated in Fig. 3
                         for the right turn. Let γ
                        
                           r
                         and γ
                        
                           l
                         denote the edge length of the octagon corresponding to the right and left turns respectively. From the figure, we observe that 
                           
                              
                                 
                                    γ
                                 
                                 
                                    r
                                 
                              
                              +
                              2
                              
                                 
                                    γ
                                 
                                 
                                    r
                                 
                              
                              /
                              
                                 
                                    2
                                 
                              
                              =
                              1090
                           
                        , which implies 
                           
                              
                                 
                                    γ
                                 
                                 
                                    r
                                 
                              
                              =
                              1090
                              /
                              (
                              1
                              +
                              
                                 
                                    2
                                 
                              
                              )
                              ≃
                              452
                              
                              meters
                           
                        . Likewise, 
                           
                              
                                 
                                    γ
                                 
                                 
                                    l
                                 
                              
                              =
                              951
                              /
                              (
                              1
                              +
                              
                                 
                                    2
                                 
                              
                              )
                              ≃
                              394
                              
                              meters
                           
                        . For a right turn, 452meters correspond to 452/93≃4.86 or about 5 unit edges, and 452/131≃3.45 or roughly 4 diagonal edges. Similarly, for a left turn, 394meters correspond to 394/93≃4.24 or about 4 unit edges, and 394/131≃3 diagonal edges. Thus, a right turn on the integer lattice consists of the following three steps: (1) navigate at least 5 unit or 4 diagonal edges, (2) make a 45-degree right turn, and (3) navigate again at least 5 unit 4 diagonal edges to complete the turn. Similarly, for a left turn, the ship needs to navigate at least 4 unit or 3 diagonal edges in the lattice, make a 45-degree left turn, and navigate again at least 4 unit or 3 diagonal edges. Each one these edge sequences before and after the turn shall be referred to as a “leg”. It is important to note that the second leg of a turn can also be the first leg of the next turn.

Having determined the minimum number of edges for right and left turns, the next task is to carefully define a new graph G
                        ′
                        =(V
                        ′,
                        E
                        ′) over which the turn-constrained navigation shall take place. Graph G
                        ′ is constructed in such a way that it contains all legal paths and no illegal ones in order to preserve optimality. In this context, optimality is with respect to the underlying integer lattice—clearly, the optimal path on the lattice is not guaranteed to be optimal in the original continuous space. At this point, we observe that there are three types of edges in E
                        ′:
                           
                              1.
                              
                                 One-Hop Edges (“1H”): Edges representing straight (non-turn) navigation. These correspond to usual unit or diagonal (or simply one-hop) edges in E.


                                 Right-Turn Edges (“RT”): Edges representing one leg of a right turn.


                                 Left-Turn Edges (“LT”): Edges representing one leg of a left turn.

The ship navigates at the normal speed k
                        =10knots (18,520meters per hour) along 1H edges, and at the reduced speed k
                        ′
                        =8knots (14,816meters per hour) along the RT and LT edges. Thus, time length of a unit 1H edge is 3600×93/18520≃18s, and time length of a diagonal 1H edge is 3600×131/18,520≃25.5s. On the other hand, time length of a non-diagonal RT edge is 3600×93×5/14,816≃113s whereas time length of a diagonal RT edge is 3600×131×4/14,816≃127.3s. Likewise, time length of a non-diagonal LT edge is 3600×93×4/14,816≃90.4s whereas time length of a diagonal RT edge is 3600×131×3/14,816≃95.5s. Our objective in the OSN problem is to find the time-wise shortest path. Thus, in the rest of the manuscript, we will exclusively be concerned with time lengths, which we denote by φ(u,
                        v) for (u,
                        v)∈ 
                        E
                        ′.

Our methodology for constructing G
                        ′ is based on the idea of vertex replication where each vertex is split into copies labeled by the direction which the ship is coming from as well as the edge type. There are eight different directions (E,W,N,S,NE,SE,NW,SW), and three edge types, resulting in a total of 24 copies of each vertex in V. For convenience, coordinate information of each vertex copy v
                        ′
                        ∈
                        V
                        ′ will be augmented by the direction and the edge type information. As an example, we consider vertex copies corresponding to the lattice coordinate x
                        =50, y
                        =50 for each one of the three E
                        ′ edge types with an east-bound direction. Fig. 4
                         illustrates these copies and the edges emanating from them. The first vertex copy we examine is (50,50,W,1H), which represents one-hop straight navigation from west to east, i.e., from (49,50) to (50,50). Since one-hop is not sufficient for any turns, we define only three edges emanating from this vertex copy corresponding to further straight (non-turn) navigation with the following three end vertices:
                           
                              1.
                              
                                 (51,
                                 
                                 50,
                                 
                                 W,
                                 
                                 1H): The corresponding edge represents one-hop straight navigation. Edge length is 18s.


                                 (55,
                                 
                                 50,
                                 
                                 W,
                                 
                                 RT): The corresponding edge represents first leg of a right turn. Edge length is 113s.


                                 (54,
                                 
                                 50,
                                 
                                 W,
                                 
                                 LT): The corresponding edge represents first leg of a left turn. Edge length is 90.4s.

Second vertex copy we consider is (50,50,W,RT)—representing 5 unit-edge navigation from west to east, that is, from (45,50) to (50,50). This much distance is sufficient for both right and left turns as well as further straight navigation. Therefore, we define six edges emanating from this vertex copy with the following six end vertices:
                           
                              1.
                              
                                 (51,
                                 
                                 50,
                                 
                                 W,
                                 
                                 1H): The corresponding edge represents one-hop straight navigation. Edge length is 18s.


                                 (55,
                                 
                                 50,
                                 
                                 W,
                                 
                                 RT): The corresponding edge represents first leg of a right turn. Edge length is 113s.


                                 (54,
                                 
                                 50,
                                 
                                 W,
                                 
                                 LT): The corresponding edge represents first leg of a left turn. Edge length is 90.4s.


                                 (54,
                                 
                                 54,
                                 
                                 SW,
                                 
                                 RT): The corresponding edge represents first leg of a right turn. Edge length is 127.3s.


                                 (53,
                                 
                                 53,
                                 
                                 SW,
                                 
                                 LT): The corresponding edge represents first leg of a left turn. Edge length is 95.5s.


                                 (54,
                                 
                                 46,
                                 
                                 NW,
                                 
                                 RT): The corresponding edge represents first or second leg of a right turn. Edge length is 127.3s.

Third vertex copy we consider is (50,50,W,LT)—representing 4 unit-edge navigation from west to east, that is, from (46,50) to (50,50). This much distance is sufficient for a left turn as well as further straight navigation, but not long enough for a right turn. Therefore, we define five edges emanating from this vertex copy with the same end vertices as the first five vertices above for the (50,50,W,RT) copy. The sixth edge with the end point (54,46,NW,RT) is excluded as it would result in an illegal move. As a second set of example edge calculations, Fig. 5
                         illustrates the process for the same lattice coordinate of x
                        =50, y
                        =50, this time with a northeast-bound direction.

Vertex copies for other directions and edges emanating from them are defined in a similar manner as above. In general, for any vertex copy, the following emanating edges need to be defined for each one of the eight directions for the listed three edge types:
                           
                              1.
                              
                                 1H Edges: Three straight navigation edges (one 1H, one RT, one LT edge).


                                 RT Edges: Three straight navigation edges (one 1H, one RT, one LT edge), two 45-degree left turn edges (one RT, one LT), and one 45-degree right turn RT edge for a total of six edges.


                                 LT Edges: Three straight navigation edges (one 1H, one RT, one LT edge) and two 45-degree left turn edges (one RT, one LT) for a total of five edges.

For a vertex copy, observe that for each one of the eight directions, there are a total of 14 emanating edges. Thus, ∣V
                        ′∣=24∣V∣and ∣E
                        ′∣=(8×14)∣V∣. In our example setting, we let the starting point for the navigation be (1,80) and the termination point be (240,80). A desirable feature of our methodology is that it allows for specifying an initial direction at the starting point and an approach direction at the destination point. For instance, if the ship is required to approach the termination point from the NW direction, the A
                        ∗ algorithm can be terminated as soon as any one of the (240,80,NW,1H), (240,80,NW,RT), or (240,80,NW,LT) vertices is permanently labeled. In our implementation, we specify an west-east direction at the starting point and allow for an arbitrary approach direction at the termination point. Thus, we start the algorithm at the vertex (1,80,W,1H) and terminate the algorithm whenever any vertex copy at the (240,80) coordinate is permanently labeled.

We conclude this section by pointing out to the following fact regarding optimality of our methodology: the A
                        ∗ algorithm that we use to find the shortest s
                        −
                        t path on G
                        ′ correctly identifies the optimal path (with our choice of the heuristic function) as discussed below. In addition, via careful definition of the edges in E
                        ′, we ensure that this graph embeds all possible legal traversals and no illegal paths. Thus, A
                        ∗ algorithm stands proven and no separate optimality proof is needed.

The OSN problem requires finding a deterministic shortest path on the graph G
                        ′, which can be computed by the well-known (heap implementation of) Dijkstra’s algorithm. When it can be used, the A
                        ∗ algorithm (Hart et al., 1968, 1972; Nilsson, 1980) is an alternative to Dijkstra’s algorithm, which has the same worst-case complexity, but empirically runs faster. In A
                        ∗, the guidance of a heuristic function, which roughly reflects the distance from the respective vertices to the destination, helps to guide the algorithm to make a more goal-oriented search than the search performed in Dijkstra’s algorithm. In the most general case, A
                        ∗ is not guaranteed to terminate with an optimal solution, but if the heuristic function h it uses is admissible, i.e., never overestimates the actual shortest distance, then A
                        ∗ indeed terminates with an optimal solution (Nilsson, 1980).

In the setting of the graph G
                        ′, which is embedded in the plane, an admissible heuristic function is the time-length of the line segment from every vertex to t with the non-turn navigation speed of k knots (“as the crow flies”; in the absence of any and all obstacles). Moreover, this heuristic function is valid in the sense that if h(t)=0 and, for all (u,
                        v)∈
                        E
                        ′,
                        h(u)⩽
                        h(v)+
                        φ(u,
                        v). This latter inequality can be seen as a triangle inequality. Note that if h is valid, then for all v
                        ∈
                        V
                        ′, h(v) turns out to be a lower bound on the shortest v, t path distance. In this case, the A
                        ∗ algorithm can be coded much more simply as re-labeling of vertices is never necessary. Appendix A provides a brief overview and pseudo-code of the Dijkstra’s and A
                        ∗ algorithms.

Due to the nature of our lattice discretization, any (45-degree) right or left turn on the lattice looks artificial and is infeasible in reality as no ship can manoeuver this path exactly. Thus, once the optimal (discrete) path is determined, any such turn needs to be smoothed such that the smoothed paths are consistent with the ship’s real-world turn dynamics. This, in turn, allows for emulating the actual (continuous-space) navigation of the ship. There has been some research on path smoothing using post-processing techniques such as curve fitting and creating the smoothed path directly (Berglund, 2003; Wang et al., 2010). In this work, we employ a more natural and realistic-looking smoothing method that takes advantage of the special structure of the underlying problem. Specifically, we smoothen the turns by replacing the inner halves of the turn legs with the arc segment of the turn circle. This process is illustrated in Fig. 6
                         for right and left turns respectively.

Sea ice covers about 7% of world’s oceans (Hanna, 1998). Of particular interest is the sea ice in the Arctic region as recent studies reveal that the Arctic sea ice is decreasing at a much faster rate than previously forecasted (Ho, 2010). This phenomena has been primarily attributed to two reasons: (1) global warming (the rate of warming at the Arctic region is twice the globally-averaged), and (2) feedback of the atmospheric circulation and oceanic circulation change (Shen and Shi, 2011).

Northern Sea Route (NSR) through the Arctic region links the Atlantic and Pacific oceans and allows for maritime transport between Europe, North America, and Asia. What makes NSR critical for world’s international trade is that it provides a route between Europe and Asia that is 9000kilometer shorter than the Panama Canal route and 17,000kilometer shorter than traveling around Cape Horn, South America (Wilson et al., 2004). Yet, usage of NSR has been limited so far primarily due to the fact that it has never been ice-free, even during the summer months (Ho, 2010). However, with the rapid melting of the Arctic sea ice, NSR could soon open to intercontinental shipping. That being the case, ship navigation in waters with partially-melted ice poses significant safety risks. In fact, Ho (2010) states that “Before the Arctic routes can reliably be used on a large scale for transit by shipping along its passages, more investments are required on infrastructure and the provision of marine services to ensure the safe and secure transit of shipping”.

In this section, we provide an ice navigation example that illustrates how our methodology can be applied to optimal ship navigation in ice-covered waters. Our goal is to lay groundwork for further studies on this topic as it is posed to become a new research area with the opening of the NSR for international seaborne transportation. It is highly likely that a methodology such as ours for finding shorter routes in icy waters will not only result in considerable fuel savings and decreased capital costs, but also reduce ships’ negative environmental impact on the delicate Arctic ecology.

Sea ice categorization is typically based on the percentage of the ocean surface it covers. International standards identify seven categories of sea ice: (1) ice-free, (2) open water, (3) very open ice, (4) open ice, (5) close ice, (6) very close ice, and (7) consolidated ice (Buysse, 2007). These categories are illustrated in Fig. 7
                     . Our example is based on an open ice navigation area, which roughly corresponds to an ice concentration of 4/10.

In our example, we continue to use the previous setup where the navigation area A is a 12 by 8miles rectangular region. Resolution factor f is taken as 20, which implies that x
                     max
                     =240 and y
                     max
                     =160 in the integer lattice discretization. For each ice block, we set the buffer zone safety distance d
                     
                        p
                      to 150meters. In order to simulate open ice formation, we construct random Voronoi tiles (Okabe et al., 2000) as follows: We first sample 100 points from a uniform distribution in the range [1,240]×[1,160]. Then we compute the Voronoi tiles for these points. Next, we manually designate roughly 40 of these tiles as ice blocks and the remaining ones as ice-free regions so that our navigation area resembles open ice. We leave it future research to devise an automated methodology for generation of random ice fields. Fig. 8
                     a depicts the ice formation and the navigation area used in our example. Fig. 8b shows the buffer zones around each ice block and the shortest path with one-edge ahead symmetric 45-degree turn constraints. Fig. 8c illustrates the smoothed shortest path with ship-turn constraints. In this particular example, the shortest path with the ship-turn constraints differs dramatically from the one with simple one-edge ahead turn constraints—illustrating unsuitability of existing approaches for ship navigation.

Similar to aircrafts, automated navigation systems are available for merchant ships (Tokyo Keiki Inc. (http://www.tokyokeiki-usa.com/categories/view/6) and Yokogawa autopilots (http://www.yokogawa.com/ydk/mr/marine/pilot/index.htm) are two examples of such systems). However, these autopilot systems are designed primarily for navigation in open waters. In restricted waterways or in the presence of close-by obstacles, the common practice is to switch to hand-steering mode due to safety concerns and limited maneuvering capability. Therefore, the optimal path obtained above for our ice navigation example needs to be traversed manually by a qualified helmsman in a real-world application. In this section, we present a proof-of-concept by having an experienced oceangoing captain hand-steer the graph-theoretic path and thereby simulate the ship’s actual path in a full-mission ship handling simulator (FMSHS). Our purpose with this simulation is to illustrate real-world feasibility of our graph-theoretical methodology and gain insight into any limitations it might have.

FMSHSs are utilized throughout the world not only for educational and training activities, but also for fulfilling research and development objectives of maritime industry. Some examples of FMSHS research activities are as follows: analysis of environmental and maneuvering difficulties in new port constructions, port approaching, real-time navigation in the presence of obstacles, and berthing/unberthing maneuvers. The FMSHS we use is Japanese Marine Science (JMS) branded and equipped with sophisticated instruments same as a real ship bridge. As a full mission simulator, it is capable of fully simulating behavioral and physical aspects of a bridge operation as well as performing advance maneuvers in restricted waterways. The simulator system consists of two independent bridges called the main bridge (shown in Fig. 9
                     ) and the secondary bridge. The navigation instruments on the main bridge are connected to a computer system. The secondary bridge is used primarily for radar navigation purposes. The computer-generated navigation imagery is projected to a large oval screen by seven CRT projectors with a 240-degree viewing angle from port wing to starboard wing.


                     Fig. 10
                      shows the manually navigated path inside the FMSHS labeled with the ship’s instantaneous speed, and Fig. 11
                      compares the manually navigated path to our graph-theoretical shortest path. We observe that the manual path closely (but not exactly) follows the graph-theoretical path while avoiding buffer zones at all times. Such a slight difference is somewhat to be expected considering the human element in the process, but the crucial observation here is that, at least in our example, the graph-theoretical path seems to be consistent with the complex navigation and turn dynamics of the merchant ship under consideration. However, we do notice a limitation of our model: we observe that the ship’s speed is a continuous quantity between about 8 and 10knots as opposed to being exactly 8knots while turning and 10knots while straight navigation. Such a discrepancy in navigation speeds might perhaps become an issue in mission-critical applications, but its impact is likely to be less dramatic in a commercial seaborne shipping setting.

This research is concerned with a graph-theoretical approach to the optimal ship navigation problem wherein the objective is to find the shortest path between two given coordinates in a lattice-discretized navigation area in the presence of obstacles subject to safety distance and ship-turn constraints. The latter constraint consists of the following: (1) the ship’s left and right turn radii are different, (2) ship’s speed reduces while turning, and (3) the ship needs to navigate a certain minimum number of lattice edges before making any turns—so that the navigation area can be discretized at any desired resolution. We present a geometry-based algorithm for computing safety buffer zone polygons corresponding to each obstacle. In order to facilitate implementation of the ship-turn constraints, we define a new graph where the lattice vertices are split into 24 copies that incorporate immediate navigation history, that is, direction and edge type information. In particular, the type of an edge specifies whether the ship was performing a straight (non-turn) navigation, or, making a right or left turn before arriving at the edge’s end vertex. For each one of these vertex copies, we carefully define outgoing edges that represent all legal traversals while avoiding any illegal moves. Once the optimal (discrete) path is determined, we smoothen it using geometry to emulate the actual (continuous) navigation of the ship.

The field application we present to illustrate our methodology is a 100,000 DWT merchant ship navigation in ice-covered waters. We simulate the actual navigation of the ship in a full-mission ship handling simulator to demonstrate real-world feasibility of our approach. Finding shorter routes in icy waters using a methodology such as ours is likely to result in not only fuel and capital savings, but also reduce ships’ negative impact on the environment.

In what follows, we propose several directions for future research. In this work, we ignore environmental effects such as winds, waves, or sea currents. Such conditions, on the other hand, often play a significant role in ship navigation. We plan to incorporate such environmental constraints in our future research. In addition, we assume that the obstacles inside the navigation area are static, that is, they do not move or change shape as the ship navigates. Even though certain obstacles fit this assumption (such as islands or rock formations), it is likely the case that obstacles such as ice blocks or other ships change location over the course of the ship’s voyage. We plan to investigate how our methodology can be adapted to handle such a scenario. Moreover, even though the shortest path we find is guaranteed to be optimal (in our discrete setting), it is limited to 45-degree turns on the integer lattice. There exist several studies in the literature that propose algorithms for finding feasible paths with arbitrary turn angles without constraining the traversals to grid edges—though without any optimality guarantees (see, e.g., (Nash et al., 2007)). We intend to investigate how such approaches can be adapted for ship navigation in the presence of environmental and ship-turn constraints.

@&#ACKNOWLEDGEMENTS@&#

The authors are grateful to Editor Prof. Immanuel Bomze and the two anonymous referees whose valuable comments and suggestions greatly improved the overall quality of this article. The authors also thank Prof. Donniell E. Fishkind with the Department of Applied Mathematics and Statistics at The Johns Hopkins University for several helpful discussions.

This appendix provides a brief overview of the A
                     ∗ and Dijkstra’s algorithms. Suppose we are given a graph G
                     =(V,
                     E), a starting vertex s
                     ∈
                     V, a termination vertex t
                     ∈
                     V, and a nonnegative length function 
                        
                           φ
                           :
                           E
                           →
                           
                              
                                 R
                              
                              
                                 ⩾
                                 0
                              
                           
                        
                     . We seek an s,t path P of shortest length 
                        
                           φ
                           (
                           P
                           )
                           ≔
                           
                              
                                 ∑
                              
                              
                                 e
                                 ∈
                                 E
                                 (
                                 P
                                 )
                              
                           
                           φ
                           (
                           e
                           )
                        
                     . Dijkstra’s algorithm grows a set F of marked vertices and also tunes distance labels η:V
                     →
                     R
                     ⩾0 while maintaining the invariant that, for all v
                     ∈
                     V, η(v) is the shortest s, v path distance when these paths are restricted to the vertices F
                     ∪{v}. Furthermore, if v
                     ∈
                     F, then such a shortest restricted path is also a global shortest s, v path. For all v
                     ∈
                     V, PRED (v) is defined as the immediate predecessor of v on the present s, v path with length η(v). At the conclusion of the algorithm, the shortest s, t path is s,…,PRED (PRED (t)), PRED (t), t and has length η(t). Pseudo-code for Dijkstra’s algorithm is given in Fig. 12
                     .

A heuristic function 
                     
                        
                           h
                           :
                           V
                           →
                           R
                        
                      (which is meant to be a rough approximation of the shortest path distance from the respective vertices to t) is said to be valid if h(t)=0 and, for all (u,
                     v)∈
                     E, h(u)⩽
                     h(v)+
                     φ(u,
                     v). This latter inequality should be seen as a triangle inequality, and if h is valid then, for all v
                     ∈
                     V, h(v) turns out to be a lower bound on the shortest v, t path distance. This can be seen by letting P
                     =
                     v
                     0, v
                     1,…,
                     v
                     
                        k
                      be a shortest v, t path and then using validity of h such that 
                        
                           h
                           (
                           v
                           )
                           =
                           h
                           (
                           
                              
                                 v
                              
                              
                                 0
                              
                           
                           )
                           =
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 0
                              
                              
                                 k
                                 -
                                 1
                              
                           
                           (
                           h
                           (
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           )
                           -
                           h
                           (
                           
                              
                                 v
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           )
                           )
                           ⩽
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 k
                                 -
                                 1
                              
                           
                           φ
                           (
                           
                              
                                 v
                              
                              
                                 i
                              
                           
                           ,
                           
                              
                                 v
                              
                              
                                 i
                                 +
                                 1
                              
                           
                           )
                           =
                           φ
                           (
                           P
                           )
                        
                     .

Given a valid heuristic function h, the A∗ algorithm has the identical pseudo-code as Dijkstra’s algorithm above, just substituting the line “Select 
                        
                           x
                           ∈
                           arg
                           
                              
                                 min
                              
                              
                                 v
                                 ∈
                                 
                                    
                                       F
                                    
                                    
                                       c
                                    
                                 
                              
                           
                           η
                           (
                           v
                           )
                        
                     ” with the line “Select 
                        
                           x
                           ∈
                           arg
                           
                              
                                 min
                              
                              
                                 v
                                 ∈
                                 
                                    
                                       F
                                    
                                    
                                       c
                                    
                                 
                              
                           
                           (
                           η
                           (
                           v
                           )
                           +
                           h
                           (
                           v
                           )
                           )
                        
                     ”. Clearly, Dijkstra’s algorithm is essentially a special case of the A∗ algorithm with h(u)=0 for all u
                     ∈
                     V. The reader is referred to Ikeda et al. (1994) for a proof that A∗ is in fact equivalent to Dijkstra’s algorithm under the change of variable φ
                     
                        h
                     (u,
                     v)≔
                     φ(u,
                     v)+
                     h(v)−
                     h(u) when h is valid.

@&#REFERENCES@&#

