@&#MAIN-TITLE@&#An end-to-end secure key management protocol for e-health applications

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We introduce an energy-aware key management protocol for e-health applications.


                        
                        
                           
                           The protocol guarantees the end-to-end principle.


                        
                        
                           
                           Constrained nodes offload asymmetric cryptographic operations to third parties.


                        
                        
                           
                           We conduct a formal validation regarding the security properties of our protocol.


                        
                        
                           
                           Analysis results highlight energy gains on constrained nodes.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

E-health

Internet of Things (IoT)

Confidentiality

Security

Privacy

Key management

@&#ABSTRACT@&#


               
               
                  Key distribution is required to secure e-health applications in the context of Internet of Things (IoT). However, resources constraints in IoT make these applications unable to run existing key management protocols. In this paper, we propose a new lightweight key management protocol. This protocol is based on collaboration to establish a secure end-to-end communication channel between a highly resource constrained node and a remote entity. The secure channel allows the constrained node to transmit captured data while ensuring confidentiality and authentication. To achieve this goal, we propose offloading highly consuming cryptographic primitives to third parties. As a result, the constrained node obtains assistance from powerful entities. To assess our protocol, we conduct a formal validation regarding security properties. In addition, we evaluate both communication and computational costs to highlight energy savings. The results show that our protocol provides a considerable gain in energy while its security properties are ensured.
               
            

@&#INTRODUCTION@&#

Internet of Things (IoT) is one of the main communication development in the last decade. Through this concept, it is possible to connect everyday sensors and devices to each other and to the Internet. According to [1], the main concept behind IoT is the pervasive presence around us of various wireless technologies such as Radio Frequency IDentification (RFID) tags, sensors, actuators or mobile phones in which computing and communication systems are seamlessly embedded. Based on unique addressing schemes, these objects interact with each other and cooperate to reach common goals.

Technology advances along with popular demand will foster the widespread deployment of IoTs services. It would radically transform our corporations, communities, and personal spheres. From the perspective of a private user, IoTs introduction will play a leading role in several services. E-health is one of the most interesting applications. In fact, it will provide medical monitoring to millions of elderly and disabled patients while preserving their autonomy and comfort anywhere. Using sensors planted in or around a body, physiological data are gathered and transmitted to qualified medical staff that can intervene in case of an emergency.

E-health applications are unlikely to fulfil a widespread diffusion until they provide strong security foundations. Making sure that only authorized entities can access and modify data is particularly relevant in e-health applications. Indeed, in these applications data are very sensitive, and any unwanted modification could lead to dramatic events. Securing communications in e-health systems necessarily passes through key management protocols. They are in charge of delivering security credentials to the involved entities. However, classical solutions are hindered due to the scarcity of resources available, either energy power or computation capabilities.

In this paper, we propose a new lightweight key management protocol. This protocol is based on collaboration to establish a secured communication channel between a highly resource constrained node and a remote entity (i.e. server). The secured channel allows the constrained node to transmit captured data while ensuring confidentiality and authentication. Our protocol offloads highly consuming cryptographic primitives to third parties which are not necessarily trusted. Consequently, constrained nodes obtain assistance from more powerful entities in order to securely establish a shared secret with any remote entity.

To assess our protocol, both in terms of security properties and energy savings, we proceed with a theoretical analysis that is formally validated through an implementation in Avispa tool [2]. In addition, using energy models that consider both communication and computational costs, we estimate energy savings at the constrained nodes side. The obtained results show a considerable gain of energy cost according to the number of third parties while security properties are kept safe.

The paper is structured as follows. In Section 2, e-health applications in the context of IoT are briefly introduced along with the main security threats that might hinder their deployment. Thereafter, we provide in Section 3 an overview on the state of the art of the proposed security approaches. In Section 4, we present in detail our novel cooperative key management protocol. Both security and quantitative analysis of our protocol are provided in Section 5. Finally, Section 6 concludes the paper and gives future directions.

Internet of Things deployment opens doors to a huge number of applications that can deeply improve our daily life. Among them, e-health applications are gaining more and more attention [1]. An e-health system is a radio-frequency-based wireless networking technology that provides ubiquitous networking functionalities. It is based on the interconnection of tiny nodes enhanced with sensing and/or actuating capabilities planted in, on, or around a human body. E-health applications are context-aware, personal, dynamic, and anticipative. As IoT meets all these characteristics, it provides a suited environment for their efficient deployment. In fact, an extensive research on using IoT paradigm in e-health has recently been reported [3]. Population ageing and the increase of survival chances from disabling illnesses will lead to an increased demand from todays population, which requires a continuous health care [4].

E-health applications could spare a patient from long stays in hospitals, which is especially sought in emerging countries that lack medical infrastructures and well-trained personnel. Additionally, the continuous monitoring anticipates emergency situations allowing rapid and effective intervention of health teams. Moreover, early stage diagnostics could also be achieved remotely [5]. In sum, e-health applications in the context of IoT constitute a cost effective and unobtrusive solution without interrupting the patient’s everyday activities. Nevertheless, their deployment could be hindered if privacy challenges are not addressed efficiently.

As health data are highly sensitive, studies in [6,7] have underlined that e-health applications might be more vulnerable to attacks compared to other IoT applications. In fact, health related data are private in nature; any breach in the confidentiality of personal captured data would seriously repulse patients from adopting e-health solutions. For instance, many people would not like their health personal information, such as an early stage of pregnancy or details of certain medical conditions, to be disclosed. In fact, eavesdropped communications could be used for several illegal purposes. Moreover, any modification in the captured data could lead to disastrous consequences, as it could engender wrong medical prescription or delay an emergency intervention.

Classical countermeasures are not suited to the constrained environment of IoT due to several factors such as power and computation scarcity, weak reliability of wireless links, and scalability. Thus, a considerable effort has been undertaken by the research community to provide viable solutions to secure IoT applications. The next section provides an overview on the state of the art of the proposed security approaches, and positions our contribution regarding the literature.

@&#RELATED WORK@&#

The research community has focused its attention on proposing security protocols that take into consideration the constrained environment of IoT. In our discussion of related work, we distinguish two research directions: (i) specific solutions for e-health systems and (ii) tailoring of security protocols for the IP-based IoT.


                     Several specific solutions for e-health systems have been proposed in the literature. TinySec is part of the official TinyOS release. It aims to achieve link-layer encryption and authentication of data in biomedical sensors [8]. The protocol is based on a single key shared among nodes, which constitutes its main weakness as node capture would give access to the entire network. Otherwise, hardware solutions are proposed to deal with the scarcity of resources [9,10]. Nevertheless, these approaches present some drawbacks as they do not offer AES (Advanced Encryption Standard) decryption (only base stations can decrypt the transmitted data). In addition, they are highly platform-dependent, and not all nodes are equipped with hardware encryption capabilities. A different approach is based on biometric techniques [11]. These techniques use the human body to manage the key establishment process based on physiological values (e.g., electrocardiogram). One of their main drawbacks is the recoverability that is not complete at nodes over the network.

A different but complementary research direction has seen several interesting approaches that aim to tailor security protocols for the IP-based IoT. The main focus of these works is to make standard based security protocols more suitable for the constrained environment of IoT. Specifically, several compression schemes for the IP-based IoT have been proposed. In [12,13], the compression of IPV6 header, extension headers, and UDP (User Datagram Protocol) header have been standardized through 6LoWPAN (IPv6 over Low power Wireless Personal Area Networks). Authors in [14,15] have presented 6LoWPAN compressions for IPsec payload headers: AH (Authentication Header) and ESP (Encapsulating Security Payload). In [16], authors have proposed a tailoring to Mikey-Ticket protocol for e-health applications in the context of IoT. Furthermore, an IKE (Internet Key Exchange) compression scheme has also been proposed in order to provide a lightweight automatic way to establish security associations for IPsec [17].

Apart from packet compression schemes, further design improvement approaches have been introduced to tailor security protocols to the IoT. Authors, in [18], have proposed complementary lightweight extensions to HIP DEX (Host Identity Protocol Diet Exchange) that could be generalized to DTLS (Datagram Transport Layer Security) and IKE. Furthermore, to offload the computational load to third parties, delegation procedures of protocol’s primitives have been proposed. Authors in [19] have introduced collaboration for HIP. Their idea is to take advantage of more powerful nodes in the neighborhood of a constrained node to carry heavy computations in a distributed way. Likewise, IKE session establishment delegation to a gateway has been proposed in [20]. Furthermore, authors in [21] have introduced a delegation procedure that enables a client to delegate certificate validation to a trusted server. While the proposed delegation approaches reduce the computational load at the constrained nodes, they break the end-to-end principle by requiring a third trusted party. Our novel cooperative key management protocol overcomes this limitation by providing an end-to-end secured channel between constrained nodes and remote entities.

Several specific solutions have been proposed for e-health applications. However, rather than developing specific solutions to each application scenario, we do believe that securing IoT applications will be achieved through the tailoring of current security protocols. Indeed, it is safer to build on more generic approaches that are backward compatible with existing solutions, and applicable to a wide range of IoT applications. To the best of our knowledge, no previous scheme has been introduced in the literature for e-health applications with the following properties:
                        
                           –
                           Keeping the constrained nodes only involved in simple operations (i.e. symmetric cryptography).

Allowing the constrained nodes to dynamically establish a shared key with any remote entity with which no previous shared knowledge is established. To achieve this goal, third parties are dedicated to support the constrained nodes in this process.

Guaranteeing the end-to-end principle as no entity has the knowledge of the exchanged secret apart from the constrained nodes and the remote entity.

The third parties are not necessarily trusted entities. Indeed, each one of them is only in possession of a part of the secret. Thus, the only way to corrupt the exchanged secret is the colluding of all the third parties.

Our protocol is not specific to e-health applications. In fact, it could be applied to a wide range of applications. In addition, it does not alter any cryptographic primitive, and thus allowing a high level of backward compatibility. As a result, any existing standard based cryptographic algorithm might easily be integrated.

In this section, we present our lightweight end-to-end key management protocol. Firstly, we present the network model and a set of assumptions. Afterwards, we provide a broad overview of our protocol along with a summary of the notations used throughout the paper. Finally, we describe in detail the different phases of our protocol.

We consider in our network model four main components: mobile and contextual sensors (constrained nodes), third parties, a remote server, and a certification authority (see Fig. 1
                        ).
                           
                              –
                              
                                 Mobile and contextual sensors: the sensors are planted in, on or around a human body to collect health-related data (e.g. blood pressure, blood glucose level, temperature level, etc.).


                                 Third parties: the third parties represent a key component in our protocol. A third party could be any entity able to perform high consuming computations on behalf of the sensor nodes. In fact, the resource constrained sensors rely on them by offloading high consuming cryptographic primitives in a cooperative way.


                                 Remote server: the remote server receives the gathered data for further processing. A remote server could be used by caregiver services in order to take appropriate decisions according to patient’s data.


                                 Certification authority: the certification authority is required to guarantee authentication between the third parties and the remote server by delivering authenticated certificates.

The network is thus heterogeneous. It combines nodes with various capabilities both in terms of computing power and energy resources. In this network, we distinguish two categories of entities:
                           
                              –
                              Highly resource constrained nodes (mobile and contextual sensors), which are unable to perform public key cryptographic operations.

Nodes with high energy, computing power, and storage capabilities (the third parties and the remote server).

Due to the high sensitivity of gathered data, we assume end-to-end secured communications between sensor nodes and the remote server. Hence, a key exchange protocol is required between the two entities to secure these communications. The protocol has to deal with resources capabilities of the involved entities, along with the fact that no prior knowledge has been established between them.

For the implementation of our protocol, we assume that:
                           
                              –
                              Sensor nodes are able to perform symmetric encryption.

Third parties are able to perform asymmetric cryptographic operations (either public or private).

Third parties are not necessarily trusted.

The remote server is powerful enough to support asymmetric encryption.

The certification authority is a trusted entity. It delivers authenticated cryptographic credentials to the third parties, and to the remote server.

Each sensor node is able to keep a list of remote third parties, which is pre-established during the initialization phase.

Each sensor node shares pairwise keys with each third party. These keys are generated during the initialization phase.

Both third parties and the remote server own a pair of public/private keys.

We provide a broad overview of our protocol before considering a formal description in the next section. Once a resource constrained sensor is willing to establish a shared secret with a remote server, it initiates our protocol. This latter goes through successive phases. First, the constrained node generates a secret key, which is then randomly split to several secret parts. The number of parts corresponds to the number of third parties involved. In the next step, the constrained node encrypts and sends each secret part to the corresponding third party. The encryption of each part is based on symmetric algorithms (less resource consuming than asymmetric ones) using pre-shared keys. In addition, MAC (Message Authentication Code) messages are used to ensure authentication. Once the third party receives its corresponding secret part, it encrypts and delivers it to the remote server. Using encryption, each third party secures the delivery. This encryption is based on asymmetric algorithms, which use the remote server’s public key. Once the remote server receives the secret part, it uses digital signatures to ensure authentication. Upon successful authentication and decryption of the different secret parts, the remote server reassembles the shared secret, which will be used to derive further keying materials. In our protocol, we also make sure that each third party proves to the remote server that it is a legitimate entity, authorized by the constrained node to act on its behalf. The following section describes in detail each phase of our protocol.

After an initialization phase, where each constrained node is pre-loaded with a set of third parties IDs along with pre-shared keys, our protocol proceeds with successive phases. Table 1
                         summarizes the notations used to present the exchanged messages, and Fig. 2
                         illustrates the succeeding phases of our protocol.
                           
                              –
                              
                                 Phase 1 (Initial exchange): node CN initiates the exchange by sending a CN_HELLO message (A) to UN. This message informs UN about the security policies (e.g. encryption algorithm, HMAC algorithm, key life time, etc.), and the cooperative key establishment process it supports. If UN agrees, it selects one of the proposed security policies, and responds with a UN_HELLO message. Nonces are also included in the exchanged messages to prevent replay attacks.


                                 Phase 2 (Securing connection between parties): this phase follows the successful connection between CN and UN. It aims to establish a secure channel either between CN and 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  or between 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  and UN.

During this phase, CN sends message C to the third parties to inform them about UN identity. The message includes a Message Authentication Code (MAC), and is encrypted using 
                                    
                                       
                                          
                                             K
                                          
                                          
                                             CN
                                             ,
                                             
                                                
                                                   TP
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 . The third parties express their willingness to be part of the key exchange protocol through message D. It is worth noting that not all the asked third parties respond with message D. For instance, this might be due to possible resource exhaustion. Hence, we consider that only m 
                                 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  (m
                                 ⩽
                                 n) have responded with message D expressing their willingness to take part in the key exchange process. In message E, each 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  provides UN with its own certificate containing its public key (delivered by CA). In addition, it requests the certificate of UN. This latter verifies that the third party has supplied a valid public key. It, then, responds with message F that contains the requested certificate. We highlight that all messages contain nonces against replay attacks.


                                 Phase 3 (Proving third parties’s representativeness of CN to UN): this phase aims to prove to UN the representativeness of CN by the third parties. To this end, in message G, UN requests the pairwise keys shared with 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                 . In response, CN applies a hash function on each key to keep it confidential, and sends it to UN through message H. The authentication will occur later after receiving message J from the third parties, which should contain the same keys’s hashes.


                                 Phase 4 (Secret generation and delivery): upon successful preparation of the involved entities, CN generates a premaster secret S, which will be used later to generate further keying materials at both CN and UN sides. The secret is split into m parts 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             S
                                          
                                          
                                             m
                                          
                                       
                                    
                                 . Each part 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                    
                                  is securely sent to the appropriate 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  in message I. The communication is secured using the symmetric key 
                                    
                                       
                                          
                                             K
                                          
                                          
                                             CN
                                             ,
                                             
                                                
                                                   TP
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 . Upon receiving message I, each 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  uses UN’s public key to encrypt message J. This message contains the secret part 
                                    
                                       
                                          
                                             S
                                          
                                          
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             K
                                          
                                          
                                             CN
                                             ,
                                             
                                                
                                                   TP
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                    
                                 ’s hash, and 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                 ’s signature that covers all the fields of the message. After the decryption of message J, UN verifies the authenticity of each message using 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                 ’s public key. If all the messages are authenticated, UN verifies 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                 ’s representativeness of CN. The verification is done by comparing the hashes received in message H and those received in message J. If the hashes match, the 
                                    
                                       
                                          
                                             TP
                                          
                                          
                                             i
                                          
                                       
                                    
                                  act on behalf of CN as they pretend. After having received all the packets, UN then reconstructs the secret S. This secret along with the previous exchanged nonces are used to derive further key credentials. Both messages I and J contain nonces to avoid replay attacks.


                                 Phase 5 (Termination phase): this phase concludes the exchanges through message K by proving to CN the knowledge of the secret S.

The derivation process is ensured by a hash function agreed upon during the first phase. Both parties are then able to derive state connection keys for encryption and authentication of the exchanged data. A secure end-to-end channel is hence created between highly constrained nodes and remote unconstrained servers.

@&#ANALYSIS@&#

In this section, we provide a detailed analysis of our proposed key management protocol both in terms of security properties and energy consumption. Firstly, we propose a theoretical analysis of our protocol regarding its security properties. In addition, we highlight the resistivity of our protocol against the well-known attacks that could hinder the establishment of a secure channel in an e-health environment. Our analysis is then validated using an automated validation tool called Avispa [2], which is based on formal models. Secondly, we focus on energy cost savings obtained through our protocol. To achieve this goal, we use energy models to estimate the total energy cost composed of both computational and communication costs.

Security features of our protocol have been assessed based on the properties presented in [22]. We have added an analysis concerning integrity and confidentiality as we consider them being critical in an e-health application. For the following discussion, we consider our communication channel split into two segments: (Seg1) from CN to 
                              
                                 
                                    
                                       TP
                                    
                                    
                                       i
                                    
                                 
                              
                            and (Seg2) from 
                              
                                 
                                    
                                       TP
                                    
                                    
                                       i
                                    
                                 
                              
                            to UN (see Fig. 1).
                              
                                 –
                                 
                                    Confidentiality: the exchanged data between the different entities involved in our protocol are kept confidential. For Seg1, symmetric encryption is used based on the pre-shared keys set during the initialization phase. We recommend the use of the AES-CCM mode that defines AES-CBC for MAC generation with AES-CTR for encryption [23]. Nowadays, more and more tiny sensors include AES hardware coprocessor, which would help to decrease the computational overhead. Regarding Seg2, communications are secured using Public Key Encryption (e.g. RSA algorithm). The CA delivers the required certificates to the involved entities. Our protocol can be run periodically to update the established keys in order to strengthen confidentiality, and prevent long term attacks.


                                    Authentication and integrity: through the use of MACs in Seg1 and digital signatures in Seg2, our protocol makes sure that the exchanged data are genuine. The aim is to ensure that data have not been altered, and have been sent from legitimate nodes. Our protocol also ensures that the involved 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                     prove their authenticity to UN. This is done through the comparison of the secret shared between CN and 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                     (we refer to Section 4.4 for more details). In addition, to avoid any replay attacks, we include nonces (e.g. time-stamps, random values, etc.) in the different exchanged messages.


                                    Distribution: the distribution of security credentials in Seg1 is performed by an off-line dealer during the initialization phase. However, in Seg2, through the use of Public Key Encryption, the involved entities establish a secure channel in an online mode. Thus, upon key’s distribution in Seg1, our protocol can be run without any external intervention, allowing updates to be processed in an automatic way.


                                    Overhead: the computation overhead is relatively low. In fact, through the different handshakes of our protocol, constrained nodes are only involved in symmetric encryption primitives, which are much less resource consuming than asymmetric ones. All asymmetric operations are offloaded to third parties that are much more powerful. Doing so, our protocol limits the computational requests for the constrained nodes. As a result, it decreases their power consumption, and thus increases their battery life-time.


                                    Resilience: the resilience of our protocol is high. Indeed, as S is split into several parts, an attacker has to take control of all third parties to compromise the exchanged secret S. Unless all 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                     are compromised, it is nearly impossible to recover the secret.


                                    Extensibility and scalability: our network model allows new sensors to be integrated (e.g. we can imagine a physician prescribing the implantation of a new sensor for medical reasons). The new sensor has to pass through an initialization phase. Then, the sensor will receive a set of 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                     ’IDs to rely on along with the pairwise keys shared respectively with each of them. This phase is performed by the network administrator. No operation is required concerning any 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                     or the remote servers that will be involved later in the protocol. Upon successful initialization phase, the new sensor can establish an end-to-end secure channel with any remote entity.


                                    Storage: due to the recent advances in flash memory technology [24], smart objects now provide vast amounts of storage space. We rely on this space in our protocol to make the constrained nodes able to store the 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                    ’s ID list along with the corresponding shared keys. We also consider that the number of 
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                     will not exceed a certain threshold defined by the network administrator. Therefore, storage space will not hinder our protocol’s deployment.

E-health applications are subject to several attacks that threaten the establishment of secure channels [6,7]. In this section, we highlight the resistivity of our protocol against these attacks. We focus on the attacks that are positioned in the network and transport layer of the OSI (Open System Interconnection) model where our protocol is performed.

Ensuring key freshness is an important concern with regards to our protocol. Indeed, to provide the perfect forward secrecy property, the involved entities have to be able to detect replayed messages. In particular, e-health applications might be more vulnerable to this kind of attacks compared to other application scenarios; an outdated information could lead to inadequate medical interventions. To overcome this issue, we have introduced the use of nonces in the different exchanged messages. In fact, these nonces could be implemented using one of the following strategies against replayed messages:
                              
                                 –
                                 Random numbers

Sequence numbers

Timestamps

Random numbers might constitute a solution in our e-health scenario. The constrained node maintains a list of the previous received random values in its internal memory. Upon receiving a new message, the node checks if the nonce has already been received. As a result, replayed messages are detected. This solution brings a drawback; the constrained node has to maintain a list of the received nonces in its internal memory. Nevertheless, due to recent advances in flash memory technology [24], smart objects now provide vast amounts of storage space, which attenuates the storage issue. The second solution is based on sequence numbers, which do not require any data storage. Indeed, sequence numbers provide a sequential counter in the exchanged messages. In case where a message is replayed, its counter will be smaller or equal to the current one. Thus, the message will be dropped. However, if one of the involved third parties goes down (e.g. reboot, hardware failure, etc.), this protection is no longer effective. In fact, the third party will lose track of the current counter value. Besides, to ensure message freshness, timestamps could also be used. This solution is highly energy consuming to be implemented for a constrained node. In fact, synchronized clocks have to be maintained between the third parties, the remote server, and the constrained nodes.

Taking into account our constrained networks scenario, we discuss the feasibility of the precedent solutions. It is obvious that maintaining clock synchronization between the third parties and the constrained nodes is not feasible. However, this solution might be considered to protect the unconstrained part of the network model, namely the channel linking the third parties with the remote server (Seg2). Doing so, the third parties and the remote server will have no difficulty to avoid replay attacks using timestamps. Besides, according to the storage capabilities of the constrained nodes, the solution based on random numbers might be adopted for the constrained part of the network (Seg1). Nevertheless, in case where the constrained nodes are highly limited regarding their storage capacity, the solution based on sequence numbers would be preferred at the expense of ensuring highly reliable entities with small probabilities of failure. In a nutshell, protecting our protocol against replayed messages could be achieved through the combination of the above discussed strategies according to the network model specificities.

Denial of Service (DoS) attacks could seriously threaten the availability of our e-health application. In fact, the gathered health related data should always be available even if the system is under a DoS attack. Indeed, if any of the involved nodes is made unavailable, in the sense that it is no longer able to gather or process data, this situation would engender disastrous consequences. For instance, we assume that a sensor is planted in the body of a patient suffering from a heart condition. In case where a heart related value that indicates an impending heart attack is registered, it should immediately be transmitted to health care services. Any delay due to a DoS attack could be fatal.

Several mechanisms are implemented in our protocol to mitigate DoS attacks regarding the involved entities. In fact, the constrained nodes share a long-term key with the third parties. Each exchanged message is authenticated upstream of any processing effort. In the same way, the third parties do not establish any internal state before authenticating both the remote server and the constrained nodes. Authenticating the constrained nodes is achieved through the long-term shared keys using MAC messages. Furthermore, authenticating the remote server is achieved through the exchange of certificates during phase 2 of our protocol (see Section 4.4). Besides, classical countermeasures could also be implemented such as rate-limiting and ACL (Access Control List). Any abnormal message would lead to an abortion of the protocol execution. In addition, based on the sensitivity of e-health applications, we advocate the use of redundancy. Whenever a node is made unavailable by a DoS attack, the protocol execution carries on with the redundant node.

Sybil attacks, where a node claims multiple fake identities could be highly harmful in the context of e-health applications. Through these attacks, an intruder could use feigned identities to send false information. As a result, either an actual emergency situation is skipped or ceaseless false emergency situations are thrown. In addition, a third party could feign as being several third parties. Doing so, it increases its chances of retrieving more shares of the secret sent by the constrained nodes. In our protocol, sybil attacks are mitigated differently according to the segment of our network model. Regarding Seg1, the exchanged messages between the third parties and the constrained nodes contain the identity of the sender, and are authenticated using the pre-shared long-term keys. As a result, the third parties are not able to use multiple identities encrypted with the same shared key. Regarding Seg2, sybil attacks are mitigated through the use of trusted certification to make sure that each entity is assigned exactly one identity.

Another point of interest regarding the threat model of e-health applications is the attacks that aim to exhaust sensors energy making them unavailable. For instance, the De-synchronization attack targets the sequence number of the exchanged messages. This will lead to infinite retransmissions, which waste both energy and bandwidth. Providing message integrity is the main security property that hinders this type of attacks. In fact, MAC messages are computed and checked for each exchanged message ensuring that the included data have not being altered.

E-health applications are subject to several other attacks. In particular, routing attacks that can quickly hinder their functioning to the point of making them unavailable [25]. Our key management protocol is not involved in securing the routing process. In fact, it aims to establish a secure channel upon which the gathered data can be securely transmitted. Indeed, we rely on other mechanisms to secure the routing process. Countermeasures usually involve the introduction of Intrusion Detection Systems (IDS) [26].

Several techniques have been introduced to model and formally validate a security protocol regarding its properties. Among them is model checking, which is a formal method-based technique used to validate finite-state-concurrent systems such as communication protocols. It usually involves verification tools to exhaustively search all execution sequences for desired properties in a protocol specification. Many security protocols have been validated through model checking, and several validation tools are based on model checking [2,27]. We highlight some advantages of model checking compared to classical approaches, which are developed around simulation, testing, and deductions.
                              
                                 –
                                 Gives the possibility for its users to check every single step of the execution process, and thus allowing them to detect any malfunction in a highly accurate way. However, using simulation or testing, only a broad overview of protocol’s behavior is provided. In addition, some flaws might remain unfound until the protocol’s production stage is initiated.

Allows prompt and automated verifications through the different tools that implement model checking. In fact, by adopting model checking, users are spared from building prototypes of their protocols.

AVISPA (Automated Validation of Internet Security Protocol and Applications) is a state-of-the-art verification tool for security protocols that includes a set of model checkers with a common front end. The tool follows the Dolev–Yao intruder model to intercept messages, or to insert modified data [28]. It performs analytical rules to state whether the protocol is safe or not. In case of unsafety, the tool provides a trace highlighting the steps that have led to the attack. In fact, Avispa is considered as an effective tool for the analysis of different Internet security protocols and applications. In the literature, several security protocols have been validated through Avispa [29]. Moreover, the security protocols standardized by the Internet engineering task force (IETF) have been analyzed by the AVISPA community (e.g. IKE, TLS, AAA), and some of the protocols have been found to be flawed [30].

The formal validation of our protocol was carried out using Avispa tool to prove the non-violation of the required security properties, in particular, confidentiality, authentication, delivery proof, and replay protection. Protocol models in Avispa are written in a role-based language called High Level Protocol Specification Language (HLPSL). The actions of the different entities are specified in a module called basic role. However, their interactions are defined by composing multiple basic roles together into a composed role. In addition, the security goals of the analyzed protocol are specified in the goal section before launching the analysis. Besides, Avispa uses four different automatic protocol analysis techniques to validate the analyzed protocol against the specified security goals: on-the-fly model-checker (OFMC), constraint-logic based attack searcher (CL-AtSe), SAT-based model checker (SATMC), and tree automata based on automatic approximations for the analysis of security protocols (TA4SP).

In our modeling, we have first specified a basic role to describe the actions of the different entities involved. Then, we have specified how the participants interact with each other in a composed role. For clarity reasons, we present our modeling using a high level Alice–Bob (A–B) notation, where:
                              
                                 –
                                 
                                    A: constrained node
                                 


                                    
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    : third party
                                 


                                    B: remote entity
                                 


                                    
                                       
                                          A
                                          →
                                          B
                                          :
                                          {
                                          
                                             
                                                N
                                             
                                             
                                                A
                                             
                                          
                                          ,
                                          SecurityPolicy
                                          }
                                       
                                    
                                 


                                    
                                       
                                          B
                                          →
                                          A
                                          :
                                          {
                                          
                                             
                                                N
                                             
                                             
                                                B
                                             
                                          
                                          ,
                                          SecurityPolicy
                                          }
                                       
                                    
                                 


                                    
                                       
                                          A
                                          →
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                          :
                                          
                                             
                                                {
                                                B
                                                ,
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      A
                                                   
                                                
                                                ,
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      B
                                                   
                                                
                                                }
                                             
                                             
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      A
                                                      ,
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                          MAC
                                       
                                    
                                 


                                    
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                          →
                                          A
                                          :
                                          
                                             
                                                {
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                }
                                             
                                             
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      A
                                                      ,
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                          MAC
                                       
                                    
                                 


                                    
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                          →
                                          B
                                          :
                                          {
                                          CertRequest
                                          ,
                                          
                                             
                                                Cert
                                             
                                             
                                                
                                                   
                                                      TP
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                N
                                             
                                             
                                                B
                                             
                                          
                                          ,
                                          
                                             
                                                N
                                             
                                             
                                                
                                                   
                                                      TP
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          }
                                       
                                    
                                 


                                    
                                       
                                          B
                                          →
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                          :
                                          {
                                          
                                             
                                                Cert
                                             
                                             
                                                B
                                             
                                          
                                          ,
                                          
                                             
                                                N
                                             
                                             
                                                
                                                   
                                                      TP
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          }
                                       
                                    
                                 


                                    
                                       
                                          B
                                          →
                                          A
                                          :
                                          {
                                          HashRequest
                                          ,
                                          
                                             
                                                N
                                             
                                             
                                                A
                                             
                                          
                                          }
                                       
                                    
                                 


                                    
                                       
                                          A
                                          →
                                          B
                                          :
                                          {
                                          Hash
                                          (
                                          
                                             
                                                K
                                             
                                             
                                                A
                                                ,
                                                
                                                   
                                                      TP
                                                   
                                                   
                                                      i
                                                   
                                                
                                             
                                          
                                          )
                                          ,
                                          
                                             
                                                N
                                             
                                             
                                                B
                                             
                                          
                                          }
                                       
                                    
                                 


                                    
                                       
                                          A
                                          →
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                          :
                                          
                                             
                                                {
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                }
                                             
                                             
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      A
                                                      ,
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                          ,
                                          MAC
                                       
                                    
                                 


                                    
                                       
                                          
                                             
                                                TP
                                             
                                             
                                                i
                                             
                                          
                                          →
                                          B
                                          :
                                          
                                             
                                                {
                                                
                                                   
                                                      S
                                                   
                                                   
                                                      i
                                                   
                                                
                                                ,
                                                Hash
                                                (
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      A
                                                      ,
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                )
                                                ,
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      A
                                                   
                                                
                                                ,
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      B
                                                   
                                                
                                                ,
                                                
                                                   
                                                      SIGN
                                                   
                                                   
                                                      
                                                         
                                                            TP
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                }
                                             
                                             
                                                
                                                   
                                                      K
                                                   
                                                   
                                                      B
                                                   
                                                
                                             
                                          
                                       
                                    
                                 


                                    
                                       
                                          B
                                          →
                                          A
                                          :
                                          
                                             
                                                {
                                                
                                                   
                                                      N
                                                   
                                                   
                                                      A
                                                   
                                                
                                                }
                                             
                                             
                                                S
                                             
                                          
                                       
                                    
                                 

The rest of the notations used are the same as those presented in Table 1.

Upon complete modeling of our protocol, we have checked its correctness using a protocol animation tool called SPAN. This tool has been introduced to help protocol developers in writing AVISPA specifications. The security goals of our protocol were subsequently evaluated by executing the four Avispa’s backends (i.e. OFMC, CL-AtSe, SATMC and TA4SP). Besides, we have used the default Dolev–Yao intruder model, which allows simulating an intruder that has full control over the network. In this model, all messages sent and received by the different entities might be intercepted, analyzed, modified (as far as the keys are known), or sent to other entities.

The results of the simulation were indicated in reports for each backend model produced by Avispa tool. These reports show that our protocol is “SAFE” against OFMC (see Fig. 3
                           ), CL-AtSe (see Fig. 4)
                            and SATMC (see Fig. 5
                           ). However, against TA4SP database, the result was “INCONCLUSIVE” (see Fig. 6
                           ). According to Avispa user manual [2], an inconclusive result does not imply that an attack has been detected. Consequently, based on the obtained results, we can safely affirm that our protocol is safe regarding the specified security goals. It is impossible for an attacker to violate any of the specified security properties, and disrupt the functioning of the protocol.

Following our formal validation, we focus in the next section on energy cost savings achieved through our protocol.

As explained above, our contribution focuses on proposing a viable key management protocol to the constrained environment of e-health applications in the context of IoT. To this end, we base our solution on offloading heavy computational operations (i.e. asymmetric operations) to third parties. This makes the constrained nodes only solicited for symmetric operations, which are much less resource consuming than asymmetric ones. In addition, our protocol does not require the third parties to be trusted. Thus, the end-to-end principle is not broken. In this subsection, we provide a performance analysis of our protocol, and measure energy savings according to the number of third parties. The results allow us, in one hand, to emphasize the impact of the offloading on energy consumption, and in the other hand, to analyze the variation of energy consumption regarding the number of third parties involved in the protocol. We first describe the energy model on which our estimations are based. Then, we evaluate the communication and computational costs of our protocol according to the number of third parties. The analysis is concluded with a discussion of the total energy cost highlighting the obtained energy savings.

Authors, in [31], have presented an energy evaluation of Wireless Sensor Nodes (WSN) regarding the communication cost. This latter is composed of the costs of transmission, reception, and listening. Besides, the energy consumption of AES encryption algorithm and SHA-1 hash algorithm on WSN nodes have been assessed in [32]. In addition, authors in [31], have also assessed the energy consumption of both ECC (Elliptic Curve Cryptography) encryption algorithm (160-bit keys) and ECDSA (Elliptic Curve Digital Signature Algorithm) signature algorithm. These implementations were processed on tiny nodes with few MHz of computational power, several kilobytes of RAM, and several tens of kilobytes of ROM (i.e. TelosB nodes).

In our evaluation, we consider the total energy cost as the sum of the communication cost and the computational cost. This latter is composed of AES encryption primitives and SHA-1 authentication primitives. Based on the energy measurements presented in [31,32], we estimate the energy consumption of tiny nodes regarding both communication and computational aspects. The deduced values, summarized in Table 2
                           , are used as an energy model for the different operations of our protocol. For the evaluation of the total energy cost, we consider the cost of transmission, reception, listening, and cryptographic operations.

Before presenting the details of our evaluation, we set the following assumptions:
                              
                                 –
                                 Our evaluation only covers energy consumption of the constrained nodes, as remote entities (i.e. third parties and the remote server) are not limited by resources scarcity. Hence, the efforts of reducing energy consumption are focused on the constrained part of the network model. In fact, we only consider the energy consumption generated by the exchanged messages with the constrained nodes.

Based on our formal description depicted in Section 4.2, we estimate the size in bytes of each exchanged message (see Table 3
                                    ).

In order to assess the impact of offloading resource consuming operations to third parties, we firstly consider a basic version of our protocol. In this version, tiny nodes do not rely on any third party to share secrets with remote entities. In fact, each tiny node generates the secret, encrypts it, and sends it to the remote entity. This basic version of our protocol uses classical PKI.

Symmetric algorithms are used to secure communications between the constrained nodes and the third parties. We assume the use of AES-CCM mode that defines AES-CBC for MAC generation and AES-CTR for encryption. Besides, we consider the use of asymmetric algorithms to secure communications between the third parties and any remote entity. We also consider the use of ECC for encryption and ECDSA for authentication, which are more energy saving compared to RSA based algorithms for the same level of security [33]. In addition, in case where no third entity is involved, asymmetric algorithms are used to secure communications between the constrained nodes and any remote entity.

The constrained nodes are IP-enabled through a lightweight IP stack (i.e. 6LowPAN). Thus, using a gateway (i.e. 6LowPAN border router), 6lowPAN headers are compressed and decompressed. The gateway role might be played by a patients smartphone, or any other device placed near a patient. Hence, we suppose in our simulation that the messages sent from the constrained nodes are transmitted through short distances. We also assume 150ms as a propagation delay needed for transmitting the messages with an effective data rate of 75kbps for the constrained nodes (e.g. TelosB) [31].

We consider that our network scenario is clear from interferences.


                           
                              
                                 –
                                 
                                    Sending cost: sending cost is estimated by computing the overall size of the messages sent by a constrained node. The cost is then computed according to the number of third parties involved using the proposed energy model. Table 4
                                     summarizes the results.


                                    Receiving cost: similarly to sending cost, receiving cost is computed according to the overall size of the messages sent to a constrained node. The cost is then estimated based on the number of third parties involved using the proposed energy model. Table 5
                                     summarizes the results.


                                    Listening cost: we consider the constrained node listening for a period of time equal to the sum of packets propagation delay (Δ), packets computation time (Comp), transmission latency (T), and reception latency (R). We suppose 150ms propagation delay needed for routing packets between the different involved entities. Moreover, for the estimation of computational time, we suppose the third parties and the unconstrained remote entity (UN) being 100 times more powerful than the constrained nodes. Furthermore, for the estimation of communication latency, we consider an effective data rate of 75kbps for a tiny node (e.g. TelosB) [31]. As an example, between the sending of message A and the receipt of message B, the constrained node (CN) remains in the listening mode during the following period of time:


                                    
                                       
                                          Δ
                                          (
                                          CN
                                          →
                                          UN
                                          )
                                       
                                    
                                    : Packets propagation delay from CN to UN,


                                    R(UN): Reception latency of UN,


                                    Comp(UN): Computational time of UN,


                                    T(UN): Transmission latency of UN,


                                    
                                       
                                          Δ
                                          (
                                          KMS
                                          →
                                          CN
                                          )
                                       
                                    
                                    : Packets propagation delay from UN to CN.

Listening cost is computed according to the number of third parties involved. Table 6
                            summarizes the results.


                           
                              
                                 –
                                 
                                    Encryption cost: encryption cost is estimated by computing the overall size of the encrypted messages exchanged with a constrained node. The cost is then computed according to the number of third parties involved using the proposed energy model. Table 7
                                     summarizes the results.


                                    Authentication cost: authentication cost is estimated by computing the overall size of the exchanged messages with a constrained node on which a MAC or a digital signature has been calculated. The cost is then computed according to the number of third parties involved using the proposed energy model. Table 8
                                     summarizes the results.

@&#DISCUSSION@&#

Upon energy cost evaluation regarding communication aspect, we have noticed an increase in energy consumption when the number of third parties augments. This is due to the increase of exchanged messages between the constrained node and the third parties. Besides, upon energy cost evaluation regarding the computational aspect, we have noticed high energy consumption in the case where no third party is used. This result is the consequence of using asymmetric cryptographic primitives by the constrained node. Indeed, these cryptographic primitives are much more resource consuming than symmetric primitives.

Based on energy evaluation regarding both communication and computational aspects, we have estimated the overall energy cost considering different numbers of third parties. The results are synthesized in Table 9
                            and plotted in Fig. 7
                           . Compared to the case with no third party involved, we notice a sharp decrease in energy consumption when two third parties are involved. This decrease in energy consumption is the result of offloading asymmetric operations. In fact, the constrained node is only involved in symmetric operations. However, we notice an increase in energy consumption with the introduction of more third parties. This is due to the communication overhead caused by the increase of the number of exchanged messages. Besides, when 10 third parties are used, we notice an increase in energy consumption. Nevertheless, it is still considerably limited compared to the basic case where no third party is involved.

The analysis study has allowed us to validate our protocol from different perspectives. First of all, we have provided a theoretical analysis regarding the different security properties required in our network scenario. Additionally, we have analyzed the resistivity of our protocol against well-known attacks, which can be led against e-health applications. The security properties of our protocol have then been formally validated using Avispa tool. Furthermore, we have proceeded with a quantitative analysis to highlight energy savings. Our estimation has showed the viability of the proposed protocol for e-health applications based on highly constrained nodes. Additionally, as the third parties are not required to be trusted, the end-to-end principle is kept safe. In fact, no intermediate entity is able to retrieve the exchanged secrets. Besides, it is worth noting that as the number of third parties increases, security is consolidated. Indeed, an eventual attacker would need to compromise a more important number of targets. Nevertheless, a reasonable tradeoff needs to be found between the number of third parties and the communication overhead.

The proposed protocol is based on offloading heavy cryptographic primitives to third parties. Highly resource-constrained nodes are then able to establish a shared end-to-end secret with any remote entity, making use of symmetric cryptography. This is achieved through simple message exchanges with third parties, which are much less energy consuming than the actual use of asymmetric cryptographic primitives. We have evaluated our protocol regarding both security aspect and energy cost savings. The results have shown that security properties of our protocol are safe. In addition, considerable energy gains according to the number of used third parties are achieved. Besides, as the number of third parties grows, security is strengthened. Nevertheless, energy consumption increases due to the communication overhead. A viable tradeoff needs to be found between security level and energy consumption. As future work, we are investigating the possibility of developing a lightweight trust model to allow constrained nodes automatically select effective third parties.

@&#REFERENCES@&#

