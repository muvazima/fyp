@&#MAIN-TITLE@&#Mesh saliency with global rarity

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Global rarity is first considered in mesh saliency detection.


                        
                        
                           
                           Acceleration of the computation in local and global saliency.


                        
                        
                           
                           An efficient and robust multi-scale local descriptor is proposed.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Visual perception

Mesh saliency

Sampling

Simplification

Mesh smoothing

@&#ABSTRACT@&#


               
               
                  Reliable estimation of visual saliency is helpful to guide many computer graphics tasks including shape matching, simplification, segmentation, etc. Inspired by basic principles induced by psychophysics studies, we propose a novel approach for computing saliency for 3D mesh surface considering both local contrast and global rarity. First, a multi-scale local shape descriptor is introduced to capture local geometric features with various regions, which is rotationally invariant. Then, we present an efficient patch-based local contrast method based on the multi-scale local descriptor. The global rarity is defined by its specialty to all other vertices. To be more efficient, we compute it on clusters first and interpolate on vertices later. Finally, our mesh saliency is obtained by the linear combination of the local contrast and the global rarity. Our method is efficient, robust, and yields mesh saliency that agrees with human perception. The algorithm is tested on many models and outperformed previous works. We also demonstrated the benefits of our algorithm in some geometry processing applications.
               
            

@&#INTRODUCTION@&#

When people watch objects, they always tend to move their eyes to salient regions that attract their attention. Saliency detection has made substantial progresses in signal processing, computer vision, and even biological literature (e.g., [1–6]). Detecting such visually important regions on 3D mesh models, i.e., mesh saliency, is a significant component in computer graphics [7]. The extracted mesh saliency has been widely used in many aspects of geometry processing to enhance the generated results, such as shape matching, alignments, mesh simplification, mesh smoothing, and segmentation, etc.

The neurophysiological basis and psychophysics of visual saliency have been widely studied over the last decades. Studies have shown that visual saliency is closely related to brain’s response to visual stimuli, which is often associated with local contrast and global rarity [8,9]. Current approaches on mesh saliency only considered the local contrast of salient regions, that is, the distinctive differences with their surrounding neighborhoods. However, the global rarity, which means that human visual system is sensitive to less frequent features and suppress frequently occurring features [8], has never been considered in detecting mesh saliency.

In this paper, we propose a novel algorithm for detecting mesh saliency based on the observation that salient regions are both locally prominent and globally rare. For the measurement of local contrast, we introduce a new multi-scale local descriptor, which captures local geometric features with different sizes of regions. Instead of measuring the local contrast on vertices individually, we calculate the local contrast on over-segmented patches with respect to their neighboring patches in a more efficient manner. Our local descriptor is rotational invariant and performs more robustly than previous single-scale descriptors. For the measurement of global rarity, we define the global saliency of each vertex based on its contrast to all other vertices, which enables that geometrically similar vertices have comparable saliency values. To reduce the computation, we cluster the vertices based on the local descriptor. Then we compute the global rarity on cluster centers and interpolate individual global rarity from cluster saliency. We test our method on various 3D models and compare it with current method of Lee et al. [7]. The experiments show that our method obtains perceptually better results than their method. Furthermore, we also adopt our extracted saliency maps in geometric applications including feature-preserved mesh smoothing, simplification, and sampling.

To the best of our knowledge, this is the first time that the global rarity principle of visual saliency has been used in detecting saliency in 3D geometric contents and has obtained promising results over previous methods.

@&#RELATED WORK@&#

Visual saliency has a long history in computer vision, which is used to estimate the approximate position of regions which attract our attention in an image. Many models for saliency detection have also been proposed. They may be biologically motivated, or computationally inspired, or involve both aspects [10–13].

Inspired by the work of saliency detection in images [10], Lee et al. [7] proposed the first approach for detecting saliency on 3D mesh surfaces, defining mesh saliency using a center-surround operator on Gaussian-weighted mean curvatures. Kim and Varshney [14] enhanced the selected regions of a volume by a visual-saliency-based operator. Gal and Cohen-Or [15] defined the saliency grade of a cluster by considering the area of the patch, the curvature, and the curvature variance in the cluster. Feixas et al. [16]proposed a unified framework for viewpoint selection and mesh saliency by defining an information channel between a set of viewpoints and the set of polygons of an object. Mortara and Spagnuolo [17] detected saliency by semantic-oriented segmentations and used the saliency to generate thumbnails of meshes. Kim and Varshney [18] introduced geometry modification as a tool to persuasively direct visual attention. They took advantage of mesh saliency to alter geometry to elicit greater visual attention. Kim et al. [19] presented a user study that compared the various mesh saliency approaches with human eye movements. Kraevoy et al. [20] defined a vulnerability map for Non-homogeneous resizing of complex models. They adopted slippage and normal curvature to measure the vulnerability map.

However, only local contrast of salient regions has been considered in these approaches and global rarity has never been studied in detecting mesh saliency. We are the first to consider the global saliency property in mesh saliency detection.

Various local shape descriptors have been proposed in the literature. An intensive survey is beyond the scope of this paper. Gatzke et al. [21] presented a method to compare different local regions by defining a similarity function on the curvature maps from both mean and Gaussian curvature. Sun et al. [22] proposed a point signature, called the Heat Kernel Signature (HKS), based on the properties of the heat diffusion process on a shape, which was obtained by restricting the heat kernel to the temporal domain. Yoshizawa et al. [23] chose radial basis functions (RBFs) to build a local approximation of the mesh in the neighborhood of vertex. They introduced the similarity by the difference among local shapes encoded in these RBFs. Shilane and Funkhouser [24] used a Harmonic Shape Descriptor (HSD) which is invariant to all rotations to describe the local geometry shape.

The recent work of Maximo et al. [25] proposed a robust and rotationally invariant local descriptor by measuring the local height field in the neighborhood of each point on the surface and presented a transformation via the extraction of Zernike moments. This 2D descriptor naturally encodes the surrounding shape and is rotationally invariant. In this paper we propose a multi-scale local shape descriptor based on this rotationally invariant local metric to capture the local surface essence of similar parts.

@&#OVERVIEW@&#

We introduce the principles of visual saliency and our model for computing mesh saliency in this section and will elaborate on details of our algorithm in the following sections.

Psychophysics studies have shown that human visual attention is primarily triggered by the following two basic principles [8,9]:
                           
                              
                                 Principle I: local contrast. High contrast against its local surrounding indicates high saliency. Salient regions always have distinctive differences with their local neighbors. This principle has been widely used in detecting saliency in previous works [10,7,19].


                                 Principle II: global rarity. Global rarity in the entire scene means more attention and high saliency. Many studies have shown that human visual system is sensitive to less frequent features and suppress frequently features [8]. This is consistent with human intuition. Take the left image as an example, 
                                    
                                  when we first look at this image, we will concentrate on the two swimming boys which are rare but not the water waves which occur frequently. We find this principle is also available for a 3D mesh surface. For example, when we watch the lion model shown in Fig. 1
                                 a, its face, nose, eyes, and mouth are rare and their saliency will be much stronger. However, its hair gains less attention due to its frequently occurring.

We apply the local contrast and global rarity principle to detect mesh saliency. For a vertex v
                        
                           i
                        , we measure its local contrast saliency S
                        
                           l
                        (v
                        
                           i
                        ) and global rarity saliency S
                        
                           g
                        (v
                        
                           i
                        ) respectively. Finally, local and global saliency are consolidated to benefit from the advantages of both aspects. Local and global saliency maps are normalized and combined:
                           
                              (1)
                              
                                 S
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       S
                                    
                                    
                                       g
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 λ
                                 
                                    
                                       S
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                           
                        where λ is a weighting factor.

We will elaborate on the details of the saliency computation in the following sections.

One problem in defining our saliency is how to define the difference between vertices. According to Principle I and II, a vertex is salient only if its feature is unique. An individual vertex contains too little information. Its surrounding regions need to be considered to measure the difference between vertices. Recently, Maximo et al.[25] introduced a novel mesh surface descriptor based on the local height map around vertices (see examples in Fig. 2
                        ). For a given vertex, the heightmap encodes its local shape. To compute the heightmap, a bounded square sub-region with side length r of the tangent plane is considered. This sub-region is divided into a 16×16 grid and cells outside the radius r are discarded. At each cell within the radius r, a height map is calculated as the Euclidean distance from itself to the mesh surface along the ray perpendicular to the tangent plane. It encodes the local shape surrounding the vertex. Fig. 2 top-left shows three representative examples of height map on the Gargoyle model.

Not directly using the height map as the descriptor, Maximo et al.[25] compute the Zernike-basis expansion of heightmap, the coefficients of which yield a rotationally invariant representation. So the dissimilarity between vertices v
                        
                           i
                         and v
                        
                           j
                         can be measured directly by:
                           
                              (2)
                              
                                 D
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 d
                                 (
                                 
                                    
                                       z
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       z
                                    
                                    
                                       j
                                    
                                 
                                 )
                              
                           
                        where z
                        
                           i
                         and z
                        
                           j
                         are their corresponding Zernike coefficients, d(.,.) denotes the Euclidean distance. Please refer to [25] for more details.

In order to measure the dissimilarity between vertices more effectively and robustly, a multi-scale descriptor is proposed. Our multi-scale descriptor depends on different size height maps (Fig. 2). Z
                        
                           ri
                         denotes the Zernike coefficients of height map with size r of vertex i. We define a multi-scale descriptor with N scale as:
                           
                              (3)
                              
                                 
                                    
                                       M
                                    
                                    
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       [
                                       
                                          
                                             Z
                                          
                                          
                                             
                                                
                                                   r
                                                
                                                
                                                   1
                                                
                                             
                                             i
                                          
                                       
                                       ,
                                       
                                          
                                             Z
                                          
                                          
                                             
                                                
                                                   r
                                                
                                                
                                                   2
                                                
                                             
                                             i
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             Z
                                          
                                          
                                             
                                                
                                                   r
                                                
                                                
                                                   N
                                                
                                             
                                             i
                                          
                                       
                                       ]
                                    
                                    
                                       T
                                    
                                 
                              
                           
                        where r
                        
                           i
                         is the size of height map. After defining the multi-scale descriptor, we can get the dissimilarity between vertices i and j as:
                           
                              (4)
                              
                                 
                                    
                                       D
                                    
                                    
                                       M
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 ,
                                 
                                    
                                       v
                                    
                                    
                                       j
                                    
                                 
                                 )
                                 =
                                 d
                                 (
                                 
                                    
                                       M
                                    
                                    
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                    
                                 
                                 ,
                                 
                                    
                                       M
                                    
                                    
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                    
                                 
                                 )
                              
                           
                        
                     

In this paper, we use the multi-scale descriptor in three different scales whose height map size R
                        ={2l, 3l, 4l}, where l
                        =0.5% of the diagonal of the mesh’s bounding box. The multi-scale descriptors of isolated vertices form a feature space whose distance metric is defined by Eq. (4). Vertices in the mesh are represented as points of this feature space. The similar vertices are located close by in this space.

According to Principle I, regions with high contrast to their surroundings are salient. Eihhauser et al. [26] points out that humans pay more attention to those regions that contrast strongly with their surroundings. Salient regions always have distinctive differences with their local neighbors. Besides contrast, spatial relationships also take an important part in human attention. If spatial relationships are considered when computing vertex-level contrast, the computation is very expensive. Similar to [13], in our local saliency measurement, we propose a patch-based method to measure local contrast. The proposed method is very efficient and fast. We defined metrics in terms of patches instead of vertices. Then, the saliency of individual vertices is computed by weighted interpolation of its neighboring patches. The weights are set according to the spatial distances. For one medium-sized mesh of 10,000 vertices, the computation time does not exceed 10s. This is much faster than the local method of Lee et al. [7].

Firstly, we view the mesh as a graph in which vertices are nodes and weighted edges measure the dissimilarity between nodes. Then, using the efficient graph-based segmentation method [27], the input mesh is segmented into patches with similar vertices (Fig. 3
                        a). For each patch p, we define its saliency as the weighted sum of contrast to its neighboring patches. N(p, 6l) denotes the set of patches within a distance 6l to the patch p. Its saliency value is defined as:
                           
                              (5)
                              
                                 
                                    
                                       S
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 p
                                 )
                                 =
                                 
                                    
                                       1
                                    
                                    
                                       w
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          q
                                          ∈
                                          N
                                          (
                                          p
                                          ,
                                          6
                                          l
                                          )
                                       
                                    
                                 
                                 
                                    
                                       f
                                    
                                    
                                       q
                                    
                                    
                                       -
                                       1
                                    
                                 
                                 ∗
                                 d
                                 (
                                 
                                    
                                       t
                                    
                                    
                                       p
                                    
                                 
                                 ,
                                 
                                    
                                       t
                                    
                                    
                                       q
                                    
                                 
                                 )
                              
                           
                        where w is the number of patches in the set N(p, 6l), t
                        
                           p
                         and t
                        
                           q
                         are the mean of the multi-scale descriptor of all vertices in patch p and in patch q, respectively. 
                           
                              
                                 
                                    f
                                 
                                 
                                    q
                                 
                              
                              =
                              ‖
                              
                                 
                                    
                                       
                                          v
                                       
                                       
                                          q
                                       
                                    
                                 
                                 
                                    ¯
                                 
                              
                              -
                              
                                 
                                    
                                       
                                          v
                                       
                                       
                                          p
                                       
                                    
                                 
                                 
                                    ¯
                                 
                              
                              
                                 
                                    ‖
                                 
                                 
                                    2
                                 
                              
                           
                         where 
                           
                              
                                 
                                    
                                       
                                          v
                                       
                                       
                                          q
                                       
                                    
                                 
                                 
                                    ¯
                                 
                              
                           
                         and 
                           
                              
                                 
                                    
                                       
                                          v
                                       
                                       
                                          p
                                       
                                    
                                 
                                 
                                    ¯
                                 
                              
                           
                         are respectively the center point of patch p and patch q. f
                        
                           q
                         denotes the weight of patch q and is defined as the Euclidean distance between p and q. Thus, those patches further away from patch p will have less influence on the saliency. The geodesic distance can also be used. But we found that the Euclidean distance is enough to get good results.

The saliency of individual vertices are computed by simple interpolation of its neighboring patches. For one given vertex v
                        
                           i
                        , we first find m patches which are most close to it. 
                           
                              
                                 
                                    U
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    {
                                    
                                       
                                          p
                                       
                                       
                                          k
                                       
                                    
                                    }
                                 
                                 
                                    k
                                    =
                                    1
                                 
                                 
                                    m
                                 
                              
                           
                         denotes these patches. The saliency of vertex v
                        
                           i
                         is achieved by:
                           
                              (6)
                              
                                 
                                    
                                       S
                                    
                                    
                                       l
                                    
                                 
                                 (
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             q
                                             ∈
                                             
                                                
                                                   U
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          
                                             V
                                          
                                          
                                             iq
                                          
                                       
                                       
                                          
                                             S
                                          
                                          
                                             l
                                          
                                       
                                       (
                                       q
                                       )
                                    
                                    
                                       
                                          
                                             ∑
                                          
                                          
                                             q
                                             ∈
                                             
                                                
                                                   U
                                                
                                                
                                                   i
                                                
                                             
                                          
                                       
                                       
                                          
                                             V
                                          
                                          
                                             iq
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              
                                 
                                    V
                                 
                                 
                                    iq
                                 
                              
                              =
                              exp
                              (
                              -
                              d
                              (
                              
                                 
                                    M
                                 
                                 
                                    
                                       
                                          v
                                       
                                       
                                          i
                                       
                                    
                                 
                              
                              ,
                              
                                 
                                    t
                                 
                                 
                                    q
                                 
                              
                              )
                              /
                              
                                 
                                    σ
                                 
                                 
                                    a
                                 
                              
                              )
                           
                         and σ
                        
                           a
                         is set to be 0.6 for all examples. In our experiments, we find that 6 neighboring patches are sufficient to produce good results.

To avoid getting far too many regions flagged as salient, we proposed a simple piecewise suppression function to decrease the saliency of some regions and reduce the number of salient vertices. The piecewise function is defined as:
                           
                              (7)
                              
                                 F
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   x
                                                   ,
                                                   
                                                   x
                                                   >
                                                   h
                                                
                                             
                                             
                                                
                                                   x
                                                   ∗
                                                   x
                                                   /
                                                   h
                                                   ,
                                                   
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where h is the threshold value which controls the range of saliency which will be weakened. Empirically, we set threshold h
                        =0.4 in all our examples. Fig. 3 shows the local saliency result for the lion model.

According to Principle II, a vertex is salient if its feature is rare with regard to all other vertices in the mesh. Similar to the model of Cheng et al. [13], the rarity of a vertex can be evaluated by its contrast to all other vertices. As for a vertex, the more similar vertices and the closer to other vertices in the feature space, the weaker its global saliency becomes. Contrary to local saliency, global saliency puts more emphasis on the regions of a mesh but not the boundaries. For a given vertex v
                     
                        i
                     , we define its global saliency as:
                        
                           (8)
                           
                              
                                 
                                    S
                                 
                                 
                                    g
                                 
                              
                              (
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       ∀
                                       
                                          
                                             v
                                          
                                          
                                             j
                                          
                                       
                                       ∈
                                       M
                                    
                                 
                              
                              
                                 
                                    D
                                 
                                 
                                    M
                                 
                              
                              (
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    v
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        
                     where 
                        
                           M
                        
                      denotes all the vertices in the mesh. It is easy to get that vertices with the same feature have the same saliency. The time complexity to evaluate the saliency value for all vertices is O(n
                     2), where n is the number of vertices of the mesh. It is computationally expensive even for medium-sized meshes, which greatly prevents its practical use.

To compute the global saliency efficiently, we draw inspiration from the grouping idea of Bie et al. [28] for solving image edit propagation problems. The edits are first solved on clusters of similar pixels and then individual pixel edits are obtained by interpolation from cluster edits. In mesh domain, it is also true that similar vertices are subject to similar global saliency. So we can group vertices into clusters and first compute the cluster saliency to accelerate the global saliency computation. Thanks to our comprehensive feature space formed by multi-scale descriptors, we construct vertex clusters in this space by the K-means clustering method with approximate nearest neighbor (ANN) searching [29]. After similar vertices are grouped into clusters, we induce the cluster saliency from Eq. (8) by replacing the vertices with the center point of its corresponding cluster. The saliency of a cluster could be formulated as:
                        
                           (9)
                           
                              
                                 
                                    S
                                 
                                 
                                    g
                                 
                              
                              (
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       ∑
                                    
                                    
                                       j
                                       =
                                       1
                                    
                                    
                                       K
                                    
                                 
                              
                              d
                              (
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    c
                                 
                                 
                                    j
                                 
                              
                              )
                              
                                 
                                    n
                                 
                                 
                                    j
                                 
                              
                           
                        
                     where c
                     
                        i
                      and c
                     
                        j
                      respectively represent the center point of clusters i and j in the feature space, K is the number of the cluster, n
                     
                        j
                      denotes the number of vertices in cluster j.

After evaluating the saliency of each cluster sample, we obtain individual vertex saliency by simple interpolation. For one given vertex v
                     
                        i
                     , we first find m clusters which are most close to the vertex in the feature space. Let T
                     
                        i
                      denotes these clusters. A smooth saliency is achieved across vertices by:
                        
                           (10)
                           
                              
                                 
                                    S
                                 
                                 
                                    g
                                 
                              
                              (
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              )
                              =
                              
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          u
                                          ∈
                                          
                                             
                                                T
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    
                                       
                                          V
                                       
                                       
                                          iu
                                       
                                    
                                    
                                       
                                          S
                                       
                                       
                                          g
                                       
                                    
                                    (
                                    
                                       
                                          c
                                       
                                       
                                          u
                                       
                                    
                                    )
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          u
                                          ∈
                                          
                                             
                                                T
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    
                                       
                                          V
                                       
                                       
                                          iu
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 V
                              
                              
                                 iu
                              
                           
                           =
                           exp
                           (
                           -
                           d
                           (
                           
                              
                                 M
                              
                              
                                 
                                    
                                       v
                                    
                                    
                                       i
                                    
                                 
                              
                           
                           ,
                           
                              
                                 c
                              
                              
                                 u
                              
                           
                           )
                           /
                           
                              
                                 σ
                              
                              
                                 a
                              
                           
                           )
                        
                      and σ
                     
                        a
                      is set to be 0.3 for all examples. It assigns larger weights to clusters closer to v
                     
                        i
                      in the feature space. In all our experiments, 5 clusters are sufficient to produce good results.

The K-means clustering adaptively samples the dissimilarity space and good results can be achieved within 50 clusters for a general mesh. Much fewer clusters are used than the number of actual vertices, resulting in a dramatic improvement in computational complexity.


                     Fig. 4
                      shows the global saliency result for the lion model. Our method highlights the geometric features which are rare in the whole mesh.

@&#EXPERIMENTAL RESULTS@&#

We totally implemented our mesh saliency detection method and compared it with [7].

To benefit from the advantages of both aspects, local and global saliency are combined by Eq. (1) to get the resulting saliency. According to the application, users can adjust the relative strength of local saliency and global saliency by tuning the weighting factor. Fig. 5
                         shows some results generated by different weighting factors. In our experiments, we set λ
                        =0.5 by default.

For the lion model, our method gives higher saliency value to the face and lower saliency to the hair than Lee et al. [7]. This is reasonable for our global rarity principle. Taking the whole model as context, the feature on the face of lion rare and the hair is just the opposite. For the frequently occurring features, our approach assigns less saliency. Fig. 6
                         shows more comparisons of the saliency maps obtained by our method and Lee et al. [7].

The saliency computation involves two parts, namely the global rarity and the local contrast. We carried out all the examples on a dual-core 2.93GHz machine with 4G memory. For a model with 30K vertices, the K-means clustering accelerated by ANN searching requires about 0.5s, and the interpolation of saliency value from clusters to vertices takes about 0.04s. The computation of the graph segmentation in the local saliency takes about 2.5s. Table 1
                         shows the performance of our saliency detection method.

In order to comprehensively evaluate the effectiveness of our saliency detection method, we propose three applications using our saliency map. We use mesh saliency maps as the importance weighting for mesh smoothing, simplification and sampling.


                        Salient Laplacian mesh smoothing. There is a lot of work on mesh smoothing. Most of these work has been based on geometric properties of mesh, such as normal vector [30,31] and curvature [32,33]. Little attention has been paid to the perception-based metrics, such as the saliency.

We incorporate mesh saliency in Laplacian smoothing operator to verify the effectiveness of our mesh saliency algorithm. We modify the Laplacian mesh smoothing method proposed by Nealen et al. [34] by weighting positional constraints with mesh saliency. Laplacian operator is an efficient method to get smooth mesh. Each vertex in a mesh is relocated to a new position based on the information of its immediate neighbors. Andrew et al. smooth a mesh by solving a linear system with positional and Laplacian.

constraints in all vertices:
                           
                              (11)
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      W
                                                   
                                                   
                                                      L
                                                   
                                                
                                                L
                                             
                                             
                                                
                                                   
                                                      W
                                                   
                                                   
                                                      p
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                                 
                                    
                                       V
                                    
                                    
                                       d
                                    
                                    
                                       ′
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                0
                                             
                                             
                                                
                                                   
                                                      W
                                                   
                                                   
                                                      p
                                                   
                                                
                                                
                                                   
                                                      V
                                                   
                                                   
                                                      d
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where V
                        
                           d
                         and 
                           
                              
                                 
                                    V
                                 
                                 
                                    d
                                 
                                 
                                    ′
                                 
                              
                           
                         respectively represent the original and new vertex positions, L is the Laplacian matrix with uniform weight, the diagonal matrices W
                        
                           L
                         and W
                        
                           p
                         are respectively used as positional weights and Laplacian weights. The weighting matrix W
                        
                           L
                         enforces the smoothness of the mesh. The weighting matrix W
                        
                           p
                         gives positional constraints and preserve the original geometry. We guide the smoothing procedure using weighting matrices W
                        
                           L
                         and W
                        
                           p
                         derived from the mesh saliency map S. It smoothes the mesh while preserving the salient geometric features. We define the weighting matrices:
                           
                              (12)
                              
                                 
                                    
                                       
                                          
                                             
                                                W
                                             
                                             
                                                p
                                             
                                          
                                          (
                                          i
                                          ,
                                          j
                                          )
                                          =
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            s
                                                            ∗
                                                            
                                                               
                                                                  S
                                                               
                                                               
                                                                  i
                                                               
                                                            
                                                            ,
                                                         
                                                         
                                                            i
                                                            =
                                                            j
                                                         
                                                      
                                                      
                                                         
                                                            0
                                                            ,
                                                         
                                                         
                                                            otherwise
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                          
                                             
                                                W
                                             
                                             
                                                L
                                             
                                          
                                          =
                                          sI
                                       
                                    
                                 
                              
                           
                        where the scale factor s was set to 10 for all the saliency-based smoothing experiments in this paper. As shown in Fig. 7
                        , our saliency-based method can better preserve visually important features, rather than the features of large curvature.


                        QEM mesh simplification. Recently, high detailed models are very commonplace in games and movies. Although these high-quality models can present high degree of realism, they consume too many resources, such as storage space and rendering time. So it is very useful to simplify the original models. Mesh saliency identifies visual important regions on mesh and can be used to guide the simplification process which helps to preserve geometric features. We integrate mesh saliency into the quadric error simplification (QEM) method proposed by Garland and Heckbert [35]. Similar to the experiment in [7], we weight the quadric error with mesh saliency. We specify relative importance across mesh regions by saliency map and guide the simplification to appear in relatively non-salient regions while preserving visual important mesh regions. Fig. 8
                         shows the simplification results using our saliency map.


                        Sampling. Our saliency map can be used for saliency-based mesh sampling. We extend the method proposed by Xu et al. [36] for the saliency based sampling. Xu et al. presented a bule noise method based on the concept of Capacity-Constrained surface triangulation (CCST), which approximates the surface as a well-formed triangle mesh with uniform areas. We use mesh saliency as weights and use CCST to get uniform weighted triangle area mesh. After getting the mesh, we project it to the original mesh and get the sampling results. Fig. 9
                         shows our saliency-based sampling results which are consistent with the mesh saliency.

The results of mesh saliency are relatively subjective. To further evaluate the performance of our method, we have conducted two user studies. We adopted the paired comparison technique [37]. It is the two-alternatives forced choice (2AFC) experiment paradigm. We compared the performance of the method of Lee et al. [7] and ours.


                        User study I. In the first user study, the subjects were asked to select one result from two saliency results shown side by side. One of them is the result produced by our method and the other is produced by the method of Lee et al. [7]. The two saliency results are put in a random order.


                        User study II. In the second user study, the subjects were asked to select one result from two saliency-guided simplification results shown side by side. The two simplification results are put in a random order. The original model was shown to the subjects for each simplification pair.


                        Analysis. A total of 72 subjects (47 males and 25 females), whose ages range from 20 to 33, participated in the studies. In the first user study, we chose 6 groups of mesh saliency detection results. In the second user study, we chose 2 groups of mesh simplification results. Fig. 10
                         shows the results of user study I and II. From the results we see that the subjects preferred the results produced by our method than the method of Lee et al.[7]. This is promising. The reason might be that our method identifies visual important regions on mesh and preserves perceptual important features during the simplification process.

@&#LIMITATIONS@&#

There are a few limitations in our mesh saliency detection method. As the local shape descriptor we use is defined in a multi-scale manner, our method is insensitive to a certain amount of noise on the mesh surface. However, the local descriptor might be affected much by large noise on the mesh and thus might affect the final detected saliency results. To alleviate this problem, we could perform a feature preserving smoothing as a pre-processing for noisy models. Our method cannot be implemented in real time due to the slow computation of the multi-scale feature descriptors. However, the local descriptors could be computed in a parallel manner and thus can be accelerated using GPU implementation.

@&#CONCLUSION@&#

We presented a novel approach to mesh saliency computation by two principles of human visual attention, namely local contrast and global rarity. We also provided a simple and efficient algorithm for implementing these two basic principles. The global rarity tries to measure the saliency of each vertex relative to the whole 3D mesh geometry, while the local contrast principle emphasizes those regions that are more distinctive with respect to their local surroundings. Both phases can be computed efficiently. The global one first solves saliency on clusters of similar vertices and then interpolates individual vertex saliency from cluster saliency. In the local one, the mesh is partitioned into patches at first. Each patch saliency is computed and the vertex saliency is computed by interpolating its neighboring patch saliency. Experimental results showed that our method captured most of the visual important regions in meshes, while still being simple and efficient.

In the future, we plan to incorporate our method into solving the problem of co-saliency detection, i.e., to find the common salient features that are presented in series of input models. It is also desirable to add face and symmetry detection into mesh saliency detection.

@&#ACKNOWLEDGEMENTS@&#

This work is supported by the National Natural Science Foundation of China (61070071, 61222206) and the National Basic Research Program of China (2011CB302400).

Supplementary data associated with this article can be found, in the online version, at http://dx.doi.org/10.1016/j.gmod.2013.05.002.


                     
                        
                           Supplementary materials
                           
                        
                     
                  

@&#REFERENCES@&#

