@&#MAIN-TITLE@&#On the integration of interest and power awareness in social-aware opportunistic forwarding algorithms

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Integrating interest and power awareness into opp. social forwarding algorithms.


                        
                        
                           
                           PI-SOFA integrates with the SocialCast, PeopleRank and SCAR algorithms.


                        
                        
                           
                           Our algorithms outperform the Epidemic, Profilecast and EBubbleRap algorithms.


                        
                        
                           
                           Performance metrics are effectiveness, efficiency, power consumption, and fairness.


                        
                        
                           
                           Real-data simulations show 500% more fmeasure, preserve 8% power with 41% less cost.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Social-aware opportunistic forwarding

Interest awareness

Power awareness

Effectiveness

Efficiency

@&#ABSTRACT@&#


               
               
                  Social-aware Opportunistic forwarding algorithms are much needed in environments which lack network infrastructure or in those that are susceptible to frequent disruptions. However, most of these algorithms are oblivious to both the user’s interest in the forwarded content and the limited power resources of the available mobile nodes. This paper proposes PI-SOFA, a framework for integrating the awareness of both interest and power capability of a candidate node within the forwarding decision process. Furthermore, the framework adapts its forwarding decisions to the expected contact duration between message carriers and candidate nodes. The proposed framework is applied to three state-of-the-art social-aware opportunistic forwarding algorithms that target mobile opportunistic message delivery. A simulation-based performance evaluation demonstrates the improved effectiveness, efficiency, reduction of power consumption, and fair utilization of the proposed versions in comparison to those of the original algorithms. The results show more than 500% extra f-measure, mainly by disregarding uninterested nodes while focusing on the potentially interested ones. Moreover, power awareness preserves up to 8% power with 41% less cost to attain higher utilization fairness by focusing on power-capable interested nodes. Finally, this paper analyzes the proposed algorithms’ performance across various environments. These findings can benefit message delivery in opportunistic mobile networks.
               
            

@&#INTRODUCTION@&#

Exponential advancements in mobile technologies – in terms of advanced sensors and various wireless network capabilities – have enriched mobile devices with intelligent features, making them the ideal candidates for pervasive systems. In parallel, social networks with their seamless accessibility from mobile devices have given rise to a gold mine of contextual information [1,2]. The resulting ecosystem that merges the social world with the mobile world, all supported by associated technologies, enables a set of smart services and applications. However, with the current 0.9 Exabytes mobile data volume that is expected to reach 11.2 Exabytes in 2017 [3], network infrastructure becomes overloaded, and users experience occasional network service contention or unavailability. Despite the ubiquitous network advantages that have reached LTE and 4G, some connectivity problems pop up such as: users suffer from rising cost of service delivery [4]; not all devices are connected with predefined routes; and not all places are reachable. These obstacles have motivated ad-hoc communications [5], delay tolerant networks [6], and opportunistic networks [7] to act as a complementary infrastructure that enables communication in environments with disruptive connections. Therefore, reliance on ad-hoc connections among mobile nodes to forward content in a local area offers partial relief from network infrastructure overload.

Given the evolving ecosystem, merging mobile technologies and social networking, social-aware opportunistic forwarding algorithms [8–10] represent one of the most promising approaches for ad-hoc communications. These algorithms take advantage of social relationships among mobile holders in a given place to forward messages accordingly. Surveying state-of-the-art work, available forwarding algorithms can be classified into three main categories: (1) the power-oblivious social-aware opportunistic forwarding algorithms which rely on social awareness and interest, but do not pay attention to power awareness when making forwarding decisions [8–11]; (2) the social-oblivious power-aware and energy-efficient routing algorithms [12–14] which seek efficient energy routes, but do not capitalize on other contextual information such as contact frequency, mobility patterns, and usage profile of the devices; (3) the social-oblivious power and context-aware opportunistic forwarding algorithms which consider power and context information, but do not exploit social information [15,16]. The forwarding algorithms target either a single destination or a group of nodes. The group-oriented forwarding algorithms identify destination nodes based on either their node IDs or a common profile. Our research domain targets the profile-based forwarding algorithms developed for mobile opportunistic message delivery. In order to forward content among mobile nodes, these algorithms currently compute a rank per node to select the optimum forwarder nodes [17]. Social forwarding algorithms include the node’s social rank in making the forwarding decision. However, most of these algorithms encounter a set of challenges in maintaining effectiveness and efficiency in performance. In previous work conducted, we reviewed the challenges facing these algorithms and focused on four main challenges [18]: the incentive-oblivious forwarder selection process; the overlooking of the power capabilities of the nodes in place; the limited contact durations among nodes; and, the forwarding algorithms’ unfair utilization of the nodes’ resources.

This research proposes PI-SOFA, a framework for integrating interest awareness and power awareness in profile-based social opportunistic forwarding algorithms. This framework integrates three main factors in making forwarding decisions: user interest in the forwarded content, user’s social rank, and power capability of the candidate node. The expected contact duration between the message carrier and the candidate forwarder may also be included when making forwarding decisions.

Our framework consists of three modules:

The first module elicits interest awareness when making forwarding decisions to facilitate content dissemination to groups of interested nodes. Being aware of users’ relative interest in the forwarded content, the forwarding algorithms are able to mainly approach interested users and avoid overwhelming uninterested ones, thus significantly reducing the cost wasted in massive information dissemination to uninterested recipients. This module mainly improves the effectiveness of the forwarding algorithm. Besides, it is necessary to bring in an incentive to motivate nodes in the forwarding process participation. Our framework proposes users’ relative interest in the forwarded content as an effective incentive to participate in forwarding, since users will also benefit by receiving this same content which is of partial interest to them. The proposed paradigm is an interest-aware version of any social forwarding algorithm that rewards or penalizes the node’s social rank based on its relative interest in the forwarded content.

The second module, on the other hand, integrates the awareness of the candidate node’s power capabilities when making forwarding decisions. This integration directs the forwarding algorithm to rely on power-capable nodes as content forwarders through rewarding or penalizing the node’s social rank based on both its power capability and its relative interest. This module reduces the overall power consumption and improves the utilization fairness of the forwarding algorithm. This approach incorporates interest and power awareness in both the ranking and the forward decision making of the social-aware forwarding algorithms to overcome four main challenges facing these algorithms: (1) the forwarder selection process is incentive-oblivious; (2) power-oblivion of the social forwarding approaches in the forwarder selection process may lead to the nodes’ inability to sustain the forwarding process accomplishment; (3) power-fairness-oblivious forwarding algorithms over-utilize some forwarder nodes while lightly utilizing others; (4) overlooking the contact duration sufficiency between the encountered nodes for complete message transfer leads to a waste of non-trivial resources.

Finally, the third module integrates a threshold-based opportunistic forwarding to the two above integrations. This module improves the effectiveness and the efficiency of the forwarding algorithm. This extra option opens the door for guided opportunistic forwarder selection; the relatively interested users who own power capable nodes are given higher priority in the next content forwarders selection, even if they do not satisfy the other selection criteria. Being interested in the content and being power capable, these forwarders have a higher probability of meeting destination nodes and of sustaining forwarding within the content time-to-live.

The proposed framework is applied to three social-aware forwarding algorithms developed for mobile opportunistic message delivery, namely, PeopleRank [11], SocialCast [10] and SCAR [15]. First, the integration of interest awareness in the ‘power-and-interest-insensitive’ algorithms is proposed via the power-oblivious interest-aware versions: IPeR [19], ISCast and ISCAR. Next, the integration of power awareness is applied via the power and interest-aware PIPeR [20], PISCast and PISCAR algorithms. Finally, the inclusion of the threshold-based opportunistic forwarding is illustrated via the PIPeROp [20], PISCastOp and PISCAROp versions.

PI-SOFA framework is then evaluated via realistic simulations using our developed simulator. These simulations utilize datasets that include both realistic [21,22] and synthesized mobility traces [23], social profiles [21], social relationships [24], power consumption models [25,26], and data that are generated by our simulator. Moreover, evaluation metrics are devised for performance comparison to measure the algorithms’ effectiveness, efficiency, power consumption, and utilization fairness. The results of the simulation-based evaluation are as follows: (1) integrating interest awareness into the social aware forwarding achieves up to 560% extra f-measure by precluding uninterested nodes and focusing on potentially interested ones; (2) introducing power awareness consumes 8% less power and 41% less cost to attain higher fairness in power utilization. This is achievable via focusing on power-capable interested nodes; (3) having accurate contact-duration expectations reduces 8% of the consumed power and time wasted in incomplete message transfers between nodes. After that, a set of normalized performance indices is proposed to help evaluate the performance of the presented algorithms across various environment setups. The proposed performance indices can guide advertisement/announcement senders in choosing the optimum algorithm depending on the environment in which the ad will be forwarded. Overall, the proposed versions promote a trade-off between delivery ratio and delay on one hand, and power preservation and fair utilization on the other.

The rest of this paper is organized as follows: Section 2 details the related work in this domain; Section 3 presents the proposed framework; Section 4 presents case studies of interest and power awareness; Sections 5 and 6 present the simulation-based evaluation and results; Section 7 concludes the discussion.

@&#RELATED WORK@&#

After surveying research work in the field of power and social awareness, we have found a shortage in the forwarding approaches work that combines both social awareness and power awareness. We therefore classify the current research into three categories:

Many social aware forwarding algorithms do not take into account power awareness in forwarding. These algorithms rank nodes upon any or combination of the following social metrics: the nodes’ social popularity [11]; common interests [19,27,28]; common mobility behavior [9]; community-based metrics [29,30]; and, activeness in connectivity with other nodes [10]. In all these ranking metrics, the highly ranked nodes are the ones forming better candidates to deliver messages to destinations, given that there is a higher probability that such nodes will encounter destination nodes more rapidly. This category of algorithms favors the highly ranked nodes. However, some of these algorithms balance between social awareness and opportunistic selection of forwarder nodes, such as PeopleRank [11] and IPeR [19]; these algorithms sustain delivery in socially-unrelated communities. Furthermore, very few algorithms introduce the concept of relying on nodes that have similar interest to that of the forwarded content as presented by IPeR [19] in our previous work, and by the interest-aware content distribution in DTN algorithm [28].

From another aspect, the social-aware forwarding algorithms are classified based on the way they identify the destination nodes: pre-identified target algorithms or profile-based target algorithms. The first group targets specific destination nodes by their explicit identification [8,10,11,31], while the second group targets groups of destination nodes by their social/mobility-behavioral profiles [9,19].

Few social-aware forwarding protocols mention awareness of the node’s remaining power as a sort of context awareness, such as SocialCast [10]; also, they still do not conduct proofs or experiments for such integration of power and context awareness. From our analysis of SocialCast, we find it consuming both computationally and storage-wise to keep records of the nodes co-location with any subscriber on real-time basis besides maintaining its mobility pattern history. Furthermore, SocialCast consumes the network through communications for the exchange of control messages among all the nodes in a specific area.

Due to the energy constraints placed on nodes in ad hoc networks, designing power-aware routing protocols is crucial to maximize the lifetime of both the nodes and the network itself. Some of these protocols target routes that cost the least power to minimize power consumption, yet they may deplete the battery of some forwarder nodes, thus reducing network lifetime [32,33]. Other approaches, such as PILOT [12], may use a route that consumes higher power to avoid using nodes whose batteries are depleting. Such approaches mainly maintain energy efficiency by combining the awareness of the node’s power with another cost function for the forwarder selection process [14]. However, all these algorithms overlook the social relationships in forwarding decisions.

To maximize the network lifetime, power awareness and lifetime prediction routing protocols seek routes that minimize the variance among the nodes’ remaining power. Such protocols improve the network lifetime, yet they tend to create additional control traffic [34]. Seeking fairness via minimizing the energy consumed per node, some protocols such as CMMBCR [13] choose the minimal total transmission power route where the remaining power of all the nodes exceeds a certain threshold value; otherwise, route selection is based on another cost function. However, the performance of such algorithms varies according to the selected threshold value [34,35].

However, in mobile opportunistic networks, connections between mobile nodes are transient leading to unstable route connections. Alternative solutions seek one-to-one hop connections among these mobile nodes. So far very few energy-aware contributions are made in this area such as the energy-aware BUBBLE Rap forwarding algorithm [36] and The energy-aware social-based multicast algorithm [37]. Both algorithms combine socially-aware routing with energy consumption optimization. However, these algorithms do not incorporate awareness of the forwarder node’s interest in the forwarded content.

The majority of the proposed context and power aware routing protocols do not consider social information in decision-making and mainly operate on static sensor networks or wireless ad hoc networks [16]. For instance, the context aware opportunistic routing protocol, SCAR [15], allows efficient routing of mobile sensor data to the destination nodes via the best path selection. SCAR relies on the candidate nodes’ collocation history with destination nodes, on their change degree of connectivity, and on their current power in path selection, without considering social awareness. Similar to SocialCast, SCAR consumes the network by the regular exchange of control messages among all the nodes present in the place. Furthermore, as a result of the limited power resources of the sensor nodes in wireless sensor networks (WSN), many power-aware and energy-efficient routing protocols propose solutions for WSN with rare attention paid to opportunistic networks [16].

However, most of those algorithms encounter a set of challenges towards maintaining effectiveness and efficiency in performance. In previous research work done [18], we reviewed the challenges encountered by these algorithms and focused on four main categories of challenges: (1) the incentive-oblivious forwarder selection process; (2) overlooking the power capabilities of the nodes in place; (3) the limited contact durations among nodes; (4) the forwarding algorithms’ unfair utilization of the nodes’ resources.

To the best of our knowledge, this current paper is the first attempt to integrate interest awareness and power awareness in social-based opportunistic forwarding algorithms. It is also the first one to propose an integrated solution for the challenges mentioned above.

This section presents our vision of a framework that enables integrating interest and power awareness both in ranking the nodes and in the decision process within social-aware opportunistic forwarding algorithms. First, interest integration in this process is introduced. Then, power integration in the ranking and decision making process is demonstrated. Finally, integration of threshold-based opportunistic forwarder selection is proposed. This framework is applicable for social-aware opportunistic forwarding in one-to-one hop mobile opportunistic networks in areas such as shopping malls, a university campus, an airport or a conference where Wifi or Bluetooth connection among mobile nodes enables the message forward for a soft-real time delivery within a couple of hours.

Integration of interest awareness in social-aware forwarding algorithms is simply based on rewarding (or penalizing) the social rank of the nodes based on their potential interest in the forwarded message. Worth mentioning throughout the paper reference to nodes’ interest indicates one-to-one relationship between the user’s interest and the node’s interest. The potentially interested nodes are the nodes whose interest profiles have partial commonality with the forwarded message’s interest profile. After eliciting the interest of the nodes and of the forwarded message, and depicting it in the form of an interest vector, [S]imilarity [I]nterest (SInt) is then measured using the Jaccard set similarity index [38] where the Jaccard similarity index for interest sets X and Y is:

                           
                              (1)
                              
                                 
                                    J
                                    a
                                    c
                                    c
                                    a
                                    r
                                    d
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                    =
                                    
                                       
                                          |
                                          x
                                          ∩
                                          y
                                          |
                                       
                                       
                                          |
                                          x
                                          ∪
                                          y
                                          |
                                       
                                    
                                 
                              
                           
                        If their similarity index exceeds a certain threshold, the social rank of the candidate node is rewarded, and de-rewarded otherwise. This [P]enalized [S]imilarity [I]nterest (PSInt) is computed as follows:

                           
                              (2)
                              
                                 
                                    P
                                    S
                                    I
                                    n
                                    t
                                    
                                       (
                                       j
                                       ,
                                       A
                                       d
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   (
                                                   S
                                                   I
                                                   n
                                                   t
                                                   (
                                                   j
                                                   ,
                                                   M
                                                   s
                                                   g
                                                   )
                                                   +
                                                   r
                                                   e
                                                   w
                                                   a
                                                   r
                                                   d
                                                   )
                                                
                                             
                                             
                                                
                                                   if
                                                   
                                                   S
                                                   I
                                                   n
                                                   t
                                                   ≥
                                                   
                                                      thr
                                                      
                                                         I
                                                         n
                                                         t
                                                      
                                                   
                                                   ,
                                                
                                             
                                          
                                          
                                             
                                                
                                                   (
                                                   S
                                                   I
                                                   n
                                                   t
                                                   (
                                                   j
                                                   ,
                                                   M
                                                   s
                                                   g
                                                   )
                                                   −
                                                   r
                                                   e
                                                   w
                                                   a
                                                   r
                                                   d
                                                   )
                                                
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where SInt(j, Ad) is Similarity Interest and computed by the Jaccard set similarity between the user’s interest vector IntFV(node) and the message specialization interest vector IntFV(Msg). It is rewarded by a predefined value reward and penalized by deducting it.

For further interest awareness, not only does the algorithm consider the potential node’s interest in rewarding its social rank, but also the algorithm includes its friends’ rewarded interest. This takes place through computing the cumulative interest of the nodes and its friends which computes the average value of the PSInt of the node and the values of the PSInt of its friends. Thus, highly selected forwarder candidates are those with high social rank and as well such that they and their friends have interest in the same message.

                           
                              (3)
                              
                                 
                                    FrInter
                                    
                                       (
                                       i
                                       ,
                                       A
                                       d
                                       )
                                    
                                    =
                                    
                                       
                                          P
                                          S
                                          I
                                          n
                                          t
                                          
                                             (
                                             i
                                             ,
                                             A
                                             d
                                             )
                                          
                                          +
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                F
                                                (
                                                i
                                                )
                                             
                                          
                                          P
                                          S
                                          I
                                          n
                                          t
                                          
                                             (
                                             j
                                             ,
                                             A
                                             d
                                             )
                                          
                                       
                                       
                                          |
                                          F
                                          (
                                          i
                                          )
                                          |
                                          +
                                          1
                                       
                                    
                                 
                              
                           
                        Assume Rank(i) is the rank of the node that is computed by any social-aware forwarding algorithm. This rank is rewarded/penalized by FrInter(i, Ad) according to the following formula:

                           
                              (4)
                              
                                 
                                    I
                                    u
                                    t
                                    i
                                    l
                                    (
                                    i
                                    ,
                                    A
                                    d
                                    )
                                    =
                                    F
                                    r
                                    I
                                    n
                                    t
                                    e
                                    r
                                    (
                                    i
                                    ,
                                    A
                                    d
                                    )
                                    *
                                    R
                                    a
                                    n
                                    k
                                    (
                                    i
                                    )
                                 
                              
                           
                        
                     

To achieve fairness in utilizing the power of the nodes in the place, the social-aware forwarding algorithm has to maintain awareness of the nodes’ current power resources and the expected power consumption upon their participation in the message forward process. Accordingly, the algorithm favors the nodes with higher power capabilities that can sustain the delivery till completion, and avoids exhausting the nodes with poor power capabilities. There are several measures to achieve this power awareness in forwarder selection.

The power-aware forwarding algorithm checks the remaining power level of the candidate nodes to pick the wealthy nodes and avoid the poor ones. This is maintained by rewarding/penalizing the node’s rank as per its remaining power level. If the node’s remaining power level exceeds a predefined battery threshold Thrbat
                           , its rank is rewarded and becomes a candidate for participation in the forwarding process. On the other hand, if its power level is less than Thrbat
                           , its rank is penalized and the algorithm avoids utilizing it in the forward process. For this reason, the application fixes a battery threshold above which the ‘wealthy’ members of the community become suitable candidates to forward the ad. Thus, the ranking function of the nodes is computed as follows:

                              
                                 (5)
                                 
                                    
                                       P
                                       I
                                       u
                                       t
                                       i
                                       l
                                       (
                                       i
                                       ,
                                       A
                                       d
                                       )
                                       =
                                       R
                                       e
                                       w
                                       a
                                       r
                                       d
                                       e
                                       d
                                       P
                                       o
                                       w
                                       e
                                       r
                                       (
                                       i
                                       )
                                       *
                                       I
                                       u
                                       t
                                       i
                                       l
                                       (
                                       i
                                       ,
                                       A
                                       d
                                       )
                                    
                                 
                              
                           where

                              
                                 (6)
                                 
                                    
                                       R
                                       e
                                       w
                                       a
                                       r
                                       d
                                       e
                                       d
                                       P
                                       o
                                       w
                                       e
                                       r
                                       
                                          (
                                          i
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      (
                                                      B
                                                      a
                                                      t
                                                      (
                                                      i
                                                      )
                                                      +
                                                      r
                                                      e
                                                      w
                                                      a
                                                      r
                                                      d
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      B
                                                      a
                                                      t
                                                      ≥
                                                      T
                                                      h
                                                      
                                                         r
                                                         
                                                            b
                                                            a
                                                            t
                                                         
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      (
                                                      B
                                                      a
                                                      t
                                                      (
                                                      i
                                                      )
                                                      −
                                                      r
                                                      e
                                                      w
                                                      a
                                                      r
                                                      d
                                                      )
                                                   
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

To attain fair utilization of the nodes resources among the community, the algorithm should not over utilize the resources of some nodes while other nodes are not utilized in the forward process at all. This fair utilization is maintained through monitoring the power level of the participating nodes. The target of fair utilization is to attain a small variation among the nodes power capabilities at the end of the delivery process. This is achieved from two perspectives. On one side, the candidate selection process favors the power capable nodes as per the earlier mentioned selection criteria. On the other side, the algorithm always maintains a minimum threshold for the participating nodes’ battery level; if the power of a message carrier node approaches the predefined threshold Thrbat
                           , it ceases participation in the message forward process.

During the forward process a significant portion of the consumed power is wasted in incomplete message transfers. The forwarding algorithm does not take into consideration the wasted time and wasted power resources due to its ignorance of the expected contact duration between the carrier and the selected forwarder node. For a successful message transfer between two nodes, they need to remain in contact long enough for the message transfer. Assume the least contact duration required for successful message transfer is transferTime. A power effective forwarding algorithm should consider the candidates expected to stay in contact with the message carrier at least transferTime, otherwise the algorithm avoids selecting these candidates. This concept is attained by satisfying the following condition:

                              
                                 (7)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                P
                                                r
                                                e
                                                d
                                                i
                                                c
                                                t
                                                e
                                                d
                                                C
                                                o
                                                n
                                                t
                                                a
                                                c
                                                t
                                                T
                                                i
                                                m
                                                e
                                                (
                                                i
                                                ,
                                                j
                                                )
                                                +
                                                ElapsedContactTime
                                                (
                                                i
                                                ,
                                                j
                                                )
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                ≥
                                                transferTime
                                                (
                                                A
                                                d
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           where PredictedContactTime(i, j) is the predicted remaining duration of contact between the message carrier i and the candidate forwarder j as per any time prediction mechanism. ElapsedContactTime(i, j) is the time elapsed since the two nodes got in contact, and transferTime(Ad) is the time required to transfer the message from node i to node j. Hence, the algorithm favors the candidate nodes that are expected to remain in contact enough duration for the message transfer. There are several time prediction mechanisms proposed by other researchers [23,39,40]. The more accurate the prediction mechanism is, the less occurrence of incomplete transfers and thus preserving power.

This version adds an extra opportunistic portion of the candidate selection process. This is achieved by forwarding the ad to any interested forwarder whose battery level is above the fixed threshold Thrbat
                        . These favored forwarders need not be socially popular users, but rather be power-capable interested forwarders. In this version, the forwarding decision logic is an OR function between the power-aware rank of the candidate node on one side and the comparison of its SInt and its Power capability against the preset thresholds on the other side. In other words, a candidate is selected if either its rank is higher than the current message holder or if both its SInt is above the interested forwarder threshold thrInt
                         and its Power capability exceeds the battery threshold Thrbat
                         as presented in the following conditions.

                           
                              (8)
                              
                                 
                                    
                                       
                                          
                                             PIutil
                                             (
                                             j
                                             ,
                                             A
                                             d
                                             )
                                          
                                       
                                       
                                          ≥
                                       
                                       
                                          
                                             PIutil
                                             
                                                (
                                                i
                                                ,
                                                A
                                                d
                                                )
                                             
                                             ∥
                                             (
                                             S
                                             I
                                             n
                                             t
                                             
                                                (
                                                j
                                                ,
                                                A
                                                d
                                                )
                                             
                                             ≥
                                             
                                                thr
                                                
                                                   I
                                                   n
                                                   t
                                                
                                             
                                             A
                                             N
                                             D
                                             B
                                             a
                                             t
                                             
                                                (
                                                j
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          ≥
                                       
                                       
                                          
                                             
                                                Thr
                                                
                                                   b
                                                   a
                                                   t
                                                
                                             
                                             
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This section presents empirical interest integration with social-aware forwarding algorithms. We first briefly demonstrate three prominent social-aware opportunistic forwarding approaches: PeopleRank, SocialCast and SCAR. For each of them we propose the interest-aware versions: IPeR, ISCast and ISCAR, respectively. Incrementally we propose their power-and-interest aware versions: PIPeR, PISCast and PISCAR. We also propose the threshold opportunistic versions: PIPeROp, PISCastOp and PISCAROp as shown in Table 1
                     .


                        PeopleRank 
                        [11] is a recently introduced message forwarding algorithm based on forwarding messages utilizing the socially popular people nodes in place. PeopleRank relies on the hypothesis that socially popular nodes form better candidates to deliver messages to destinations given that there is a higher probability that such nodes will encounter destinations more quickly. Nodes are socially ranked as per their social relationship whether through a declared friendship, or if they share common interests. This paper improves the contact-aware version of PeopleRank (CA-PeR) which is computed as follows:

                           
                              (9)
                              
                                 
                                    C
                                    A
                                    −
                                    P
                                    e
                                    R
                                    
                                       (
                                       i
                                       )
                                    
                                    =
                                    
                                       (
                                       1
                                       −
                                       d
                                       )
                                    
                                    +
                                    d
                                    *
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          F
                                          (
                                          i
                                          )
                                       
                                    
                                    
                                       
                                          C
                                          A
                                          −
                                          P
                                          e
                                          R
                                          
                                             (
                                             j
                                             )
                                          
                                          *
                                          
                                             w
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                       
                                       
                                          |
                                          F
                                          (
                                          j
                                          )
                                          |
                                       
                                    
                                 
                              
                           
                        
                        d is the damping factor, 
                           
                              C
                              A
                              −
                              P
                              e
                              R
                              (
                              j
                              )
                           
                         is friend j’s PeopleRank value, F(i) is the set of friends of node i who are available in vicinity, w
                        
                           i, j
                         is the contact-component and computed by the following equation.

                           
                              (10)
                              
                                 
                                    
                                       w
                                       
                                          i
                                          ,
                                          j
                                       
                                    
                                    =
                                    
                                       
                                          
                                             |
                                          
                                          
                                             encounters
                                             
                                                i
                                                ,
                                                j
                                             
                                          
                                          
                                             |
                                          
                                       
                                       
                                          
                                             ∑
                                             
                                                k
                                                ∈
                                                F
                                                (
                                                i
                                                )
                                             
                                          
                                          
                                             |
                                             
                                                encounters
                                                
                                                   i
                                                   ,
                                                   k
                                                
                                             
                                             |
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Through IPeR [20], we explore the effect of integrating social interest with the forwarding process of the social-based ranking PeopleRank (CA-PeR) algorithm. IPeR introduces another parameter in ranking the nodes besides the typical social ranking and activeness used in the CA-PeR version. In specific, to consider a node for forwarding a message such as an advertisement, we compute the similarity in interest between the candidate forwarding node and the forwarded advertisement message, and use this information for further decision making. IPeR integrates the SInt (Similarity Interest) parameter into the CA-PeR ranking function to accommodate not only social ranking, but also an “interest-aware” social ranking component. The damping factor (d) used in CA-PeR will also still determine the amount of reliance on both mere opportunistic forwarding and the new interest-aware social ranking component we coined. Interest-aware social ranking consists of the usual social ranking component of CA-PeR which will now be rewarded if there is interest similarity in place, and penalized otherwise.

The higher the rank of a node and of its contacts, the more likely a node becomes a candidate for message forwarding. A candidate node is highly ranked if it is linked to popular friends and also if the node and its friends are partially interested in the forwarded content. The following equation formalizes this concept.

                              
                                 (11)
                                 
                                    
                                       
                                          
                                             
                                                I
                                                P
                                                e
                                                R
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                =
                                                
                                                   (
                                                   1
                                                   −
                                                   d
                                                   )
                                                
                                                +
                                                d
                                                *
                                                FrInter
                                                
                                                   (
                                                   i
                                                   ,
                                                   M
                                                   s
                                                   g
                                                   )
                                                
                                                *
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      F
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                                
                                                   
                                                      C
                                                      A
                                                      −
                                                      P
                                                      e
                                                      R
                                                      
                                                         (
                                                         j
                                                         )
                                                      
                                                      *
                                                      
                                                         w
                                                         
                                                            i
                                                            ,
                                                            j
                                                         
                                                      
                                                   
                                                   
                                                      |
                                                      F
                                                      (
                                                      j
                                                      )
                                                      |
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where FrInter( j, Msg) is the Penalized Similar Interest which is computed as per equation (3). Thus, IPeR magnifies the node’s social rank if the node and its friends are interested in the message above a certain interest threshold thrInt
                            and penalizes the rank otherwise.

According to the logic of the IPeR Algorithm, first, the nodes that initiate an advertisement message (advertisers) rank the users in proximity using the IPeR function based on their candidacy to forward the advertisement message. The advertiser then sends the message to the ‘interested forwarders’ whose Similarity interest SInt(j, Ad) is beyond a certain threshold. As these forwarders encounter other nodes, they check their interest, their social rank, whether they have already received this message or not, and their willingness to forward it to others along their way. In case of match, they forward the message to the new candidates. This process is repeated until the target time duration t expires or the target number of recipients is achieved.

Through PIPeR [20], we explore the effect of integrating power awareness with the interest-based social forwarding process of the IPeR algorithm. Accordingly PIPeR introduces another parameter in ranking the nodes besides the interest-aware social ranking and activeness used in IPeR. In specific, to consider a mobile node for forwarding an ad, the algorithm elicits the candidate node’s available battery level, and uses this information as a means of indicating the node’s willingness to forward.

PIPeR emphasizes power awareness through rewarding the node whose battery level is above a certain battery threshold, and penalizes it otherwise. Accordingly a candidate node is highly ranked if the following conditions are fulfilled: its battery is above a certain threshold, its owner is linked to popular friends, and the node owner and their friends are interested in the message. Thus, the higher the rank of a mobile node and its contacts are, the more likely a node becomes a candidate for forwarding the ad. The node’s power-aware rank PIPeR is formalized by this equation.

                              
                                 (12)
                                 
                                    
                                       P
                                       I
                                       P
                                       e
                                       R
                                       
                                          (
                                          i
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      (
                                                      B
                                                      a
                                                      t
                                                      (
                                                      i
                                                      )
                                                      +
                                                      r
                                                      e
                                                      w
                                                      a
                                                      r
                                                      d
                                                      )
                                                      *
                                                      I
                                                      P
                                                      e
                                                      R
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      B
                                                      a
                                                      t
                                                      
                                                         (
                                                         i
                                                         )
                                                      
                                                      ≥
                                                      
                                                         Thr
                                                         
                                                            b
                                                            a
                                                            t
                                                         
                                                      
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      (
                                                      B
                                                      a
                                                      t
                                                      (
                                                      i
                                                      )
                                                      −
                                                      r
                                                      e
                                                      w
                                                      a
                                                      r
                                                      d
                                                      )
                                                      *
                                                      I
                                                      P
                                                      e
                                                      R
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where IPeR is the interest-aware version of PeopleRank and is computed as per Eq. (11).

According to the logic of the PIPeR Algorithm, first, the advertiser node ranks the users in proximity using the PIPeR function based on their candidacy to forward the ad. The advertiser then sends the ad to the “power-capable interested forwarders” whose Similarity Interest SInt(j, Ad) is beyond a certain threshold and whose PIPeR value is rewarded by its current battery level for exceeding the battery threshold Thrbat
                           . As these new ad holders encounter other nodes, they check their interest, social rank, battery level, and whether they have already received this ad or not. In case of match, they forward the ad to the new candidates. This process is repeated until the target time duration t expires or the target number of recipients is achieved. Any ad carrier node whose battery level goes below the preset battery threshold ceases to scan or forward ads to avoid depleting the remaining battery level.

To explain in detail as shown in Algorithm 1
                           , initially, all the nodes’ PIPeR values favor opportunistic forwarder selection i.e. 
                              
                                 P
                                 I
                                 P
                                 e
                                 R
                                 =
                                 (
                                 1
                                 −
                                 d
                                 )
                              
                           . Whenever two nodes come in contact and if their owners are friends, the nodes exchange 4 pieces of information: their PIPeR values, the count of each one’s friends |F(i)|, their interest feature vectors IntFV(i), and the nodes’ current battery levels. The exchanged information is used in updating their PIPeR ranks as per Eq. (2) (as shown in lines 3–8). Whenever an ad holder i comes in contact with another node j, they exchange their current PIPeR ranks, and node i sends the ad interest vector IntFV(Ad) to node j to receive the computed SInt(j, Ad) (lines 9–11). If node j belongs to the destination set of this ad (line 12), node i delivers a copy of the ad to node j. If node j is not a destination node but its PIPeR rank and similarity interest exceed those of node i, then node i forwards a copy of the ad to node j (lines 12 and 13). Note that the PIPeR algorithm sets Scanning-Condition to bat(j) ≥ Thrbat
                            in code line 9.

The PIPeROp approach sets the Opportunistic-Interest-Condition to the condition bat(j) ≥ Thrbat
                            and SInt(j, Ad) ≥ Interested-Forwarder-Threshold in code line 12. Accordingly, this algorithm selects the next message holder to be any candidate whose similarity interest with the ad exceeds the interested forwarder threshold and as well whose node power is above the battery threshold. In addition, it selects any candidate whose power-aware rank is not less than the current message holder.


                        SocialCast 
                        [10] is an interest-based routing protocol in DTNs supporting publish-subscribe mechanism. It uses prediction-based mechanism to guide in the ad holder selection, combined with store-and-forward to cope with intermittently connected networks. SocialCast relies on observing previous co-location and mobility patterns to predict the next mobility patterns of the users using Kalman filter forecasting techniques [39] to select the best carriers that can forward messages from the publisher to the interested subscribers. SocialCast complements the information about the receivers’ interests, which is necessary to route information, with data about the social ties among people and their consequent predicted movements. Generally speaking, SocialCast selects the carriers whose predicted mobility pattern will most probably get them in contact with any of the destination nodes. That is, SocialCast relies on the higher probability of the forwarder candidate’s co-location with the destination nodes as well as relying on its change degree of connectivity to select the best forwarder nodes. With a closer look, SocialCast builds a utility rank per node that is computed as shown in Eq. (13).

                           
                              (13)
                              
                                 
                                    util
                                    
                                       (
                                       i
                                       )
                                    
                                    =
                                    
                                       w
                                       
                                          c
                                          o
                                          l
                                       
                                    
                                    *
                                    
                                       P
                                       
                                          c
                                          o
                                          l
                                       
                                    
                                    
                                       (
                                       i
                                       )
                                    
                                    +
                                    
                                       w
                                       
                                          c
                                          d
                                          c
                                       
                                    
                                    *
                                    
                                       P
                                       
                                          c
                                          d
                                          c
                                       
                                    
                                    
                                       (
                                       i
                                       )
                                    
                                 
                              
                           
                        where Pcol
                        (i) and Pcdc
                        (i) are the predicted co-location of node i with any of the destination nodes, and the predicted Change Degree Of Connectivity of node i. The weights wcol
                         and wcdc
                        , respectively represent the relative importance of the co-location attribute and the change of degree of connectivity attribute.

It is worth noting that SocialCast is restrictive in forwarder selection for 2 reasons: It allows each node to forward only one copy of the message, as well it allows only the best candidate among the group of currently contacted nodes to get this message copy.

ISCast presents a forwarding process that is aware of the node’s interest in the forwarded message without reliance on the interests of the node’s friends. This type of forwarding is applicable in areas where co-location of the node and its friends is rare or at least is not the norm. The ISCast algorithm introduces interest awareness in the forwarder node selection process by rewarding/penalizing the utility rank of the node based on the node’s penalized similarity interest PSInt(i, Ad), which is computed by equation (2).

Thus, ISCast magnifies the node’s social rank if the node is interested in the message above a certain interest threshold thrInt
                            and it is penalized otherwise. Then the utility value of the node util(i) is weighed by PSInt(i, Ad) to produce the interest-aware utility value of the node as shown in Eq. (14).

                              
                                 (14)
                                 
                                    
                                       Iutil
                                       (
                                       i
                                       ,
                                       A
                                       d
                                       )
                                       =
                                       P
                                       S
                                       I
                                       n
                                       t
                                       (
                                       i
                                       ,
                                       A
                                       d
                                       )
                                       *
                                       util
                                       (
                                       i
                                       )
                                    
                                 
                              
                           
                        

When the message holder i encounters node j, it forwards the ad if node j satisfies either of the following conditions: (1) SInt(j, Ad) is above the Interested-Forwarder-Threshold; (2) Iutil(j, Ad) exceeds Iutil(i, Ad) and as well exceeds Iutil of all the nodes k that node i is in contact with now.

                              
                                 (15)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                S
                                                I
                                                n
                                                t
                                                
                                                   (
                                                   j
                                                   ,
                                                   A
                                                   d
                                                   )
                                                
                                                ≥
                                                T
                                                h
                                                
                                                   r
                                                   
                                                      I
                                                      n
                                                      t
                                                   
                                                
                                                
                                                   ∥
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                (
                                                Iutil
                                                (
                                                j
                                                )
                                                >
                                                Iutil
                                                (
                                                i
                                                )
                                                
                                                &
                                                
                                                Iutil
                                                (
                                                j
                                                )
                                                >
                                                Iutil
                                                (
                                                k
                                                )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                ∀
                                                
                                                   k
                                                   ∈
                                                   I
                                                   n
                                                   C
                                                   o
                                                   n
                                                   t
                                                   a
                                                   c
                                                   t
                                                   (
                                                   i
                                                   )
                                                   )
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The PISCast version improves the interest and power awareness of the SocialCast algorithm. According to PISCast, the node’s utility value is rewarded/penalized based on the node’s similarity interest PSInt and the remaining power level Bat.

                              
                                 (16)
                                 
                                    
                                       PIutil
                                       
                                          (
                                          i
                                          )
                                       
                                       =
                                       
                                          {
                                          
                                             
                                                
                                                   
                                                      −
                                                      (
                                                      P
                                                      S
                                                      I
                                                      n
                                                      t
                                                      (
                                                      i
                                                      ,
                                                      A
                                                      d
                                                      )
                                                      *
                                                      B
                                                      a
                                                      t
                                                      (
                                                      i
                                                      )
                                                      )
                                                      *
                                                      u
                                                      t
                                                      i
                                                      l
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                                
                                                   
                                                      if
                                                      
                                                      P
                                                      S
                                                      I
                                                      n
                                                      t
                                                      <
                                                      0
                                                   
                                                
                                             
                                             
                                                
                                                
                                                   
                                                      
                                                      &
                                                      
                                                      B
                                                      a
                                                      t
                                                      <
                                                      0
                                                      ,
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                      P
                                                      S
                                                      I
                                                      n
                                                      t
                                                      (
                                                      i
                                                      ,
                                                      A
                                                      d
                                                      )
                                                      *
                                                      B
                                                      a
                                                      t
                                                      (
                                                      i
                                                      )
                                                      *
                                                      u
                                                      t
                                                      i
                                                      l
                                                      (
                                                      i
                                                      )
                                                   
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           where util(i) is computed as per Eq. (13), and PSInt(i, Ad) is computed as per Eq. (2).

Furthermore, the selected forwarder node must satisfy either of the following conditions: (1) PIutil(j, Ad) exceeds PIutil(i, Ad) and as well exceeds PIutil of all the nodes k that node i is in contact with now; (2) SInt(j, Ad) is above the Interested-Forwarder-Threshold. This is clear in the following inequalities.

                              
                                 (17)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                S
                                                I
                                                n
                                                t
                                                
                                                   (
                                                   j
                                                   ,
                                                   A
                                                   d
                                                   )
                                                
                                                ≥
                                                T
                                                h
                                                
                                                   r
                                                   
                                                      I
                                                      n
                                                      t
                                                   
                                                
                                                
                                                   ∥
                                                   (
                                                
                                                P
                                                I
                                                u
                                                t
                                                i
                                                l
                                                
                                                   (
                                                   j
                                                   )
                                                
                                                >
                                                P
                                                I
                                                u
                                                t
                                                i
                                                l
                                                
                                                   (
                                                   i
                                                   )
                                                
                                                
                                                &
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                P
                                                I
                                                u
                                                t
                                                i
                                                l
                                                (
                                                j
                                                )
                                                >
                                                P
                                                I
                                                u
                                                t
                                                i
                                                l
                                                (
                                                k
                                                )
                                                
                                                ∀
                                                
                                                   k
                                                   ∈
                                                   I
                                                   n
                                                   C
                                                   o
                                                   n
                                                   t
                                                   a
                                                   c
                                                   t
                                                   (
                                                   i
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The threshold opportunistic version of PISCast, namely PISCastOp, seeks candidates that satisfy the PISCast conditions, or satisfies the Opportunistic-Interest-Power condition. The Threshold Opportunistic version conditions are met by satisfying the following inequalities.

                              
                                 (18)
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                (
                                                S
                                                I
                                                n
                                                t
                                                (
                                                j
                                                ,
                                                A
                                                d
                                                )
                                                ≥
                                                I
                                                n
                                                t
                                                e
                                                r
                                                e
                                                s
                                                t
                                                e
                                                d
                                                −
                                                F
                                                o
                                                r
                                                w
                                                a
                                                r
                                                d
                                                e
                                                r
                                                −
                                                T
                                                h
                                                r
                                                e
                                                s
                                                h
                                                o
                                                l
                                                d
                                                
                                                &
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                b
                                                a
                                                t
                                                
                                                   (
                                                   j
                                                   )
                                                
                                                ≥
                                                T
                                                h
                                                
                                                   r
                                                   
                                                      b
                                                      a
                                                      t
                                                   
                                                
                                                
                                                   )
                                                   ∥
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                (
                                                PIutil
                                                (
                                                j
                                                )
                                                >
                                                PIutil
                                                (
                                                i
                                                )
                                                
                                                &
                                                
                                                PIutil
                                                (
                                                j
                                                )
                                                >
                                                PIutil
                                                (
                                                k
                                                )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                ∀
                                                
                                                   k
                                                   ∈
                                                   InContact
                                                   (
                                                   i
                                                   )
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                        SCAR 
                        [15] is a sensor context-aware routing protocol for opportunistic routing. SCAR is an adaptive power-aware version of SocialCast. SCAR relies on predicted values of the utility attributes instead of current values to improve performance. The SCAR protocol is designed for opportunistic routing among mobile sensor nodes. The forecast mechanism is based on observing the candidate node’s history of co-location with the destination nodes, its change of degree of connectivity with other sensor nodes, and its battery level. SCAR includes a monotonically decreasing function that adapts to the predefined ranges of values of a certain attribute. The algorithm mainly sets an adaptive range for the battery level. This range, Rangebat
                        , monotonically decreases as the battery level enters a critical range. The node’s utility rank defined in [15] is shown in Eq. (19).

                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             Util
                                             (
                                             i
                                             )
                                          
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                Range
                                                
                                                   c
                                                   o
                                                   l
                                                
                                             
                                             *
                                             
                                                w
                                                
                                                   c
                                                   o
                                                   l
                                                
                                             
                                             *
                                             
                                                P
                                                
                                                   c
                                                   o
                                                   l
                                                
                                             
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             +
                                             
                                             
                                                Range
                                                
                                                   c
                                                   d
                                                   c
                                                
                                             
                                             *
                                             
                                                w
                                                
                                                   c
                                                   d
                                                   c
                                                
                                             
                                             *
                                             
                                                P
                                                
                                                   c
                                                   d
                                                   c
                                                
                                             
                                             
                                                (
                                                i
                                                )
                                             
                                             +
                                             
                                                Range
                                                
                                                   b
                                                   a
                                                   t
                                                
                                             
                                             *
                                             
                                                w
                                                
                                                   b
                                                   a
                                                   t
                                                
                                             
                                             *
                                             
                                                P
                                                
                                                   b
                                                   a
                                                   t
                                                
                                             
                                             
                                                (
                                                i
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where Pcol
                        (i), Pcdc
                        (i) and Pbat
                        (i), respectively are the predicted co-location of node i with any of the sink nodes, the predicted Change Degree Of Connectivity of node i, and the predicted remaining battery level of node i. The three predicted attributes are forecasted by applying the Kalman filter prediction techniques. The weights wcol, wcdc
                         and wbat
                        , respectively represent the relative importance of the co-location attribute, the change of degree of connectivity attribute and the battery level attribute. Also, Rangecol, Rangecdc
                         and Rangebat
                         are the adaptive monotonically decreasing range functions for the respective attributes.

This interest-aware version of SCAR rewards/penalizes the adaptive SCAR utility value of a node based on the collective interest of the node and its friends in the forwarded message. This version favors potentially interested nodes that are socially connected to potentially interested friends rather than uninterested ones. The new utility function is computed as follows:

                              
                                 (20)
                                 
                                    
                                       IUtil
                                       (
                                       i
                                       )
                                       =
                                       FrInter
                                       (
                                       i
                                       ,
                                       A
                                       d
                                       )
                                       *
                                       U
                                       t
                                       i
                                       l
                                       (
                                       i
                                       )
                                    
                                 
                              
                           
                        

where Util(i) is computed as per Eq. (19) and FrInter(i, Ad) is computed as per Eq. (3). Besides, the criteria for forwarder selection follow that applied by ISCast as shown in the condition (15).

The PISCAR version integrates power awareness to the interest-aware ISCAR version. Through this version, the partially interested nodes that are power capable become favored forwarder candidates. We present within this version whether our power-aware approach preserves more power in comparison to the interest-oblivious power-aware SCAR. Furthermore, we evaluate their performance in terms of fair utilization of power resources.

The opportunistic version of PISCAR, namely PISCAROp, seeks candidates that satisfy either the PISCAR conditions or the Opportunistic-Interest-Power condition. The Opportunistic-Interest-Power condition is met by satisfying the inequalities mentioned in (18).

@&#EVALUATION@&#

For our algorithms to operate effectively, a set of attainable assumptions given today’s technology are made. These assumptions include: (1) the presence of an ontology of interest among the nodes of interaction; (2) each user mobile device has an installed client that carries a local copy of the user’s social profile cached from his online social network; (3) direct interest is extracted from the social profile of the candidates; (4) all the messages have the same size for simplicity of cost calculations; (5) the algorithms also consider short-duration advertisements or announcements that target users located in a place within a short period of time e.g. a couple of hours (soft real-time delivery); (6) connectivity between mobile devices is achieved either through Wifi or Bluetooth; (7) the algorithms do not assume the existence of a fully connected social graph among the users in place, in contrast to CA-PeR algorithm, since these algorithms are based on interest and friendship and for applicability in a mall environment/conference center within a mobility duration of a couple of hours. Our algorithms have been simulated once with a fully connected social graph and another time without this precondition to prove their applicability in either environment; (8) IPeR and PIPeR consider the message sender to be the source that has no interest in receiving its own message. Thus, its rank starts as (1-d) and never improves due to the zero-interest component in the equation. However, all the forwarders update their ranks as they encounter their friends to become selective based on the candidate’s popularity and interest; (9) finally, to achieve power awareness, each node is assumed to provide its current power level when requested.

@&#METHODOLOGY@&#

This study empirically evaluates the improvement in performance of PeopleRank [11], SocialCast [10] and SCAR [15] algorithms after integrating the PI-SOFA framework as follows: (1) integrating interest awareness to produce their new interest-aware versions (IPeR, ISCast and ISCAR); (2) integrating power awareness to empirically evaluate the power and interest-aware versions of PeopleRank, SocialCast and SCAR (PIPeR, PISCast and PISCAR); (3) integrating threshold-opportunistic forwarding to produce PIPeROp, PISCastOp and PISCAROp; (4) implementing the interest-oblivious and power-oblivious Epidemic [41] algorithm to set its performance as a benchmark for all the algorithms; (5) implementing the opportunistic forwarding based on the interest-only selection criteria to compare its performance to the social-aware opportunistic forwarding algorithms for the sake of evaluating whether social relationships implicitly provide the knowledge of common interest among users; (6) comparing the new versions’ performance to another popular social aware forwarding algorithm, namely, ProfileCast [9] which relies on the concept that users of similar interest have similar mobility patterns. ProfileCast relies on users’ behavioral profiles in the selection of a forwarder node. For behavioral profile computations in ProfileCast, the SInt (the similarity interest) of each node to the forwarded message is used; (7) comparing our algorithms to the energy-aware social-based forwarding algorithm EBubbleRap [36]. EBubbleRap introduces an energy-aware utility function to the original BubbleRap algorithm’s [31] local and global ranking functions which rank the nodes within their local communities and the global community, respectively; (8) depicting the importance of integrating contact-duration-awareness in forwarder selection through introducing contact-duration-awareness in the forwarding decisions of the PIPeROp algorithm. This takes place through the demonstration of a contact-duration aware version of PIPeROp that relies on the Kalman filter prediction mechanism [39] in candidate node selection. The PIPeROp performance is once compared with the Kalman filter prediction and another time with an accurate contact-duration prediction mechanism while setting the benchmark to be the contact-duration oblivious PIPeR version.

We build our own simulator for a mall environment with 100 shops randomly distributed over an area of 1 km × 1 km. For accurate mobility patterns, the simulator imports user traces from the Self-similar Least Action Walk (SLAW) mobility model [23]. The SLAW mobility model implements social contexts present among people sharing common interests in small scale communities such as malls, or theme parks. To experiment with various conditions, we vary user density and ad hoc wireless range as shown in Table 2
                        . Since our focus is on relatively short-time ads that target users during a single visit, we are interested in the system’s performance during the first hour of simulations. We assume all ads have the same size for simplicity of cost calculations. Our results are based on ads generated by all the shops and are shown as an average of 20 runs changing the random distribution of the users’ mobility, profiles, friends list and initial battery levels. Our simulator generates random social profiles including interest for each user. Furthermore, the constructed friendship graph includes up to 20% of the available users in the friend list per user.

From their simulation experiments, the SCAR authors find that the optimum values for the weights and range functions are as follows: Rangecol
                         = 1, Rangecdc
                         = 1, Rangebat
                         = remaining battery portion, 
                           
                              
                                 w
                                 
                                    c
                                    o
                                    l
                                 
                              
                              =
                              0.75
                           
                        , wcdc
                         = 0.25 [15]. They have not conducted experiments that include the battery attribute so they do not mention any optimum set of weights that include wbat
                        . Accordingly, we have conducted a set of experiments to select the optimum weights. The optimum values deduced from these experiments are shown in Table 2.

In reality, not all users are interested in the same ads. To simulate this, the simulator sets the similarity interest of a certain percentage of the users with SInt(InterestedNode, Ad) ≥ 0.5 for interested forwarders and SInt(DestinationNode, Ad) ≥ 0.9 for destination nodes. While various user interest distributions have been tested, we only show results for the discrete uniform distribution; users are equally distributed between 11 categories with varying interest rates ranging from 0 to 1. Accordingly, the destination set constitutes 18% of the mobile users’ population while the interested forwarders cover 36%. The remaining 46% of the population are uninterested in the Ad. In another set of experiments, we assume there are two separate interest graphs, namely 20% of the community are Destination nodes while the remaining 80% of the community are uninterested nodes. In a third set of experiments, we assume a discrete normal interest distribution where the destination set covers 2% of the community, and the interested forwarders set covers 48% while the remaining 50% are uninterested nodes.

The SInt(source, Ad) acts as a knob controlling the acceptable set of contacted uninterested users since it acts as a starting cutoff point for forwarder selection. As per the experiments we conducted in previous work [19], we set SInt(source, Ad) to 0.3 in this paper’s simulation runs.

This set of parameters cover the initial battery level distribution, the simulated model of power consumption and the simulated distribution of the battery depletion rate.

The simulator experiments with various battery distributions for different purposes as follows: One set of simulation runs starts with full battery levels for all nodes to extract the pure effect of each algorithm on consuming the nodes’ power. Another simulation set uses discrete normal battery distribution to resemble the battery communities in real life. A third set of experiments uses a distribution that is based on a real dataset of the remaining battery capacity recorded by [25] for 10 mobile nodes in 24  h.

The simulation runs are based on realistic power consumption values and various battery level distributions. The simulator imports the power consumption values of four popular phone brands as studied by [26], which are comparable to other popular mobile brands.

The simulator implements the usage profiles studied in another research study [42]. The battery depletion rate is computed based upon these usage profiles. In another set of experiments, the depletion rate is randomly and uniformly distributed among the nodes with a range of values [0–100%]. However, in the set of experiments that consider the real battery distribution dataset environment, the depletion rate is computed based on the available battery distributions in this dataset.

To further validate our results using real social-based mobility traces, the simulator imports the mobility traces, interests and friendship graphs gathered during the SIGCOMM 2009 conference [21]. In this conference, 76 participants were handed in smart phones and were asked to use the installed MobiClique application for mobile social networking during the conference. Their social information, namely the list of friends and interests, was collected from their Facebook social profile. Thus, this dataset provides real friendship and interest graphs. The simulator picks any of the users to be the source of the ad and show the results within a 1-hour time frame.

The goals of this research are: (1) to seek opportunistic contact with the interested users in the least possible time while minimizing the overall cost and consumed power, especially for users not interested in the ad; (2) to maintain fair power consumption among the nodes over time. To measure the effective advertising performance of the compared algorithms, our simulator uses the following metrics:

The algorithm effectiveness is measured through classifying the contacted nodes as per their interest and through measuring the algorithm’s recall, precision, f-measure and accuracy.

An algorithm is effective if it contacts a high portion of the interested users while simultaneously avoiding the uninterested ones. Our simulator measures it by the ratio of contacted users classified by their interest; users are either interested forwarders, destination nodes, or uninterested forwarders.

Effectiveness is also measured through recall, precision, f-measure and accuracy [43]. Note that the targeted true set consists of the interested forwarder nodes in addition to the destination nodes, while the false set contains the uninterested nodes.

The efficiency of an algorithm is measured through the cost it pays, the delivery ratio it achieves, and the delay incurred towards such achievement.

Cost is measured by forwarded message replicas to accomplish this process. We measure the total number of ad replicas that have been generated at any given time, and also measure the cost per unit delivery ratio.

We measure the portion of successfully reached destination nodes over time to reflect efficiency.

Each ad sent to one of the destination nodes reflects a degree of user satisfaction. User satisfaction may be measured by the average delay consumed until an ad is delivered to any destination node.

Algorithm power-efficiency is reflected by its ability to conserve the overall power consumption. We measure this metric by computing the total consumed power from all the nodes’ batteries over time as well as the total consumed power per unit delivery ratio.

A fair algorithm would not exhaust some nodes’ batteries in ad forwarding while preserving other nodes’ power. That is, it seeks reducing variance among the nodes’ battery levels. We measure fairness via 3 measures:

The final mean and standard deviation of the nodes’ power community as they present the effect of each algorithm in shaping the final battery distribution.

The variance among the nodes’ battery levels over time. The ability of an algorithm to reduce/increase the variations among the nodes’ battery levels along the forwarding process is a measure of fairness; fairness indicates community closeness which is inversely proportional to variance.

The fairness index of the algorithm. Inspired by the fairness index defined by another research work [44] we compute it as shown in Eq. (21). This index ranges from 0 to 1 where the value 1 indicates the highest level of fairness when the SD of the final battery distribution reaches 0.

                              
                                 (21)
                                 
                                    
                                       F
                                       a
                                       i
                                       r
                                       n
                                       e
                                       s
                                       s
                                       I
                                       n
                                       d
                                       e
                                       x
                                       =
                                       1
                                       −
                                       
                                          
                                             S
                                             D
                                          
                                          
                                             m
                                             e
                                             a
                                             n
                                          
                                       
                                    
                                 
                              
                           
                        

The performance of the power-aware algorithm is measured in terms of the time and power wasted due to incomplete transfers of the message between two nodes as they get disconnected before the complete transfer takes place. The aim of this metric is to compare between the contact-duration-aware version of PIPeROp and its contact-duration-oblivious version.

For a collective performance analysis of the algorithms, we compile the metrics in a normalized 8-metric space. We also compose three normalized performance indices namely, effectiveness index, efficiency index and power awareness index. Each of these indices is the harmonic mean of a group of the above mentioned normalized metrics as detailed in the following formula.

                              
                                 (22)
                                 
                                    
                                       
                                          
                                             
                                                Effectiveness
                                                −
                                                I
                                                n
                                                d
                                                e
                                                x
                                                =
                                                H
                                                a
                                                r
                                                m
                                                o
                                                n
                                                i
                                                c
                                                M
                                                e
                                                a
                                                n
                                                (
                                                F
                                                m
                                                e
                                                a
                                                s
                                                u
                                                r
                                                e
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                IntFWDRatio
                                                ,
                                                UnIntFWDRatio
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                Efficiency
                                                −
                                                I
                                                n
                                                d
                                                e
                                                x
                                                =
                                                HarmonicMean
                                                (
                                                D
                                                e
                                                l
                                                i
                                                v
                                                e
                                                r
                                                y
                                                ,
                                                C
                                                o
                                                s
                                                t
                                                ,
                                                D
                                                e
                                                l
                                                a
                                                y
                                                )
                                             
                                          
                                       
                                       
                                          
                                             
                                                PowerAwareness
                                                −
                                                I
                                                n
                                                d
                                                e
                                                x
                                                =
                                                H
                                                a
                                                r
                                                m
                                                o
                                                n
                                                i
                                                c
                                                M
                                                e
                                                a
                                                n
                                                (
                                                P
                                                o
                                                w
                                                e
                                                r
                                                C
                                                o
                                                n
                                                s
                                                u
                                                m
                                                p
                                                t
                                                i
                                                o
                                                n
                                                ,
                                             
                                          
                                       
                                       
                                          
                                             
                                                F
                                                a
                                                i
                                                r
                                                n
                                                e
                                                s
                                                s
                                                I
                                                n
                                                d
                                                e
                                                x
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

@&#RESULTS@&#

This section analyzes the results of the conducted simulation experiments. We first present the compared algorithms’ performance in terms of the interest-aware metrics, then we focus on the power-aware metrics performance. This is followed by a brief analysis of the PIPeR performance after introducing contact-duration-awareness. The next section is allocated for a detailed discussion of the performance indices in various distributions.

Integration of interest awareness improves the three algorithms’ effectiveness. As shown from Fig. 1
                              a, the interest-aware algorithms maintain higher effectiveness compared to that of the interest-oblivious versions. This is clear from both the significant increase in the ratio of contacted interested forwarder nodes (the white portion of the bar), and the significant decrease in the ratio of uninterested nodes (the grey portion of the bar). This effectiveness is also depicted in Fig. 1b where the interest-aware forwarding algorithms achieve higher f-measure than the interest-oblivious versions. It is also evident that EBubbleRap fails to avoid the uninterested forwarders as it contacts 43% of them. On another side, the Interest-Only forwarding algorithm is quite selective to avoid all the uninterested nodes while maintaining a high number of contacted interested nodes. In comparison, the social-based forwarding algorithms do not maintain this high level of selectivity as they fail to avoid a high ratio of uninterested nodes and achieve lower f-measure values compared to the Interest-Only algorithm.

In comparison to PeopleRank, the IPeR and PIPeR versions significantly reduce cost to the half to reach 80% of the destination nodes as depicted by Fig. 2
                              a. When compared to SCAR and SocialCast, their interest-aware and their power-aware versions double the cost up to 6 times for the sake of contacting 19% extra destination nodes and 28% extra interested nodes with total avoidance to the uninterested nodes.

In terms of delay in delivery, Fig. 2b shows how all the interest-aware and power-aware versions maintain comparable delay – if not a reduced one – to the interest and power-oblivious ones. For instance, all the interest-aware and power-aware SCAR versions reduce delay to 29% of that incurred by SCAR. As for SocialCast, it confusingly achieves a very small delay as it could only reach one destination node after 5 min; if it had achieved more delivery ratio, the delay would have been higher.


                              Fig. 3
                               a illustrates the portion of consumed power versus the achieved delivery ratio. In comparison to PeopleRank, its power-aware versions successfully conserve 10% of the power consumed by PeopleRank to reach comparable delivery ratio. However, the power-aware versions of the SCAR and SocialCast algorithms consume 3.6% extra power towards higher delivery ratio achievement and to attain the highest level of interested node selection. The difference in performance between the power-aware SCAR and SocialCast versions on one side and the power-aware PeopleRank versions on the other side is attributed to the core logic of SCAR and SocialCast which picks one candidate among the currently contacted nodes after consuming several power-consuming comparison computations. Their power-aware versions add the power-capability and interest-level as extra criteria for node selection, which incur more power consumption but achieves more precise node selection. Moreover, the EBubbleRap consumes more power to reach a comparable delivery ratio to our proposed algorithms.

From Fig. 3b, which depicts the fairness of the compared algorithms, the PIPeR versions are fairer than the power-oblivious PeopleRank and IPeR algorithms. On the other hand, the power-aware SCAR and power-aware SocialCast versions are less fair than SCAR and SocialCast which barely contact nodes; Ironically, SCAR is considered the fairest algorithm while it barely contacts nodes leading to the least power consumption and the least delivery ratio. However, all the power-aware SCAR and SocialCast versions maintain higher level of fairness than all the PeopleRank versions and the benchmark algorithms. It is noteworthy that our proposed algorithms successfully attain a much higher level of fairness than EBubbleRap.


                        Table 3
                         depicts the results of forwarding decision based on the expected contact duration with the selected forwarder using each of the following contact expectation methods: accurate expectation, Kalman filter prediction, and no expectations at all. The results show that the accurate expectation of contact duration significantly reduces the wasted power and time while preserving the f-measure. Also, applying Kalman filter reduces the wasted resources at the cost of a reduced f-measure. From the conducted experiments, we noticed that introducing Kalman filter prediction mechanism in the forwarder selection process may not be effective unless the proper initialization parameters are applied to the filter. Also, from the experiments we deduce that the Kalman filter requires a calibration period to reach a stage of accurate prediction. Thus, for the short-duration forward processes, the Kalman filter prediction mechanism may not be efficient and there is a need for more accurate and fast calibration mechanisms.


                              Fig. 4
                               depicts, via an 8-metric space, a performance comparison among the PeopleRank versions. In comparison to PeopleRank, the interest and power-aware versions reduce cost and power consumption significantly. These versions focus mainly on interested forwarders and avoid the uninterested ones attaining the highest level of f-measure with comparable delay and some reduction in delivery ratio. More precisely, the PIPeR versions attain the highest levels of fairness while consuming a bit less power than that consumed by PeopleRank. It is worth noting that the PIPeR versions succeed to attain significant f-measure values which costs them more than the cost incurred by the IPeR algorithm, and leads to a slight reduction in their utilization fairness.

Furthermore, integrating interest and power awareness to SCAR improves its effectiveness, delivery ratio and delay. As depicted in Fig. 5
                              , the proposed interest and power-aware SCAR versions achieve higher delivery ratio, f-measure, maintain a significant increase in the ratio of contacted interested forwarders while preserving the avoidance of uninterested node contact. Such increase in delivery ratio and in interested forwarders contact incurs reasonable increase in cost and power consumption with comparable delay. These versions overcome the defect of SCAR in achieving the least delivery ratio.

The simulation results illustrated in Fig. 6
                               conclude that the interest and power-aware SocialCast versions, in comparison to SocialCast, achieve higher f-measure, delivery ratio. This achievement comes at the cost of comparable power consumption, fairness, cost and less delay.


                              Figs. 4–6 illustrate how the threshold-oppor-tunistic versions achieve an extra f-measure level – in comparison to their non-opportunistic peers – and maintain less delay with a slightly higher cost due to contacting more destinations and more interested nodes.

@&#DISCUSSION AND CONCLUSION@&#

Generally speaking, integrating interest awareness in social-based forwarding approaches maintains a balance between utilizing interest and social context information, which improves the performance of these forwarding algorithms in case of any discrepancy in interest/social information availability.

As opposed to the interest-oblivious algorithms, the interest-aware versions significantly concentrate their power consumption on contacting interested nodes while avoiding contact with uninterested ones. Consequently, the interest-aware algorithms maintain a high level of precision. From another aspect, the power-aware algorithms maintain a trade-off between the reduction in power consumption and securing a comparable delivery ratio. These power-aware versions acquire this high level of precision, even though they may fall in moderate utilization fairness levels due to the burden the message carriers exert while seeking interested nodes with high power capabilities. Such extra computations handled by the message carriers cause the carrier nodes’ power exhaustion, and increase the variance among the power levels of the community of nodes. For this reason, these power-aware versions set a power threshold to prevent the message carriers from approaching the power exhaustion border.

From the perspective of integrating contact duration awareness in forwarder selection, the more accurate the algorithm is in contact duration expectation, the less power and time are wasted in incomplete message transfers. This in return saves power consumption.

The analysis of Figs. 7
                     –9
                     
                      facilitates performance prediction of the algorithms across various environments. These 3 figures illustrate the power awareness, the effectiveness, and the efficiency of the proposed algorithms within environments encompassing various distributions. These distributions include various interest distributions, power distributions, user densities, and message sizes. From the analysis, the following is deduced: (1) along the various environment changes, the interest and power-aware PeopleRank versions maintain higher level of power awareness than that achieved by PeopleRank - except for PIPeROp in the normal battery distribution environment; (2) the interest and power-aware SCAR and SocialCast versions achieve a slightly lower level of power awareness compared to that achieved by SCAR and SocialCast as they succeed in contacting a higher percent of destination nodes and interested forwarders – except for PISCAROp in the normal battery distribution environment; (3) SCAR and SocialCast always fail in the effectiveness metric, while the level of effectiveness of PeopleRank is always stable; (4) the efficiency metric of all algorithms is predictable in all environments except for the normal interest distribution, and this is due to the challenge imposed by the normal interest distribution that results in generating a very small set of destination nodes; (5) the efficiency of SCAR and SocialCast decreases as the user density increases; thus, they are not recommended in crowded areas; (6) PIPeROp maintains the highest level of effectiveness in the majority of the environments while pertaining a very high level of efficiency and a fairly high level of power awareness. Furthermore, the performance of PIPeROp improves as the user density increases.

It can be concluded that integrating interest and power awareness to social-aware forwarding algorithms improves their effectiveness and efficiency. The proposed variations of the interest and power-aware versions promote the trade-off between seeking higher delivery ratio and f-measure on one side, and reducing power consumption and improving the utilization fairness on the other side. not only that, but also the above analysis recommends certain algorithms to be utilized in specific environments.

@&#REFERENCES@&#

