@&#MAIN-TITLE@&#Benders decomposition without separability: A computational study for capacitated facility location problems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a simplified way of deriving Benders cuts for convex optimization.


                        
                        
                           
                           The method is applied to linear/quadratic capacitated facility location problems.


                        
                        
                           
                           For linear case, our Benders method qualifies as one of the best exact solvers.


                        
                        
                           
                           For quadratic case, our Benders method is by far the best available exact solver.


                        
                        
                           
                           Our Benders heuristics outperform previous proposals from the literature.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Benders decomposition

Congested capacitated facility location

Perspective reformulation

Branch-and-cut

Mixed-integer convex programming

@&#ABSTRACT@&#


               
               
                  Benders is one of the most famous decomposition tools for Mathematical Programming, and it is the method of choice e.g., in mixed-integer stochastic programming. Its hallmark is the capability of decomposing certain types of models into smaller subproblems, each of which can be solved individually to produce local information (notably, cutting planes) to be exploited by a centralized “master” problem. As its name suggests, the power of the technique comes essentially from the decomposition effect, i.e., the separability of the problem into a master problem and several smaller subproblems. In this paper we address the question of whether the Benders approach can be useful even without separability of the subproblem, i.e., when its application yields a single subproblem of the same size as the original problem. In particular, we focus on the capacitated facility location problem, in two variants: the classical linear case, and a “congested” case where the objective function contains convex but non-separable quadratic terms. We show how to embed the Benders approach within a modern branch-and-cut mixed-integer programming solver, addressing explicitly all the ingredients that are instrumental for its success. In particular, we discuss some computational aspects that are related to the negative effects derived from the lack of separability. Extensive computational results on various classes of instances from the literature are reported, with a comparison with the state-of-the-art exact and heuristic algorithms. The outcome is that a clever but simple implementation of the Benders approach can be very effective even without separability, as its performance is comparable and sometimes even better than that of the most effective and sophisticated algorithms proposed in the previous literature.
               
            

@&#INTRODUCTION@&#

In this article we study the multiple-allocation (or multiple-source) Capacitated Facility Location (CFL) problem and its quadratic variant known as the congested CFL problem. In both problems we are given a set of customers and potential facility locations. Customers have to be served by open facilities, and their demands have to be satisfied by the limited capacity of open facilities. Demand can be split and a customer can be partially served by several locations. Multiple allocations arise, for example, when customers correspond to population areas and not all the individuals from the same area have to be served by the same facility. In the problem variant with linear objective function (known as classical CFL), the solution cost, which is to be minimized, is defined as the sum of costs for opening facilities plus the costs for allocating customer demands to open facilities. In congested CFL, introduced by Desrochers, Marcotte, and Stan (1995), possible congestions at open facilities imply diseconomies of scale expressed through convex cost functions. These convex costs arise due to a possibly larger number of overtime workers, usage of more costly materials, or by neglecting or postponing equipment maintenance schedules (Harkness & ReVelle, 2003). Hence, the goal is now to minimize the sum of facility opening costs, customer allocation costs plus the congestion costs (typically defined as service/production costs at facilities and/or waiting times at facilities). In congested CFL considered throughout this paper, the convex cost are modeled using quadratic functions. In congested CFL, a more balanced solution is sought after, i.e., a solution that takes into consideration expected waiting times such that open facilities are not “overloaded” by customer demands. The congestion is usually not measured in the same units as the opening and allocation costs (which can be easily expressed in currencies), hence, it is not surprising that congestion costs (being quadratic), grow much faster than the remaining (linear) part of the objective function. Consequently, it may happen that the optimal solution requires to open too many facilities, so as to keep their load at minimum. Since decision makers prefer to have a control over the number of open facilities, a p-median constraint is usually added to the problem formulation, where p is a given input parameter.

A large body of work is available for classical CFL. We address only a small portion of published articles, and refer the reader to a more comprehensive literature overview available in Klose and Drexl (2005) and a more recent one in Fernández and Landete (2015). To the best of our knowledge, the state-of-the-art exact methods for CFL are: (1) a branch-and-cut-and-price algorithm (B&C&P) by Avella and Boccia (2009), which is based on the idea of reformulating CFL as a fixed charge network design problem, and separating the mixed dicut inequalities, and (2) a Lagrangian-based branch-and-bound by Görtz and Klose (2012). State-of-the-art heuristics are those proposed by Avella, Boccia, Sforza, and Vasil’ev (2009) (a Lagrangian relaxation combined with a cutting plane method) and an MIP-based heuristic called kernel search by Guastaroba and Speranza (2012). On the contrary, congested CFL did not receive that much attention: besides the original article (Desrochers et al., 1995), in which the problem has been approached by column generation and optimal solutions have been reported for very small instances, the problem has been only recently considered in the master thesis (Selfun, 2011). However, there are plenty of models in which congestion issues at facilities are modeled using queuing theory, or considering different objective functions. For more details, see e.g., a recent survey by Boffey, R. Galvão, and Espejo (2007) and recent literature overviews given in Aboolian, Berman, and Krass (2012); Zhang, Berman, and Verter (2009).

Applying Benders decomposition to CFL appears very natural as it follows the “recipe” given by Benders in the early 60’s (Benders, 1962): keep the integer variables, and relax the “complicated” continuous variables. A careful look into the recent literature suggests however that, since the work of Wentges (Wentges, 1996) in the 90’s, and despite a wide range of approaches applied to CFL, the Benders decomposition method was not considered the solution method of choice.

The main motivation of the present article was therefore to rethink the well-known concept of Benders decomposition for CFL, considering both linear and convex nonlinear objective functions. Our goal was to provide guidelines for a modern implementation of Benders decomposition based on the MIP technology which was not available back in the 70’s and 80’s when most of the related articles have been published.

For classical (i.e., linear) CFL, our method is competitive and sometimes better than the state-of-the-art exact approaches available in the current literature: a branch-and-cut-and-price algorithm by Avella and Boccia (2009) and a Lagrangian-based branch-and-bound by Görtz and Klose (2012). For the largest available CFL instances, our method has been run as a heuristic and successfully compared with the kernel search heuristic by Guastaroba and Speranza (2012), which was shown to beat all previous CFL heuristics. For the congested case, we show how to obtain a much tighter convex Mixed-Integer Non-Linear Programming (MINLP) formulation using the perspective reformulation (Frangioni & Gentile, 2009; Günlük & Linderoth, 2012). We then demonstrate that our new decomposition approach computationally dominates the perspective reformulation solved using a state-of-the-art commercial solver based on second-order cone cuts.

More formally, CFL is stated as follows: Given a set J of potential facility locations, and a set I of customers, let di
                      ≥ 0 denote demand of a customer i ∈ I, and sj
                      ≥ 0 capacity of a facility j ∈ J. Opening a facility j ∈ J costs fj
                      ≥ 0, and serving a single unit of demand of customer i by facility j costs cij
                      ≥ 0, for all i ∈ I, j ∈ J. The goal is to find a subset of facility locations to open, and to serve all customers, so that the facility opening plus customer allocation costs are minimized. Let us assume without loss of generality that each customer can be allocated to every facility (if this is not the case, we will assume 
                        
                           
                              c
                              
                                 i
                                 j
                              
                           
                           =
                           ∞
                        
                     ). In the traditional compact Mixed-Integer Linear Programming (MILP) formulation for CFL, 
                        
                           |
                           J
                           |
                           +
                           |
                           I
                           |
                           ·
                           |
                           J
                           |
                        
                      variables are used to model the problem. For each j ∈ J, binary variable yj
                      is set to one if facility j is open, and to zero, otherwise. For each i ∈ I and j ∈ J, the continuous allocation variable xij
                      ≥ 0 will denote the fraction of the demand of customer i ∈ I served by facility j ∈ J.

The classical CFL model reads

                           
                              (1)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                f
                                                j
                                             
                                             
                                                y
                                                j
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                d
                                                i
                                             
                                             
                                                c
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (2)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    s.t.
                                    
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    1
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≤
                                    
                                       y
                                       j
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       d
                                       i
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≤
                                    
                                       s
                                       j
                                    
                                    
                                       y
                                       j
                                    
                                    
                                    
                                    ∀
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≥
                                    0
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       y
                                       j
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    
                                    
                                    ∀
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        The objective is to minimize the sum of facility opening costs, plus the customer allocation costs. Assignment constraints (2) make sure that complete customer demand is satisfied, and capacity constraints (4) make sure that the capacity of an open facility cannot be exceeded. Constraints (3) state that allocation to a facility j is only possible if this facility is open. They are redundant in the MILP formulation, but are known to significantly strengthen the quality of Linear Programming (LP) relaxation bounds. Note that, because of capacity constraints (4), the integrality condition on variables xij
                         is not automatically satisfied by an optimal solution, hence one should add it explicitly in case single-source CFL is considered—a variant not covered in the present paper.

CFL is NP-hard, however, when a set of open facilities is fixed, the problem of finding optimal customer allocations boils down to a transportation problem that can be solved efficiently using specialized algorithms based on e.g., minimum-cost flows. Furthermore, the following well-known and very useful constraints are sufficient to guarantee that a chosen subset of open facilities may produce a feasible solution:

                           
                              
                                 
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       s
                                       j
                                    
                                    
                                       y
                                       j
                                    
                                    ≥
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       d
                                       i
                                    
                                    .
                                 
                              
                           
                        These constraints turn out to be very important for our Benders reformulation as well.

Similarly, congested CFL can be modeled as the following Mixed-Integer Non-Linear Program (MINLP)

                           
                              (7)
                              
                                 
                                    
                                       
                                       
                                          
                                             min
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                f
                                                j
                                             
                                             
                                                y
                                                j
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                d
                                                i
                                             
                                             
                                                c
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                             
                                             +
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             F
                                             
                                                (
                                                
                                                   ∑
                                                   
                                                      k
                                                      ∈
                                                      I
                                                   
                                                
                                                
                                                   d
                                                   k
                                                
                                                
                                                   x
                                                   
                                                      k
                                                      j
                                                   
                                                
                                                )
                                             
                                             
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                d
                                                i
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       
                                       
                                          
                                             s.t.
                                             
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                y
                                                j
                                             
                                             =
                                             p
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             (
                                             2
                                             )
                                             −
                                             (
                                             6
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        where F(.) is the penalty function, which is assumed to be nonnegative, continuous and convex for non-negative arguments. This function penalizes every additional “unit” being served by a given facility. Depending on the application, function F is used here to model the service/production costs at the facilities or the waiting times—both are expected to increase with the increasing demand in a convex fashion. Desrochers et al. (1995) show that, under these assumptions, the objective function remains convex in (x, y) for all nonnegative values of x, hence we are dealing with a convex MINLP. Throughout this paper, for the ease of exposition, we will assume that F(t) is a linear function, say 
                           
                              F
                              (
                              t
                              )
                              =
                              a
                              t
                              +
                              b
                              ,
                           
                         with nonnegative input coefficients a and b, though our decomposition approach (cf. Section 3) can be extended to more general cases. To prevent opening too many facilities and to allow the decision makers to control the number of open facilities, p-median constraint (8) is added to the model (Desrochers et al., 1995).

Using aggregated variables to model the exact demand served by facility j (namely: 
                           
                              
                                 v
                                 j
                              
                              =
                              
                                 ∑
                                 
                                    i
                                    ∈
                                    I
                                 
                              
                              
                                 d
                                 i
                              
                              
                                 x
                                 
                                    i
                                    j
                                 
                              
                              ,
                           
                         that we will refer to as facility load), the congestion cost at a facility j ∈ F is given as F(vj
                        ) · vj
                        . Consequently, the objective function can be written as:

                           
                              
                                 
                                    min
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       f
                                       j
                                    
                                    
                                       y
                                       j
                                    
                                    +
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       d
                                       i
                                    
                                    
                                       c
                                       
                                          i
                                          j
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    +
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    F
                                    
                                       (
                                       
                                          v
                                          j
                                       
                                       )
                                    
                                    
                                       v
                                       j
                                    
                                 
                              
                           
                        Our model then reads

                           
                              (9)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                f
                                                j
                                             
                                             
                                                y
                                                j
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                d
                                                i
                                             
                                             
                                                c
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                             
                                             +
                                          
                                       
                                       
                                          
                                             b
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                v
                                                j
                                             
                                             +
                                             a
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                v
                                                j
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                             
                                             
                                             
                                             s.t.
                                             
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                y
                                                j
                                             
                                          
                                       
                                       
                                          
                                             =
                                             p
                                          
                                       
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       d
                                       i
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    
                                       v
                                       j
                                    
                                    
                                    
                                    
                                    ∀
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    =
                                    1
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                 
                              
                           
                        
                        
                           
                              (13)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≤
                                    
                                       y
                                       j
                                    
                                    
                                    
                                    
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (14)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       v
                                       j
                                    
                                    ≤
                                    
                                       s
                                       j
                                    
                                    
                                       y
                                       j
                                    
                                    
                                    
                                    
                                    ∀
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       x
                                       
                                          i
                                          j
                                       
                                    
                                    ≥
                                    0
                                    
                                    
                                    ∀
                                    i
                                    ∈
                                    I
                                    ,
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                    
                                       y
                                       j
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    
                                    ∀
                                    j
                                    ∈
                                    J
                                 
                              
                           
                        
                     

To obtain a tighter model one can derive the so-called perspective reformulation (Frangioni & Gentile, 2009; Günlük & Linderoth, 2012) of the problem, in which each quadratic term 
                           
                              v
                              j
                              2
                           
                         in the objective function is replaced by a nonnegative variable zj
                        , namely:

                           
                              (17)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             min
                                             {
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                f
                                                j
                                             
                                             
                                                y
                                                j
                                             
                                             +
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                d
                                                i
                                             
                                             
                                                c
                                                
                                                   i
                                                   j
                                                
                                             
                                             
                                                x
                                                
                                                   i
                                                   j
                                                
                                             
                                             +
                                             b
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                v
                                                j
                                             
                                             +
                                             a
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                z
                                                j
                                             
                                             ∣
                                             
                                                v
                                                j
                                                2
                                             
                                             ≤
                                             
                                                z
                                                j
                                             
                                             
                                                y
                                                j
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             ∀
                                             
                                             j
                                             ∈
                                             J
                                             ,
                                             
                                             z
                                             ≥
                                             0
                                             ,
                                             
                                             
                                                (
                                                10
                                                )
                                                −
                                                (
                                                16
                                                )
                                             
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The second-order cone (SOC) constraints 
                           
                              
                                 v
                                 j
                                 2
                              
                              ≤
                              
                                 z
                                 j
                              
                              
                                 y
                                 j
                              
                              ,
                           
                         together with the minimization of the objective function, guarantee that the quadratic load 
                           
                              v
                              j
                              2
                           
                         of a facility j is zero if the facility is closed, and it is zj
                         if the facility is open. Note that, for a given vj
                        , the smaller yj
                         > 0 the larger zj
                        , meaning that small fractional values of yj
                         are penalized by the objective function. As a result, the model automatically tends to favor integral values for the y variables, which explains why the perspective reformulation of a problem is typically much tighter than the standard one (see, e.g. Frangioni & Gentile, 2009; Günlük & Linderoth, 2012). We therefore use (17) in our computational study.

In this section we describe the basic steps for the design of a Benders decomposition approach to be embedded in a modern MIP solver.

For the sake of generality, let the problem of interest (an MILP or a convex MINLP) be restated as

                           
                              (18)
                              
                                 
                                    
                                       
                                          
                                             min
                                             f
                                             (
                                             x
                                             ,
                                             y
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (19)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                             g
                                             (
                                             x
                                             ,
                                             y
                                             )
                                             ≤
                                             0
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (20)
                              
                                 
                                    
                                       
                                          
                                             y
                                             
                                             integer
                                          
                                       
                                    
                                 
                              
                           
                        where 
                           
                              x
                              ∈
                              
                                 
                                    R
                                 
                                 m
                              
                              ,
                           
                        
                        
                           
                              y
                              ∈
                              
                                 
                                    R
                                 
                                 n
                              
                              ,
                           
                         and functions 
                           
                              f
                              :
                              
                                 
                                    R
                                 
                                 
                                    m
                                    +
                                    n
                                 
                              
                              ↦
                              R
                           
                         and 
                           
                              g
                              :
                              
                                 
                                    R
                                 
                                 
                                    m
                                    +
                                    n
                                 
                              
                              ↦
                              
                                 
                                    R
                                 
                                 p
                              
                           
                         are assumed to be differentiable and convex. Let Ay ≤ b denote the subset of linear inequalities in (19) that do not involve x, including variable bounds on the y variables (if any). To simplify our treatment, we assume that

                           
                              
                                 
                                    S
                                    :
                                    =
                                    {
                                    y
                                    :
                                    A
                                    y
                                    ≤
                                    b
                                    }
                                 
                              
                           
                        is a nonempty polytope, while the convex sets X(y) ≔ {x: g(x, y) ≤ 0} are nonempty, closed and bounded for all y ∈ S, as it happens in our CFL case. Problem (18)–(20) can trivially be restated as the master problem in the y space

                           
                              (21)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                             
                                             min
                                             w
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (22)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                             w
                                             ≥
                                             Φ
                                             (
                                             y
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (23)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                             A
                                             y
                                             ≤
                                             b
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (24)
                              
                                 
                                    
                                       
                                          
                                             
                                             y
                                             
                                             integer
                                          
                                       
                                    
                                 
                              
                           
                        where

                           
                              
                                 
                                    Φ
                                    
                                       (
                                       y
                                       )
                                    
                                    :
                                    =
                                    
                                       min
                                       
                                          x
                                          ∈
                                          X
                                          (
                                          y
                                          )
                                       
                                    
                                    f
                                    
                                       (
                                       x
                                       ,
                                       y
                                       )
                                    
                                 
                              
                           
                        is the convex function expressing the optimal solution value of problem (18)–(20) as a function of y, and w is a continuous variable that captures its value in the objective function. (Problems where X(y) can be empty for some y ∈ S can be handled similarly, by adding the feasibility condition 0 ≥ Ψ(y) ≔ min {1
                           T
                        
                        s | g(x, y) ≤ s, s ≥ 0} to (21)–(24).)

Note that Φ(y), though convex, is nonlinear even in case f and g are. For example, the toy continuous problem 
                           
                              min
                              {
                              x
                              ∣
                              x
                              ≥
                              y
                              ,
                              
                              x
                              ≥
                              −
                              y
                              ,
                              y
                              ∈
                              [
                              −
                              1
                              ,
                              1
                              ]
                              }
                           
                         leads to the master 
                           
                              min
                              {
                              Φ
                              (
                              y
                              )
                              ∣
                              y
                              ∈
                              [
                              −
                              1
                              ,
                              1
                              ]
                              }
                           
                         where 
                           
                              Φ
                              (
                              y
                              )
                              =
                              |
                              y
                              |
                           
                         is clearly convex but nonlinear, and attains its minimum in 
                           
                              y
                              =
                              0
                              ,
                           
                         i.e., in a point that is not a vertex of 
                           
                              S
                              =
                              [
                              −
                              1
                              ,
                              1
                              ]
                           
                        .

Master problem (21)–(24) is therefore a convex MINLP that can be solved by an LP-based branch-and-cut approach where the integrality requirement on y is relaxed and Φ(y) is approximated by linear cuts to be generated on the fly and added to the current LP-relaxation; see Bonami, Kilinc, and Linderoth for a recent introduction to modern MINLP solution techniques. A crucial point is therefore the efficient generation of the approximation cuts, whose correctness exploits the convexity assumption. To this end, consider a (possibly noninteger) solution y
                        * of the LP relaxation of the current master. Because of convexity, Φ(y) can be underestimated by a supporting hyperplane at y
                        *, so we can write the following linear cut

                           
                              (25)
                              
                                 
                                    w
                                    ≥
                                    Φ
                                    
                                       (
                                       y
                                       )
                                    
                                    ≥
                                    Φ
                                    
                                       (
                                       
                                          y
                                          *
                                       
                                       )
                                    
                                    +
                                    ξ
                                    
                                       
                                          (
                                          
                                             y
                                             *
                                          
                                          )
                                       
                                       T
                                    
                                    
                                       (
                                       y
                                       −
                                       
                                          y
                                          *
                                       
                                       )
                                    
                                 
                              
                           
                        Here ξ(y
                        *) denotes a subgradient of Φ in y
                        * that can be computed (if constraint qualifications hold) as

                           
                              (26)
                              
                                 
                                    
                                       
                                          
                                             ξ
                                             
                                                (
                                                
                                                   y
                                                   *
                                                
                                                )
                                             
                                             =
                                             
                                                ∇
                                                y
                                             
                                             f
                                             
                                                (
                                                
                                                   x
                                                   *
                                                
                                                ,
                                                
                                                   y
                                                   *
                                                
                                                )
                                             
                                             +
                                             
                                                u
                                                *
                                             
                                             
                                                ∇
                                                y
                                             
                                             g
                                             
                                                (
                                                
                                                   x
                                                   *
                                                
                                                ,
                                                
                                                   y
                                                   *
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where x
                        * and u
                        * are optimal primal and (Lagrangian) dual solutions of the convex problem obtained from (18)–(20) by replacing y with the given y
                        *, and ∇
                           y
                         is the gradient operator with respect to the y variables; see (Geoffrion, 1972) for details.

The above formula involves the computation of partial derivatives of f and g with respect to the yj
                        ’s, so it is problem specific and sometimes cumbersome to apply. We next introduce a very simple reformulation that makes its implementation straightforward. By definition, Φ(y) can be computed by solving the convex problem (referred to as the subproblem in the literature)

                           
                              (27)
                              
                                 
                                    
                                       
                                          
                                             Φ
                                             (
                                             y
                                             )
                                             =
                                             min
                                             f
                                             (
                                             x
                                             ,
                                             q
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (28)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                             g
                                             (
                                             x
                                             ,
                                             q
                                             )
                                             ≤
                                             0
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (29)
                              
                                 
                                    
                                       
                                          
                                             
                                             y
                                             −
                                             q
                                             =
                                             0
                                          
                                       
                                    
                                 
                              
                           
                        The variable-fixing Eq. (29) is meant to be imposed as y ≤ q ≤ y by just modifying the lower and upper bounds on the q variables, so it can be handled very efficiently by the solver in a preprocessing phase when y is given.

By construction, y only appears in the trivial constraint (29), hence the subgradient in (26) is just

                           
                              (30)
                              
                                 
                                    
                                       
                                          
                                             ξ
                                             
                                                (
                                                
                                                   y
                                                   *
                                                
                                                )
                                             
                                             =
                                             
                                                r
                                                *
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where r
                        * is an optimal dual vector associated to (29), e.g., the vector of reduced costs when this constraint is imposed as y
                        * ≤ q ≤ y
                        *. This leads to the (generalized) Benders cut

                           
                              (31)
                              
                                 
                                    w
                                    ≥
                                    Φ
                                    
                                       (
                                       
                                          y
                                          *
                                       
                                       )
                                    
                                    +
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       r
                                       j
                                       *
                                    
                                    
                                       (
                                       
                                          y
                                          j
                                       
                                       −
                                       
                                          y
                                          j
                                          *
                                       
                                       )
                                    
                                 
                              
                           
                        where each (possibly negative) reduced cost 
                           
                              r
                              j
                              *
                           
                         defines a lower bound on the increase of the objective function Φ(y
                        *) when 
                           
                              y
                              j
                              *
                           
                         increases—note that each reduced cost 
                           
                              r
                              j
                              *
                           
                         is the optimal dual variable associated with the bound constraint 
                           
                              
                                 q
                                 j
                              
                              ≥
                              
                                 y
                                 j
                                 *
                              
                           
                         (if 
                           
                              
                                 r
                                 j
                                 *
                              
                              ≥
                              0
                           
                        ) or 
                           
                              
                                 q
                                 j
                              
                              ≤
                              
                                 y
                                 j
                                 *
                              
                           
                         (if 
                           
                              
                                 r
                                 j
                                 *
                              
                              <
                              0
                           
                        ).

Following Benders general recipe, all continuous variables are projected out of the model, and the overall objective function is replaced by a single continuous variable w. The resulting master problem is then given by

                           
                              (32)
                              
                                 
                                    
                                       
                                          
                                             min
                                             w
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (33)
                              
                                 
                                    
                                       
                                          
                                             
                                             s.t.
                                             
                                             w
                                          
                                       
                                       
                                          
                                             ≥
                                             Φ
                                             (
                                             y
                                             )
                                          
                                       
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (34)
                              
                                 
                                    
                                       
                                          
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                s
                                                j
                                             
                                             
                                                y
                                                j
                                             
                                          
                                       
                                       
                                          
                                             ≥
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                d
                                                i
                                             
                                          
                                       
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (35)
                              
                                 
                                    
                                       
                                          
                                             
                                             
                                                y
                                                j
                                             
                                          
                                       
                                       
                                          
                                             ∈
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                       
                                       
                                       
                                          
                                             
                                             ∀
                                             j
                                             ∈
                                             J
                                          
                                       
                                    
                                 
                              
                           
                        where Φ(y) in the convex function expressing the solution cost of the best-possible assignment compatible with the given (possibly noninteger) y ∈ [0, 1]
                           J
                        . Of course, for congested CFL one needs to extend the master problem by the p-median constraint (8).

Recall that constraint (34) guarantees that the overall capacity of open facilities is sufficient to accommodate the overall customer demand. This latter constraint plays a very important role in our model, as it acts as a global feasibility cut ensuring that any solution y of the master admits a feasible x in the original model, hence Φ(y) is well defined for any master (possibly noninteger) solution y. As a consequence, no so-called Benders feasibility cuts are needed in our setting.

Within a modern MIP solver, cuts are possibly separated at every node of the branching tree. Besides internal general-purpose cuts, the user can design his/her own separation function that receives a (possibly noninteger) master solution (y*, w*) on input, and tries to generate a violated cut. In our setting, we are interested in generating violated Benders cuts of the form (31) derived from the convex relaxation obtained by removing integrality constraints on y variables. Separation of Benders cuts is therefore performed for both, fractional and integer values of y
                        *. To this end, for the given y
                        * the convex subproblem (27)–(29) is solved for 
                           
                              y
                              =
                              
                                 y
                                 *
                              
                           
                         to get the optimal value Φ(y
                        *) and the associated reduced cost vector r
                        *. Note that the solution of the latter problem can be rather time consuming, as it does not decompose into smaller subproblems as it happens in typical application of Benders decomposition. Nevertheless, as y is fixed, the explicit constraints xij
                         ≤ yj
                         are automatically preprocessed and become just implicit upper bounds on the x variables. In addition, for congested CFL the SOC constraints 
                           
                              
                                 v
                                 j
                                 2
                              
                              ≤
                              
                                 z
                                 j
                              
                              
                                 y
                                 j
                              
                           
                         become regular quadratic constraints. As a consequence, the solution of the subproblem can be orders of magnitude faster than the solution of the convex relaxation where y is not fixed and only the integrality requirement is relaxed, making the Benders approach appealing.

We observe that the solution of the subproblem (27)–(29) for 
                           
                              y
                              =
                              
                                 y
                                 *
                              
                           
                         could take advantage of the specific structure of the CFL problem. In particular, for linear CFL the subproblem is in fact a transportation problem that could be solved by a specialized algorithm. According to our experience, however, using a general-purpose LP solver such as the dual simplex method has the advantage of a better warm-start mechanism, so after some testing we decided not to use any specialized code—thus making the overall implementation simpler.

Many authors pointed out that the subproblem is typically dual degenerate, which means that many optimal dual solutions exist (see, e.g., Magnanti & Wong, 1981; Naoum-Sawaya & Elhedhli, 2013; Van Roy, 1986; Wentges, 1996). Since each optimal dual solution leads to different reduced costs and hence to a different Benders cut, the question on how to choose the “best” Benders cuts to be inserted into the master is a key of an efficient implementation. In our implementation strategy, we do not insist on generating Pareto optimal cuts (like e.g., in Magnanti & Wong, 1981) but just apply the very basic method of the previous subsection. For linear CFL only, we apply the following simple recomputation of the optimal reduced costs (and hence of the Benders cut coefficients) that according to our experience produced more stable cuts.

Let u
                        * be the vector of dual variables associated to assignment constraints (2) found by the LP solver applied to the subproblem, i.e., to the original model (1)–(6) with the variable-fixing constraint y
                        * ≤ y ≤ y
                        *. Our idea is to fix u
                        * and to recompute optimal reduced costs by solving a series of continuous knapsack problems. Recall that Φ(y) denotes the optimal value of (1)–(6) as a function of y. As already observed by many authors (see, e.g. Cornuéjols, Sridharan, & Thizy, 1991), by Lagrangian duality we can write

                           
                              
                                 
                                    
                                       
                                          
                                             Φ
                                             (
                                             y
                                             )
                                          
                                       
                                       
                                          ≥
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                u
                                                i
                                                *
                                             
                                             +
                                             
                                                min
                                                
                                                   0
                                                   ≤
                                                   x
                                                   ≤
                                                   1
                                                
                                             
                                             
                                                {
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      J
                                                   
                                                
                                                
                                                   f
                                                   j
                                                
                                                
                                                   y
                                                   j
                                                
                                                +
                                                
                                                   ∑
                                                   
                                                      j
                                                      ∈
                                                      J
                                                   
                                                
                                                
                                                   ∑
                                                   
                                                      i
                                                      ∈
                                                      I
                                                   
                                                
                                                
                                                   (
                                                   
                                                      d
                                                      i
                                                   
                                                   
                                                      c
                                                      
                                                         i
                                                         j
                                                      
                                                   
                                                   −
                                                   
                                                      u
                                                      i
                                                      *
                                                   
                                                   )
                                                
                                                
                                                   x
                                                   
                                                      i
                                                      j
                                                   
                                                
                                                ∣
                                                
                                                   (
                                                   3
                                                   )
                                                
                                                ,
                                                
                                                   (
                                                   4
                                                   )
                                                
                                                }
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          =
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                u
                                                i
                                                *
                                             
                                             +
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                (
                                                
                                                   f
                                                   j
                                                
                                                +
                                                
                                                   
                                                      KP
                                                   
                                                   
                                                      
                                                         u
                                                         *
                                                      
                                                   
                                                   j
                                                
                                                )
                                             
                                             
                                             
                                                y
                                                j
                                             
                                          
                                       
                                    
                                 
                              
                           
                        where the |J| independent continuous knapsack problems

                           
                              
                                 
                                    
                                       
                                          KP
                                       
                                       
                                          
                                             u
                                             *
                                          
                                       
                                       j
                                    
                                    :
                                    =
                                    min
                                    
                                       {
                                       
                                          ∑
                                          i
                                       
                                       
                                          (
                                          
                                             d
                                             i
                                          
                                          
                                             c
                                             
                                                i
                                                j
                                             
                                          
                                          −
                                          
                                             u
                                             i
                                             *
                                          
                                          )
                                       
                                       
                                          z
                                          i
                                       
                                       ∣
                                       
                                          ∑
                                          
                                             i
                                             ∈
                                             I
                                          
                                       
                                       
                                          d
                                          i
                                       
                                       
                                          z
                                          i
                                       
                                       ≤
                                       
                                          s
                                          j
                                       
                                       ,
                                       
                                       0
                                       ≤
                                       z
                                       ≤
                                       1
                                       }
                                    
                                 
                              
                           
                        can be solved very efficiently (and in a numerically very clean way) by a simple sorting algorithm. This leads to the Benders cut

                           
                              
                                 
                                    w
                                    ≥
                                    
                                       ∑
                                       
                                          i
                                          ∈
                                          I
                                       
                                    
                                    
                                       u
                                       i
                                       *
                                    
                                    +
                                    
                                       ∑
                                       
                                          j
                                          ∈
                                          J
                                       
                                    
                                    
                                       (
                                       
                                          f
                                          j
                                       
                                       +
                                       
                                          
                                             KP
                                          
                                          
                                             
                                                u
                                                *
                                             
                                          
                                          j
                                       
                                       )
                                    
                                    
                                    
                                       y
                                       j
                                    
                                 
                              
                           
                        Note that the above procedure would work for any vector u of Lagrangian multipliers associated with (2), though the maximum cut violation is achieved for an optimal dual vector u
                        * for the point y
                        * to be separated.

We have seen that the master problem (21)–(24) calls for the minimization of a convex function Φ(y) over a nonempty polytope S, under the integrality requirement (24). Branch-and-cut solution methods relax the integrality condition and use enumeration to enforce it. A crucial step is how to solve effectively, by cutting planes, the convex problem min 
                           y ∈ S
                        
                        Φ(y) arising at the root node. As a matter of fact, in many cases reported in the literature (and perhaps in many more not reported ones) such a solution approach turns out to be so slow that it makes the overall Benders method simply impractical.

As already discussed, many authors attributed slow convergence to dual degeneracy, hence focused on how to select a “best possible” Benders cut for the given y
                        * at hand. According to our experience, however, cut selection is important but the cut loop strategy adopted at the root node is the real culprit of inefficiency. Following Kelley’s recipe (Kelley, 1960), which is standard in MIP solvers, at each cut loop iteration one generates one or more cuts that are violated by the current LP-optimal solution y
                        *, adds them to the current relaxation, and reoptimizes it to get the new optimal solution y
                        * to cut at the next iteration. This approach works well in many cases, but it is known to be extremely inefficient when Φ and S have a shape that leads to a zig-zagging y
                        * trajectory, as it happens e.g. in Lagrangian dual optimization or in column generation (Vanderbeck, 2005). In these cases, “stabilized” approaches such as the bundle method (Lemaréchal, Nemirovskii, & Nesterov, 1995) are known to outperform Kelley’s one by a large margin. Thus, the implementation of stabilized cutting plane (at least) at the root node is expected to be of crucial importance in Benders decomposition, in particular when a single cut is separated for each y
                        * as it happens in our CFL implementation.

Following our previous proposal for uncapacitated facility location (Fischetti, Ljubić, & Sinnl, 2016), we did not implement a bundle method but a simple in-out variant very much in the spirit of Ben-Ameur and Neto (2007); Fischetti and Salvagnin (2010); Naoum-Sawaya and Elhedhli (2013). The resulting cutting plane procedure is applied before starting the branch-and-cut, i.e., before the root node. It is aimed at quickly determining a hopefully small set of Benders cuts that brings the master LP relaxation value as close as possible to the “real optimal value” min 
                           y ∈ S
                        
                        Φ(y).

At each cut loop iteration, we have two points in the y space: the optimal solution y
                        * of the current master LP (as in Kelley’s method), and a stabilizing point 
                           
                              y
                              ˜
                           
                         inside the convex feasible set S. This point is initialized by solving the convex problem max {∑
                           j ∈ J
                        
                        yj
                        ∣y ∈ S} through an internal point method (barrier without crossover).

At each iteration, we move 
                           
                              y
                              ˜
                           
                         towards y
                        * by setting 
                           
                              
                                 y
                                 ˜
                              
                              =
                              α
                              
                              
                                 y
                                 ˜
                              
                              +
                              
                                 (
                                 1
                                 −
                                 α
                                 )
                              
                              
                              
                                 y
                                 *
                              
                           
                         and then apply our Benders-cut separator to the “intermediate point” 
                           
                              λ
                              
                              
                                 y
                                 *
                              
                              +
                              
                                 (
                                 1
                                 −
                                 λ
                                 )
                              
                              
                              
                                 y
                                 ˜
                              
                              ,
                           
                         where parameters λ ∈ (0, 1] and α ∈ (0, 1] are discussed later on. The generated Benders cut is statically added to the current master LP. After 5 consecutive iterations in which the LP bound does not improve, parameter λ is reset to 1 (so we are back to Kelley) and the cut loop continues. After 5 more consecutive iterations without improvement, the procedure is aborted, the LP is solved once again and all cuts with a positive slack are removed. To speedup computation, slack cuts in the current master LP are also removed at every 5th iteration.

Our computational experience with CFL (both linear and congested) confirms the findings of Fischetti et al. (2016), and shows that the above stabilization approach—though very simple—works well and quickly produces lower bounds very close to the best-possible one.

As to the choice of parameters α and λ, for congested CFL we adopted the values originally proposed in Fischetti et al. (2016), namely 
                           
                              α
                              =
                              0.5
                           
                         and 
                           
                              λ
                              =
                              0.2
                           
                        . For linear CFL, instead, we noticed that an overall speedup can be obtained by a more conservative approach producing a sequence of very similar points to be separated. This is because, for the linear case, Benders cuts are generated by solving the subproblem through the dual simplex method, each time starting from the optimal LP base of the previous separation. So, the more similar the points to separate, the faster the cut generation. Hence we defined 
                           
                              α
                              =
                              0.9
                           
                         and 
                           
                              λ
                              =
                              0.1
                           
                         to increase the attraction grip of the internal point 
                           
                              y
                              ˜
                           
                        . A similar approach is instead not worthwhile for the congested CFL, where the subproblem is nonlinear and is solved by using a barrier method that starts from scratch at each call.

To mitigate the use of the time-consuming Benders cut separation that requires the solution of a single but large subproblem, for the linear case we tested the following CFL-specific strategy that tries to enforce subproblem separability in a heuristic way. To this end, we observe that subproblem decomposition into smaller subproblems is inhibited by the presence of the capacity constraints (4): if we temporarily relax them, we get an uncapacitated problem for which Benders cuts can be derived very efficiently by using simple ad-hoc algorithms (Fischetti et al., 2016). So we can think of a two-level cut strategy where “blurred” Benders cuts are quickly generated from the uncapacitated model, and the generation of the capacitated Benders cuts is activated only as a last resort, i.e., when the given solution y
                        * is integer and is going to update the incumbent—in which case we need the “real Benders cut” to assess the correct value of Φ(y
                        *). Of course, the approach makes sense only for those instances where the capacity constraints (though non-redundant) are not very tight, meaning that only a few “real Benders cuts” need to be generated. According to our computational analysis, the approach is in fact very successful for just a few instances in our testbed, while it does not pay off in general.

@&#IMPLEMENTATION DETAILS@&#

In this section we describe some implementation details that play an important role in the design of an effective code. The description is based on the actual MIP solver we used, namely IBM ILOG Cplex 12.6.1, but it extends easily to other solvers.

Modern MIP solvers exploit multi-threading, so it is important not to lose this important feature when embedding user-specific functions such as Benders-cut generation. Cplex’s default is quite conservative, and it switches to single-thread as soon as the user installs “potentially risky” callbacks. In our implementation, we reset the number of threads to the one provided by the hardware, say NT (
                           
                              N
                              T
                              =
                              4
                           
                         for our computer), and select the opportunistic mode (CPX_PARAM_PARALLELMODE=-1) to better exploit parallelism. Also, to be thread-safe, at startup we create NT copies (clones) of the subproblem (27)–(29), and let each thread work on its own copy to produce its Benders cuts. As the clone is not destroyed but just modified at each separation call, warm-start is automatically applied without the need of explicitly saving/loading optimal LP bases (this of course applies to the linear case only). As to the cut initialization before branch-and-cut described in Section 3.5, it is intrinsically sequential—in particular, for the linear case as the dual simplex method does not exploit parallelization. So we decided to run NT multiple copies of it, in parallel, with slightly modified α and λ parameters to produce different search paths. When the first such run terminates, all other runs are aborted, and all the generated Benders cuts are statically added to the master which is solved once again to obtain the final lower bound. Finally, slack cuts are purged to avoid overloading the initial master.

As already observed, in our setting the subproblem does not decompose into smaller pieces, so each Benders cut separation is quite time consuming. As a matter of fact, for some large instances more than 90% of the overall computing time can be spent within the cut separation function. This is a very unusual setting for a general-purpose MIP solver, so one may expect that its default parameter tuning is inappropriate. In particular, it makes sense to use very aggressive parameters for internal heuristics, and for exploiting time-consuming strategies such as full strong branching and best-bound search that are not in the Cplex’s default. To be more specific, in our implementation we set to 2 (aggressive) the level of all Cplex’s internal cuts. We also selected the full-strong branching strategy (CPX_PARAM_VARSEL=3) and the pure best-bound search strategy (CPX_PARAM_NODESEL=1, CPX_PARAM_BBINTERVAL=1, and CPX_PARAM_BTTOL=0.0). As to heuristics, we decided to apply RINS heuristic at every node (CPX_PARAM_RINSHEUR=1) to feed our Benders-cut separator with low-cost integer solutions.

At each node of the branch-and-cut tree, we do not allow for more than 20 consecutive calls of the Benders separation function (100 for the root node). This is obtained by maintaing a counter K (one for each thread) which is reset to 0 when a node is first processed, and is increased by 1 before invoking the separation function. To limit computing time, we apply the following give-up mechanism. After having solved the current subproblem and possibly added the generated Benders cut to the master, we retrieve the primal optimal value UB (say) of the subproblem that was just solved. As UB is an upper bound on the best bound that can be obtained at the current node by Benders cuts, we set 
                           
                              K
                              =
                              +
                              ∞
                           
                         in case K ≥ 2 and UB is strictly smaller than the value of the current incumbent, meaning that we have no hope to prune the current node (unless the incumbent is updated, which is a very rare event). This policy turned out to speedup the overall computation, though we are aware of the fact that it prevents the generation of Benders cuts that could be useful to improve the bound in other nodes. Even with the above setting, it may happen that the fraction of computing time spent for separation is excessive, so we skip the separation of fractional solutions (within the so-called usercut callback) when this fraction exceeds 50% of the current computing time.

To ensure correctness, integer solutions that can update the incumbent are always separated (within the so-called lazyconstraint callback) so their actual cost is recomputed exactly.

By design, our branch-and-cut scheme learns a lot of information (notably: Benders cuts and heuristic solutions) during execution, and in particular after the root node. On the other hand, the root node plays a special role for what concerns preprocessing, internal cut generation and initial heuristics, so the more information is available at the root node the better. In particular, it is very important to start with a very good heuristic solution and with a rich family of Benders cuts, to favor root-node variable fixing and generation of internal cuts. As already mentioned, to escape Kelley’s cutting plane scheme we implemented our own stabilized cutting plane procedure before branch-and-cut, so the generated Benders cuts are immediately available at the root node. In addition, we found useful to increase the information available at the root node by a simple restart mechanism. Namely, before entering the final branch-and-cut run we stop the execution right after the root node (by setting CPX_PARAM_NODELIM=1), add the generated Benders cuts (saved in our own data structure) as static cuts to the master model, update the incumbent, and repeat. This restart mechanism is applied twice before entering the final run (CPX_PARAM_NODELIM=∞).

For the master problem, we used the following numerical tolerances: CPX_PARAM_EPINT= 0.0, CPX_PARAM_EPRHS=1e-7, and CPX_PARAM_EPGAP=1e-6. To be consistent, for the subproblem we need an increased precision so we set CPX_PARAM_EPRHS = CPX_PARAM_EPGAP=1e-9. In addition, when solving the subproblem for the congested CFL we had to set CPX_PARAM_CALCQCPDUALS=2 to skip some preprocessing reductions that would inhibit the computation of the optimal dual solution (and reduced costs) needed to derive the Benders cut.

In this section we report on our computational experience on four classes of CFL instances from the recent literature. When it comes to linear CFL, we compare the performance of our Benders approach against state-of-the-art exact and heuristic methods published in the last few years. For congested CFL, we compare our generalized Benders decomposition framework with the perspective reformulation solved by the commercial solver IBM ILOG Cplex 12.6.1.

Our algorithm has been implemented in C, and derived on top of IBM ILOG Cplex 12.6.1 callable library. The computational study is conducted on a cluster of identical machines each consisting of an Intel Xeon E3-1220V2 @ 3.1 GHz, with 16 GB of RAM each. This processor was launched by Intel in 2012 and is credited for 1892 Mflop/s in the Linpack benchmark report of Dongarra (2014). Computing times reported are wall-clock seconds and refer to 4-thread runs. The default timelimit is set to 50,000 seconds, unless stated otherwise. In our Benders implementation, all Cplex parameters not mentioned in the previous section were left at their default values. For Cplex stand-alone runs, e.g., the perspective reformulation, we set CPX_PARAM_EPGAP=1e-6 and left all other parameters at their default values.

The following abbreviations are used in the tables presented throughout this section: the total computing time in wall-clock seconds (t[s]), the time needed to solve the LP-relaxation at the root node (tr
                     [s]), the total number of enumerated branch-and-bound nodes (Nodes), the percentage gap at the root node (gr
                     [%]), and the percentage gap obtained after reaching the timelimit (g[%]). The gaps are computed as 
                        
                           100
                           
                              (
                              
                                 z
                                 
                                    U
                                    B
                                 
                              
                              −
                              
                                 z
                                 
                                    L
                                    B
                                 
                              
                              )
                           
                           /
                           
                              z
                              
                                 U
                                 B
                              
                           
                           ,
                        
                      where zUB
                      is the optimal or best objective value found by our Benders approach and zLB
                      is the appropriate lower bound for the gap. This calculation of gaps is consistent with the one from the recent literature, see, e.g., (Guastaroba & Speranza, 2012).

The following four sets of benchmark instances are considered in our study:

                           
                              •
                              
                                 cap*: This is a subset of non-trivial instances from the OR-Library (Beasley, 2015). The set consists of 12 instances with 
                                    
                                       |
                                       I
                                       |
                                       =
                                       1
                                       ,
                                       000
                                    
                                  and 
                                    
                                       |
                                       J
                                       |
                                       =
                                       100
                                    
                                 . Note that the remaining (smaller) instances available in this library are left out, since they can be easily solved by modern MIP solvers in fractions of a second.


                                 GK: These instances have been generated by Görtz and Klose (2012); Klose and Görtz (2007) and tested by the branch-and-price and Lagrangian-based branch-and-bound from Klose and Görtz (2007) and Görtz and Klose (2012), respectively. Instances are generated following the procedure proposed by Cornuéjols et al. (1991): customers and potential facilities are uniformly randomly placed in a unit square. Euclidean distances multiplied by 10 represent allocation costs per unit of flow. Facility opening costs are generated as 
                                    
                                       
                                          f
                                          j
                                       
                                       =
                                       U
                                       
                                          [
                                          0
                                          ,
                                          90
                                          ]
                                       
                                       +
                                       U
                                       
                                          [
                                          100
                                          ,
                                          110
                                          ]
                                       
                                       
                                          
                                             s
                                             j
                                          
                                       
                                       ,
                                    
                                  where U[a, b] stands for a uniformly distributed random number from [a, b). Customer demands and capacities of facilities are drawn uniformly at random from [5, 35] and [10, 160], respectively. Finally, the following scaling factor is used to rescale the capacities and create different subclasses of instances:

                                    
                                       
                                          
                                             r
                                             =
                                             
                                                ∑
                                                
                                                   j
                                                   ∈
                                                   J
                                                
                                             
                                             
                                                s
                                                j
                                             
                                             /
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                d
                                                i
                                             
                                             .
                                          
                                       
                                    
                                 Smaller instances from this set comprise a group of 75 instances with |J| × |I| ∈ {100 × 100, 100 × 200, 100 × 500, 200 × 200, 200 × 500} and consider values of r ∈ {3, 5, 10}. Larger instances from this set (introduced later in Görtz & Klose, 2012) comprise a group of 120 instances with |J| × |I| ∈ {300 × 300, 300 × 1500, 500 × 500, 600 × 1500, 700 × 700, 1000 × 1000} and the values of r ∈ {5, 10, 15, 20}. Instance generator has been provided by Görtz and Klose (2012) and is available online (http://home.imf.au.dk/aklose/CFLP/generator.tgz).


                                 i*: These instances were used to test the branch-and-cut-and-price algorithm by Avella and Boccia (2009) and are available at http://www.ing.unisannio.it/boccia/CFLP.htm. They are generated following the same procedure proposed in Cornuéjols et al. (1991): the set consists of 100 instances of size |J| × |I| ∈ {300 × 300, 300 × 1500, 500 × 500, 700 × 700, 1000 × 1000} and r ∈ {5, 10, 15, 20}.


                                 p*: These instances have been addressed by the heuristic algorithms of Avella et al. (2009) and Guastaroba and Speranza (2012). They consist of three groups, denoted by test bed A, B and C, containing 150, 145 and 150 instances, respectively. All test beds are with |J| × |I| ∈ {800 × 4400, 1000 × 1000, 1000 × 4000, 1200 × 3000, 2000 × 2000} and r ∈ {1.1, 1.5, 2, 3, 5, 10}. The only difference between the test beds concerns allocation costs: these are two orders of magnitude smaller than facility opening costs for test bed A, one order of magnitude smaller than facility opening costs for test bed B, and of the same order as the facility opening costs for test bed C. The first two test beds are publicly available at http://wpage.unina.it/sforza/test/ , the last one at http://or-brescia.unibs.it/instances/instances_clfp. To the best of our knowledge, these instances were not solved to optimality by any of the previously proposed approaches. Only heuristic results from Avella et al. (2009) and Guastaroba and Speranza (2012) are available. Instances p* contain up to 2,000 facilities and 4,000 customers, hence the underlying compact models consist of millions of variables and constraints. This is the first attempt to solve the largest instances of this class to provable optimality.

For this set of instances, aside from giving results for our Benders approach, we also present results obtained by using our “blurred” option described in Section 3. Recall that the latter approach consists of generating uncapacitated Benders cuts in the user-cutcallback and in the initial in-out procedure. To ensure feasibility, capacitated Benders cuts are only separated in the lazy-cutcallback. Table 1
                            compares the computing times and the number of branch-and-bound nodes for the following four approaches: compact model solved by Cplex, Benders, “blurred” Benders, and the approach by Görtz and Klose (2012). We first observe that Benders is one order of magnitude faster than Cplex, and that “blurred” Benders outperforms Cplex by an even larger margin, with speedup factors between 10 and 90. This speedup is quite remarkable, in particular after noticing that “blurred” Benders sometimes requires ten times more branch-and-bound nodes than the remaining three approaches. There are two factors for the success of the “blurred” Benders in case of cap* instances. First, uncapacitated Benders cuts are separated in a combinatorial fashion, thanks to the separability of the subproblem, see (Fischetti et al., 2016), and the time-consuming separation of the unseparable subproblem is performed only to cut off infeasible integer solutions. Second, the capacity requirements on facilities are, in case of cap* instances, not very tight in the underlying optimal solutions. Hence, uncapacitated Benders cuts successfully guide the branch-and-cut process, and allow for a faster exploration of the search space. Unfortunately, the other instances considered in our study do not exhibit the same structure, and the success of “blurring” was not confirmed in the remaining cases.

In Table 1 we also give the original computing times reported in Görtz and Klose (2012), that refers to an Intel Pentium D930 @ 3 GHz and IBM ILOG Cplex 8.0 (the latter being used as an LP solver, so it is not much slower than our 12.6.1 version). According to Görtz and Klose (2012), this hardware is comparable with an Intel Pentium 4 @ 3.06 GHz ranked at 1414 Mflop/s in the Linpack benchmark report of Dongarra (2014), while our own hardware is ranked 1892 Mflop/s. One can therefore conclude that Benders and Lagrangian-based branch-and-bound are two competitive approaches for cap*.

This set of instances has been previously tested by the two best exact methods from the literature: B&C&P by Avella and Boccia (2009) and B&B by Görtz and Klose (2012). In Table 2
                            we compare our Benders code with these two approaches, and with the compact model solved by IBM ILOG Cplex 12.6.1. Instances are grouped according to their size and the value of r, each group thus contains five instances. Computing times and number of branch-and-bound nodes, averaged per group, are reported. We again provide the computing times as originally reported in the respective papers on slower systems: results from Avella and Boccia (2009) were obtained on an Intel Pentium IV @ 1.7 GHz (credited for 796 Mflop/s in Dongarra, 2014) and IBM ILOG Cplex 8.1, while those for Görtz and Klose (2012) were obtained on an Intel Pentium D930 @ 3 GHz (credited for 1414 Mflop/s) and IBM ILOG Cplex 8.0. As already mentioned, our own results have been obtained on an Intel Xeon E3-1220V2 @ 3.1 GHz (credited for 1892 Mflop/s) and IBM ILOG Cplex 12.6.1.

Surprisingly, IBM ILOG Cplex 12.6.1 solves all the i* instances to optimality. The remaining three methods have difficulties with the largest ones of size 1000 × 1000. There are two instances with 
                              
                                 r
                                 =
                                 15
                              
                            that were not solved by Avella and Boccia (2009) within their imposed timelimit of 100,000 seconds. One instance with 
                              
                                 r
                                 =
                                 5
                              
                            was unsolved by Görtz and Klose (2012). Similarly, our method does not manage to prove the optimality for a single instance with 
                              
                                 r
                                 =
                                 15
                              
                            (although its final gap remains below 0.08%). Following (Görtz & Klose, 2012), average computing times reported in Table 2 do not take in consideration these unsolved cases. Comparing Benders and Cplex with respect to the average computing times and for instances of different sizes, we observe that Benders is much faster than Cplex in all cases, except for size 1, 000 × 1, 000 and 
                              
                                 r
                                 =
                                 15
                              
                            where Benders and Cplex are comparable. We want to point out that it would be possible to tune our code to speedup convergence for some special cases, but this was not the intention of our computational study. Instead, we prefer to provide a stable and robust implementation, despite the unsatisfactory performance in a very few cases.

The overall results for i* indicate that Benders often outperforms the B&C&P, and that it is competitive with Lagrangian-based B&B. The latter method is often faster than Benders, despite the fact that it sometimes requires 10 times more branch-and-bound nodes for proving optimality. Indeed, B&B is faster in exploring the search space because Lagrangian relaxation solved at each node of the B&B tree boils down to a simple knapsack problem (of a small size) that can be efficiently solved in pseudo-polynomial time, whereas Benders suffers from the non-separability of the subproblem.

Finally, it is interesting that B&B and Benders are complementary, when it comes to efficiency in solving the largest among these instances. Whereas the most difficult among 1, 000 × 1, 000 instances for B&B are those with tight capacities (
                              
                                 r
                                 =
                                 5
                              
                           ), they are the easiest ones for Benders, and vice versa, those with rather lose capacities 
                              
                                 (
                                 r
                                 =
                                 15
                                 )
                              
                            are the easiest for B&B and the most difficult ones for Benders. Instances with very lose capacities (
                              
                                 r
                                 =
                                 20
                              
                           ) are consistently the easiest ones for all four considered approaches.

For this family of instances, we first demonstrate the power of decomposition by comparing the computing times required for solving the root node relaxation by Benders and Cplex. Fig. 1
                           a shows a performance profile over 120 instances from this family: a point with coordinates (x, y) in this plot indicates that the computing time of y instances was ≤ x seconds. Whereas for solving the LP-relaxation at the root node Benders requires at most 170 seconds, for 13 instances Cplex requires more than one hour, and for 5 of them even more than two hours. For about 50% of instances, Cplex and Benders at the root node are competitive, but for the largest ones from this family with |J| × |I| ∈ {700 × 700, 600 × 1500, 1000 × 1000} Benders can clearly draw an advantage from the decomposition, by projecting out a large number of allocation variables. Accompanying Fig. 1b reports performance profiles for the gaps obtained by Cplex and Benders at the root node (denoted by Cplex-root and Benders-root, respectively). We observe that the obtained root gaps are almost identical, which confirms the effectiveness of the initial cut selection strategy described in Section 3.5. Notice that these instances exhibit extremely tight LP-relaxation gaps—more than 50% of them have LP-relaxation gaps ≤ 0.5%, and the largest LP-relaxation gap is < 1%.

Besides comparing the root node relaxations, we also ran Benders and Cplex with a timelimit of 3600 seconds; the obtained percentage gaps are also reported in Fig. 1b. For 75% of the instances, after one hour of computing time, Benders delivers solutions with optimality gaps ≤ 0.2%, whereas Cplex does not manage to solve even the LP-relaxation for 13 out of 120 cases.

We recall that these instances were introduced by Görtz and Klose (2012) who report optimal solutions for all of them, obtained within a timelimit of 50,000 seconds. After running Benders with a timelimit of 50,000 seconds we did not manage to solve all the instances from this family to provable optimality. However, the obtained gaps were extremely small: over all 120 instances, the average and the maximum gap that we obtained are 0.08% and 0.4%, respectively. The main difficulty of the Benders approach remains closing the last per-mills of the gap in most of the cases. More precisely, from 120 instances of this set, 38 instances are solved to optimality, for 31 the gap is < 0.05%, for 40 the gap is between 0.05% and 0.2% and for only 11 of them, the gap is between 0.2% and 0.4%.

This set represents the family of largest benchmark instances, with up to 2000 facilities and 4000 customers, that, prior to this work, were not tackled by exact approaches. For this family of 445 instances, Benders was able to prove optimality in 210 cases (within our default timelimit of 50,000 seconds).

In the following, we first compare Benders with the kernel search heuristic of Guastaroba and Speranza (2012) (denoted by GS in the following), that was shown to significantly improve the previously published heuristic results by Avella et al. (2009). For that purpose, we stop Benders after enumerating 10 branch-and-bound nodes and report the obtained percentage gaps and computing times. Fig. 2
                            shows performance profiles considering the percentage gaps and the computing times, separated by test beds A, B and C. Results for (Guastaroba & Speranza, 2012) have been obtained using an Intel Xeon @ 2.27 GHz (which is about 30% slower than our computer) and IBM ILOG Cplex 12.2. One observes that Benders always produces smaller gaps in shorter computing times for all three test beds. The difference is especially pronounced for test bed C: the worst gaps obtained by Benders are ≤ 2% (and in 80% of all instances even ≤ 1%), whereas GS gaps are > 2% for 70% of all instances, and can be as large as 8%.

The idea of enumerating only 10 B&B nodes by Benders was mainly to demonstrate its ability to serve as an efficient heuristic outperforming other state-of-the-art CFL heuristics. Even as a heuristic, Benders manages to prove optimality for 5 (out of 150) instances of test bed A, for 0 (out of 145) instances of test bed B and for 15 (out of 150) instances of test bed C. By increasing the timelimit to 3600 seconds (50,000 seconds, respectively), Benders proves optimality for 86 (97) instances from test bed A, 22 (40) from test bed B, and 68 (73) for test bed C.

To assess the efficacy and computational limitations of generalized Benders decomposition for congested CFL, we consider the group of i* instances introduced above with up to 1,000 facilities and 1,000 customers. The number of open facilities p, which is specified as part of the input, is defined as 
                           
                              p
                              =
                              ⌊
                              
                              π
                              
                              |
                              J
                              |
                              
                              ⌋
                              ,
                           
                         where π ∈ {0.4, 0.6, 0.8}. Since no previous computational studies are available, we focus on comparing the performance of Benders against the perspective reformulation (cf. Section 2.2) which is solved by IBM ILOG Cplex 12.6.1 using second order cone constraints. Tables 3
                         and 4
                         summarize the obtained results. Each line corresponds to the first instance from the i* group with a fixed scaling ratio r ∈ {5, 10, 15, 20} (namely, instances i*_1, i*_6, i*_11, and i*_16) and a fixed value of π. For each instance we report the optimal solution value, the percentage gap and the computing time at the root node, plus the final percentage gap and the overall computing time. Runs for which the timelimit of 50,000 seconds is reached, are marked with TL in the computing-time column. Note that some runs for the perspective reformulation were aborted due to memory problems before any meaningful output was produced, in which case “–” entries are shown in the tables.

Recall that the relative tolerance CPX_PARAM_EPGAP for the master in Benders and for Cplex is set to 1e-6 in our experiments, i.e., as soon as the percentage gap between the lower and upper bound is < 0.0001%, the corresponding method terminates and reports the obtained solution as optimal. The OPT values reported in the tables are those obtained by Benders.

The obtained results indicate that Benders beats the perspective reformulation by a large margin: out of the 60 considered instances, Benders solves 45 to optimality, and for the remaining 15 it reaches the timelimit with the final gaps ≤ 0.3%. On the contrary, the perspective reformulation delivers optimal solutions for only 21 cases, while for 23 instances the timelimit is reached with final gaps as large as 35%, and for 16 instances memory problems are experienced (and no lower or upper bounds have been reported by Cplex). Besides, the performance of Cplex is quite unstable, with differences in computing times (for instances of the same size) varying by a factor of 100 or more (cf. the first two lines of Table 3). On the contrary, Benders’ performance remains stable with gaps at the root node being ≤ 0.3% and the root node computing times staying below two hours in most of the cases.

Finally, to test the effects of the cardinality constraint (8) on the algorithmic performance, we provide Table 5
                         in which the perspective reformulation is compared with our Benders decomposition on the same set of benchmark instances, but without the constraint (8). One observes that in terms of the obtained final gaps and the overall CPU time, there is no significant difference in the performance of Benders, when compared to the results shown in Tables 3 and 4. Only for the instances of size 300 × 1500, the problem becomes easier (for both approaches), which can be explained by the fact that the optimal solution requires to open all available facilities, which is not the case for the remaining instances.

@&#CONCLUSIONS@&#

This paper provides a computational study of a modern implementation of Benders decomposition, applied to two problems with non-separable subproblems: linear capacitated facility location, and its non-linear but convex variant known as congested CFL.

Our Benders implementation is rather simple and general, and was not tweaked for the specific application at hand. In particular, we introduced a simplified way of deriving optimality generalized Benders cuts for convex problems, that works well in practice and is straightforward to implement.

The resulting method is simpler and more efficient than some of the state-of-the art exact and heuristic approaches for linear CFL. The only exact method that remains competitive with Benders is another relatively simple approach proposed by Görtz and Klose (2012) and based on a Lagrangian relaxation. As pointed out by its authors, this Lagrangian-based branch-and-bound can work surprisingly well because of the fast way of solving the Lagrangian relaxation in combination with an effective branching strategy. In such a setting, Benders decomposition is intrinsically penalized because of the large overhead imposed by the non-decomposable LP/QP subproblems. Nevertheless, the obtained results indicate our simple Benders decomposition can be considered one of the state-of-the-art solution approaches for CFL.

As to the congested CFL problem, Benders clearly qualifies as the best-available solution method.

@&#ACKNOWLEDGMENTS@&#

This research was funded by the Vienna Science and Technology Fund (WWTF) through Project ICT15-014. The first author was also supported by the University of Padova (Progetto di Ateneo “Exploiting randomness in Mixed Integer Linear Programming”), and by MiUR, Italy (PRIN project “Mixed-Integer Nonlinear Optimization: Approaches and Applications”). The work of I. Ljubić and M. Sinnl was also supported by the Austrian Research Fund (FWF, Project P 26755-N19), while that of the last author was also supported by an STSM Grant from COST Action TD1207. Thanks are also due to three anonymous referees for their helpful comments.

@&#REFERENCES@&#

