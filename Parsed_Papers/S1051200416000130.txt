@&#MAIN-TITLE@&#Single chains to represent groups of objects

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Chain codes representations are applied to binary objects.


                        
                        
                           
                           Concatenation of the chain codes is achieved.


                        
                        
                           
                           Each object can be recovered without loss of information.


                        
                        
                           
                           Context-mixing algorithm is applied to the single chain.


                        
                        
                           
                           Greater compression levels are obtained.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Single chains

Chain codes

Contour shapes

Compression

Context-mixing

@&#ABSTRACT@&#


               
               
                  A chain code is a common, compact and size-efficient way to represent the contour shape of an object. When a group of objects is studied using chain codes, previous works require to obtain one chain code for each object. In this paper we assign a single chain to a group of objects, in such a way that all the properties of each object of the group can be recovered from the single chain. In order to achieve higher levels of compression, we propose a lossless method, that consists of representing a group of objects by means of a single chain, and then to apply a context-mixing algorithm. Regarding other methods of compression of the state-of-the-art, our experiments demonstrate that the best compression performance is achieved when our lossless method is applied. In this case more than 15% of a better compression level is reached.
               
            

@&#INTRODUCTION@&#

A chain code is a common and compact way to represent a contour shape.

The “Freeman chain code”, proposed by Freeman in 1961 [1], is known as F8 chain code (F8 for short). It is composed of eight directions and travels through the center of the pixels of a contour shape on the basis of eight connectivity. Each movement direction is codified using a symbol 
                        α
                        ∈
                        {
                        0
                        ,
                        1
                        ,
                        2
                        ,
                        …
                        ,
                        7
                        }
                      in counter clockwise direction (see Fig. 1
                     ).

On the other hand, F4 chain code (F4 for short) travels through the edges of the pixels of a contour shape using four connectivity. A movement direction is codified using a symbol 
                        α
                        ∈
                        {
                        0
                        ,
                        1
                        ,
                        2
                        ,
                        3
                        }
                      (see Fig. 2
                     ). It is also known as a crack code because it covers the contour shape along edges of border pixels [2–6].

In 1999, Bribiesca [7] proposed the vertex chain code, denoted by VCC. Among its most important features, VCC is composed by the symbols 
                        0
                        ,
                        1
                      and 2. It has some information between the contour shape and the inner part of the object. This code represents the changes made of a contour shape by computing the number of affected pixels (see Fig. 3
                     ).

Sánchez-Cruz and Rodríguez-Dagnino [8] proposed, in 2005, the 3OT chain code (3OT for short). They compared 3OT with F4 and obtained a better result thanks to the use of the symbols 
                        0
                        ,
                        1
                      and 2 to label the changes generated in relation to orthogonal directions. 3OT has the same number of symbols than VCC, however it is composed of 3 vectors to codify the contour: reference, support and change. The symbol 0 represents no changes between reference and support, 1 represents a change equal to reference and 2 represents a change in contrary sense of the reference (see Fig. 4
                     ).

Relied on F8, also in 2005, Kui and Žalik [9] proposed a new chain code, that we called here AF8 chain code (AF8 for short). This code is based on changes obtained with every pair of F8 code vectors when following the contour, i.e. every vector of change in the contour is compared with the previous one, and depending on the angle, a symbol is assigned (see Fig. 5
                     ). AF8 was compared with F4, F8, VCC and 3OT 
                     [10], and the results showed that AF8 reported more advantages when using the Huffman algorithm. However, in 2009 the combination 3OT-Arithmetic coding [11] performed better compression levels than AF8-Arithmetic.

From 
                        F
                        4
                        ,
                        
                           VCC
                        
                        ,
                        3
                        
                           OT
                        
                        ,
                        F
                        8
                      and AF8 other chain codes have been derived. The derived codes are obtained when combining the symbols that appear in the contours, making a probabilistic model to modify the number of bits required to store the coded contour shape. For example, 
                        
                           
                              E
                           
                           
                              −
                           
                        
                        
                           VCC
                        
                     , 
                        
                           
                              V
                           
                           
                              −
                           
                        
                        
                           VCC
                        
                      and 
                        
                           
                              C
                           
                           
                              −
                           
                        
                        
                           VCC
                        
                      chain codes were proposed in [12]. The 
                        
                           
                              E
                           
                           
                              −
                           
                        
                        
                           VCC
                        
                      chain code was obtained by considering that VCC uses two bits to represent three symbols. The 
                        
                           
                              V
                           
                           
                              −
                           
                        
                        
                           VCC
                        
                      chain code arises by considering a variable-length of VCC. The 
                        
                           
                              C
                           
                           
                              −
                           
                        
                        
                           VCC
                        
                      chain code is based on applying the Huffman algorithm on the VCC code-symbols. On the other hand, the 
                        
                           
                              M
                           
                           
                              −
                           
                        
                        3
                        
                           OT
                        
                      chain code was proposed when considering groups of symbols of 3OT 
                     [13], whereas MDF9 chain code was proposed by considering the AF8 patterns in pieces of discrete straight lines of the contour shapes [14]. Recently, NAD chain code was introduced in [15] and obtained more compression levels in [16]. It is a variation of AF8, where instead of using the symbols 
                        0
                        ,
                        …
                        ,
                        7
                     , the authors use four symbols grouped as follows: 
                        0
                        ,
                        2
                        ,
                        310
                        ,
                        311
                        ,
                        312
                        ,
                        301
                        ,
                        300
                      and 1 (and labeling the angles according to Fig. 6
                     ).

The AAF8 chain code is the newest basic code (it is not derived from another known code), introduced in [17]. AAF8 chain code is composed of three vectors (two angles), in which, regarding the reference vector, a symbol of change direction is given, independently of the support vector direction. It is considered in a basis of eight connectivity. Table 1
                      shows the basic and the derived codes.


                     NAD is the latest chain code that surpasses the compression levels of the previous codes. We have compared our method with it. However, 3OT and AF8 are also worthy to be compared because they are very close to the NAD compression ratios, according to recent obtained results by Žalik et al. [16]. From these works, it can be observed that looking for better modifications of basic chain codes, together with the help of information theory, we can obtain a better compression performance. Of course, we must take into account that compression is also related to recognition, in the sense of being able to recognize redundancy in the information given by the geometry of the objects.

In order to complete the comparisons, we also made our implementations using F8 and F4, because they are the classical chain codes used in literature.

All the chain codes above mentioned have the common particularity that they were designed to represent a contour shape of an isolated object. However, to achieve even higher compression levels, we propose to change the paradigm, instead of handling objects with isolated chains we now represent groups of objects using a single chain. The idea is simple: we concatenate the chain codes of each contour shape of the group. In general the concatenation of chains is always possible, and in order to recover the single chains that form the concatenated chain, it is not necessary to have more information, like the length of each single chain and the position of each object.

The purpose of the paper is to be able to transmit and maintain the shapes without loss of information from an original repository. Often the object repositories are given in different files, which can be numerated to sort the different objects. However, to save memory storage space, the set of objects can be placed in a single file, making sure the information on the form is unchanged, keeping it in a minimum bounding rectangular frame. As we demonstrate in this work, we avoid all extra storage thanks to the characteristics of the chain codes of objects. However, there are other interesting applications that do not need such an extra storage information, as we explain in Section 4.4.

Of course, if a real scene want to be recovered, the positions of objects should be taken into account, then an extra storage information has to be spent, like the distance between objects. This distance can be stored between chain as the number of pixels among starting pixel between each pair of objects.

Since Freeman proposed the first chain code [1], a considerable amount of papers using chain codes for a wide variety of issues in different fields have appeared. On the one hand, they have been studied theoretically to propose unique descriptors and to reach high compression levels for binary objects [1,7–18]. When a group of objects is studied, authors of these previous published articles usually encode object by object.

On the other hand, chain codes have been used to real applications, like map representations and compression [2,19,20], to look for dominant points [21–24], to extract and to encode edges from 3D scenes [25–27], for analysis and shape recognition [28–30], for recognition of skeletal structures [31], and more recently for analysis and document compression [32–34].

For recognition tasks, obtaining a unique descriptor for each object that permits us object classification is a challenge. Perhaps this conviction has made the researchers do not propose until now concatenating the descriptors for groups of objects.

The novelty of our proposed method is to no longer consider isolated objects. As we have demonstrated our method facilitates keep such descriptors into a single chain, to recover subsequently object by object (for further analysis and recognition tasks if it is desired).

Some clues that strings can be better compressed with longer strings come from the following previous works: for example, Sahami and Shayesteh [35] used a technique based on neural networks to find high compressions, they noted that the compression ratio increases linearly with the image size. Also, in [11] was noticed that compression rates increase while contour perimeter also increases.

The contents of this work are as follows. In Section 2, some preliminaries are given. In Section 3 the concept of a chain code for a contour shape is extended to a group of objects by using only a single chain. Experiments and results exploiting the idea of using a single chain code for a group of objects are given in Section 4. Finally, in Section 5 some conclusions of this paper are given.

In this section we introduce some concepts, algorithms and notations used throughout this work.

An alphabet 
                     
                        A
                      is a set of symbols. A chain C of length n over an alphabet 
                     
                        A
                      is a sequence of n elements of 
                        A
                     , given by next expression:
                        
                           
                              C
                              :
                              =
                              
                                 
                                    c
                                 
                                 
                                    1
                                 
                              
                              
                                 
                                    c
                                 
                                 
                                    2
                                 
                              
                              ⋯
                              
                                 
                                    c
                                 
                                 
                                    n
                                 
                              
                              ,
                              
                              
                                 
                                    c
                                 
                                 
                                    i
                                 
                              
                              ∈
                              A
                               for all 
                              i
                              =
                              1
                              ,
                              …
                              ,
                              n
                              .
                           
                        
                      If there is not ambiguity hazard about the alphabet 
                        A
                     , we just say that C is a chain.

Let 
                        C
                        :
                        =
                        
                           
                              c
                           
                           
                              1
                           
                        
                        ⋯
                        
                           
                              c
                           
                           
                              n
                           
                        
                      and 
                        T
                        :
                        =
                        
                           
                              t
                           
                           
                              1
                           
                        
                        ⋯
                        
                           
                              t
                           
                           
                              m
                           
                        
                      be chains of length n and m, respectively. We define the concatenation of C and T, denoted by 
                        C
                        ⋅
                        T
                      or CT, as the chain:
                        
                           
                              
                                 CT
                              
                              :
                              =
                              
                                 
                                    c
                                 
                                 
                                    1
                                 
                              
                              ⋯
                              
                                 
                                    c
                                 
                                 
                                    n
                                 
                              
                              
                                 
                                    t
                                 
                                 
                                    1
                                 
                              
                              ⋯
                              
                                 
                                    t
                                 
                                 
                                    m
                                 
                              
                              .
                           
                        
                     
                  

Let Γ be a contour shape of an object. A chain code of Γ is a chain 
                        C
                        (
                        Γ
                        )
                      that represents (encode) the contour shape Γ, this means that it is possible to recover (decode) the contour shape Γ using only the information of the chain code 
                        C
                        (
                        Γ
                        )
                     .

The contour shape of an object can be seen as a set of vectors [17], so, a chain code is a representation of a set of vectors. As a consequence, all the basic codes can be handled as vector components, VCC inclusive, as it is explained also in [17].

For data compression, several coding schemes have been used. One of the most popular is the Huffman algorithm [36], which is simple and easily described in terms of a prefix-code tree, generated from the probability that a symbol has in a message, giving a short code to the most frequent symbol and a larger to that which appear with lower probability. For a code of size n the algorithm runs in 
                           O
                           (
                           n
                           log
                           ⁡
                           n
                           )
                         time, however the algorithm has the disadvantage that the code lengths must be rounded to a whole number of bits.

Another of the most known code-schemes is the Arithmetic algorithm [37]. It can be computed by updating the probabilities 
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                         of each symbol of a message in an interval between 0 and 1, dividing the interval in proportion to the probability distribution for each input symbol, narrowing the interval by a factor of 
                           
                              
                                 p
                              
                              
                                 i
                              
                           
                         on each symbol i. This procedure is carried out iteratively until reading the last symbol.

Another algorithm that obtains high compression rates is PPM (Prediction by Partial Matching) [38]. Although is slower to run, it has better compression performance than Huffman and Arithmetic. The main idea of PPM is to consider previous symbols (context) of a message to generate a conditional probability of the current symbol. Because the probability distribution tends to be high it can be used by Arithmetic algorithm to obtain a bit sequence, working much better than Huffman algorithm for this approach.

On the other hand, context-mixing algorithm is related to PPM in the sense that the compressor is divided into a predictor and an Arithmetic coder, except that it uses a binary alphabet to simplify encoding and model merging [39].

Particularly, PAQ archivers are a family of lossless data compressors based on context-mixing, and they are distributed as free software under the GNU general public license.

Among the PAQ archivers, one of them is called 
                           
                              PAQ
                           
                           8
                           L
                        , which is used for lossless compression of files with alphabets of few symbols. Throughout the work we use 
                           
                              PAQ
                           
                           8
                           L
                         because we want to apply it to chain codes, which come from alphabets of size 
                           2
                           ,
                           3
                           ,
                           4
                         or 8.

The Huffman and Arithmetic algorithms have been widely used to prove the binary object compression methods [12,9,19,14,10,13,11,8]. Relied on RLE and MTFT transform to decrease the chain code entropy, Žalik and Lucak [15], and Žalik et al. [16] reached the best rate compression to isolated binary objects. On the other hand, methods for document image compression have been carried out in [33] and [34], achieving better compression performance than JBIG2 and DjVu by a wide range, where 
                           
                              PAQ
                           
                           8
                           L
                         was utilized to compress the resulting file text of such proposed methods.

In this section we explain the coding and decoding of contour objects. To encode a group of N objects, the idea is simple but powerful: create a single chain formed by the concatenation of the chain codes of each object, i.e., to obtain the single chain S that represents the N objects 
                        
                           
                              Γ
                           
                           
                              1
                           
                        
                        ,
                        …
                        ,
                        
                           
                              Γ
                           
                           
                              N
                           
                        
                     , encode each 
                        
                           
                              Γ
                           
                           
                              i
                           
                        
                      and obtain the chain codes 
                        
                           
                              S
                           
                           
                              1
                           
                        
                        ,
                        …
                        ,
                        
                           
                              S
                           
                           
                              N
                           
                        
                     . Finally, define the single chain that represents all the objects as 
                        S
                        :
                        =
                        
                           
                              S
                           
                           
                              1
                           
                        
                        ⋯
                        
                           
                              S
                           
                           
                              N
                           
                        
                     .


                     
                        Example 3.1
                        The F4-single chain of Fig. 7
                            is
                              
                                 
                                    
                                       
                                          
                                             
                                                
                                                   S
                                                
                                                
                                                   F
                                                   4
                                                
                                             
                                          
                                          
                                             :
                                             =
                                          
                                          
                                             F
                                             4
                                             (
                                             a
                                             )
                                             ⋅
                                             F
                                             4
                                             (
                                             b
                                             )
                                             ,
                                          
                                       
                                       
                                          
                                             where
                                             
                                             F
                                             4
                                             (
                                             a
                                             )
                                          
                                          
                                             =
                                          
                                          
                                             000101111212122232330100033222323003
                                          
                                       
                                       
                                          
                                              and
                                             
                                             F
                                             4
                                             (
                                             b
                                             )
                                          
                                          
                                             =
                                          
                                          
                                             0010103001212121123322112332330303
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        

Observe that given N arbitrary chains, it is always possible to create the concatenation S from these N chains, but in order to recover the original objects, it is necessary to have more information, as the length of each individual chain and the position of each of them in S. However, we avoid this extra storage exploiting the characteristics of the chain codes.

As we mentioned in Introduction, all the basic codes can be handled as vector components. This means that as a consequence, when a chain code is decoded, we obtain the sequence of vectors that represents the contour shape. 
                        Lemma 3.2
                        
                           Let C be a crack code of a contour shape Γ and let 
                           
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    v
                                 
                                 
                                    n
                                 
                              
                            
                           be the vectors obtained when C is decoded. There exists a unique vector 
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                            
                           such that the end of 
                           
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                            
                           is the beginning of 
                           
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                           
                           .
                        


                     
                        Proof
                        The existence is easy, it is 
                              
                                 
                                    v
                                 
                                 
                                    n
                                 
                              
                           . Assume 
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                            is the vector from the point 
                              (
                              0
                              ,
                              0
                              )
                            to the point 
                              (
                              1
                              ,
                              0
                              )
                           . Let 
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                            be a vector such that the end of 
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                            is the point 
                              (
                              0
                              ,
                              0
                              )
                           , the beginning of 
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                           . The beginning of 
                              
                                 
                                    v
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                            is the point 
                              (
                              0
                              ,
                              0
                              )
                           . 
                              
                                 
                                    v
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                            is not the vector to 
                              (
                              −
                              1
                              ,
                              0
                              )
                            neither 
                              (
                              0
                              ,
                              1
                              )
                            because 
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                            is the leftmost top vector of the contour shape. 
                              
                                 
                                    v
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                            is not the vector to 
                              (
                              1
                              ,
                              0
                              )
                            or 
                              (
                              0
                              ,
                              −
                              1
                              )
                            because in this case 
                              
                                 
                                    v
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              =
                              
                                 
                                    v
                                 
                                 
                                    1
                                 
                              
                            or 
                              
                                 
                                    v
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                              =
                              −
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                           , but vectors of a contour shape don not overlap. This means there is not a 
                              
                                 
                                    v
                                 
                                 
                                    i
                                    +
                                    1
                                 
                              
                            vector and thus 
                              
                                 
                                    v
                                 
                                 
                                    i
                                 
                              
                              =
                              
                                 
                                    v
                                 
                                 
                                    n
                                 
                              
                           .  □


                     
                        Remark 3.3
                        The contour shapes that we are considering in this work are always closed curves because they come from a real object, so, for this work, the previous Lemma is also valid for chain codes that are not crack codes, i.e., for codes that cover the contour shape traveling through the center of the pixels. The proof of this fact is similar.

The pair of previous results say that if we have a single chain S as the result of coding N objects, then, in order to recover the N objects, we need to decode the chain S as a simple chain code, until the end of one vector is the beginning of the first vector, in this moment we have completed an object.

The next algorithm is used to decode the single chain that represents the group on N objects.


                     
                        Algorithm 3.4
                        Decode N objects


                           Input A single chain S that represents N objects.


                           Output 
                           N objects 
                              
                                 
                                    Γ
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    Γ
                                 
                                 
                                    N
                                 
                              
                            represented by S.
                              
                                 1.-
                                 Let 
                                       
                                          
                                             v
                                          
                                          
                                             1
                                          
                                       
                                     be the first vector found when S is decoded as a chain code.

Define 
                                       j
                                       :
                                       =
                                       1
                                       ,
                                       i
                                       :
                                       =
                                       1
                                     and the set of vectors 
                                       V
                                       :
                                       =
                                       {
                                       
                                          
                                             v
                                          
                                          
                                             1
                                          
                                       
                                       }
                                    .


                                    
                                       i
                                       :
                                       =
                                       i
                                       +
                                       1
                                    . Let 
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                     the following found vector when S is decoded as a chain code.


                                    
                                       V
                                       =
                                       V
                                       ∪
                                       {
                                       
                                          
                                             v
                                          
                                          
                                             i
                                          
                                       
                                       }
                                    .

Define 
                                       
                                          
                                             Γ
                                          
                                          
                                             j
                                          
                                       
                                       :
                                       =
                                       V
                                     and 
                                       j
                                       =
                                       j
                                       +
                                       1
                                    .

Eliminate the symbols of S used to find the object V.


                           Else The sets 
                              
                                 
                                    Γ
                                 
                                 
                                    j
                                 
                              
                            represent the objects encoded by S.

Observe that condition Until guarantees that an object was found, because by Lemma 3.2, the first found vector with this property should be the end of an object.

@&#EXPERIMENTS AND RESULTS@&#

In this section we apply our proposed method of single chains to represent groups of objects, and, as a result, we obtain high levels of compression. To test our method, we use the 44 images of Fig. 8
                     . The first 12 objects of Fig. 8 were downloaded from the Repository [40]. The rest of the objects were downloaded from the Repository [41].

Let C be a chain. By 
                           C
                           +
                           
                              PAQ
                           
                           8
                           L
                         we mean the result of applying 
                           
                              PAQ
                           
                           8
                           L
                         to the chain C. The size, in bytes, of C is denoted by 
                           Size
                           (
                           C
                           )
                         and the size of 
                           C
                           +
                           
                              PAQ
                           
                           8
                           L
                         is denoted by 
                           Size
                           (
                           C
                           +
                           
                              PAQ
                           
                           8
                           L
                           )
                        . If C is a chain code, to specify what kind of code it is we write 
                           C
                           (
                           P
                           )
                        , where P is an element of 
                           B
                           :
                           =
                           {
                           F
                           4
                           ,
                           F
                           8
                           ,
                           
                              VCC
                           
                           ,
                           
                              AF
                           
                           8
                           ,
                           3
                           
                              OT
                           
                           ,
                           N
                           A
                           D
                           }
                        .

Let 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 C
                              
                              
                                 N
                              
                           
                         be the chain codes of N objects 
                           
                              
                                 Γ
                              
                              
                                 1
                              
                           
                           ,
                           …
                           ,
                           
                              
                                 Γ
                              
                              
                                 N
                              
                           
                         and let S be the single chain that represents the N objects. Results of this section show that for all 
                           P
                           ∈
                           B
                         we have
                           
                              
                                 Size
                                 (
                                 S
                                 (
                                 P
                                 )
                                 +
                                 
                                    PAQ
                                 
                                 8
                                 L
                                 )
                                 <
                                 
                                    ∑
                                    
                                       i
                                       =
                                       1
                                    
                                    N
                                 
                                 Size
                                 (
                                 
                                    
                                       C
                                    
                                    
                                       i
                                    
                                 
                                 (
                                 P
                                 )
                                 +
                                 
                                    PAQ
                                 
                                 8
                                 L
                                 )
                                 .
                              
                           
                         Moreover, the minimum of left side is reached when 
                           P
                           =
                           3
                           
                              OT
                           
                         and, in this case, 
                           Size
                           (
                           S
                           (
                           3
                           
                              OT
                           
                           )
                           +
                           
                              PAQ
                           
                           8
                           L
                           )
                         is up to 
                           25
                           %
                         less than the sum 
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 N
                              
                           
                           Size
                           (
                           
                              
                                 C
                              
                              
                                 i
                              
                           
                           (
                           P
                           )
                           +
                           
                              PAQ
                           
                           8
                           L
                           )
                        , for any other 
                           P
                           ∈
                           B
                        . This means that in order to improve, in up to 
                           25
                           %
                        , the compression, it is better to create a single chain with 3OT that represents all the objects of the image, instead of managing isolated chain codes.

The chain codes of the objects that appear in Fig. 8 are denoted by 
                           
                              
                                 C
                              
                              
                                 1
                              
                           
                           (
                           P
                           )
                           ,
                           …
                           ,
                           
                              
                                 C
                              
                              
                                 44
                              
                           
                           (
                           P
                           )
                        , where 
                           P
                           ∈
                           B
                        . Table 2
                         shows the values 
                           Size
                           (
                           
                              
                                 C
                              
                              
                                 i
                              
                           
                           (
                           P
                           )
                           +
                           
                              PAQ
                           
                           8
                           L
                           )
                        , for 
                           i
                           =
                           1
                           ,
                           …
                           ,
                           44
                         and 
                           P
                           ∈
                           B
                        .

In order to see the behavior of single chains, from Fig. 8 we have formed 12 groups of objects. There are objects with a short length in comparison of other objects. For instance the length of objects 
                           6
                           ,
                           7
                           ,
                           8
                         and 9 are 
                           2264
                           ,
                           1236
                           ,
                           5996
                         and 1096, respectively. Thus the sum of the lengths of objects 
                           6
                           ,
                           7
                         and 9 is less than the length of object 8. For that reason we have decided that the smallest group, the Group 1, is composed by the objects of the first repository, i.e. the first 12 objects. Groups 
                           2
                           ,
                           3
                           ,
                           4
                         and 5 are composed by objects from 1 to 13, 14, 15 and 16, respectively. Group 6 is formed by objects 1 to 20 and then we added 4 objects to each new group until Group 12, which is formed by the 44 objects.

For 
                           j
                           =
                           1
                           ,
                           …
                           ,
                           12
                        , let 
                           
                              
                                 N
                              
                              
                                 j
                              
                           
                         be the number of objects of the group j and let 
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                           (
                           P
                           )
                         be the single chain that represents the objects of same group j with the codification 
                           P
                           ∈
                           B
                        . Table 3
                         shows the values 
                           Size
                           (
                           
                              
                                 S
                              
                              
                                 j
                              
                           
                           (
                           P
                           )
                           +
                           
                              PAQ
                           
                           8
                           L
                           )
                         (row “Single chain”) and 
                           
                              
                                 ∑
                              
                              
                                 i
                                 =
                                 1
                              
                              
                                 
                                    
                                       N
                                    
                                    
                                       j
                                    
                                 
                              
                           
                           Size
                           (
                           
                              
                                 C
                              
                              
                                 i
                              
                           
                           (
                           P
                           )
                           +
                           
                              PAQ
                           
                           8
                           L
                           )
                         (row “Isolated”) for 
                           j
                           =
                           1
                           ,
                           …
                           ,
                           12
                         and 
                           P
                           ∈
                           B
                        . In both cases, computing the sum and using single chains, the lowest value is always given when the codification is made with 3OT. Column “Percent of improvement” shows the percent of memory storage saved, when a group of objects is encoded with 3OT in a single chain rather than have encoded as isolated objects.


                        Fig. 9
                         shows that the performance by increasing the groups is not linear, however, results in a slightly warped curve, i.e. decreasing its slope for larger groups. As can be observed, this behavior tells that the longer is the concatenated string (i.e. as more objects are compressed), the higher the performance when using single chains.

Among the most used algorithms to compress chains of characters are Huffman, Arithmetic and context-mixing. Regarding the first two, versions of variable-length of Huffman and Arithmetic adaptive have also been used. Furthermore, the context-mixing algorithm already has an enhanced version of the Arithmetic algorithm.

Given a group of objects, as reported in Table 3, in terms of compression we now know that it is better to apply 
                           
                              PAQ
                           
                           8
                           L
                         on a single chain for the whole group rather than on separated chains. Now, some questions arise with respect to the performance of Huffman, Arithmetic and context-mixing algorithms: What is the behavior of these algorithms when
                           
                              (a)
                              a single chain for the whole group is obtained and then algorithms for compression are applied to this single chain?, or

isolated chain codes for every object are obtained and then algorithms for compressing are applied to each of these chains?

Which method does give the best compression level?

In order to give an answer, we have compared the performance of these three known algorithms. Table 4
                         shows the number of bytes required to compress individual objects using the Huffman algorithm. On the other hand, Table 5
                         shows the number of bytes required to compress individual objects using the Arithmetic algorithm.

Finally, Fig. 10
                         shows the behavior of bytes employed when chain codes and a single chain are used to encode the objects of Fig. 8. The left graph shows the average of bytes needed to encode an object of Fig. 8, when it is encoded element by element, i.e., for every object of the figure, a chain code is obtained, and then, an algorithm to compress is applied to every chain code. The right graph shows the average of bytes needed to encode an object of Fig. 8, when the it is encoded in a single chain and then, an algorithm to compress is applied.

From these results, it can be seen that, considering all the different chain codes, broadly speaking Huffman and Arithmetic algorithms compress slightly better when objects are treated in isolation, moreover, the efficiency remains practically equal to the best performances given by 3OT, AF8 and NAD, in this order. However, it is clear that when context-mixing algorithm is applied, the compression significantly improves the case of single chains by a wide margin.

In the case of compression for chain codes, Huffman has better performance on AF8, followed by NAD and then 3OT. A similar behavior on 3OT and AF8 had already been observed in [10]. On the other hand, Arithmetic performs better for 3OT, followed by AF8, as happened in [11]. Finally, 
                           
                              PAQ
                           
                           8
                           L
                         compresses all alike, especially when a single chain is considered.

For the Huffman method, there is a tradeoff between the bits assigned to the symbols and the total length of the string. Although Huffman works with three symbols that 3OT has, this method is more efficient with AF8 since there are two advantages: AF8 chain codes have shorter strings than 3OT, and also AF8 has three more frequent symbols, giving fewer bits to the most frequent, and more bits for the less frequent. The three most frequent symbols of AF8 are: 0, 1 and 2 (or 
                           
                              
                                 0
                              
                              
                                 ∘
                              
                           
                        , 
                           +
                           
                              
                                 45
                              
                              
                                 ∘
                              
                           
                         and 
                           −
                           
                              
                                 45
                              
                              
                                 ∘
                              
                           
                        , respectively), while the rest appear much less frequently, assigning to them more bits, of course. On the other hand, it is less efficient to use Huffman with 3OT because the number of bit allocation is increased. As we know, the perimeter covered with 3OT is greater than AF8 since AF8 goes through the centers of the contour pixels, while 3OT goes through the edges, causing longer chains than AF8. For a good example of this behavior see for example Table 5 of Ref. [10].

On the other hand, arithmetic method is more efficient for 3OT than for AF8, because it is not so sensible to the length of the chain but to the frequency of the symbols, thanks to the fact that, while reading input symbols, arithmetic normalizes the probabilities between 0 and 1. So, Huffman spends, at least, the same amount of bits than the length of the chain, on the contrary, arithmetic method does not necessarily make the same. Consider the extreme case of a chain with length of 1000, with pure 1 symbols. Huffman will give 1000 bits of compression, not less, whereas arithmetic algorithm will only give one bit, plus other more few bits for decoding the original length of ones. The case of absolute codes like F8 and F4, give the worst results in compression reported in literature since, broadly speaking, they represent the same shape information with different symbols, contrary to what 3OT and AF8 do, i.e. its eight symbol codes are more equally probable in the chains, spending more bits in symbol assignments.

Why is it better to use a single chain to represent the whole objects than to use a chain of each object? As can be seen from the results obtained in our work, the compression rates are higher if chain codes are concatenated than if are managed separately. Previous works like [14,13,15] have made improvements in the compression of chain codes than come from binary objects, thanks in part to the geometrical analysis of the shape-of-objects, trying to catch the redundancy present in the contours, which has resulted in finding pattern substrings and repetitions of bit streams, both to reduce the entropy and to improve compression of the chains. However, a deeper statistical analysis, as the one conducted by the 
                           
                              PAQ
                           
                           8
                           L
                         archiver, shows that together with the search for better patterns can help to find better statistical models.

The frequency and context information of the symbols contained in a single string obtained by the Arithmetic and context-mixing, is much poorer if all are concatenated. Thus, statistical information given by the frequency of each symbol is better enriched in a longer chain than in a shorter, causing, in the case of mixing context prediction of contexts, a marked improvement of compression. The advantage of using the 
                           
                              PAQ
                           
                           8
                           L
                         method is that it uses statistical models to estimate the probability distribution of symbols. It relies mainly on variable order models based on PPM (Prediction by Partial Matching), which perform a statistical analysis of models with different orders at the same time and then uses matching of larger context. It is based on the premise that the larger context which is available for statistical model is the best predictor.

Perhaps a comparison with existing methods in the literature is not entirely fair, since to date these methods have been performed on chains for each of the objects in the image, while we have proposed to use only one chain. Moreover, in our model we do not set out to reduce the entropy of chains, as is done, for example, in [15,16], who use RLE and Move-to-front Transform to reduce entropy of the chains. However, highlighting the advantage of encoding with a single chain to all objects, and even without reducing the entropy of the chain, let us consider the average number of bytes required to store the set of objects: for one hand, the best compression levels appeared in [16] for the first 12 objects tested, an average of 198.21 bytes is reported, while using our method our best average is 170 bytes, which is 14.23% of gain. However, as the number of objects increases, it is interesting to see that the gain with our method is increased, as shown in Table 3. Thus, for the case of the 44 objects, we obtained an average of 167 bytes, and our profit would be 15.7%.

Real applications of our method can be carried out as follows. For one hand, most of the repositories of shape of objects consider their allocations in separate images. Also, methods proposed by researches to represent objects are by means of separated chains. So, we propose to allocate the whole sample shape of objects under study, i.e., for research purposes, authors can use only one single image, and obtain only one single chain code to be transmitted in order to recover the whole objects in only one single image file.

As another application, it is important to find descriptors for individual objects. In this sense, we are proposing that it is not needed to save object by object. We can save all the objects in a big stream without extra information (as an explicit separation) and then obtain the descriptors of each object. This means that if we have a stream that represents a group of objects, and we want to apply a transform to all the objects, then we only need to apply the transform to the stream, and it is not needed to apply the transform to the chains separately, for individual objects.

Also, the fact of avoiding an explicit separation gives a world of new research. For instance it is possible to save all the properties of the objects in a single chain, without the necessity to work with each of the chains. For example, in the paper [42] authors proved that it is possible to count the number of holes of an image using only the symbols of the VCC chain code. So, using our proposed algorithm, it is possible to count the total number of holes of an image composed by N objects using only one big stream. This is valid even though we avoid an explicit separation. As future work, we suggest using this great idea by 3OT chain code.

Of course, we applied the algorithms of compression on the chain codes without transforming them to reduce its entropy, however, as another further work, if algorithms to reduce the entropy of a single chain code are implemented, the compression levels can be improved even more.

So, broadly speaking, there are three main reasons why we propose the concatenation method. Firstly, we have made it very clear that it is possible to concatenate the chain codes without an explicit separation and then recover object by object. If we have for example two objects with chain codes N1 and N2, and we obtain the big stream 
                           N
                           1
                           
                              dis
                           
                           N
                           2
                        , where dis represents the distance between N1 and N2, then of course we can recover the objects in exactly the same position. It is also obvious that we can recover the objects, because we are using an explicit separation in the big stream, however, for the applications given above it is not necessary to spend extra information given by dis, and also we are able to recover the original objects.

Another reason is because sometimes it is important to find descriptors for individual objects. In this sense, we are proposing that it is not needed to save object by object in separate files. We can save all the objects in a big stream without extra information, and then obtain the descriptors of each object. For instance, a complete study of corner detection, compactness, eccentricity, genus, etc., or even transforms of curves like contraction, rotation, closure and intersection [1], can be carried out. This means that if we have a stream that represents a group of objects, and we want to apply a transform to all the objects, then we only need to apply the transform to the whole stream.

Finally, concatenating chain codes, allows to save more memory storage.

@&#CONCLUSIONS@&#

As we know, in literature, a number of interesting articles about methods to represent, separately, contours of binary objects have appeared. Authors have carried out an analysis of length and compression performance. In this paper we have used the following strategy: a single chain that represents all the objects of a image has been found and then it has been applied the context-mixing algorithm.

We have proved that it is possible to save and recover the information of all the objects in a single chain.

Our experiments demonstrate that the combination of a single chain with 3OT and 
                        
                           PAQ
                        
                        8
                        L
                      achieve up to 
                        25
                        %
                      of efficiency, in compression, in comparison with managing chain codes representing each object of the image, and 15.7% better compression regarding the state-of-the-art.

As a consequence of single chains, giving one more step to what has been done so far in the literature to encode individual objects, we have proposed an new method to improve compression efficiency when considering groups of objects that appear in an image.

@&#ACKNOWLEDGEMENTS@&#

The first author would like to thank Universidad Autónoma de Aguascalientes for the moral and financial support to obtain a Ph.D. in the Centro de Investigaciones y de Estudios Avanzados del Instituto Politécnico Nacional. Second author, also thanks Universidad Autónoma de Aguascalientes for its financial support under grant PIINF14-2.

@&#REFERENCES@&#

