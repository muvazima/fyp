@&#MAIN-TITLE@&#Near optimal design of wavelength routed optical networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           Problem of wavelength routed network design is considered.


                        
                        
                           
                           Network design models augmented with valid inequalities provide lower bounds.


                        
                        
                           
                           A heuristic is developed for the problem.


                        
                        
                           
                           Computational experiments are reported on large problem instances.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

OR in telecommunications

Wavelength division multiplexing

Column generation

Network design

Heuristics

@&#ABSTRACT@&#


               
               
                  The problem of designing a wavelength routed optical transport network without wavelength conversion at intermediate nodes is considered. A class of valid inequalities for wavelength routing and assignment is reported and is used to augment traditional network design formulations. The resulting network cost provides a lower bound on the cost of a network that permits wavelength routing. The resulting network is shown to be optimal for a majority of the problem instances tested and in those cases where it is not, a trial-and-error method is proposed that is able to find near-optimal solutions within relatively short period of time. This is achieved by developing efficient and effective heuristics that attempt to provide a feasible wavelength routing. Computational tests are reported on relatively larger problem sizes than have been reported in literature on the wavelength routing problem.
               
            

@&#INTRODUCTION@&#

We address the problem of designing a wavelength routed optical transport network. We are given a graph 
                        
                           G
                           =
                           (
                           V
                           ,
                           E
                           )
                           ,
                        
                      called the supply graph, and the demands units dij
                      (integer valued) to be transported between each pair of nodes i, j ∈ V . An optical transport facility installed on edge e ∈ E at cost ce
                      can carry C simultaneous optical signals via wavelength division multiplexing (WDM) technology using wavelengths λ
                     1 to λC
                     . It is assumed that each unit of demand requires one wavelength. A demand may be routed from its origin to destination via several edges of E using optical switching at intermediate nodes. However, we assume that wavelength conversion at intermediate nodes is not permitted, and each demand must be assigned a specific wavelength λl
                     , 1 ≤ l ≤ C, which will be used on each edge of the end-to-end path of the demand. This is known in the literature as the wavelength continuity constraint. Another routing constraint is the non-splittability of demand units, i.e., each unit of demand must be carried along a single path, and cannot be split into smaller fractional units of size less than one unit and routed along several paths. However, if dij
                      > 1, then it can be split into individual units, each unit being of size one. The objective is to design a minimum cost network that will permit a feasible wavelength assignment and routing for each demand unit. We call this problem WRND, or wavelength routed network design.

This problem is quite difficult to solve (the problem is NP-Hard since a special case of the problem, that of deciding whether a feasible wavelength routing with wavelength continuity exists on a given network, is NP-Complete (Refer Chlamtac, Ganz, & Karmi, 1992), but a relaxed version of this problem, called the standard network design problem (NDP), also known as the network loading problem, is relatively easier to solve although this problem is also NP-Hard (Bienstock, Chopra, Günlük, & Tsai, 1998). If the wavelength continuity constraint and non-splittability constraint are relaxed, WRND reduces to the NDP. In the NDP, we require a minimum cost installation of facilities, each with capacity C, on the edges of G, that will simply permit a feasible multicommodity flow of all demands. Although this problem is also quite hard to solve, some recent results have permitted optimal solutions of this problem for instances with 25–30 nodes when the facility cost function is Euclidean in nature (Agarwal, 2015).

Given an instance of the WRND, the optimal solution of the corresponding instance of the NDP is clearly a lower bound on the optimal solution of WRND. Our design approach for WRND makes use of this observation to find a near-optimal solution of WRND as follows. We solve the NDP relaxation of WRND, obtaining the optimal solution x with cost Z(x). Given solution x, we attempt to find a feasible routing of demands in this network with non-splittability and wavelength continuity constraints imposed. If such a routing is indeed possible, then clearly, we have found the optimal solution of WRND. However, if a feasible routing is not achieved, let nλ
                      > C denote the number of layers needed. We solve the problem NDP again with a reduced facility capacity 
                        
                           
                              C
                              ′
                           
                           =
                           C
                           −
                           δ
                           ,
                        
                      obtaining a solution 
                        
                           x
                           
                              δ
                           
                           ′
                        
                      with cost 
                        
                           Z
                           (
                           
                              x
                              
                                 δ
                              
                              ′
                           
                           )
                        
                     . Clearly 
                        
                           Z
                           
                              (
                              
                                 x
                                 
                                    δ
                                 
                                 ′
                              
                              )
                           
                           ≥
                           Z
                           
                              (
                              x
                              )
                           
                        
                     . By conducting a process of trial and error on the value of δ, we attempt to find a minimum cost network that is feasible for WRND. Once such a solution has been found, 
                        
                           Z
                           
                              (
                              
                                 x
                                 
                                    δ
                                 
                                 ′
                              
                              )
                           
                           −
                           Z
                           
                              (
                              x
                              )
                           
                        
                      represents the optimality gap of this solution. Using this approach, we were able to obtain solutions that were within 1.2% of the lower bound in most cases on a set of test problems with 25 nodes, 50 edges and traffic matrices of varying densities. Our computational tests (Section 6) suggest that for high traffic density problems, a good choice of 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                           ,
                        
                      while for medium and low traffic density problems, a good choice of 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                           +
                           1
                        
                      or 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                           +
                           2
                        
                     .

We note that the problem of finding a wavelength routing of given set of demands on a given network so as to minimize the number of wavelengths required (called routing and wavelength assignment or RWA) has received a great deal of research attention (Chen & Banerjee, 1995; Dutta & Rouskas, 2000; Ramaswami & Sivarajan, 1995; Zang, Jue, & Mukherjee, 2000). However, the problem of designing a minimum cost network that will permit wavelength routing of a given set of demands is largely unaddressed in the literature. Our main contribution is in addressing this gap.

Given the NDP solution x, the problem of finding a feasible wavelength routing (RWA) can be formulated in multiple ways depending on the specific problem context. Some of these formulations are reviewed in Section 2. Here we briefly outline the formulation used in this paper. This formulation is similar to the formulation by Lee, Kang, Lee, and Park (2002). Given a network, for each specific wavelength λl
                      (called a λ-layer) we can route a subset of demands in this layer. The paths used by these demands must be non-overlapping because only one demand can use a given wavelength on each facility. This packing of demands into a specific λ-layer is represented by a column aj
                     , and the associated integer variable xj
                     , where j denotes the packing pattern, denotes the number of layers in the solution with this specific pattern of packing of demands. The formulation ensures that all demands are packed into one of the λ-layers, and the objective is to minimize the total number of layers needed to pack all demands. As there can be a very large number of ways to pack a layer, the formulation may have an extremely large number of columns. However, the LP relaxation of the problem can be solved using a column generation approach. Having solved the LP relaxation, we use a simple rounding heuristic to obtain an integer solution. If the total number of layers needed in this solution does not exceed C, we have found a feasible wavelength routing of all demands. Otherwise, information about the final number of layers needed is used to redesign the network with a suitable value of δ. We note that the column-generation subproblem is itself an integer program akin to a set-packing problem, and has a very large number of columns, each representing a demand path. This problem is also solved using a column generation approach and a rounding heuristic. However, the column generation subproblem in this case is the shortest path problem which is solved quite efficiently using Dijkstra’s algorithm.

Although the RWA approach described above produces good results, it is computationally rather inefficient due to a 2-tier column generation structure. We propose several strategies to improve its computational efficiency by decoupling the wavelength assignment from the routing of demands. Computational results demonstrate that these strategies are extremely effective, and lead to many fold reduction in the computational effort without a significant deterioration in the solution quality. The details are given in Section 3.

The basic approach suggested for solving the WRND problem worked quite well in some cases, but in other cases the optimality gap turned out to be unacceptably large. A closer examination of these cases revealed that occasionally, the optimal topology designed for the NDP contains certain features which pose serious bottlenecks with respect to the wavelength continuity constraints. We augment the NDP formulation with additional binary variables and constraints so that such bottlenecks are prevented in the optimal solution. The constraints added are indeed valid for the WRND, and therefore, the resulting solution represents a valid lower bound. When used with this strengthened formulation, our approach seems to work extremely well. As a result, we are able to report solutions that are within 1.2% of optimality for a majority of problem instances as large as 25 nodes, 50 edges, fully-dense traffic matrices, and 160 λ-layers.

The rest of the paper is organized as follows. In Section 2, we place the problem in the context of extant literature. The wavelength routing model is described in Section 3. The strengthened topology design model is described in Section 4. Implementation details are provided in Section 5 and computational experience is detailed in Section 6. Some concluding remarks and scope for future research is given in Section 7.

@&#LITERATURE REVIEW@&#

Wavelength division multiplexing is a well-explored area within telecommunication engineering. Good surveys on different aspects of the technology can be found in Sivalingam and Subramaniam (2000). The two separate subproblems of the WRND, i.e., NDP and RWA, have been independently well-studied. Recent advances in the NDP, using metric inequalities and p-partition based inequalities, (refer Agarwal, 2006; Avella, Mattia, & Sassano, 2007; Agarwal, 2015) coupled with new implementations of capacity formulation (Agarwal, 2013) are able to obtain optimal solutions to problems with up to 25–30 nodes in a few minutes of computing time, when the facility cost structure is Euclidean in nature.


                     Zang et al. (2000) provide a survey of different types of RWA problems that arise in WDM networks. In these problems, the underlying physical network is usually considered as given. Given this fixed physical network, the problem is to decide on wavelength routing and assignments to cater to a variety of objectives and constraints. The RWA problem considered in this paper is equivalent to the “static routing and wavelength assignment” problem discussed by Zang et al. (2000). Dutta and Rouskas (2000) provides a survey of formulations for the same problem with different objectives. Various heuristics are discussed. A key point of difference between such formulations and the formulation used in the present work is that in the former, the size of the formulation increases linearly with the number of wavelengths supported per fiber. In our model, as will be seen in Section 3, the size of the model is independent of the number of wavelengths supported per fiber.


                     Chen and Banerjee (1995) studied the RWA problem under the assumption of dynamic demands and limited number of wavelength converters in the network. Their approach relies on replicating the physical networks as many times as there are supported wavelengths. However, this can result in very large problem instances for higher number of wavelengths per fiber. Ramaswami and Sivarajan (1995) studied the RWA problem with the objective of maximizing the amount of carried traffic subject to wavelength continuity constraints. Linear programming-based bounds are developed. Ramaswami and Sivarajan (1996) considered the RWA problem with demands specified as traffic patterns (unlike specification in absolute units as considered in the present work) and constraints on propagation delays along paths. Propagation delays are not considered in our work, but can be easily incorporated, if required. Numerical results are presented based on the analysis of 6-node network topologies. Mukherjee, Banerjee, Ramamurthy, and Mukherjee (1996) studied the RWA problem in the context of two objectives — minimizing delay or maximizing the offered load. Sasaki (2000) discussed the RWA problem in cases of networks with specific underlying physical topology such as rings, trees and line networks. The author discusses various upper bounds on the number of wavelengths needed per fiber to support different traffic types. Chlamtac et al. (1992) studied the computational complexity of assigning wavelengths to lightpaths, each corresponding to a predefined set of contiguous arcs in the physical network, and showed that this problem is NP-Hard. Banerjee and Mukherjee (1997) developed a model that minimizes the average hop distance ignoring the wavelength-continuity constraint.


                     Banerjee and Mukherjee (1996) considered the RWA problem where the demand is either 1 or 0 units between each pair of nodes, and develop randomized heuristics to solve the problem. In the problem we consider, the number of demand units between a pair of nodes can be any arbitrary integer, and the method developed by Banerjee and Mukherjee (1996) cannot be directly applied. Liang and Shen (2000) considered the RWA in large WDM networks in the context of finding the least cost lightpath from an origin node to a destination node that may include wavelength conversion at intermediate nodes. The cost associated with the path comes due to the cost of using a particular wavelength on an edge and the cost of converting wavelengths at nodes. Pióro and Medhi (2004) provided formulation for RWA problems under survivability constraints and report computational results for relatively smaller problem sizes. Kennington, Olinick, Ortynski, and Spiride (2003) developed a heuristic method of solving a WRND under survivability constraints. Skorin-Kapov, Furdek, Pardo and Marino (2012) developed heuristics to address the problem of wavelength assignment to reduce the impact of crosstalk attack propagation.

Column-generation-based solution procedures for the RWA have also appeared in literature. Lee, Lee, and Park (2000) considered applying column generation for the RWA problem for ring networks. For mesh networks, Jaumard, Meyer, and Thiongane (2009) considered the problem of minimizing the blocking rate in the network. Our formulation and solution procedure for the RWA is nearly the same as that proposed byLee et al. (2002). These authors developed an exact solution procedure for the RWA problem using a 2-tiered column generation approach, where the column generation for upper tier is solved exactly using a branch and price approach. Such an approach can be computationally very expensive, and is not really necessary for the WRND whose objective is to design a least cost network that allows a feasible RWA for the demands. The contribution of our work in this regard is in developing effective and efficient heuristics to solve the RWA problem for larger problem instances than those reported by Lee et al. (2002). These approaches, when used in conjunction with a trial-and-error approach with the NDP, yield an optimal or near-optimal solution for the WRND within a reasonable computational time. Belgacem, Charon, and Hudry (2014) studied the RWA under scheduled traffic demand where a lightpath is required to be transmitted between two nodes in a given interval of time. Other approaches to RWA include using genetic algorithms (Banerjee, Mehta, & Pandey, 2004; Qin, Liu, Zhang, & Wen, 2002) and Lagrangean relaxation techniques (Guan, Guo, Zhai, Gong & Qiao, 2007; Zhang, Yang & Liu, 2004). Thus, many of the extant models for RWA focus on minimizing the number of wavelengths required. These are not directly applicable in our work where the focus is only on achieving a feasible routing given the number of wavelengths.

To summarize, the two problems — NDP and RWA — have been studied separately within the telecommunication and operations research community quite extensively. Computational results have been reported in literature for relatively smaller sized problems. This paper uses recent results for the NDP and augments the model with valid inequalities taking into account the structure of the RWA problem to design optimal or near-optimal networks for relatively larger problem instances. To the best of our knowledge, the joint problem — WRND — does not seem to have been addressed in the literature.

In this section, we describe the model and the solution approach for finding a feasible wavelength routing of all demands for a given network. It is assumed that the network has already been designed using the NDP model, the details of which are provided later in Section 4. We use the following notation.

                        
                           
                              
                                 
                                    G
                                    =
                                    (
                                    V
                                    ,
                                    E
                                    )
                                 
                               the graph with node set V (
                                 
                                    |
                                    V
                                    |
                                    =
                                    v
                                 
                              ) and edge set E (
                                 
                                    |
                                    E
                                    |
                                    =
                                    m
                                 
                              )


                              αe
                               the number of optical facilities installed on edge e ∈ E in the given network.


                              K Set of origin-destination pairs (hereafter referred to as commodities) with non-zero demands


                              dk
                               units of demand for commodity k ∈ K.

Since there are C wavelengths per fiber, the network can be thought to constitute C independent layers, each with αe
                      units of capacity available on edge e. Each layer can be used to route a subset of demands subject to the restriction that the number of demand paths using edge e in that layer should not exceed αe
                     . When a specific layer is used to route a particular demand, we say that the demand is packed in that layer. Any feasible packing of a subset of demands can be represented by a |K|-vector aj
                     , whose kth element akj
                      represents the number of demands of commodity k ∈ K packed in the pattern. With each vector aj
                     , we associate an integer variable xj
                      representing the number of layers for which the packing pattern aj
                      is used. The objective is to minimize the total number of layers needed for a feasible packing of all demands. If this number turns out to be less than or equal to C, then we have found a feasible wavelength routing of all demands. Let J denote the set of all possible demand packing patterns. Then, the master problem (MP) can be formulated as follows:

                        
                           (1)
                           
                              
                                 
                                    
                                       
                                          [MP]
                                          
                                       
                                    
                                    
                                       
                                          Min.
                                          
                                          
                                             Z
                                             
                                                M
                                                P
                                             
                                          
                                          =
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                J
                                             
                                          
                                          
                                             x
                                             j
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          s
                                          .
                                          t
                                          .
                                          
                                             ∑
                                             
                                                j
                                                ∈
                                                J
                                             
                                          
                                          
                                             a
                                             
                                                k
                                                j
                                             
                                          
                                          
                                             x
                                             j
                                          
                                          ≥
                                          
                                             d
                                             k
                                          
                                          
                                          ∀
                                          k
                                          ∈
                                          K
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             x
                                             j
                                          
                                          ∈
                                          
                                             Z
                                             +
                                          
                                          
                                          ∀
                                          j
                                          ∈
                                          J
                                       
                                    
                                 
                              
                           
                        
                     
                  

The difficulty with this formulation is that the number of possible packing patterns that are elements of set J can be extremely large and virtually impossible to enumerate even for relatively small problems. Nevertheless, the LP relaxation of the above formulation, referred to as [LMP], can be solved via a column generation approach. Let uk
                      be the dual variable associated with the constraint for the kth commodity (Constraint (1)) of [LMP]. The reduced cost of the jth pattern is 
                        
                           1
                           −
                           
                              ∑
                              
                                 k
                                 ∈
                                 K
                              
                           
                           
                              u
                              k
                           
                           
                              a
                              
                                 k
                                 j
                              
                           
                        
                     . Here on, we omit subscript j for ease of exposition. Each demand unit of commodity k packed in this pattern will follow a specific path. Let Pk
                      be the index set of all possible paths of commodity k. It is assumed that the index sets of all commodities are mutually disjoint, so that a given index t belongs to only one Pk
                     . For t ∈ Pk
                     , define γt
                      as the binary m-vector representing the path, i.e., 
                        
                           
                              γ
                              
                                 t
                              
                              e
                           
                           =
                           1
                           ,
                        
                      if edge e is used on path t, and zero otherwise. Element corresponding to edge e in this vector is 1 if edge e ∈ E is on this path, and 0 otherwise. For t ∈ Pk
                     , associate binary variables θt
                      with γt
                      so that 
                        
                           
                              θ
                              t
                           
                           =
                           1
                        
                      if demand k uses path t in the layer, and 0 otherwise. This implies that 
                        
                           
                              a
                              k
                           
                           =
                           
                              ∑
                              
                                 t
                                 ∈
                                 
                                    P
                                    k
                                 
                              
                           
                           
                              θ
                              t
                           
                        
                     . The pattern generation subproblem can then be defined as shown.

                        
                           
                              
                                 
                                    
                                       
                                          [
                                          P
                                          G
                                          P
                                          ]
                                          
                                       
                                    
                                    
                                       
                                          Max.
                                          
                                          
                                          
                                             Z
                                             
                                                P
                                                G
                                                P
                                             
                                          
                                          =
                                          
                                             ∑
                                             
                                                k
                                                ∈
                                                K
                                             
                                          
                                          
                                             ∑
                                             
                                                t
                                                ∈
                                                
                                                   P
                                                   k
                                                
                                             
                                          
                                          
                                             u
                                             k
                                          
                                          
                                             θ
                                             t
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          s
                                          .
                                          t
                                          .
                                          
                                             ∑
                                             
                                                k
                                                ∈
                                                K
                                             
                                          
                                          
                                             ∑
                                             
                                                t
                                                ∈
                                                
                                                   P
                                                   k
                                                
                                             
                                          
                                          
                                             γ
                                             
                                                t
                                             
                                             e
                                          
                                          
                                             θ
                                             t
                                          
                                          ≤
                                          
                                             α
                                             e
                                          
                                          
                                          
                                          ∀
                                          e
                                          ∈
                                          E
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             θ
                                             t
                                          
                                          ∈
                                          
                                             {
                                             0
                                             ,
                                             1
                                             }
                                          
                                          
                                          ∀
                                          t
                                          ∈
                                          
                                             P
                                             k
                                          
                                          ,
                                          ∀
                                          k
                                          ∈
                                          K
                                       
                                    
                                 
                              
                           
                        
                     
                  

Problem [PGP] is similar to problem (SP) formulated by Lee et al. (2002) except that problem [PGP] does not explicitly disallow generation of more than dk
                      number of patterns for the kth commodity. This is, however, not a problem because the optimal solution obtained to problem [MP] will be the same in both cases.

Having solved this problem, setting 
                        
                           
                              a
                              k
                           
                           =
                           
                              ∑
                              
                                 t
                                 ∈
                                 
                                    P
                                    k
                                 
                              
                           
                           
                              θ
                              t
                           
                        
                     ∀k yields the desired column for the Master Problem. This column has a reduced cost 1-ZPGP
                      with respect to the [MP], and if ZPGP
                      ≤ 1, then [LMP] has been optimally solved.

Problem [PGP] also has a large number of columns, which again can be addressed via column generation. The column generation subproblem in this case is simply the shortest path problem with we
                      as the cost of edge e, where we
                      is the dual variable of the constraint associated with edge e in the LP relaxation of [PGP]. Since the shadow prices are non-negative, this shortest path problem can be efficiently solved using the well-known Dijkstra’s algorithm.

There can be several ways of implementing the above framework for solving this problem. The implementation described by Lee et al. (2002) is an exact approach based on branch and price. However, it is quite inefficient for solving larger size problems. Our objective in solving the problem [MP] is to find a feasible solution with ZMP
                      ≤ C, and not necessarily to minimize ZMP
                     . Therefore, we have made several changes to the implementation described byLee et al. (2002), turning it into a computationally efficient yet effective heuristic approach. The details of our implementation are described in Section 5.

If the NDP relaxation of WRND is solved completely disregarding the issue of wavelength routing, the optimal solution may sometimes contain serious bottlenecks with respect to wavelength continuity constraints, which make this solution unsuitable for RWA. This is illustrated with the classical example of a 4-node network. Let C=2, and demands 
                        
                           
                              d
                              23
                           
                           =
                           
                              d
                              24
                           
                           =
                           
                              d
                              34
                           
                           =
                           1
                           ,
                        
                      and 
                        
                           
                              d
                              12
                           
                           =
                           
                              d
                              13
                           
                           =
                           
                              d
                              14
                           
                           =
                           0
                        
                     . Consider the following network design: 
                        
                           
                              x
                              12
                           
                           =
                           
                              x
                              13
                           
                           =
                           
                              x
                              14
                           
                           =
                           1
                           ,
                        
                      and 
                        
                           
                              x
                              23
                           
                           =
                           
                              x
                              24
                           
                           =
                           
                              x
                              34
                           
                           =
                           0
                        
                     . Clearly, this solution is feasible for NDP, because all demands can be routed via node 1, if the wavelength continuity constraint is not present. However, if the wavelength continuity constraint is to be enforced, it is easy to see that at most 2 of the 3 demands can be routed.

To see this, as depicted in Fig. 1
                     , suppose that demand d
                     23 follows the route 2–1–3 and is assigned wavelength λ
                     1. Demand d
                     24 follows route 2–1–4 but it cannot be assigned the same wavelength as d
                     23, because both the paths share a common facility on edge (1, 2). Suppose that it is assigned wavelength λ
                     2. Now, we have one unit of unused capacity each on edges (1, 3)   and (1, 4), but their wavelengths do not match. Therefore, demand d
                     34 cannot be routed under wavelength continuity constraint. We can route any two of the three demands, but not the third.

The above example leads to following general conclusion. If there are exactly three facilities incident on a node, then the total number of demands routed via this node (i.e., excluding the demands that originate/terminate at this node) cannot exceed C under the wavelength continuity constraint. However, if wavelength conversion is permitted, then this number increases to 1.5C. This observation can be generalized for any odd degree node. If a node has 
                        
                           2
                           n
                           +
                           1
                        
                      facilities terminating on it, the total number of demands routed via this node cannot exceed nC. However, in our implementation, we impose this restriction only on nodes of degree 3, because it is rare that a node would have 5 or more optical facilities incident on it. Also, imposing these constraints on nodes of degree 5 or more is computationally expensive, and is unlikely to lead to a significant change in the design.

Before suggesting a way to incorporate the above restriction in the NDP model, we present the well known formulation of the standard NDP. We define a set K of 
                        
                           (
                           n
                           −
                           1
                           )
                        
                      commodities as follows. Commodity k ∈ K represents all traffic from node k to all nodes i with i > k. Let 
                        
                           ∂
                           
                              i
                           
                           k
                        
                      be the demand of commodity k at node i. Then for 
                        
                           1
                           ≤
                           k
                           ≤
                           n
                           −
                           1
                           ,
                        
                     
                     
                        
                           ∂
                           
                              i
                           
                           k
                        
                      is defined as follows:

                        
                           
                              
                                 
                                    
                                       
                                          
                                             ∂
                                             
                                                i
                                             
                                             k
                                          
                                          =
                                          
                                             {
                                             
                                                
                                                   
                                                      
                                                         0
                                                         
                                                         for
                                                         
                                                         i
                                                         <
                                                         k
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            −
                                                            
                                                               ∑
                                                               
                                                                  j
                                                                  >
                                                                  k
                                                               
                                                            
                                                            
                                                               d
                                                               
                                                                  k
                                                                  j
                                                               
                                                            
                                                            
                                                            for
                                                            
                                                            i
                                                            =
                                                            k
                                                         
                                                      
                                                   
                                                
                                                
                                                   
                                                      
                                                         
                                                            d
                                                            
                                                               k
                                                               i
                                                            
                                                         
                                                         
                                                         for
                                                         
                                                         i
                                                         >
                                                         k
                                                      
                                                   
                                                
                                             
                                             }
                                          
                                       
                                    
                                 
                              
                           
                        
                     
                  

It is well known that this method of defining commodities, called aggregate commodity definition, is much more efficient compared to defining each origin-destination pair as a separate commodity (Bienstock et al., 1998). Let xe
                      be the number of facilities installed on edge e ∈ E, and 
                        
                           f
                           
                              i
                              j
                           
                           k
                        
                      the (directed) flow of commodity k on edge 
                        
                           e
                           =
                           (
                           i
                           ,
                           j
                           )
                        
                     . Note that in order to correctly write the flow conservation constraints, it is necessary to impose a direction on the flow variables even though the traffic demands and capacities themselves are assumed to be undirected. With these variable definitions, the NDP can be formulated as the following mixed integer program, which is well known in the literature as the flow-formulation (Bienstock et al., 1998).

                        
                           
                              
                                 
                                    
                                       
                                          [
                                          N
                                          D
                                          P
                                          ]
                                          
                                       
                                    
                                    
                                       
                                          Min.
                                          
                                          
                                             ∑
                                             
                                                e
                                                ∈
                                                E
                                             
                                          
                                          
                                             c
                                             e
                                          
                                          
                                             x
                                             e
                                          
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          s
                                          .
                                          t
                                          .
                                          
                                             ∑
                                             i
                                          
                                          
                                             f
                                             
                                                i
                                                j
                                             
                                             k
                                          
                                          −
                                          
                                             ∑
                                             i
                                          
                                          
                                             f
                                             
                                                j
                                                i
                                             
                                             k
                                          
                                          =
                                          
                                             ∂
                                             
                                                j
                                             
                                             k
                                          
                                          
                                          ∀
                                          j
                                          ∈
                                          V
                                          ,
                                          ∀
                                          k
                                          ∈
                                          K
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             ∑
                                             
                                                k
                                                ∈
                                                K
                                             
                                          
                                          
                                             (
                                             
                                                f
                                                
                                                   i
                                                   j
                                                
                                                k
                                             
                                             +
                                             
                                                f
                                                
                                                   j
                                                   i
                                                
                                                k
                                             
                                             )
                                          
                                          ≤
                                          C
                                          
                                             x
                                             e
                                          
                                          
                                          ∀
                                          e
                                          ∈
                                          E
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             f
                                             
                                                i
                                                j
                                             
                                             k
                                          
                                          ≥
                                          0
                                          
                                          ∀
                                          e
                                          =
                                          
                                             (
                                             i
                                             ,
                                             j
                                             )
                                          
                                          ∈
                                          E
                                          ,
                                          k
                                          ∈
                                          K
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             x
                                             e
                                          
                                          ∈
                                          
                                             Z
                                             +
                                          
                                          
                                          ∀
                                          e
                                          ∈
                                          E
                                       
                                    
                                 
                              
                           
                        
                     
                  

Next we propose to strengthen this formulation by adding more variables and constraints, so that the bottlenecks of the type described previously are prevented in the final design. For node i, let 
                        
                           
                              X
                              i
                           
                           =
                           
                              ∑
                              
                                 j
                                 ∈
                                 δ
                                 (
                                 i
                                 )
                              
                           
                           
                              x
                              
                                 i
                                 j
                              
                           
                           ,
                        
                      where 
                        
                           δ
                           (
                           i
                           )
                           =
                           {
                           j
                           ∈
                           V
                           :
                           (
                           i
                           ,
                           j
                           )
                           ∈
                           E
                           }
                        
                     . In other words, Xi
                      is the total number of facilities incident on node i. For j ∈ δ(i), let 
                        
                           
                              
                                 F
                                 ^
                              
                              
                                 i
                                 j
                              
                           
                           =
                           
                              ∑
                              k
                           
                           
                              (
                              
                                 f
                                 
                                    i
                                    j
                                 
                                 k
                              
                              +
                              
                                 f
                                 
                                    j
                                    i
                                 
                                 k
                              
                              )
                           
                           ,
                        
                      i.e., the total traffic flow on edge (i, j). Note that 
                        
                           
                              F
                              ^
                           
                           
                              i
                              j
                           
                        
                      includes some of the traffic originating at node i, as well as the traffic passing through node i. Define 
                        
                           
                              D
                              i
                           
                           =
                           
                              ∑
                              
                                 j
                                 ∈
                                 V
                                 ∖
                                 {
                                 i
                                 }
                              
                           
                           
                              d
                              
                                 i
                                 j
                              
                           
                           ,
                        
                      i.e., the total traffic originating at node i. Then, the total traffic passing through node i can be expressed as 
                        
                           
                              F
                              i
                           
                           =
                           
                              ∑
                              
                                 j
                                 ∈
                                 δ
                                 (
                                 i
                                 )
                              
                           
                           
                              
                                 F
                                 ^
                              
                              
                                 i
                                 j
                              
                           
                           −
                           
                              D
                              i
                           
                        
                     . In order to prevent the bottlenecks of the kind described earlier, we wish to impose the constraint that if 
                        
                           
                              X
                              i
                           
                           =
                           3
                           ,
                        
                      then Fi
                      must not exceed C. This constraint should be imposed on each node of the network in the above formulation. It is important to note that the restriction of C on Fi
                      should be imposed only if 
                        
                           
                              X
                              i
                           
                           =
                           3
                           ,
                        
                      and there should be no restriction otherwise.

In order to impose this restriction on node i it is necessary to introduce an additional binary variable zi
                      for that node, where 
                        
                           
                              z
                              i
                           
                           =
                           1
                        
                      if Xi
                      ≥ 4, and 
                        
                           
                              z
                              i
                           
                           =
                           0
                        
                      otherwise. It is easy to verify that the desired restriction on the traffic flow through a node with 
                        
                           
                              X
                              i
                           
                           =
                           3
                        
                      is achieved by adding the following constraints to the formulation [NDP]:

                        
                           
                              
                                 
                                    
                                       
                                          
                                             X
                                             i
                                          
                                          
                                       
                                    
                                    
                                       
                                          ≥
                                          
                                          4
                                          
                                             z
                                             i
                                          
                                          
                                          
                                          
                                          
                                          
                                          
                                             (
                                             a
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             X
                                             i
                                          
                                          
                                       
                                    
                                    
                                       
                                          ≤
                                          
                                          3
                                          +
                                          M
                                          
                                             z
                                             i
                                          
                                          
                                          
                                          
                                          
                                             (
                                             b
                                             )
                                          
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             F
                                             i
                                          
                                          
                                       
                                    
                                    
                                       
                                          ≤
                                          
                                          C
                                          +
                                          M
                                          
                                             z
                                             i
                                          
                                          
                                          
                                          
                                          
                                             (
                                             c
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                     where M is a sufficiently large number. Note that constraint (a) ensures that 
                        
                           
                              z
                              i
                           
                           =
                           0
                        
                      if Xi
                      ≤ 3, and (b) ensures that 
                        
                           
                              z
                              i
                           
                           =
                           1
                        
                      if Xi
                      ≥ 4. The third constraint (c) restricts Fi
                      to C if 
                        
                           
                              z
                              i
                           
                           =
                           0
                        
                     . The doubt may arise for the case of 
                        
                           
                              X
                              i
                           
                           =
                           2
                           ,
                        
                      which is also characterized by 
                        
                           
                              z
                              i
                           
                           =
                           0
                        
                     . However, note that Fi
                      ≤ C is a valid restriction for the case of 
                        
                           
                              X
                              i
                           
                           =
                           2
                        
                     . Therefore, these inequalities are indeed valid for problem WRND. Also note that constraint (c) does not impose any restriction on Fi
                      if 
                        
                           
                              z
                              i
                           
                           =
                           1
                           ,
                        
                      since M is large. Since these restrictions are valid for WRND, the optimal solution of this expanded formulation is a valid lower bound on the optimal solution of WRND. When the model [NDP] has been augmented with these variables and constraints, we call the resulting model augmented NDP or [ANDP].

We illustrate the effectiveness of these constraints with the following example. For a 25-node instance with 
                        
                           C
                           =
                           160
                        
                      and the traffic demands for each node pair drawn randomly from the set {0,1,2,3}, when the NDP was solved without these constraints, the cost of optimal network was Z(NDP) = 4070. When the wavelength routing model was solved for this network, the minimum number of wavelengths needed for feasible routing was found to be 179, i.e., almost 12% more than the actual number. However, when the NDP was solved with the stronger formulation described above, it produced a solution with Z(ANDP) = 4080, i.e., the network cost increased by only about 0.25%. However, for this solution, the wavelength routing model was indeed able to find a feasible routing with 160 wavelengths. In this case, the latter solution can be claimed optimal for WRND, since it represents a lower bound as well as a feasible solution. As shown in the computational results reported in Section 6, out of 10 instances for this class of problems, in nine cases a feasible routing was found within 160 layers. In the remaining one case, the network has to be redesigned with a smaller value of C in order to get a feasible routing, which resulted in an optimality gap of 0.5%.

The methodology described in the previous section can be implemented in different ways. We outline below some of these approaches.

Problem NDP is solved using the stronger formulation described in Section 4 with 
                        
                           C
                           =
                           160
                        
                     . The RWA problem is solved on the network so designed. To do this, [LMP], which is the linear programming relaxation of problem [MP], is started with a restricted number of columns, one for each demand. This is called the restricted master problem (RMP). Each column of the RMP corresponds to a unit of demand using an entire λ-layer. In this approach, the initial RMP consists of an identity matrix as the starting basis. This starting solution is equivalent to using one wavelength for each unit of demand. Note that our goal in solving the RWA is to obtain a feasible solution to [MP] whose objective function value is no greater than C. To this end, following the procedure suggested by Lee et al. (2002), is computationally prohibited. The authors there developed a branch and price method in order to solve [PGP] optimally with the objective of minimizing the objective function of [MP]. Note that the [PGP] itself has an exponential number of columns (each column corresponds to a path in the NDP network). Furthermore, the output of the optimal solution to the [PGP] is one of an exponentially large number of columns for [MP]. It is unlikely that such an approach involving solving [MP] optimally will prove to be computationally efficient in order to solve the WRND. For instance, in one of our computational experiments, there was no limit on the number of paths generated within the [PGP]. A large number of paths were generated and these paths were used to generate different packings for [MP]. Even after close to an hour of computational time, it was observed that computation for solving problem [LMP] was continuing even though ZMP
                      had reached a value less than C. To reiterate, our goal is to find a solution to [MP] whose objective function value is less than or equal to C, and not necessarily to minimize ZMP
                     . Towards this end, we discuss several enhancements and shortcuts that have resulted in obtaining extremely fast solutions to the [MP] which are feasible for the WRND.

The first important enhancement is being able to solve the integer programs, [PGP] and [MP], effectively and efficiently. [PGP] is solved using a rounding heuristic described below.


                        [Procedure PGP]
                        
                           
                              
                                 Step 1.
                              
                              Solve the LP relaxation of [PGP] to optimality using column generation. If 
                                    
                                       
                                          Z
                                          
                                             P
                                             G
                                             P
                                          
                                          
                                       
                                       ≤
                                       1
                                       ,
                                    
                                  STOP since it proves that [LMP] has been solved to optimality.

If the solution θ is integral, a packing with negative reduced cost has been found. Return the same to the RMP and STOP. Otherwise go to Step 3.

Assuming 
                                    
                                       θ
                                       ¯
                                    
                                  is the fractional solution, let 
                                    
                                       
                                          t
                                          *
                                       
                                       =
                                       arg
                                       min
                                       
                                          {
                                          
                                             ⌈
                                             
                                             
                                                
                                                   θ
                                                   ¯
                                                
                                                t
                                             
                                             ⌉
                                          
                                          −
                                          
                                             
                                                θ
                                                ¯
                                             
                                             t
                                          
                                          }
                                       
                                       ,
                                    
                                  and impose constraint 
                                    
                                       
                                          θ
                                          
                                             t
                                             *
                                          
                                       
                                       =
                                       
                                          ⌈
                                          
                                          
                                             
                                                θ
                                                ¯
                                             
                                             
                                                t
                                                *
                                             
                                          
                                          ⌉
                                       
                                    
                                 . Return to Step 1.

When the procedure above fails to return a usable packing to add to RMP, [LMP] is considered solved and a similar rounding procedure is used to solve [MP] heuristically.


                        [Procedure MP]
                        
                           
                              
                                 Step 1.
                              
                              Solve RMP by column generation until ZPGP
                                  ≤ 1.

If the solution is integral, STOP and return ZMP
                                  as the number of wavelengths required. Otherwise go to Step 3.

Assuming 
                                    
                                       x
                                       ¯
                                    
                                  is the fractional solution, let 
                                    
                                       
                                          j
                                          *
                                       
                                       =
                                       arg
                                       min
                                       
                                          {
                                          
                                             ⌈
                                             
                                                
                                                   x
                                                   ¯
                                                
                                                j
                                             
                                             ⌉
                                          
                                          −
                                          
                                             
                                                x
                                                ¯
                                             
                                             j
                                          
                                          }
                                       
                                       ,
                                    
                                  and impose 
                                    
                                       
                                          x
                                          
                                             j
                                             *
                                          
                                       
                                       =
                                       
                                          ⌈
                                          
                                             
                                                x
                                                ¯
                                             
                                             
                                                j
                                                *
                                             
                                          
                                          ⌉
                                       
                                    
                                 . Return to Step 1.

If ZMP
                         ≤ C then the designed network allows for a feasible WDM routing of the demands.

In the approach described above, the initial solution consists of each demand occupying an entire λ-layer, and following an arbitrary path. At the start of the algorithm, problem [PGP] has no columns at all. The columns are slowly added as they are generated. This results in very slow convergence of the algorithm. In this section we demonstrate that the convergence of the algorithm is enormously speeded up if the problem [PGP] is provided with a sensible initial set of routes for all demands.

Consider a relaxation of problem RWA, where the wavelength continuity constraint has been dropped. This is the problem of finding a feasible routing of all demands in a given network assuming that wavelength conversion is freely available at all nodes. Note that the non-splittability of individual demands is still enforced, i.e., each demand unit must follow a single path, and cannot be split into fractional parts routed along different paths. We call this problem multi-commodity discrete routing [MDR]. A formulation of the problem is provided below:

                           
                              
                                 
                                    
                                       
                                          
                                             [
                                             M
                                             D
                                             R
                                             ]
                                             
                                          
                                       
                                       
                                          
                                             Min.
                                             
                                             
                                             
                                                Z
                                                
                                                   M
                                                   D
                                                   R
                                                
                                             
                                             =
                                             β
                                          
                                       
                                    
                                    
                                       
                                          
                                             s
                                             .
                                             t
                                             .
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                ∑
                                                
                                                   t
                                                   ∈
                                                   
                                                      P
                                                      k
                                                   
                                                
                                             
                                             
                                                γ
                                                
                                                   t
                                                
                                                e
                                             
                                             
                                                θ
                                                t
                                             
                                             ≤
                                             C
                                             
                                                α
                                                e
                                             
                                             +
                                             β
                                             
                                             ∀
                                             e
                                             ∈
                                             E
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   t
                                                   ∈
                                                   
                                                      P
                                                      k
                                                   
                                                
                                             
                                             
                                                θ
                                                t
                                             
                                             ≥
                                             
                                                d
                                                k
                                             
                                             
                                             ∀
                                             k
                                             ∈
                                             K
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             
                                                θ
                                                t
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             
                                             ∀
                                             t
                                             ∈
                                             
                                                P
                                                k
                                             
                                             ,
                                             ∀
                                             k
                                             ∈
                                             K
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             β
                                             ≥
                                             0
                                          
                                       
                                    
                                 
                              
                           
                        
                     

This problem is nearly identical to [PGP], except that the right hand side is replaced with 
                           
                              C
                              
                                 α
                                 e
                              
                              +
                              β
                              ,
                           
                         instead of αe
                        . Here β is an artificial variable representing additional capacity on each edge, and the objective function is to minimize its value. Note that it includes an additional set of constraints for each commodity to ensure that all demand units of that commodity are assigned a route. If the optimal objective value of this problem is zero, we have found a feasible solution of problem [MDR]. Although this problem cannot be solved exactly due to an enormously large number of paths for each demand (Gondran & Minoux, 1984), there exist extremely fast and effective heuristic algorithms for solving it. We use an approach suggested by Gondran and Minoux (1984). A brief description of an algorithm based on the approach suggested by Gondran and Minoux (1984) is provided below for easy reference. In this description, each demand unit is treated as an independent entity for the purpose of routing. Let 
                           
                              n
                              =
                              
                                 ∑
                                 
                                    k
                                    ∈
                                    K
                                 
                              
                              
                                 d
                                 k
                              
                              ,
                           
                         be the total number of demand units. Each demand unit is indexed by b, and Eb
                         denotes the set of edges on the current path of demand b.

[Procedure Gondran–Minoux 1]

                           
                              Step 0.
                              Using ce
                                  as edge cost, compute shortest paths for all node pairs, and route each demand unit along the shortest path. Let fe
                                  be the total flow on edge e under this routing, and let 
                                    
                                       
                                          v
                                          e
                                       
                                       =
                                       max
                                       
                                          {
                                          0
                                          ,
                                          
                                             f
                                             e
                                          
                                          −
                                          C
                                          
                                             α
                                             e
                                          
                                          }
                                       
                                    
                                  be the capacity violation on edge e under current routing. Compute 
                                    
                                       
                                          V
                                          
                                             s
                                             t
                                             a
                                             r
                                             t
                                          
                                       
                                       =
                                       V
                                       =
                                       
                                          ∑
                                          
                                             e
                                             ∈
                                             E
                                          
                                       
                                       
                                          v
                                          e
                                       
                                    
                                 . Let 
                                    
                                       
                                          E
                                          v
                                       
                                       =
                                       
                                          {
                                          e
                                          :
                                          
                                             v
                                             e
                                          
                                          >
                                          0
                                          }
                                       
                                    
                                 .

If 
                                    
                                       V
                                       =
                                       0
                                       ,
                                    
                                  STOP, a feasible routing has been found. Otherwise, go to the first demand unit. That is, 
                                    
                                       b
                                       =
                                       1
                                       ,
                                    
                                  and go to step 2.

If b > n , go to Step 4. If 
                                    
                                       
                                          E
                                          b
                                       
                                       ∩
                                       
                                          E
                                          v
                                       
                                       =
                                       ∅
                                       ,
                                    
                                  let 
                                    
                                       b
                                       ⟵
                                       b
                                       +
                                       1
                                    
                                  (choose the next demand unit) and repeat Step 2. Otherwise go to Step 3.

Let 
                                    
                                       
                                          E
                                          1
                                       
                                       =
                                       
                                          {
                                          e
                                          ∈
                                          
                                             E
                                             b
                                          
                                          :
                                          
                                             f
                                             e
                                          
                                          ≥
                                          C
                                          
                                             α
                                             e
                                          
                                          +
                                          1
                                          }
                                       
                                       ,
                                    
                                  and 
                                    
                                       
                                          E
                                          2
                                       
                                       =
                                       
                                          {
                                          e
                                          ∈
                                          E
                                          ∖
                                          
                                             E
                                             b
                                          
                                          :
                                          
                                             f
                                             e
                                          
                                          ≥
                                          C
                                          
                                             α
                                             e
                                          
                                          }
                                       
                                    
                                 . Define edge cost πe
                                  as follows. 
                                    
                                       
                                          π
                                          e
                                       
                                       =
                                       1
                                    
                                  if e ∈ E
                                 1 ∪ E
                                 2, and 0 otherwise. Compute the shortest path for demand unit b, using edge costs πe
                                 , and route the demand along this new path. Update ve, V, and Ev
                                  etc. Let 
                                    
                                       b
                                       ⟵
                                       b
                                       +
                                       1
                                    
                                  and go back to Step 2.

If 
                                    
                                       V
                                       =
                                       
                                          V
                                          
                                             s
                                             t
                                             a
                                             r
                                             t
                                          
                                       
                                       ,
                                    
                                  STOP, algorithm fails to find a feasible routing. Otherwise, 
                                    
                                       
                                          V
                                          
                                             s
                                             t
                                             a
                                             r
                                             t
                                          
                                       
                                       =
                                       V
                                       ,
                                    
                                  and go back to Step 1.

Note that edge costs πe
                         are computed in Step 3 in such a way that if demand b is routed along the shortest path with respect to these costs, shifting the demand to the new path leads to maximum possible reduction in violation V that can be achieved by rerouting this demand. We note that πe
                         can be thought of as a penalty of using edge e on the new path, and represents the increase in violation of edge e. The algorithm continues re-routing the demands until a zero-violation routing has been found, or no further reduction in V is possible by re-routing any demand.

With the above background, our modified approach for solving [WRND] is outlined as follows:

[Procedure WRND]

                           
                              Step 1.
                              Solve model [ANDP], producing capacity solution α.

Solve model [MDR] using [Procedure Gondran–Minoux 1], and let Γ be the set of routes assigned to various demand units in the solution.

Setup problem [PGP] with Γ as the initial set of routes, and then solve problem [MP] via [PGP], as described in the previous section.

One of the computational strategies to reduce the time for solving the [MP] is to impose an upper limit np
                         on the number of paths generated for [PGP]. Once the number of paths reaches np
                        , further generation of new paths is stopped. Of course, np
                         should not be too small, as it can result in a grossly sub-optimal solution. Imposing a judiciously chosen limit can significantly reduce the cpu time without any noticeable deterioration in solution quality. Using a smaller value of np
                         can result in a substantial reduction in cpu time. An important effect of using the initial set of routes Γ is that the desired solution quality can be obtained with a much smaller value of np
                        , thus resulting in further time savings. Table 1
                         compares the ZMP
                         and cpu time for different values of np
                         for both cases, i.e., with and without Γ. The values represent the average over the same 10 instances with high traffic density that are studied in Section 6. Here traffic density is defined as 
                           
                              
                                 d
                                 ¯
                              
                              /
                              C
                              ,
                           
                         where 
                           
                              d
                              ¯
                           
                         is average traffic demand per node pair.

Note that with Γ, using 
                           
                              
                                 n
                                 p
                              
                              =
                              1000
                           
                         results in the same solution quality, as with 
                           
                              
                                 n
                                 p
                              
                              =
                              1600
                           
                         when Γ is not used. However, the average cpu time needed in the former case is only 113.1 seconds, as opposed to 161.3 seconds in the latter case, i.e., almost a 30% reduction in CPU time.

Initial computational tests (details of which are provided in Section 6) showed that while using the approach outlined thus far gave extremely good results for high and medium traffic density problems, it was possible to improve on the performance by specific improvements for low traffic density problems. Two such methods are discussed in this section and Section 5.4.

If the right-hand-side of the constraints have 
                           
                              
                                 α
                                 e
                              
                              =
                              1
                           
                         for all edges, problem [PGP] is the standard set packing problem. Polyhedral structure of the set packing problem has been well studied. Specifically, Padberg (1973) discussed several classes of facet-defining inequalities for this problem, which can be used to solve [PGP] more efficiently. We briefly describe one particular class, the clique inequalities here, which were found to be very effective in improving the solutions of [PGP] for low traffic density problems. In the context of Set Packing problem, Padberg (1973) introduced the notion of an intersection graph in which each node represents a column of problem and an edge exists between a pair of nodes if the corresponding columns have overlapping non-zero entries in one or more rows. Recall that in [PGP], each column is a demand path, and two columns are overlapping if the corresponding paths have one or more common edges. Clearly, any pair of such columns cannot simultaneously be present in a feasible solution. In fact, consider a subset S of columns in which each pair is overlapping. Then, a feasible solution can contain at most one of these columns, i.e., ∑
                           i ∈ S
                        
                        xi
                         ≤ 1 is a valid inequality, which has been shown to be facet-defining under appropriate conditions for the set packing polyhedron by Padberg (1973). It is easy to see that such a subset corresponds to a clique in the intersection graph. Given the current solution 
                           
                              x
                              ¯
                           
                         the problem of finding a violated clique inequality reduces to finding the maximum weight clique in the intersection graph, where 
                           
                              
                                 x
                                 ¯
                              
                              i
                           
                         is the weight associated with node i of the graph. If the total weight of the clique exceeds 1, we have found a violated clique inequality.
                     

We note that the addition of clique inequalities makes the pricing problem more difficult because the shadow prices of the clique inequalities also must be taken into account, and the pricing problem is no longer a shortest path problem. To overcome this difficulty, the solution process of [PGP] is divided into two phases. In the first phase, when the new columns are being added to the problem, no clique inequalities are added. Once a sufficiently large number of columns has been added, we start the second phase, in which no further columns are added, and only the clique inequalities are added. When no more clique inequalities can be found, the rounding heuristic described earlier is applied to find an integer solution. For finding the violated clique inequalities, we use the algorithm proposed by Östergård (1999) in our implementation.

The graph for low traffic density problems tends to be more sparse as compared to medium and high traffic density problems. This results in relatively more degree 3 and degree 4 nodes in the final network. It is possible to incorporate the ideas developed in Section 4 to generate initial route-set Γ that is more conducive to wavelength routing for such networks. While constructing the set Γ using Gondran–Minoux’s Algorithm, we wish to find a discrete routing so that the traffic passing through a degree 3 node does not exceed C units. It is easy to incorporate this constraint in Gondran–Minoux’s algorithm by keeping track of the violation of these constraints, and by defining appropriate penalties to reduce and finally eliminate such violations.

For a given degree 3 node, if the violation of this constraint will increase by routing additional traffic via this node, i.e., the node already has C or more units of traffic passing through it, we impose an additional penalty of 0.5 units on all the 3 edges incident on that node. Thus, if a path passes through this node, it will incur an additional penalty of 1 unit. Note that a degree 4 node has four subsets of 3 edges and the same restriction must be imposed on each of these subsets. Consider a degree 4 node, say node i, with nodes p, q, r and s as its adjacent nodes. Identifying each edge incident on i with one of the neighboring nodes, let the four subsets be pqr, pqs, prs and qrs. A throughput constraint of C units must be imposed on each of these subsets. While routing a demand in Gondran–Minoux’s algorithm, if any one of these constraints is violated, a penalty of one unit should be incurred. The question is, can we appropriately modify the cost matrix of the shortest path problem to correctly account for these penalties without destroying the structure of the shortest path problem? We propose the following to address this issue.

Assume that only one of these four subsets, say pqr, is at or above capacity, and all others are below capacity. Then we impose a cost of 0.5 on edges (i, p), (i, q) and (i, r), and a cost of 
                           −
                        0.5 on edge (i, s). It is easy to see that with these edge-costs, a demand path that contributes to a violation of capacity for pqr, will correctly incur a penalty of one unit, and incur no penalty otherwise. Now consider the case when two out of four subsets, say pqr and pqs are at or above capacity, and the remaining two are below capacity. There are six ways a demand can pass through node i. These are 
                           
                              p
                              −
                              i
                              −
                              q
                              ,
                           
                        
                        
                           
                              p
                              −
                              i
                              −
                              r
                              ,
                           
                        
                        
                           
                              p
                              −
                              i
                              −
                              s
                              ,
                           
                        
                        
                           
                              q
                              −
                              i
                              −
                              r
                              ,
                           
                        
                        
                           
                              q
                              −
                              i
                              −
                              s
                           
                         and 
                           
                              r
                              −
                              i
                              −
                              s
                           
                        . If the path uses 
                           
                              p
                              −
                              i
                              −
                              q
                              ,
                           
                         then it should attract the penalty of 2 units, because it contributes to the through traffic for both subsets, pqr and pqs. Similarly, for option 
                           
                              r
                              −
                              i
                              −
                              s
                              ,
                           
                         no penalty should be incurred, and for the remaining four, a penalty of one unit should be incurred. Let the cost be 1 for (i, p) and (i, q), zero for the remaining two edges. It is easy to verify that this correctly captures all penalties.

Now consider the case when three out of four subsets, say pqr, pqs and prs, are at or above capacity, and qrs is below capacity. Then, setting the cost of edge 
                           
                              (
                              i
                              ,
                              p
                              )
                              =
                              2
                           
                         and costs of edges (i, q), (i, r), (i, s) all equal to 1 will correctly capture the penalty for all cases. In the final case, the flows through all four subsets are at or above capacity. This case is easily addressed by setting the cost of each edge as 2 units.

When the Gondran–Minoux’s algorithm is used to generate the initial set of paths using additional penalties as described above (the procedure is referred to as [Procedure Gondran–Minoux 2]), the resulting set of paths is much more compatible with wavelength routing constraints, than it is without these penalties. Let 
                           
                              Γ
                              ^
                           
                         and Γ be the path-sets generated using [Procedure Gondran–Minoux 2] and [Procedure Gondran–Minoux 1] respectively. Table 2 shows the number of layers needed for feasible routing in different cases over a set of 10 low-density problems with 
                           
                              C
                              =
                              160
                              ,
                           
                         details of which are provided in Section 6. New routes were not generated in addition to the original starting sets provided by the respective Gondran–Minoux procedures in order to contrast clearly the quality of routes generated. It is observed that with Γ as the initial route set, a feasible routing was found in only 1 out of 10 instances, irrespective of whether clique inequalities were used or not. However, if 
                           
                              Γ
                              ^
                           
                         is used as the initial route set (without clique inequalities), in 6 out of 10 instances a feasible and hence optimal solution was found. Moreover, when clique inequalities were also used in conjunction with 
                           
                              
                                 Γ
                                 ^
                              
                              ,
                           
                         the number of instances with feasible routing increased to 9. The usage of clique inequalities appears to be ineffective for set Γ but its effectiveness is quite apparent with set 
                           
                              Γ
                              ^
                           
                        .

[Procedure MP] is a heuristic method to solve the RWA. In this section, we provide a comparison between this method and the method by Lee et al. (2002). The authors provide details of three networks (NET1, NET2 and NET3). Unfortunately, we were unable to obtain the exact demand data for these networks. However, using description of demand generation method provided in their work, we were able to generate statistically comparable, though not necessarily identical, demand sets. In order to make the comparison as reasonable as possible, we performed tests on Class 1 problems as described byLee et al. (2002). The results in terms of number of wavelengths needed as reported in their work exhibited much smaller range as compared to the tests on Class 2 problems.

Since the problem instances generated by us are not identical to theirs, but statistically similar, we compare the summary statistics on sets of 20 randomly generated instances. These comparisons for the three sets of problems are shown in the Table 3. Each entry in the table provides the summary statistics for number of wavelength layers for each problem set in the following format: (minimum, average, maximum).
                        
                        
                     

Even though each of the 20 problems for which the summary statistics are reported need not be exactly the same, the tight range within which the solutions lie and the close proximity of the average values suggests that both methods tend to provide good results. In terms of computational time, we note that [Procedure MP] works significantly faster when compared to the total time reported by Lee et al. (2002), especially for the larger problem NET2. However, note that the problem instances are not the exact same but only statistically comparable. Also, the computing machinery used by Lee et al. (2002) is different from that used in our work. These could also be the sources of differences in computational time.

We conducted computational tests on a set of 10 randomly generated graphs with 25 nodes and 50 edges. The coordinates of the nodes were located randomly on a grid of 100 by 100 units, and the facility cost ce
                      was taken as the Euclidean distance between the nodes. For each graph, three traffic matrices were generated, with low, medium and high traffic density, respectively. The number of traffic demands for each node pair was a randomly generated integer from the range [0, θ], where θ=3, 7 and 20, respectively, for low, medium and high density. Value of C was assumed to be 160 in these instances, as this is the maximum number of wavelengths that modern optical systems with 50 GHz spacing can support over C and L bands. However, the use of older systems with 50 GHz spacing which support 32, 40 and 80 wavelengths are also quite prevalent. Therefore, we report some results for C=40 and C=80 also with medium traffic density. Computational tests were carried out on a 3.3 GHz processor with 4 GB RAM. CPLEX 12.6 was used as the LP/IP solver.

Different parameter values were tried and the best obtained values are reported. For high and medium traffic density problems, np
                      was set at 1000. For low traffic density problems, the initial starting set 
                        
                           Γ
                           ^
                        
                      was itself sufficient to produce the best results without generating any additional routes. For low traffic density problems, a time limit of 10 seconds was set for each maximum-clique identification problem.

The results for the three sets of problems, i.e., for High, Medium and Low density instances are reported in Tables 4–6
                     
                     , respectively. Each table is organized as follows. Column (2) reports the cost of initial network designed with 
                        
                           
                           C
                           =
                           160
                           ,
                        
                      and column 3 reports the number of λ-layers needed for feasible routing of all demands in this network. If this number, nλ
                     , is greater than 160, a second iteration is carried out with a smaller value of 
                        
                           C
                           =
                           160
                           −
                           δ
                           ,
                        
                      where δ > 0 needs to be carefully chosen. Our experience suggests that for high traffic density problems, a good choice of 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                           ,
                        
                      while for medium and low traffic density problems, a good choice is 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                           +
                           1
                        
                      or 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                           +
                           2
                        
                     . For subsequent iterations, if necessary, δ is increased by 1. These results are reported in columns (4)–(6). Column (4) reports the C value used in iteration 2, column (5) reports the network cost, and column (6) the number of wavelengths needed for feasible routing. If the number of wavelengths still exceeds 160, which happens in a very few instances, a third iteration is carried out with a further reduced value of C, the results of which are reported in columns (7)–(9). Columns (10) and (11) report the combined cpu time spent in all iterations on network design and wavelength routing, respectively. Finally, Column (13) reports the percent optimality gap between the final solution cost and the cost of iteration 1 network, which is a lower bound. While designing the lower bound network during Iteration 1, it is important to solve the problem optimally so as to claim that the resulting solution is a lower bound. However, in subsequent iterations with lower values of C, it is not necessary to solve the problem optimally, as we only wish to get a feasible solution with a small gap from the lower bound. Such a solution is generally obtained within a few minutes of cpu time, while solving the problem to optimality may take much longer. Therefore, we impose an upper limit of 600 seconds of cpu time on the network design phase of Iterations 2 and 3.

It is seen from Tables 4–6 that high traffic density problems require more iterations as compared to low traffic density problems. The total computational times are also higher for high traffic density problems. All problem instances across different traffic densities are solved within 1000 seconds of computational time. For low traffic density problems, as indicated in Section 5.4, it is possible to improve on the Gondran–Minoux’s algorithm to make the resulting starting routes more compatible for wavelength routing. Since the resulting network can have negative cost undirected arcs, the Floyd–Warshall algorithm is used and only routes that do not have a negative cycle are added to the set of starting routes. A majority of the problem instances are solved within 1.2% of optimality. A good rule of thumb for choice of δ for subsequent iterations of high traffic density problems seems to be 
                        
                           δ
                           =
                           
                              n
                              λ
                           
                           −
                           C
                        
                      from the first iteration. However, for medium and low traffic density problems, δ is required to be higher. Also, it is observed that the values of nλ
                      of subsequent iterations is not necessarily a decreasing function of δ. It remains an avenue of further research to probe whether this is due to the heuristic solution procedure for [MP] or due to formulation [ANDP] itself.

In this section, we perform a sensitivity analysis of the computational results with respect to the graph density and the C value by altering these parameters in a controlled fashion. All tests were performed on medium traffic density problems. Firstly, tests are performed on 25-node problems by changing the number of edges to 40 and 60 rather than 50. Results for these runs are reported in Tables 7 and 8
                        , respectively.

From Table 7, we see that the solution quality and computing time are comparable to the case with 50 edges.

From Table 8, it is clear that the problem gets much harder to solve as the graph density is increased. At present, 25 nodes and 60 edges appear to be the limit in terms of problem sizes that can be provably solved within a reasonable optimality gap. The bottleneck is the solution procedure for [ANDP]. It is noted that for 2 of the 10 problems, the ANDP algorithm failed to design the optimal lower bound network within 1800 seconds of computing time. The average optimality gap is also seen to increase slightly compared to the case with 50 edges. Problem instance 10 is the only case in our computational experiments where the final design shows a gap of more than 5%. Application of the rule of thumb to choose δ in iteration 2 resulted in a designed network with a gap of 11.2%. However, in iteration 3, by trying out a different value for δ such that the choice of C is halfway between the choices in iteration 1 and iteration 2, the gap was brought down to 6%.

Next set of tests were performed on 25 nodes and 50 edges problems, with 
                           
                              C
                              =
                              80
                           
                         and 
                           
                              C
                              =
                              40
                              ,
                           
                         which are more commonly used in real networks. These results are reported in Tables 9
                         and 10
                        , respectively.

For one problem instance, 7, application of the rule of thumb for choice of δ in iteration 2 led to gap of 5.1%. However, by attempting to redesign the lower bound network with an intermediate value of C led to a better design with a gap of 3.4%. These instances (instance 10 in Table 8 and instance 7 in Table 9) seem to suggest that if nλ
                         turns out to be significantly greater than C in iteration 1 (especially for the case in Table 8), the problem instance is likely to have a higher value of final % Gap.

As the value of C decreases, even a small increase in δ leads to a significant increase in the optimality gap. This happens because each unit change in δ value constitutes a larger percentage of C. However, the computational times are also likely to be lesser as can be seen from Table 10. Hence, the preferred rule of thumb for 
                           
                              C
                              =
                              40
                           
                         case is to choose 
                           
                              δ
                              =
                              
                                 n
                                 λ
                              
                              −
                              C
                           
                        .

@&#CONCLUSION@&#

In this paper, the optical network design problem subject to wavelength continuity constraint, WRND, was considered. Although the standard NDP and the RWA problem have been considered separately in literature, the joint problem of WRND has received virtually no attention. Using new inequalities derived for wavelength routing, the standard NDP formulation was strengthened to provide tighter lower bound network designs for WRND. For low traffic density problems, upper bounds were obtained by developing a fast and efficient heuristic that utilizes an enhanced Gondran–Minoux algorithm to generate paths that are more conducive for wavelength routing. The effectiveness of our approach was further enhanced by using the clique inequalities before applying the rounding heuristic. The quality of the heuristic solutions is found to be particularly good in the case of low and medium traffic density cases, where a majority of the problem instances are solved optimally. In the case of high traffic density problems also, the optimality gaps are quite small. Computational tests were conducted on problem instances that are significantly larger than those that have been reported in recent literature on network design and wavelength routing problems. Despite this, the problem instances reported are of moderate size. It remains an avenue for further research as to how even larger problem instances can be solved more efficiently. Another as yet unexplored area is the design of wavelength routed survivable networks with shared protection routing. Design of such networks without the wavelength continuity constraint was addressed by the authors in a recent work (Agarwal & Venkateshan, 2014). Currently we are exploring the issue of imposing wavelength continuity in the design of such networks.

@&#ACKNOWLEDGEMENTS@&#

The authors would like to thank the two anonymous referees and the editor, Prof. Immanuel Bomze, for their comments which helped improve the presentation of our work. This work was partially supported by the Research and Publications Committee of the Indian Institute of Management, Ahmedabad.

@&#REFERENCES@&#

