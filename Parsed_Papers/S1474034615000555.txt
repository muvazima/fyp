@&#MAIN-TITLE@&#Integrating heterogeneous engineering knowledge and tools for efficient industrial simulation model support

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           The enhanced knowledge management improves the simulation design and integration.


                        
                        
                           
                           The article proposes a data model supporting simulation model engineering.


                        
                        
                           
                           An infrastructure called the Engineering Service Bus improves simulation processes.


                        
                        
                           
                           The approach is evaluated on a hydraulic system use-case showing its efficiency.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Knowledge modeling

Data transformation

Ontology design

Integrated environment

System integration and implementation

@&#ABSTRACT@&#


               
               
                  Design of simulation models and their integration into industrial automation systems require knowledge from several heterogeneous data sources and tools. Due to the heterogeneity of engineering data, the integration of the tools and data are time-consuming and error-prone tasks nowadays. The key goal of this article is to provide an effective and efficient integration of heterogeneous data sources and tools as a knowledge basis to support dynamic simulation for industrial plants. The integrated knowledge is utilized both (i) in the design phase of simulation models for defining structure and interfaces of the models and (ii) in the runtime phase of industrial systems for model-driven configuration of the integrated environment. Reaching such goals with a manual approach or point-to-point integration is not beneficial as it may be possible for a few tools and data sources, but quickly gets very complex. A growing number of elements increases the risk of errors and the effort needed for integration. The proposed solution is based on a specification of a common data model to represent engineering knowledge and a service-oriented tool integration with the Engineering Service Bus. Engineering knowledge is integrated in a knowledge base implemented with ontologies in Web Ontology Language-Description Logic (OWL-DL). The proposed approach is demonstrated and evaluated on an educational hydraulic system. Major results of the article are: (i) a data model to represent engineering knowledge for dynamic industrial systems, (ii) the integration platform that, based on this model, integrates the tools for system design and runtime, and (iii) basic design-time and runtime processes for the integrated industrial simulations.
               
            

@&#INTRODUCTION@&#

Current industrial systems are becoming very complex. To support their design and to facilitate testing, simulation is becoming an essential method for improving the design of industrial plants as well as to optimize their behavior. Industrial simulation is considered as a basic tool for a virtual commissioning of industrial plants, which is intended to optimize the structure of plants during engineering processes as well as to test and to fine-tune control algorithms. This kind of tasks require to perform many experiments. Making them on the real plant directly would be time-consuming and costly, therefore, the preferred approach is to shift the experiments into the simulated world. Furthermore, experiments on real systems can be unsafe (e.g., in case of power plants or aircrafts), unrepeatable under the same conditions (e.g., operation under unique time-courses of weather conditions and activity profiles), and costly (e.g., expensive sensors placed under extreme conditions). As simulation models are the main building stones for the virtual commissioning, this article is focused on the support for the design of simulation models as well as their integration within industrial automation systems. These issues are also integral parts of the envisioned Factories of the Future [1] and the article satisfies their requirements.

Although the use of simulations offers a lot of benefits, the current approaches suffer from (i) a complicated design phase and (ii) a problematic integration with the rest of systems related to the design and tool integration for industrial plants. Even though companies and researchers focused on industrial automation emphasize the need for increasing the integration and re-use of codes, algorithms, and other engineering artifacts, such needs are not met in existing simulations on the SCADA system level (i.e., Supervisory Control and Data Acquisition system level, which is explained in details later). Current industrial plants have a mechatronic nature frequently, i.e., the systems are created by collaborative work of several engineering disciplines [2,3]. To properly support the design of simulations, it is needed to integrate heterogeneous data and tools from such different engineering areas. However, sharing knowledge and data in non-standardized and non-automated ways is very inefficient. Important pieces of information can get lost and delays in engineering projects can occur [4].

The main motivation for this article is to reuse the knowledge related to design and structure of industrial plants for the simulation model design and integration. The engineering knowledge is available from engineering plans, such as electrical schemas, piping and instrumentation diagrams (P&IDs), floor plans, mechanical plans and others. Such engineering plans exist in every industrial project and they can be reprocessed for simulation purposes. To support this issue, a knowledge base is used. The utilized knowledge base is called the Engineering Knowledge Base (EKB) and it is introduced in [5]. The EKB can involve several data models represented as ontologies [6]. This article discusses the EKB data models intended to support dynamic simulations for industrial plants. The proposed integration process does not cover technical integration only, but it also incorporates the semantics, i.e., the meaning of knowledge and data. In addition, the proposed approach covers the whole simulation life-cycle: design, integration, testing, and runtime operation phases. From the point of view of including semantics and targeting the whole simulation life-cycle, the existing integration in the domain of industrial simulation is rather weak. In addition, this article describes the infrastructure that is able to process available domain models (plans), and the process how to configure and how to utilize the proposed model and infrastructure from the user perspective.

The operation of industrial plants is automated by automation systems. They are software parts of industrial systems and their design phase is difficult and costly especially in case of the current complex mechatronic systems. The addressed integration level is depicted in Fig. 1
                     , emphasizing the dash-dot contribution of this article. This schematic layered hierarchy of automation systems is called the automation pyramid. Many particular versions of the pyramid exist; one of its representations can be found in [7].

The pyramid depicted in Fig. 1 represents our view on the data architecture in automation systems. On the lowest level, there are input and output data, which are physically handled by I/O modules and fieldbuses. On the second level, there are control algorithms in programmable logic controllers (PLCs). The third level consists of a SCADA system [8]. This level is proposed to be extended with simulations. A SCADA system is a system that is intended to provide access to industrial plants, both for human operators and for upper software systems. It can be considered as a borderline between the hardware and software parts of the automation system, because the lower levels are tightly connected to the hardware, whereas the higher levels are software-oriented. SCADA systems include human–machine interfaces (HMIs) [9] that are software tools for the interaction with human operators, historians for storing time-series of historical data, alarms and events subsystems, and many other subsystems. In this article, we consider a SCADA to be a software system only. The highest levels of the automation pyramid include Manufacturing Execution System (MES) providing planning and scheduling of the production, and Enterprise Resource Planning (ERP), which is used for the company management (e.g., SAP).

The goal of the article is to reuse the engineering knowledge related to engineering-phase of industrial plants for supporting the design and integration of simulation models on the SCADA level of automation systems. The article addresses the following research issues, whose position is depicted by numbered circles in Fig. 2
                      relating the research issues to the state of the art:
                        
                           •
                           
                              RI–1: Design of the Engineering Knowledge Base for Simulation

Design of a knowledge base has to allow capturing all relevant pieces of information to support the industrial simulation model design and integration. This research issue is related to the application of the EKB principles for simulation purposes.


                              RI–2: Design of a Technical Infrastructure

A modular infrastructure integrating various tools and supporting the knowledge base for capturing structured knowledge as well as model-driven configuration and simulation model design poses a challenge.


                              RI–3: Engineering and Integration of Simulation Models

A methodology for simulation model design based on formalized knowledge is required to make simulation engineering more efficient and to prevent design and integration errors.

The remainder of the article is structured as follows. Section 2 summarizes the related work in the areas addressed in the rest of the article. Section 3 addresses research issue RI–1 dealing with the structure of the EKB. The section proposes a common data-model to capture knowledge about physical systems, simulations and other domains in automation systems. Section 4 discusses the Engineering Service Bus as a technical infrastructure satisfying the needs for the support of industrial simulations. It provides a solution for the research issue RI–2. Section 5 addresses the research issue RI–3. It is focused on the process of populating the knowledge base with knowledge and retrieving it, as well as it also discusses the differences between design-time and runtime processes of the Engineering Service Bus. Section 6 shows how to utilize the proposed approach in practice. It describes the hydraulic use-case to illustrate and to evaluate the method. Finally, Section 7 concludes, evaluates contributions of the novel method and proposes further work.

@&#RELATED WORK@&#

The extraction and re-use of knowledge for supporting engineering of industrial plants as well as their automation and control systems are crucial tasks in the emerging area of knowledge-based engineering (KBE) [10,11]. In terms of the KBE, the approach in this article can be classified as knowledge-based engineering applied to the simulation area. The most relevant related works are summarized in Fig. 2 and they are described below.

Creating mathematical models for mechatronic systems can be done with the bond-graph theory [12] systematically. The term “bond” is related to the interaction of devices, where energy is transferred and balanced. Bond graphs utilize generalized variables flow and effort, whose product is energy to be transferred through specific bonds. The main limitation of bond graphs is that they are primarily intended for manual use. Although various software implementations have been released, their way of use still follows the manual nature and it does not satisfactorily meet current requirements on module-based simulation or vertical scalability and encapsulation of models. The approach presented in this article considers bond graphs to be a still useful and promising paradigm for creation of simulation modules and the proposed models, infrastructure and processes are in compliance with this theory.

Since the presented approach is oriented on large-scale industrial problems, the engineering and the behavior investigation should be solved on an appropriate level of granularity and abstraction. This assumption leads to orientation on blocks, encapsulating specific functionalities. One of the block-based approaches is presented in [13], dealing with the ontology-driven simulation model design. The paper is focused on generating MATLAB–Simulink blocks and defining them via DAVE-ML according to a domain ontology, which is the Trajectory Simulation Ontology in the presented case. Connections of these blocks are consequently done manually.

The Ontology Driven Simulation design tool suite is presented in [14]. The described approach is based on two ontologies; the first one is called a domain ontology and it categorizes knowledge including a problem vocabulary. The second one is called a modeling ontology and it is used for the simulation model description. The discrete event model is assumed and it is represented by the DeMO (e.g. Discrete Event Modeling Ontology [15]). The whole approach is based on mapping concepts from domain ontologies to a modeling ontology, translating ontology instances to an intermediate XML markup language and generating an executable simulation [14]. The approach presented in this article is based on a similar idea, but it addresses integration of engineering tools, data sources, as well as it reflects features of large-scale industrial systems.

Integration approaches in the industrial automation typically rely on repeating manual work, which is not satisfactory in the area of flexible systems of the future. A promising integration approach is the semantic integration, which is based on the specification of system interfaces and on finding mappings between common entities in heterogeneous schemas [16]. For example, semantic mappings can inter-relate a really measured variable and its simulated approximation, real devices and their equivalents in a simulation model or local names of tags used in a particular tool with the global representation of the tag name.

Data models for semantic integration are usually captured in ontologies. One of the most famous definitions is by T. Gruber: “An ontology is an explicit specification of a conceptualization” [6]. In the presented approach, a set of particular ontologies is utilized. The important benefit of ontologies is the simple querying and inferring new pieces of knowledge. The language SPARQL [17] is frequently used for querying, whereas the language SWRL [18] can be used for inferring new knowledge.

The semantic integration level is not an alternative to the technical integration approach. Semantic integration extends technical integration and it utilizes the technical level for data transport between systems and tools that produce or consume data [19]. Both levels can be implemented in various ways. In this article, the semantic integration of engineering knowledge is based on the EKB [5] (addressed in Section 3) and the utilized technical infrastructure for the tool integration is the Engineering Service Bus [20] (addressed in Section 4).

Tool and data integration is a standard task in current business IT systems. However, integration of simulation models within the rest of automation systems is not common [21,22]. Therefore, benefits of simulation models are not achieved decently. Existing integration approaches in the simulation domain are focused on re-using the simulation code. In order to provide results of simulations to all groups of users, a complex generic integration environment is required, but does not exist yet.

A widely cited approach for the simulation integration is HLA [23]. It is a framework dealing especially with the composition of simulations from sub-models. It does not address the problem of data sources. Aside from such an absence of data source management, the shortcoming of this framework is the absence of semantics.

The process of integration in the industrial automation area is standardized by ISA-95. The data models defined by this standard and applications satisfying it are described in [24]. ISA-95 is focused on vertical (also called hierarchical) integration of automation tools and it systemizes this type of integration. The standard is widely cited especially when integrating ERP systems with the rest of automation systems.

Another widely-used standard is ISA-88, which is focused on batch processes. The approach presented in this article adopts basic principles of ISA-88 and one of the basic scenarios used for testing of the proposed infrastructure is the simulation of batch processes in hydraulics.

At the borderline between technical and semantic integration, there is a standard ISO 15926 [25]. Although it has been originally intended to oil industry, its ideas are general and usable in other domains as well. In the original version of the standard, the description of data models and reference data was based on EXPRESS language. It was difficult to use, hence the standard was enhanced with supporting OWL ontologies [26].

Many UML-based and XML-based representations of plant topologies can be found in literature. The Systems Modeling Language (SysML) is a general-purpose modeling language for model-based systems engineering [27], which is built on top of UML. This language can be used not only for the description of systems, but also to support the design of simulation models typically in Modelica language [28]. Examples of transformers from the SysML to simulation models are SysML2Modelica or SysML4Modelica.

A widely cited XML-based language is AutomationML [29], which is intended for the description of industrial plants and software tools from the automation, instrumentation, and control perspectives. AutomationML is based on four hierarchies that can be inter-mapped. They describe system components including their parameters, system units, roles, and interfaces. The common weak point of such XML formats is the absence of semantics as well as XML files are difficult to query and to perform knowledge reasoning, hence their application for the configuration of the integration platform is limited nowadays.

Among existing ontologies, the most relevant is OntoCAPE [30], which is a set of (possibly inter-mapped) ontologies covering a description of large-scale physical systems, signals, etc. It has a layered modular structure and it is implemented in OWL-DL. In a broad research context, the OntoCAPE is described in [31] that also summarizes other existing ontologies in related domains. Nevertheless, the shortcoming of the existing ontologies is that they cope with a specific domain, and thus they do not cover the whole automation system in terms of the supporting the design and integration of simulation models within industrial automation systems.

Industrial data acquisition is usually based on OPC. It is a technology intended especially for acquiring process data and sending control actions to the devices. Each variable is denoted by “tag”, which is a unique name for that variable. OPC Unified Architecture (OPC UA) is an industrial specification developed on bases of the classic OPC specification and it combines all of the following classic OPC standards: OPC Data Access, OPC Historical Data Access, and OPC Alarms and Events into one unifying specification [32]. Unlike classic OPC, OPC UA clients can request data from other clients, hence the UA clients can behave as OPC UA servers as well. Both OPC and OPC UA standards are used in the presented approach for the data acquisition.

Simulation design and integration rely on various approaches investigated in the areas of semantic integration of data-models, integration of software systems based on SOA and ESBs, and advanced methods for simulation model design. These disciplines must be connected in such a way that leads to a synergy between the particular results. Although a lot of work has been done in each particular area, from the simulation support point of view, their connection leads to a qualitatively better result for facilitating simulation models. The approach proposed in this article is built on top of the state of the art in the following areas: the semantic and technical integration, knowledge representation utilizing ontologies in OWL-DL, bond graphs for design of block-oriented simulation models, ISA-88 for batch processes, and industrial data acquisition based on OPC and OPC UA technology.

Summarizing the basic terminology, the term real plant means a physical industrial system. In the use-case in Section 6, the real plant is an instance of a hydraulic system. The real devices in hydraulic systems are tanks (i.e., vessels), pipes, pumps, and valves. Examples of device parameters are lengths of pipes, volumes of tanks, maximal flow of pumps, etc. Parameters are properties of real devices and they are typically constants characterizing their size or shape. All values measured in the system by sensors are typically available on a software level on OPC servers. Each variable on the OPC server is called an OPC tag and it is a triple (name of the variable, timestamp, and value). Values of tags are time-series. They are control actions for a real plant (i.e., inputs into the real plant), and measured variables (i.e., outputs of real sensors). Tags are also inputs and outputs of simulation models in the very same way as in the real plant case.

Industrial plants are typically dynamic systems, i.e., they “have a response to an input that is not instantaneously proportional to the input or disturbance and that may continue after the input is held constant” [33]. Simulation models for industrial plants are software representations of mathematical models of the real plant behavior. “Mathematical models for dynamic systems are derived from the conservation laws of physics and the engineering properties of each system component” [33]. Converting mathematical models to executable simulation models typically rely on manual work of simulation experts. Such work can have diverse nature as various types of simulation exist, such as block-oriented simulation or equation-based simulation. The approach in this article is not limited for a specific simulation type. Nevertheless, the block-oriented simulation model in a signal-oriented simulator is utilized in the use-case in Section 6. Each simulation model is typically executed by a simulation solver, which is a numerical engine performing the simulation models under a given simulation time and satisfying relative and absolute precisions. Simulation models can be widely used in a variety of control and monitoring algorithms for diverse tasks, such as testing and fine-tuning control systems, supporting decision-making, training human operators, optimizing plant operation, or estimating unmeasured variables. The very same model can be used for all of these tasks, the difference is how inputs and outputs of the simulation model are used.

Simulation models have inputs and outputs, which are variables in the mathematical sense, and parameters that are mathematical constants specifying model dynamics, see Fig. 3
                     . In compliance with [33], the inputs are “functions of the independent variable of the differential equation, the excitation, or the forcing function to the system” [33]. The outputs are “the dependent variables of the differential equation that represent the response of the system” [33]. In practice, inputs and outputs are sampled, hence their values are time-series with discrete time. If the system is affected by disturbances, we assume that these variables are included as part of inputs. The parameters cover the three sets: (i) constants of the differential equations parameterizing the model dynamics, (ii) settings of the simulation solver, and finally (iii) initial conditions of the simulation model. In the following text, these interfaces of simulation models are described in details.

More formally, continuous-time finite-dimensional dynamic systems are described by the following equations [34]:
                        
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      x
                                                   
                                                   
                                                      ̇
                                                   
                                                
                                             
                                             
                                                i
                                             
                                          
                                          =
                                          
                                             
                                                f
                                             
                                             
                                                i
                                             
                                          
                                          (
                                          t
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                n
                                             
                                          
                                          ,
                                          
                                             
                                                u
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                u
                                             
                                             
                                                m
                                             
                                          
                                          )
                                          
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          n
                                       
                                    
                                 
                                 
                                    
                                    
                                       
                                          
                                             
                                                y
                                             
                                             
                                                j
                                             
                                          
                                          =
                                          
                                             
                                                g
                                             
                                             
                                                j
                                             
                                          
                                          (
                                          t
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                x
                                             
                                             
                                                n
                                             
                                          
                                          ,
                                          
                                             
                                                u
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          …
                                          ,
                                          
                                             
                                                u
                                             
                                             
                                                m
                                             
                                          
                                          )
                                          
                                          j
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          p
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 u
                              
                              
                                 k
                              
                           
                           ,
                           k
                           =
                           1
                           ,
                           …
                           ,
                           m
                        
                     , denote inputs or stimuli; 
                        
                           
                              
                                 y
                              
                              
                                 j
                              
                           
                           ,
                           j
                           =
                           1
                           ,
                           …
                           ,
                           p
                        
                     , denote outputs or responses; 
                        
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     , denote state variables; t denotes time; 
                        
                           
                              
                                 
                                    
                                       x
                                    
                                    
                                       ̇
                                    
                                 
                              
                              
                                 i
                              
                           
                        
                      denotes the time derivative of 
                        
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           ;
                           
                              
                                 f
                              
                              
                                 i
                              
                           
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     , are real-valued functions of 
                        
                           1
                           +
                           n
                           +
                           m
                        
                      real variables; and 
                        
                           
                              
                                 g
                              
                              
                                 j
                              
                           
                           ,
                           j
                           =
                           1
                           ,
                           …
                           ,
                           p
                        
                     , are real-valued functions of 1 +
                     n + m real variables [34]. In the sense of Fig. 3, the inputs are a set of 
                        
                           
                              
                                 u
                              
                              
                                 k
                              
                           
                           ,
                           k
                           =
                           1
                           ,
                           …
                           ,
                           m
                        
                     . The outputs are a set of 
                        
                           
                              
                                 y
                              
                              
                                 j
                              
                           
                           ,
                           j
                           =
                           1
                           ,
                           …
                           ,
                           p
                        
                     . In this article, we assume that the functions 
                        
                           
                              
                                 f
                              
                              
                                 i
                              
                           
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                      as well as 
                        
                           
                              
                                 g
                              
                              
                                 j
                              
                           
                           ,
                           j
                           =
                           1
                           ,
                           …
                           ,
                           p
                        
                     , can be parameterized with mathematical parameters that are real-value constants. Such a parametrization supports adaptation of simulation models or their parts to a wider class of problems without complicated re-design of the internal implementation of the model. Each of those functions can have an arbitrary set of parameters. Therefore, we get a set of constant parameters 
                        
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           ,
                           l
                           =
                           1
                           ,
                           …
                           ,
                           q
                        
                     , where q is a number of parameters.

A complete description of dynamic systems requires a set of initial conditions 
                        
                           
                              
                                 x
                              
                              
                                 i
                              
                           
                           (
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                           )
                           =
                           
                              
                                 x
                              
                              
                                 i
                                 0
                              
                           
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     , where 
                        
                           
                              
                                 t
                              
                              
                                 0
                              
                           
                        
                      denotes initial time [34]. Initial conditions are considered as a special set of simulation model parameters. To calculate outputs of these equations (i.e., the time series of 
                        
                           
                              
                                 y
                              
                              
                                 j
                              
                           
                           ,
                           j
                           =
                           1
                           ,
                           …
                           ,
                           p
                        
                     ), a simulation environment utilizes an internal or external simulation solver. The configuration of a simulation solver includes parameters such as required relative and absolute precision, minimal and maximal time-step, maximal number of zero-crossings, and others. We denote these parameters as simulation solver parameters 
                        
                           
                              
                                 s
                              
                              
                                 z
                              
                           
                           ,
                           z
                           =
                           1
                           ,
                           …
                           ,
                           r
                        
                     . In the sense of Fig. 3, parameters are a set of constants involving (i) sets of mathematical parameters 
                        
                           
                              
                                 c
                              
                              
                                 l
                              
                           
                           ,
                           l
                           =
                           1
                           ,
                           …
                           ,
                           q
                        
                     , (ii) simulation solver parameters 
                        
                           
                              
                                 s
                              
                              
                                 z
                              
                           
                           ,
                           z
                           =
                           1
                           ,
                           …
                           ,
                           r
                        
                     , and (iii) initial conditions 
                        
                           
                              
                                 x
                              
                              
                                 i
                                 0
                              
                           
                           ,
                           i
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     . Constraints of these parameters are related either to the simulation tool or to the simulation task. Constraints of simulation tool parameters (e.g., precision) are defined as simple assignment in simulation domain and passed during a configuration phase to a simulator connector. The detailed description of model implementation is not involved in the paper because it would exceed the paper scope.

The transformation of the aforementioned differential equations to difference equations for the discrete-time finite-dimensional systems is straightforward. It can be found in [34], thus we will not discuss it in more details here. The proposed method is intended both for the continuous-time and discrete-time finite-dimensional dynamical systems, the use-case in Section 6 is continuous-time.

Knowledge needed for designing and integrating simulation models is usually embodied in different and partly overlapping domain-specific data models. To facilitate the design of simulation models and to integrate engineering knowledge from various sources, the presented approach uses the Engineering Knowledge Base framework [5]. The Engineering Knowledge Base (EKB) is an ontology-based data-modeling approach. An ontology allows a programmer to specify in a meaningful and machine-understandable way the concepts and relationships that collectively characterize a domain and specific situations in that domain. While it is safe to assume that there will not be global ontologies agreed by one and all [5], the EKB builds on the idea that it is possible to create an ontology to be used as a common model for unifying and integrating the knowledge distributed among various data models. This common model represents the concepts that are overlapping across different local data models and that are relevant for engineering artifacts, such as simulation models. The EKB enables querying and inferring new pieces of knowledge efficiently, as it has been explained in [22] for the case of technical integration of simulations. In future, such knowledge could be also used to support intelligent fault diagnostics and PLC programming.

Specific pieces of information in the EKB should not be entered manually as it is time consuming and error-prone, but they should be derived from existing engineering tools and models semi-automatically. Each domain expert utilizes specific kinds of plans or notations. For example, chemical and water distribution systems are typically described by piping and instrumentation diagrams or flow diagrams and electrical systems are described by electrical schemas. In the hydraulic system use-case, the physical water distribution network itself is represented by P&ID diagrams, which is created by mechanical and civil engineers, electrical schemas represent electrical mounting such as drives for pumps, measurement and signal processing, which are in scope of electrical engineers, and control engineers utilize both these kinds of plans to design the control system and to implement control algorithms. Furthermore, the control system can influence the original electrical schema, hence such engineering disciplines have to cooperate during the design phase of the automation project life-cycle. In the following text, the data model of the EKB that satisfies capturing engineering data in a structured way is discussed in details. The processes how to populate the EKB with knowledge and how to utilize the captured knowledge for the integration at runtime are subsequently discussed in Section 5.

The EKB formalizes relevant information for integrating and designing simulation models of industrial plants. The following description explains the ontology model, which is the data model of the EKB. Fig. 4
                         depicts the most important domains represented in the ontology: the real plant domain, simulation domain, tag domain, and parameter domain. A crucial part of the figure are the mappings, which are used to inter-relate corresponding entities.

The real plant domain represents the structure of a real system, i.e., it includes physical devices and their connections. The simulation domain is focused on simulation models, which approximate the behavior of the real plant. This is the reason why the simulation domain and the real plant domain are connected by an arrow, expressing which parts of the real plant are simulated by simulation blocks and modules. Both real plant and simulation domains have tags and parameters. The inputs and outputs introduced in Fig. 3 are labeled with names, which define tags. Tags are variables with unique names that are inputs and outputs of devices or simulation models. On the contrary, parameters are properties of devices that characterize behavior and features of devices, models, etc. The difference between tags and parameters is that tag values are time-series (i.e., sets of samples), whereas parameters have constant values (i.e., time-independent single values). The tag domain in Fig. 4 is a taxonomy of tags that formalizes tags in the system and interrelates diverse tag representations in different domains. The parameter domain is a taxonomy of existing parameters that formalizes parameters in the system and interrelates diverse parameter representations in different domains.

Following this brief introduction into relevant domains, the further text explains this common data model in more details. The section addresses the research issue RI–1, which is focused on the design of a knowledge base for simulation model design and integration. The proposed data model of the EKB has been also called the automation ontology and it follows standard modeling approaches satisfying OWL-DL and industrial systems description.

The sub-ontology describing real industrial plants is depicted on the left-hand side of Fig. 5
                        . A real system is denoted as an individual of the “real plant” concept. Each plant is structured into one or more “locations”, which frequently correspond to geographical positions or functional behavior of system parts. Plant locations consist of one or more “real devices” (such as pumps, pipes or tanks), which are key entities of the real system description. Furthermore, it is not enough just to list the real devices, but it is very important to express how they are connected. The connections are formalized based on predicates “hasPowerBond” and “hasSignalBond”, which are adopted from the bond-graph theory [12]. The power bond means a connection where energy is transferred and balanced between the devices, whereas signal bonds are devoted to data or information transfers. Such a distinction is frequently used in the area of simulation modeling and in some cases also in the area of industrial automation.

Each real device can have one or more “parameters” as well as it can have input and output “tags” [35]. Since it is needed to map tags and parameters from various domains and their importance is crucial for the integration purposes, the proposed formalization considers them as a stand-alone domain.

Tags are definitions of particular input/output variables. The tag is a name of the variable and the definition of its data type as well as the minimal and maximal values. Values of tags are time-series of physical quantities that are either measured by sensors in the real plant or exported by a connector in the case of simulations and other software systems. They are process variables hence they characterize an actual state of the real plant. For example, frequent tags in hydraulic plants are pressure, flow, or liquid level. At runtime, values of tags are represented as sets of triples (tag, timestamp, and value), which are called in the presented formalization and the technical infrastructure “samples”. Within the service bus, tags must have unique names. However in particular tools, tags can have various names, which typically occurs in multi-disciplinary projects when for example simulation models are developed by another team of experts than the SCADA HMI. The transformation between the global tag names (i.e., service bus tags) and local names (defined by real, simulation and other types of tags) are done by connectors.

In Fig. 5, tags are depicted in the middle bottom part of the figure. Tags are distinguished by a data source, for example, a real tag represents tags on the OPC server related to real variables, and a simulation tag is related to inputs and outputs of simulation modules. These tags must be mapped in order to express that they have the same meaning, but their values can be different due to the various data sources. For example, a tag representing a liquid level in a tank can be measured in the real system and it can be simulated in parallel. An important benefit of the utilization of the EKB together with EngSB is a possibility to express tag workflows easily and efficiently. Such a specification of tag workflows is easy to modify as it is separated from tools. It also supports switching among various scenarios such as training human operators on the simulation model or substitution of a real value with a simulated value when a specific sensor is broken. The specification of tag workflows is discussed in Section 5.2, dealing with runtime processes.

Parameters are physical properties representing device features, such as size or length and other characteristics. Parameters are constant values (i.e., independent on time) and they are called “singles” in the proposed technical infrastructure.

The parameter sub-ontology and its mappings to other sub-ontologies are depicted in Fig. 5. The EKB distinguishes several kinds of parameters as each domain (i.e., real plant, simulation, or others) can be related to a dedicated set of parameters. From the user point of view, the most important set of parameters are parameters of a real system and its devices. For example, real parameters are lengths or diameters of pipes, volume of vessels, elevation above a reference level, etc. The second important group of parameters is related to the simulation model. We distinguish between “simulation parameters” and “simulation run parameters”. The simulation parameters are related to simulation modules and blocks. Control experts are familiar with various approximations of device or system behavior, such as transfer functions. For example, time constants and steady-state gains can be simulation parameters related to simulated devices. In general, simulation parameters are based on real parameters, but due to the simplification of the simulation model or due to the lack of information, there can be used approximations of real parameters instead. Another set of parameters are the simulation run parameters, which are related to each particular simulation experiment. They are conditions and settings of a simulation solver, which executes the simulation model. For example, simulation run parameters are the start time and the stop time of the simulation time, a type of a numerical solver, zero-crossing conditions, or minimal and maximal time steps. Last but not least, initial conditions are a special set of parameters, which define the state of a system at the beginning of a simulation. For example, initial conditions are a liquid level or temperature in each tank in the simulation time 
                           
                              t
                              =
                              0
                           
                        . The values can depend on a selected simulation scenario.

Further tools can have their local parameters as well, such as HMIs, data sources or others. Some of them can be based on real parameters, but a large variety of such parameters can be related to technical configurations of the tools. An example of this set of parameters is the setting of the connections of HMIs and OPC servers including IP addresses, protocols and ports, refresh periods, etc.

The structure of the simulation domain is depicted in Fig. 5 on the right-hand side. Each simulation model can be composed from one or more “simulation modules”, which are defined as an abstraction for any simulation code executable by a simulation solver. Examples of simulation modules can be particular MATLAB M-files, MATLAB–Simulink models, or files for a fuzzy rule-based system. A simulation model of a real system can be decomposed into more than one simulation modules, for example according to the spatial location of devices, functional behavior, etc. To execute the simulation, further modules can be needed, e.g., to prepare input data or to process output data, calculate statistics, etc. These modules do not implement the model of the real plant itself. Simulation modules are executed in a specific order, which is formalized in the EKB with a class “simulation workflow”. A process of a decomposition of simulation problems into simulation modules and specifying simulation workflows is strongly project-dependent and we do not try to substitute experiences of simulation experts in these tasks, we just investigate the support for them both in the design and integration phases of the simulation model life-cycle.

Simulation modules consist of simulation blocks. Simulation blocks can be either user-defined (used for specific and not repeating blocks) or included in a simulation library. The EKB model includes a class “simulation library” that represents available libraries and their simulation blocks. Typically, such blocks included in libraries have parameters only declared but not defined (they are called generic blocks), whereas their instantiations in simulation modules should be parameterized with specific values according to the required behavior.

The simulation domain is mapped to the real plant domain via the property “simulates” that expresses which real devices are simulated by specific simulation modules and blocks.

The fundamental requirement on the technical infrastructure is to inter-connect the EKB with engineering tools and automation system tools including simulations. The developed technical infrastructure is based on the Engineering Service Bus. It is equipped with connectors that are able to transform local domain data and their global representations into the EKB. For example, each P&ID is processed by a tool connector and its knowledge is captured, transformed, and stored in the shared ontology in the EKB. This section addresses the research issue RI–2 that is focused on the design of the technical infrastructure, which seamlessly integrates the EKB for simulation design and integration.

The Engineering Service Bus (EngSB) [20] extends the concept of the Enterprise Service Bus (ESB) [36] and of Service-Oriented Architecture (SOA) [37] to offer a vendor-independent solution for the integration of engineering tools with heterogeneous data models of an engineering environment. As shown in Fig. 6
                     , engineering tools are connected via tool connectors with the EngSB which provide software-services at their interfaces enabling the exchange of data and the calling of tool-specific services. The figure shows a simplified view on a particular EngSB configuration that generally consists of the following components: (i) engineering specific tools for e.g., piping & instrumentation, electrical planning, (ii) tool connectors establishing connections between engineering tools and EngSB components, (iii) the EKB enabling the mapping between heterogeneous local data models and common, project-specific concepts, (iv) flexible configuration of engineering processes and rules in a workflow engine, and (v) project-level applications which provide services based on integrated data and functions, such as the Engineering Cockpit that facilitates project monitoring and project reporting in heterogeneous engineering environments [20].

Engineering tools provide engineering experts data and methods in a vendor-specific manner, but typically support methods to access those services externally. The EngSB facilitates two ways of connecting engineering tools: in case of data integration, data instances of the appropriate data model are sent to and received from the EngSB. Connectors read/write data instances using files which are exported before and may be imported by the engineering tool. In case of functional integration the data models of engineering tools and tool-specific methods are considered at the binding of the tool with the EngSB. However, this approach requires a cooperation with tool vendors in order to provide tool-specific interfaces. Thus, the connector exchanges information via the interfaces that the tool vendor provides. This also implies that the quality of binding strongly depends on the vendor.

Connectors link engineering tools with the EngSB and consist of two parts. On the one hand, there is an engineering tool specific part, and an engineering tool independent part which enables communication to any component of the EngSB. The tool independent interface is also called “engineering tool domain” and may be interpreted as a standardization of connectors and engineering tool types [38] which facilitates the easy exchange of engineering tools without affecting data exchange with other engineering tools.

While engineering tool domains minimize the complexity of integrating engineering tools, they are not able to overcome semantic heterogeneity. The Engineering Knowledge Base (see Section 3) distinguishes between local tool concepts and project-wide common concepts and provides mapping mechanisms used to transform data instances between local concepts via common concepts.

An essential aforementioned benefit of the EngSB is a technological independent description of engineering processes and their automation [39]. The workflow engine of the EngSB supports the automated execution of workflows and processes between engineering tools and it is therefore responsible for the management of rules and events, as well as for the correct execution of the engineering processes. From a technical perspective, an engineering workflow is a set of configurable engineering process steps which were modeled in BPMN [40]. The workflow represents the way of integration as defined by project requirements. The defined process steps take into account the concepts modeled in the EKB, such as roles, mechatronic objects, restrictions, and engineering domains, engineering tools, and their data models and methods. Additionally, the EngSB logs the process execution behavior for analyzing purposes, so that the modeled engineering process may be compared with the executed one and therefore differences can be identified.

In order to support the design of simulation models, it is necessary to integrate all the relevant engineering data in the EKB. To support the runtime integration of simulation models within the rest of the automation systems, these simulation models and respective automation tools have to be connected to the EngSB. To achieve this, the following tool domain connectors have been designed and developed. In the simplest case, the combined support for the design and runtime integration of simulation models requires the three following domains.

The plant engineering domain is related to manage real plant data in the EKB. In compliance with the EKB model in Fig. 5, it includes methods for importing and managing the following real plant information:
                           
                              1.
                              Real plant name.

Location of devices within the real plant.

Devices and their connections (i.e., bonds).

Tag names in the EngSB, interfaces of simulation modules, and on OPC server.

Parameters related to the real devices as well as their values and types.

The plant engineering domain can be implemented by various tool connectors. One of them is a connector for Microsoft Visio, which is utilized in the hydraulic use-case in Section 6.

The simulation domain is related to the simulation models, covering especially their execution at runtime but also their configuration and design. The basic scenario assumes that a connector for a selected simulator loads simulation modules, configures their parameters, and sets input tag values. Afterwards, the simulator calculates output tags based on given input tag values and the connector exports the simulated outputs. The simulation domain defines methods for the following tasks:
                           
                              1.
                              Loading a simulator engine.

Loading a simulation module.

Passing on all kinds of parameters and settings of a simulation solver.

Loading input values.

Exporting output values.

In the current state, we have implemented a connector for MATLAB/Simulink [41]. MATLAB is one of the most widely used simulators, which is popular due to a wide range of functionalities, rapid prototyping, and extension possibilities. MATLAB includes the tool Simulink, which is a graphical signal-oriented simulation environment with various simulation solvers.

Connectors for MATLAB and Simulink are based on the MATLAB C external API. This API is a part of the MATLAB distribution and it includes methods for opening and closing MATLAB engine, getting and setting variables and their values in MATLAB workspace and finally a method for a remote execution of commands. In future, we would like to implement a connector for the equation-based simulations in the language Modelica [42].

The SCADA domain is responsible for interchanging tag values with the real plant (PLC level of the automation pyramid), their visualization in SCADA HMIs, and capturing them in historians. Key technologies for this exchange are OPC (OLE for Process Control) and OPC UA (OPC Unified Architecture). Since OPC UA has not been widespread in industry yet, we are focused on the classic OPC technology now.

An OPC client transfers runtime process data between the OPC server and the EngSB. Typically, such data contain measured samples from the real plant and control actions for the actuators. The control actions come from either HMI or APC (advanced process control), which can be implemented in various ways, such as a fuzzy supervisory control system compiled into an executable form, as a module in MATLAB or as a routine in a dedicated software. An OPC client has two types of interfaces. The first one is for the configuration of a system, whereas the second one is a data interface for reading and writing online data. The configuration interface has methods to add or to remove a tag and to add or to remove a branch from hierarchically structured OPC tags. The data interface has methods for both reading and writing online samples of tags. There are two implementations of these methods called synchronous and asynchronous, which differ in how they return values.

While the previous section described the technical infrastructure based on the EngSB, the following text discusses processes how to utilize the EKB and the EngSB from the user perspective in the industrial practice. This section addresses the research issue RI–3.

Design and integration of simulation models are very complex issues with many inter-related tasks, which are not frequent in general software engineering integration. We can distinguish two basic types of integration processes: design-time and runtime integration processes. Typical data flows for both process types are compared in Fig. 7
                     . The design-time processes, depicted on the left-hand side of Fig. 7, are focused on aggregating tool domain knowledge into the EKB, i.e., they are based on instantiating ontology classes in the EKB to capture available engineering knowledge. On the contrary, the runtime processes, depicted on the right-hand side of Fig. 7, are based on transferring values of tags between stakeholders within the EngSB. Runtime processes do not utilize the EKB, but they use a source code management (SCM) to control versions of settings and data. The benefit of the EngSB is that both types of processes can utilize the same technical infrastructure seamlessly. Details about these two process types are described in the following sub-sections.

The main task for the simulation design-time is to obtain data from domain engineering tools and to transform them into the structured representation of the EKB. The tool connectors are responsible not only for the extraction of tool data but they also interpret tool data in the domain context. This is the distinction between the source data and aggregated EKB knowledge from the information theory point of view. The EKB can be consequently efficiently populated with data in such a form that conforms the requirements on querying and reasoning in further process steps. Furthermore, the data and knowledge are not only downloaded from tools, but they can also be propagated to other tools, especially in the case of mechatronic projects.

The basic pieces of information come from process plans, which are P&IDs in the case of water distribution networks. Parameters and their values are not included in process plans typically, they are listed in a documentation or in special cases in a database. Processing natural language is not expected in this case due to the complicated text semantics and requirements on a high reliability. These pieces of information must be extended with expert knowledge deciding what simulation modules will be in the system, how their devices will be approximated, etc. Whenever such knowledge is included in the EKB, it can be retrieved out of it and it can be used for example for the OPC server configuration, e.g., tags and their groups can be created.

After collecting all relevant pieces of information into the EKB, they are processed and utilized for supporting the design of simulation models and the configuration of the EngSB environment for runtime processes. Such an integration approach is a typical example of the model-driven system configuration [43].

In the case of simulation module design, a simulation expert is involved in the iterative design process as follows. First, the design tool drives the interview with the simulation expert on the decomposition of a real system into one or more simulation modules. The initial proposals of the simulation design tool are focused on a module separation according to locations assigned to the real plant devices. After defining borderlines of the simulation modules, the design of the modules themselves can start. We distinguish between two basic scenarios depending whether a simulation library with simulation blocks exists or not.

If a simulation library is available, the structure of the simulation model can be generated automatically [44]. The EKB and the simulation connector then instantiate library blocks and connect them according to the topology of the real plant.

If a simulation library does not exist, the design process can be either manually-driven by a simulation expert, or it can follow the workflow presented in [21]. The major workflow steps can be summarized as follows: (i) selection of a granularity level, i.e., which devices will be simulated and which ones should be considered only as parts of complex units such as pump stations; (ii) a user selects parameters and values of blocks; and (iii) the machine automatically resolves connections according to the real system and it controls the whole source code and parameter version management system.

In compliance with [34], we assume that the simulation models and blocks are designed by engineers from the respective engineering disciplines. It means that the role of experts affects the heterogeneous engineering plans to be captured in the EKB as well as the basic building stones for the simulation models, which are then automatically combined and used for the automated design of simulation models as the last step of the discussed engineering process.

The simulation module or set of simulation modules should be integrated with the rest of the automation system in the EngSB infrastructure. This integration especially requires a definition of tags, which are inputs and outputs of simulation models. Values of these tags are exchanged via the EngSB at runtime. As well, a required routing of tags has to be configured. For each tag, the routing declares from which producer to which consumer the values must be transferred. The rules for this exchange are configured based on the knowledge captured in the EKB. This kind of setting is called the model-driven configuration of the EngSB runtime. Simulation models also need parameter values to configure their behavior. To summarize the required settings for the simulation model integration, the following values have to be configured:
                           
                              1.
                              List of input tags for each module.

List of output tags for each module.

List of parameters for each module.

Routing of tags between stakeholders.

After the configuration of the EngSB and the initialization of all stakeholders with parameters, the EngSB transfers tag values between stakeholders in the runtime mode. The exchange of tag values between stakeholders is driven by rules of the workflow engine in the EngSB environment. Each available tag sample is sent to the workflow engine and the engine re-sends the sample to the relevant stakeholders based on configured workflow engine rules. These rules are generated from the knowledge captured in the EKB. The required knowledge covers the simulation workflows and simulation runs individuals of the EKB data model. The automatic generation of the rules is a part of the model-driven configuration of the EngSB environment.

For instance, the right-hand part of Fig. 7 shows how SCADA HMI is used for the interaction with human operators. These operators can monitor and control, from the same HMI screens, either the simulation model or the real system, whose process values are provided by OPC. Simulation models can in this case simulate some artificial events, or they can be synchronized with the real plants via OPC. Both real plant and simulation data are stored in the runtime databases (historians), which can be arbitrarily accessed by operators via HMIs, or by simulation models.

Each simulation model can consist of one or more simulation modules that approximate specific parts of the real plant or that provide data transformations needed for simulation, e.g., pre-processing of initial conditions or calculation of boundary conditions. The main rule for the execution of the entire simulation workflow is the satisfaction of the data-driven architecture, i.e., data are transferred within simulation modules or among simulation modules and other tools such as HMIs when tag values are available or when a batch task should start by a user command. The timing issues are in charge of simulation engineers, and the proposed approach does not pose any additional constraints for this task. In the basic case, the execution of simulations is stopped when waiting for required data. The exchange of tag values between simulation modules and the rest of the integrated environment is the task provided partly by the Java-implementation of the connector and partly by data exchange blocks in the language of the simulation. To execute a complex simulation composed from several simulation modules, the proposed infrastructure utilizes the EngSB workflow engine, i.e., the rules for the execution of simulation modules being parts of the complex simulation workflows have the same nature as the rules for the integration of simulations with the rest of the automation system. Both sets of rules are based on the EKB knowledge, from which they are automatically generated.

To illustrate the rules for execution of complex simulation workflows, we can use an exemplary scenario depicted in Fig. 8
                        . The solid arrows illustrate the transfer of tag values between simulation module interfaces, whereas the dashed lines express that the simulation modules are executed by a simulation solver. Simulation solvers are typically included in simulation environments, such as MATLAB. Frequently, the simulation modules utilize the same simulation solver, however, each module can use a different solver in general. The role of the simulation solver can be compared to an interpreter of programming languages where the code corresponds to the simulation module and the interpreter to the simulation solver executing the simulation module. The core of the simulation solver is an implementation of a numerical method that is able to solve equations defined by the simulation module directly (in case of equation-based simulations) or equations inferred from simulation models by the simulation environment (in case of the signal-oriented simulations). In compliance with the mathematical description of dynamic systems, the main problem to be supported by the numerical method is the calculation of time-series related to the differential equations, presented in Section 3. In current solvers, widely used numerical methods are Runge–Kutta methods. An overview of these numerical methods can be found in [45]. Since several simulation solvers are included in simulation environments (such as MATLAB), the simulation or integration engineers do not need to have a detailed insight into the numerical method or the entire solver.

From the simulation design and integration points of view, important aspects are configurable parameters that simulation solvers require. The parameters are directly passed as a configuration to the numerical method algorithm, such as absolute and relative precision of the calculation, or start and end of the simulation time. Some of the parameters configure a version of the numerical method to be used, for example the number of steps in multi-step methods. The parameters, which are expected to change during the simulation model engineering or execution, are captured in the automation ontology, whereas those that are fixed during the whole simulation model life-cycle can be directly stored in the simulation modules. In case of batch processes, input data have to be available already at the beginning of the execution of the simulation workflow. In case of synchronized tasks, several stakeholders run in parallel and exchange data.

Current design and integration approaches in industrial automation are based on manual repeating work. To numerically evaluate the proposed approach, we assume that the simulation model design-time consists of the following process steps: (i) Specification of the real system taking 20% of the whole effort, (ii) definition of modeling granularity lasting 5%, (iii) design and implementation of simulation blocks and their interfaces taking approx. 30%, (iv) instantiation of simulation blocks, their interconnections and assembling of real signals taking 30%, and finally (v) testing, fine-tuning, and re-design with 20% of the whole effort. As the simulation integration corresponds to the size and structure of a particular simulation model, we assume that it can be approximated as a half of the step (iv) duration. In other words, we assume that the effort and time for integration of simulation models within the rest of automation systems corresponds to 15% on top of the design process of simulation models. These process steps were defined based on the literature review, practical experiences of authors, and experiences of industrial partners, who are a system integrator and a developer of user-oriented industrial automation applications.

Both the simulation design-time processes and the simulation runtime integration processes utilize the EKB and the technical infrastructure based on the EngSB. From this reason, it is difficult and insignificant to evaluate the EKB and the EngSB infrastructure independently. We will evaluate the whole two kinds of processes utilizing this infrastructure.

In case of the design-time processes for simulation models, the industrial partners estimated time and costs savings regarding this issue to be 30–40%. Utilizing the extended bond-graph method proposed by the authors of this article in [44], we can automate the entire process step (iv) dealing with the implementation of the simulation model and to save time and effort needed for testing in step (v). Therefore, we get savings of time and effort corresponding to 30% related to (iv) and a half of 20% related to (v).

In case of the improved integration of simulation models, the saved time and costs ranges between 25% and 45% depending on the proportion of follow-up algorithms and on the complexity of a project. The former value means that the specification of the system is improved and available in a structured way in the EKB (i.e., step (i) in the above specified list of process steps lasting 10% of effort) as well as the integration of simulation models is solved semi-automatically, lasting originally 15% of the effort needed for the simulation model engineering. The latter value 45% is related to savings covering an improved engineering process for other automation system tools, especially the design of HMI and configuration of OPC. However, these issues are out of the scope of this paper, therefore, we do not describe them in details.

The investigated aspects and methods can be demonstrated on a large variety of industrial systems. We selected an example dealing with a hydraulic system. Such kinds of systems are common in industry but also in our everyday life as water distribution networks are a specific case of hydraulic systems. This section illustrates how to utilize the proposed data model of the EKB and the technical infrastructure based on the EngSB in order to design and to integrate a simulation model for the laboratory tank model. It also evaluates the entire proposed approach.

The hydraulic use-case addresses a laboratory tank model, which is an educational system located in the Odo Struger Laboratory at the Automation and Control Institute of the Vienna University of Technology [46]. We focus on the module depicted in Fig. 9
                     . It involves the tanks T1 and T2, pipes P1–P8, pump E1, valves V1–V3, and liquid-level sensors LI_T1 and LI_T2. Their topology is depicted in the P&ID on the right-hand side of Fig. 9. Although this system is a laboratory model, it offers enough possibilities to approximate tasks related to real industrial plants and to perform various scenarios. The goal of a simulation model for this plant is to estimate liquid levels in all tanks and flows through pipes. Operators should be able to test on the simulation model what happens if a specific valve is opened, if a pump is set to the maximum power, etc. As the proposed approach is component-based and considers physical devices as units that are arbitrarily connected to larger assemblies, the proposed method can be scaled-up for real large-scale industrial plants.

Since the design and integration of simulation models are based on the real plant structure, it is necessary to start with the technical description of the real system. In other words, we should populate the EKB with ontology individuals representing real devices and their connections, as well as parameters and tags of those devices. Fig. 10
                      depicts the P&ID of the laboratory tank model created in MS Visio equipped with the EngSB connector. MS Visio is one particular tool that supports expressing engineering plans and data, but any other CAD tool could be used as well. The P&ID in Fig. 10 is enhanced with explicit representations of pipes, which are not standard parts of P&IDs. The explicit expression of pipes simplifies the subsequent population of the EKB with individuals. In addition, this connector supports insertion of parameters and their values into P&IDs as well, although they are not included in P&ID diagrams frequently. The reason is to make the design process and aggregation of engineering data more simple and efficient on the prototype level. It is faster and easier to grab the information from such an enhanced P&ID than retrieve the design knowledge from other data sources that are not in a machine-understandable form, such as in the case addressed in [47].

Having the system represented in MS Visio with the EngSB connector, clicking the button “Export to ontology”, causes that the connector creates the ontology individuals that represent all devices in the P&ID, parameters and their values, and tags. The structure of the ontology individuals included in the EKB for the laboratory tank model is depicted in Fig. 11
                     . Due to readability reasons, the figure does not show information about parameters and their values or properties of tags, but these pieces of information are also involved in the EKB. The depicted selection contains the structure of the real plant, i.e., the devices and their connections in the ontology notation.

By saving relevant knowledge from the source drawing to the ontology, the knowledge is captured in the machine-understandable form. It is consequently re-used for design of a simulation model. The simulation model design covers the selection of devices, which should be simulated. Having this kind of knowledge, a simulation skeleton can be created and used as a starting point for the implementation of the simulation logic. In the previous section, we explained that the presented infrastructure supports two basic scenarios for the simulation model design: the design process when a simulation library comprising simulation components is available, and the design process starting from scratch without prior engineering artifacts. In case of the tank model use-case, we implemented a simulation library first, i.e., we follow the scenario when the simulation library is available.

The simulation library was equipped with two simulation blocks representing pipes. The first one has pressure difference as input and calculates flow as output, whereas the second one has flow as input and pressure loss as output. The library also includes a simulation block representing a valve, which has pressure loss as input and flow as output. This interface supports simulation of valve closure, when the calculated flow is set to zero. If we modeled a valve as a convertor of flow into pressure loss, we would get infinite resistance of a valve, which is not numerically stable or even possible. In case of pumps, the simulation library could include two basic realizations, one pump creating pressure difference, and the second one affecting given flow through the pump depending on its current power. The library was equipped only with the first block in order to emulate limited resources in the industrial world. Finally, the library includes blocks modeling tanks, differing in number of real inputs and outputs.

Having the description of the real industrial plant captured in the real plant sub-ontology and having the simulation library annotated in the simulation sub-ontology of the EKB, we can merge these pieces of knowledge and create a simulation model for the specific plant. The simulation model created for the laboratory tank model is depicted in Fig. 12
                     . It is not important how the blocks are inter-wired and internally represented in terms of this article, but we will focus on interfaces of the simulation model (i.e., input tags depicted on the left-hand side of the figure and output tags depicted on the right-hand side), and parameters of the model, which are depicted on the top of the figure. Such tags and parameters are captured in the EKB during the design phase of the simulation model, and they are crucial for the integration phase of the model.

The next process steps are focused on the integration of the simulation model. The fundamental issue is the specification of simulation model interfaces, i.e., its input and output tags. The simulation model for the laboratory tank model has 4 input tags and 2 output tags, which should be integrated according to particular simulation scenarios. We assume that the model can be used for training human operators, and model-based fault detection. The operator training means that a trainee uses standard HMI screens and instead of working with the real system, he or she is connected to the simulation model. Therefore, a simulation run or a set of simulation runs are specified in the EKB and the EngSB infrastructure is configured in such a way that tags are routed between the simulation and HMI at runtime. The model-based fault detection is a type of a run when the same actions for the real plant are transferred to the simulation model as inputs, hence the real plant and its simulation run in parallel. The output of the simulation is then instantaneously compared with the measured data. Therefore, this type of a simulation run requires interaction with the real system, which is done via OPC server. It is necessary to configure the OPC server and OPC clients, which covers mainly setting of tag names and types of tags. Since all simulation tags and OPC tags coming from and to the real plant are captured in the knowledge base, such pieces of knowledge are used for generating the global tag list, which is a list of tags in the EngSB environment.

Most of the simulation models are parameterized with simulation parameters. In case of the laboratory tank model, such parameters specify lengths of pipes and their diameters as well as areas of tanks. Other parameters are elevations of pipes and tanks as well as parameters related to simulation runs, which are however not depicted in Fig. 11 due to simplicity reasons. During engineering processes, specification and fine-tuning of parameters evolves and it is beneficial to have the parameters and their values specified in the parameter sub-ontology in the EKB. For each simulation run, the simulation parameters are grabbed from the ontology in order to have a consistent set of parameter values.

To test and to evaluate the proposed approach, the following quality criteria were specified and estimated on the use-case level: completeness, performance, and functionality. Completeness is considered in the sense of the theory of formal languages, i.e., as a capability of the proposed data model and of the infrastructure to contain all elements needed for the design and integration of simulation models for industrial systems. It can be evaluated only on real use-cases. Performance is the rate of measured computational complexity of the proposed infrastructure. Functionality means the satisfaction of functional requirements on the data model and on the infrastructure. The obvious evaluation criterion is a scalability of the proposed approach to real large-scale systems. The proposed data model for the EKB was found to be 100% complete in terms of capturing all required pieces of knowledge in appropriate form. It included physical devices, their interconnections, parameters and tags, as well as available simulation blocks and their interfaces. The functionality of the proposed approach satisfied requirements on the use-case level as well as on the virtual testing scenarios. In case of this simple example, the performance was above measurable level as time periods for each types of operations were under significant time intervals. Therefore, we analyzed the influence of increasing number of devices, tags, and other entities in the EKB estimating the behavior under complex industrial conditions that were modeled.

The proposed approach was inspected for scaling-up to real large-scale industrial systems use. The technical infrastructure based on the EngSB is from the very beginning based on technologies supporting scaling-up for complex systems. The main limitation was identified as the performance of access to data captured in the automation ontology in the EKB. The authors analyzed the performance of several ontology frameworks in [48] and the simplified results of this performance evaluation are depicted in Fig. 13
                     . It compares the framework Jena equipped with the storages SDB and TDB as well as the framework Sesame Bigdata. Assuming maximal response time to be 3s, the figure shows that these frameworks work satisfactory up to the size of approximately 1million of triples. The query 1 listed all tags and the query 2 listed such tags that were created after a specific date and time. Let us assume that each real device is associated with a tag having a type, minimal value and maximal value, and that each device is connected to another device as well as that to the real system is mapped a simulation model at the end of the simulation engineering process. We get that to each device are related approx. 20 individuals, but this number can be higher (i) if a plant or module are structured into regions or submodules extensively (ii) if more parameters are related to devices and simulation blocks. Therefore, we expect 20–30 ontology individuals related to each device. The performance limit 1million of EKB individuals is thus reached in case of systems including 30,000–50,000 real devices.

This article explains the important role of knowledge representation and integration in the area of industrial automation systems, which is one of the emerging areas of knowledge management applications. One of the main contributions of the article is the proposed common data model of the EKB. It is a class model of the automation ontology capturing knowledge required for design and integration of simulation models for industrial automation. Simulation models are software approximations of real dynamic behavior of industrial plants and this article contributes to making their design and integration more efficient. The proposed infrastructure supporting the EKB data model and the seamless technical integration of various automation tools is addressed as well. It is based on the extension of the Enterprise Service Bus called the EngSB. The article summarizes the processes how to grab data, capture them in the knowledge base, and retrieve them out of it in terms of supporting the design of simulation models and their integration within industrial automation environments.

Current integration approaches in industrial automation are based on manual repeating work. They should be improved by such approaches that respect the distributed and heterogeneous nature of software automation tools. Well-structured and formalized knowledge leads to improved integration of simulation models. The proposed EKB data model satisfies the research issue RI–1 dealing with the design of a knowledge base for engineering data. Depending on the proportion of follow-up algorithms and on the complexity of a project, the saved time and costs related to the introduction of the EKB ranges between 25% and 45%, as it was explained in Section 5.4.

The proposed integration approach utilizing the EngSB is the suitable solution for a seamless tool integration for supporting simulation model engineering efficiently, which satisfies the research issue RI–3. Industrial partners estimated time and costs savings regarding this issue to be 30–40%. The technical infrastructure supporting the EKB and semi-automated simulation model engineering as the result of RI–2 is a key enabler for the results of RI–1 and RI–3. Hence its impact cannot be evaluated independently. As the proposed technical infrastructure is considered as a prerequisite for RI–1 and RI–3, its impact is already assessed as part of the aforementioned improvement indicators.

Although manual approach or point-to-point integration get very complex with a growing number of elements, the proposed approach can be scaled-up easily and it satisfies requirements on scalability for large-scale systems including up to 30–50 thousands of devices. With the complexity of industrial plants, the risk of errors using a manual approach grows; whereas the effort needed for the proposed integration does not depend on the number of devices and connected software tools, since their connectors are implemented once. Functionality capabilities were derived from the application context based on the scientific state of the art and on interviews with industrial partners, and their satisfaction was shown on the use-case in Section 6.

The proposed methodology contributes to save time and costs for development, deployment, reconfigurability, and re-use. Nevertheless, not all pieces of knowledge that are required for design and integration of simulation models can be extracted from available engineering plans, thus interaction with a skilled expert user is required. The main benefit of the entire proposed solution is a simplified re-design and re-use of simulation models and scenarios. Due to having knowledge in the knowledge base in a consistent and machine-understandable form, errors in simulation model design and integration are reduced. The proposed method contributes to a reduction of time for development and testing of the whole automation system.

In 
                        future work
                     , we would like to extend the proposed data model and the technical infrastructure for supporting a semi-automated failure diagnostics to detect for example leakages of liquid, broken sensors, etc. The technical infrastructure will be also extended with a profiler that will analyze data flows within the EngSB and it will map the measured execution time for each component onto the EKB data model in order to support estimations of performance and scalability for each integration scenario.

@&#ACKNOWLEDGMENTS@&#

This work was supported by the Christian Doppler Forschungsgesellschaft, the Federal Ministry of Economy, Family and Youth, and the National Foundation for Research, Technology and Development – Austria; and by the Grant Agency of the Czech Technical University in Prague, Grant No. SGS12/188/OHK3/3T/13.

@&#REFERENCES@&#

