@&#MAIN-TITLE@&#Weakly connected dominating set-assisted ant-based routing protocol for wireless ad-hoc networks

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We propose a novel WCDS-assisted ACO based routing protocol.


                        
                        
                           
                           The on-demand feature of AODV is used to improve the ACO scheme.


                        
                        
                           
                           WCDS works as an auxiliary structure to broadcast the Forward_Ant message.


                        
                        
                           
                           A LCC strategy is used to maintain the WCDS architecture.


                        
                        
                           
                           The pseudo-random-proportional-selection scheme selects the efficient route.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Ant colony optimization

On-demand routing

Weakly connected dominating set

Wireless ad-hoc networks

@&#ABSTRACT@&#


               
               
                  Advances in wireless ad-hoc network techniques have spurred the development of new approaches to increase network efficiency. One of the more popular approaches is swarm intelligence. Swarm intelligence imitates the collective behavior of biological species to solve network routing problems. Meanwhile, weakly connected dominating sets (WCDS) can serve as auxiliary structures for clustering nodes in the network. This paper uses the clustering concept of WCDS to propose an improved ant-based on-demand clustering routing (AOCR) protocol for wireless ad-hoc networks. Network states’ information is obtained from the Forward_Ant, and is only broadcast by the head of every cluster, thus decreasing the overhead required to transmit ant packets. To increase network efficiency, the pseudo-random-proportional-selection strategy is used to evaluate the best path from the source node to the destination node by the Backward_Ant.
               
            

@&#INTRODUCTION@&#

Advances in wireless ad-hoc networks have spurred the development of novel protocols to reduce packet delay, increase packet delivery rates and increase the energy-efficiency of communication. These protocols control how devices communicate with each other over the network if these devices are unfamiliar with the network topology.

That is to say, the nodes need to discover the network topology. The basic idea is that a node should promulgate its existence and then listen for notifications broadcast by its neighboring nodes. Each node thus learns how to reach other nodes or announces that it can reach them once a node is within the transmission range of other node as show in Fig. 1
                     . Most of the routing algorithms involved can be categorized as being proactive, reactive or hybrid [1], and these classifications are further described below.

In a proactive protocol, each node periodically transmits control packets throughout the network to refresh its list of destinations and their associated routes. In this way, a request to send data can quickly obtain a route from the source node to the destination node. However, this continuous proactive transmission of control packets results in considerable message overhead. In addition, this approach is unsuitable for use with mobile nodes because of its slow reaction to routing failures. Some commonly-used proactive protocols include Destination Sequenced Distance Vector (DSDV) [2] which manipulates each node as a customized router to periodically advertise its view of the interconnection topology to other nodes within the network; Optimal Link State Routing (OLSR) [3] which optimizes the simple link state by reducing the volume of retransmitting control packets in the entire networks based on the link state algorithm; and Cluster-head Gateway Switch Routing (CGSR) [4] which establishes a clusterhead-token infrastructure and uses least cluster change (LCC) to provide the firmest cluster structure for grouping mobile nodes and assigning radio channel codes.

In a reactive protocol, the node transmits control packets only on demand, thus conserving more bandwidth. However, the node may have to wait a considerable length of time for a route to be established before it can start to send data. Commonly-used reactive protocols include Ad hoc On-demand Distance Vector (AODV) [5] which makes each mobile node perform as a customized router and establishes routes as needed with little or no dependence on periodic broadcasts; Dynamic Source Routing (DSR) [6] which adapts quickly to routing changes caused by frequently moving nodes and requires little or no overhead when nodes remain static; and Temporally Ordered Routing Algorithm (TORA) [7] which is based on the link reversal concept using destination-oriented routing information to create independent local routing information for each destination node.

A hybrid protocol is usually based on a proactive protocol but contains some of the features and advantages of reactive protocol. In other words, the zone formation of network is based on the proactive protocol, and the connections of zones and route discovery are based on the reactive protocol. However, hybrid protocols entail some disadvantages, such as the need to choose and maintain the zones, and the need to arrive at a reasonable choice between proactive and reactive protocols. Commonly-used hybrid protocols include ZRP (Zone Routing Protocol) [8], Zone-based Hierarchical Link State (ZHLS) [9], and Sharp Hybrid Adaptive Routing Protocol (SHARP) [10]. ZRP limits the range of the proactive procedure, thus only keeping routes to the nodes’ local neighbors within the local scope of the networks by adjusting the routing zone radius. ZRP then searches all the networks by a reactive procedure to discover routes to the destinations beyond the node’s routing zone. ZHLS incorporates local information through a global positioning system (GPS) into a new peer-to-peer hierarchical routing approach and becomes proactive if the destination is within the zone of the source, or reactive if the location search requires the zone ID of the destination. SHARP automatically finds a good balance between proactive and reactive routing and enables every node to use a different application-specific performance pledge to control the adaptation of the routing layer.

In the last few years, some self-configuring, self-stabilizing and self-organizing algorithms have been considered as possible solutions for scalable multi-hop networks. Recently, there has been a growing interest in the use of swarm intelligence or nature-inspired algorithms [11] for routing in networks. Swarm intelligence is a computational intelligence technique to simulate the collective behavior of biological species for solving node distribution problems without extra central control or coordination. Ant colonies, flocks of birds, herds of animals and schools of fish are natural examples of swarm intelligence. The foraging of bees and ants, and the hill building behavior of termites has inspired researchers to develop efficient routing algorithms. On the other hand, many clustering techniques have been proposed for ad-hoc networks to obtain some benefits [12]. For example, for resource utilization efficiency, two disjoining clusters can use the same frequency or code set to achieve the spatial reuse of resources [13]. For routing discovery, routing process can be confined in the extent of clusters instead of the whole network so that redundant message exchange can be lowered [14]. Additionally, a clustering structure makes network appear smaller and more stable since local changes need not be updated in the entire network [15]. One of the clustering schemes used to cluster ad-hoc network nodes is forming some selected nodes as a weakly connected dominating set (WCDS) [16]. These algorithms are based on centralized approximation algorithms to find minimum connected dominating sets (CDSs). However, the authors proposed a zonal distributed algorithm to solve the problem of non-localized computation. The zonal algorithm is regulated by a parameter x, and this parameter x controls the size of the regions. When x is small, the scheme can quickly generate a larger WCDS. When x is large, the scheme operates like a non-localized algorithm and produces smaller WCDS. Regarding the connected dominating set construction problem, the method proposed in [17] constructed the WCDS based on the maximal independent set. The time and message complexity of this algorithm are O(n) and O(log n), respectively. Each node in the network only requires maintaining its neighboring nodes’ information. The scheme proposed in [18] presented a randomized distributed algorithm for constructing the minimal connected dominating set with an O(log Δ) approximation ratio, where Δ is the maximum degree in the network. With this algorithm, a sparse and connected sub-graph with a low stretch factor was proved as the effective one.

Based on these above reasons, we adopt ant colony optimization (ACO) as the main concept for routing path selection and WCDS as an auxiliary structure assisting the ant-based on-demand clustering routing (AOCR) protocol for wireless ad-hoc networks. This protocol can be classified as a hybrid protocol since the idea is derived from the local proactive cluster distribution and reactive communication among clusters. The protocol presented in this work uses ant-like agents inspired by the foraging behavior of ant colonies to explore networks and discover a route with several QoS requirements including minimal traffic overhead or energy-efficiency. In general, ACO is designed to find a better routing path by continually issuing routing packets (ants) to depose the pheromone information on the path from the source to the destination, so that ACO can maintain the routing path according to the pheromone trail. However, ACO would take a lot of overhead and energy consumption to discovery and maintain this routing information due to the periodical routing packets transmission. This feature may also occur when there are no data packets which need to be sent, and result in lower network performance. To overcome the deficiencies, we adopt the on-demand feature in AODV to improve ACO. We also refer the simplified version of AODV to make the efficiency of ACO better. Besides, in order to qualify the characteristics of wireless ad-hoc network, we implement a WCDS construction scheme to cluster network nodes to achieve more efficient packet transmission since only the nodes in WCDS forward the packets to their neighbors. In a short summary, we combine the characteristics of AODV and ACO to complement the deficiencies, and also use WCDS constructed by LCC as an auxiliary structure to elevate the efficiency of maintaining the network topology. Table 1
                      shows the comparative analysis of ACO, AODV, and our proposed scheme, AOCR. More details about these technologies are described in the later section.

The rest of the paper is organized as follows. Section 2 reviews existing routing protocols for both ant-based and conventional routing. Section 3 explains our algorithm in detail. Section 4 shows the analytical comparison and evaluation results to compare the proposed algorithm to the typical protocol — AODV and an existing ant algorithm routing protocol — AntSense. Conclusions are drawn in Section 5.

This section introduces the details of the three technologies, ACO, AODV, and WCDS, used in the development of our proposed scheme.

AODV provides a routing method for ad-hoc networks [5]. AODV has some key features such as building routes on demand, not recording nodes not in use, only maintaining useful paths, and having a high scalability. For these reasons, AODV is the easiest routing protocol to use for ad-hoc networks, and thus the most frequently studied. AODV broadcasts RREQ (Route Request) messages only when it receives a request to send data packets and the source node fails to identify a route to the destination node. The source node forwards the RREQ to its neighboring nodes, and then these nodes forward the request message until some node provides navigation information for the destination. This node then sends a RREP (Route Reply) along the original RREQ path back to the source node. When the source node receives this RREP message, the path is established and the source node can start to send data packets to the destination. Also, every node broadcasts hello messages to confirm connectivity with its neighboring nodes.

The excessive number of parameters in the original AODV specification can give rise to errors. AODVjr [19], the earliest simplified version of AODV, was developed by omitting some of these parameters including sequence numbers, precursor lists, RERR, and the gratuitous RREP. In addition, only the destination node can generate the RREP, thus preventing loops. The much simpler AODVjr can be extended by incorporating some optimizations to improve performance, and can also integrate some security features as the control packets contain no mutable fields.

In [20], the AntSense project is designed to be used as a new routing protocol thus optimizing ant colony behavior in WSNs. The idea is derived from that ants search food and then leave the pheromone trail along the path which they walk through as shown in Fig. 2
                        . The pheromone flavors can attract other ants to take the existing paths but evaporate with the time. Initially, the probability for each ant to choose its next step is the same. As the time passes, the pheromone on a longer path would last shorter since few ants pass through the longer path. Finally, the shorter path can become the best path between anthill and food.

In the networks, the ants are considered to be packets traveling through the network in search of a better path to the food (i.e., the sink-node). The source node periodically and randomly sends a forward ant to one of its neighbors. The selected neighbor then estimates the pheromone, updates the pheromone table, and finally forwards the forward ant to one of its neighbors till the forward ant arrives at the destination node. After that, the destination node sends a backward ant along the path the forward ant just takes for returning back to the source node. When the backward ant arrives at the source node, the path is established and the data packets can start to be transmitted to the destination node. This ant-based routing algorithm establishes the packet delivery path based on the energy-aware mechanism. However, some unavoidable defects in the ant-based routing scheme still exist. The defects will be addressed and can be improved by our proposed scheme in Section 3.

WCDS is a variant of the dominating set (DS). A dominating set S for a graph G
                        =(V, E) is a node subset S
                        ⊆
                        V such that, for every node 
                           
                              v
                              
                              ∈
                              
                              V
                           
                        , either 
                           
                              v
                              
                              ∈
                              
                              S
                           
                         or V can find a neighbor u in S. In contrast, in a graph G
                        =(V, E), the subgraph weakly induced by a subset S
                        ′(S
                        ′
                        ⊂
                        V) is the graph Sw
                        
                        =(N[S], E
                        ∩(N[S]×
                        S
                        ′)), where N[S] includes the nodes in S
                        ′ and all of their one-hop neighbors. The edges of Sw
                         are all edges in G having at least one end point in S
                        ′. A subset S
                        ′ is a WCDS if S
                        ′ is a DS and Sw
                         is connected. A simple example of WCDS is shown in Fig. 3
                        , where all nodes in the network are divided into several clusters. Each cluster includes a cluster head (in red
                           1
                           For interpretation of color in Fig. 3, the reader is referred to the web version of this article.
                        
                        
                           1
                        ). The cluster head has the largest degree and the smallest ID in terms of the neighboring nodes in the cluster. Each cluster also has several normal nodes (in orange), and all these nodes are one-hop from the cluster head. The rules of forming WCDS dictate that the distance between any two cluster heads should be less than two hops. But this is not necessarily the case here (e.g., nodes 4 and 9 or 4 and 14). To remedy this problem, some additional cluster heads (in green) are added.

WCDS has already been applied in many fields. For example, in ad-hoc networks, messages are forwarded among nodes in a multi-hop mode. Clustering nodes can reduce the complexity of message routing, and the concept of WCDS is very suitable for the formation of clusters. The authors of [21] proposed an energy-aware routing scheme based on a WCDS-induced clustering structure for data aggregation in the research related to wireless sensor networks. This approach reduces overall energy consumption and prolongs network lifetime by reducing the transmission energy required through data aggregation, traffic balancing and routing via nodes with more remaining energy.

AOCR is an on-demand routing protocol based on the ant colony algorithm and a clustering architecture. AOCR uses Forward_Ants to explore the overall network with the assistance of special nodes, cluster heads in clusters, as well as uses Backward_Ants to reinforce and select a better path from the source to the destination based on the pheromone trail values stored in the pheromone table built by the Forward_Ants.

Our algorithm develops a novel concept derived from the traditional ant-based algorithm. First, we adopt broadcasting ant packets instead of randomly unicasting to one of the neighboring nodes, thus reducing the time consumed by the routing discovery process. However, it may result in the increased number of generated ant packets. Hence, we use the clustering architecture of WCDS to reduce the packet load. In our proposed scheme, only the node in the WCDS can broadcast Forward_Ants. Each node in the network would periodically execute the ClusterHeadDetermination() as the Algorithm 1 shows to rebuild the WCDS structure.
                        
                           
                              
                              
                                 
                                    
                                       Algorithm 1: Procedure of WCDS construction
                                 
                              
                              
                                 
                                    //N: Null node
                                 
                                 
                                    //C: cluster head
                                 
                                 
                                    //O: ordinary node
                                 
                                 
                                    //N[v]: node v’s neighbor nodes
                                 
                                 
                                    //clusterID(v): node v’s clusterID
                                 
                                 
                                    //degree(v): node v’s degree
                                 
                                 
                                    //status(v): node v’s role
                                 
                                 
                                    
                                       ClusterHeadDetermination()
                                    
                                 
                                 
                                    1
                                       begin
                                    
                                 
                                 
                                    2
                                       
                                       if status(v) == N then
                                    
                                 
                                 
                                    3
                                       
                                       
                                       foreach u∈N[v]
                                 
                                 
                                    4
                                       
                                       
                                       
                                       if status(u) == N then
                                    
                                 
                                 
                                    5
                                       
                                       
                                       
                                       
                                       if degree(v)<degree(u) then
                                    
                                 
                                 
                                    6
                                       
                                       
                                       
                                       
                                       Exit()
                                 
                                 
                                    7
                                       
                                       
                                       
                                       
                                       else if (degree(v) == degree(u)) && (nodeID(v)>nodeID(u)) then
                                    
                                 
                                 
                                    8
                                       
                                       
                                       
                                       
                                       
                                       Exit()
                                 
                                 
                                    9
                                       
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    10
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    11
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    12
                                       
                                       
                                       end foreach
                                    
                                 
                                 
                                    13
                                       
                                       status(v)=C
                                 
                                 
                                    14
                                       
                                       clusterID(v)=nodeID(v)
                                 
                                 
                                    15
                                       
                                       Send CH(v) to N[v]
                                 
                                 
                                    16
                                       
                                       else
                                    
                                 
                                 
                                    17
                                       
                                       
                                       if status(v) == O then
                                    
                                 
                                 
                                    18
                                       
                                       
                                       
                                       foreach u∈N[v]
                                 
                                 
                                    19
                                       
                                       
                                       
                                       
                                       if (status(u) == O) && (clusterID(v)<clusterID(u)) then
                                    
                                 
                                 
                                    20
                                       
                                       
                                       
                                       
                                       status(v)=C
                                 
                                 
                                    21
                                       
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    22
                                       
                                       
                                       
                                       end foreach
                                    
                                 
                                 
                                    23
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    24
                                       
                                       LeastClusterChange()
                                 
                                 
                                    25
                                       
                                       end if
                                    
                                 
                                 
                                    26 end
                                    
                                 
                              
                           
                        
                     
                     
                        
                           
                              
                              
                                 
                                    
                                       Algorithm 2: Procedure of receiving CH(u)
                                 
                              
                              
                                 
                                    
                                       OnReceivingCH(u)
                                    
                                 
                                 
                                    1
                                       
                                       
                                       begin
                                    
                                 
                                 
                                    2
                                       
                                       
                                       if clusterID(v) == NULL then
                                    
                                 
                                 
                                    3
                                       
                                       
                                       status(v)=O
                                 
                                 
                                    4
                                       
                                       
                                       clusterID(v)=nodeID(u)
                                 
                                 
                                    5
                                       
                                       end if
                                    
                                 
                                 
                                    6
                                       end
                                    
                                 
                              
                           
                        
                     
                     
                        
                           
                              
                              
                                 
                                    
                                       Algorithm 3: Procedure of LCC
                                 
                              
                              
                                 
                                    //C: cluster head
                                 
                                 
                                    //O: ordinary node
                                 
                                 
                                    //N[v]: node v’s neighbor nodes
                                 
                                 
                                    //clusterID(v): node v’s clusterID
                                 
                                 
                                    //degree(v): node v’s degree
                                 
                                 
                                    //status(v): node v’s role
                                 
                                 
                                    
                                       LeastClusterChange()
                                    
                                 
                                 
                                    1
                                       
                                       begin
                                    
                                 
                                 
                                    2
                                       
                                       if status(v) == C then
                                    
                                 
                                 
                                    3
                                       
                                       
                                       foreach u∈N[v]
                                 
                                 
                                    4
                                       
                                       
                                       
                                       if (status(u) == C) && (clusterID(v) != clusterID(u)) then
                                    
                                 
                                 
                                    5
                                       
                                       
                                       
                                       
                                       if degree(v)<degree(u) then
                                    
                                 
                                 
                                    6
                                       
                                       
                                       
                                       
                                       status(v)=O
                                 
                                 
                                    7
                                       
                                       
                                       
                                       
                                       clusterID(v)=nodeID(u)
                                 
                                 
                                    8
                                       
                                       
                                       
                                       
                                       break
                                 
                                 
                                    9
                                       
                                       
                                       
                                       
                                       else if (degree(v) == degree(u)) && (clusterID(v)>clusterID(u)) then
                                    
                                 
                                 
                                    10
                                       
                                       
                                       
                                       
                                       status(v)=O
                                 
                                 
                                    11
                                       
                                       
                                       
                                       
                                       clusterID(v)=nodeID(u)
                                 
                                 
                                    12
                                       
                                       
                                       
                                       
                                       break
                                 
                                 
                                    13
                                       
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    14
                                       
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    15
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    16
                                       
                                       
                                       end foreach
                                    
                                 
                                 
                                    17
                                       
                                       else
                                    
                                 
                                 
                                    18
                                       
                                       min_clusterID = INT_MAX
                                 
                                 
                                    19
                                       
                                       
                                       foreach u∈N[v]
                                 
                                 
                                    20
                                       
                                       
                                       
                                       if status(u) == C then
                                    
                                 
                                 
                                    21
                                       
                                       
                                       
                                       
                                       if clusterID(v) == nodeID(u) then
                                    
                                 
                                 
                                    22
                                       
                                       
                                       
                                       
                                       Exit()
                                 
                                 
                                    23
                                       
                                       
                                       
                                       
                                       else if min_clusterID>clusterID(u) then
                                    
                                 
                                 
                                    24
                                       
                                       
                                       
                                       
                                       min_clusterID=clusterID(u)
                                 
                                 
                                    25
                                       
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    26
                                       
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    27
                                       
                                       
                                       
                                       end if
                                    
                                 
                                 
                                    28
                                       
                                       
                                       end foreach
                                    
                                 
                                 
                                    29
                                       
                                       
                                       if min_clusterID<INT_MAX then
                                    
                                 
                                 
                                    30
                                       
                                       
                                       clusterID(v)=min_clusterID
                                 
                                 
                                    31
                                       
                                       
                                       else
                                    
                                 
                                 
                                    32
                                       
                                       
                                       status(v)=C
                                 
                                 
                                    33
                                       
                                       
                                       clusterID(v)=nodeID(v)
                                 
                                 
                                    34
                                       end if
                                    
                                 
                                 
                                    35 end
                                    
                                 
                              
                           
                        
                     In Algorithm 1, each node’s role should be N(Null node), C(Cluster head) or O(Ordinary node) during constructing the WCDS and eventually each node’s role would be C or O when the WCDS is established. If a node v’s status is N, the node v becomes the cluster head if it has the largest degree and smallest ID compared to its neighboring nodes with status N (Algorithm 1, lines 2–13). The cluster head then broadcasts a CH message to its neighboring nodes (Algorithm 1, line 14) to indicate that it would become a cluster head. When the nodes with a NULL clusterID receive the broadcast message, they would join the cluster (as shown in Algorithm 2). After all of the nodes have joined their own clusters, an ordinary node v may become an additional cluster head if node v finds its clusterID is smaller than neighbor node u’s clusterID (Algorithm 1, line 16–19).

In addition, a LCC strategy is used to maintain the WCDS architecture in the networks to minimize the WCDS maintenance cost (Algorithm 1, line 23). The LCC strategy is shown in Algorithm 3. According to the LCC strategy, the cluster head will change only under the following circumstances:
                        
                           (1)
                           If cluster head v is close to cluster head u, cluster head v would revert to cluster head u’s member if it has smaller degree (Algorithm 3, line 2–12).

If an ordinary node v moves out of range of all clusters, it would become the cluster head of a newly-formed cluster (Algorithm 3, line 30–31).

Secondly, our ant-based algorithm changes its behavior from proactive to reactive without periodically sending ant packets so as to reduce network overhead. Finally, in traditional ant-based protocols, a node generates a Backward_Ant if it contains routing information to the destination node and receives a Forward_Ant. However, in our proposed ant-based scheme, the Forward_Ant would be forwarded until it arrives at the destination node. The destination node is the only one which can generate a Backward_Ant, thus preventing loops and reducing the complexity of routing packets for loop-free control.

In AOCR, when a node requests permission to send data, it first checks the routing table for a route to the destination node. Failure to find such a route triggers the routing discovery process (Fig. 4
                     ). Before sending Forward_Ants, the node determines whether it is a cluster head or a normal cluster member. It then initializes its remaining energy Er
                     , the minimal node remaining energy E
                     min of the nodes in the path taken by the Forward_Ant, the average path energy Ep
                     , and the average network energy EN
                     . These values are carried by the Forward_Ant and are combined to evaluate the network fitness G. All data structures in the Forward_Ant are shown in Fig. 5
                      where SeqNo is generated uniquely by the source node of the Forward_Ant; Src is the source node address and Dest is the target node address.

The Forward_Ants are then appended with the network fitness and sent out to explore the network for a route to the destination node. If the node is a normal member node in the cluster, it just unicasts the Forward_Ant to its cluster head. Otherwise, it broadcasts Forward_Ant to other cluster heads in other clusters.

When a node j receives the Forward_Ant, it evaluates the path fitness 
                        
                           
                              
                                 G
                              
                              
                                 ij
                              
                              
                                 j
                              
                           
                        
                      
                     [22] defined as (1) from the previous node i to the node j.
                        
                           (1)
                           
                              
                                 
                                    G
                                 
                                 
                                    ij
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    G
                                 
                                 
                                    hi
                                 
                                 
                                    i
                                 
                              
                              +
                              
                                 
                                    
                                       
                                          P
                                       
                                       
                                          c
                                       
                                    
                                 
                                 
                                    
                                       
                                          M
                                       
                                       
                                          ij
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 G
                              
                              
                                 hi
                              
                              
                                 i
                              
                           
                        
                      is the path fitness. It is evaluated from the node h to the node i by the previous node i; 
                        
                           
                              
                                 G
                              
                              
                                 ij
                              
                              
                                 j
                              
                           
                        
                      is equal to the sum of 
                        
                           
                              
                                 G
                              
                              
                                 hi
                              
                              
                                 i
                              
                           
                        
                      and 
                        
                           
                              
                                 
                                    
                                       P
                                    
                                    
                                       c
                                    
                                 
                              
                              
                                 
                                    
                                       M
                                    
                                    
                                       ij
                                    
                                 
                              
                           
                        
                      , where Pc
                      is the power for receiving a packet by the current node from the previous node, and Mij
                      is the evaluation of energy consumption from node i to node j. It is determined by (2):
                        
                           (2)
                           
                              
                                 
                                    M
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    E
                                 
                                 
                                    j
                                 
                              
                              ·
                              
                                 
                                    E
                                 
                                 
                                    min
                                 
                                 
                                    j
                                 
                              
                              ·
                              
                                 
                                    
                                       
                                          
                                             
                                                E
                                             
                                             
                                                ‾
                                             
                                          
                                       
                                       
                                          P
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             
                                                E
                                             
                                             
                                                ‾
                                             
                                          
                                       
                                       
                                          N
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                        
                     where Ej
                      is the remaining energy of node j, 
                        
                           
                              
                                 E
                              
                              
                                 min
                              
                              
                                 j
                              
                           
                        
                      is the minimal remaining node energy of the path from the source node to the current node j when the Forward_Ant passes, given as (3);
                        
                           (3)
                           
                              
                                 
                                    E
                                 
                                 
                                    min
                                 
                                 
                                    j
                                 
                              
                              =
                              Min
                              (
                              
                                 
                                    E
                                 
                                 
                                    min
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    E
                                 
                                 
                                    j
                                 
                              
                              )
                           
                        
                     
                  


                     
                        
                           
                              
                                 
                                    
                                       E
                                    
                                    
                                       ‾
                                    
                                 
                              
                              
                                 P
                              
                              
                                 j
                              
                           
                        
                      is the average remaining path energy as formulated by (4);
                        
                           (4)
                           
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          ‾
                                       
                                    
                                 
                                 
                                    P
                                 
                                 
                                    j
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                E
                                             
                                             
                                                ‾
                                             
                                          
                                       
                                       
                                          P
                                       
                                       
                                          i
                                       
                                    
                                    ·
                                    
                                       
                                          H
                                       
                                       
                                          P
                                       
                                       
                                          i
                                       
                                    
                                    +
                                    
                                       
                                          E
                                       
                                       
                                          j
                                       
                                    
                                 
                                 
                                    
                                       
                                          H
                                       
                                       
                                          P
                                       
                                       
                                          j
                                       
                                    
                                 
                              
                           
                        
                     where 
                        
                           
                              
                                 
                                    
                                       E
                                    
                                    
                                       ‾
                                    
                                 
                              
                              
                                 P
                              
                              
                                 j
                              
                           
                        
                      is the average remaining path energy estimated by the node i, 
                        
                           
                              
                                 H
                              
                              
                                 p
                              
                              
                                 i
                              
                           
                        
                      is the current hop count of node i and 
                        
                           
                              
                                 H
                              
                              
                                 p
                              
                              
                                 j
                              
                           
                        
                      is the current hop count of node j.
                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          ‾
                                       
                                    
                                 
                                 
                                    N
                                 
                                 
                                    j
                                 
                              
                              =
                              μ
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          ‾
                                       
                                    
                                 
                                 
                                    N
                                 
                                 
                                    i
                                 
                              
                              +
                              (
                              1
                              -
                              μ
                              )
                              
                                 
                                    
                                       
                                          E
                                       
                                       
                                          ‾
                                       
                                    
                                 
                                 
                                    N
                                 
                                 
                                    j
                                 
                              
                           
                        
                     where μ is the network update factor.

Following the path fitness evaluation, the node will update the pheromone in the pheromone table by (6).
                        
                           (6)
                           
                              
                                 
                                    τ
                                 
                                 
                                    ij
                                 
                              
                              =
                              (
                              1
                              -
                              ρ
                              )
                              
                                 
                                    τ
                                 
                                 
                                    ij
                                 
                              
                              +
                              Δ
                              
                                 
                                    τ
                                 
                                 
                                    ij
                                 
                              
                           
                        
                     where ρ is the pheromone evaporation factor, Δτij
                      is the updating pheromone and is calculated by (7).
                        
                           (7)
                           
                              Δ
                              
                                 
                                    τ
                                 
                                 
                                    ij
                                 
                              
                              =
                              1
                              /
                              
                                 
                                    G
                                 
                                 
                                    ij
                                 
                                 
                                    j
                                 
                              
                           
                        
                     
                  

The process then checks whether the Forward_Ant has arrived at the destination node. If the visited node is the destination node, the node sends a Backward_Ant back to the source node. Otherwise, if the node is a cluster head, it broadcasts the Forward_Ant to its neighboring nodes; if it is a normal node, it unicasts the Forward_Ant to its cluster head. Fig. 6
                      shows the detailed flow for receiving Forward_Ants.

If the destination node receives the Forward_Ant, the Forward_Ant will be killed and the destination will start a pseudo-random-proportional-selection strategy to select the next hop and then send a Backward_Ant back to the source node. This strategy is presented as follows:
                        
                           (8)
                           
                              
                                 
                                    S
                                 
                                 
                                    ij
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          
                                             
                                                arg
                                                
                                                
                                                   
                                                      max
                                                   
                                                   
                                                      j
                                                      
                                                      ∈
                                                      
                                                      
                                                         
                                                            N
                                                         
                                                         
                                                            i
                                                         
                                                      
                                                   
                                                
                                                
                                                {
                                                
                                                   
                                                      τ
                                                   
                                                   
                                                      ij
                                                   
                                                
                                                }
                                             
                                             
                                                if
                                                
                                                
                                                   
                                                      P
                                                   
                                                   
                                                      j
                                                   
                                                
                                                <
                                                
                                                   
                                                      P
                                                   
                                                   
                                                      0
                                                   
                                                
                                             
                                          
                                          
                                             
                                                s
                                             
                                             
                                                otherwise
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     where Pj
                      is a number randomly generated between 0 and 1, P
                     0 is a constant number between 0 and 1, and Ni
                      is the set of node i’s neighboring nodes. By this method, the next hop Sij
                      from node i to node j is selected based on the maximal pheromone trail l among all next hops if Pj
                     
                     <
                     P
                     0. On the contrary, a node s will be chosen as the next hop based on the probability in (9).
                        
                           (9)
                           
                              
                                 
                                    P
                                 
                                 
                                    is
                                 
                              
                              =
                              
                                 
                                    
                                       
                                          τ
                                       
                                       
                                          is
                                       
                                    
                                 
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          
                                          ∈
                                          
                                          
                                             
                                                N
                                             
                                             
                                                i
                                             
                                          
                                       
                                    
                                    
                                       
                                          τ
                                       
                                       
                                          ij
                                       
                                    
                                 
                              
                           
                        
                     
                  


                     Pis
                      is the probability of a next hop s being selected by node i. The selection process is similar to roulette and the size of each zone on this roulette wheel is based on the pheromone value. As such increased pheromone increases the probability the node will be picked as the next hop. Once the next hop is selected, the node will update the routing table and forward a Backward_Ant. Each node receives the Backward_Ant would repeat this path-selection strategy until the Backward_Ant arrives at the source node. When the source node receives the Backward_Ant, it updates the routing table, thus concluding routing discovery, and the source node can start sending data packets to the destination node through the route established by the Backward_Ant. Fig. 7
                      shows the detailed flow of sending and receiving Backward_Ants.

In this subsection, we conduct an analytical comparison to compare the proposed scheme to AODV and AntSense since AODV is a typical protocol and AntSense is a well-known existing ant based routing protocol. Table 2
                         shows the comparison of these schemes.

AOCR not only combines the features of AntSense and AODV, but also is assisted by WCDS to promote the performance of ACO algorithm. By constructing the WCDS structure, AOCR can broadcast routing packets from a cluster-header to other cluster-headers instead of one node to other neighboring nodes. That means the routing discovery of AOCR can be improved. When AOCR constructs the WCDS structure, the maintenance complexity is related to the maximum degree of the input graph (M) since the WCDS with a minimum size is considered. After WCDS is well constructed, the maintenance policy would follow LCC. LCC is an event triggered maintenance policy since it maintains the cluster structure only when the clusters change. Furthermore, the node of LCC might broadcast its cluster status when the cluster changes. Hence, the maintenance complexity of LCC is O(Δn). The maintenance complexity of AOCR is therefore represented by O(InM
                        +Δn).

NS-2 is a popular network simulator mainly used in the studies of routing and protocols. Also, many researchers have used this simulator to verify their ideas many years [23,24]. Besides, the simulator is much cheaper and faster than a real test since an experiment may be expensive in both time and financial costs for building and rebuilding the experiment in every real test [25]. Therefore, this paper exploits simulations to validate the proposed concept using the network simulator NS-2.31 and is separated into two parts. First, we compare and analyze the performance of AODV, AntSense and AOCR in terms of different traffic loads. Second, we try to observe the performance of AOCR in terms of different pheromone evaporation rates. In our experiment results, the network topology produces 18 cluster heads, and the distance between each other is about 166m since we evenly distribute nodes in the network and select the diagonal nodes as the source and destination nodes in the network. A different topology architecture will have different results because nodes’ degrees and positions will result in a different WCDS by the WCDS construction algorithm. The setting of our network environment is described in more details in the following section.

The quality of network service is measured using the following metrics:
                              
                                 (1)
                                 Packet delivery ratio: the ratio of the number of data packets received by the destination node to the number of data packets sent by source node.

Network goodput: the rate of the data bits received by the destination node.

Average end to end delay: the average time required to send data packets from the source node to the destination node.

Residual energy ratio: a key metric for designing an energy-aware protocol, this is the ratio of total network energy remaining after the simulation to the total energy before the simulation.

Network overhead: the volume of control bits received by all nodes per second during algorithm execution.

To validate the effectiveness of the proposed scheme, we compare the performances of the existing AODV and AntSense schemes against our proposed AOCR scheme according to the settings in Table 3
                           . The settings are set up for comparing the performance of the three algorithms. In our simulation, the environment is built by distributing nodes (positioned uniformly at 200m apart from each other) in a 1000m×1000m grid area. The data traffic is generated in a Constant Bit Rate (CBR) mode and the User Datagram Protocol (UDP) transport layer protocol is used in the Internet Protocol (IP) network layer. The protocol used for Data Link layer and MAC sub-layer is the IEEE 802.11 standard. The transmission range of each node is 250m and the TwoRayGround model is used for propagation. Two key parameters in our protocol algorithm are μ
                           =0.7 and ρ
                           =0.2. The traffic loads in the simulations ranged from 10 to 30packets/s. Each simulation is conducted five times, and the average values are taken. In each simulation, CBR traffic wait at least 40s before starting to give AOCR and AntSense enough time to setup the environment. The durations of CBR traffic for these three schemes are all identical.


                           Fig. 8
                            shows the simulation results for packet delivery ratio (PDR). As the traffic load increases the PDR decreases. The results show the PDRs for AOCR and AntSense are similar, but both are lower than that for AODV. Nevertheless, as shown in Fig. 9
                           , AOCR has a higher network goodput than the other two protocols when traffic load increases. This is because the clustering concept of AOCR could find a route to the destination node quickly and most of data packets could be transmitted in a shorter time even though the traffic load becomes heavier. Meanwhile, AODV and AntSense may need longer time to find a path to the destination node by flooding and sending ants without clustering architecture. These facts may lower the network efficiency when the traffic load increases. Furthermore, AntSense performs worst due to the increased collision probability of transmitted packets and periodic delivery of ant packets.


                           Fig. 10
                            showes that the average end to end delay increases as the traffic load increases. For AntSense in particular, the large number of proactively and periodically generated ant packets imposes a significant delay on the network. AODV and AOCR, on the other hand, have lower average end to end delays since there are no proactively generated packets attempting to discover routes in the network. Instead, the on-demand nature of these protocols reduce the likelihood of generating a huge number of packets. Fig. 10 also shows that AOCR outperforms AODV since the AOCR cluster algorithm results in a comparatively low delay.


                           Fig. 11
                            the respective network costs incurred by each protocol to execute its algorithm. The costs of all three protocols increase with traffic loading. AntSense incurs the greatest cost for routing discovery and maintenance due to the large number of ant packets generated, while AOCR and AODV require much lower costs because they are on-demand protocols. Furthermore, because AOCR needs to maintain clusters, it incurs a slightly higher cost than AODV. However, as traffic load increases, the overhead of AODV approaches that of AOCR due to the increased frequency of packet retransmission in AODV.


                           Fig. 12
                            shows the remaining energy in the network following the simulation. Increased traffic load results in an increasingly noticeable decrease in remaining energy. In this simulation scenario, we give one traffic load for each routing scheme to analyze the energy consumption of these schemes when there is one data stream in the network. Otherwise, the energy consumption analysis of these schemes is meaningless because AODV never consumes energy if no data stream exists due to AODV’s on-demand characteristic. From the simulation result, we can know that both AntSense and AOCR are energy-aware ant algorithms and thus discover routes according to the energy information presented by each node in the network. However, AntSense continues to consume energy to send ant packets even if no nodes had requested data. AOCR and AODV, on the other hand, are on-demand algorithms and thus do not consume energy except when responding to a data request. Therefore, AntSense has the least remaining energy also and the largest decline ratio due to its need to continually transmit ant packets. Meanwhile, AOCR has the smallest decline ratio because AOCR takes network status in consideration while searching for routes on demand. Nevertheless, when the traffic load is light, the remaining energy of AOCR is slightly lower than the one of AODV. Hence, we can know AOCR has the better performance when the traffic load is heavy because the cost of WCDS construction in AOCR is too much compared to AODV without WCDS construction in a light traffic load scenario.

The pheromone evaporation rate might affect the path selection. A lower pheromone evaporation rate may make the ants choose one path from more ones since the pheromone flavors resided on the path becomes longer. The convergence time of finding the optimal path therefore becomes longer and may result in poor performance. On the other hand, a higher pheromone evaporation rate may result in a quicker path breakdown so that route re-discovery and packet retransmission frequently happen. This phenomenon may result in poor network performance. We try to find how the pheromone evaporation rate would affect the performance of the proposed AOCR. In the evaluation, we set the traffic load as 30packets/s and change the pheromone evaporation rate from 0.1 to 0.7.

In Figs. 13
                           
                           and 14
                           , we can observe that 0.2 and 0.3 pheromone evaporation rates can achieve better performance in the PDR and goodput compared to other evaporation rates and the performance declines as the pheromone evaporation rate increases. However, when the pheromone evaporation rate becomes too low, like 0.1, several paths between the source node and the destination node are possibly established so that each ant then has multiple path choices. Hence, a large volume of packets are transmitted on the selected paths so that the network congestion may happen and finally result in poor performance.

In Fig. 15
                           , we can find that a 0.2 pheromone evaporation rate can achieve the least end to end delay, and the delay time increases as the pheromone evaporation rate increases because of the vulnerable connection between the source node and the destination node. However, when the pheromone evaporation rate becomes too low, like 0.1, there may exist multiple paths between the source node and the destination node. The network congestion may happen and therefore result in a longer end to end delay.


                           Fig. 16
                            shows the network residual energy in terms of different pheromone evaporation rates. From the result, we could realize the evaporation does not affect the residual energy too much for AOCR. However, since a higher evaporation rate (like 0.5 to 0.7) may cause a reduced PDR and the decreased number of the transmitted packets, more energy therefore is conserved.

@&#CONCLUSION@&#

We use a WCDS-assisted ACO mechanism to propose a novel protocol, called AOCR. AOCR can find more efficient routes in wireless ad-hoc networks, since AOCR uses a pre-established WCDS architecture to quickly spread ant packets to find routes to the destination. Compared with other ant-based routing protocols, the proposed algorithm requires considerably less storage and fewer network transmission resources to perform an intelligent route search. The network’s average remaining energy, the path’s average remaining energy and the path’s minimum node remaining energy are jointly used to evaluate the strength of the pheromone carried by ants in the intelligent swarm algorithm. Stronger pheromone levels indicate that a path has better energy quality and its pheromone can be intensified by deposition, while weaker pheromone levels indicate reduced energy quality and this pheromone will be reduced by evaporation. The algorithm follows the pseudo-random-proportional-selection policy to selects the most efficient route. Thus, the energy status of each node can be considered and the energy consumption among nodes can be balanced by the routing protocol. Moreover, the number of ant packets can be decreased since the WCDS structure can facilitate the efficient issuing of such probe packets to find a routing path. In addition, only the destination node can generate Backward_Ants to prevent routing loops.

To validate the network efficiency conducted by our proposed WCDS assisted AOCR scheme, we compared our scheme to some other typical schemes, such as AntSense and AODV. Compared with AntSense, we can find our scheme can perform better. Compared with AODV, AOCR can achieve better results in a heavy traffic network since the clustering scheme can speed up the packet delivery and the ant based swarm intelligence method can facilitate to select an optimal path. Especially, our routing protocol is quite suitable for a dense network, where network nodes are highly connected.

@&#REFERENCES@&#

