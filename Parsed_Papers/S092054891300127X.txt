@&#MAIN-TITLE@&#Deriving guidelines for cross-vendor reuse of IEC 61131-3 modules based on Normalized Systems theorems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We illustrate that designing cross-vendor reusable modules in automation systems is hard.


                        
                        
                           
                           Some theoretical foundations on how to design reusable modules are given.


                        
                        
                           
                           Five dependency problems in IEC 61131--‐3 projects are illustrated.


                        
                        
                           
                           Three rules are proposed in order to avoid these dependencies.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Normalized Systems

Modularity

IEC 61131-3

Black box

@&#ABSTRACT@&#


               
               
                  Flexibility, maintainability and evolvability are very desirable properties for modern automation control systems. In order to achieve these characteristics, modularity is regarded as an important concept in several scientific domains. The reuse of modules facilitates the reproduction of functionality, or extensions of existing systems in similar environments. However, it is often necessary to ‘prepare’ such an environment to be able to reuse the intended programmed functionality. In an IEC 61131-3 environment, cross-vendor reuse of modules is problematic due to dependencies in proprietary programming environments and existing configurations. In this paper, we aim to enable cross-vendor reuse of modules by controlling these dependencies. Our approach is based on the Normalized Systems Theory, from which we derived three guidelines for the design of reusable modules in an IEC 61131-3 environment for automation control projects. These guidelines are intended to support programmers in controlling dependencies, regardless of the commercial programming environment they work with.
               
            

@&#INTRODUCTION@&#

In several scientific domains, the structure of extensive and complex systems is regarded as a composition of a large amount of small modular building blocks. For instance, biological systems are typically based on the accumulation of very small cellular structures. This structure allows the system to easily grow or adapt itself to its ever changing environment. Analogously, in computer hardware design, the use of compatible and interchangeable modular components (e.g., screen, main board) was considered to be of major importance for the ability of the computer industry to innovate or, for specific companies, to obtain a significant market share [1]. Hence, a high degree of modular granularity is often associated with the properties of evolvability and maintainability as the fine-grained building blocks can be substituted, aggregated, and again combined to higher level aggregations. In hardware engineering, these levels of aggregations resulted in, for instance, microchips.

One of the remarkable advantages of a microchip design is the fact that each time a chip needs some functionality of another chip, this is obtained via the interface of the microchip, i.e., through one of its pins. However, documentation is crucial. The core functionality of the chip and its interface (including the size, format of the microchip holder, voltage ranges and current consumption) has to be known by the user to enable the use of the chip, without the need to manually investigate the internal working of the chip. Hence, the documentation should include an accurate interface documentation, describing the interactions of the chip ‘module’ with its environment. Consequently, if this documentation is available, a microchip can be considered a black box (i.e., a module which can be used without any additional knowledge of its internal construction) without hidden dependencies, meaning that no other aspects than those described in the documentation are needed to (re)use the chip as a module.

This relates to the IEEE definition of software flexibility: “the ease with which a system or component can be modified for use in applications or environments other than those for which it was specifically designed” [2]. However, documenting dependencies -which is certainly an improvement with regard to hidden dependencies- does not guarantee that they can be easily dealt with. Especially when these dependencies (despite being documented) are vendor-specific, it might be not easy to control these dependencies. Therefore, we will try to make a contribution regarding this challenge.

In this paper, we present an explorative attempt towards partly achieving module flexibility in an IEC 61131-3 environment [3]. More specifically, our approach will focus on controlling dependencies and interactions between subroutines (i.e., the so-called Program Organization Units (POU)) based on Normalized Systems Theory and earlier insights on modularity. Normalized Systems Theory (NST) focuses on obtaining evolvable and flexible modular structures, based on a set of unambiguous and proven theorems [4]. The theory initially concentrated on software architectures for business-related applications, but its applicability to other domains such as industrial controllers and business processes has been illustrated as well [5–7].

Our final goal is to formulate a set of practical guidelines for designing IEC 61131-3 POUs which can be reused in several projects in a black box way, based on the theorems of Normalized Systems Theory. Improving the programming style by adding restrictions was already suggested in older languages [8], however, as control engineers are no computer scientists, some authors suggest that they are not thoroughly aware of software engineering methodologies ([9], p. 462). In this paper, we perform an explorative attempt to define guidelines for the user of an IEC 61131-3 environment to increase cross-vendor reusability.

The rest of this paper is structured as follows. In Section 2, the IEC 61131-3 standard is briefly introduced. Next, we will highlight some theoretical foundations, i.e., insights from both Normalized Systems Theory and its extension to general modularity reasoning in Section 3. In Section 4, our guidelines towards obtaining cross-vendor reusable modules in IEC 61131-3 will be formulated and elaborated upon. Finally, we present our conclusions in Section 5.

Industrial Programmable Logic Controllers (PLCs) were introduced in the late 1960s as an electronic replacement for hard-wired relay systems for the implementation of automation control logic. PLCs are usually programmed in one of the languages of the IEC 61131-3 standard [3]. Two of these languages are text-based: Instruction List (IL), similar to assembly; and Structured Text (ST), similar to a higher level programming language. Two other languages are graphic: Ladder Diagram (LD), similar to an electrical drawing; and Function Block Diagram (FBD), where the modules are graphically represented and the interfaces are connected with several lines. It should be noted that the standard also provides a fifth language, Sequential Function Chart (SFC), for specifying sequential control functions.

A module in IEC 61131-3 is called a Program Organization Unit (POU), which contains code in any of the available languages. A POU can be a Program, a Function, or Function Block. A Program is automatically called by the PLC system (specified in the Task Configuration). A Function has several input parameters, one return value, additional output and in_out parameters, has no memory, can store no state, and can be called by a Program or a Function Block. A Function Block has several input and output parameters, and can store a state by using an instance variable. Every module (POU) has a declaration part (containing variable declarations) and a part containing the functionality. When a module calls Function Blocks, the corresponding instance variables have to be declared in the declaration part.

It is remarkable that in IEC 61131-3, one can write a single application using several distinct programming languages simultaneously, sharing the same structural model, as long as each POU uses a single programming language [10].

The standard includes a syntax for directly represented variables, which is used to address hardware I/O. However, linking these hardware I/O addresses to physical hardware is outside the scope of the standard. The compiled IEC 61131-3 code is linked with physical hardware on a PLC vendor-dependent way. In other words, IEC 61131-3 provides means to standardize source code, but the development environment, compiler and PLC run-time environment are proprietary. In addition, both source and compiled code are typically stored in a vendor-dependent file format.

The so-called Configuration of an IEC 61131-3 project includes the declaration of global variables and program selection (each task defines the automatic calling of a Program). In addition, Derived Data Types (user- or manufacturer defined) can be declared, and library selections can be typically made for the scope of the entire IEC 61131-3 project. These libraries include common functionality in the form of standard Functions and Function Blocks. Standard library functionality may be overloaded (implementation dependent), corresponding to the specifications of the standard. As a result, the proprietary development environments might differ in the available versions of standard Functions and Function Blocks.

The IEC 61131-3 standard is widely used, but sometimes in a slightly different way. Different interpretations are indeed possible. In this respect, Mario de Sousa [11] and Plaza et al. [12] described some ambiguities.

In this section we will briefly discuss some theoretical foundations upon which the guidelines, formulated in Section 4, are based. First, we will discuss the Normalized Systems Theory. Next, we will discuss some more general aspects regarding modularity.

Updating systems or adding functionality to a software program has the tendency to cause a deterioration of the software structure. Already back in 1980, Lehman stated the law of increasing complexity [14] which expresses this phenomenon:
                           “As an evolving program is continually changed, its complexity, reflecting deteriorating structure, increases unless work is done to maintain or reduce it.”
                        
                     

The deterioration of the structure is often reduced by rewriting the software system several times throughout its lifecycle (see Fig. 1
                        
                        ). However, building software systems which are immune against Lehman's Law would be better. To enable this, the theory of Normalized Systems [4] has been developed. The NST authors state that currently, sufficient knowledge is available to design such evolvable systems. However, this knowledge mainly takes the form of expert developers' individual experience, also known as tacit knowledge. Reformulating this knowledge in a theoretically based way, and making it explicit facilitates implementation and collaboration [15], and increases the chance that implementations become actual manifestations of the knowledge about evolvable software development.

Software modules can be dedicated to contain data tags (Data Entities) or functionality (Action Entities). A task is an atomic piece of functionality, from which no internal parts evolve independently. To achieve the property of evolvability, NST states that modular structures should strictly adhere to the following four theorems [4,16]:
                              
                                 1.
                                 Separation of Concerns: An Action Entity can only contain a single task.

If two or more parts (called ‘change drivers’) of the core functionality of a module can change independently, they must be separated. Consequently, each module shall be dedicated to one core task.

Data Version Transparency: Data Entities that are received as input or produced as output by Action Entities need to exhibit Version Transparency.

A new version of a set of arguments passed between modules should be able to be introduced, or multiple versions must be able to co-exist without affecting any other module (version).

Action Version Transparency: Action Entities that are called by other Action Entities need to exhibit Version Transparency.

A module A must be able to call another module B, while new versions of A and B should be able to be introduced or co-exist. The introduction of a new version should not require changes to any other module (version).

Separation of States: The calling of an Action Entity by another Action Entity needs to exhibit State Keeping.

Every module needs to keep track of its requests to other modules by state keeping. If results are not returned as expected, the exceptional situation must be handled based on this state.

An important facilitator in order to build powerful and complex systems, is the systematic application of the concept of modularity: the decomposition of a system into a set of collaborating subsystems. In this section we will elaborate on two key aspects of modularity. First, we will discuss the need to discern both a black box and a white box view on modules. Next, we will highlight the different types of possible interaction (coupling) between modules in order to be able to cooperate.

When analyzing modular systems, two different design perspectives can generally be applied (see e.g., [5]). First, a functional or black box perspective can be employed. In this view, it is mainly described what a module does (i.e., what its function is) in terms of its input variables, transfer function and output variables (i.e., its interface). In this perspective, the user does not need to know any details about the internal working of the module: only the interaction with its environment is described.

Second, the constructional or white box perspective describes the constituent subsystems of which a system consists, as well as the way in which these subsystems collaborate in order to bring forth the function as described in the black box perspective. As such, the realization of a set of functional requirements by using a set of modules can be regarded as a transformation from the functional perspective to the constructional perspective [4].

However, in order to be able to perform this functional/constructional transformation in an efficient way, the black box (sub) modules should be fully reliable to use, by which we mean that every dependency of the module has to be clearly articulated.

In earlier work, we focused on the evaluation of several kinds of coupling [5], as categorized by Myers [17]:
                              
                                 1.
                                 
                                    Common coupling: Common coupling occurs when modules communicate using global variables, without using their interfaces (arguments) for this. Consequently, these modules are not well separated. In terms of Normalized Systems, common coupling is a violation of the first theorem, ‘Separation of Concerns’.


                                    Data coupling: Data coupling occurs when two modules pass data using simple data types (no data structures), and every parameter is used in both modules. An update of the set of arguments (including possible new data types) requires the technical implementation of the interface to be flexible, in order to keep module calls of earlier versions valid. Consequently, it is not always straightforward to maintain version transparency with data coupling.


                                    Stamp coupling: Stamp coupling occurs when two modules pass data using a data structure as an argument, and both modules do not necessarily require all the fields in the data structure. Removing a used field of the data structure, or changing the used data type or name of a field causes similar problems as those regarding data coupling. However, if changes are restricted to additions of fields only, stamp coupling is an acceptable form of coupling.


                                    Control coupling: Control coupling occurs when module A influences the execution of module B by passing data (parameters). Commonly, such parameters are called flags. If flags would differentiate between several core functionalities in one module, this implies a violation of the ‘Separation of Concerns’ theorem (control coupling itself is not violating this theorem, but combining more than one core task in one module is not allowed). Hence, control coupling should be used for version selection only.

The IEC 61131-3 standard was developed with the aim of creating a set of common PLC programming languages [3]. Adopting the standard, several PLC vendors made their proper IEC 61131-3 programming environment. In accordance with the initial intent of the IEC 61131-3 standard authors, the definition of such common languages for different PLC hardware and its subsequent adoption by multiple vendors, would most likely cause an increase of the portability and reusability of the programmed software applications. These non-functional requirements are considered important [18]. However, obtaining fully reliable reusable software modules based on IEC 61131-3 seems to remain a challenging issue in practice, partly due to (hidden) dependencies.

In this section we will first highlight some of the typical dependencies, which might arise during programming efforts and prevent an engineer from obtaining a reusable module in IEC 61131-3. Next, we will propose a set of guidelines in order to avoid some of these dependencies, based on the theoretical background discussed in Section 3.

When analyzing feedback of IEC 61131-3 practitioners regarding potential dependencies, several issues seem to arise. Without claiming to be exhaustive, we would like to illustrate at least the following elements:
                           
                              1.
                              
                                 Hardware addresses: The IEC 61131-3 standard includes a syntax for process I/O (Inputs and Outputs) hardware addresses. Also, explicit memory addresses can be used. The use of explicit memory addresses or hardware IO addresses implies a dependency of the module with the global address space of the PLC. When a module, which refers to its original address space, is reused in another address space, the addresses become meaningless. In other words, the hidden dependency here is the address space.


                                 Library configurations: A library in IEC 61131-3 is considered an implementation or vendor-dependent resource [3]. Therefore, libraries are not exchangeable between different programming environments. When a data type or functionality, included in a library, is used in a module or POU, this module becomes dependent on that library (and hence, programming environment).


                                 CPU dependencies: Some library modules provided by a particular vendor can only be used for a specific set of CPUs of this vendor. Consequently, modules which use this kind of system functionality, can only be reused when downloaded into the same kind of CPUs, or even the same specific CPU type. For the user, the set of valid CPU types is a (hidden) dependency.


                                 Common file format: Typically each vendor defines its own file format to save the code and configuration data of a PLC project. In theory, it is possible to transfer code based on import/export file formats. However, in practice, cross-vendor common file formats are rarely implemented in commercially available PLC programming environments. From the perspective of both end users and system integrators, library functionality (provided by a vendor) of one brand does not end up to be available in the library of another brand, because the file format is not portable and the source code is typically protected. Consequently, the file format is a dependency, related to the dependency of library configurations.


                                 Name conflicts: Apart from a predefined limited set of reserved IEC 61131-3 keywords, names of data types, Functions, Function Blocks or other constructs can be freely chosen by the developer. Consequently, name conflicts might show up. When two or more developers provide modules, calling other modules on submodular level which coincidentally have the same names, these name conflicts hampers the use of functionality on modular level. Therefore, the conceptual flat or global name space is similar to common coupling and can be considered a dependency.

When an intended black box module calls internally another module, which has the same name as an existing module (with another functionality) within the same deployment environment, a problematic hidden dependency shows up. Also, when this module requires the configuration of an additional library, which on its turn has a name clashing problem with an existing library module, we have again a manifestation of the dependency of existing module names.

Based on our previous discussion, we will now propose a set of guidelines to mitigate the above mentioned dependencies. Consequently, our efforts can be seen as an attempt towards obtaining more deterministic cross-vendor reuse of IEC 61131-3 modules. For each of the guidelines, we will provide a definition, reference to its theoretical basis and illustration.

In IEC 61131-3, vendor specific data types or functionality (so-called ‘dependent code’) should be separated from vendor independent code (so-called ‘generic code’) by means of Connection Entities. A Connection Entity is basically an Action Entity doing the service of a ‘connector’.

This guideline is derived from the NST ‘Separation of Concerns’ theorem. Generic code has a high reuse potential, containing core functionality which is independent of vendor or individual application specific details. We call brand specific functionality with low or no cross-vendor reuse potential dependent code. As both the generic and dependent code can clearly evolve independently, both should be considered as separate concerns according to NST.

The idea behind this guideline is to distinguish constructs (i.e., data types or POUs) which can be reused in any programming environment, brand or (hardware) address space, from constructs which are dedicated for one brand, a (set of) CPU(s), or even an individual application.

Consider for example a module containing the functionality of a proportional-integral-derivative (PID) controller. Typically, every PLC vendor provides its own PID controller module in one of its libraries. When a module calls internally such a vendor-dependent module, it can not be reused in another environment. However, when we apply the guideline of separating generic and dependent code, the generic part of the algorithm can be reused (Fig. 2
                              
                              ). In such a case, a structure of five modules arises (for the case of two brands). First, we have one single generic module, which calls Connection Entities, depending on the brand. Each Connection Entity —a total of two Connection Entities in the considered situation— calls a vendor-dependent PID controller module of the respective brand. Both the PID controller and Connection Entity are vendor-dependent, so we have duplicates in terms of functionality in both environments. The interface between the generic module and the generic side of each Connection Entity should be identical.

To summarize, the generic module can be cross-vendor reused, the PID controller modules can be reused within one brand (which is commonly applied), and the Connection Entities are application-specific (which is uncommon, but developing Connection Entities is a core suggestion of this paper). Following Fig. 2
                              , the generic code is coupled with the Connection Entity by way of stamp coupling, to allow the generic module to evolve. Since we do not anticipate to reuse an individual Connection Entity and its corresponding dependent module, the dependent side of this connection can be based on data coupling, common coupling or whatever is convenient according to accessing the dependent code. In the application, the decision to which Connection Entity the generic module has to be linked, is based on control coupling.

This guideline can also be used to deal with CPU dependencies. In this case, the appropriate Connection Entity should be selected with regard to the corresponding CPU type of the PLC instance.

In addition to collaborating POUs, Derived Data Types (i.e., user- or manufacturer-specified) can also cause hidden couplings, because Derived Data Types are declared in a library or in a project-wide resource. Hardware addresses are a global resource as well. In other words, Connection Entities should not only pass parameters, they should also map or convert data from vendor-dependent data types to generic data types and vice versa if necessary (Fig. 2). The Connection Entities themselves contain vendor-dependent data types to be able to map them to generic ones, so they contain a part of ‘dependent code’, possibly including the hardware addresses of the process IO of the PLC. The side or interface which connects to generic code can evolve and be reused in a generic way.

Consider again the example of the PID functionality. In theory, it is possible to make this functionality not only brand-wide, but also cross-vendor reusable. To achieve this, the implementation of this kind of algorithms should become cross-vendor portable. In order to improve portability, the PLCopen organization developed the ‘XML Formats for IEC 61131-3’ [19], but this file format is not widely used up to this point. Consequently, the technical portability of modules between the proprietary development environments is challenging.

With our proposed guideline, we recommend to restrict the use of variables, assigned to hardware addresses, in Connection Entity modules only. Hence, every PLC programmer should follow this guideline to isolate hardware related dependencies. Consequently, a hardware change can be made by merely introducing a new Connection Entity and programming the appropriate selection, based on a version ID.

In IEC 61131-3, all Functions, Function Blocks and Derived Data Types (i.e., user defined) which are used inside a POU, should be described in the POU's documentation, including their version, the library to which they might belong, and the version of this library.

This guideline is derived from the fact that the analysis of modular structures based on NST assumes the specification of black box modules (i.e., exhibiting a complete and exhaustive documentation) to realize functional requirements. In case not all external aspects on which the module depends are listed, no guarantee can be offered that all the necessary conditions are fulfilled to successfully deploy the module.

One could assume that a reusable module contains definitions and code of all necessary data types and submodules to perform the required actions on the inputs and its current states towards the desired outputs and new states. However, definitions of local submodules, as in some other (high-level) languages, are not permitted in IEC 61131-3 [20]. Coupling with an external module can be done via the interface, or on a hidden way (Fig. 3
                              
                              ). In both cases, the concerning coupled modules must be available. In case the coupling is clearly indicated, the programmer is informed that an availability check of the external module is useful. In case the coupling is implicit or hidden, an exhaustive study of the documentation is crucial for the programmer. If this documentation is missing or incomplete, even white box inspection of the module is needed to enable reusability.

The documentation should include the library in which the concerning constructs are possibly hosted. As such, a PLC programmer has some information about the potential need to include a new library (version) in the environment setup.

We do not have any control over the programming structure or quality of libraries or, more general, external technologies. By applying our first guideline, it should be possible to isolate these dependencies. However, to be able to isolate them, the programmer has to recognize them in a first stage. In other words, the guideline ‘explicitation of modular dependencies’ enables the programmer to categorize generic and dependent code.

In IEC 61131-3, a module, variable or Derived Data Type name should include the name of the library or project, accompanied with the version ID of the hosting library or project, to avoid naming and version conflicts.

This guideline is derived from the NST theorems ‘Data Version Transparency’ and ‘Action Version Transparency’. A new version of an action or data entity should not have an impact on existing data or action entities in the same or other environments. Hence, for multiple versions of action or data entities to co-exist in an IEC 611331-3 environment, a module, variable or derived data type name should include the name of the hosting entity, i.e., the library or project, accompanied with the version ID of this hosting entity to avoid naming and version conflicts.

Typically the names of updated modules included in a library do not differ with earlier versions of the same modules. Therefore, we suggest that names of a module, variable or Derived Data Type should include the name of the library, accompanied with the version ID of the library. As a result, two or more versions of a library could co-exist in the same programming environment. As such, developers do not only specify in a module's documentation which entities are used in the module, but also of which versions these entities are. This way, problems because of an imperfection in the version transparency of a library can be avoided. To design a system which manages name spaces, existing concepts could be used as a reference (e.g., some possible similarities with the DNS (Domain Name System) concept are conceivable) (Fig. 4
                              
                              ). Note that in a recent update (February 2013) of the IEC 61131-3 standard, so-called namespaces can be defined [21]. Most likely these namespaces would facilitate the implementation of our guideline. However, it is expected that it will last a while before commercial products will include the new features of this third edition. Meanwhile, practitioners can maintain the names of their entities manually by systematically including the hosting project or library (version) as a prefix of the intended module name in the project. Further, such a systematical approach might be automated or semi-automated, possibly combined with the new name space concept of IEC 61131-3 edition 3.

@&#CONCLUSION@&#

This paper focused on some important causes why properties like evolvability and (re)usability are hard to achieve in automation control projects. Nevertheless, we are convinced that the required theoretical knowledge for obtaining this desired goal is already largely available. However, making the existing theoretical knowledge and experience-based guidelines explicit for some specific application domains seems to be challenging. In this contribution, we addressed some typical dependency problems in the context of IEC 61131-3 based automation software, for engineers trying to reuse and port modules to other projects or cross-vendor environments. Experienced engineers might (tacitly) recognize these problems, and are often able to find a ‘work-around’ to achieve customized solutions for an individual project. Unfortunately, these ‘work-arounds’ tend to become more and more problematic as the size of software applications grows.

Aiming to formulate a set of practical guidelines to obtain more flexible software in an IEC 61131-3 environment, we first gave an overview of some useful theoretical foundations. Based on these concepts, we derived a set of guidelines for designing a reusable IEC 61131-3 modular design. In addition, we gave explicit attention to the need for accurate version management of these modules, in order to achieve evolvable automation systems in which different versions of modules and libraries can co-exist. Because of this potential co-existence of versions, downwards compatibility becomes straightforward. In future research, we might perform a set of case studies in order to empirically validate the feasibility and effectiveness of our proposed set of guidelines.

@&#ACKNOWLEDGMENT@&#

Peter De Bruyn is supported by a Research Grant of the Agency for Innovation by Science and Technology in Flanders (IWT).

@&#REFERENCES@&#

