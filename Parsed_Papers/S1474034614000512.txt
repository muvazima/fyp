@&#MAIN-TITLE@&#Disassembly sequence planning using a Simplified Teaching–Learning-Based Optimization algorithm

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We studied two kinds of disassembly sequence planning problems.


                        
                        
                           
                           A Simplified Teaching–Learning-Based Optimization algorithm for these problems is proposed.


                        
                        
                           
                           Three new operators are designed: feasible solution generator, teaching phase operator and learning phase operator.


                        
                        
                           
                           All the algorithm parameters except population size and iteration times are self-adapted and need not to be tuned.


                        
                        
                           
                           The good performance of the proposed algorithm is proved by experimental studies and benchmark test.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Disassembly

Disassembly sequence planning

Meta-heuristics

Teaching–Learning-Based Optimization

Simplified Teaching–Learning-Based Optimization

@&#ABSTRACT@&#


               
               
                  Disassembly Sequence Planning (DSP) is a challenging NP-hard combinatorial optimization problem. As a new and promising population-based evolutional algorithm, the Teaching–Learning-Based Optimization (TLBO) algorithm has been successfully applied to various research problems. However, TLBO is not capable or effective in DSP optimization problems with discrete solution spaces and complex disassembly precedence constraints. This paper presents a Simplified Teaching–Learning-Based Optimization (STLBO) algorithm for solving DSP problems effectively. The STLBO algorithm inherits the main idea of the teaching–learning-based evolutionary mechanism from the TLBO algorithm, while the realization method for the evolutionary mechanism and the adaptation methods for the algorithm parameters are different. Three new operators are developed and incorporated in the STLBO algorithm to ensure its applicability to DSP problems with complex disassembly precedence constraints: i.e., a Feasible Solution Generator (FSG) used to generate a feasible disassembly sequence, a Teaching Phase Operator (TPO) and a Learning Phase Operator (LPO) used to learn and evolve the solutions towards better ones by applying the method of precedence preservation crossover operation. Numerical experiments with case studies on waste product disassembly planning have been carried out to demonstrate the effectiveness of the designed operators and the results exhibited that the developed algorithm performs better than other relevant algorithms under a set of public benchmarks.
               
            

Ant Colony Optimization

Average Running Time

Bill of Materials

Disassembly Sequence Planning

Feasible Solution Generator

Genetic Algorithm

Greedy Randomized Adaptive Search Procedure

Learning Phase Operator

Particle Swarm Optimization

Rate of Best

Simplified Swarm Optimization

Standard Deviation

Simplified Teaching-Leaning-Based Optimization

Teaching-Leaning-Based Optimization

Teaching Phase Operator

@&#INTRODUCTION@&#

Mass-customized productions, technology updating and shortening lifespan of products in modern societies have resulted in generation of enormous amount of waste products like Waste Electrical and Electronic Equipment (WEEE). Developing technical solutions for sustainable recovery of waste products becomes a global trend. End-of-life recovery options include part reuse, remanufacturing, material recycling, energy recovery and disposal. As shown in Fig. 1
                     , disassembly, which is a systematic method for separating a product into its constituent components and subassemblies [1], is a critical stage for end-of-life recovery. Finding an optimum or near optimum disassembly sequence is crucial to increasing the efficiency of the disassembly process.

Disassembly Sequence Planning (DSP) determines the order in which components are removed from products aiming at minimizing the disassembly time or cost, while considering the disassembly direction, disassembly method, and other attributes of components. DSP has been proved as a NP-hard problem [2] and has been becoming an important but still a challenging research topic in recent years. In the previous research, heuristics and meta-heuristics were used to find near optimum or optimum solutions and generate cost-effective and feasible disassembly sequences. Heuristics include rule-based recursive method [3], graph-based heuristic approach [4], etc. Meta-heuristics, which have been widely applied for solving such problems as well, include Genetic Algorithm (GA) [5–11], Particle Swarm Optimization (PSO) [12–17], Ant Colony Optimization (ACO) [18–20], Greedy Randomized Adaptive Search Procedure (GRASP) [21–23], etc. However, the controlling parameters in the above meta-heuristics need to be tuned, such as crossover rate and mutation probability in GA, inertia weight and two acceleration constants in PSO, two weights for path selection and evaporation rate in ACO, and window size in GRASP, etc. This characteristic makes the above meta-heuristics not adaptive and robust enough for various situations.

A new population-based evolutional algorithm named Teaching–Learning-Based Optimization (TLBO) algorithm, which was originally introduced by Rao, et al. in 2012 [24,25], has been successfully applied to continuous non-linear large scale problems [26,27] including mechanical design optimization [25], parameter optimization of machining processes [28–30], high dimensional real parameter optimization [31], economic emission load dispatch [32], etc. Unlike the above optimization techniques, the TLBO algorithm does not require any algorithm parameters (except population size and iteration times) to be tuned and outperforms some of the well-known meta-heuristics regarding constrained benchmark functions, constrained mechanical design, and continuous non-linear numerical optimization problems [24].

However, the TLBO algorithm is not suitable for solving the DSP problems directly as it was designed for continuous optimization problems while the DSP problems are discrete combinatorial optimization problems with complex disassembly precedence constraints. In continuous problems, a solution is a vector of design variables, each of which belongs to a continuous rang. Sequencing the components in a product for disassembly planning is a typical DSP problem. In this problem, a solution can be represented as a permutation of integers, which are the serial numbers of components in a product. For this DSP problem, the solution space is not continuous and TLBO is unable to be applied directly. Meanwhile, a directly discretized TLBO algorithm could not be a good choice for the above DSP problem either. In a DSP problem, the search space for an optimal solution is growing exponentially according to the number of components in the product, while the disassembly constraints could be complex. These characteristics cause that there are few feasible solutions in the population by using a random solution generation method embedded in TLBO. Furthermore, disassembly precedence constraints cannot be preserved simply using an arithmetic operation method during the evolutions towards optimization, which leads to few feasible solutions in the offspring. Hence, the directly discretized TLBO algorithm can hardly converge and solve the DSP problem effectively.

In order to solve the DSP problems more efficiently, this paper proposes a new optimization algorithm named Simplified Teaching–Learning-Based Optimization (STLBO) algorithm. The STLBO algorithm inherits the main idea of the teaching–learning-based evolutionary mechanism so as to take the merits of the TLBO algorithm. Three new operators, including a Feasible Solution Generator (FSG), a Teaching Phase Operator (TPO) and a Learning Phase Operator (LPO), have been designed and incorporated into the algorithm so as to make the algorithm applicable for DSP problems with complex constraints. In the meantime, the complex and multidimensional matrix computation used to modify solutions in the TLBO algorithm is simplified to a precedence preservation crossover operation in the STLBO algorithm. The detecting of feasibilities of new generated solutions would be also avoided. With the designed operators, STLBO can converge faster in the optimization or search process with higher accuracy so as to eventually improve the disassembly efficiency as well as reducing disassembly cost.

The rest of the paper is organized as follows: In Section 2, the proposed STLBO algorithm for DSP problems is presented in detail. Section 3 demonstrates the performance of STLBO algorithm through numerical experiments and benchmark tests with case studies of waste product disassembly planning. Finally, conclusions are drawn in Section 4.

This section presents the STLBO algorithm developed for DSP problems in detail. Firstly, the TLBO algorithm is introduced briefly. And then, the framework of the STLBO algorithm is described. Subsequently, three key operators implemented in STLBO algorithm are presented in detail with illustrative examples of disassembly of waste products. Lastly, the comparison analysis of STLBO algorithm with other optimization algorithms is given and the implementation steps of STLBO algorithm for the DSP problems are outlined.

The TLBO algorithm is a teaching–learning process inspired method simulating two fundamental modes of learning: through teacher (teaching phase) and interacting with the other learners (learning phase), where a group of learner (i.e. class) is considered as a population and the different learning subjects offered to the learners represents the different decision variables of the optimization problem. The grade of a learning subject offered to a learner represents the value of a decision variable in a solution. The result of a learner calculated from the grades of all the offered learning subjects represents the fitness function value of a solution. The learner with the best result in the entire population is considered as the teacher. The TLBO algorithm is explained below with the teaching phase and learning phase.

In the teaching phase, a good teacher conveys knowledge among the learners and tries to improve the mean results of the learners. Suppose there are m learning subjects (decision variables) offered to n learners in a class. At any sequential teaching–learning cycle t, the grades of learner i (
                           
                              i
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              n
                           
                        ) is denoted as 
                           
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    1
                                 
                                 
                                    t
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    2
                                 
                                 
                                    t
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    m
                                 
                                 
                                    t
                                 
                              
                              )
                           
                        , where 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                    ,
                                    j
                                 
                                 
                                    t
                                 
                              
                           
                         denotes the grade of learner i in subject j (
                           
                              j
                              =
                              1
                              ,
                              2
                              ,
                              …
                              ,
                              m
                           
                        ) in cycle t. The mean grade of all the learners in subject j is denoted as 
                           
                              
                                 
                                    M
                                 
                                 
                                    j
                                 
                                 
                                    t
                                 
                              
                           
                        . The result of learner i considering all the subjects is denoted as 
                           
                              f
                              (
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                              )
                           
                        . The grades of the teacher equals to those of the best learner 
                           
                              
                                 
                                    X
                                 
                                 
                                    best
                                 
                                 
                                    t
                                 
                              
                           
                        . The difference between the grade of the teacher and mean grade of the learners in each subject 
                           
                              
                                 
                                    D
                                 
                                 
                                    t
                                 
                              
                              =
                              (
                              
                                 
                                    d
                                 
                                 
                                    1
                                 
                                 
                                    t
                                 
                              
                              ,
                              
                                 
                                    d
                                 
                                 
                                    2
                                 
                                 
                                    t
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    d
                                 
                                 
                                    m
                                 
                                 
                                    t
                                 
                              
                              )
                           
                         is calculated by the following equation:
                           
                              (1)
                              
                                 
                                    
                                       d
                                    
                                    
                                       j
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       r
                                    
                                    
                                       t
                                    
                                 
                                 ·
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       best
                                       ,
                                       j
                                    
                                    
                                       t
                                    
                                 
                                 -
                                 round
                                 (
                                 1
                                 +
                                 
                                    
                                       r
                                    
                                    
                                       t
                                    
                                 
                                 )
                                 ·
                                 
                                    
                                       M
                                    
                                    
                                       j
                                    
                                    
                                       t
                                    
                                 
                                 )
                              
                           
                        where 
                           
                              
                                 
                                    r
                                 
                                 
                                    t
                                 
                              
                           
                         is a random number in the range [0, 1] and 
                           
                              round
                              (
                              1
                              +
                              
                                 
                                    r
                                 
                                 
                                    t
                                 
                              
                              )
                           
                         can be either 1 or 2 decided by 
                           
                              
                                 
                                    r
                                 
                                 
                                    t
                                 
                              
                           
                        . Based on 
                           
                              
                                 
                                    D
                                 
                                 
                                    t
                                 
                              
                              ,
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                           
                         is modified according to the following equation:
                           
                              (2)
                              
                                 
                                    
                                       X
                                    
                                    
                                       i
                                    
                                    
                                       new
                                       ,
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       X
                                    
                                    
                                       i
                                    
                                    
                                       t
                                    
                                 
                                 +
                                 
                                    
                                       D
                                    
                                    
                                       t
                                    
                                 
                              
                           
                        If 
                           
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    new
                                    ,
                                    t
                                 
                              
                           
                         gives a better result (fitness value) than 
                           
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                           
                        , update 
                           
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    t
                                 
                              
                           
                         with 
                           
                              
                                 
                                    X
                                 
                                 
                                    i
                                 
                                 
                                    new
                                    ,
                                    t
                                 
                              
                           
                        .

In the learning phase, a learner p may learn something new from another randomly selected learner q (
                           
                              q
                              
                              ≠
                              
                              p
                           
                        ) according to the following equation:
                           
                              (3)
                              
                                 
                                    
                                       X
                                    
                                    
                                       p
                                    
                                    
                                       new
                                       ,
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         p
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         p
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         q
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   )
                                                   ,
                                                
                                                
                                                   if
                                                   
                                                   (
                                                   f
                                                   (
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         p
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   )
                                                   <
                                                   f
                                                   (
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         q
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   )
                                                   )
                                                
                                             
                                             
                                                
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         p
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   +
                                                   
                                                      
                                                         r
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   (
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         q
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   -
                                                   
                                                      
                                                         X
                                                      
                                                      
                                                         p
                                                      
                                                      
                                                         t
                                                      
                                                   
                                                   )
                                                   ,
                                                
                                                
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        If 
                           
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                                 
                                    new
                                    ,
                                    t
                                 
                              
                           
                         gives a better result (fitness value) than 
                           
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                           
                        , update 
                           
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                           
                         with 
                           
                              
                                 
                                    X
                                 
                                 
                                    p
                                 
                                 
                                    new
                                    ,
                                    t
                                 
                              
                           
                        .

As analyzed in the Introduction section, neither directly implementation nor directly discretization of the TLBO algorithm could solve the DSP problems effectively. The new proposed STLBO algorithm is presented in detail in the following subsections.

The STLBO algorithm is based on the framework of a discrete and population-based optimization method, and inherits the main idea of the teaching–learning-based evolutionary mechanism from the TLBO algorithm. The STLBO algorithm includes two phase: teaching phase and learning phase, and three key parts: FSG, TPO and LPO. The pseudo-code of the STLBO algorithm is illustrated in Fig. 2
                        .

In the teaching phase, the teacher is identified firstly, and then the mean of the fitness function values (mean result) of the learners is calculated. According to the mean result and the result of the teacher, the teaching factor is calculated, which is a self-adaptive parameter determining the probability that a learner learns from the teacher. Each learner will be modified using TPO according to the teaching factor.

In the learning phase, another learner is randomly selected for each learner and a new learner is generated using FSG with its result calculated. According to the results of these three learners, self-learning factor and the factor of learning from another are calculated, which are self-adaptive parameters respectively determine the probability that a learner learns from himself, and the probability that a learner learns from another one.

The detailed explanations of FSG, TPO and LPO are presented in the following subsections.

A feasible solution for a DSP problem is a disassembly sequence that satisfies the given disassembly precedence constraints. The implementation model of FSG depends on the way how disassembly precedence constraints are represented. The general steps for implementing the FSG are as follows:
                           
                              Step 1:
                              Set the vector of components available for disassembly 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             A
                                          
                                       
                                    
                                  to 
                                    
                                       Ø
                                    
                                 ;

Check the current disassembly state and disassembly precedence constraints to find new components available for disassembly, and push them back to 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             A
                                          
                                       
                                    
                                 ;

Choose one component from 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             A
                                          
                                       
                                    
                                  randomly, push it back to Solution, erase it from 
                                    
                                       
                                          
                                             C
                                          
                                          
                                             A
                                          
                                       
                                    
                                  and suppose that it is disassembled from the product;

If all the components are disassembled from the product, the Solution is randomly generated, otherwise, go to Step 2.

This paper studied two types of DSP problems with different ways of representing the disassembly precedence constraints. The aforementioned 4 steps are general ones for implementing FSG; however, disassembly precedence constraints are represented in different ways, so the methods for finding the available components for disassembly by checking disassembly precedence constraints vary.
                           Problem 1
                           All the components and joints in the waste product are uniformly considered as components, in other words, the components and joints in the waste product are not discriminated. For instance, in the example illustrated in Fig. 3
                              , Joints 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          1
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          j
                                       
                                       
                                          2
                                       
                                    
                                 
                               both are considered as components and represented as 
                                 
                                    
                                       
                                          c
                                       
                                       
                                          4
                                       
                                    
                                 
                               and 
                                 
                                    
                                       
                                          c
                                       
                                       
                                          5
                                       
                                    
                                 
                               respectively. The disassembly precedence constraints are represented as rules, which are described as pairs of precedent set 
                                 
                                    
                                       
                                          Pre
                                       
                                       
                                          i
                                       
                                    
                                 
                               and following set 
                                 
                                    
                                       
                                          Fol
                                       
                                       
                                          i
                                       
                                    
                                 
                              . In each rule i, the components in 
                                 
                                    
                                       
                                          Pre
                                       
                                       
                                          i
                                       
                                    
                                 
                               have disassembly precedence over the components in 
                                 
                                    
                                       
                                          Fol
                                       
                                       
                                          i
                                       
                                    
                                 
                              . The disassembly precedence rules for the example in Fig. 3 are as follows:
                                 
                                    
                                       
                                          
                                             
                                                
                                                   Rule
                                                
                                                
                                                   1
                                                
                                             
                                          
                                       :
                                    
                                       
                                          
                                             
                                                
                                                   Pre
                                                
                                                
                                                   1
                                                
                                             
                                             =
                                             Ø
                                             ,
                                             
                                             
                                                
                                                   Fol
                                                
                                                
                                                   1
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   5
                                                
                                             
                                             }
                                          
                                       ;


                                       
                                          
                                             
                                                
                                                   Pre
                                                
                                                
                                                   2
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   5
                                                
                                             
                                             }
                                             ,
                                             
                                             
                                                
                                                   Fol
                                                
                                                
                                                   2
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   3
                                                
                                             
                                             }
                                          
                                       ;


                                       
                                          
                                             
                                                
                                                   Pre
                                                
                                                
                                                   3
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   3
                                                
                                             
                                             }
                                             ,
                                             
                                             
                                                
                                                   Fol
                                                
                                                
                                                   3
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   4
                                                
                                             
                                             }
                                          
                                       ;


                                       
                                          
                                             
                                                
                                                   Pre
                                                
                                                
                                                   4
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   4
                                                
                                             
                                             }
                                             ,
                                             
                                             
                                                
                                                   Fol
                                                
                                                
                                                   4
                                                
                                             
                                             =
                                             {
                                             
                                                
                                                   c
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   c
                                                
                                                
                                                   2
                                                
                                             
                                             }
                                          
                                       .

The pseudo-code of FSG implemented for Problem 1 is outlined in Fig. 4
                        .
                           Problem 2
                           The components and joints in the waste product are considered discriminatorily. In the disassembly process, the components are to be removed while the joints are to be broken. The disassembly precedence constraints are represented in a mathematical formation: two matrices and a list are used to represent the information on interferences between joints and components and among the components themselves.

Joint accessibility matrix A. The rows correspond to joints and the columns to components. The element 
                                    
                                       
                                          
                                             a
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                    
                                  is binary and indicates whether Joint i is restricted by the presence of Component j.

Disassembly precedence matrix P. The rows and columns correspond to components. The element 
                                    
                                       
                                          
                                             p
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                    
                                  indicates, for each Component i, which access directions are obstructed by Component j. If five possible access directions (
                                    
                                       ±
                                    
                                 x, 
                                    
                                       ±
                                    
                                 y, +z) are considered, assuming that the product is fixed on a horizontal table or on the floor, each element 
                                    
                                       
                                          
                                             p
                                          
                                          
                                             i
                                             ,
                                             j
                                          
                                       
                                    
                                  can be expressed as five bits, each of which corresponds to one of the five access directions.

Joints list for each component 
                                    
                                       L
                                       =
                                       (
                                       
                                          
                                             L
                                          
                                          
                                             1
                                          
                                       
                                       ,
                                       
                                          
                                             L
                                          
                                          
                                             2
                                          
                                       
                                       ,
                                       …
                                       ,
                                       
                                          
                                             L
                                          
                                          
                                             n
                                          
                                       
                                       )
                                    
                                 . The element 
                                    
                                       
                                          
                                             L
                                          
                                          
                                             i
                                          
                                       
                                    
                                  indicates a list of all the joints that involve Component i.

The disassembly precedence constraints for the example in Fig. 3 are represented are as follows:
                           
                              (4)
                              
                                 A
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   1
                                                
                                             
                                             
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 P
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   0
                                                
                                                
                                                   0010
                                                
                                                
                                                   0110
                                                
                                             
                                             
                                                
                                                   0001
                                                
                                                
                                                   0
                                                
                                                
                                                   0110
                                                
                                             
                                             
                                                
                                                   1001
                                                
                                                
                                                   1001
                                                
                                                
                                                   0
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 L
                                 =
                                 
                                    
                                       
                                          
                                             
                                                L
                                             
                                             
                                                1
                                             
                                          
                                          ,
                                          
                                             
                                                L
                                             
                                             
                                                2
                                             
                                          
                                          ,
                                          
                                             
                                                L
                                             
                                             
                                                3
                                             
                                          
                                       
                                    
                                 
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   
                                                      j
                                                   
                                                   
                                                      1
                                                   
                                                
                                                ,
                                                
                                                   
                                                      j
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                
                                                   
                                                      j
                                                   
                                                   
                                                      1
                                                   
                                                
                                             
                                          
                                          ,
                                          
                                             
                                                
                                                   
                                                      j
                                                   
                                                   
                                                      2
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The pseudo-code of the FSG implemented in Problem 2 is outlined in Fig. 5
                        .

TPO is used to replace current learners with new better learners in terms of better results (fitness function values) in the teaching phase. The teacher tries to improve the mean of the results of learners by giving his/her experiences and knowledge (e.g. better disassembly sequence) for the learners with expectation of their fitness function value to reach his/her level eventually. In other words, the feasible solutions in the teaching phase follow a random process to evolve and the quality of solutions depends on teacher’s and population’s capability.

New solutions can be randomly generated using TPO according to the teacher and the class in the teaching phase. Firstly the low bound of the objective function value (
                           
                              
                                 
                                    f
                                 
                                 
                                    lb
                                 
                              
                           
                        ) is given according to the best disassembly situation. Then, a self-adaptive parameter named teaching factor (
                           
                              
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                           
                        ) is used for modifying the existing learners, which can be calculated according to the mean of the objective function value of the population (
                           
                              
                                 
                                    f
                                 
                                 
                                    m
                                 
                              
                           
                        ), the objective function value of the teacher (
                           
                              
                                 
                                    f
                                 
                                 
                                    t
                                 
                              
                           
                        ) and the low bound of the objective function value:
                           
                              (7)
                              
                                 g
                                 (
                                 x
                                 )
                                 =
                                 
                                    
                                       x
                                    
                                    
                                       x
                                       -
                                       
                                          
                                             f
                                          
                                          
                                             lb
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                       p
                                    
                                    
                                       t
                                    
                                 
                                 =
                                 
                                    
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             t
                                          
                                       
                                       )
                                    
                                    
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             t
                                          
                                       
                                       )
                                       +
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             m
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

Finally, the precedence preservative operator is applied to preserve the precedence relationship in the feasible solutions when updating them. The pseudo-code of the TPO is outlined in Fig. 6
                        .

In the procedure of TPO, a new solution is generated by a procedure of choosing and setting the elements one by one, from the left to the right of the solution. Firstly, the probability is set randomly, which is used to compare with 
                           
                              
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                           
                        . If the probability is less than 
                           
                              
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                           
                        , the leftmost element of the teacher is chosen and pushed back to the new solution; otherwise the leftmost element of the learner is chosen and pushed back to the new solution. Then, the chosen element is erased from both the teacher and learner. Finally, the learner is updated with the new generated solution if the new one is better. In this way, the disassembly precedence in solutions is preserved.


                        Table 1
                         gives an example for using TPO to generate a new solution with 5 elements: a new solution (2 3 4 5 1) is generated from a teacher (2 3 1 4 5) and a learner (4 3 5 1 2). Suppose Component 3 has precedence over Component 5 and 
                           
                              
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                              =
                              0.6
                           
                        . It is seen that the precedence is preserved in the new solution.

LPO is used to modify the existing learners with new better learners in the learning phase, where learners learn from each other and improve their abilities. Learning phase also follows a random process to generate feasible solutions, but the qualities of the solutions depend on current learner’s ability, other learners’ ability and random distribution.

New solutions can be randomly generated using LPO according to the learners themselves, other learners and randomly generated learners in the learner phase. Two self-adaptive parameters named self-learning factor (
                           
                              
                                 
                                    p
                                 
                                 
                                    s
                                 
                              
                           
                        ) and factor of learning from another (
                           
                              
                                 
                                    p
                                 
                                 
                                    a
                                 
                              
                           
                        ) are used for modifying the existing learners, which can be calculated according to the objective function value of the learner itself (
                           
                              
                                 
                                    f
                                 
                                 
                                    s
                                 
                              
                           
                        ), the objective function value of another learner (
                           
                              
                                 
                                    f
                                 
                                 
                                    a
                                 
                              
                           
                        ), the objective function value of a randomly generated learner (
                           
                              
                                 
                                    f
                                 
                                 
                                    r
                                 
                              
                           
                        ) and the low bound of the objective function value (
                           
                              
                                 
                                    f
                                 
                                 
                                    lb
                                 
                              
                           
                        ):
                           
                              (9)
                              
                                 
                                    
                                       p
                                    
                                    
                                       s
                                    
                                 
                                 =
                                 
                                    
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             s
                                          
                                       
                                       )
                                    
                                    
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             s
                                          
                                       
                                       )
                                       +
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             a
                                          
                                       
                                       )
                                       +
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             r
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       p
                                    
                                    
                                       a
                                    
                                 
                                 =
                                 
                                    
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             s
                                          
                                       
                                       )
                                       +
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             a
                                          
                                       
                                       )
                                    
                                    
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             s
                                          
                                       
                                       )
                                       +
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             a
                                          
                                       
                                       )
                                       +
                                       g
                                       (
                                       
                                          
                                             f
                                          
                                          
                                             r
                                          
                                       
                                       )
                                    
                                 
                              
                           
                        
                     

The pseudo-code of LPO is similar to that of TPO outlined in Fig. 7
                        . A new solution is generated from three parent solutions with two self-adaptive parameters in LPO, while a new solution is generated from two parent solutions with one self-adaptive parameter in TPO. In the learner phase, the learning factors for different learners are different, and they need to be calculated before implementing LPO, while the teaching factor just needs to be calculated once in the teaching phase.

Like GA, PSO, TLBO, etc., the STLBO algorithm is also a population based technique which implements a group of solutions to evolve and learns to find a near optimum or optimum solution.

Compared with GA and PSO applied in solving DSP problems in the previous research works, the teaching-leaning-based evolutionary mechanism of the STLBO algorithm is novel and different from the crossover and mutation mechanisms of GA and particle position update mechanism of PSO. In the STLBO algorithm, all the algorithm parameters (except population size and iteration times) are self-adapted and need not to be tuned. While GA requires the crossover rate and mutation probability, and the discrete PSO requires inertia weight and two acceleration constants.

The STLBO algorithm is also different from the TLBO algorithm in the following aspects. (a) The realization methods for evolutionary mechanism are different. In the STLBO algorithm, learners are modified using the TPO and LPO, applying the method of precedence preservation crossover operation. While in the TLBO algorithm, learners are modified using multidimensional matrix computation. (b) The adaptation methods for the algorithm parameters are different. In the STLBO algorithm, the teaching factor (
                           
                              
                                 
                                    p
                                 
                                 
                                    t
                                 
                              
                           
                        ), self-learning factor (
                           
                              
                                 
                                    p
                                 
                                 
                                    s
                                 
                              
                           
                        ) and factor of learning from another (
                           
                              
                                 
                                    p
                                 
                                 
                                    a
                                 
                              
                           
                        ) are calculated according to the results of learners (objective function values of solutions). While in the TLBO algorithm, the difference mean is calculated according to the grades of learners in each learning subject, in which the learning factor (
                           
                              
                                 
                                    r
                                 
                                 
                                    t
                                 
                              
                           
                        ) is a random number in the range [0, 1] and the teaching factor (
                           
                              round
                              (
                              1
                              +
                              
                                 
                                    r
                                 
                                 
                                    t
                                 
                              
                              )
                           
                        ) can be either 1 or 2 decided by 
                           
                              
                                 
                                    r
                                 
                                 
                                    t
                                 
                              
                           
                        .

The steps for implementation of the STLBO algorithm for solving DSP problems can be summarized as follows:
                           
                              Step 1:
                              Define and formulate a DSP problem in a mathematical model and represent the disassembly precedence constraints;

Initialize the optimization parameters: solution length (number of components) population size (number of learners) and iteration times;

Generate a random population using FSG according to the population size and the number of components for disassembly;

Calculate the teaching factor and modify all the learners using TPO;

Calculate the self-learning factor and factor of learning from another for each learner and modify all of them using LPO;

Stop if the stop criteria are satisfied or maximum iteration times are achieved, otherwise repeat from Step 4.

In order to test the performance of the STLBO algorithm and conduct a further comparative study, two kinds of disassembly sequence planning problems are described and used for testing. In both problems, the case of complete disassembly of wasted products is considered and it assumes that the structure of waste products and disassembly precedence constraints are known. Two types of representation methods of disassembly precedence constraints and the corresponding methods for generating a feasible disassembly sequence are in advance presented respectively in Section 2.3. All the algorithms tested were coded in the C++ programming language and carried out on a personal computer with 2GHz Intel Core2 Duo CPU T5750 and 2GB memory.

In the first DSP problem, all the components and joints in a waste product are uniformly considered as components. Four types of attributes of the disassembly process are considered: disassembly direction, disassembly method, demand after disassembly, and material contained in component [5,15]. A brief description of these attributes is presented as follows, where 
                           
                              x
                              ∈
                              {
                              0
                              ,
                              1
                              ,
                              …
                              ,
                              n
                              -
                              1
                              }
                           
                         denotes the identifier of a component and n denotes the number of components.
                           
                              •
                              Disassembly direction: 
                                    
                                       dir
                                       (
                                       x
                                       )
                                    
                                  
                                 
                                    
                                       ∈
                                    
                                  {
                                    
                                       ±
                                    
                                 x, 
                                    
                                       ±
                                    
                                 y, 
                                    
                                       ±
                                    
                                 z}. Each component must be disassembled in a particular direction. The 
                                    
                                       ±
                                    
                                 x, 
                                    
                                       ±
                                    
                                 y and 
                                    
                                       ±
                                    
                                 z indicate six possible directions respectively.

Disassembly method: 
                                    
                                       met
                                       (
                                       x
                                       )
                                       ∈
                                       {
                                       D
                                       ,
                                       N
                                       }
                                    
                                 . The letter D indicates Destructive disassembly, which focuses on recycling of materials, while the letter N indicates nondestructive disassembly, which focuses on components reuse.

Demand after disassembling: 
                                    
                                       dem
                                       (
                                       x
                                       )
                                       ∈
                                       {
                                       0
                                       ,
                                       1
                                       ,
                                       2
                                       }
                                    
                                 . The values 0, 1 and 2 indicate no demand, demand of reuse and demand of recycling respectively.

Material contained in a component: 
                                    
                                       mat
                                       (
                                       x
                                       )
                                       ∈
                                       {
                                       A
                                       ,
                                       P
                                       ,
                                       S
                                       }
                                    
                                 . The letters 
                                    
                                       A
                                       ,
                                       P
                                    
                                  and S indicate three types of materials contained in components: aluminum, plastic, and steel, respectively.

The objective of this problem is to find a feasible disassembly sequence 
                           
                              X
                              =
                              (
                              
                                 
                                    x
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                    -
                                    1
                                 
                              
                              )
                           
                         to minimize the total disassembly time 
                           
                              f
                              (
                              X
                              )
                           
                        , which depends on the basic disassembly time 
                           
                              bt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                        , the penalty of direction change 
                           
                              dt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         and the penalty of method change 
                           
                              mt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         for each component 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                        . The objective function is as follows:
                           
                              (11)
                              
                                 minimize
                                 :
                                 f
                                 (
                                 X
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          0
                                       
                                       
                                          n
                                          -
                                          1
                                       
                                    
                                 
                                 bt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          0
                                       
                                       
                                          n
                                          -
                                          2
                                       
                                    
                                 
                                 dt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          0
                                       
                                       
                                          n
                                          -
                                          2
                                       
                                    
                                 
                                 mt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                           
                        where 
                           
                              bt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                              ,
                              dt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         and 
                           
                              mt
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         are computed as follows:

If
                           
                              (12)
                              
                                 dem
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 dem
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 )
                                 =
                                 2
                                 
                                 and
                                 
                                 mat
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 mat
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                       +
                                       1
                                    
                                 
                                 )
                              
                           
                        then
                           
                              (13)
                              
                                 bt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 0
                                 ,
                                 
                                 dt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 0
                                 ,
                                 
                                 mt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 0
                              
                           
                        otherwise
                           
                              (14)
                              
                                 bt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 bas
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                              
                           
                        
                        
                           
                              (15)
                              
                                 dt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   
                                                   direction is not changed
                                                
                                             
                                             
                                                
                                                   1
                                                   ,
                                                   
                                                   direction is changed by 90
                                                   °
                                                
                                             
                                             
                                                
                                                   2
                                                   ,
                                                   
                                                   direction is changed by 180
                                                   °
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 mt
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   0
                                                   ,
                                                   
                                                   method is not changed
                                                
                                             
                                             
                                                
                                                   1
                                                   ,
                                                   
                                                   method is changed
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

Eq. (12) represents a special situation: two adjacent components in a disassembly sequence are made by the same material, and both are demanded for recycling. These two components will not be separated from each other and will be disassembled as a combination. In Eq. (14), 
                           
                              bas
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         indicates the basic disassembly time for Component 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                        .

An example for Problem 1 is shown in Fig. 8
                        , where the waste product is modeled by a tree and the disassembly precedence constraints are defined among the nodes. In this tree, the dashed-line arrow indicates that the component/subassembly at the start point has priority for disassembly over the component/subassembly at the end point. The tree is generated based on the Bill of Materials (BOM) and the disassembly precedence constraints can be acquired from the geometric information and connector information using a connector-knowledge-based approach [33]. The waste product has 13 components indexed by numbers 0, 1, …, 12. The input data of the example is given in Table 2
                        . And the disassembly precedence rules generated from Fig. 8 are shown as follows:
                           
                              
                                 
                                    
                                       
                                          
                                             Rule
                                          
                                          
                                             1
                                          
                                       
                                    
                                 :
                              
                                 
                                    
                                       
                                          
                                             Pre
                                          
                                          
                                             1
                                          
                                       
                                       =
                                       Ø
                                       ,
                                       
                                       
                                          
                                             Fol
                                          
                                          
                                             1
                                          
                                       
                                       =
                                       {
                                       1
                                       ,
                                       2
                                       }
                                    
                                 ;


                                 
                                    
                                       
                                          
                                             Pre
                                          
                                          
                                             2
                                          
                                       
                                       =
                                       {
                                       1
                                       ,
                                       2
                                       }
                                       ,
                                       
                                       
                                          
                                             Fol
                                          
                                          
                                             2
                                          
                                       
                                       =
                                       {
                                       0
                                       ,
                                       3
                                       ,
                                       6
                                       ,
                                       8
                                       ,
                                       11
                                       }
                                    
                                 ;


                                 
                                    
                                       
                                          
                                             Pre
                                          
                                          
                                             3
                                          
                                       
                                       =
                                       {
                                       3
                                       }
                                       ,
                                       
                                       
                                          
                                             Fol
                                          
                                          
                                             3
                                          
                                       
                                       =
                                       {
                                       4
                                       ,
                                       5
                                       ,
                                       7
                                       }
                                    
                                 ;


                                 
                                    
                                       
                                          
                                             Pre
                                          
                                          
                                             4
                                          
                                       
                                       =
                                       {
                                       5
                                       }
                                       ,
                                       
                                       
                                          
                                             Fol
                                          
                                          
                                             4
                                          
                                       
                                       =
                                       {
                                       9
                                       ,
                                       10
                                       ,
                                       12
                                       }
                                    
                                 .

To demonstrate the effectiveness of the proposed TPO or LPO, the following three cases are implemented:
                              
                                 Case 1:
                                 STLBO with TPO while without LPO;

STLBO with LPO while without TPO;

STLBO with both TPO and LPO.

The following parameters are initialized as:
                              
                                 •
                                 Solution length=13;

Population size=10;

Iteration times=100.

The numerical results are shown in Fig. 9
                           .

As shown in Fig. 9 (a), the algorithm in Case 1 converges fast to the local optimum at its early stage, and the objective function values 
                              
                                 f
                                 (
                                 X
                                 )
                              
                            obtained in Case 1 are located in a large range in the first half of the iterations. Then all the learners converge fast to a certain level for that the teacher’s ability and population’s capability are limited.

As shown in Fig. 9 (b), the algorithm in Case 2 converges slow with low optimization accuracy, and the objective function values 
                              
                                 f
                                 (
                                 X
                                 )
                              
                            obtained in Case 2 are located in a range during almost the whole iterations. When modifying the learners using LPO, a new solution is generated according to two existed learners and one randomly generated solution. As thus, there is a chance to find better solutions in Case 2, thus making the speed of convergence of the algorithm slow.

As shown in Fig. 9 (c), the complete the STLBO algorithm in Case 3 converges faster than the algorithms in Case 1 and Case 2 with higher optimization accuracy. The complete STLBO takes the advantages of both TPO and LPO.

From the numerical results, it can be concluded that learning from teacher using TPO makes the speed of convergence fast, and self-learning and learning from each other using LPO make additional chances to find better solutions. Combining TPO and LPO together makes the STLBO algorithm converges fast and enhances the search accuracy of it.

The following cases were implemented to test and compare the STLBO algorithm with GA [5] and SSO algorithm [15]:
                              
                                 Case 4:
                                 population size=10 and iteration times=100;

population size=20 and iteration times=50;

population size=50 and iteration times=20;

population size=100 and iteration times=10;

population size=100 and iteration times=100.

Firstly, Case 4 is used to compare the speed of convergence of the STLBO algorithm with that of GA and SSO algorithm. The optimum result of each iteration is recorded when running the algorithms. The convergence curves of these algorithms tested in Case 4 are shown in Fig. 10
                           . It is observed that the STLBO algorithm converge faster than GA and SSO algorithm.

Then, Cases 4–8 are designed to compare the performances of the STLBO algorithm with the GA and SSO algorithm, and each algorithm runs 100 times independently in each case respectively. The numerical results are shown in Table 3
                           , in which STD stands for Standard Deviation, ROB stands for Rate Of Best and ART stands for Average Running Time (millisecond). It is observed that the STLBO algorithm performs better than GA and SSO algorithm on all the cases, which means that the STLBO algorithm’s teaching–learning-based mechanism with TPO and LPO is effective. The STLBO algorithm consumes a bit more time than SSO algorithm but it has a higher rate of finding the best solution.

In addition, Cases 4–7 shows that a bigger population size makes STLBO, GA and SSO performing better even with less iteration times. As the value of iteration times in Case 7 is quite small, the performance of the algorithms may be improved by increasing the iteration times. Therefore Case 8 is implemented. It is observed that all these three algorithms’ performance is improved by increasing the iteration times to 100.

One of the optimal solutions found by the STLBO algorithm for the example of Problem 1 is (1 2 3 0 8 11 5 7 9 6 4 10 12) and the total disassembly time is 33.

In the second DSP problem, the components and joints in a waste product are considered respectively. Three types of attributes of the disassembly process are considered as follows:
                           
                              (1)
                              Direction changes of breaking joints. More direction changes lead to the higher cost of breaking joints;

Tool changes of breaking joints. More tool changes lead to the higher cost of breaking joints;

The number of directions obstructed by other components when extracting a component. More obstructed directions lead to the higher cost of extracting process.

The mathematical model of this DSP problem is presented in the benchmarks published by González and Adenso-Díaz [34]. The objective function is as follows:
                           
                              (17)
                              
                                 minimize
                                 :
                                 f
                                 (
                                 X
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          0
                                       
                                       
                                          n
                                          -
                                          1
                                       
                                    
                                 
                                 (
                                 
                                    
                                       c
                                    
                                    
                                       J
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 +
                                 
                                    
                                       c
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 )
                              
                           
                        where 
                           
                              
                                 
                                    c
                                 
                                 
                                    J
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         indicates the cost of breaking all the joints that involve component 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         after 
                           
                              
                                 
                                    x
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                    -
                                    1
                                 
                              
                           
                         are all extracted, and 
                           
                              
                                 
                                    c
                                 
                                 
                                    C
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         indicates the cost of extracting component 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         after 
                           
                              
                                 
                                    x
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                    -
                                    1
                                 
                              
                           
                         are all extracted. They are computed as follows:
                           
                              (18)
                              
                                 
                                    
                                       c
                                    
                                    
                                       J
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 
                                    
                                       
                                          ∑
                                       
                                       
                                          j
                                          ∈
                                          
                                             
                                                B
                                             
                                             
                                                J
                                             
                                          
                                          (
                                          
                                             
                                                x
                                             
                                             
                                                i
                                             
                                          
                                          )
                                       
                                    
                                 
                                 c
                                 (
                                 j
                                 )
                                 ·
                                 
                                    
                                       c
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 j
                                 )
                                 ·
                                 
                                    
                                       c
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 j
                                 )
                              
                           
                        where 
                           
                              
                                 
                                    B
                                 
                                 
                                    J
                                 
                              
                              (
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                              )
                           
                         indicates the list of joints that involve component 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         after 
                           
                              
                                 
                                    x
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                    -
                                    1
                                 
                              
                           
                         are all extracted, 
                           
                              c
                              (
                              j
                              )
                           
                         indicates the based cost of breaking Joint 
                           
                              j
                              ,
                              
                                 
                                    c
                                 
                                 
                                    1
                                 
                              
                              (
                              j
                              )
                           
                         indicates the cost penalty of tool change when breaking Joint j, and 
                           
                              
                                 
                                    c
                                 
                                 
                                    2
                                 
                              
                              (
                              j
                              )
                           
                         indicates the cost penalty of direction change when breaking Joint j.
                           
                              (19)
                              
                                 
                                    
                                       c
                                    
                                    
                                       C
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 =
                                 100
                                 -
                                 (
                                 4
                                 -
                                 
                                    
                                       n
                                    
                                    
                                       O
                                    
                                 
                                 (
                                 
                                    
                                       x
                                    
                                    
                                       i
                                    
                                 
                                 )
                                 )
                                 ×
                                 24.75
                              
                           
                        where 
                           
                              
                                 
                                    n
                                 
                                 
                                    O
                                 
                              
                              (
                              xi
                              )
                           
                         indicates the number of directions obstructed by other components when extracting component 
                           
                              
                                 
                                    x
                                 
                                 
                                    i
                                 
                              
                           
                         after 
                           
                              
                                 
                                    x
                                 
                                 
                                    0
                                 
                              
                              ,
                              
                                 
                                    x
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    x
                                 
                                 
                                    n
                                    -
                                    1
                                 
                              
                           
                         are all extracted. 
                           
                              
                                 
                                    c
                                 
                                 
                                    1
                                 
                              
                              (
                              j
                              )
                           
                         and 
                           
                              
                                 
                                    c
                                 
                                 
                                    2
                                 
                              
                              (
                              j
                              )
                           
                         are computed as follows:
                           
                              (20)
                              
                                 
                                    
                                       c
                                    
                                    
                                       1
                                    
                                 
                                 (
                                 j
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1.1
                                                   ,
                                                   broke
                                                   
                                                   a
                                                   
                                                   joint
                                                   
                                                   just
                                                   
                                                   before
                                                   
                                                   and
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   the
                                                   
                                                   tool
                                                   
                                                   is
                                                   
                                                   changed
                                                
                                             
                                             
                                                
                                                   1.1
                                                   ,
                                                   extracted
                                                   
                                                   a
                                                   
                                                   component
                                                   
                                                   just
                                                   
                                                   before
                                                
                                             
                                             
                                                
                                                   1
                                                   ,
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (21)
                              
                                 
                                    
                                       c
                                    
                                    
                                       2
                                    
                                 
                                 (
                                 j
                                 )
                                 =
                                 
                                    
                                       
                                          
                                             
                                                
                                                   1.15
                                                   ,
                                                   broke
                                                   
                                                   a
                                                   
                                                   joint
                                                   
                                                   just
                                                   
                                                   before
                                                   
                                                   and
                                                
                                             
                                             
                                                
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   
                                                   the
                                                   
                                                   direction
                                                   
                                                   is
                                                   
                                                   changed
                                                
                                             
                                             
                                                
                                                   1.15
                                                   ,
                                                   extracted
                                                   
                                                   a
                                                   
                                                   component
                                                   
                                                   just
                                                   
                                                   before
                                                
                                             
                                             
                                                
                                                   1
                                                   ,
                                                   otherwise
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The published disassembly benchmarks of 24 instances were taken for experimental studies. The best solutions and corresponding objective function values for these instances are kept up-to-date online (http://coruxa.epsig.uniovi.es/∼adenso/file_d.html). The test problems (of size n = 25 and 50) were generated using the GEN-PRODIS tool [34], which is able to generate an unlimited number of random test cases with specified characteristics (number of components and degree of compactness). All the components are right-angled parallelepiped, and a component may not be involved in more than eight joints and the total number of disassembly tools was set to five. Fig. 11
                         gives an example of an instances (100-025-005-05) with n = 25 components in the published benchmarks.

To test the benchmarks, the following parameters are initialized as:
                           
                              •
                              Solution length=
                                 n;

Population size=20;

Iteration times=200.

The best results obtained by the STLBO algorithm compared with the previous best results are shown in Table 4
                        . It is seen that the STLBO algorithm found eight new best solutions and five solutions that are equal to the previous best ones. Table 5
                         outlines the eight new best solutions found by the STLBO algorithm.

In summary, the experimental results illustrate that the developed STLBO algorithm performs well on DSP since it outperforms other methods such as GA and SSO and find 8 new best solutions out of 24 instances in the published benchmarks. The success of the STLBO algorithm could come from a better balance of global exploration and local exploitation, resulting from a powerful teaching–learning-based mechanism. The teaching phase is more like a kind of global exploration and learner phase is more like a kind of local exploitation. Moreover, all the parameters in the STLBO algorithm are self-adapted and need not to be tuned thus making the implementation simpler. And the teacher of each iteration is used to modify the learners thereby increasing the convergence rate.

@&#CONCLUSIONS@&#

This paper proposes a novel STLBO algorithm for solving DSP problems. The STLBO algorithm is divided into two phase: teaching phase and learning phase. And three new key operators are presented: FSG, TPO and LPO. The developed STLBO algorithm is a discrete and population-based optimization algorithm with a new teaching–learning-based evolutionary mechanism. The characteristics and advantages of the developed STLBO are summarized as follows:
                        
                           •
                           The STLBO algorithm is specially designed for DSP problems and adapts to different DSP problems with different ways of representing the disassembly precedence constraints.

The implementation of the STLBO algorithm is simple for that all the algorithm parameters are self-adapted and need not to be tuned. Thus the performance of the algorithm is stable.

And STLBO can converge fast with high optimization accuracy by implementing the new teaching–learning-based evolutionary mechanism.

Two types of DSP problems are described and formulated in a mathematical model. The effectiveness and good performance of STLBO for solving DSP problems are proved by experimental studies and benchmark test.

In the future, more complex case studies for DSP problems will be introduced. The performance of the STLBO algorithm can be enhanced by improving the design of TPO and LPO by combining them with other search techniques. The STLBO algorithm can also be used to solve complex combinatorial optimization problems. Moreover, the STLBO algorithm can be extended as a multi-objective optimization algorithm to solve multi-objective disassembly sequence planning problems.

@&#ACKNOWLEDGEMENTS@&#

This research is carried out as a part of GREENet project which was supported by a Marie Curie International Research Staff Exchange Scheme Fellowship within the 7th European Community Framework Programme under Grant Agreement No. 269122. The paper reflects only the author’s views and that the Union is not liable for any use that may be made of the information contained therein. This research work is also supported by the Special Funds for the Scientific and Technological Cooperation with EU from the Ministry of Science and Technology of China under Grant No. 1208 and the Natural Science Foundation of China (NSFC) under Grant No. 51121002.

@&#REFERENCES@&#

