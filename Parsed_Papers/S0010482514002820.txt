@&#MAIN-TITLE@&#Finding splitting lines for touching cell nuclei with a shortest path algorithm

@&#HIGHLIGHTS@&#


               
                  
                  
                     
                        
                           
                           We utilize the ellipse fitting algorithm to obtain the markers of cell nuclei.


                        
                        
                           
                           The splitting line of touching cell nuclei is extracted by EDT.


                        
                        
                           
                           The concave points are adopted to adjust the endpoints of initial splitting line.


                        
                        
                           
                           We calculate the shortest path between the adjusted endpoints to find the accurate splitting line.


                        
                        
                           
                           Our algorithm achieves good experimental results on different types of touching cell nuclei.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Splitting line

Touching cell nuclei

Shortest path

Segmentation

@&#ABSTRACT@&#


               
               
                  A shortest path-based algorithm is proposed in this paper to find splitting lines for touching cell nuclei. First, an initial splitting line is obtained through the distance transform of a marker image and the watershed algorithm. The initial splitting line is then separated into different line segments as necessary, and the endpoint positions of these line segments are adjusted to the concave points on the contour. Finally, a shortest path algorithm is used to find the accurate splitting line between the starting-point and the end-point, and the final split can be achieved by the contour of the touching cell nuclei and the splitting lines. Comparisons of experimental results show that the proposed algorithm is effective for segmentation of different types of touching cell nuclei.
               
            

@&#INTRODUCTION@&#

Splitting of touching cell nuclei is a crucial technique in image analysis [1–9]. Many algorithms have therefore been proposed for this purpose [1–9]. Some of the basic tools used by these algorithms are ellipse fitting [4,5], shape information of the contour [2,6,7], watershed [1,8–10], and so on. The splitting line is important in this context. A good splitting line should be located at the edge inside the touching area. The splitting line shows the possible complete contour of a single nucleus. This is very important for biological applications such as cell analysis and cell measurement. Ellipse fitting-based algorithms use ellipses to represent each separated nucleus of the touching cell nuclei. However, the ellipses cannot be considered as the actual boundary of each nucleus. Shape information-based algorithms usually give straight lines as the splitting lines, which are not accurate. Watershed-based algorithms can give the contour of each nucleus, but the contour is usually affected by the positions of markers [9]. Therefore, different markers of the same region may generate different contours [9], and the position of the splitting line will change if the markers are different. These algorithms cannot always give the same splitting line for different sets of markers.

To find good splitting lines, a shortest path-based algorithm is proposed in this paper. First of all, we apply an ellipse fitting-based algorithm [11] to obtain the ellipse centers as the markers. Then, the distance transform of the marker image is used to find the initial splitting lines. These lines can be separated into several line segments, which are used for splitting the multiple nuclei. Furthermore, the starting-point and the endpoint of each line segment are obtained and adjusted. Finally, with each pair of endpoints we apply the shortest path algorithm in a local area to obtain the final splitting lines. Therefore, the final segmentation result can be obtained by combining the contour of the nuclei and the splitting lines. Because of the endpoint searching strategy and the shortest path algorithm, the splitting line runs along the edge inside the touching cell nuclei and it is easy to obtain the complete contour of each nucleus. To evaluate the performance of the proposed algorithm, other algorithms are used for comparison using quantitative and qualitative methods. Experimental results show that our algorithm is effective.

A preliminary version of this paper was presented in [12]. Compared to [12], the extension mainly includes (1) proposing a novel concave point-finding method, (2) adjusting the initial splitting line by rules, (3) adding quantitative evaluation of the experimental results.

The procedure employed by our algorithm is illustrated in Fig. 1
                     . Details of the algorithm are given below.

Each pair of touching cell nuclei can be roughly separated by any line between the two nucleus centers. We refer to the nucleus center as a marker in this paper. As the contour of the nucleus is similar to the ellipse, the ellipse center can be regarded as the marker of the nucleus. Therefore, we use the ellipse fitting-based algorithm [11] to extract the nucleus markers. The algorithm adopted from [11] contains four steps.

The closed contours of touching cell nuclei are extracted by a marker-based watershed algorithm, following the procedure shown in Fig. 2
                        . We take the eroded result of Otsu binary image as the marker of the foreground, and take the distance transform of the foreground as the marker of the background. After the foreground and the background are both marked as the regional minimum, the contour with the largest gradient between the foreground and the background can be generated by watershed transform.

After that, each contour is segmented into several arcs by concave points, each fitting one ellipse. Finally, the fitted ellipses are combined on the basis of their shape information. Details can be found in [11].

We propose a simple and efficient method to find concave points, rather than the method presented in [11]. Firstly, polygon vertices from a contour are saved in a sequence by a polygon approximation algorithm [7,11]. Then, for each point like A with two neighboring points B and C (see Fig. 3
                        ), the cross product of two vectors AB and AC is calculated. If the cross product is negative, A is saved as a concave point, such as the example shown in Fig. 3(a). Otherwise, A is not a concave point (see Fig. 3(b)). With this method, it is not necessary to calculate the concavity of every point. The concave points along the contour can be found more efficiently. Finally, the concave angle of each concave point is compared with a pre-set threshold. If the concave angle is larger than the threshold, this concave point should be removed. In practice, if the concave angle of a point is greater than 150°, this point is usually on a smooth line. Therefore, we choose 150° as the threshold of the concave angle in this paper. The experimental results also show the effectiveness of this threshold.


                        Fig. 4
                         shows the procedure for generating markers. Fig. 4(a) shows the original touching cell nuclei for segmentation. Fig. 4(b) is the fitted ellipses for the nuclei and Fig. 4(c) is the extracted markers of the nuclei. With these markers, we can find the initial splitting lines by a proper method.

As the markers of touching cell nuclei have been obtained, we only need to find a proper method to generate the splitting line. Distance transform is an effective method for separating points according to their distance distribution. However, the position of the splitting line varies with different markers. Therefore, the splitting lines obtained by distance transform are regarded as initial splitting lines only.

Different types of distance transforms have been proposed to improve the performance of segmentation algorithms [3,13]. In our algorithm, we use the Euclidean Distance Transform (EDT) [13] on the complementary marker image.


                        Fig. 5
                        (b) shows the result of distance transform and Fig. 5(c) shows the initial splitting lines obtained by EDT. We can see that the touching cell nuclei can be separated into different regions with only a single nucleus inside. Obviously, the endpoints of the splitting line should be located at the concave points. Thus, the initial splitting line should be adjusted.

The initial splitting lines obtained by EDT separate the whole image into areas based on markers. As we do not take the contour information of cell nuclei into consideration, the initial splitting line is not accurate. Generally, a reasonable splitting line should start and end at the concave points on the contour. Therefore, we separate the initial splitting line into endpoints and adjust these endpoints to the nearest concave points.

If there are some line segments touching (see Fig. 6
                        (a)), they can be separated by tracing the points on each of them (see Fig. 6(b)). Suppose there are N (in Fig. 6(a), 
                           N
                           =
                           3
                        ) line segments touching each other. 
                           
                              
                                 S
                              
                              
                                 i
                              
                           
                         is the starting-point of line segment 
                           
                              
                                 L
                              
                              
                                 i
                              
                           
                         (
                           1
                           ≤
                           i
                           ≤
                           N
                        ). The separation procedure is given below:
                           
                              (1)
                              Take any starting-point (
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                 ) of one line segment (
                                    
                                       
                                          L
                                       
                                       
                                          i
                                       
                                    
                                 ) as the initial tracing point 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                 : 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                    =
                                    
                                       
                                          S
                                       
                                       
                                          i
                                       
                                    
                                 .

Set the value of 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                  as 0 and check the eight-neighbor of 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                 .

If there is one pixel 
                                    
                                       
                                          pt
                                       
                                       
                                          j
                                       
                                    
                                  with a value of 1, let 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                    =
                                    
                                       
                                          pt
                                       
                                       
                                          j
                                       
                                    
                                 , go to (2).

Else if there is no pixel with a value of 1, set the endpoint of the line segment 
                                    
                                       
                                          L
                                       
                                       
                                          i
                                       
                                    
                                 : 
                                    
                                       
                                          E
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                 , set the value of 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                  as 0.

Else if there is more than one pixel with a value of 1, which means 
                                    
                                       
                                          L
                                       
                                       
                                          i
                                       
                                    
                                  is one of the touching line segments, set the endpoint of the line segment 
                                    
                                       
                                          L
                                       
                                       
                                          i
                                       
                                    
                                 : 
                                    
                                       
                                          E
                                       
                                       
                                          i
                                       
                                    
                                    =
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                 , set the value of 
                                    
                                       
                                          pt
                                       
                                       
                                          s
                                       
                                    
                                  as 0.

After all the line segments have been checked, each pair of touching cell nuclei is represented by a pair of starting-point (
                           
                              
                                 S
                              
                              
                                 i
                              
                           
                        ) and endpoint (
                           
                              
                                 E
                              
                              
                                 i
                              
                           
                        ). These make up the original coordinate array of starting-points and endpoints (an SE array).

Naturally, the concave points segment the closed contour of the nuclei into different arcs. In the SE array, each endpoint on the contour must belong to a definite arc ending at a pair of concave points. Therefore, the endpoint can be adjusted to the concave point with less distance within this arc. In this paper, we utilize the contour point index and Euclidean distance to adjust the coordinates of the endpoints on the contour. In the implementation of our algorithm, the points of the contour are saved in an anticlockwise array, which starts at the leftmost point. We define the index of each point in this contour array as contour point index (CPI). For any point A on the contour, 
                           C
                           P
                           I
                           (
                           A
                           )
                         represents the index of the point A stored in the contour point array. Fig. 7
                         shows a sample adjustment of endpoints. If the endpoint is not on the contour like 
                           
                              
                                 E
                              
                              
                                 2
                              
                           
                        , it remains the original coordinates. Otherwise, the endpoint on the contour like 
                           
                              
                                 E
                              
                              
                                 1
                              
                           
                         should be adjusted to the nearest concave point.

For any endpoint pair assumed as 
                           
                              
                                 E
                              
                              
                                 1
                              
                           
                         and 
                           
                              
                                 E
                              
                              
                                 2
                              
                           
                        , 
                           
                              
                                 E
                              
                              
                                 1
                              
                           
                         is first adjusted by the following procedure. 
                           
                              
                                 E
                              
                              
                                 2
                              
                           
                         is adjusted in the same way.
                           
                              (1)
                              If the endpoint 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                  is not on the contour, the coordinate of 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                  is not adjusted and this procedure ends, else go to (2) to adjust 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                 .

Find the two concave points (assumed as 
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                  and 
                                    
                                       
                                          C
                                       
                                       
                                          2
                                       
                                    
                                 ) on the arc with 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                 .

Calculate the 
                                    CPI
                                  difference (DCPI) between each concave point 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    )
                                  and the endpoint 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                  (
                                    DCPI
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                    )
                                 ).

Calculate the Euclidean distance between each concave endpoint 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    )
                                  and the other endpoint 
                                    
                                       
                                          E
                                       
                                       
                                          2
                                       
                                    
                                  
                                 
                                    (
                                    ED
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          E
                                       
                                       
                                          2
                                       
                                    
                                    )
                                    )
                                 , and also the Euclidean distance between the two endpoints 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                  and 
                                    
                                       
                                          E
                                       
                                       
                                          2
                                       
                                    
                                  
                                 
                                    (
                                    ED
                                    (
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                    ,
                                    
                                       
                                          E
                                       
                                       
                                          2
                                       
                                    
                                    )
                                    )
                                 .

For each concave point 
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    
                                    (
                                    i
                                    =
                                    1
                                    ,
                                    2
                                    )
                                 , if it meets the following two conditions, it is selected as a candidate point:
                                    
                                       (a)
                                       
                                          
                                             DCPI
                                             (
                                             
                                                
                                                   C
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   E
                                                
                                                
                                                   1
                                                
                                             
                                             )
                                             <
                                             
                                                
                                                   Th
                                                
                                                
                                                   DCPI
                                                
                                             
                                          .


                                          
                                             ED
                                             (
                                             
                                                
                                                   C
                                                
                                                
                                                   i
                                                
                                             
                                             ,
                                             
                                                
                                                   E
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                             <
                                             ED
                                             (
                                             
                                                
                                                   E
                                                
                                                
                                                   1
                                                
                                             
                                             ,
                                             
                                                
                                                   E
                                                
                                                
                                                   2
                                                
                                             
                                             )
                                          .

If there are no candidate concave points, the coordinate of 
                                             
                                                
                                                   E
                                                
                                                
                                                   1
                                                
                                             
                                           is not adjusted and this procedure ends.

Else, if there is only one candidate concave point, adjust the endpoint 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                  to this concave point.

Else, if both are candidate concave points, adjust the endpoint 
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                  to the concave point with smaller 
                                    DCPI
                                    (
                                    
                                       
                                          C
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                       
                                          E
                                       
                                       
                                          1
                                       
                                    
                                    )
                                 .

In this procedure, DCPI is calculated as follows:
                           
                              (1)
                              
                                 DCPI
                                 (
                                 A
                                 ,
                                 B
                                 )
                                 =
                                 |
                                 
                                    CPI
                                    (
                                    A
                                    )
                                    −
                                    CPI
                                    (
                                    B
                                    )
                                 
                                 |
                                 .
                              
                           
                        The pre-set threshold 
                           
                              
                                 Th
                              
                              
                                 DCPI
                              
                           
                         is decided by the size of the cell nuclei, and we take 
                           
                              
                                 Th
                              
                              
                                 DCPI
                              
                           
                           =
                           15
                         in this paper.

After the adjustment, the endpoints can be located at the concave points on the contour to generate a more accurate splitting line. These adjusted endpoint pairs are the base of the shortest path algorithm.

The shortest path algorithm has been widely used in various applications [14–17], such as crack detection, road extraction, and stereo image matching. The algorithm searches for the shortest path in the Region of Interest (ROI) following a special cost function. In this paper, the shortest path technique is used to extract the accurate splitting line of touching cell nuclei. The implementation of the shortest path algorithm includes two main parts: (1) shortest path algorithm and (2) extraction of the ROI.

In our application, splitting the nuclei means finding a continuous edge line in a possible touching area. However, the edge is too weak to be found by general edge detectors [18,19]. Moreover, these edge detectors cannot ensure that the edge is a continuous line for splitting touching cell nuclei.

The shortest path algorithm [14,20] can be used to detect continuous lines. To find a path passing through the edge inside the possible touching area, we can simply design a cost function based on the gradient information to constrain the shortest path following the edge.

The cost function of one path is usually calculated on the trellis of a rectangular region, as shown in Fig. 8
                           . One path P on the trellis is a sequence of vertices represented by 
                              (
                              
                                 
                                    p
                                 
                                 
                                    1
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ,
                              …
                              ,
                              
                                 
                                    p
                                 
                                 
                                    m
                                 
                              
                              )
                           . 
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                            (
                              1
                              ≤
                              i
                              ≤
                              m
                           ) represents the position of path P in the ith layer, as shown in Fig. 7. For any path on the trellis, such as the red path in Fig. 7, the cost function is defined as
                              
                                 (2)
                                 
                                    C
                                    (
                                    P
                                    )
                                    =
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          m
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          0
                                       
                                    
                                    (
                                    i
                                    ,
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    )
                                    +
                                    
                                       
                                          ∑
                                       
                                       
                                          i
                                          =
                                          1
                                       
                                       
                                          m
                                          −
                                          1
                                       
                                    
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    (
                                    i
                                    ,
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    )
                                    .
                                 
                              
                           
                        


                           
                              
                                 
                                    C
                                 
                                 
                                    0
                                 
                              
                            is the object term of the cost function. 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                            is the constraint term of the cost function.

As the shortest path in our application is a line with a large gradient, 
                              
                                 
                                    C
                                 
                                 
                                    0
                                 
                              
                              (
                              i
                              ,
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              )
                            is defined as the inverse gradient value of the vertex (
                              i
                              ,
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                           ). In other words, the trellis used to calculate cost function is defined on the anti-gradient image to ensure the shortest path with the largest sum of gradients.

The first order of the cost function 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                            can be defined as a penalizing function of discontinuities in large fluctuations as follows:
                              
                                 (3)
                                 
                                    
                                       
                                          C
                                       
                                       
                                          1
                                       
                                    
                                    (
                                    i
                                    ,
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                       
                                    
                                    ,
                                    
                                    
                                       
                                          p
                                       
                                       
                                          i
                                          +
                                          1
                                       
                                    
                                    )
                                    =
                                    {
                                    
                                       
                                          
                                             
                                                0
                                             
                                             
                                                if
                                                
                                                |
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                   
                                                
                                                −
                                                
                                                   
                                                      p
                                                   
                                                   
                                                      i
                                                      +
                                                      1
                                                   
                                                
                                                |
                                                ≤
                                                1
                                             
                                          
                                          
                                             
                                                ∞
                                             
                                             
                                                otherwise
                                                .
                                             
                                          
                                       
                                    
                                 
                              
                           
                        


                           
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                            indicates that, if the vertices in layers i and 
                              i
                              +
                              1
                            disconnect from each other, 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                            will be 
                              ∞
                            and the path will not go through path (
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              ,
                              
                                 
                                    p
                                 
                                 
                                    i
                                 
                              
                              +
                              1
                           ). So, 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                            controls the connectivity of the path and ensures that the path is continuous. With the definitions of 
                              
                                 
                                    C
                                 
                                 
                                    0
                                 
                              
                            and 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                           , the shortest path can be obtained by minimizing the cost function 
                              C
                              (
                              P
                              )
                            with the dynamic programming algorithm [14,20]. Because of the object term 
                              
                                 
                                    C
                                 
                                 
                                    0
                                 
                              
                            and the constraint term 
                              
                                 
                                    C
                                 
                                 
                                    1
                                 
                              
                           , the calculated shortest path is not only a continuous line, but also lies on the edge.

According to the calculation of the shortest path, a rectangular region within an endpoint pair, named as the Region of Interest (ROI), should first be extracted. The length of the ROI is equal to the distance between the endpoints, and the width of the ROI depends on prior knowledge (the width is 11 pixels in this paper).


                           Fig. 9
                            exemplifies extraction of the ROI. The pictures in Fig. 9 are enhanced with higher contrast for better demonstration. Fig. 9(a) is the anti-gradient image, which is used for calculation of the shortest path. In Fig. 9(a), the ROI is marked by the green rectangle, in which S and E are the middle points of two opposite sides of the ROI. The ROI can be simply extracted from Fig. 9(a), as shown in Fig. 9(b). However, the extracted ROI is often not horizontal, which is not convenient for the calculation of the shortest path. Therefore, the ROI is horizontalized as shown in Fig. 9(c).

With the extracted ROI, the shortest path can be effectively obtained. However, the shortest path calculated in the ROI may yield some undesirable effects, such as not ending at the endpoint E, or even running outside the touching nuclei. To ensure that the shortest path passes the endpoints, the intensities of all points in the start and end boundaries except S and E are set as 
                              ∞
                            (see Fig. 10
                           ). Ideally the ROI should lie inside the contour, but in some cases the ROI introduces some pixels outside the contour because of its rigid shape constraint. Thus, the gray values outside the contour are also set as 
                              ∞
                           . Therefore, the shortest path algorithm can create a path at least cost, which not only passes through S and E but also lies inside the touching cell nuclei.

After finding the shortest path in the ROI, we rotate the shortest path to the opposite direction when obtaining the ROI. The S and E in the rotated shortest path are relocated on the original S and E. Consequently, the whole shortest path is connected to the original contour with the help of S and E. Because of the rotation and the interpolation of the shortest path image, the shortest path could become a slightly thick line rather than a single pixel line. To reduce the distortion, a morphological thinning operation [21,22] with default parameters is applied to the relocated shortest path. Then the final segmentation can be given as the closed contour of all separated nuclei. Fig. 11
                         shows the final segmentation result of the cell nuclei in Fig. 5. It demonstrates that the touching cell nuclei are segmented correctly and accurately.

We compared our algorithm with other algorithms quantitatively and qualitatively: widely used marker-based watershed algorithm [1,8,9,23] and the recently proposed two-step cell splitting algorithm [24]. The marker-based watershed algorithm uses the eroded binary image obtained by Otsu׳s method [25] as the marker image to obtain the splitting line by EDT. The two-step cell splitting algorithm [24] proposes a practical method to obtain the touching area more accurately and follows an efficient concave point matching rule for segmentation. All algorithms are tested on two image sets containing 56 images and 6374 cell nuclei totally. The images used are fluorescence images from DNA stained HeLa cells which were imaged on a Zeiss fluorescence microscope at 20×magnification. And the sizes of the cells are ranging from 2 to 10 μm. However, the absolute scale information could not be obtained from the original collaborator. Thus the exact scale of each cell nucleus could not be given. But, this would not affect the performance of our algorithm. Our algorithm has been verified on these cells with different sizes, and experimental results show that our algorithm obtains better results. Some examples are shown below.


                     Fig. 12
                      shows two touching cell nuclei. The nuclei have clear concave points on the contours and a clear edge in the touching areas. For the cell nuclei in the first row, all algorithms give good contours and correct segmentation of touching areas. However, only our algorithm achieves good visual effect for the example in the second row. This indicates that our algorithm is robust and can segment various types of touching nuclei. Both the watershed-based algorithm and the two-step cell splitting algorithm give the correct number of nuclei for this case, but neither is accurate and robust enough.


                     Fig. 13
                      is the result of incomplete nuclei touching each other at the image boundary. This kind of touching area usually has only one valid concave point. In this case, the watershed-based algorithm and the two-step cell splitting algorithm cannot give an accurate splitting line. However, our algorithm obtains a reasonable splitting line, which accurately follows the edge of the touching cell nuclei. Because our algorithm utilizes not only the contour information, but also the gray value distribution inside the touching area.

In Fig. 14
                     , the nuclei touch each other strongly. These nuclei do not have enough obvious concave points and the boundaries inside the touching area are not clear. In this case, only our algorithm gives an accurate splitting line. The eroded Otsu binary image cannot obtain the right number and accurate positions of the markers for EDT. Thus, the watershed-based algorithm generates a bad splitting result. The two-step cell splitting algorithm only finds the obvious concave points, and adds extra points for matching. When the contour of the touching cell nuclei is not accurate enough to obtain obvious concave points, it fails to achieve the correct segmentation. Based on the accurate contour generated by the watershed transform and the original gray value distribution, our algorithm splits the touching cell nuclei well.


                     Fig. 15
                      shows a complex case with multiple nuclei touching each other. The binary image obtained by Otsu׳s method cannot be eroded to the markers with the right number and position, so it obtains no accurate splitting lines and has many over-segmentations. As the curvature of the concave points on the contour is very small, the two-step cell splitting algorithm could not obtain enough effective concave points for segmentation. Moreover, the two-step cell splitting algorithm is based on point pair matching, and it cannot deal effectively with complex cases, such as the example shown in Fig. 15. In contrast, our algorithm achieves a satisfactory segmentation.

More comparison results are shown in Fig. 16
                     . Our algorithm works well in all conditions, especially in strongly touching and multiple touching cell nuclei.

All experiments are performed on 56 images measuring 512×512 or 1034×1382 pixels on a PC (CPU: Inter Core i5 quad-core 3.2GHz, RAM: 4.0 GB). The average running time of our algorithm is 4.14s per image. Three measures are calculated in [11] to compare the three algorithms for the number of segmented nuclei. We name the number of correctly detected nuclei N
                     
                        c
                     , the number of not detected nuclei N
                     
                        n
                     , the number of false alarm N
                     
                        f
                      and the total number N
                     
                        all
                     . The three measures PCD, PND and PFA can be defined as 
                        PCD
                        =
                        
                           
                              N
                           
                           
                              c
                           
                        
                        /
                        
                           
                              N
                           
                           
                              all
                           
                        
                     , 
                        PND
                        =
                        
                           
                              N
                           
                           
                              n
                           
                        
                        /
                        
                           
                              N
                           
                           
                              all
                           
                        
                      and 
                        PFA
                        =
                        
                           
                              N
                           
                           
                              f
                           
                        
                        /
                        
                           
                              N
                           
                           
                              all
                           
                        
                     . The comparison results are listed in Table 1
                     .

In Table 1, we can see that our algorithm has the greatest PCD and the lowest PFA at the same time. To validate the efficiency of our algorithm, a paired-sample t test is performed. The statistical results of the t test are listed in Table 2
                     . Take D
                     
                        PCD
                      as an example, W
                     
                        i
                      is the difference in PCDs in the ith image, S
                     
                        W
                      is the sample variance of W, and T is calculated as 
                        
                           
                              W
                           
                           
                              ¯
                           
                        
                        /
                        (
                        
                           
                              S
                           
                           
                              W
                           
                        
                        /
                        
                           
                              n
                           
                        
                        )
                     . To carry out the t test, we firstly define X and Y as the PCD of our algorithm and the PCD of one compared algorithm, respectively. The hypotheses for a one-sided paired-sample t-test can be given as below:
                        
                           (1)
                           
                              H
                              0: X=Y, there is no significant difference between the PCDs of the compared algorithm and our algorithm.


                              H
                              1: 
                                 X
                                 >
                                 Y
                              , our algorithm yields higher PCD than the compared algorithm.

At the significance level (
                        α
                        =
                        0.01
                     ), all p-values are very low. The t-test result indicates that our result is significantly better in terms of PCD, PND and PFA than the other two algorithms. The highest PCD level (90.87%) proves that our algorithm has correctly detected most of the nuclei. The lowest PFA level (1.30%) means that our algorithm produces the fewest false alarms. The watershed-based algorithm leads to high PFA, which means this algorithm may produce many over-segmentations. The two-step cell splitting algorithm cannot give splitting lines of strongly touching and multiple touching cell nuclei, which leads to under-segmentations. Our algorithm obtains appropriate splitting lines in most cases, the final splitting lines are located at the edge inside the touching area.

To validate the accuracy of the contour of our algorithm, two measures are calculated to compare the single nucleus contour of four algorithms including the ellipse fitting-based algorithm [11]. One is the possibility of correctness (PC), which is the area included in both the result and the ground truth divided by the whole area of the nucleus in the ground truth. The other is the possibility of efficiency (PE), which is the area included in both the result and the ground truth divided by the whole area of the nucleus in the result image. A high PC level means the area of each nucleus in ground truth is mostly detected by our algorithm. A high PE level means most of the area detected by our algorithm belongs to the nuclei in the ground truth. The ground truth reference nuclei image for contour measurement is provided by manual segmentations by the researchers in our group. Moreover, we add the comparison with the ellipse fitting method which is from our previous ellipse fitting algorithm [11]. The statistical results of contour measurement are listed in Table 3
                     .

Compared with the other algorithms, our algorithm achieves the highest PC (93.25%) and PE (89.16%) levels. This indicates that our results have covered most of the nuclei while introducing the least background, and are superior to other algorithms. In this paper, the complete contour of a nucleus is made up of touching nuclei contour and splitting lines. With the help of watershed and shortest path algorithms, a good continuous contour of nucleus can be obtained by our algorithm. Thus, our algorithm can perform well regarding the segmentation of touching cell nuclei and its performance is better than that of other algorithms.

@&#CONCLUSIONS@&#

In this paper, we proposed a new algorithm based on ellipse fitting and the shortest path. The correct position and the number of markers generated by the ellipse fitting algorithm [11] ensure that the PCD, PFA and PND are at a good level. The shortest path algorithm can find an optimal path through the endpoints, which contributes to a high level of PC and PE. Compared with the watershed-based algorithm and the two-step cell splitting algorithm, our algorithm yields better results quantitatively and qualitatively.

None declared.

@&#ACKNOWLEDGMENTS@&#

We thank all the reviewers for their constructive comments and suggestions. A preliminary version of this paper was presented in [12]. This work was partly supported by the National Natural Science Foundation of China (Grant no. 61271023), Fundamental Research Funds for the Central Universities (YWF-14-YHXY-029), 863 Program (2012AA02A606), and Beijing Key Laboratory of Digital Media, Beihang University.

@&#REFERENCES@&#

