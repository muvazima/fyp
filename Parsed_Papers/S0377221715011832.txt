@&#MAIN-TITLE@&#Increasing the revenue of self-storage warehouses by optimizing order scheduling

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We consider order acceptance for self-storage warehouses to maximize revenue.


                        
                        
                           
                           We model warehouse operations as scheduling n independent multiprocessor tasks.


                        
                        
                           
                           We propose a column generation and a branch-and-price method.


                        
                        
                           
                           Our algorithm can significantly increase the revenue of self-storage warehouses.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Scheduling

Self-storage warehouse

Multiprocessor task scheduling

Column generation

Branch-and-price

@&#ABSTRACT@&#


               
               
                  We consider a self-storage warehouse, facing storage orders for homogeneous or heterogeneous storage units over a certain time horizon. The warehouse operations manager needs to decide which storage orders to accept and schedule them across different storage units to maximize revenue. We model warehouse operations as scheduling n independent multiprocessor tasks with given start and end times, with an objective to maximize revenue. With operational constraints like the maximal upscaling level, precedence order constraints, and maximal idle time, the established mixed-integer program cannot be efficiently solved by commercial softwares. We therefore propose a column generation approach and a branch-and-price method to find an optimal schedule. Computational experiments show that, compared with current methods in self-storage warehouses, our method can significantly increase the revenue.
               
            

@&#INTRODUCTION@&#

Our research is inspired by Shurgard (see shurgard.eu), an international corporation providing warehousing services to both family and business customers. Shurgard and Public Storage (see publicstorage.com) are among the largest corporations in an industry called self-storage warehousing, a considerable industry in the world. By the end of 2013, there were approximately 59,500 self-storage facilities worldwide. In the United States, for example, the national Self Storage Association (SSA) estimates that the self-storage industry had total gross revenues of about $24 billion (USD) in 2013, and “8.96 percent of all American households currently rent a self storage unit” (see 2013-2014 self-storage fact sheet report, selfstorage.org).

By adopting a self-storage operation protocol (customers handle storage operations by themselves), Shurgard successfully controls its cost, and the revenue is the major concern. To increase the revenue of a self-storage warehouse, Gong, De Koster, Frenk, and Gabor (2013) deal with facility design problems. Our paper handles facility operations problems given a facility design.

Shurgard provides storage units in different sizes. Customers can rent a storage unit for a certain period of time (measured by months). The rent depends primarily on the size of the storage units. At the beginning of a storage decision horizon (one to four months), a new storage plan is made. For Shurgard, most storage order requests for the coming two or three months are known at the beginning of a storage decision horizon since customers usually book the storage units with a lead time. Therefore we focus in this paper on the offline scheduling problem. However, the method we develop is sufficiently fast to allow rescheduling for new order arrivals. Offline scheduling is also justified due to the dynamic pricing strategy of self-storage warehouses. In this respect, self-storage warehousing has some similarity with revenue management in other industries (see Phillips, 2005). Customers who reserve storage space ahead of time obtain a discounted price, whereas last minute renting involves premium prices. This strategy changes customer behavior and customers will make reservations ahead of time.

To specify the research problem and understand the problem background, we visited 61 self-storage warehouses (see the Appendix, Table 6) in the USA, Europe, and Asia, between December 2007 and June 2013. We collected price, design, and demand information, and interviewed managers, customers, and laborers. It appears the operation modes are highly dependent on the geographical location. According to the 2013-2014 self-storage fact sheet report, “the distribution of U.S. self storage facilities (Q4-2013) is as follows: 32 percent urban, 52 percent suburban and 16 percent rural” (see selfstorage.org).

Among the 61 warehouses we visited, 19.7 percent are located in or close to city centers. These warehouses are inclined to reject customers when capacity is fully occupied as demand appears to be abundant. A total of 68.9 percent of the warehouses (could be urban, suburban, and rural) attempt to upscale customers when the desired storage types are fully occupied, and 11.4 percent facilities are commonly located in inappropriate places (e.g., remote outskirts) with low demand. This paper primarily considers the first two facility types, since a warehouse with low demand may need to consider relocation, which is another academic field (see, e.g., Wesolowsky, 1973).

The main decision of a self-storage warehouse manager is to decide which new order to accept and which not to accept, given the current occupation of the warehouse. The storage decision relies on the revenue an order can generate for the warehouse, the duration of the order, and the requested storage types. The decision also depends on the current occupation of the warehouse. It is usually not possible to allocate currently occupied storage rooms for future demand, as customers can extend their contracts. Therefore, in the decision, only currently available storage rooms (or storage units) are included. If demand cannot be satisfied, two options will be adopted, dependent on demand status of warehouses: (1) In an area with high demand, orders are rejected when warehouses are fully occupied. We call this research problem as basic problem. (2) In most cases, there may be more alternatives for the customer. For example, a larger storage unit can be offered by the manager to the customer at the lower price. We call this problem the upscaling problem.

We model the problem as a deterministic scheduling problem and regard each storage unit (in the Shurgard case, there are several heterogeneous storage types, each of which contains multiple homogeneous storage units ) as a machine, with arrival orders as jobs, and model the decision problem as a fixed-interval multiprocessor task scheduling problem. The fixed interval means we consider orders with given start and end times. Each order will generate a given revenue. The scheduling objective is to maximize the total revenue by a decision whether to accept an order or not over a finite horizon. Our models are particularly fit for the facilities with high demand, and less suitable for the facilities with low demand.

We show that the problem in self-storage warehouses can be solved rather efficiently by a branch-and-price algorithm with a column generation approach. The algorithms can be applied to similar problems emerging in other business contexts.

The remainder of the paper is organized as follows: In the following section, we conduct a literature review. In Section 3, we describe the research problem. In Section 4, we present an integer program model. In Section 5, we present analysis and algorithms, including the upscaling model and its solution. Section 6 shows computational results and experiments. We conclude with our contribution and suggestion for further research in Section 7.

@&#LITERATURE REVIEW@&#

This paper uses approaches from multiprocessor task scheduling problems in which multiprocessor tasks require more than one processor at the same time. Drozdowski (1996) shows the rationale behind the concept of multiprocessor tasks and presents the results in multiprocessor task scheduling both for parallel and for dedicated processors. Brucker and Kramer (1996) present polynomial algorithms for resource-constrained and multiprocessor task scheduling problems. Our research is also related to fixed interval scheduling problems in which each job has a finite number of fixed processing intervals. Kovalyov, Ng, and Cheng (2007) review the models, applications, computational complexity, and algorithms of such interval scheduling problems.

Four subproblems in our paper are directly related to the following research.

                           
                              (1)
                              When n orders request homogeneous storage types only, the problem can be viewed as a fixed-interval multiprocessor task scheduling problem. In this formulation, a storage unit is regarded as a machine, and orders are regarded as jobs. One order requires one storage unit at a time. For this case, Arkin and Silverberg (1987) have shown that the problem can be transformed into a minimum cost flow problem and can be solved to optimality by an O(n
                                 2log n) algorithm.

When n storage types are heterogeneous and upscaling operations are allowed, Kolen, Lenstra, and Papadimitriou (1987) show that the problem is strongly NP-hard if there are three or more storage types. They employ a reduction from “numerical 3-dimensional matching.” Kolen and Kroon (1991) further show that the problem still is strongly NP-hard if there are only two storage types. The reduction is also from “numerical 3-dimensional matching.” Carter and Tovey (1992) discuss problem variants in classroom assignments.

If the storage types are non-identical but have no monotonic preference (i.e., job j can be processed on a subset 
                                    
                                       M
                                       j
                                    
                                  of all machines), the problem becomes more general and was shown to be strongly NP-hard by Arkin and Silverberg (1987). They also presented an 
                                    
                                       O
                                       (
                                       
                                          n
                                          
                                             m
                                             +
                                             1
                                          
                                       
                                       )
                                    
                                  algorithm that can solve the problem to optimality, where m is the number of total storage units. Their algorithm can be used for the problem with monotonic preference, but is not sufficiently efficient when m is large. For the general problem, Kroon, Salomon, and Van Wassenhove (1995) develop a fast near-optimal algorithm tailored for solving real-life instances for the maintenance department of KLM at Schiphol Airport.

If one order requires multiple storage units, the problem is generally NP-hard since it contains the NP-hard knapsack problem as a special case. Chen, Hassin, and Tzur (2002) develop a dynamic programming algorithm with time complexity of 
                                    
                                       O
                                       (
                                       
                                          n
                                          
                                             m
                                             +
                                             1
                                          
                                       
                                       )
                                       ,
                                    
                                  which can solve this case to optimality for any fixed m, but it effectively works only for a small m. They obtain a 1/3-approximation in the special case where the profit of each task j equals 
                                    
                                       
                                          (
                                          
                                             e
                                             j
                                          
                                          −
                                          
                                             b
                                             j
                                          
                                          )
                                       
                                       
                                          s
                                          j
                                       
                                       ,
                                    
                                  where sj
                                  is the number of units required by task j. Using different ideas, Bar-Noy, Bar-Yehuda, Freund, Naor, and Schieber (2001) show a 1/3-approximation for arbitrary weights.

For integer programs with a very large number of variables, column generation, using implicit pricing of nonbasic variables to generate new columns or to prove optimality of LP at a node of the branch-and-bound tree, is an efficient approach (Barnhart, Johnson, Nemhauser, Savelsbergh, & Vance, 1998). Gamrath (2010) develops a generic branch-cut-and-price solver GCG, and presents its theoretical background, implementational details and computational results. Column generation and branch-and-price algorithms have been employed to solve problems in vehicle routing (see Mourgaya and Vanderbeck, 2007; Tas, Gendreau, Dellaert, Van Woensel, and De Kok, 2014) and personnel scheduling (Van den Bergh, Belien, De Bruecker, Demeulemeester, & De Boeck, 2013), among others.

Column generation and branch-and-price algorithms have been applied to several fields close to this research. Mestry, Damodaran, and Chen (2011) use a branch-and-price approach for order acceptance and capacity planning in make-to-order operations. Our research is not for a make-to-order environment, but it considers capacity flexibility in self-storage service. Parallel machine scheduling, another field close to our research, has been solved by column generation (Van den Akker, Hoogeveen, & Van De Velde, 1999). Van den Akker, Hoogeveen, and Van Kempen (2012) use column generation to solve parallel machine scheduling problems with minmax objective functions.

Our research is related to the topic of order acceptance and scheduling. Slotnick (2011) presents a taxonomy and a review of the literature of order acceptance, categorizes its contributions, and shows that the main trade-off in the topic of order acceptance is between the revenue brought in by a particular order and all of its associated costs of processing.

Our research also relates to resource allocation problems, such as call center operator scheduling, airline crew scheduling, and nurse scheduling (see Gans, Koole, & Mandelbaum, 2003). Different from them, we mainly consider storage space allocation (see Tompkins, White, Bozer, & Tanchoco, 2003). However, traditional storage space allocation models mainly consider a trade-off between high space utilization and warehouse operation productivity (e.g., in a forward-reserve storage system). Our storage space allocation aims at achieving the maximal revenue with a storage resource restriction.

Another paper related to ours is Lee, Çetinkaya, and Jaruphongsa (2003), which employs scheduling techniques in a third-party warehouse study and focuses on inventory management. However, the main objective of our paper differs. We focus on increasing revenue since this is the main concern in self-storage.

In self-storage warehouses, managers make storage plans like a monthly, a bi-monthly, or a quarterly storage plan, depending on the decision horizons. We call this planning horizon the “storage decision horizon.” The storage plan considers the requests that have arrived in the previous period.

In the paper, we employ the following general notations and, without loss of generality, we assume that all the aforementioned variables (numbers) are integers.


                     m: the total number of currently available storage units;


                     n: the total number of storage orders (jobs);


                     i: the storage type, 
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           K
                        
                     ;


                     K: the total number of storage types;


                     j: the jth order, 
                        
                           j
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     ;


                     
                        J
                     : the order set 
                        
                           {
                           1
                           ,
                           …
                           ,
                           n
                           }
                        
                     ;


                     
                        F
                     : the set of family orders;


                     
                        B
                     : the set of business orders;


                     bj
                     : the fixed start time of the storage period of order j;


                     ej
                     : the fixed end time of the storage period of order j;


                     cj
                     : the storage type required by order j;


                     ni
                     : the number of orders that request storage type i;


                     mi
                     : the number of storage units in type i;


                     rj
                     : the revenue generated by order j;


                     U: the maximum total number of upscaled orders;


                     γ: the maximum number of upscaling levels for an order;


                     L: the maximum idle time limit between two adjacent orders.

At the beginning of each storage decision horizon, managers examine all current orders and only consider orders with a storage start time within the examined storage decision horizon. If a warehouse accepts an order j for storage reservation, it can collect a positive revenue rj
                     , for 
                        
                           j
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     . Declining a storage reservation does not lead to costs. Each job j has a fixed start time bj
                      with T
                     0 ≤ bj
                      ≤ Te
                      and a fixed end time cj
                     , for 
                        
                           j
                           =
                           1
                           ,
                           …
                           ,
                           n
                        
                     . Each storage unit can only serve one order in a period. To avoid dissatisfying customers, the warehouse does not allow the preemption of any occupied storage. The warehouse processes each order once or not at all. The main management decision in the warehouse storage plan is to find a feasible subset of the orders to maximize the total revenue. If all storage units are homogeneous, we can solve the problem by existing algorithms (Arkin & Silverberg, 1987). But warehouses in the real world usually have many classes of storage units with different sizes.

In this paper, we consider a self-storage warehouse offering m available storage units of K heterogeneous storage types (or classes). For storage type i, the warehouse provides mi
                      homogeneous storage units, for 
                        
                           i
                           =
                           1
                           ,
                           …
                           ,
                           K
                           ,
                        
                      with 
                        
                           
                              ∑
                              i
                           
                           
                              m
                              i
                           
                           =
                           m
                        
                     . In an environment with moderate demand, warehouse managers may adopt upscaling operations to improve operational flexibility and revenue. In an upscaling operation, a self-storage warehouse uses higher-class storage units to meet a request for lower-class storage units. Note that lower-class storage units are always smaller than higher-class storage units. To maximize the revenue, managers examine all current orders and decide which orders should be accepted with or without upscaling.

Warehouse managers may also consider specific operational constraints to facilitate warehouse management or increase revenues. All of the following constraints are incorporated into this approach.

                        
                           (i)
                           Total number of upscaling operations. An upscaled order means a possible inefficient use of a storage unit and potential loss of revenues in the future. So, managers may set a limit U on the total number of upscaled orders in a storage plan.

Maximum number of upscaling levels. If space differences between the smallest and largest storage types are large, managers usually apply a limit γ on the maximum number of upscaling levels. For example, an upscaling operation may be limited to one level only (i.e., an order requiring storage type i can only be upscaled to storage type 
                                 
                                    i
                                    +
                                    1
                                 
                              ).

Precedence constraints on family and business orders. Orders for storage units can be divided into two categories: family orders and business orders. The division is based on the customer type. Companies with business orders often extend their storage contracts at the end of storage periods, while family customers seldom do this. Therefore, warehouse managers prefer scheduling a business order after a family order, not vice versa.

Maximum idle time L between two accepted orders. Idle time between two consecutive orders usually means waste. To increase the utilization of storage units, managers may apply a maximal idle time constraint in developing a storage plan.

In this section, we present a 0–1 integer program model for the self-storage warehouse order scheduling problem. This model is used for comparative purposes in our computational study. We reformulate the problem as a set covering formulation in next section and develop a branch-and-price algorithm in Section 5.

Our decision variables are 
                           
                              
                                 x
                                 
                                    j
                                    k
                                 
                                 i
                              
                              ∈
                              
                                 {
                                 0
                                 ,
                                 1
                                 }
                              
                              .
                           
                        
                        
                           
                              
                                 x
                                 
                                    j
                                    k
                                 
                                 i
                              
                              =
                              1
                           
                         if and only if order j is assigned to storage unit k in storage type i, 
                           
                              ∀
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                              ,
                              j
                              =
                              1
                              ,
                              …
                              ,
                              n
                              ,
                              k
                              =
                              1
                              ,
                              …
                              ,
                              
                                 m
                                 i
                              
                           
                        .

We assume jobs are sorted by nondecreasing start times bj
                        . The 0–1 integer program model is formulated as follows:

                           
                              (1)
                              
                                 
                                    
                                       Z
                                       
                                          (
                                          I
                                          P
                                          )
                                       
                                    
                                    =
                                    max
                                    
                                       ∑
                                       
                                          {
                                          j
                                          |
                                          1
                                          ≤
                                          j
                                          ≤
                                          n
                                          }
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          {
                                          i
                                          |
                                          
                                             c
                                             j
                                          
                                          ≤
                                          i
                                          ≤
                                          
                                             c
                                             j
                                          
                                          +
                                          γ
                                          ∧
                                          i
                                          ≤
                                          R
                                          }
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          {
                                          k
                                          |
                                          1
                                          ≤
                                          k
                                          ≤
                                          
                                             m
                                             i
                                          
                                          }
                                       
                                    
                                    
                                       r
                                       j
                                    
                                    
                                       x
                                       
                                          j
                                          k
                                       
                                       i
                                    
                                 
                              
                           
                        subject to

                           
                              (2)
                              
                                 
                                    
                                       ∑
                                       
                                          {
                                          i
                                          |
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                          }
                                       
                                    
                                    
                                       ∑
                                       
                                          {
                                          k
                                          |
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          
                                             m
                                             i
                                          
                                          }
                                       
                                    
                                    
                                       x
                                       
                                          j
                                          k
                                       
                                       i
                                    
                                    ≤
                                    1
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    j
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    n
                                    ,
                                 
                              
                           
                        
                        
                           
                              (3)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   {
                                                   u
                                                   ∈
                                                   
                                                      P
                                                      j
                                                   
                                                   }
                                                
                                             
                                             
                                                ∑
                                                
                                                   {
                                                   k
                                                   |
                                                   1
                                                   ≤
                                                   k
                                                   ≤
                                                   
                                                      m
                                                      i
                                                   
                                                   }
                                                
                                             
                                             
                                                x
                                                
                                                   u
                                                   k
                                                
                                                i
                                             
                                             ≤
                                             
                                                m
                                                i
                                             
                                             ,
                                             
                                             for
                                             
                                             each
                                             
                                             j
                                             =
                                             1
                                             ,
                                             ⋯
                                             ,
                                             n
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             and
                                             
                                             
                                                c
                                                j
                                             
                                             ≤
                                             i
                                             ≤
                                             
                                                c
                                                j
                                             
                                             +
                                             γ
                                             ∧
                                             i
                                             ≤
                                             R
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (4)
                              
                                 
                                    
                                       ∑
                                       
                                          {
                                          j
                                          |
                                          1
                                          ≤
                                          j
                                          ≤
                                          n
                                          }
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          {
                                          i
                                          |
                                          
                                             c
                                             j
                                          
                                          +
                                          1
                                          ≤
                                          i
                                          ≤
                                          
                                             c
                                             j
                                          
                                          +
                                          γ
                                          ∧
                                          i
                                          ≤
                                          R
                                          }
                                       
                                    
                                    
                                       ∑
                                       
                                          {
                                          k
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          
                                             m
                                             i
                                          
                                          }
                                       
                                    
                                    
                                       x
                                       
                                          j
                                          k
                                       
                                       i
                                    
                                    ≤
                                    U
                                    ,
                                 
                              
                           
                        
                        
                           
                              (5)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                x
                                                
                                                   j
                                                   k
                                                
                                                i
                                             
                                             +
                                             
                                                x
                                                
                                                   h
                                                   k
                                                
                                                i
                                             
                                             ≤
                                             1
                                             ,
                                             for
                                             
                                             each
                                             
                                             pair
                                             
                                             of
                                             
                                             jobs
                                             
                                             j
                                             ∈
                                             B
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             and
                                             
                                             h
                                             ∈
                                             
                                                A
                                                j
                                             
                                             ,
                                             
                                             k
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             
                                                m
                                                i
                                             
                                             ,
                                             
                                             
                                                c
                                                j
                                             
                                             ≤
                                             i
                                             ≤
                                             
                                                c
                                                j
                                             
                                             +
                                             γ
                                             ∧
                                             i
                                             ≤
                                             R
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                (
                                                
                                                   x
                                                   
                                                      h
                                                      k
                                                   
                                                   i
                                                
                                                +
                                                
                                                   x
                                                   
                                                      l
                                                      k
                                                   
                                                   i
                                                
                                                )
                                             
                                             −
                                             
                                                ∑
                                                
                                                   {
                                                   j
                                                   |
                                                   h
                                                   <
                                                   j
                                                   <
                                                   l
                                                   }
                                                
                                             
                                             
                                                x
                                                
                                                   j
                                                   k
                                                
                                                i
                                             
                                             ≤
                                             1
                                             ,
                                             for
                                             
                                             each
                                             
                                             h
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             n
                                             ,
                                             k
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             
                                                m
                                                i
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                                c
                                                h
                                             
                                             ≤
                                             i
                                             ≤
                                             
                                                c
                                                h
                                             
                                             +
                                             γ
                                             ∧
                                             i
                                             ≤
                                             R
                                             
                                             and
                                             
                                             l
                                             ∈
                                             
                                                L
                                                h
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             
                                                x
                                                
                                                   j
                                                   k
                                                
                                                i
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             ,
                                             
                                             for
                                             
                                             each
                                             
                                             j
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             n
                                             ,
                                             
                                             and
                                             
                                             k
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             
                                                m
                                                i
                                             
                                             ,
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             and
                                             
                                             
                                                c
                                                j
                                             
                                             ≤
                                             i
                                             ≤
                                             
                                                c
                                                j
                                             
                                             +
                                             γ
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The objective function (1) maximizes the total revenue collected from the accepted jobs.

Constraints (2) state that each order is stored at most once.

Constraints (3) guarantee that the number of orders stored in parallel by storage units in type i never exceeds mi
                         at any time point during the storage decision horizon. We define order set 
                           
                              
                                 P
                                 j
                              
                              =
                              
                                 {
                                 k
                                 |
                              
                              
                                 b
                                 k
                              
                              ≤
                              
                                 e
                                 j
                              
                              ,
                              
                                 b
                                 j
                              
                              ≤
                              
                                 e
                                 k
                              
                              
                                 ,
                                 |
                              
                              
                                 c
                                 j
                              
                              −
                              
                                 c
                                 k
                              
                              
                                 |
                                 ≤
                                 γ
                                 ,
                                 k
                                 ∈
                                 J
                                 }
                              
                              ,
                           
                         for each 
                           
                              j
                              =
                              1
                              ,
                              …
                              ,
                              n
                              ,
                           
                         so that 
                           
                              P
                              j
                           
                         contains all parallel orders of order j, which have crossover processing time with order j and can be assigned to the same storage type.

Constraint (4) ensures that the total number of upscaled orders is bounded by U. If an order j requires storage type cj
                         and is assigned to storage type 
                           
                              
                                 c
                                 j
                              
                              +
                              k
                           
                         and 1 ≤ k ≤ γ, the order j is then called an upscaled order.

Constraints (5) guarantee that each business job is not followed by a family job. Here, we define order set 
                           F
                         containing all family orders and order set 
                           B
                         containing all business orders. Therefore, we have 
                           
                              J
                              =
                              F
                              ∪
                              B
                           
                        . We call orders 
                           
                              j
                              ∈
                              B
                           
                         and 
                           
                              k
                              ∈
                              F
                           
                         for which k > j incompatible. We define order set 
                           
                              
                                 A
                                 j
                              
                              =
                              
                                 {
                                 k
                                 |
                                 k
                                 >
                                 j
                                 
                                 and
                                 
                                 k
                                 ∈
                                 F
                                 }
                              
                           
                         for 
                           
                              j
                              ∈
                              B
                              ,
                           
                         so that 
                           
                              A
                              j
                           
                         contains all the incompatible orders of order j, which have a greater start time.

Constraints (6) ensure that idle time between any two adjacent orders for the same storage unit does not exceed the maximum idle time limit L. We define that order l is a long-distance order of h(l > h) if 
                           
                              
                                 b
                                 l
                              
                              −
                              
                                 e
                                 h
                              
                              >
                              L
                           
                        . We define order set 
                           
                              
                                 L
                                 h
                              
                              =
                              
                                 {
                                 l
                                 |
                                 l
                                 >
                                 h
                                 ,
                                 
                                    b
                                    l
                                 
                                 −
                                 
                                    e
                                    h
                                 
                                 >
                                 L
                                 
                                 and
                                 
                                 
                                    [
                                    
                                       c
                                       h
                                    
                                    ,
                                    
                                       c
                                       h
                                    
                                    +
                                    γ
                                    ]
                                 
                                 ∩
                                 
                                    [
                                    
                                       c
                                       l
                                    
                                    ,
                                    
                                       c
                                       l
                                    
                                    +
                                    γ
                                    ]
                                 
                                 ≠
                                 ∅
                                 }
                              
                           
                         for 
                           
                              h
                              =
                              1
                              ,
                              …
                              ,
                              n
                              ,
                           
                         so that 
                           
                              L
                              h
                           
                         contains all the long-distance orders of order h, which can be assigned to the same storage types. For two orders h and l and a given storage unit k in type i, the constraints (6) contain two parts: 
                           
                              (
                              
                                 x
                                 
                                    h
                                    k
                                 
                                 i
                              
                              +
                              
                                 x
                                 
                                    l
                                    k
                                 
                                 i
                              
                              )
                           
                         and 
                           
                              
                                 ∑
                                 
                                    {
                                    j
                                    |
                                    h
                                    <
                                    j
                                    <
                                    l
                                    }
                                 
                              
                              
                                 x
                                 
                                    j
                                    k
                                 
                                 i
                              
                           
                        . If 
                           
                              
                                 ∑
                                 
                                    {
                                    j
                                    |
                                    h
                                    <
                                    j
                                    <
                                    l
                                    }
                                 
                              
                              
                                 x
                                 
                                    j
                                    k
                                 
                                 i
                              
                              =
                              0
                              ,
                           
                         we have the constraint 
                           
                              (
                              
                                 x
                                 
                                    h
                                    k
                                 
                                 i
                              
                              +
                              
                                 x
                                 
                                    l
                                    k
                                 
                                 i
                              
                              )
                              ≤
                              1
                           
                        . These mean that if there are no orders accepted between h and l, then we cannot accept both h and l at the same time since Jl
                         is an order with a long distance from h. If 
                           
                              
                                 ∑
                                 
                                    {
                                    j
                                    |
                                    h
                                    <
                                    j
                                    <
                                    l
                                    }
                                 
                              
                              
                                 x
                                 
                                    j
                                    k
                                 
                                 i
                              
                              ≥
                              1
                              ,
                           
                        
                        
                           
                              (
                              
                                 x
                                 
                                    h
                                    k
                                 
                                 i
                              
                              +
                              
                                 x
                                 
                                    l
                                    k
                                 
                                 i
                              
                              )
                           
                         can have any value. This means that if there are some orders assigned between jobs h and l, then there are no additional constraints on the selection of h and l.

The 0–1 integer programming formulation is difficult to be solved, due to the large number of binary variables and constraints in our real problems. An example warehouse has 213 storage units divided over 8 types and 1391 orders per year, resulting in nearly 300,000 variables.

In the next section we therefore present a set covering formulation which can be solved by a branch-and-price algorithm and greatly improve the efficiency of searching an optimal solution.

To get the set covering formulation, we define a storage schedule as a string of jobs that can be assigned together to any single storage unit during the planning period [T
                        0, Te
                        ]. Let 
                           
                              a
                              
                                 j
                                 s
                              
                              i
                           
                         be a constant that is equal to 1 if order j is included in storage schedule s for storage type i; otherwise, 
                           
                              a
                              
                                 j
                                 s
                              
                              i
                           
                         is equal to 0, for 
                           
                              i
                              =
                              1
                              ,
                              ⋯
                              ,
                              K
                           
                        . Accordingly, the column vector 
                           
                              
                                 (
                                 
                                    a
                                    
                                       1
                                       s
                                    
                                    i
                                 
                                 ,
                                 ⋯
                                 ,
                                 
                                    a
                                    
                                       n
                                       s
                                    
                                    i
                                 
                                 )
                              
                              T
                           
                         represents the jobs in the storage schedule s for storage type i. The revenue 
                           
                              R
                              s
                              i
                           
                         of storage schedule s in type i is computed as 
                           
                              
                                 R
                                 s
                                 i
                              
                              =
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 r
                                 j
                              
                              
                                 a
                                 
                                    j
                                    s
                                 
                                 i
                              
                           
                        . We define 
                           
                              u
                              j
                              i
                           
                         to be a constant that is equal to 1 if order j is an upscaled order in storage i for 
                           
                              j
                              =
                              1
                              ,
                              …
                              ,
                              n
                           
                         and 
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                        . Otherwise, its value is 0. Let 
                           
                              
                                 μ
                                 s
                                 i
                              
                              =
                              
                                 ∑
                                 
                                    j
                                    =
                                    1
                                 
                                 n
                              
                              
                                 u
                                 j
                                 i
                              
                              
                                 a
                                 
                                    j
                                    s
                                 
                                 i
                              
                           
                        . Therefore, 
                           
                              μ
                              s
                              i
                           
                         is the number of upscaled orders in schedule s of storage type i.

We call a storage schedule s feasible in storage type i if the following conditions are satisfied:

                           
                              (1)
                              
                                 ej
                                  ≤ bk
                                  for each pair of orders j and k with j < k which are included in storage schedule s;


                                 
                                    
                                       
                                          μ
                                          s
                                          i
                                       
                                       ≤
                                       U
                                    
                                 ;

each job included in s requests a storage type between cj
                                  and 
                                    
                                       
                                          c
                                          j
                                       
                                       +
                                       γ
                                    
                                 ;

no family order follows a business order;

the idle time between two adjacent orders is less than L.

Let Si
                         be the set containing all feasible storage schedules of storage type i. Note that |Si
                        | is a large number. We introduce variables 
                           
                              
                                 x
                                 s
                                 i
                              
                              
                                 (
                                 s
                                 =
                                 1
                                 ,
                                 ⋯
                                 ,
                                 |
                              
                              
                                 S
                                 i
                              
                              
                                 |
                                 ;
                                 i
                                 =
                                 1
                                 ,
                                 ⋯
                                 ,
                                 K
                                 )
                              
                           
                         that assume a value of 1 if storage schedule s is selected for storage type i and 0 otherwise. The problem is to select mi
                         storage schedules to maximize the total revenue, such that together they contain each job at most once. The problem is then to determine values 
                           
                              x
                              s
                              i
                           
                        :

The set covering formulation (master program) is given as follows.

                           
                              (8)
                              
                                 
                                    
                                       Z
                                       
                                          (
                                          I
                                          P
                                          )
                                       
                                       ′
                                    
                                    =
                                    max
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                          ,
                                          ⋯
                                          ,
                                          K
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             S
                                             i
                                          
                                       
                                    
                                    
                                       R
                                       s
                                       i
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                 
                              
                           
                        subject to

                           
                              (9)
                              
                                 
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             S
                                             i
                                          
                                       
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    
                                       m
                                       i
                                    
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    i
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    K
                                    ,
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             S
                                             i
                                          
                                       
                                    
                                    
                                       μ
                                       s
                                       i
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    U
                                    ,
                                 
                              
                           
                        
                        
                           
                              (11)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             S
                                             i
                                          
                                       
                                    
                                    
                                       a
                                       
                                          j
                                          s
                                       
                                       i
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    1
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    j
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    n
                                    ,
                                 
                              
                           
                        
                        
                           
                              (12)
                              
                                 
                                    
                                       x
                                       s
                                       i
                                    
                                    ∈
                                    
                                       {
                                       0
                                       ,
                                       1
                                       }
                                    
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    s
                                    ∈
                                    
                                       S
                                       i
                                    
                                    
                                    and
                                    
                                    i
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    K
                                    .
                                 
                              
                           
                        
                     

Constraints (9) and the integrality constraints (12) ensure that at most mi
                         storage schedules are selected for storage type i. Constraint (10) guarantees that the total number of upscaled orders is less than U. Constraints (11) ensure that each job is executed at most once.

The above set covering master program model 
                           
                              Z
                              
                                 I
                                 P
                              
                              ′
                           
                         is equivalent to the 0–1 integer program model ZIP
                        . But the number of binary variable 
                           
                              x
                              s
                              i
                           
                         goes exponentially with the number of jobs n, so it is not applicable to write down all the columns in the constraint matrix. We therefore use column generation method to solve this model.

We select a limited subset 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              ⊆
                              
                                 S
                                 i
                              
                              ,
                           
                        
                        
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                         and replace the binary constraints (12) with linear constraints (17). We then get a linear programming (LP) subproblem.

                           
                              (13)
                              
                                 
                                    
                                       Z
                                       
                                          (
                                          LP
                                          )
                                       
                                    
                                    =
                                    max
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             
                                                S
                                                i
                                             
                                             ¯
                                          
                                       
                                    
                                    
                                       R
                                       s
                                       i
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                 
                              
                           
                        subject to

                           
                              (14)
                              
                                 
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             
                                                S
                                                i
                                             
                                             ¯
                                          
                                       
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    
                                       m
                                       i
                                    
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    i
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    K
                                    ,
                                 
                              
                           
                        
                        
                           
                              (15)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             
                                                S
                                                i
                                             
                                             ¯
                                          
                                       
                                    
                                    
                                       μ
                                       s
                                       i
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    U
                                    ,
                                 
                              
                           
                        
                        
                           
                              (16)
                              
                                 
                                    
                                       ∑
                                       
                                          i
                                          =
                                          1
                                          ,
                                          …
                                          ,
                                          K
                                       
                                    
                                    
                                    
                                       ∑
                                       
                                          s
                                          ∈
                                          
                                             
                                                S
                                                i
                                             
                                             ¯
                                          
                                       
                                    
                                    
                                       a
                                       
                                          j
                                          s
                                       
                                       i
                                    
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    1
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    j
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    n
                                    ,
                                 
                              
                           
                        
                        
                           
                              (17)
                              
                                 
                                    0
                                    ≤
                                    
                                       x
                                       s
                                       i
                                    
                                    ≤
                                    1
                                    ,
                                    
                                    for
                                    
                                    each
                                    
                                    s
                                    ∈
                                    
                                       
                                          S
                                          i
                                       
                                       ¯
                                    
                                    
                                    and
                                    
                                    i
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    K
                                    .
                                 
                              
                           
                        
                     

In Section 5.1, we show how to find an initial 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              ,
                           
                        
                        
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                         for this LP subproblem. Starting with the LP subproblem, we add new columns by column generation. These new columns are obtained through a pricing algorithm. The details of the pricing algorithm are presented in Section 5.2. We show how to get an integer solution of our master problem in Section 5.3.

We use the best solution of the following heuristics as an initial 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              ,
                           
                        
                        
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                         for LP subproblem Z
                        (LP) 
                        (13). Notice that the heuristics can consider operational constraints when scheduling the orders.

                           
                              1.
                              Greedy algorithm with operational constraints (GA).

Sort all orders by non-increasing value of rj
                                 . Schedule the sorted jobs to the first available storage unit of the lowest possible storage type one by one. If a job cannot be stored in any storage unit of any storage type, it is discarded.

Earliest start time heuristic with operational constraints (ES).

Sort all orders by non-decreasing value of their start times; ties are broken by their values. Schedule the current job to the first available storage unit of the lowest possible storage type one by one. Several public storage warehouses use this heuristic in Europe.

To solve LP subproblem, we use the pricing algorithm to (1) determine whether we already have an optimal solution of Z
                        (LP) 
                        (13) for 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 S
                                 i
                              
                           
                         ; and (2) to determine which new columns could be added to the LP subproblem if an optimal solution has not been found.

From the theory of linear programming, we know that a solution to a maximization problem is optimal if the reduced cost of each variable is negative or zero. The reduced cost 
                           
                              R
                              s
                              
                                 ′
                                 i
                              
                           
                         of any storage schedule s of storage type i is given by


                        
                           
                              
                                 
                                    R
                                    s
                                    
                                       ′
                                       i
                                    
                                 
                                 =
                                 
                                    R
                                    s
                                    i
                                 
                                 −
                                 
                                    λ
                                    i
                                 
                                 −
                                 
                                    λ
                                    u
                                 
                                 
                                    μ
                                    s
                                    i
                                 
                                 −
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    n
                                 
                                 
                                    λ
                                    j
                                 
                                 
                                    a
                                    
                                       j
                                       s
                                    
                                    i
                                 
                                 ,
                              
                           
                        
                     

where λi
                         is the given value of the dual variable corresponding to condition (14) and 
                           
                              
                                 λ
                                 1
                              
                              ,
                              ⋯
                              ,
                              
                                 λ
                                 n
                              
                           
                         are the given values of the dual variables corresponding to conditions (16). To test whether the current solution is optimal, we determine if there exists a storage schedule s ∈ Si
                         with a positive reduced cost. If no storage schedule in Si
                        , 
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                              ,
                           
                         has a positive reduced cost, we already have an optimal solution of Z
                        (LP) for 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 S
                                 i
                              
                           
                        . To that end, we solve the pricing problem of finding a storage schedule in Si
                         with maximum reduced cost. Because λi
                         is a constant that is included in the reduced cost of each storage schedule, we essentially have to maximize

                           
                              (18)
                              
                                 
                                    
                                       R
                                       s
                                       i
                                    
                                    −
                                    
                                       λ
                                       u
                                    
                                    
                                       μ
                                       s
                                       i
                                    
                                    −
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       λ
                                       j
                                    
                                    
                                       a
                                       
                                          j
                                          s
                                       
                                       i
                                    
                                    =
                                    
                                       ∑
                                       
                                          j
                                          =
                                          1
                                       
                                       n
                                    
                                    
                                       (
                                       
                                          r
                                          j
                                       
                                       −
                                       
                                          λ
                                          u
                                       
                                       
                                          u
                                          j
                                          i
                                       
                                       −
                                       
                                          λ
                                          j
                                       
                                       )
                                    
                                    
                                       a
                                       
                                          j
                                          s
                                       
                                       i
                                    
                                    ,
                                 
                              
                           
                        subject to constraints of the start times and end times of the jobs.

Now all jobs can be separated into two subsets: 
                           
                              
                                 
                                    J
                                 
                                 −
                              
                              =
                              
                                 {
                                 
                                    J
                                    j
                                 
                                 |
                                 
                                    r
                                    j
                                 
                                 ≤
                                 
                                    λ
                                    u
                                 
                                 
                                    u
                                    j
                                    i
                                 
                                 +
                                 
                                    λ
                                    j
                                 
                                 ,
                                 j
                                 =
                                 1
                                 ,
                                 ⋯
                                 ,
                                 n
                                 }
                              
                           
                         and 
                           
                              
                                 
                                    J
                                 
                                 +
                              
                              =
                              
                                 {
                                 
                                    J
                                    j
                                 
                                 |
                                 
                                    r
                                    j
                                 
                                 >
                                 
                                    λ
                                    u
                                 
                                 
                                    u
                                    j
                                    i
                                 
                                 +
                                 
                                    λ
                                    j
                                 
                                 ,
                                 j
                                 =
                                 1
                                 ,
                                 ⋯
                                 ,
                                 n
                                 }
                              
                           
                        . For jobs in 
                           
                              
                                 
                                    J
                                 
                                 +
                              
                              ,
                           
                         we generate K jobs sets:


                        
                           
                              
                                 
                                    J
                                 
                                 
                                    i
                                    +
                                 
                              
                              =
                              
                                 {
                                 
                                    J
                                    j
                                 
                                 |
                                 
                                    J
                                    j
                                 
                                 
                                 requests
                                 
                                 storage
                                 
                                 type
                                 
                                 i
                                 
                                 or
                                 
                                 lower
                                 ,
                                 
                                 
                                    J
                                    j
                                 
                                 ∈
                                 
                                    
                                       J
                                    
                                    +
                                 
                                 }
                              
                           
                         for 
                           
                              i
                              =
                              1
                              ,
                              ⋯
                              ,
                              K
                           
                        .

To maximize (18), we have 
                           
                              
                                 a
                                 
                                    j
                                    s
                                 
                                 i
                              
                              =
                              0
                           
                         for any job 
                           
                              
                                 J
                                 j
                              
                              ∈
                              
                                 
                                    J
                                 
                                 −
                              
                           
                         (
                           
                              j
                              =
                              1
                              ,
                              ⋯
                              ,
                              n
                           
                        ) since these jobs have no positive values added in (18). If 
                           
                              
                                 
                                    J
                                 
                                 +
                              
                              =
                              ∅
                           
                         or 
                           
                              
                                 ∑
                                 
                                    
                                       J
                                       j
                                    
                                    ∈
                                    
                                       
                                          J
                                       
                                       +
                                    
                                 
                              
                              
                                 (
                                 
                                    r
                                    j
                                 
                                 −
                                 
                                    λ
                                    u
                                 
                                 
                                    u
                                    j
                                    i
                                 
                                 −
                                 
                                    λ
                                    j
                                 
                                 )
                              
                              ≤
                              
                                 λ
                                 i
                              
                              ,
                           
                         we already find an optimal solution for Z
                        (LP) and 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 S
                                 i
                              
                           
                        ; otherwise, we use the following pricing algorithm to find the optimal value of (18).

The pricing algorithm is based on dynamic programming and uses a forward recursion that exploits the property that the jobs are sequenced in the order of increasing indices for each storage unit. Let Fi
                        (j) denote the maximum reduced cost for all feasible storage schedules for storage type i that consist of jobs from the set 
                           
                              
                                 J
                              
                              
                                 i
                                 +
                              
                           
                         in which the last job is j. In order to find the storage schedule that realizes Fi
                        (j), we define set 
                           
                              
                                 K
                                 j
                              
                              =
                              
                                 {
                                 
                                    J
                                    k
                                 
                                 |
                                 k
                                 =
                                 1
                                 ,
                                 …
                                 ,
                                 j
                                 −
                                 1
                                 ,
                                 0
                                 ≤
                                 
                                    b
                                    j
                                 
                                 −
                                 
                                    e
                                    k
                                 
                                 <
                                 L
                                 ,
                                 
                                    J
                                    k
                                 
                                 ∈
                                 
                                    
                                       J
                                    
                                    
                                       i
                                       +
                                    
                                 
                                 ,
                                 and
                                 
                                 
                                    J
                                    k
                                 
                                 ∉
                                 F
                                 
                                 i
                                 f
                                 
                                 
                                    J
                                    j
                                 
                                 ∈
                                 B
                                 }
                              
                           
                         and select 
                           
                              
                                 F
                                 i
                              
                              
                                 (
                                 h
                                 )
                              
                              =
                              
                                 max
                                 
                                    k
                                    :
                                    
                                       J
                                       k
                                    
                                    ∈
                                    
                                       K
                                       j
                                    
                                 
                              
                              
                                 F
                                 i
                              
                              
                                 (
                                 k
                                 )
                              
                           
                        . The value of Fi
                        (j) is then equal to 
                           
                              
                                 F
                                 i
                              
                              
                                 (
                                 h
                                 )
                              
                              +
                              
                                 (
                                 
                                    r
                                    j
                                 
                                 −
                                 
                                    λ
                                    u
                                 
                                 
                                    u
                                    j
                                    i
                                 
                                 −
                                 
                                    λ
                                    j
                                 
                                 )
                              
                           
                        .

The recursion is then for 
                           
                              i
                              =
                              1
                              ,
                              ⋯
                              ,
                              K
                              ,
                           
                        
                        
                           
                              j
                              =
                              1
                              ,
                              ⋯
                              ,
                              n
                              ,
                           
                         and 
                           
                              
                                 J
                                 j
                              
                              ∈
                              
                                 
                                    J
                                 
                                 
                                    i
                                    +
                                 
                              
                              ,
                           
                        
                        
                           
                              
                                 
                                    
                                       F
                                       i
                                    
                                    
                                       (
                                       j
                                       )
                                    
                                    =
                                    
                                       {
                                       
                                          
                                             
                                                
                                                   
                                                      r
                                                      j
                                                   
                                                   −
                                                   
                                                      λ
                                                      u
                                                   
                                                   
                                                      u
                                                      j
                                                      i
                                                   
                                                   −
                                                   
                                                      λ
                                                      j
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   if
                                                   
                                                   
                                                      K
                                                      j
                                                   
                                                   =
                                                   ∅
                                                
                                             
                                          
                                          
                                             
                                                
                                                   
                                                      
                                                         max
                                                         
                                                            k
                                                            :
                                                            
                                                               J
                                                               k
                                                            
                                                            ∈
                                                            
                                                               {
                                                               
                                                                  K
                                                                  j
                                                               
                                                               }
                                                            
                                                         
                                                      
                                                      
                                                         F
                                                         i
                                                      
                                                      
                                                         (
                                                         k
                                                         )
                                                      
                                                      +
                                                      
                                                         (
                                                         
                                                            r
                                                            j
                                                         
                                                         −
                                                         
                                                            λ
                                                            u
                                                         
                                                         
                                                            u
                                                            j
                                                            i
                                                         
                                                         −
                                                         
                                                            λ
                                                            j
                                                         
                                                         )
                                                      
                                                   
                                                
                                             
                                             
                                                
                                                   
                                                   if
                                                   
                                                   
                                                      K
                                                      j
                                                   
                                                   ≠
                                                   ∅
                                                   .
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The optimal value is then found as 
                           
                              
                                 F
                                 *
                              
                              =
                              
                                 max
                                 
                                    i
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    K
                                 
                              
                              
                                 F
                                 i
                                 *
                              
                              =
                              
                                 max
                                 
                                    i
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    K
                                 
                              
                              
                                 max
                                 
                                    j
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    n
                                 
                              
                              
                                 F
                                 i
                              
                              
                                 (
                                 j
                                 )
                              
                           
                        .

If 
                           
                              
                                 F
                                 i
                                 *
                              
                              <
                              
                                 λ
                                 i
                              
                              ,
                           
                         then the current linear programming solution is optimal. Otherwise, it is not and we need to introduce new columns to the LP subproblem (13). Candidates are associated with those i for which 
                           
                              
                                 F
                                 i
                                 *
                              
                              ≥
                              
                                 λ
                                 i
                              
                           
                        . An operational issue is the number of columns to add to the linear program after having solved the pricing algorithm. The more columns we add per iteration, the fewer linear programs we need to solve – but the more columns we add per iteration, the larger the linear programs become. An empirically good choice appears to add 10 columns that correspond to 10 values of i for which 
                           
                              F
                              i
                              *
                           
                         is the largest. The pricing algorithm finds Fi
                        (j) in O(n) time for 
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                         and 
                           
                              j
                              =
                              1
                              ,
                              …
                              ,
                              n
                           
                        . Therefore the overall time complexity is O(Kn
                        2).

After running the pricing algorithm, we either confirm an optimal solution of Z
                        (LP) 
                        (13) for 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 S
                                 i
                              
                           
                         or find some columns that can be added to 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              ,
                           
                        
                        
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                        . Using the modified 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              ,
                           
                         we will solve the LP subproblem again. Theoretically, we can gradually add all columns in Si
                         to 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              ,
                           
                        
                        
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                              ,
                           
                         and ensure an optimal solution of Z
                        (LP) 
                        (13) for 
                           
                              
                                 
                                    S
                                    i
                                 
                                 ¯
                              
                              =
                              
                                 S
                                 i
                              
                           
                        .

Let 
                           
                              
                                 x
                                 s
                                 
                                    i
                                    *
                                 
                              
                              ,
                           
                         
                        s ∈ Si
                        , denote the optimal solution to Z
                        (LP) 
                        (13), and let S
                        
                           i* denote the set containing all columns s for which 
                           
                              
                                 x
                                 s
                                 
                                    i
                                    *
                                 
                              
                              >
                              0
                           
                        . If 
                           
                              x
                              s
                              
                                 i
                                 *
                              
                           
                         is integral for 
                           
                              i
                              =
                              1
                              ,
                              ⋯
                              ,
                              K
                           
                         and s ∈ S
                        
                           i*, the 
                           
                              x
                              s
                              
                                 i
                                 *
                              
                           
                         (
                           
                              i
                              =
                              1
                              ,
                              …
                              ,
                              K
                           
                        ) constitutes an optimal solution of 
                           
                              Z
                              
                                 (
                                 I
                                 P
                                 )
                              
                              ′
                           
                         
                        (8). If 
                           
                              x
                              s
                              
                                 i
                                 *
                              
                           
                         is non-integer, then we need to apply a branch-and-bound approach to close the integrality gap and find an optimal integral solution for our problem. The branching strategy of fixing a variable at either 0 or 1 in LP subproblem does not work in combination with column generation. Our branching strategy is based on current non-integer solution.

In current non-integer solution, we identify three kinds of non-integral orders.

                           
                              •
                              
                                 Split order. If an order is included in two storage schedules s
                                 1 and s
                                 2 in two different storage types, i.e., 
                                    
                                       0
                                       <
                                       
                                          x
                                          
                                             
                                                s
                                                1
                                             
                                          
                                          i
                                       
                                       <
                                       1
                                    
                                  and 
                                    
                                       0
                                       <
                                       
                                          x
                                          
                                             
                                                s
                                                2
                                             
                                          
                                          j
                                       
                                       <
                                       1
                                    
                                  (i ≠ j), we define the order as a split order. Constraints (16) rule out the possibility that 
                                    
                                       
                                          x
                                          
                                             
                                                s
                                                1
                                             
                                          
                                          i
                                       
                                       >
                                       0
                                    
                                  and 
                                    
                                       
                                          x
                                          
                                             
                                                s
                                                2
                                             
                                          
                                          j
                                       
                                       =
                                       1
                                    
                                  for any split order. We define orders set 
                                    I
                                  that contains all split orders.


                                 Partial order. We define 
                                    
                                       
                                          x
                                          j
                                       
                                       
                                          (
                                          i
                                          )
                                       
                                       =
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                S
                                                i
                                             
                                          
                                       
                                       
                                          a
                                          
                                             j
                                             s
                                          
                                          i
                                       
                                       
                                          x
                                          s
                                          i
                                       
                                    
                                 . If 0 < xj
                                 (i) < 1, we call order j a partial order in storage type i. We define orders set 
                                    P
                                  that contains all partial orders.


                                 Fractional order. If an order is included in at least two storage schedules s
                                 1 and s
                                 2 in the same storage type, i.e., 
                                    
                                       0
                                       <
                                       
                                          x
                                          
                                             
                                                s
                                                1
                                             
                                          
                                          i
                                       
                                       <
                                       1
                                    
                                  and 
                                    
                                       0
                                       <
                                       
                                          x
                                          
                                             
                                                s
                                                2
                                             
                                          
                                          i
                                       
                                       <
                                       1
                                       ,
                                    
                                  we define the order as a fractional order.

If current non-integer solution has split orders, we branch on split orders first. To select one of the active nodes to explore, we use a depth-first search strategy.

In this case, we have 
                              
                                 I
                                 ≠
                                 ∅
                              
                           . We select the smallest indexed order 
                              
                                 j
                                 ∈
                                 I
                              
                            as a branching node. By branching, we assign order j to storage type i for 
                              
                                 
                                    c
                                    j
                                 
                                 ≤
                                 i
                                 ≤
                                 
                                    c
                                    j
                                 
                                 +
                                 γ
                              
                            and i ≤ K. Hence, the maximum number of active branching nodes is γ. In descendant node, if order j is assigned to storage type cj
                           , we delete order j for all storage type i ≠ cj
                            in calculating LP subproblem.

If current non-integer solution has partial orders but no split orders, we branch on partial orders. We use depth-first search strategy here again.

In this case, we have 
                              
                                 I
                                 =
                                 ∅
                              
                            and 
                              
                                 P
                                 ≠
                                 ∅
                                 ,
                              
                            and at least one job j that 
                              
                                 
                                    x
                                    j
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 
                                    ∑
                                    
                                       s
                                       ∈
                                       
                                          S
                                          i
                                       
                                    
                                 
                                 
                                    a
                                    
                                       j
                                       s
                                    
                                    i
                                 
                                 
                                    x
                                    s
                                    i
                                 
                                 <
                                 1
                              
                           . Since 
                              
                                 I
                                 =
                                 ∅
                                 ,
                              
                            we only need to consider jobs for storage type i. We select xj
                           (i) as a branching variable and have two sub-nodes 
                              
                                 
                                    x
                                    j
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 1
                              
                            and 
                              
                                 
                                    x
                                    j
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 0
                              
                           . The lowest indexed job in 
                              P
                            is selected first. In solving the problem at the node of 
                              
                                 
                                    x
                                    j
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 1
                                 ,
                              
                            we change the jth constraint in (11) to

                              
                                 (19)
                                 
                                    
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                S
                                                i
                                             
                                          
                                       
                                       
                                          a
                                          
                                             j
                                             s
                                          
                                          i
                                       
                                       
                                          x
                                          s
                                          i
                                       
                                       =
                                       1
                                    
                                 
                              
                           and

                              
                                 (20)
                                 
                                    
                                       
                                          ∑
                                          
                                             i
                                             |
                                             i
                                             =
                                             1
                                             ,
                                             …
                                             ,
                                             i
                                             −
                                             1
                                             ,
                                             i
                                             ,
                                             …
                                             ,
                                             K
                                          
                                       
                                       
                                          ∑
                                          
                                             s
                                             ∈
                                             
                                                S
                                                i
                                             
                                          
                                       
                                       
                                          a
                                          
                                             j
                                             s
                                          
                                          i
                                       
                                       
                                          x
                                          s
                                          i
                                       
                                       =
                                       0
                                       .
                                    
                                 
                              
                           
                        

While solving the problem at the node of 
                              
                                 
                                    x
                                    j
                                 
                                 
                                    (
                                    i
                                    )
                                 
                                 =
                                 0
                                 ,
                              
                            we simply delete order j from 
                              J
                           . This branching strategy is called Branching on Aggregated Variables in Gamrath (2010).

If current non-integer solution contains only fractional orders but no split orders or partial orders, i.e., 
                              
                                 I
                                 =
                                 ∅
                              
                            and 
                              
                                 P
                                 =
                                 ∅
                                 ,
                              
                            we apply the following dynamic programming to get a solution without fractional orders in storage type i.

Let set 
                              
                                 J
                                 i
                              
                            contain all fractional orders in storage type i. Re-index jobs in 
                              
                                 J
                                 i
                              
                            by non-decreasing start times. Let 
                              
                                 
                                    F
                                    i
                                 
                                 
                                    (
                                    j
                                    ,
                                    
                                       J
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       J
                                       
                                          (
                                          
                                             
                                                m
                                                ¯
                                             
                                             i
                                          
                                          )
                                       
                                    
                                    )
                                 
                              
                            denote the maximum revenue for all feasible storage schedules for storage type i that consist of the first j jobs from set 
                              
                                 J
                                 i
                              
                            in which the last jobs in 
                              
                                 
                                    m
                                    ¯
                                 
                                 i
                              
                            storage units are 
                              
                                 
                                    J
                                    
                                       (
                                       1
                                       )
                                    
                                 
                                 ,
                                 …
                                 ,
                                 
                                    J
                                    
                                       (
                                       
                                          
                                             m
                                             ¯
                                          
                                          i
                                       
                                       )
                                    
                                 
                                 ,
                              
                            where 
                              
                                 
                                    m
                                    ¯
                                 
                                 i
                              
                            is the total number of fractional schedules in storage type i. We define set 
                              
                                 
                                    K
                                    
                                       (
                                       j
                                       )
                                    
                                 
                                 =
                                 
                                    {
                                    
                                       J
                                       k
                                    
                                    |
                                    k
                                    =
                                    1
                                    ,
                                    …
                                    ,
                                    j
                                    ,
                                    0
                                    ≤
                                    
                                       b
                                       
                                          (
                                          j
                                          )
                                       
                                    
                                    −
                                    
                                       e
                                       k
                                    
                                    <
                                    L
                                    ,
                                    and
                                    
                                    
                                       J
                                       k
                                    
                                    ∉
                                    F
                                    
                                    i
                                    f
                                    
                                    
                                       J
                                       
                                          (
                                          j
                                          )
                                       
                                    
                                    ∈
                                    B
                                    }
                                 
                              
                           .

The forward recursion is then for 
                              
                                 
                                    j
                                    =
                                    1
                                    ,
                                    ⋯
                                    ,
                                    |
                                 
                                 
                                    J
                                    i
                                 
                                 
                                    |
                                    ,
                                 
                              
                           
                           
                              
                                 
                                    
                                       
                                          
                                          
                                          
                                             
                                                
                                                   F
                                                   i
                                                
                                                
                                                   (
                                                   j
                                                   ,
                                                   
                                                      J
                                                      
                                                         (
                                                         1
                                                         )
                                                      
                                                   
                                                   ,
                                                   …
                                                   ,
                                                   
                                                      J
                                                      
                                                         (
                                                         
                                                            
                                                               m
                                                               ¯
                                                            
                                                            i
                                                         
                                                         )
                                                      
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                       
                                          
                                          
                                          
                                             
                                                
                                                =
                                                max
                                                
                                                   {
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  F
                                                                  i
                                                               
                                                               
                                                                  (
                                                                  j
                                                                  −
                                                                  1
                                                                  ,
                                                                  
                                                                     J
                                                                     
                                                                        (
                                                                        1
                                                                        )
                                                                     
                                                                  
                                                                  ,
                                                                  …
                                                                  ,
                                                                  
                                                                     J
                                                                     
                                                                        (
                                                                        
                                                                           
                                                                              m
                                                                              ¯
                                                                           
                                                                           i
                                                                        
                                                                        )
                                                                     
                                                                  
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  
                                                                     max
                                                                     
                                                                        k
                                                                        :
                                                                        
                                                                           J
                                                                           k
                                                                        
                                                                        ∈
                                                                        
                                                                           {
                                                                           
                                                                              K
                                                                              j
                                                                           
                                                                           }
                                                                        
                                                                     
                                                                  
                                                                  
                                                                     F
                                                                     i
                                                                  
                                                                  
                                                                     (
                                                                     j
                                                                     −
                                                                     1
                                                                     ,
                                                                     
                                                                        J
                                                                        
                                                                           (
                                                                           1
                                                                           )
                                                                        
                                                                     
                                                                     ,
                                                                     …
                                                                     ,
                                                                     
                                                                        J
                                                                        k
                                                                     
                                                                     ,
                                                                     …
                                                                     ,
                                                                     
                                                                        J
                                                                        
                                                                           (
                                                                           
                                                                              
                                                                                 m
                                                                                 ¯
                                                                              
                                                                              i
                                                                           
                                                                           )
                                                                        
                                                                     
                                                                     )
                                                                  
                                                                  +
                                                                  
                                                                     r
                                                                     
                                                                        (
                                                                        j
                                                                        )
                                                                     
                                                                  
                                                                  .
                                                               
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       
                                    
                                 
                              
                           
                        

The optimal value is then found as 
                              
                                 
                                    F
                                    *
                                 
                                 =
                                 
                                    max
                                    
                                       {
                                       
                                          J
                                          
                                             (
                                             k
                                             )
                                          
                                       
                                       ,
                                       k
                                       =
                                       1
                                       ,
                                       …
                                       ,
                                       |
                                       
                                          
                                             m
                                             ¯
                                          
                                          i
                                       
                                       |
                                       }
                                    
                                 
                                 
                                    F
                                    i
                                 
                                 
                                    (
                                    |
                                 
                                 
                                    J
                                    i
                                 
                                 
                                    |
                                    ,
                                    
                                       J
                                       
                                          (
                                          1
                                          )
                                       
                                    
                                    ,
                                    …
                                    ,
                                    
                                       J
                                       
                                          (
                                          
                                             
                                                m
                                                ¯
                                             
                                             i
                                          
                                          )
                                       
                                    
                                    )
                                 
                              
                           . The overall time complexity of the dynamic programming is 
                              
                                 O
                                 (
                                 
                                    n
                                    
                                       
                                          
                                             m
                                             ¯
                                          
                                          i
                                       
                                       +
                                       2
                                    
                                 
                                 )
                              
                           . By applying this dynamic programming, we always find an integer solution in storage type i.

To summarize our branch-and-price algorithm, we present the following pseudo-code framework.


                        algorithm: Branch-and-price

Initialization and initial incumbent LB


                        begin Exploring current node


                        
                        do while true
                     


                        
                        Solving LP subproblem


                        
                        Running pricing algorithm


                        
                        
                        if LP subproblem is optimal for 
                           
                              
                                 S
                                 i
                              
                              ¯
                           
                         = Si
                         
                        then exit do
                     


                        
                        Add new columns to 
                           
                              
                                 S
                                 i
                              
                              ¯
                           
                        
                     


                        
                        end do
                     


                        Renew UB for current node and incumbent UB when needed


                        
                        if
                        
                           
                              I
                              ≠
                              ∅
                           
                         or 
                           
                              P
                              ≠
                              ∅
                           
                         
                        then
                     


                        
                        
                        If UB for current node ≥ incumbent LB then
                     


                        
                        
                        
                        Branching into descendant nodes
                     


                        
                        else if Fractional orders exist then
                     


                        
                        Eliminate fractional orders by dynamic programming


                        
                        end if
                     


                        Renew incumbent LB when needed


                        Current node is fathomed


                        
                        if incumbent LB = incumbent UB then
                     


                        
                        Optimal solution found


                        
                        
                        end
                     


                        
                        end if
                     


                        
                        if Active nodes exist then
                     


                        
                        Exploring next node


                        
                        else
                     


                        
                        Output solution which has incumbent LB as optimal


                        
                        
                        end
                     


                        
                        end if
                     


                        end
                     

In this section, we examine our optimal and heuristic algorithms with generated warehouse data (the number of storage types and storage units) and order data (storage start time, storage end time, storage type, and associated revenue) based on real parameters from the warehouses we visited. We combine the experiments with sensitivity analysis, and examine the influence of variance of demand levels, decision horizons, and warehouse sizes. We also did experiments on the model ZIP
                      
                     (1) by
                     
                      CPLEX and found that none of the instances can be completed within 30 minutes.

                        
                           (1)
                           Warehouse data. We use the price and storage type data from a warehouse in Rotterdam (see Table 7 in the Appendix) as a basic case. The rentable storage capacity includes 213 storage units with 8 storage types. In this experiment, we set the total number of orders received per year to 1391, which is the total number of orders in 2008 for this warehouse. For each combination of decision horizon and demand level, we use the number of orders from Table 1.

Storage decision horizon. The basic storage decision horizon is set to two months. We will vary it in a range of [1, 4] months in our experiments.

Order information. Storage types of orders are generated by an empirical distribution based on the data from Table 7. Since most self-storage warehouses only accept an integer number of months for the order storage, the unit for order storage time is month. The order storage times are generated from a truncated normal distribution and rounded to integers. The longest order storage time is set to one year. We use the average storage duration following from Table 7 as the mean and 0.5 months as the standard deviation in the normal distribution that is used to generate the storage duration. The start times and end times are calculated in weeks. However, in line with common practice, independent of the starting date and finish date of the rent, the renting fee is calculated for the whole calendar month. To simplify our exposition, we assume that one month consists of four weeks. The start time of each order is generated from the uniform distribution of [T
                              0, Te
                              ].

Initialization. We randomly generate an initial occupation rate, using a uniform distribution [34.5 percent, 100 percent], where 34.5 percent is the lowest occupation rate and 100 percent the highest occupation rate obtained from the warehouses from which we collected data.

In this experiment, we fix the number of storage units to 107 and the storage decision horizon to two months, then vary the demand levels. The results of this experiment are presented in Table 2.

From Table 2, we observe the following: (1) When the total number of orders increases, the relative revenue improvement increases significantly. The optimal branch-and-price algorithm works more effectively in a higher-demand environment. (2) Compared with ES, which is the main method in current self-storage warehouses operations, our algorithm can improve the revenue by as much as 50.5 percent in a high-demand setting. (3) The running time of the optimal algorithm is short.

In this experiment, we fix the number of storage units to 107 and set the demand level as Level 1, then vary storage decision horizons from one month to four months. The results of this group of numerical experiments are presented in Table 3.

We observe the following: (1) The revenue improvement is generally more significant in longer decision horizon than in shorter decision horizons. (2) Our algorithm can improve the revenue by as much as 26.8 percent compared with ES in an environment with long decision horizons.

In this experiment, we fix storage decision horizon to two months and vary the warehouse size from 2000 meter2 to 5000 meter2. When the warehouse size is increased, both the total number of orders and the number of storage units are increased. In Table 4, we present the experimental results. We find the following: (1) Compared with ES, our algorithm can improve the revenue by at least 26.2 percent. (2) The difference in warehouse sizes does not have a significant influence on average relative revenue improvement.

To explore the joint effect of the number of orders and the decision horizon on the performance of our algorithm, we vary the demand level from Level 1 to Level 4 and the decision horizons from one month to four months. We show the average relative revenue improvement of our optimal algorithm compared with the revenue of heuristic ES in Fig. 1
                        
                        
                        .

From the figure, we observe the following: With the increase in demand level, our algorithm shows larger improvements. This is reasonable since a higher demand level means more space in the selection decision of orders. On the other hand, the relative revenue improvement does not increase monotonically with the decision horizon.

We consider a warehouse in Paris with a long (three months) storage decision horizon, to show the application of the upscaling problem with operational constraints. The parameters are in Table 10 (see the Appendix). We consider further constraints as follows: (i) the total number of upscaling operations is less than 50 percent of the total orders, (ii) the maximum upscaling level is 1, (iii) warehouse managers consider precedence constraints and do not prefer scheduling a family order after a business order, (iv) the maximum idle time between two accepted orders is two months.

The results are presented in Table 5. Our optimal algorithm is 19.6 percent better than ES.

In this paper, we consider a self-storage warehouse facing orders for heterogeneous storage units over a certain time horizon with revenue rewards. The warehouse operation manager has to decide which storage order to accept in order to maximize the revenue while considering upscaling operations. We model warehouse operations as scheduling n independent multiprocessor tasks with given start and end times, where the objective is to maximize total revenue.

For the storage order upscaling operations problem, we propose a branch-and-price algorithm with a column generation approach of solving this problem to optimality. We compare the algorithm with other heuristics and apply this algorithm to several self-storage warehouse with data based on real facilities. The results show that our algorithm is efficient and can improve the revenue. Based on experiments, our algorithm can improve the revenue by, on average, 13.9 percent compared with the GA algorithm and by, on average, 28.2 percent compared with the ES algorithm. This algorithm facilitates warehouse operation managers to optimize their revenue while considering operational constraints. With sufficient flexibility in modeling their problem, warehouse operation managers can define the total number of upscaled orders, the maximum upscaling level, which orders are business orders, and the maximum idle time between two accepted orders.

It is
                     
                     
                      possible to adapt our algorithm such that it can handle time buckets of one day. However, the calculation time will dramatically increase. As in practice contracts currently have a monthly basis (calendar months), there is no real need to adapt the algorithm to time buckets of one day.

@&#ACKNOWLEDGMENTS@&#

We thank the two anonymous referees whose valuable suggestions greatly improved the quality of the paper. Xiandong Zhang acknowledges the support of NSFC (grant nos. 71171058 and 11371103). Yeming Gong acknowledges the support of NSFC (grant no. 70901028) and Chutian Scholarship. We are grateful to Prof. Bo Chen of the University of Warwick for his comments on algorithms.

In this appendix, we show data we collected. Table 6 shows the overall status of 61 warehouses we visited. We used this table in model assumption and model building. Tables 7–10 show the data of storage types, storage unit numbers, prices, mean demand values and storage periods for four warehouses. We used these data in numerical experiments or applications.

@&#REFERENCES@&#

