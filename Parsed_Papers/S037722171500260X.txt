@&#MAIN-TITLE@&#Multi-stage optimization for periodic inspection planning of geo-distributed infrastructure systems

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           A method for finding inspection intervals of geo-distributed infrastructure systems is proposed.


                        
                        
                           
                           The system is partitioned into groups based on pre-specified features.


                        
                        
                           
                           The group’s inspection interval is first computed based on the expected cost per cycle.


                        
                        
                           
                           We find the system inspection schedule considering the workforce and budget constraints.


                        
                        
                           
                           An integer program and a heuristics are introduced to determine the inspection schedule.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Periodic inspection

Hidden failures

Integer nonlinear programming

Clusters

Maintenance cost

@&#ABSTRACT@&#


               
               
                  This paper develops a multi-stage optimization framework for determining periodic inspection intervals for geo-distributed infrastructure systems subject to hidden failures. We assume that the unit’s failure can only be rectified at periodic inspection when a perfect repair is carried out to restore the unit to as-good-as-new condition. For large-scale systems such as fire hydrants in a city, water supply and power transformer distribution networks in urban areas, firstly, we partition the units of a system into groups based on their pre-specified features by a clustering algorithm; then compute an optimal periodic inspection interval for each group based on the expected cost per cycle; and finally, we find the inspection schedule for the whole system that not only minimizes the total inspection and maintenance cost but also satisfies the workforce and budget resource constraints. An integer nonlinear programming formulation and a heuristics are introduced to determine the inspection schedule. The proposed approach is applied to scheduling periodic inspection of large amounts of fire hydrants in a major U.S. city.
               
            


set of time intervals


set of units


set of unit clusters

= 1 if the kth cluster of units is inspected at the ith interval, 0 otherwise


optimal inspection time interval for the kth cluster of units


most recent time to do inspection for the kth cluster of units


upper bound of τk
                        
                     


age of unit n at the time of planning


expected unavailable time if a repair action occurs in the kth cluster of units


minimum number of times to do inspection for the kth cluster of units


maximum number of inspection activities for the ith interval


minimum number of inspection activities for the ith interval


maximum budget for the ith interval


penalty parameter for the optimal time interval


number of units in the kth cluster


inspection and preventive maintenance cost per unit


repair cost per unit


penalty cost per unit time if a failure occurs before the next planned inspection time to a unit


conditional CDF of failure time for unit n
                     

PDF of failure time for unit n
                     

@&#INTRODUCTION@&#

The reliability of infrastructure systems in urban areas and its associated social impacts, such as inoperable fire hydrants and power outage, has been one of the biggest problems facing municipal authorities (Christodoulou, Deligianni, Aslani, & Agathokleous, 2009). In the last 5–20 years, with the availability of geographic information systems and computer-based asset management systems, more and more municipalities have started to collect infrastructure reliability data and plan proactive maintenance interventions (Zhu, Yashchin, & Hosking, 2014). Proactive maintenance is carried out previously to failure and aims at reducing breakdown risk and disastrous consequences in human life in some cases. Proactive maintenance can be classified as condition-based maintenance (CBM) and preventive maintenance (PM). The CBM is performed when an indicator of the health condition of the system reaches a pre-determined level. One of the three main tasks of CBM is to monitor the condition indicator and assess the current system’s health condition from the measured data (Zhu, Elsayed, Liao, & Chan, 2010). Despite advances in measurement technologies, the unaffordable cost of a continuous monitoring limits the application of CBM, especially in infrastructure maintenance. For example, it is extremely expensive, if not impossible, to keep monitoring the crack increase on roads and the water flow and pressure of fire hydrants.

The PM is carried out at pre-determined time intervals which are estimated based on historical data, failure time distributions of the systems, and economic or availability models. In practice, PM is still the most common maintenance policy applied to repairable systems due to its relatively simple implementation (Taghipour & Banjevic, 2011). When a system is maintained at unequal time intervals, the PM policy is known as sequential PM. Barlow and Hunter (1960) firstly introduce time-based maintenance that minimizes the limiting unavailability. Following their work, many PM models and policies are proposed assuming maximum availability, minimum maintenance cost, or both, and some operative constraints (Jiang & Jardine, 2005; Nakagawa & Mizutani, 2009; Wang & Pham, 2006). For example, Badia and Berrade (2009) propose a bivariate policy based on minimum cost per unit of time over an infinite time span, where one of the terms refers to the inspection time and the other to the number of failures previous to the system replacement. Barros, Berenguer, and Grall (2003) determine the optimal replacement times for a two-unit parallel system based on a stochastic cost model. Chen, Chen, and Yuan (2003) propose a state and time-dependent PM policy for a multi-state deteriorating system that minimizes the expected total operating cost per life cycle. Bris, Chatelet, and Yalaoui (2003) try to optimize for each component of a system, the maintenance policy minimizing the cost function, with respect to the availability constraints on a given mission time period. However, none of these methods have considered the feasibility of the optimal PM solutions for individual units due to, for example, the global labor and budget constraints in reality. In order to optimize the objective function and determine the optimum maintenance time, many optimization approaches are developed. For instance, Bris et al. (2003) propose new methods to minimize the PM cost of series-parallel systems using ant colony optimization. Grigoriev, Klundert, and Spieksma (2006) introduce an integer linear program formulation for scheduling periodic maintenance, and Hilber, Miranda, Matos, and Bertling (2007) develop heuristics and evolutionary algorithms for multi-objective maintenance problems. Ahmadi (2014) investigates a deteriorating system whose state is partially observable.

Periodically scheduled inspections, a kind of PM, are generally applied to complex production systems and crucial infrastructure systems during life cycle to verify functional conditions with reference to the system safety, reliability, and performance levels. For example, power plants and fire hydrants are typical equipments subject to periodic inspection for public safety. During the scheduled inspections, the potential and hidden failures are detected and fixed, and PM also can be performed to avoid or reduce future failures. A lot of work have been recently published on the inspection problem. Chelbi and Daoud (2009) review inspection policies for multi-component systems considering the cases of cold and hot stand-by systems with known and partially known lifetime distributions and components failure dependency. Huynh, Barros, Berenguer, and Castro (2011) develop a condition-based periodic inspection/replacement policy and compare with a benchmark time-based block replacement policy. Cui, Loh, and Xie (2004) obtain sequential plans to ensure that the availability of a system with n units achieves the required level under different availability criteria. In reality, many systems subject to hidden failures, e.g., the failure of redundant power transformers, the breakdown of protection circuits in health care devices, insufficient water pressure of fire hydrants, etc. Taghipour and Banjevic (2011) propose a model to find an optimal periodic inspection interval over finite and infinite time horizons for a multi-component repairable system subject to hidden failures. The authors calculate the expected cost per cycle for different numbers of inspection intervals, and find the optimal inspection frequency. The calculation is numerically intensive as the times of failure are not known. The models do not allow for components with hidden failures to be repaired if found failed. Leung (2001) introduces four optimal inspection policies using the inspection density under the assumption of unknown system lifetime distribution. The total expected cost is minimized by applying the calculus of variations.

For management and maintenance of large-scale geo-distributed repairable systems, the basic cost to transport equipments, technicians and spare parts from one place to another can be the main concern among the total maintenance cost. In light of this, we propose an optimization framework to find the periodic inspection interval for geo-distributed infrastructure systems subject to hidden failures. Firstly, we cluster the geo-distributed units into groups based on their features and/or connectivity. This step helps to reduce the logistics cost for PM. Secondly, we determine the optimal periodic inspection interval for each cluster with respect to minimal expected cost per cycle. Finally, given the optimal inspection interval, we calculate the best inspection schedule for the whole system considering the coupling resource constraints and the inspection cost. We develop a nonlinear optimization algorithm to solve the scheduling problem.

The rest of the paper is organized as follows. Section 2 presents the optimization models and algorithms to solve these formulations. Section 3 provides a case study for a real-world system of fire hydrants. Finally, Section 4 concludes the paper.

We consider a large-scale infrastructure system with geo-distributed units. The units are subject to hidden failures. The objective is to determine the periodic inspection interval for each unit of the system with minimum maintenance cost and operational constraints. We make the following assumptions:

                        
                           1.
                           The kth cluster of units is inspected at times 
                                 
                                    t
                                    i
                                    k
                                 
                              ;

Failures are only rectified and repaired at periodic inspections;

A penalty cost is applied to the elapsed time from a failure to its detection at the next planned inspection;

The inspection is perfect and PM is performed if no failure is detected;

A unit is “good-as-new” after either an inspection or a repair;

Inspection times are negligible;

The lifetime distributions of all units are known and independent.

In this section, we develop an optimization framework for planning of periodic inspection of repairable systems with geo-distributed units under budget and workforce constraints. First, we introduce the problem formulation, then a solution approach to solve it is given. Since the size of the problem under consideration is very large, which consists of several binary variables in the model, it becomes intractable if we try to deal with the unified NP-hard nonlinear problem for the entire system. We attack this issue by separating into three steps: partitioning the system into a number of clusters, computing the optimal periodic interval for each cluster independently without considering the global constraints, and then forming a scheduling problem based on the optimal values from the second step but taking into account the budget and labor constraints.

Infrastructure systems, such as power distribution networks, water distribution networks and fire hydrant systems in urban area, usually consist of tens of thousands of components spread over a large geographical area. For example, the red dots in Fig. 1
                         indicate the fire hydrants in a major U.S. city that has been studied in this paper. For such large-scale systems, the logistics cost to transport equipments, technicians and spare parts for maintenance activities is often noticeable. To reduce such cost as well as to shrink the size of the large-scale optimization framework, we propose to partition set of 
                           
                              |
                              N
                              |
                           
                         units into 
                           
                              |
                              K
                              |
                           
                         disjoint groups, i.e. clusters, and schedule the periodic inspection for each of them. In practice, units under the same working condition, which is called a feature, such as water pressure level for a hydrant system, and load and ambient temperature for an electric transformer system should have a similar degradation rate (IEEE Power & Energy Society, 2011; International Electrotechnical Commission, 2005; Winders, 2002). Besides the important geographical feature for the geo-distributed system, we also consider other features such as water pressure level for a hydrant system to cluster the set of units.

The k-means algorithm is one of the most powerful tools for clustering vector-based data (Wu et al., 2007). Each unit (or point) is characterized by a number of features such as the geographical measures, water pressure level for a hydrant system, and ages of units. The algorithm aims to maximize the similarities between data points in the same cluster, which is achieved by minimizing the total distances between all points from their centroids (MacQueen, 1967). Given a set of data points 
                           
                              {
                              
                                 p
                                 1
                              
                              ,
                              …
                              ,
                              
                                 p
                                 
                                    |
                                    N
                                    |
                                 
                              
                              }
                              ,
                           
                         where each point is a d-dimensional real vector, the classical clustering problem can be expressed as the following optimization problem

                           
                              (1a)
                              
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                                   x
                                                   ,
                                                   w
                                                
                                             
                                             
                                          
                                       
                                       
                                          
                                             g
                                             
                                                (
                                                x
                                                ,
                                                w
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   n
                                                   ∈
                                                   N
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                w
                                                
                                                   n
                                                   k
                                                
                                             
                                             
                                                
                                                   ∥
                                                   
                                                      x
                                                      k
                                                   
                                                   −
                                                   
                                                      p
                                                      n
                                                   
                                                   ∥
                                                
                                                2
                                                2
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1b)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                w
                                                
                                                   n
                                                   k
                                                
                                             
                                             =
                                             1
                                             ,
                                             n
                                             ∈
                                             N
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (1c)
                              
                                 
                                    
                                       
                                       
                                          
                                             
                                                w
                                                
                                                   n
                                                   k
                                                
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             ,
                                             n
                                             ∈
                                             N
                                             ,
                                             k
                                             ∈
                                             K
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                         where d is the number of features, 
                           x
                        
                        
                           k
                         is the centroid of the kth cluster, and wnk
                         = 1 if the data point 
                           p
                        
                        
                           n
                         is assigned to the kth cluster.

One shortcoming of the above formulation is that it might lead to either empty clusters or clusters with very few points. Ng (2000) is interested in the applications where the number of points in each cluster k is fixed, i.e., nk
                        , the author proposes to add 
                           
                              |
                              K
                              |
                           
                         equality constraints to the model (1)
                        
                           
                              (2)
                              
                                 
                                    
                                       ∑
                                       
                                          n
                                          ∈
                                          N
                                       
                                    
                                    
                                       w
                                       
                                          n
                                          k
                                       
                                    
                                    =
                                    
                                       n
                                       k
                                    
                                    ,
                                    k
                                    ∈
                                    K
                                    .
                                 
                              
                           
                        
                     

Other work such as Bradley, Bennett, and Demiriz (2000) and Banerjee and Ghosh (2006) require the lower bounds lk
                         on the cluster sizes, which impose the following constraints

                           
                              (3)
                              
                                 
                                    
                                       l
                                       k
                                    
                                    ≤
                                    
                                       ∑
                                       
                                          n
                                          ∈
                                          N
                                       
                                    
                                    
                                       w
                                       
                                          n
                                          k
                                       
                                    
                                    ,
                                    k
                                    ∈
                                    K
                                    .
                                 
                              
                           
                        
                     

These formulations are NP-hard mixed-integer nonlinear programs, the alternating minimization algorithm based on the divide and conquer technique, originated from Lloyd’s algorithm (Lloyd, 1982) for clustering without size constraints, is widely used to solve them. It makes use of the fact that there is no coupling constraint between variables 
                           x
                         and 
                           w
                         in the feasible set. The algorithm is carried out in two steps:


                        
                           
                              1.
                              
                                 For fixed 
                                 
                                    x
                                 
                                 (t), g(
                                    x
                                 
                                 (t), 
                                    w
                                 ) is minimized over 
                                 
                                    w
                                  
                                 subject to 
                                 (1b), (1c) 
                                 and either 
                                 (2) 
                                 or 
                                 (3) 
                                 to get 
                                 
                                    w
                                 
                                 (t + 1);


                                 For fixed 
                                 
                                    w
                                 
                                 (t + 1), g(
                                    x, w
                                 
                                 (t + 1)) is minimized over 
                                 
                                    x
                                  
                                 to get 
                                 
                                    x
                                 
                                 (t + 1).


                              If lk and uk for every
                              
                                 
                                    k
                                    ∈
                                    K
                                 
                               
                              are integers, then there exists a binary optimal solution of (
                              
                                 5
                              
                              ) which solves the integer linear programming in Step 1 with constraint (
                              
                                 4
                              
                              ).
                           

Following the proof of Proposition 3.1 in Bradley et al. (2000), by a similar argument, we convert the problem in Step 1 into a minimum cost flow problem, which is proved to have a binary solution under certain conditions (Bertsekas, 1991). We define a directed graph with 
                                 
                                    |
                                    N
                                    |
                                    +
                                    2
                                    |
                                    K
                                    |
                                    +
                                    1
                                 
                               nodes as depicted in Fig. 2
                              . There is an arc from any data point 
                                 p
                              
                              
                                 n
                               to the kth cluster with a shipping cost 
                                 
                                    
                                       ∥
                                    
                                    
                                       
                                          x
                                       
                                       k
                                       
                                          (
                                          t
                                          )
                                       
                                    
                                    −
                                    
                                       p
                                       n
                                    
                                    
                                       
                                          ∥
                                       
                                       2
                                       2
                                    
                                 
                               and the associated flow upper bound is 1. There is an arc from the dummy node 
                                 d
                              
                              
                                 k
                               to cluster k with zero shipping cost and the flow upper bound is 
                                 
                                    |
                                    N
                                    |
                                 
                              . The dummy node 
                                 
                                    d
                                    
                                       K
                                       +
                                       1
                                    
                                 
                               is connected to every node 
                                 
                                    
                                       d
                                       k
                                    
                                    ,
                                    
                                       (
                                       k
                                       ∈
                                       K
                                       )
                                    
                                 
                               with zero cost and the flow upper bound is 
                                 
                                    |
                                    N
                                    |
                                 
                              . The flow lower bound for every arc is 0. The supply for data point node 
                                 p
                              
                              
                                 n
                               is 1, the supply for cluster k is − lk
                              , the supply for node 
                                 d
                              
                              
                                 k
                               is lk
                               − uk
                              , and the supply for node 
                                 
                                    d
                                    
                                       K
                                       +
                                       1
                                    
                                 
                               is 
                                 
                                    
                                       ∑
                                       
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       u
                                       k
                                    
                                    −
                                    
                                       |
                                       N
                                       |
                                    
                                 
                              . Thus, linear programming problem (5) is a minimum cost flow problem for the proposed graph with a flow vector 
                                 w
                              . Because the values for supplies and flow bounds are integers, the optimal flow vector 
                                 w
                               is integer (see, Proposition 2.3 in Bertsekas, 1991). Since the upper bound for 
                                 w
                               is 1, 
                                 w
                               is binary. Note that the integer linear programming in Step 1 with constraint (4) is equivalent to the minimum cost flow problem, thus 
                                 w
                               solves the integer linear programming.□

Instead of solving the difficult integer programming problem, we need only to handle a linear network optimization problem (5). It is even easier to be solved than a general linear programming by some specialized algorithms (Bertsekas, 1998).

The solution from Step 2 has a simple closed form

                           
                              
                                 
                                    
                                       x
                                       k
                                       
                                          (
                                          t
                                          +
                                          1
                                          )
                                       
                                    
                                    =
                                    
                                       
                                          
                                             ∑
                                             
                                                n
                                                ∈
                                                N
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   w
                                                   
                                                      n
                                                      k
                                                   
                                                
                                                )
                                             
                                             
                                                (
                                                t
                                                +
                                                1
                                                )
                                             
                                          
                                          
                                             p
                                             n
                                          
                                       
                                       
                                          
                                             ∑
                                             
                                                n
                                                ∈
                                                N
                                             
                                          
                                          
                                             
                                                (
                                                
                                                   w
                                                   
                                                      n
                                                      k
                                                   
                                                
                                                )
                                             
                                             
                                                (
                                                t
                                                +
                                                1
                                                )
                                             
                                          
                                       
                                    
                                    ,
                                    k
                                    ∈
                                    K
                                    .
                                 
                              
                           
                        
                     

Given a cluster, we determine the optimal periodic inspection interval over an infinite time horizon based on the renewal-reward theorem (Serfozo, 2009). With this theorem, we formulate the objective function as the expected cost per cycle. The expected cost is calculated as the sum of the expected cost of all the units in the cluster. The expected cost of a unit consists of three parts, the inspection and PM cost, the repair cost if failure occurs to a unit, and the penalty cost for the elapsed time from a failure to its detection at the next inspection. The expected cycle time is given by the sum of the inspection interval and the total expected unavailable time due to repair. Here, we assume repairs are carried out sequentially. The optimal inspection interval τk
                         for cluster 
                           
                              k
                              ∈
                              K
                           
                         with nk
                         units subject to an upper bound 
                           
                              
                                 τ
                                 ¯
                              
                              k
                           
                         is determined by minimizing the following objective function

                           
                              (6a)
                              
                                 
                                    
                                       
                                          
                                             min
                                             
                                          
                                       
                                       
                                          
                                             
                                                1
                                                
                                                   
                                                      τ
                                                      k
                                                   
                                                   +
                                                   
                                                      u
                                                      k
                                                   
                                                   
                                                      ∑
                                                      
                                                         n
                                                         =
                                                         1
                                                      
                                                      
                                                         n
                                                         k
                                                      
                                                   
                                                   
                                                      F
                                                      n
                                                   
                                                   
                                                      (
                                                      
                                                         τ
                                                         k
                                                      
                                                      |
                                                      
                                                         t
                                                         n
                                                         0
                                                      
                                                      )
                                                   
                                                
                                             
                                             
                                                [
                                                
                                                   C
                                                   1
                                                
                                                
                                                   n
                                                   k
                                                
                                                +
                                                
                                                   C
                                                   2
                                                
                                                
                                                   ∑
                                                   
                                                      n
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                      k
                                                   
                                                
                                                
                                                   F
                                                   n
                                                
                                                
                                                   (
                                                   
                                                      τ
                                                      k
                                                   
                                                   
                                                      |
                                                   
                                                   
                                                      t
                                                      n
                                                      0
                                                   
                                                   )
                                                
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             +
                                             
                                             
                                                C
                                                3
                                             
                                             
                                                [
                                                
                                                   τ
                                                   k
                                                
                                                
                                                   n
                                                   k
                                                
                                                +
                                                
                                                   u
                                                   k
                                                
                                                
                                                   ∑
                                                   
                                                      n
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                      k
                                                   
                                                
                                                
                                                   F
                                                   n
                                                
                                                
                                                   (
                                                   
                                                      τ
                                                      k
                                                   
                                                   
                                                      |
                                                   
                                                   
                                                      t
                                                      n
                                                      0
                                                   
                                                   )
                                                
                                                −
                                                
                                                   ∑
                                                   
                                                      n
                                                      =
                                                      1
                                                   
                                                   
                                                      n
                                                      k
                                                   
                                                
                                                
                                                   ∫
                                                   
                                                      
                                                         t
                                                         n
                                                         0
                                                      
                                                   
                                                   
                                                      τ
                                                      k
                                                   
                                                
                                                t
                                                
                                                   f
                                                   n
                                                
                                                
                                                   (
                                                   t
                                                   )
                                                
                                                d
                                                t
                                                ]
                                             
                                             ]
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (6b)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                          
                                             0
                                             ≤
                                             
                                                τ
                                                k
                                             
                                             ≤
                                             
                                                
                                                   τ
                                                   ¯
                                                
                                                k
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

The above objective function is a nonlinear function with one decision variable. Some efficient global optimization algorithms such as sampling algorithm DIRECT (Jones, Perttunen, & Stuckman, 1993) and multilevel coordinate search MCS (Huyer & Neumaier, 1999), that do not require to provide the objective function gradient information, can be used to solve the problem.

In practice, there are some operational and economic constraints for the entire system such as labor and budget availability for each period. If the inspection planning based on the solution from Section 2.2 is deployed, some of these constraints will be likely violated. Our scheduling strategy is to obey the global constraints for the final planning, but possibly readjust the optimal scheduled inspection intervals for each group obtained from the last step. Thus, the resulting inspection intervals for each group can be slightly uneven. The continuous time horizon is discretized into a finite evenly spaced time intervals 
                           
                              |
                              I
                              |
                           
                        . In this model, we attempt to minimize the total deviation from the optimal inspection intervals.

The objective of our scheme is to minimize the total inspection cost for all clusters and impose the inspection frequency close to the optimal inspection time interval τk
                        :

                           
                              (7)
                              
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                                   t
                                                   i
                                                   k
                                                
                                             
                                             
                                             
                                          
                                       
                                       
                                          
                                             ϕ
                                             
                                                (
                                                t
                                                )
                                             
                                             =
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                t
                                                i
                                                k
                                             
                                             
                                                C
                                                1
                                             
                                             
                                                n
                                                k
                                             
                                             +
                                             
                                                ∑
                                                
                                                   
                                                      i
                                                      1
                                                   
                                                   ,
                                                   
                                                      i
                                                      2
                                                   
                                                   ∈
                                                   I
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                   :
                                                   
                                                      i
                                                      2
                                                   
                                                   >
                                                   
                                                      i
                                                      1
                                                   
                                                
                                             
                                             β
                                             
                                                t
                                                
                                                   
                                                      i
                                                      1
                                                   
                                                
                                                k
                                             
                                             
                                                t
                                                
                                                   
                                                      i
                                                      2
                                                   
                                                
                                                k
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             ×
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   t
                                                   
                                                      
                                                         i
                                                         1
                                                      
                                                      +
                                                      1
                                                   
                                                   k
                                                
                                                )
                                             
                                             …
                                             
                                                (
                                                1
                                                −
                                                
                                                   t
                                                   
                                                      
                                                         i
                                                         2
                                                      
                                                      −
                                                      1
                                                   
                                                   k
                                                
                                                )
                                             
                                             
                                                |
                                                
                                                   i
                                                   2
                                                
                                                −
                                                
                                                   i
                                                   1
                                                
                                                −
                                                
                                                   τ
                                                   k
                                                
                                                |
                                             
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             +
                                             
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             β
                                             
                                                t
                                                
                                                   i
                                                
                                                k
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   t
                                                   
                                                      1
                                                   
                                                   k
                                                
                                                )
                                             
                                             …
                                             
                                                (
                                                1
                                                −
                                                
                                                   t
                                                   
                                                      i
                                                      −
                                                      1
                                                   
                                                   k
                                                
                                                )
                                             
                                             
                                                |
                                                i
                                                −
                                                
                                                   τ
                                                   k
                                                   0
                                                
                                                −
                                                
                                                   τ
                                                   k
                                                
                                                |
                                             
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        where the first term in the objective function (7) is the total cost of inspections, the second and third terms are aggregate deviations between the final scheduled inspection times and the optimal ones weighted by a positive scalar β.

The above objective function is subject to the following set of constraints.

                           
                              –
                              Minimum number of inspections for the kth cluster

                                    
                                       (8)
                                       
                                          
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                
                                             
                                             
                                                t
                                                i
                                                k
                                             
                                             ≥
                                             
                                                r
                                                k
                                             
                                             ,
                                             
                                             
                                             k
                                             ∈
                                             K
                                          
                                       
                                    
                                 
                              

Manpower availability at the ith interval

                                    
                                       (9)
                                       
                                          
                                             
                                                
                                                   h
                                                   ̲
                                                
                                                i
                                             
                                             ≤
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                t
                                                i
                                                k
                                             
                                             ≤
                                             
                                                
                                                   h
                                                   ¯
                                                
                                                i
                                             
                                             ,
                                             
                                             
                                             i
                                             ∈
                                             I
                                          
                                       
                                    
                                 
                              

Maximum budget availability at the ith interval

                                    
                                       (10)
                                       
                                          
                                             
                                                ∑
                                                
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                t
                                                i
                                                k
                                             
                                             
                                                C
                                                1
                                             
                                             
                                                n
                                                k
                                             
                                             ≤
                                             
                                                
                                                   b
                                                   ¯
                                                
                                                i
                                             
                                             ,
                                             
                                             
                                             i
                                             ∈
                                             I
                                          
                                       
                                    
                                 
                              

Binary variable condition

                                    
                                       (11)
                                       
                                          
                                             
                                                t
                                                i
                                                k
                                             
                                             ∈
                                             
                                                {
                                                0
                                                ,
                                                1
                                                }
                                             
                                             ,
                                             
                                             
                                             i
                                             ∈
                                             I
                                             ,
                                             k
                                             ∈
                                             K
                                             .
                                          
                                       
                                    
                                 
                              

Note that we allow 
                           
                              
                                 
                                    h
                                    ̲
                                 
                                 i
                              
                              =
                              
                                 
                                    h
                                    ¯
                                 
                                 i
                              
                              =
                              0
                           
                         for some 
                           
                              i
                              ∈
                              I
                           
                         that represents nonbusiness periods. This is a large-scale integer nonconvex nonlinear programming, where the numbers of clusters 
                           
                              |
                              K
                              |
                           
                         and time periods 
                           
                              |
                              I
                              |
                           
                         are typically at least a few tens. It is very difficult or even likely impossible for state-of-the-art exact MINLP solvers (Bussieck & Vigerske, 2010) to solve problems of these sizes to optimality in our applications because of the prohibitive running time and huge memory needed. We propose a scalable heuristic approach to solving the problem (7)–(11).

Because a concave function attains its optimal minimizer at an extreme point of the feasible set, the discrete problem (7)–(11) can be transformed into an equivalent continuous nonlinear programming

                           
                              (12a)
                              
                                 
                                    
                                       
                                          
                                             
                                                min
                                                
                                                   t
                                                   i
                                                   k
                                                
                                             
                                             
                                             
                                          
                                       
                                       
                                          
                                             
                                                ψ
                                                ρ
                                             
                                             
                                                (
                                                t
                                                )
                                             
                                             =
                                             ϕ
                                             
                                                (
                                                t
                                                )
                                             
                                             +
                                             ρ
                                             
                                                ∑
                                                
                                                   i
                                                   ∈
                                                   I
                                                   ,
                                                   k
                                                   ∈
                                                   K
                                                
                                             
                                             
                                                t
                                                
                                                   i
                                                
                                                k
                                             
                                             
                                                (
                                                1
                                                −
                                                
                                                   t
                                                   
                                                      i
                                                   
                                                   k
                                                
                                                )
                                             
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12b)
                              
                                 
                                    
                                       
                                          
                                             s.t.
                                             
                                          
                                       
                                       
                                          
                                             (
                                             8
                                             )
                                             ,
                                             (
                                             9
                                             )
                                             ,
                                             (
                                             10
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (12c)
                              
                                 
                                    
                                       
                                       
                                          
                                             0
                                             ≤
                                             
                                                t
                                                i
                                                k
                                             
                                             ≤
                                             1
                                             ,
                                             
                                             
                                             i
                                             ∈
                                             I
                                             ,
                                             k
                                             ∈
                                             K
                                             ,
                                          
                                       
                                    
                                 
                              
                           
                        for a sufficiently large ρ > 0. However, as ρ increases, so does the number of local minimizers of the problem (12). As a result, it might lead to a low solution quality for any local search method if we do not have a good enough starting point, which is expected to be close to the global optimal solution. Homotopy method can be used to obtain a good initial guess. The main concept is that we commence solving a strictly convex problem, whose optimal solution does not depend on a starting point and is unique, and gradually deform the convex problem into the nonconvex problem (12). The solution from the previous problem acts as a starting point for the next one, and we eventually end with a solution of the original problem. This idea was successfully applied to solve the scheduling problem for charging electrical assets in Phan, Xiong, and Ghosh (2012), where the objective function is quadratic. We will see that the same technique to produce the homotopy affect can be achieved by the deformation of ρ for the polynomial of higher degree ϕ(
                           t
                        ).

                           Theorem 2
                           
                              The following hold
                              
                                 
                                    (i)
                                    
                                       There exists a constant
                                       
                                          
                                             ρ
                                             ¯
                                          
                                        
                                       such that if
                                       
                                          
                                             ρ
                                             >
                                             
                                                ρ
                                                ¯
                                             
                                          
                                        
                                       then problems (
                                       
                                          7
                                       
                                       )–(
                                       
                                          11
                                       
                                       ) and (
                                       
                                          12
                                       
                                       ) are equivalent.
                                    


                                       There exists a constant 
                                       
                                          ρ
                                        
                                       such that if ρ < 
                                          ρ
                                        
                                       then ψρ
                                       (
                                          t
                                       ) is strictly convex on [
                                          0, 1
                                       ].


                              
                                 
                                    (i)
                                    This result was proved in Giannesi and Niccolucci (1976).

Because ϕ(
                                          t
                                       ) is a polynomial, the smallest eigenvalue of ∇2
                                       ϕ(
                                          t
                                       ) over the compact set [0, 1] exists and is finite, which is denoted by ρ
                                       min. Taking 
                                          
                                             
                                                ρ
                                                ̲
                                             
                                             =
                                             
                                                
                                                   ρ
                                                   min
                                                
                                                2
                                             
                                          
                                        implies that ∇2
                                       ψρ
                                       (
                                          t
                                       ) is positive definite for any ρ < 
                                          ρ
                                       , which completes the proof.□

The above theorem suggests us to increase ρ iteratively from a small value to get the homotopy trajectory. We now describe the algorithm for solving (12):


                        
                           
                              1.
                              
                                 Initialize 
                                 
                                    t
                                 
                                 (0), ρ
                                 (0), δ
                                 1 > 0, δ
                                 2 > 1


                                 For 
                                 n = 1, 2, …
                                    
                                       (a)
                                       
                                          Solve the following starting from 
                                          
                                             t
                                          
                                          (n) 
                                          to get 
                                          
                                             t
                                          
                                          (n + 1)
                                          
                                             
                                                
                                                   
                                                      
                                                         
                                                            
                                                               
                                                                  min
                                                                  
                                                                     
                                                                     t
                                                                  
                                                               
                                                               
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               
                                                                  ψ
                                                                  
                                                                     ρ
                                                                     
                                                                        (
                                                                        n
                                                                        )
                                                                     
                                                                  
                                                               
                                                               
                                                                  (
                                                                  t
                                                                  )
                                                               
                                                            
                                                         
                                                      
                                                      
                                                         
                                                            
                                                               
                                                                  s
                                                                  .
                                                                  t
                                                                  .
                                                               
                                                               
                                                               
                                                            
                                                         
                                                         
                                                            
                                                               (
                                                               8
                                                               )
                                                               ,
                                                               (
                                                               9
                                                               )
                                                               ,
                                                               (
                                                               10
                                                               )
                                                            
                                                         
                                                      
                                                      
                                                         
                                                         
                                                            
                                                               0
                                                               ≤
                                                               
                                                                  t
                                                                  i
                                                                  k
                                                               
                                                               ≤
                                                               1
                                                               ,
                                                               
                                                               
                                                               i
                                                               ∈
                                                               I
                                                               ,
                                                               k
                                                               ∈
                                                               K
                                                               .
                                                            
                                                         
                                                      
                                                   
                                                
                                             
                                          
                                       


                                          Terminate the algorithm if a stopping criteria is satisfied. Otherwise, go to 
                                                Step 2c
                                             .
                                       


                                          If 
                                          ρ
                                          (n) ≤ 0 then set 
                                          ρ
                                          (n + 1) = ρ
                                          (n) + δ
                                          1, else set 
                                          ρ
                                          (n + 1) = ρ
                                          (n)
                                          δ
                                          2.

We apply the proposed optimization framework to plan and schedule the inspection of fire hydrants in a major U.S. city, as shown in Fig. 1, over a year. For safety reasons, fire hydrants are subject to periodic inspections. Based on the inspection results, hydrants that have failed or are in poor condition are either repaired or replaced. There are total 
                        
                           |
                           N
                           |
                           =
                        
                     10,803 hydrants in the city. For the optimization framework, we identify 
                        
                           |
                           K
                           |
                        
                      = 50 hydrant clusters from the aforementioned clustering algorithm where the bounds in (4) are defined by

                        
                           
                              
                                 
                                    l
                                    k
                                 
                                 =
                                 
                                    ⌊
                                    
                                       (
                                       1
                                       −
                                       0.01
                                       )
                                    
                                    
                                       
                                          |
                                          N
                                          |
                                       
                                       
                                          |
                                          K
                                          |
                                       
                                    
                                    ⌋
                                 
                                 ,
                                 
                                 
                                 and
                                 
                                 
                                 
                                    u
                                    k
                                 
                                 =
                                 
                                    ⌊
                                    
                                       (
                                       1
                                       +
                                       0.01
                                       )
                                    
                                    
                                       
                                          |
                                          N
                                          |
                                       
                                       
                                          |
                                          K
                                          |
                                       
                                    
                                    ⌋
                                 
                                 ,
                              
                           
                        
                     for all 
                        
                           k
                           ∈
                           K
                        
                     . The time interval 
                        
                           Δ
                           I
                        
                      is a week, so there are 
                        
                           |
                           I
                           |
                           =
                           52
                        
                      weeks in our numerical simulation. All tests were conducted on a 64-bit Windows 7 ThinkPad W520 with Intel i7-2720QM 2.2 gigahertz CPU and 8 gigabyte RAM. MCS in Huyer and Neumaier (1999) was used to solve (6), and the network optimizer from CPLEX v12.5 (IBM, 2014) is the tool for solving (5).

The city is divided into 7 different pressure zones, as shown in Fig. 3
                        . In Fig. 4
                        , we illustrate the graphical results for 7 clusters where the geographical attributes and water pressure levels are considered. The geographical features include the longitude and latitude of each hydrant. The pressure level reflects information such as water demand, population density, and residential or commercial consumers, etc. It took only 26 seconds for the clustering algorithm to converge.

As we can see the resulting unit clusters are able to reduce the logistics cost thanks to the close proximity to each other for units in the same cluster. The clusters also can capture the water pressure level information when grouping, for example the 23rd and 27th clusters are slightly spread by the pressure levels on pipelines.

We let the value for β be 0.1 in (7). The value for the minimum number of inspections rk
                         is selected as follows

                           
                              
                                 
                                    
                                       
                                       
                                          
                                             if
                                             
                                             
                                             
                                                r
                                                min
                                             
                                             −
                                             0.3
                                             <
                                             
                                                
                                                   365
                                                   −
                                                   
                                                      τ
                                                      k
                                                      0
                                                   
                                                   *
                                                   Δ
                                                   I
                                                
                                                
                                                   τ
                                                   k
                                                
                                             
                                             ≤
                                             
                                                r
                                                min
                                             
                                             +
                                             0.7
                                          
                                       
                                    
                                    
                                       
                                       
                                          
                                             then
                                             
                                             
                                             
                                                r
                                                k
                                             
                                             =
                                             
                                                r
                                                min
                                             
                                             .
                                          
                                       
                                    
                                 
                              
                           
                        
                     

In homotopy algorithm, we use 
                           t
                        
                        (0) = 1, ρ
                        0 = −1000, δ
                        1 = 100, δ
                        2 = 1.5 and terminate the algorithm when

                           
                              
                                 
                                    
                                       max
                                       
                                          i
                                          ∈
                                          I
                                          ,
                                          k
                                          ∈
                                          K
                                       
                                    
                                    
                                       
                                          (
                                          
                                             t
                                             
                                                i
                                             
                                             k
                                          
                                          )
                                       
                                       
                                          (
                                          n
                                          )
                                       
                                    
                                    
                                       (
                                       1
                                       −
                                       
                                          
                                             (
                                             
                                                t
                                                
                                                   i
                                                
                                                k
                                             
                                             )
                                          
                                          
                                             (
                                             n
                                             )
                                          
                                       
                                       )
                                    
                                    ≤
                                    
                                       10
                                       
                                          −
                                          3
                                       
                                    
                                    .
                                 
                              
                           
                        First, we use a state-of-the-art MINLP solver, namely KNITRO version 8.1 (Byrd, Nocedal, & Waltz, 2006), to solve our model (7)–(11) for different settings on the number of clusters and time intervals so as to validate the solution quality and running time of our heuristic approach. It is a NLP-based branch and bound algorithm, and is exact when ϕ is convex. However, in our application, ϕ is nonconvex; thus KNITRO serves as a heuristics as well. To the best of our knowledge, there is no existing MINLP solvers that can guarantee to solve the problems (7)–(11) of the sizes we are testing to optimality. We implement the homotopy algorithm in AMPL modeling language (Fourer, Gay, & Kernighan, 2002) and use the active-set method from KNITRO to solve the subproblem (S).


                        Table 1 reports the performance of algorithms in terms of the computed optimal objective function value (opt) for (7), the number of inspections (#insp), and the running time (time) in seconds. Denote #var by the number of binary variables for problems (7)–(11).

We can see that the optimal objective function values for our approach (denoted by “HOMO”) and KNITRO are very comparable. The proposed method yields all most the same solution quality with those obtained from the global technique. As expected, the global technique is not scalable, which requires a huge computation time for medium size problems. KNITRO failed to solve for the last two problems within the allotted maximum time (3 hours), even it could not provide an integer feasible point. The proposed algorithm was able to solve for problems with practical sizes in a reasonable time frame.


                        Table 2
                         gives the final inspection schedule for seven selected clusters, depicted in Fig. 4, which represents the weeks in the year to do inspections. The first column is the cluster index, the second column gives the value of the optimal periodic inspection time interval τk
                         calculated from the first stage of the multi-stage procedure. The third column (labeled by “Last year”) is the time point of the most recent inspection before our planning time, i.e., the latest inspection of last year. We use the convention that time starts at a reference time point labeled 1 and proceeds in steps of 1 week. Starting from the fourth column afterward, the time points for the 1st and subsequent inspections are given. For example, the cluster number 24 has a periodic inspection of 13 weeks, the most recent inspection was carried out at the 51st week of last year. The 1st inspection for this year will be at the 12th week, and the 2nd inspection will be done after 25 weeks from the start of planning time. The numbers in bold highlight that the time intervals between them are slightly different from the optimal value τk
                        . For instance, the time interval between the 3rd inspection (at the 38th week) and the 4th inspection (at the 49th week) is 11 (weeks), while the inspection intervals for the 1st and the 2nd inspections are equal to the optimal one τk
                         = 13. In most cases, they obey the optimal inspection time requirement, that is, the inspection intervals are identical to τk
                        . Because of the workforce and budget limitation for periods, some inspections are deviated from the optimal values for a few time units, but are still close to the suggested values.

@&#CONCLUSIONS@&#

In this paper, we proposed an optimization framework for solving the periodic inspection interval over an infinite time horizon for large-scale geo-distributed infrastructure systems. In particular, we developed an integer nonlinear programming model and a heuristics to solve the problem. The clustering technique makes use of not only the geographic information but also other data, which evidently influence the health condition of units. The proposed approach has been applied to planning the periodic inspection of fire hydrants in a major U.S. city. The research results in this study lay important foundation for sustainable resource management. In the future, we would like to allow a more general decision-making scenario in the mathematical model of inspection time interval by taking more practical operational constraints into accounts.

@&#ACKNOWLEDGMENTS@&#

The authors wish to thank the associate editor and two anonymous referees, whose valuable comments and suggestions helped us strongly improve the content and presentation of the paper.

@&#REFERENCES@&#

