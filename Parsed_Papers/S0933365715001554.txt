@&#MAIN-TITLE@&#User-defined functions in the Arden Syntax: An extension proposal

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           We studied the rationale behind the Arden Syntax concepts related to functions.


                        
                        
                           
                           We confronted the Arden Syntax model with some functional programming models.


                        
                        
                           
                           We propose an extension that allows an author to safely define and use functions.


                        
                        
                           
                           We give examples of possible Arden Syntax constructs augmented with functions.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Programming languages

Artificial intelligence

Expert systems

Medical informatics

Clinical decision support systems

@&#ABSTRACT@&#


               
               
                  Background
                  The Arden Syntax is a knowledge-encoding standard, started in 1989, and now in its 10th revision, maintained by the health level seven (HL7) organization. It has constructs borrowed from several language concepts that were available at that time (mainly the HELP hospital information system and the Regenstrief medical record system (RMRS), but also the Pascal language, functional languages and the data structure of frames, used in artificial intelligence). The syntax has a rationale for its constructs, and has restrictions that follow this rationale. The main goal of the Standard is to promote knowledge sharing, by avoiding the complexity of traditional programs, so that a medical logic module (MLM) written in the Arden Syntax can remain shareable and understandable across institutions.
               
               
                  Objectives
                  One of the restrictions of the syntax is that you cannot define your own functions and subroutines inside an MLM. An MLM can, however, call another MLM, where this MLM will serve as a function. This will add an additional dependency between MLMs, a known criticism of the Arden Syntax knowledge model. This article explains why we believe the Arden Syntax would benefit from a construct for user-defined functions, discusses the need, the benefits and the limitations of such a construct.
               
               
                  Methods and materials
                  We used the recent grammar of the Arden Syntax v.2.10, and both the Arden Syntax standard document and the Arden Syntax Rationale article as guidelines. We gradually introduced production rules to the grammar. We used the CUP parsing tool to verify that no ambiguities were detected.
               
               
                  Results
                  A new grammar was produced, that supports user-defined functions. 22 production rules were added to the grammar. A parser was built using the CUP parsing tool. A few examples are given to illustrate the concepts. All examples were parsed correctly.
               
               
                  Conclusions
                  It is possible to add user-defined functions to the Arden Syntax in a way that remains coherent with the standard. We believe that this enhances the readability and the robustness of MLMs. A detailed proposal will be submitted by the end of the year to the HL7 workgroup on Arden Syntax.
               
            

@&#INTRODUCTION@&#

The Arden Syntax is a knowledge-encoding standard, started in 1989, and now in its 10th revision, maintained by the health level seven (HL7) organization. It has a well-thought set of constructs; however, the lack of functions forces the repetition of code. This is usually perceived in software development as error-prone and inelegant. A call to another MLM can be used as a function call, but this is too cumbersome for a simple calculation. For example, an author can write a conversion from Fahrenheit to Celsius more naturally using a function. However an addition of function constructs must not transform the Arden Syntax into a traditional programming language, which was one of the original design goals, explained in the rationale for the Arden Syntax [1]. This article only gives the main concepts involved in the addition of functions, without many technical details. A detailed proposal will be made this year to the HL7 organization. Adding features to a computer language is a quite subjective matter; computer languages are made for humans, not computers. This article therefore cites several sources to promote its proposals, but does not provide any formal proof of the benefits of the additional constructs.

To study implementation issues, we used the Arden Syntax Standard documents, and also the rationale for the Arden Syntax [1]. Several sources cited by the Rationale for the Arden Syntax were studied also to verify that the addition of user-defined functions is not contradictory with the goals and the general philosophy of the Arden Syntax.

We give a few common concepts around functions that will serve in the discussion about the proposal. Functions have a mathematical definition, and the implementation in computer languages of functions often deviates from this definition, mostly because of implementation constraints. A computer execution model based on computable functions can represent constructs that are as powerful as constructs that use a computer execution model based on Turing's abstract machine [2]. Several constructs of computable functions, described in Alonzo Church's paper [3] defining the “lambda calculus” have inspired some of the most advanced computer languages (Lisp, ML, Haskell, for example). Most computer languages deviate from this theoretical functional model, for practical or implementation reasons. The deviations concern mostly the modifications and actions that a function is allowed to make (modify global variables, send messages, etc.). The languages that adhere to the functional model are called functional languages, and are taught in advanced computer science courses. Languages with functions that make modifications outside of their definition are called “impure”, whereas languages that don’t are called “pure”. Furthermore, functions must be distinguished from subroutines. A “pure” function takes arguments, and produces a result, that is returned to the caller. Nothing else is changed, and the result is reproducible. An “impure” function can read and modify variables outside of its definition, and perform actions (like writing to a database, or printing). Therefore two calls to such a function with the same arguments can return different values. A subroutine doesn’t return a value, and exists only to access and modify outer variables and perform actions. An action or a modification made by a called subroutine or “impure” function to something outside of its definition is called a side-effect. Side-effects are not part of functions in the mathematical sense. The basic usage of functions (i.e. without the many powerful but complex features of functional languages) is now commonly taught to medical students, not necessarily via programming languages, but rather through the use of spreadsheet computer applications [4]. A full usage of functions as a computing model can be difficult to understand and use, and some functional constructs will be contradictory with the goal of ease of use of the Arden Syntax.

The rationale for the Arden Syntax is an interesting document for the Arden Syntax, as it paves the way to further additions to the language, and even encourages them. It gives to future authors clear guidelines for the development of extensions, by exposing the general philosophy and backgrounds of the approach. In light of these explanations, it appears that several languages influenced the Arden Syntax, and a balance has been maintained between ease of learning and possibilities of language constructs. In every revision of the Arden Syntax that followed the initial version of 1992, the standard evolved, operators and syntactic constructs were added to handle lists, data and control flow with more ease, mainly (the interested readers should refer to the documents of the standard for the detailed list, that is very long):
                           
                              •
                              In v. 2: Operators to sort, index and extract lists, 
                                    interface
                                  keyword to use external functions.

In v. 2.5: Structured data, with the 
                                    object
                                  data type, and the possibility to 
                                    include
                                  other MLMs.

In v. 2.6: Localization enhancements.

In v. 2.8: Operators to add and remove elements from lists, to better control the sorting of lists with the 
                                    using
                                  construct, addition of the 
                                    switch-case
                                  construct.

In v. 2.9: Support for fuzzy sets, with a new 
                                    fuzzy
                                  datatype, and its support in many operators.

In v. 2.10: No language constructs were added, the additions concerned the XML encoding of MLMs.

In light of these continuous evolutions, the proposition of adding user-defined functions had to be coherent with the progresses made by the Arden Syntax standard. We used the article “Rationale for the Arden Syntax” as a guide for the implementation of functions in the Arden Syntax. We then compared this source with several current implementations of languages, whether functional or not. We then weighted the possible additions with the constraints expressed in [1], especially the ease of learning, to retain or reject some constructs. As described in [1], the Arden Syntax borrows many constructions from functional languages, namely APL [5], J [6] and also the ML language [7] (of course the main influences of the language are the HELP system [8] and the RMRS's rule system [9]). The syntax reflects this in several constructs. For example, a built-in function can be applied to a list, something that could not be expressed as clearly in the other languages in 1989 (whereas nowadays such constructs are expected of a modern language). It is interesting to describe the influence of the APL language in this context. APL was first a mathematical notation invented in 1957 by Pr. Kenneth E. Iverson at the Harvard University, later released as a book [5]. This language was the language of choice to perform complex calculations involving lists and matrices, being an “Array based language”. The usage of APL however necessitated special keyboards and special displays. This led Pr. Iverson to invent the J language, a successor to APL that used the ASCII character set only. The APL and J implementation of array processing as language elements had an influence on several other now well-known languages like MATLAB [10] and R [11]. The Arden Syntax can be considered an array-based language (in a reduced form, because it operates only on unidimensional arrays). As the authors explained it in paragraph 6.4 [1], they studied these functional languages (APL, J and ML) to avoid as much as possible the use of gotos and loops, and to define the 
                           where
                         construct of the language, that allows the selection of data and the application of weighting functions to categorical data. However, the syntax does not allow the user to define his own formulas, and instead a call to another MLM must be made, which is impractical for simple formulas. Nearly all languages nowadays allow the use of functions, and physicians use formulas regularly in spreadsheet calculations, for example. In the rationale document [1] there is no opinion that formally discourages the introduction of user-defined functions or subroutines; the authors just evoke this matter in paragraph 6.2: “Experience so far has shown that the lack of loops, gotos, and subroutines has not limited MLM authors”.

In the current standard, an MLM can be used as if it was a function, using the 
                              call
                            statement. This approach has several problems, some of them pointed very early by Musen [12].
                              
                                 -
                                 Fragmentation of the knowledge: the modular approach, when the called MLM can be reused by several MLMs, is the ideal case. However the called MLM, even if not written for sharing, but only to be used as a local formula, becomes nevertheless available to other MLMs. This pollutes the list of MLMs, and promotes duplication of code, as MLM authors will avoid the call to another MLM for just a simple formula. On the other hand, if for example institution X writes an MLM A that computes a simple formula, and institution Y uses it by calling it from its MLM B, any significant change to MLM A will break the inference made in MLM B. Having the formula directly inside MLM B will prevent this case. One of the initial objectives for the Arden Syntax was to have “modular independent knowledge bases” [1], where everything is included in the MLM.

The call to an MLM is an “impure” function call. The called MLM can make actions, before returning a value. The possible actions include modifying the patient database, possibly triggering other MLMs. This has also implications in the management of transactions: if the executions of MLMs happen in separate transactions, in the case of an error some database modifications might have been carried out by the called MLMs, inside successful transactions, therefore preventing the correct rollback to previous values.

The MLM's frame-like structure requires the use of an entire frame structure for every MLM, with the repetition of the information contained in the 
                                       library
                                     and 
                                       maintenance
                                     slots. This adds at least 20 additional lines; this is clearly an inadequate approach when the function is only 2 or 3 lines long, and from the same institution, for the same MLM.

Recursive calls (an MLM calling itself, either directly or indirectly via another MLM) are not forbidden in the current standard. This is acknowledged (in part) in the rationale document [1] at paragraph 6.2: “By letting MLMs call each other through nesting or by passing data through the clinical database, MLMs are Turing-complete, but this is not the focus of the Arden Syntax”.

The 
                              interface
                            keyword can be used to declare functions that can be called via the 
                              call
                            statement. However such calls are reserved to functions written in another programming language, system functions and libraries. Conceptually the call is the same as a call to another MLM, except that the possible actions are even less restricted than the actions that can be carried out by another MLM, as virtually anything that is possible in the system is allowed. Functions called by the 
                              interface
                            keyword are of course non-standard, and therefore discouraged for knowledge sharing.

The grammar of the Arden Syntax is currently written in Backus-Naur form (BNF) in the HL7 documents. As stated in the standard, the grammar can be entered in a “look ahead, left to right rightmost derivation” (LALR) parser. We used the CUP LALR parser from Princeton University (now maintained by the Technische Universität München) [13]. We entered each new production rule individually and ran the CUP tool to detect conflicts and either rewrote or removed any rule that caused a conflict (typically Shift/Reduce conflicts). We then ran the parser on several test constructs, and also on the examples given in this article.

@&#RESULTS@&#

We have taught the Arden Syntax regularly for five years to students of the master of science in medical informatics, using our teaching environment [14], and one frequent criticism was the lack of user-defined functions. The availability of user-defined functions is now an expected feature of a programming language, taught in programming courses [4]. Students are unaware of the matters of the Arden Syntax Rationale and expect this availability. The ability to call another MLM is perceived as a poor substitute for user-defined functions.

We propose a new 
                              functions
                            slot that centralizes the user-defined functions. This proposal describes the limited semantics that allow a safe usage of functions in MLMs. The main goal is to have user-defined functions that can be called in the same way that MLMs are called. The syntax should be simple, consistent with the rest of the Arden Syntax. It has already been discussed that a computing model based on functions can be made equivalent to a Turing-Complete language, so we choose to be careful in this respect, to avoid that the Arden Syntax becomes a complicated computer language. We eliminate side effects in functions to avoid the difficulties associated with them. The syntax must still be intuitive and easy to learn, so we make the definition of functions similar to the definitions of functions in Pascal and other imperative languages. The functions proposal here should be understood as a syntactical addition to improve the expression of formulas and abstractions, not as a way to write more complex MLMs. To enforce the simplicity of the syntax, this proposal does not allow elaborate functional constructs (recursion, high-order functions, lambda abstractions, folds). The detection of recursion will make Arden Syntax compilers harder to write, but safer to use for the MLM author. MLMs can still be called, and used as the main knowledge sharing mechanism. The current proposal is for small functions that don’t need to be separated from the statements that use them. It does not promote any systematic replacement of MLM calls by function calls.

A new slot named 
                              functions
                            is introduced. This slot will be located after the 
                              type
                            slot, and before the 
                              data
                            slot. In this slot, functions are declared using the following syntax:
                              
                                 
                                    
                                    
                                       
                                          
                                             function <name>([with <parameters>])
                                          
                                       
                                       
                                          
                                             
                                             <function-body>
                                          
                                       
                                       
                                          
                                             endfunction;
                                          
                                       
                                    
                                 
                              
                           
                        

The keyword 
                              function
                            is used, as in the Pascal language. Functions end with the 
                              endfunction
                            keyword, similarly to the other structured constructs of the Arden Syntax (e.g. 
                              endif
                           , 
                              enddo
                           , 
                              endswitch
                           ). The parameters are identifiers, separated by commas. The keyword 
                              with
                            is used to start the parameter list, to emphasize the difference with the other lists. The name of a function, like a variable in an MLM, cannot be a reserved word (the reserved words are listed in the Arden Syntax specification). A function can be called like an MLM, using the 
                              call
                            keyword, optionally followed by arguments. The function must be called with the correct number of arguments. When the function is executed, each parameter has the value of the corresponding argument that is provided by the call. The parameter is used in the function's body like a regular variable. Inside a function, results are returned using the 
                              return
                            keyword, just like an MLM can return results. A function can return a “list of lists”, exactly like a call to an MLM. Functions cannot be used directly inside an expression (this is postponed to future changes), but two constructs have been added in statements that use the 
                              where
                            and 
                              index
                            keywords, to allow the selection of elements using a user-defined function.

In order to keep the functions pure and easy to follow, and because functions are not subroutines, the variables that are declared inside the MLM (in the 
                              data
                            and 
                              logic
                            slot) are not accessible to user-defined functions. They have to be passed explicitly as arguments. When a variable is passed as an argument, it is passed by value, not by reference. This means that a copy of the variable is made first, so that the instructions in the function cannot modify the original value. One exception to this rule is the scope of resources, declared in the 
                              resources
                            slot. The resource terms are accessible to a user-defined function.

An additional keyword is proposed: 
                                 apply
                              . The goal is to apply a function that takes scalar arguments to a tuple composed of each successive member of one or more lists. This construct, used in many functional languages, expresses transformation on lists more concisely than a loop construct. The general form of the construct is
                                 
                                    
                                       
                                       
                                          
                                             
                                                apply <function_name> [with <arguments>] to
                                             
                                          
                                       
                                    
                                 
                              
                           

The function is called with n
                              +
                              p arguments, n being the number of lists the function is applied to, and p being the number of extra arguments introduced by the 
                                 with
                               keyword. All lists must be of the same length, or of length one, or null. The function is called with all the first elements of the lists, then again with all the second elements of the lists, and so on, for all elements of each list. If a list has only one element, this element is used for all calls, and if a list is null, null is used for all calls. The optional extra arguments, preceded by the 
                                 with
                               keyword, are passed as they are in each call, and can be used to pass values that are necessary for the calculation, but that are not in the lists that are processed. In the function's definition, they are placed after the n parameters that represent the elements of the n lists cited above. If the value returned by the function is a list, it is replaced with null. The result, after the 
                                 apply
                               operator has been executed, is a list that is the concatenation of the results of the calls. In short, the apply operator is an operator that accepts a “list of lists”, and returns a list as a result. The main advantage of this construct is that it avoids the use of an explicit loop construct to process lists that are read from the data slot. The same calculation can be carried out with an explicit loop that processes the lists; however all the verifications of the list lengths and the instructions to extract each value from each list would take many lines, and would be more subject to programming errors. The concept is similar to the 
                                 using
                               keyword that indicates which built-in function or construct must be used to sort the resulting list of an operation; however 
                                 apply
                               is syntactically closer to the 
                                 call
                               statement, as it accepts a “list of lists” (but different in that it can return only a list, not a “list of lists”). This construct needs special attention, as the first argument (or arguments) is supplied for each iteration, and the rest of the arguments (if any) is supplied explicitly, using the 
                                 with
                               keyword. This means that a reader that is not aware of the 
                                 apply
                               statement can be initially confused by the difference in the number of arguments between 
                                 apply
                               and 
                                 call
                              . Once this difference has been understood, the construct is easy to use. Two examples are given in Section 3.2.

The 
                                 where
                               operator has been changed to allow the usage of user-defined functions. As in the regular Arden Syntax, the 
                                 where
                               operator is used with a list, and it selects each element of the list that satisfies the given constraints. Here the constraints are expressed in the form of several calls to a user-defined function, each call returning either 
                                 true
                               or 
                                 false
                              . The call to the user-defined function is written with one less argument, as the first argument will be each element provided by the iteration on the list. This means that for a function that takes only one argument, it is sufficient to give only the name of the function:
                                 
                                    
                                       
                                       
                                          
                                             
                                                <expression> where it is <function_name>
                                             
                                          
                                       
                                    
                                 
                              
                           

When the function takes more arguments, a construct using the 
                                 with
                               keyword is used to specify the additional arguments:
                                 
                                    
                                       
                                       
                                          
                                             
                                                <expression> where with <arguments> it is <function_name>
                                             
                                          
                                       
                                    
                                 
                              
                           

Some examples are given in Section 3.2 to illustrate the constructs.

Like the 
                                 where
                               operator, the 
                                 index
                               operator has been changed to accept the use of functions. It returns the indices of the elements instead of the elements themselves, just as it does in the regular Arden Syntax. The binary operator form 
                                 index … from …
                               is used in all cases, to avoid ambiguities with any usage that would look like a function call in the 
                                 index … [of] …
                               form. For example, 
                                 index minimum
                               
                              (a,b,c) could be mistaken for a function call. This is also one of the reasons why we introduced the use of the 
                                 with
                               keyword in function calls. Furthermore this language construct always returns a list of indices, like most of the uses of 
                                 index
                               as a binary operator. With the use of functions, index can be seen as an n-ary operator, with n being the number of extra arguments passed to the function.

The 
                                 call
                               statement has been changed to accept calls to user-defined functions. This allows the assignment to multiple variables using the result of a user-defined function, just like with the result of a call to an MLM.

The 
                                 include
                               statement can be used to include the function definitions from another MLM. In case of naming conflicts, i.e. a function is defined in the MLM and also in the included MLM, the local definition always takes precedence. This precedence rule is the same as the one in the standard for objects and resource definitions. The reuse of functions via the 
                                 include
                               statement works well because functions are pure, and therefore don’t depend on any specific variable of the MLM that is not passed as a function argument. A function might depend on a declared resource, but as the resources of the MLM are also included by the 
                                 include
                               statement, the dependency is satisfied. It must be reminded that currently it is already possible to achieve this functionality in the current standard, only with a slightly more verbose syntax. When a call is made to the other MLM, using the regular call syntax, the first argument names the function to use, and a switch inside the logic slot executes the code that corresponds to the wanted function.

The new constructs were added to the grammar of the Arden Syntax v. 2.10, using the CUP LALR parser [13]. 22 production rules were added to the grammar. All the examples were parsed correctly. The constructs however have not yet been added to the runtime part of our Arden Syntax implementation [15].

We give a few examples to illustrate the new constructs. To avoid long listings, we only show abridged parts of some slots (functions, data and logic slots).

The first example declares a simple function that converts degrees Fahrenheit to degrees Celsius. The function works with scalar and list arguments. Two calls are made in the logic slot, one with a scalar argument, the second with a list argument, to demonstrate the function calls.
                           
                              
                                 
                                 
                                    
                                       
                                          functions:
                                    
                                    
                                       
                                          function fahrenheit_to_celsius(with F) return (F-32)/1.8; endfunction
                                       
                                    
                                    
                                       ;;
                                    
                                    
                                       
                                          logic: A:= 95;
                                    
                                    
                                       
                                          B:= call fahrenheit_to_celsius with A;//B will contain 35
                                       
                                    
                                    
                                       
                                          X:= 95, 104;
                                    
                                    
                                       
                                          Y:= call fahrenheit_to_celsius with X;//Y will contain (35, 40);
                                       
                                    
                                 
                              
                           
                        
                        
                           Example 1
                           Temperature conversion from degrees Fahrenheit to Celsius.

The following examples have no medical orientation; they just demonstrate how the function constructs are used.

A simple use of the 
                           where
                         operator with the name of a function:
                           
                              
                                 
                                 
                                    
                                       
                                          /* define “tall” as having a height above 180 cm */
                                       
                                    
                                    
                                       
                                          function tall(with HEIGHT) return HEIGHT > 180; endfunction;
                                       
                                    
                                    
                                       
                                          …
                                    
                                    
                                       
                                          Y:= (160, 170, 190, 186) where they are tall; // Y will be (190, 186)
                                       
                                    
                                 
                              
                           
                        
                     

Another use of the 
                           where
                         operator, with the name of a function, and an extra argument:
                           
                              
                                 
                                 
                                    
                                       
                                          /* define “taller” as having a height above threshold T */
                                       
                                    
                                    
                                       
                                          function taller(with HEIGHT, T) return HEIGHT > T; endfunction;
                                       
                                    
                                    
                                       
                                          …
                                    
                                    
                                       
                                          Y:= (160, 170, 190, 186) where with 165 they are taller;
                                       
                                    
                                    
                                       
                                          
                                          
                                          // Y will be (170, 190, 186)
                                       
                                    
                                 
                              
                           
                        
                     

An example of the 
                           index
                         operator, with the function “tall” introduced above:
                           
                              
                                 
                                 
                                    
                                       
                                          Y:= index tall from (160, 170, 190, 186); // Y will be (3, 4)
                                       
                                    
                                 
                              
                           
                        
                     

Another example of the 
                           index
                         operator, with the function “taller” introduced above:
                           
                              
                                 
                                 
                                    
                                       
                                          Y:= with 165 index taller from (160, 170, 190, 186); // Y will be (2, 3, 4)
                                       
                                    
                                 
                              
                           
                        
                     

A simple example of the 
                           apply
                         operator with a simple function and two lists:
                           
                              
                                 
                                 
                                    
                                       
                                          function fsq(with X, Y)
                                       
                                    
                                    
                                       
                                          
                                          if X < 0 then return Y; else return X * X + Y; endif;
                                       
                                    
                                    
                                       
                                          endfunction;
                                       
                                    
                                    
                                       …
                                    
                                    
                                       
                                          A:= -4,-2, 0, 2, 4;
                                       
                                    
                                    
                                       
                                          B:= 9, 8, 7, 6, 5;
                                       
                                    
                                    
                                       
                                          C:= apply fsq to A, B; // C will be (9, 8, 7, 10, 21)
                                       
                                    
                                 
                              
                           
                        
                     

A second example of the 
                           apply
                         operator with an extra argument, and the difference with 
                           call
                        :
                           
                              
                                 
                                 
                                    
                                       
                                          function fsq2(with X, Y, Z)
                                       
                                    
                                    
                                       
                                          
                                          if X < 0 then return Z; else return X * X + Y; endif;
                                       
                                    
                                    
                                       
                                          endfunction;
                                       
                                    
                                    
                                       …
                                    
                                    
                                       
                                          A:= -4,-2, 0, 2, 4;
                                       
                                    
                                    
                                       
                                          B:= 9, 8, 7, 6, 5;
                                       
                                    
                                    
                                       
                                          C:= apply fsq2 with 99 to A, B; // C will be (99, 99, 7, 10, 21)
                                       
                                    
                                    
                                       
                                          D:= call fsq2 with 2, 6, 99; // D will be 10
                                       
                                    
                                 
                              
                           
                        
                     

The same example of the 
                           apply
                         operator with an extra argument, and the equivalent direct 
                           call
                        s, for a better understanding of what the 
                           apply
                         operator does:
                           
                              
                                 
                                 
                                    
                                       
                                          function fsq2(with X, Y, Z)
                                       
                                    
                                    
                                       
                                          
                                          if X < 0 then return Z; else return X * X + Y; endif;
                                       
                                    
                                    
                                       
                                          endfunction;
                                       
                                    
                                    
                                       …
                                    
                                    
                                       
                                          A:= -4,-2, 0, 2, 4;
                                       
                                    
                                    
                                       
                                          B:= 9, 8, 7, 6, 5;
                                       
                                    
                                    
                                       
                                          C:= apply fsq2 with 99 to A, B; // C will be (99, 99, 7, 10, 21)
                                       
                                    
                                    
                                       
                                          // the following lines do the same calculation as the line above:
                                       
                                    
                                    
                                       
                                          C1:= call fsq2 with -4, 9, 99; // C1 will be 99
                                       
                                    
                                    
                                       
                                          C2:= call fsq2 with -2, 8, 99; // C2 will be 99
                                       
                                    
                                    
                                       
                                          C3:= call fsq2 with 0, 7, 99; // C3 will be 7
                                       
                                    
                                    
                                       
                                          C4:= call fsq2 with 2, 6, 99; // C4 will be 10
                                       
                                    
                                    
                                       
                                          C5:= call fsq2 with 4, 5, 99; // C5 will be 21
                                       
                                    
                                    
                                       
                                          C:= C1, C2, C3, C4, C5; // C will be (99, 99, 7, 10, 21)
                                       
                                    
                                 
                              
                           
                        
                     

The next example demonstrates the usage of a function as a selection criterion, using the 
                           where
                         construct, adapted for this purpose. It defines two functions, one that estimates the creatinine clearance using the Cockcroft–Gault formula [16], the other one defining a local binary criterion stating that the patient is in severe renal insufficiency or not, given the arguments that represent serum creatinine, body weight, age and sex, that will be assigned to the parameters CREAT, WEIGHT, AGE, SEX. To simplify the example, only the most recent weight is taken into account for the calculation. In a real MLM for each measure of serum creatinine, the weight of the patient at the time of the blood sample should be used to estimate the creatinine clearance.
                           
                              
                                 
                                 
                                    
                                       
                                          functions:
                                       
                                    
                                    
                                       
                                          
                                          
                                          /* estimate creatinine clearance, using:
                                       
                                    
                                    
                                       
                                          
                                          
                                          * CREAT in umol/l, WEIGHT in kg, AGE in years, SEX M/F/U
                                       
                                    
                                    
                                       
                                          
                                          
                                          * result is in ml/mn */
                                       
                                    
                                    
                                       
                                          
                                          function cockroft_gault(with CREAT, WEIGHT, AGE, SEX)
                                       
                                    
                                    
                                       
                                          
                                          
                                          if SEX = “M” then K:= 1.23; else K:= 1.04; endif;
                                       
                                    
                                    
                                       
                                          
                                          
                                          return K * WEIGHT * (140 - AGE) / CREAT;
                                       
                                    
                                    
                                       
                                          
                                          
                                          endfunction;
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                 
                                    
                                       
                                          /* return true if the estimated creatinine clearance is less than 30 ml/mn
                                       
                                    
                                    
                                       
                                          * (the threshold might vary across institutions) */
                                       
                                    
                                    
                                       
                                          function in_severe_renal_insufficiency(with CREAT, WEIGHT, AGE, SEX)
                                       
                                    
                                    
                                       
                                          
                                          CG:= call cockroft_gault with CREAT, WEIGHT, AGE, SEX;
                                       
                                    
                                    
                                       
                                          
                                          return CG < 30;
                                       
                                    
                                    
                                       
                                          endfunction;
                                       
                                    
                                    
                                       
                                          ;;
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                 
                                    
                                       
                                          data:
                                       
                                    
                                    
                                       
                                          
                                          CREAT_VALUES:= read {creatinine in umol/l}; // read all creatinine measures
                                       
                                    
                                    
                                       
                                          
                                          WEIGHT:= read latest {body_weight in kg};
                                       
                                    
                                    
                                       
                                          
                                          BIRTHDATE:= read latest {birthdate};
                                       
                                    
                                    
                                       
                                          
                                          SEX:= read latest {sex in MFU}; // sex “M” (male) “F” (female) “U” (undetermined)
                                       
                                    
                                    
                                       
                                          
                                          AGE:= (now - BIRTHDATE) / 1 year; // age in years
                                       
                                    
                                    
                                       
                                          ;;
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                 
                                    
                                       
                                          logic:
                                       
                                    
                                    
                                       
                                          
                                          /* The following have been retrieved using the data slot:
                                       
                                    
                                    
                                       
                                          
                                          * CREAT_VALUES: a list of creatinine measure values (in umol/l)
                                       
                                    
                                    
                                       
                                          
                                          * WEIGHT: the current weight of the patient, in kilograms
                                       
                                    
                                    
                                       
                                          
                                          * AGE: the current age of the patient, in years
                                       
                                    
                                    
                                       
                                          
                                          * SEX: the sex of the patient, M for male, F for female
                                       
                                    
                                    
                                       
                                          
                                          *
                                       
                                    
                                    
                                       
                                          
                                          * SEVERE_CREAT_VALUES is a list that will contain only the creatinine values
                                       
                                    
                                    
                                       
                                          
                                          * that indicate a severe renal insufficiency using the Cockroft-Gault formula
                                       
                                    
                                    
                                       
                                          
                                          * SEVERE_CREAT_VALUE_INDEXES is the same as SEVERE_CREAT_VALUES, except that it
                                       
                                    
                                    
                                       
                                          
                                          * contains the indices of the elements instead of their values
                                       
                                    
                                    
                                       
                                          
                                          */
                                       
                                    
                                    
                                       
                                          SEVERE_CREAT_VALUES:=
                                       
                                    
                                    
                                       
                                          
                                          CREAT_VALUES where with WEIGHT, AGE, SEX they are in_severe_renal_insufficiency;
                                       
                                    
                                    
                                       
                                          SEVERE_CREAT_VALUE_INDEXES:=
                                       
                                    
                                    
                                       
                                          
                                          with WEIGHT, AGE, SEX index in_severe_renal_insufficiency from CREAT_VALUES;
                                       
                                    
                                    
                                       …
                                    
                                    
                                       
                                          ;;
                                       
                                    
                                 
                              
                           
                        
                        
                           Example 2
                           A more elaborate example involving the WHERE and INDEX operators, with functions.

The following example defines a function that estimates the weight of a child, using his age in months or years [17], and a second function that compares this estimation to actual measures of the weight. This function uses 
                           if
                        s and thus cannot be used directly with list arguments. It is therefore better applied to the list of weights using the new 
                           apply
                         keyword.
                           
                              
                                 
                                 
                                    
                                       
                                          functions:
                                       
                                    
                                    
                                       
                                          
                                          /*
                                       
                                    
                                    
                                       
                                          
                                          * Weight “best guess” formula for weight estimation in children:
                                       
                                    
                                    
                                       
                                          
                                          * For Infants < 12 months: Weight (kg) = (age in months + 9)/2
                                       
                                    
                                    
                                       
                                          
                                          * For Children aged 1-5 years: Weight (kg) = 2 x (age in years + 5)
                                       
                                    
                                    
                                       
                                          
                                          * For Children aged 5-14 years: Weight (kg) = 4 x age in years.
                                       
                                    
                                    
                                       
                                          
                                          */
                                       
                                    
                                    
                                       
                                          function weight_best_gess(with AGE)
                                       
                                    
                                    
                                       
                                          
                                          if AGE < 1 year then
                                       
                                    
                                    
                                       
                                          
                                          
                                          return ((AGE / 1 month) + 9) / 2;
                                       
                                    
                                    
                                       
                                          
                                          elseif AGE < 5 years then
                                       
                                    
                                    
                                       
                                          
                                          
                                          return 2 * (AGE / 1 year) + 5;
                                       
                                    
                                    
                                       
                                          
                                          else
                                       
                                    
                                    
                                       
                                          
                                          
                                          return 4 * (AGE / 1 year);
                                       
                                    
                                    
                                       
                                          
                                          endif
                                       
                                    
                                    
                                       
                                          endfunction;
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                 
                                    
                                       
                                          function weight_deviation(with WEIGHT, BIRTHDATE)
                                       
                                    
                                    
                                       
                                          
                                          AGE:= time of WEIGHT - BIRTHDATE; //age at the time weight was measured
                                       
                                    
                                    
                                       
                                          
                                          ESTIMATED_WEIGHT:= call weight_best_guess with AGE;
                                       
                                    
                                    
                                       
                                          
                                          return WEIGHT - ESTIMATED_WEIGHT;
                                       
                                    
                                    
                                       
                                          endfunction;
                                       
                                    
                                    
                                       
                                          ;;
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                 
                                    
                                       
                                          data:
                                       
                                    
                                    
                                       
                                          
                                          WEIGHTS:= read {body_weights in kg}; //read all body weight measures
                                       
                                    
                                    
                                       
                                          
                                          BIRTHDATE:= read {birthdate}; //read birth date of patient
                                       
                                    
                                    
                                       
                                          ;;
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              
                                 
                                 
                                    
                                       
                                          logic:
                                       
                                    
                                    
                                       
                                          
                                          //calculate the list of differences between estimated and measured weights
                                       
                                    
                                    
                                       
                                          
                                          ESTIMATED_WEIGHT_DEVIATIONS:= apply weight_deviation with BIRTHDATE to WEIGHTS;
                                       
                                    
                                    
                                       …
                                    
                                    
                                       
                                          ;;
                                       
                                    
                                 
                              
                           
                        
                        
                           Example 3
                           Usage of a function that takes scalar arguments, and application to a list

Many constructs are possible with the introduction of functions. It is important to cite those other possible constructs, and to explain why these constructs have not been retained.

Functional languages are very powerful, and their constructs take time to master. This is however contradictory with the goals of the Arden Syntax, that is targeted toward users that have little or no formal computer science knowledge. An important feature of the Arden Syntax is that physicians with little training in computer science can understand a MLM. Also teaching the Arden Syntax should not be made more difficult. These principles were clearly expressed from the beginning [1]. A lot of more elaborate constructs in functional (and most modern general-purpose) programming languages serve in the processing of complex data structures (trees, lists of lists, value maps) that are deliberately absent of the Arden Syntax, so their inclusion in the standard would bring little benefit. For all these reasons we explain here why certain constructs found in other languages, which at first seem interesting, have been rejected from this proposal. Of course this could prove to be wrong, as the computer language knowledge is evolving with the population of physicians, especially the young physicians. However, it is safer to postpone the addition of a feature, when it becomes evident that it is needed, than to be forced to remove it when is found that it is not desirable.

In this proposal, calls are made by value. This means that a function operates on copies of the arguments. Other languages propose calls by reference. This means that a reference to the original object is passed to the function, therefore the function can modify the original value. For example if the argument is an object, the function could modify elements of the original object. This behavior is contrary to the notion of functions, where the only result is the returned value (or values). Also this modification is considered as a side-effect, which is something we want to prevent. A traditional objection to calls by value is that when lists or large structures are used as arguments, their copy on each call can be very inefficient. However optimizations are possible to detect the modification of a variable inside a function, so that the copy of a list or structure only takes place if such a modification is present.

Recursive function calls (i.e. a function calling itself directly or indirectly) is a powerful construct, but also hard to master correctly. There is a risk of infinite recursion that can have fatal consequences for the program's execution. Also there is little need for recursion in the Arden Syntax as the data has no recursive definition (except maybe for the special case of objects that can contain lists of objects). Direct recursive calls can be detected at compile time. The detection of indirect recursive calls at runtime is implementation dependent; one possible algorithm is to maintain a list of the functions that are currently active for an MLM execution (a list of names is sufficient), and to search this list before a call to a function. If the call targets a function that is already active, an error is raised. It must be noted however that recursion is already available with the existing MLM call mechanism.

First-class functions, or “functions as data”, is a mechanism where functions can be manipulated, assigned to variables, to list elements, to object elements, passed as arguments, and returned by functions. This can be done in this proposal in a limited fashion, in the same way that MLMs can be assigned to variables. First-class functions are also often used with anonymous functions (see Section 3.3.5), but we think that anonymous functions would complicate the language.

Anonymous functions are functions that have no name, only the function definition. This construct, also called “lambda functions” is used with the paradigm of “first-class functions”. Such a function can be passed like another value, and can for example be passed to another function in its declaration form as an argument, and used in the called function.

This would be something like:
                              
                                 
                                    
                                    
                                       
                                          
                                             functions: function dothreetimes(x,f)
                                          
                                       
                                       
                                          
                                             
                                             
                                             a:= call f with x;
                                          
                                       
                                       
                                          
                                             
                                             
                                             b:= call f with a;
                                          
                                       
                                       
                                          
                                             
                                             
                                             c:= call f with b;
                                          
                                       
                                       
                                          
                                             
                                             
                                             return c;
                                          
                                       
                                       
                                          
                                             
                                             endfunction;
                                          
                                       
                                       
                                          
                                             ;;
                                          
                                       
                                    
                                 
                              
                           
                           
                              
                                 
                                    
                                    
                                       
                                          
                                             logic:
                                          
                                       
                                       
                                          
                                             
                                             x:= call dothreetimes with 2, function (with x) return x*x; endfunction;
                                          
                                       
                                       
                                          
                                             
                                             //x would be 64 (2**(2*3))
                                          
                                       
                                       
                                          
                                             
                                             y:= call dothreetimes with 3, function (with x) return x+x; endfunction;
                                          
                                       
                                       
                                          
                                             
                                             //y would be 24 (3*(2**3), e.g. (((3+3)+(3+3))+((3+3)+(3+3))))
                                          
                                       
                                       
                                          
                                             ;;
                                          
                                       
                                    
                                 
                              
                           
                        

This is a powerful construct, which allows passing not only data, but also behavior to a function. However this notion is hard to learn for beginners, and is leading to code that can be hard to follow. We believe this paradigm doesn’t fit the goal of the Arden Syntax which is to keep modules simple.

This would change the Arden Syntax completely and transform it more into a general-purpose programming language, which is not the current purpose of the Arden Syntax.

In many old and new languages (e.g. Lisp, Haskell, Ruby), when a function returns, if there is no 
                              return
                            instruction, the last computed expression is returned as a return value.

This is too implicit for the Arden Syntax where all constructs (except variable types) are explicitly declared. Also when an MLM returns from a call, it returns a value using the 
                              return
                            instruction, so the two mechanisms should be kept identical for consistency.

Allowing side-effects in the Arden Syntax functions would enable read (and maybe write) access to the variables of the calling MLM. Most languages allow side effects in their functions; however this means that the result of the function's execution is less predictable, because a variable of the MLM accessed by the function may have been modified in other parts of the program, leading to a program execution that is hard to follow. Most languages allow side-effects for performance or implementation reasons; in typical MLMs most of the processing time is taken by database queries, so the small performance penalty taken in avoiding side effects is negligible.

A function name must be declared exactly once in this proposal. In most languages, a function can be defined multiple times if the number and/or types of parameters differ. In the Arden Syntax, variables are not explicitly typed, so defining a function by the type of its parameters is not feasible. However, we could allow the definition a function with the same name but different parameters, differing only by the number of parameters. This is used in most modern programming languages, but we think this may be confusing for less experienced users. Also, having unique function names makes it possible to use a variable to represent a function.

We could allow the call of functions using an extended syntax call <name_of_mlm>.<name_of_function> with <arguments>. This would however make the functions a unit of knowledge sharing, and the unit of knowledge sharing in the Arden Syntax is the MLM. This would also cause reference problems, because changes in the referenced function could cause the MLM to behave differently. There is however a way to reuse a function defined in another MLM, using the 
                              include
                            statement. The 
                              include
                            statement includes the definitions made in another MLM, so it would be naturally augmented by the functions defined inside the declared MLMs.

If subroutines were allowed in the Arden Syntax, they would be allowed to access and maybe modify variables directly. This is not a part of this proposal. Allowing subroutines has many drawbacks, the main one being to allow side effects (see Section 2.2). Subroutines are useful to decompose complex actions in simpler steps. However actions are not complicated in the Arden Syntax, so subroutines would bring little benefit. Also in the current standard, other MLMs can already be called to perform actions (but this is discouraged).

@&#CONCLUSIONS@&#

While changing the Arden Syntax can be a controversial matter, after such a long existence of the standard, the lack of user-defined functions is not in favor of the Arden Syntax when new users compare the Syntax with other current languages. A controlled introduction of functions could correct this negative experience, and enhance the expressiveness and clarity of the Arden Syntax, while preserving its design rationale. The introduction of functions can be made coherently with the philosophy of the language, and its grammar. We believe this would be a benefit for the sharing of knowledge written in the Arden Syntax. A detailed proposal will be submitted by the end of the year to the HL7 workgroup on Arden Syntax. The experts in the workgroup will then discuss if the addition of user-defined functions remains in the philosophy and goals of the Arden Syntax, and if it is a worthwhile addition to the standard.

@&#REFERENCES@&#

