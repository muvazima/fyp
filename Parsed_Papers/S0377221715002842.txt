@&#MAIN-TITLE@&#Ant colony optimization based binary search for efficient point pattern matching in images

@&#HIGHLIGHTS@&#


               
               
                  
                     
                        
                           
                           An ACOBSPPM algorithm is proposed to match an image with the stored images.


                        
                        
                           
                           The algorithm is shown to be efficient in terms of computation time and accuracy.


                        
                        
                           
                           The algorithm is shown to scale well when compared to binary search.


                        
                        
                           
                           The algorithm is efficient for matching identical and partial images.


                        
                     
                  
               
            

@&#KEYPHRASES@&#

Decision support systems

Image recognition

Point pattern matching

Ant Colony Optimization

Binary search

@&#ABSTRACT@&#


               
               
                  Point Pattern Matching (PPM) is a task to pair up the points in two images of a same scene. There are many existing approaches in literature for point pattern matching. However, the drawback lies in the high complexity of the algorithms. To overcome this drawback, an Ant Colony Optimization based Binary Search Point Pattern Matching (ACOBSPPM) algorithm is proposed. According to this approach, the edges of the image are stored in the form of point patterns. To match an incoming image with the stored images, the ant agent chooses a point value in the incoming image point pattern and employs a binary search method to find a match with the point values in the stored image point pattern chosen for comparison. Once a match occurs, the ant agent finds a match for the next point value in the incoming image point pattern by searching between the matching position and maximum number of point values in the stored image point pattern. The stored image point pattern having the maximum number of matches is the image matching with the incoming image. Experimental results are shown to prove that ACOBSPPM algorithm is efficient when compared to the existing point pattern matching approaches in terms of time complexity and precision accuracy.
               
            

@&#INTRODUCTION@&#

Point Pattern Matching (PPM) is an important problem in the field of computer vision and pattern recognition. Its major task is to pair up the points in two images of a same scene (Zhang, Zu, & Chnag, 2003). PPM can be classified as a complete match if there is a one to one mapping and an incomplete match otherwise. PPM is usually formulated as a geometric pattern recognition problem of point-sets, in which we seek to identify all correspondence(s) of a pattern set in a sampling set.

Some of the practical applications of PPM includes model-based tracking and recognition of a referenced template pattern in images, duplicate image identification, remotely sensed data with applications in civilian, agriculture, geology, oil and mineral exploration, astronomy, and military (Li, Meng, & Holstein, 2003).

Some of the algorithms existing in the literature for point pattern matching include Relaxation approach (Ranade & Rosenfeld, 1980), Fuzzy Relaxation approach (Ogawa, 1984), Alignment (Huttenlocher & Ullman, 1990), Randomized Alignment (Vinod & Ghose, 1993), 2D Cluster Approach (Irani & Raghavan, 1996), Nearest Neighbor search (Boxer, 1998), Probabilistic Sorted Nearest Neighbor approach and Input Sensitive algorithms (Aiger & Kedem, 2010). The drawback in these algorithms is that the computation complexity is high. Chew et al. (1997) have proposed the best known algorithm for rigid transformations for point pattern matching which requires O (m
                     3
                     n
                     2 log mn) time, where ‘m’ denotes the number of points in the model matched with the number of points ‘n’ in the scene. Van Wamelen, Li, and Iyengar (2004) have proposed Fast Expected Time (FET) algorithm which is a randomized algorithm for the alignment approach to model-based recognition. The running time of this algorithm is found to be O (n (log m)3/2), where ‘m’ is the number of points in the model matched with the number of points ‘n’ in the scene. Aiger and Kedem (2010) have proposed an Approximate Input Sensitive algorithm for point pattern matching. According to this algorithm, given point sets P and Q in the plane, the problem of point pattern matching is to determine whether P is similar to some portion of Q, where P may undergo transformations from a group G of allowed transformations. The running time of this algorithm is roughly O (n log n + km log n), where ‘m’ denotes the number of points in P matched with the number of points ‘n’ in Q. However, the drawback of the rigid transformation algorithm, FET and Input Sensitive algorithms is that the time complexity for point pattern matching is higher.


                     Kang, Efros, Hebert, and Kanade (2009) have proposed a Re-Search algorithm to cope with confusing patterns in an indoor environment. The drawback of this algorithm is that the images which are less similar to the query image are ranked higher when compared to the images which are more similar to the query image. To overcome the drawbacks in the existing approaches, an Ant Colony Optimization based binary search approach of point pattern matching has been proposed.

According to this approach, the point pattern of an image is obtained from the edges of an image. Each point pattern has a group of point values. Consider that the incoming image and the stored image point patterns are denoted as I and S, respectively. Then, I = {ip
                     1; ip
                     2; : : : ; ipm
                     } and S = {sq
                     1; sq
                     2; : : : ; sqn
                     }, where ipj
                      and sqk
                      represent the point values in the incoming image and stored image point pattern, respectively. The problem is to find whether the point values in I are similar to some or all of the point values in S. An Ant Colony Optimization based Binary Search Point Pattern Matching (ACOBSPPM) algorithm is proposed for matching the point values in I with the point values in S.

In ACOBSPPM algorithm, a group of ant agents equivalent to the number of stored image point patterns is chosen where each ant agent compares the point values in the incoming image point pattern with the point values of the stored image point pattern. The ant agents have a global value which is initially zero. Each ant agent deposits pheromone to match each point value of an incoming image point pattern with the point values of the compared stored image point pattern using a binary search method. The ant agent counts the number of point values in the incoming image point pattern matching with the compared stored image point pattern. This denotes the matching point value count. A threshold matching point value count is obtained by dividing the matching point value count by the total number of point values in the incoming image point pattern. If the threshold is greater than 5 percent, then the matching point value count of the ant agent is compared with the global value. If the matching point value count is greater than the global value, the ant agent updates the global value with the matching point value count and the corresponding stored image point pattern. The process is stopped if one of the ant agents has a threshold of 95 percent or above. If none of the ant agents obtains a threshold percent of 95, the process is stopped when all the ant agents complete the matching process. Thus the stored image point pattern corresponding to the highest matching point value count in the global value is the solution.

This paper is organized as follows. Section 2 describes the related work. Section 3 describes Ant Colony Optimization. Section 4 describes the point pattern generation. Section 5 describes Ant Colony Optimization based Binary Search Point Pattern matching for image matching. Section 6 describes the mathematical model of the system. Section 7 describes a case study. Section 8 explains the computational complexity. Section 9 discusses the experimental results. Section 10 compares ACOBSPPM algorithm with the existing point pattern matching algorithms. The conclusions are presented in Section 11.

@&#RELATED WORK@&#


                     Wayman, Jain, Maltoni, and Maio (2005) have addressed the minutiae matching problem as a point pattern matching problem and proposed an operation research solution by formulating the problem as a maximization problem. Stiglmayr and Klamroth (2009) had proposed a Branch and Bound Algorithm for Medical Image Registration and formulated the problem as a Quadratic Assignment Problem. Chui and Rangarajan (2003) had proposed a Robust Point Pattern Matching algorithm for Medical Image Registration and have formulated the point matching problem as a minimization problem.


                     Chew et al. (1997) have proposed the best known algorithm for rigid transformations for point pattern matching which requires O (m
                     3
                     n
                     2 log mn) time, where ‘m’ denotes the number of points in the model matched with the number of points ‘n’ in the scene. Aiger and Kedem (2007) have proposed a Geometric pattern matching for point sets in a plane. The runtime of this algorithm is O (n
                     2 log4 
                     mn), where m and n are the number of points in P and Q, respectively.


                     Van Wamelen et al. (2004) have proposed Fast Expected Time (FET) which is a randomized algorithm for the alignment approach to model-based recognition. The runtime of this algorithm is found to be O (n(log m)3/2) where ‘m’ is the number of points in the model matched with the number of points ‘n’ in the scene. Aiger and Kedem (2010) have proposed an Approximate Input Sensitive (AIS) algorithm for point pattern matching. The runtime of this algorithm is O (n log n + km log n), where ‘m’ denotes the number of points in the model matched with the number of points ‘n’ in the scene. However, the runtimes of rigid transformation algorithm, geometric pattern matching algorithm, FET and AIS algorithms were high.


                     Qin, Li, and Tian (2005) have proposed a modified greedy algorithm for Remote Imagery matching by epipolar constraint and local reliability constraint for Remote Sensing Image. However, the drawback is that the precision of the final estimation of the epipolar geometric depends tightly on those of the 2D matched points. To have a better estimation of the epipolar geometric, the accuracy of the matched points should be increased and there must be good distribution of the 2D matched points.
                  


                     Kang et al. (2009) proposed a Re-Search algorithm for image matching, that is designed to cope with self-repetitive structures and confusing patterns in the indoor environment. However, the drawback of this algorithm is that the images with a lower similarity to the query image were ranked higher than the images with a higher similarity to the query image.

Similarity of images can also be found using Pearson Correlation Coefficient, Spearman's rank correlation and Kendall's method. However, the computational complexity for images of size ‘n’ pixels for Pearson Correlation coefficient is of the order ‘n’. To locate a template in an image having N subimages, the time required is proportional to ‘Nn’. Also, the computational time becomes considerable for large values of ‘N’ and ‘n’. The computational complexity of Kendall's method is of the order ‘n
                     2’ and Spearman Rank Correlation Coefficient requires an order of n log2 
                     n for images of size ‘n’ pixels (Goshtasby, 2012).

To overcome these drawbacks, an Ant Colony Optimization based Binary Search Point Pattern Matching (ACOBSPPM) algorithm is proposed to match an incoming image with the stored images. The advantage is that, the runtime of ACOBSPPM algorithm is less when compared to rigid transformation algorithm for point pattern matching, geometric point pattern matching algorithm, FET and AIS algorithms. Also, it is shown that the precision accuracy of ACOBSPPM algorithm is higher when compared to Re-Search algorithm. Also, the computational complexity of ACOBSPPM algorithm is less when compared to the computational complexity of correlation coefficient methods.

A colony of ants denoting a set of computational concurrent and asynchronous agents moves through states of the problem corresponding to partial solutions of the problem to solve (Dorigo & Stutzle, 2005). They move by applying a stochastic local decision policy based on two parameters, called trails and attractiveness. By moving, each ant incrementally constructs a solution to the problem. When an ant completes a solution, or during the construction phase of the solution, the ant evaluates the solution and modifies the trail value on the components used in its solution. This pheromone information will direct the search of the future ants. Furthermore, an ACO algorithm includes two more mechanisms such as trail evaporation and, optionally, daemon actions. Trail evaporation decreases all trail values over time, in order to avoid unlimited accumulation of trails over some component. Daemon actions can be used to implement centralized actions which cannot be performed by single ant, such as the invocation of a local optimization procedure, or the update of global information to be used to decide whether to bias the search process from a non-local perspective (Maniezzo, Gambardella, & de Luigi, 2004).

The point pattern of an image is generated based on the edges of an image. Fig. 1 shows the generation of point pattern for an image.

The edges of an image are found and represented as a binary matrix. The values in the binary matrix are either ‘1’ or ‘0’. The value ‘1’ in the binary matrix denotes an edge of an image. Each edge is assigned a point value. To obtain a point value, the corresponding row position and column position of an edge denoted by the value ‘1’ in the binary matrix is concatenated. Thus all the edges in the binary matrix are traversed row wise and converted into point values. These point values collectively form the point pattern of an image. Consider the binary matrix representation of the edges of an image of size 5 × 5 shown in Fig. 2. The point pattern for this image is obtained as follows. The first edge in the image is found to be in the first row and second column. Thus the point value of this edge is formed by concatenating the row number ‘1’ and the column number ‘2’ giving a point value ‘12’. Similarly, the remaining edges in the binary matrix are converted into their point values forming the point pattern 12,13,15,21,22,25,32,33,34,41,43,55. The pseudocode for point pattern generation for an image is shown in Fig. 3
                     
                     .

An incoming image point pattern is matched with a group of stored images point patterns using an Ant Colony Optimization based Binary Search Point Pattern Matching algorithm. According to ACO based approach, a group of ant agents equivalent to the number of stored image point patterns is taken and each ant agent finds the matching stored image point pattern for the incoming image point pattern. The ant agents maintain a global value which is initially 0.

The ant agent moves along a path by depositing pheromone to reach the goal. Each ant agent has a tabu list denoting a dynamic memory structure. The tabu list has four positions namely the low, high, count and match positions. The low, high, count and match positions are initialized with the values 1, n, 0 and 1, respectively, where ‘n’ is the maximum number of point values in the compared stored image point pattern. The ant agent matches the point values from the incoming image point pattern with the point values in the stored image point pattern by depositing pheromone. The ant agent deposits pheromone by finding the mid position of the values stored in the low and high position. The pheromone deposition denotes the position of the point value in the stored image point pattern to be compared with the incoming image point value. The position of the point value to be compared, in the stored image point pattern represented by the pheromone deposition of the ant agent is considered as a potential solution for the problem. For instance, the pheromone deposition {8} represents that the point value at the eighth position in the stored image point pattern to be compared with the incoming image point value.

Energy value is a measure of how well a desired behavior is performed by an ant agent. The energy value denotes the attractiveness of the ant agent to reach the goal. The energy value of an ant agent is found by comparing the incoming image point value with the stored image point value denoted by the pheromone deposition. If the compared stored image point value is less than the incoming image point value, a match has not occurred and the energy value of the ant agent is +1 and the position denoted by the pheromone deposition is incremented by one and stored in the low position in the ant agent's tabu list. If the compared point value in the stored image point pattern is greater than the incoming image point value, a match has not occurred and the energy value of the ant agent is −1 and the position denoted by the pheromone deposition is decremented by one and stored in the high position in the tabu list of the ant agent. If a match has not occurred and the value in the low position is less than or equal to the value in the high position, the pheromone deposition evaporates and the ant agent moves to the next trail. The ant agent deposits pheromone and the process is continued to find a match for the same incoming image point value with the compared stored image point pattern.

If a match has not occurred and the value in the low position is greater than the value in the high position, it denotes the incoming image point value is not present in the stored image point pattern. Hence, the low position in the tabu list of the ant agent is updated with the value in the match position and high position is updated by the value ‘n’. The pheromone deposition evaporates and the ant agent moves to the next trail. The ant agent chooses the next incoming image point value and the process continues till all the point values in the incoming image point pattern are compared with the stored image point pattern.

If the compared stored image point value is equal to the incoming image point value, a match has occurred and the energy value of the ant agent is 0 and the position denoted by the pheromone deposition is incremented by 1 and stored in the low and match position in the tabu list of the ant agent. Also the high position in the tabu list of the ant agent is updated by the value ‘n’ and the count position is incremented by 1. The pheromone deposition evaporates and the ant agent moves to the next trail. The ant agent chooses the next point value in the incoming image point pattern for comparison with the point values in the stored image point pattern and the process continues till all the point values in the incoming image point pattern are compared with the stored image point pattern.

Let Ai
                      be the ant agent and let 
                        
                           SQ
                           
                              
                              i
                           
                           
                              
                              j
                           
                        
                      be the point value at the jth position of the stored image point pattern of the ith ant agent. i = 1, 2,…, no. of ant agents, j = 1, 2,…, n. Let IP denotes the point value of the incoming image point pattern to be compared with the stored image point pattern. The energy value of the ant agent is calculated using Eq. (1).

                        
                           (1)
                           
                              
                                 
                                    
                                    
                                    
                                       
                                          Energy
                                          
                                          
                                             (
                                             A
                                             i
                                             )
                                          
                                          =
                                          +
                                          1
                                          ,
                                          
                                          I
                                          P
                                          >
                                          S
                                          
                                             Q
                                             j
                                             i
                                          
                                          
                                          low
                                          
                                          position
                                          =
                                          j
                                          +
                                          1
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          Energy
                                          
                                          
                                          
                                             (
                                             A
                                             i
                                             )
                                          
                                          =
                                          0
                                          ,
                                          
                                          I
                                          P
                                          =
                                          S
                                          
                                             Q
                                             j
                                             i
                                          
                                          
                                          low
                                          
                                          position
                                          =
                                          j
                                          +
                                          1
                                          ,
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          high
                                          
                                          position
                                          =
                                          n
                                          ,
                                          match
                                          
                                          position
                                          =
                                          j
                                          +
                                          1
                                          ,
                                          
                                          count
                                          
                                          position
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          
                                          =
                                          count
                                          
                                          position
                                          +
                                          1
                                       
                                    
                                 
                                 
                                    
                                    
                                    
                                       
                                          Energy
                                          
                                          
                                             (
                                             A
                                             i
                                             )
                                          
                                          =
                                          −
                                          1
                                          ,
                                          
                                          
                                          I
                                          P
                                          <
                                          S
                                          
                                             Q
                                             j
                                             i
                                          
                                          
                                          high
                                          
                                          position
                                          =
                                          j
                                          −
                                          1
                                       
                                    
                                 
                              
                           
                        
                     
                  

The value stored in the count position in the tabu list of the ant agent denotes the number of point values of the incoming image point pattern matching with the point values of the compared stored image point pattern. This denotes the matching point value count. A threshold matching point value count is computed by dividing the matching point value count by the total number of point values in the incoming image point pattern. If the matching point value count percentage is greater than the threshold specified as 5 percent, the ant agent checks for the global value. If the global value is less than the matching point value count, the ant agent updates the global value with the matching point value count and the corresponding stored image point pattern. The purpose of setting a threshold percentage is that at least 5 percent of the values in the incoming image point pattern must be matched with the point values of the compared stored image point pattern.

The process is stopped when any of the ant agents has a threshold matching point value count percentage of 95 or above. If none of the ant agents obtains a threshold percent of 95, the process is stopped when all the ant agents complete the matching process. Thus, the stored image point pattern in the global value is the solution denoting the matching stored image for the incoming image. Fig. 4
                      shows the pseudocode for Ant Colony Optimization based Binary Search Point Pattern Matching algorithm.

The point pattern image matching problem is mathematically formulated as follows. Let S be the representation for the stored image point pattern. Let I represent the model of an incoming image point pattern to be matched with a stored image point pattern S.

                        
                           (2)
                           
                              
                                 S
                                 =
                                 
                                    {
                                    s
                                    
                                       q
                                       1
                                    
                                    ,
                                    s
                                    
                                       q
                                       2
                                    
                                    ,
                                    s
                                    
                                       q
                                       3
                                    
                                    ,
                                    …
                                    ,
                                    s
                                    
                                       q
                                       n
                                    
                                    }
                                 
                                 ,
                                 
                                 where
                                 
                                 s
                                 
                                    q
                                    k
                                 
                                 >
                                 0
                                 ,
                                 
                                 k
                                 =
                                 1
                                 
                                 to
                                 
                                 n
                              
                           
                        
                     
                     
                        
                           (3)
                           
                              
                                 I
                                 =
                                 
                                    {
                                    i
                                    
                                       p
                                       1
                                    
                                    ,
                                    i
                                    
                                       p
                                       2
                                    
                                    ,
                                    i
                                    
                                       p
                                       3
                                    
                                    ,
                                    …
                                    ,
                                    i
                                    
                                       p
                                       m
                                    
                                    }
                                 
                                 ,
                                 
                                 where
                                 
                                 i
                                 
                                    p
                                    j
                                 
                                 >
                                 0
                                 ,
                                 
                                 j
                                 =
                                 1
                                 
                                 to
                                 
                                 m
                              
                           
                        
                     Here, sqk
                      and ipj
                      denote the set of point values in the point pattern for the stored and the model of the incoming image as shown in Eqs. (2) and (3), respectively. The numbers of point values in the point pattern for the stored image and the incoming image are denoted by ‘n’ and ‘m’, respectively. The problem of point pattern matching is to find whether the point values in I matches with the some or all point values in S.

The point values sq
                     1,…, sqn
                      and ip
                     1,…, ipm
                      of the stored image point pattern and incoming image point pattern, respectively, are sorted in the ascending order and binary search is performed between sq
                     1 and sqn
                      to find a match for ip
                     1. Assume that the point value ip
                     1 of the incoming image point pattern matches with the point value sq
                     3 of the stored image point pattern at position 3 shown as M(ip
                     1) in Fig. 5
                     . Since the point values ip
                     1, ip
                     2, ip
                     3,…, ipm
                      are sorted in the ascending order, it is seen that the point values ip
                     2, ip
                     3,…, ipm
                      are greater than ip
                     1. Hence these point values will also be greater than sq
                     3 at position 3 and will lie at a position greater than 3. This implies that the point values ip
                     2, ip
                     3,…, ipm
                      lie between the values sq
                     4, sq
                     5,…, sqn
                      (between positions 4 and n). Hence a binary search is made between the values sq
                     4 and sqn
                      for the point values ip
                     2, ip
                     3,…, ipm
                      as shown in Fig. 5. Since the point values of the stored and incoming image point pattern are sorted in ascending order, the number of point values ‘n’ of the stored image point pattern eventually decreases for successive matches of the point values in the incoming image point pattern since each point value in the incoming image point pattern is compared with the point values in the stored image point pattern from the previous matching position in the stored image point pattern.

Let Zj
                      be a function which returns 1, if a point value (ipj
                     ) in the point pattern of the incoming image matches with a point value (sqk
                     ) in the point pattern of the stored image and returns 0 otherwise. Thus the count of the matching points in the incoming image point pattern I with the stored image point pattern S is formulated in Eq. (4).

                        
                           (4)
                           
                              
                                 
                                    ∑
                                    
                                       j
                                       =
                                       1
                                    
                                    m
                                 
                                 
                                    Z
                                    j
                                 
                                 ,
                              
                           
                        
                     where

                        
                           
                              
                                 
                                    
                                       
                                          
                                             Z
                                             j
                                          
                                          =
                                          1
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          
                                             p
                                             j
                                          
                                          
                                          ∈
                                          s
                                          q
                                          
                                          j
                                          =
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          m
                                       
                                    
                                 
                                 
                                    
                                       
                                          
                                             Z
                                             j
                                          
                                          =
                                          0
                                          ,
                                          
                                          ∀
                                          
                                          i
                                          
                                             p
                                             j
                                          
                                          
                                          ∉
                                          s
                                          q
                                          
                                          j
                                          =
                                          1
                                          ,
                                          2
                                          ,
                                          …
                                          ,
                                          m
                                       
                                    
                                 
                              
                           
                        
                     
                  

If there are ‘h’ stored image point patterns, the process of finding a match with the stored image point patterns is formulated as a maximization problem as shown in Eq. (5).

                        
                           (5)
                           
                              
                                 
                                    
                                       
                                          maximize
                                       
                                    
                                    
                                       
                                          
                                             1
                                             ≤
                                             l
                                             ≤
                                             h
                                          
                                       
                                    
                                 
                                 
                                    (
                                    
                                       
                                          ∑
                                          
                                             j
                                             =
                                             1
                                          
                                          m
                                       
                                       
                                          
                                             Z
                                             j
                                          
                                          
                                             (
                                             l
                                             )
                                          
                                       
                                    
                                    )
                                 
                              
                           
                        
                     
                  

This section deals with matching an incoming image point pattern with the stored image point patterns. To match an incoming image point pattern with the stored image point patterns, an ACO based point pattern matching approach is used. In this case study, an illustration is shown for matching an incoming image point pattern with 3 stored image point patterns. The point pattern values of the stored image point patterns are shown in Table 1
                     . The incoming image point pattern I has the point values {22, 25, 34}. To match an incoming image point pattern I with the stored image point patterns S1, S2 and S3, an Ant Colony Optimization based Binary Search Point Pattern Matching algorithm is invoked.

According to this approach, a group of ant agents is chosen to find the solution. Since there are 3 stored image point patterns, 3 ant agents namely ant agent-I, ant agent-II and ant agent-III are chosen. All the ant agents compare the incoming image point pattern I which has the point values {22, 25, 34} with one of the stored image point patterns. For instance, in this case study, ant agent-I, ant agent-II and ant agent-III compare the incoming image point pattern I with the stored image point pattern S1, S2 and S3, respectively. The ant agent maintains a global value which is initially zero. The tabu list of each ant agent has a low, high, count and match positions.

Consider the ant agent-I choosing the stored image point pattern S1 which has the point values {12,13,15,21,22,25,32,33,34,41,43,55,67,89,90} for comparison with the incoming image point pattern I which has the point values {22,25,34}. The first point value ‘22’ from the incoming image point pattern is chosen by the ant agent-I and searches for a match with the point values in the stored image point pattern by depositing pheromone. Initially the values in the low, high, count and match positions in the tabu list of the ant agent-I are 1, 15, 0 and 1, respectively. The ant agent-I deposits pheromone by choosing the mid position of the values stored in the low and high positions in its tabu list. Here, the mid position of the values 1 and 15 stored in the low and high positions, respectively, of the ant agent-I is 8. Thus the pheromone deposition of the ant agent-I in the first trail is 8. The point value ‘33’ at position 8 in the stored image point pattern S1 is compared with the point value ‘22’ of the incoming image point pattern. Since the point value ‘33’ in the stored image point pattern is greater than ‘22’, the energy value of the ant agent-I is −1 and the pheromone deposition of the ant agent-I is decremented by 1 and stored in the high position in the tabu list of the ant agent-I. Hence the value in the high position in the tabu list of the ant agent-I is 7. Since a match does not occur, and the value in the low position is less than the value in the high position, the pheromone deposition evaporates and the ant agent-I moves to the next trail. The ant agent-I deposits pheromone by choosing the mid value of the values 1 and 7 stored in the low and high positions, respectively, in its tabu list. The mid value 4 denotes the pheromone deposition. Since the point value ‘21’ at position 4 in the stored image point pattern is less than the incoming image point value ‘22’, the energy value of the ant agent is +1 and the pheromone deposition of the ant agent-I is incremented by 1 and stored in the low position in its tabu list. Since a match does not occur and the value in the low position is less than the value in the high position, the pheromone deposition evaporates and the ant agent-I moves to the next trail and the process is repeated. Table 2
                      shows ant agent-I matching the point values of the incoming image point pattern with the point values of the stored image point pattern S1.
                  

It is found from Table 2, that in trail 4, the pheromone deposition of the ant agent-I is ‘5’. The point value ‘22’ at position 5 in the stored image point pattern is equal with the incoming image point value ‘22’. Thus the energy value of the ant agent-I is 0 and the pheromone deposition is incremented by 1 and stored in the low and match position in the tabu list and the high position is updated with the maximum number of point values in the stored image. Also the count position is incremented by 1. Thus the values in the low, match, high and count positions in the tabu list of ant agent-I are 6, 6, 15 and 1, respectively. The ant agent-I moves to the next trail and the pheromone deposition evaporates. The ant agent-I chooses the next point values 25 and 34 from the incoming image point pattern and the process is repeated. It is observed from Table 2 that a match for the point values ‘25’ and ‘34’ is found by the ant agent-I in trail 8 and trail 10, respectively. Thus the count position of the ant agent-I is 3. Hence the matching point value count of the ant agent-I is 3. Since all the point values in the incoming image point pattern {22, 25, 34} are compared, the matching point value percentage is 100 which is greater than the threshold, i.e., 5 percent. Hence the matching point value count is compared with the global value. Since the matching point value count is greater than the global value 0, the ant agent-I updates the global value with the matching point value count 3 along with the corresponding stored image point pattern S1. Since the threshold value is greater than 95 percent, the solution is reached and the ant agent-II and ant agent-III matching the incoming image point pattern {22, 25, 34} with the stored image point patterns S2 and S3, respectively, stop the process. Table 3 shows the ant agents finding a match between the incoming image point pattern I with their corresponding stored image point patterns. It is observed from Table 3 that, since the matching point value count and threshold percent value of ant agent-II is 0, the ant agent-II does not update the global value. Since the matching point value count and the threshold percent value of ant agent-III is 2 and 66.7, respectively, the ant agent-III compares the matching point value count with the global value. Since the matching point value count is less than the global value, the ant agent-III does not update the global value. Thus the stored image point pattern S1 matches with the incoming image point pattern I.

The complexity of the system is studied in terms of number of comparisons to be made to match the point values in the incoming image point pattern with the point values in the stored image point pattern. The complexity of the system has been studied for several cases.

ACOBSPPM algorithm employs a binary search approach to match the incoming image point values with the stored image point values. For a worst case, none of the point values in the incoming image point pattern matches with the point values of the stored image point pattern. The complexity in finding a match for each point value in the incoming image point pattern is log n, where n is the total number of point values in the stored image point pattern. Thus the total number of comparisons to be made in a worst case is m log n where m is the number of point values in the incoming image point pattern. Table 4
                         shows the number of comparisons to be made for different number of point values in stored image patterns with that of the incoming image pattern.

ACOBSPPM algorithm uses a binary search approach to match the incoming image point values with the stored image point values. Since the point values are sorted in ascending order, it is sufficient that the ant agent searches for a match from the point of matching position in the stored image point pattern, for each successive incoming image point values. Assume that the numbers of point values in the stored image point pattern and incoming image point pattern are ‘n’ and ‘m’, respectively.

Assume that the match occurs only for x incoming image point values with the stored image point values. Assume that the matching positions are x1, y1 and z1, respectively. The number of searches for the nonmatching (m − x) incoming image point values is (m − x) log n. The number of comparisons for the first matching incoming image point value is log n. The number of comparisons for the second and third matching incoming image point values is log (n − x1) and log (n − y1), respectively. Thus the total number of comparisons will be

                           
                              (6)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             (
                                             m
                                             −
                                             x
                                             )
                                             log
                                             n
                                             +
                                             log
                                             n
                                             +
                                             {
                                             (
                                             log
                                             (
                                             n
                                             −
                                             x
                                             1
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             +
                                             
                                             log
                                             (
                                             n
                                             −
                                             y
                                             1
                                             )
                                             +
                                             ⋯
                                             (
                                             x
                                             −
                                             1
                                             )
                                             
                                                
                                                times
                                             
                                             }
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             =
                                             (
                                             m
                                             −
                                             x
                                             )
                                             log
                                             n
                                             +
                                             log
                                             n
                                             +
                                             log
                                             n
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             +
                                             
                                             log
                                             (
                                             1
                                             −
                                             x
                                             1
                                             /
                                             n
                                             )
                                             +
                                             log
                                             n
                                             +
                                             log
                                             (
                                             1
                                             −
                                             y
                                             1
                                             /
                                             n
                                             )
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (7)
                              
                                 
                                    
                                       
                                       
                                       
                                          
                                             =
                                             (
                                             m
                                             −
                                             x
                                             )
                                             log
                                             
                                             n
                                             +
                                             x
                                             log
                                             
                                             n
                                             +
                                             log
                                             (
                                             1
                                             −
                                             x
                                             1
                                             /
                                             n
                                             )
                                             +
                                             log
                                             (
                                             1
                                             −
                                             y
                                             1
                                             /
                                             n
                                             )
                                             +
                                             ⋯
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             =
                                             m
                                             log
                                             n
                                             −
                                             x
                                             log
                                             n
                                             +
                                             x
                                             log
                                             n
                                             +
                                             log
                                             (
                                             1
                                             −
                                             x
                                             1
                                             /
                                             n
                                             )
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             
                                             +
                                             log
                                             (
                                             1
                                             −
                                             y
                                             1
                                             /
                                             n
                                             )
                                             +
                                             ⋯
                                          
                                       
                                    
                                    
                                       
                                       
                                       
                                          
                                             =
                                             m
                                             log
                                             n
                                             +
                                             log
                                             (
                                             1
                                             −
                                             x
                                             1
                                             /
                                             n
                                             )
                                             +
                                             log
                                             (
                                             1
                                             −
                                             y
                                             1
                                             /
                                             n
                                             )
                                             +
                                             ⋯
                                          
                                       
                                    
                                 
                              
                           
                        
                        
                           
                              (8)
                              
                                 
                                    
                                    =
                                    m
                                    log
                                    
                                    n
                                    −
                                    
                                       {
                                       x
                                       1
                                       /
                                       n
                                       +
                                       x
                                       
                                          1
                                          ∧
                                       
                                       2
                                       /
                                       n
                                       …
                                       }
                                    
                                    −
                                    
                                       {
                                       y
                                       1
                                       /
                                       n
                                       +
                                       y
                                       
                                          1
                                          ∧
                                       
                                       2
                                       /
                                       n
                                       +
                                       ⋯
                                       }
                                    
                                 
                              
                           
                        
                     

Consider the case where the incoming image point pattern is similar to the stored image point pattern. This means that all point values in the incoming image point pattern match with the point values of the stored image point pattern. Thus the comparisons occur at position 1, 2, 3, …, n in the stored image point pattern. Thus the numbers of comparisons in a best case are given in Eqs. (9) and (10), respectively.

                           
                              (9)
                              
                                 
                                    log
                                    
                                    n
                                    +
                                    log
                                    (
                                    n
                                    −
                                    1
                                    )
                                    +
                                    log
                                    (
                                    n
                                    −
                                    2
                                    )
                                    +
                                    log
                                    (
                                    n
                                    −
                                    3
                                    )
                                    +
                                    ⋯
                                    +
                                    log
                                    (
                                    n
                                    −
                                    n
                                    )
                                 
                              
                           
                        
                        
                           
                              (10)
                              
                                 
                                    
                                    =
                                    log
                                    
                                    0
                                    +
                                    log
                                    
                                    1
                                    +
                                    log
                                    
                                    2
                                    +
                                    log
                                    
                                    3
                                    +
                                    ⋯
                                    +
                                    log
                                    n
                                    =
                                    log
                                    n
                                    !
                                 
                              
                           
                        
                     

@&#EXPERIMENTAL RESULTS@&#

The experiment is done for several scenarios. First, the experiment is done for matching incoming images with distinct stored images. Second, the experiment is repeated for patterns in an indoor environment.

The experiment is repeated for gray scale images, binary images and color images which are distinct. Fig. 6
                        (a) shows the gray scale images taken from SIPI image database (USC-SIPI Image Database, 2015). Fig. 6(b) shows the binary images taken from Lens image database (LEMS, 2015) and Fig. 6(c) shows the color images. The experiment is done in a system configuration of Intel® Pentium® CPU B960@2.20 gigahertz and 1954 megabytes RAM.

The experiment is done to prove the efficiency of ACOBSPPM algorithm to match the incoming images shown in Fig. 7
                        (a) and (b) with the stored images shown in Fig. 6(a)–(c). Fig. 7(a) shows the incoming images ‘Image1’, ‘Image2’, ‘Image3’ and ‘Image4’ which are compared with the images shown in Fig. 6(a)–(c) using an ACOBSPPM algorithm. It is seen from Fig. 7(a) that ‘Image1’, ‘Image2’, ‘Image3’ and ‘Image4’ match with the stored images ‘Moving Vehicle1’, ‘Airplane’, ‘Bird’ and ‘Logo’, respectively. It is also found that the incoming images are similar to the stored images.


                        Fig. 7(b) shows the incoming images ‘Image5’, ‘Image6’, ‘Image7’ and ‘Image8’ compared with the images shown in Fig. 6(a)–(c) using an ACOBSPPM algorithm. It is observed from Fig. 7(b) that ‘Image 5’ and ‘Image 6’ denote a rotated and blurred image, respectively, of the image ‘Lion’ shown in Fig. 6(c). ‘Image 7’ denotes a portion of the image ‘Lion’ shown in Fig. 6(c) and ‘Image8’ denotes a brighter image of the image ‘Snow’ shown in Fig. 6(c). It is seen from Fig. 7(b) that ‘Image5’, ‘Image6’, and ‘Image7’ match with the stored image ‘Lion’ and ‘Image8’ matches with the stored image ‘Snow’.

Thus the efficiency of ACOBSPPM algorithm is proved by showing its ability to identify the incoming images that are identical with the stored images, to identify incoming images that are similar to a portion of the stored image and to identify incoming images that are blurred, rotated or brighter than the stored images.


                        Table 5
                         shows the number of point values of each of the incoming images shown in Fig. 7(a) and (b) matching with each of the stored images in Fig. 6(a)–(c) using ACOBSPPM algorithm. The highest number of matching points for each incoming image with the stored image is highlighted. The corresponding stored image having the highest number of matching point denotes the matching image. For instance, it is seen from Table 5 that the point values of the point pattern of the incoming image ‘Image 1’ are matched with the point values of the point patterns of the stored images and the number of point values matching with each of the stored image is found. It is seen that the stored image ‘Moving Vehicle 1’ has the highest number of matching point values. Thus the stored image ‘Moving Vehicle 1’ is the matching image for the incoming image ‘Image1’ as shown in Fig. 7(a). This is repeated for all other incoming images and the matching stored images are found.


                        Fig. 8
                         shows the time taken for matching each of these incoming images with all the 8 stored images shown in Fig. 6(a)–(c) to identify the matching stored image. It is seen from the graph that the time increases with the increase in the number of point values in the incoming image pattern.

The efficiency of ACOBSPPM algorithm is explored for image matching problem in the context of typical indoor environments. Unlike outdoor environments, manmade indoor environments are usually full of self-repetitive structures and confusing patterns, which make them extremely challenging for image matching. In such cases, many of the images look similar at first but, upon closer inspection, the subtle details can be noticed that distinguish each image from the others. One such application of ACOBSPPM algorithm is locating people at a particular floor. Fig. 9
                         shows several images of an indoor environment. Fig. 10
                         shows a query image matched with the stored images shown in Fig. 9. It is seen from Fig. 10 that ‘Query Image1’ shows a person standing in a particular floor in an indoor environment. To locate the floor, ACOBSPPM matches ‘Query Image1’ with the stored images shown in Fig. 9 and identifies ‘Image 8’ as the matching one. Similarly ‘Query Image2’ has some modifications and is found to match with ‘Image 2’ from the stored images shown in Fig. 9. Though ‘Image1’ and ‘Image2’ in Fig. 9 look similar, it is shown in Fig. 10 that ACOBSPPM algorithm matches ‘Query Image2’ with the most similar image proving the accuracy of ACOBSPPM algorithm.

The robustness of ACOBSPPM algorithm is proved for several images taken from a CMU database (JISCT, 2015). These images are grouped into classes as shown in Fig. 11
                        . The edges for these images shown in Fig. 11 are obtained using a canny edge detection method and a point pattern is obtained for the same.

To prove the accuracy of ACOBSPPM algorithm, samples from each class shown in Fig. 11 were chosen to form the set of stored images. Another group of samples from each class shown in Fig. 11 were chosen to form the set of incoming images. The incoming images were matched with the set of stored images to find the matching image and the class of the incoming image. Table 6
                        a shows the names of the stored images. Table 6
                        b shows the incoming images along with the matching images and the corresponding class to which they belong. To prove that the images retrieved using ACOBSPPM algorithm are accurate, the correlation coefficients of the incoming and the stored images are found as shown in Fig. 12
                        . It is shown in Fig. 12 that the matching images are most accurate and strongly correlated with the incoming image.

A comparison of ACOBSPPM algorithm is made with point pattern matching approaches such as FET and Approximate Input Sensitive algorithms. Also, ACOBSPPM algorithm is compared with Re-Search algorithm for image matching. Since ACOBSPPM algorithm employs a binary search approach, a comparison is made with the binary search method.

A comparison of ACOBSPPM algorithm is made with Fast Expected Time algorithm.


                           Van Wamelen et al. (2004) have proposed Fast Expected Time (FET) algorithm which is a randomized algorithm for the alignment approach to model-based recognition. The complexity of this algorithm is found to be O(n(log m)3/2), where ‘m’ is the number of points in the model compared with the number of points ‘n’ in the scene. The drawback is that, when the points that are close neighbors are aligned, the accuracy of the resulting transformation depends heavily on the accurate alignment of the points.

According to ACOBSPPM algorithm, the alignment of the points need not be considered since no transformations are required. The complexity of the algorithm is O(m log n) for a worst case and 
                              
                                 
                                    (
                                    
                                       m
                                       log
                                       n
                                    
                                    )
                                 
                                 −
                                 
                                    {
                                    x
                                    1
                                    /
                                    n
                                    +
                                    x
                                    
                                       1
                                       
                                          2
                                          /
                                          n
                                       
                                    
                                    …
                                    }
                                 
                                 −
                                 
                                    {
                                    y
                                    1
                                    /
                                    n
                                    +
                                    y
                                    
                                       1
                                       
                                          2
                                          /
                                          n
                                       
                                    
                                    …
                                    }
                                 
                              
                            for an average case which is less than the complexity of Fast Expected Time algorithm. Here ‘m’ is the number of points in the model denoting the incoming image point pattern and ‘n’ is the number of points in a scene denoting the stored image point pattern.

A comparison with FET algorithm is done by choosing certain points for the images ‘Moving Vehicle1’ and ‘Airplane’. The images are converted into a point pattern and certain point values are chosen from the original point pattern of the image at random to form a model ‘m’ for each image. Similarly a scene ‘n’ is formed by choosing certain point values randomly from the original point pattern of each image. The experiment was repeated for different number of points in the scene. The number of points in the scene is such that it is 2, 4 and 8 times the number of points in the model. The time taken to find a match between the model and the scene is found for each image. The average time taken for comparing the model with the scene was studied and compared with that of the results reported in Van Wamelen et al. (2004) as shown in Table 7
                           . It is observed that the computation time for matching the model of the image with the scene of the image using ACOBSPPM algorithm is less when compared to FET algorithm.

A comparison of the computation time of ACOBSPPM algorithm with Approximate Input Sensitive algorithm is done for 5 real images used in Aiger and Kedem (2010) as shown in Fig. 13
                        .


                           Aiger and Kedem (2010) have proposed an Approximate Input Sensitive (AIS) algorithm for point pattern matching. According to this approach, given point sets P and Q in the plane, the problem of point pattern matching is to determine whether P is similar to some portion of Q, where P may undergo transformations from a group G of allowed transformations. For this, small subsets are efficiently extracted from Q that can be matched to a small subset of P. The runtime is proportional to the number k of these subsets. The runtime of this algorithm depends roughly linearly on the number of subsets k, in addition to an n log n factor. Thus the run time of this approximate matching algorithm is roughly O(n log n + km log n), where ‘m’ and ‘n’ are the number of points in P and Q, respectively.

According to ACOBSPPM algorithm, the point values in P denoting the incoming image point pattern are compared with point values in Q denoting the stored image point pattern. This method does not involve extraction of subsets from Q. The complexity of the algorithm is O (m log n) for a worst case where ‘m’ and ‘n’ are the number of points in P and Q, respectively. It is shown that the complexity of ACOBSPPM algorithm is less when compared to input sensitive algorithm. The edges for all the real images shown in Fig. 13 are obtained using a canny edge detection method and a point pattern is obtained for the same. The experiment was done by choosing 8, 16, 32, 64, 128, 256 and 512 point values randomly from the point pattern of the Real Image 1 and compared for a match with that of the point patterns of the real images shown in Fig. 13.


                           Fig. 14
                           (a)–(g) shows the comparison of the computation time reported for AIS algorithm (Aiger & Kedem, 2010) and ACOBSPPM algorithm to match several randomly selected points from Real Image 1 with other real images shown in Fig. 13. It is observed from the graphs in Fig. 14(a)–(g) that the computation time for matching images using ACOBSPPM algorithm is less when compared to AIS algorithm.


                           Kang et al. (2009) have proposed an image matching algorithm, named Re-Search that is designed to cope with self-repetitive structures and confusing patterns in the indoor environment. This algorithm explores the image matching problem in the context of typical indoor environments. Unlike outdoor environments, manmade indoor environments are usually full of self-repetitive structures and confusing patterns, which make them extremely challenging for image matching. In such cases, many of the images look similar at first but, upon closer inspection, the subtle details can be noticed that distinguish each image from the others.

This algorithm uses state-of-art image search techniques, and it matches a query image with a two-pass strategy. In the first pass, a conventional image search algorithm is used to search for a small number of images that are most similar to the query image. In the second pass, the retrieval results from the first step are used to discover features that are more distinctive in the local context. Thus Re-Search algorithm retrieves 8 images for the given query image.

ACOBSPPM algorithm uses an ACO based binary search approach for matching the point values of an incoming image point pattern with the point values of the stored image point pattern and returns the best matching image.

ACOBSPPM algorithm is tested on images in a manmade indoor environment. Fig. 15
                              (a) shows 11 clear images in an indoor environment. Fig. 15(b) shows the ranking of the matching images for ‘Query Image3’ using Re-Search algorithm based on these 11 images. Fig. 15(c) shows the best matching image for ‘Query Image3’ using ACOBSPPM algorithm based on these 11 images. It is observed from Fig. 15(c) that the matching image retrieved using ACOBSPPM algorithm is qualitatively more relevant when compared with the matching image at Rank 1 retrieved using Re-Search algorithm shown in Fig. 15(b). The qualitative relevance is proved by showing that the objects in the Query Image3 are more visible in the image retrieved using ACOBSPPM algorithm. To further prove the accuracy quantitatively, the correlation coefficients of Query Image 3 with the matching images retrieved using ACOBSPPM algorithm and Re-Search algorithm are found. It is found that the correlation coefficient of the Query Image 3 with the image retrieved using ACOBSPPM algorithm in Fig. 15(c) is 0.5977 whereas the correlation coefficient of the Query Image 3 with the image retrieved in the Rank 1 position using Re-Search algorithm in Fig. 15(b) is 0.2649. Thus the accuracy of ACOBSPPM algorithm is higher when compared to Re-Search algorithm both qualitatively and quantitatively.


                              Fig. 15(d) shows 11 confusing images in an indoor environment. Fig. 15(e) shows the ranking of the matching images for Query Image 4 using Re-Search algorithm based on the images in Fig. 15(d). Fig. 15(f) shows the matching image for Query Image4 using ACOBSPPM algorithm based on the images in Fig. 15(d). It is observed from Fig. 15(f) that the matching image retrieved using ACOBSPPM algorithm as well as the image at Rank 1 retrieved using Re-Search algorithm are similar and relevant to the Query Image4. To prove the accuracy quantitatively, the correlation coefficients of Query Image 4 with the matching images retrieved using ACOBSPPM algorithm and Re-Search algorithm are found. It is found that the correlation coefficient of the Query Image 4 with the image retrieved using ACOBSPPM algorithm in Fig. 15(f) is 0.3977 whereas the correlation coefficient of the Query Image 4 with the image retrieved in the Rank 1 position using Re-Search algorithm in Fig. 15(e) is 0.2537. This reveals that ACOBSPPM algorithm retrieves better images.

The accuracy of an algorithm is measured in terms of the relevant images retrieved. Precision accuracy measures the relevancy of the images retrieved using an algorithm. Since, ACOBSPPM algorithm retrieves only one image, the recall accuracy is not compared. Hence, the precision accuracy of ACOBSPPM and Re-Search algorithm is compared for the Query Image3 and Query Image4 as shown in Table 8
                              . It is observed from Fig. 15(c) and (f) that ACOBSPPM algorithm has one relevant image out of 1 retrieved image for both Query Image3 and Query Image4. It is observed from Fig. 15(b) and (e) that Re-Search algorithm has 6 relevant images out of the 8 retrieved images for Query Image3 and 7 relevant images out of the 8 retrieved images for Query Image4. Hence it is shown in Table 8 that the precision accuracy of ACOBSPPM algorithm is higher when compared to Re-Search algorithm proving that ACOBSPPM algorithm retrieves relevant images when compared to Re-Search algorithm.
                           


                        Qin et al. (2005) have proposed a modified greedy algorithm for Remote Imagery matching. According to this approach, image matching is done by epipolar constraint and local reliability constraint. However, the drawback is that the precision of the final estimation of the epipolar geometric depends tightly on those of the 2D matched points. To have a better estimation of the epipolar geometric, we should increase the accuracy of the matched points and there must be a good distribution of the 2D matched points.

ACOBSPPM algorithm matches point pattern of the incoming images with the point pattern in the stored images. Unlike, Remote Imagery matching approach, the accuracy of the matching points need not be increased.

ACOBSPPM algorithm is compared with point pattern matching using binary search.

According to binary search method, the entire set of point values in the stored image point pattern is searched for matching each point value in the incoming image point pattern. The number of comparisons for matching an incoming image point pattern with the point values in the stored image point pattern is m log n where ‘m’ is the total number of point values in the incoming image point pattern and ‘n’ is the total number of point values in the stored image point pattern.

According to ACOBSPPM algorithm, each time a match occurs between the point value of the incoming image point pattern and the point value in the stored image point pattern, the search for successive point values of the incoming image point pattern is done only from the position at which a match occurs in the stored image point pattern. This reduces the number of comparisons for finding a match between the incoming image point patterns with the stored image pattern. In the worst case, when none of the point values in the incoming image point pattern matches with the point values in the stored image point pattern, the number of comparisons to be made using ACOBSPPM algorithm is m log n. In the average case, where some of the point values in the incoming image point pattern matches with the point values in the stored image point pattern, the number of comparisons is 
                              
                                 
                                    (
                                    
                                       m
                                       log
                                       n
                                    
                                    )
                                 
                                 −
                                 
                                    {
                                    x
                                    1
                                    /
                                    n
                                    +
                                    x
                                    
                                       1
                                       
                                          2
                                          /
                                          n
                                       
                                    
                                    …
                                    }
                                 
                                 −
                                 
                                    {
                                    y
                                    1
                                    /
                                    n
                                    +
                                    y
                                    
                                       1
                                       
                                          2
                                          /
                                          n
                                       
                                    
                                    …
                                    }
                                 
                              
                           . In the best case, if the incoming image point pattern and the stored image point pattern are similar, the number of comparisons is log n!, where ‘n’ denotes the total number of point values in the stored image point pattern and ‘m’ denotes the total number of point values in the incoming image point pattern. Hence, it is observed that the average case and best case complexity of ACOBSPPM algorithm is less than the complexity of a binary search and the worst case complexity of ACOBSPPM algorithm is equal to binary search. Fig. 16(a)–(h) shows the number of comparisons using Binary search and ACOBSPPM algorithm for matching the incoming images shown in Fig. 7(a) and (b) with the stored images shown in Fig. 6(a)–(c). It is observed from the graph that the number of comparisons using ACOBSPPM algorithm is less when compared to binary search.

@&#CONCLUSIONS@&#

An Ant Colony Optimization based Binary Search Point Pattern matching algorithm is proposed to match an incoming image point pattern with the stored image point patterns. The algorithm is shown to be efficient when compared to FET and Approximate Input sensitive algorithm in terms of computation time. The ACOBSPPM algorithm is much better when compared to Re-Search algorithm both qualitatively and in terms of precision accuracy. Also ACOBSPPM algorithm is shown to have less number of comparisons when compared to binary search method. It is also shown that ACOBSPPM algorithm is efficient in matching the incoming images that are identical to the stored images. Also the efficiency of the algorithm is proved for matching the partial, rotated and blurred incoming images where only some point values of the incoming image point pattern matches with the point values of the stored image.

@&#REFERENCES@&#

